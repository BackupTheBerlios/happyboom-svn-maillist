<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Happyboom-svn] r349 - in haypo/hachoir: . trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/happyboom-svn/2005-December/index.html" >
   <LINK REL="made" HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r349%20-%20in%20haypo/hachoir%3A%20.%20trunk&In-Reply-To=%3C200512260331.jBQ3V8dG013847%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000253.html">
   <LINK REL="Next"  HREF="000254.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Happyboom-svn] r349 - in haypo/hachoir: . trunk</H1>
    <B>haypo at BerliOS</B> 
    <A HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r349%20-%20in%20haypo/hachoir%3A%20.%20trunk&In-Reply-To=%3C200512260331.jBQ3V8dG013847%40sheep.berlios.de%3E"
       TITLE="[Happyboom-svn] r349 - in haypo/hachoir: . trunk">haypo at berlios.de
       </A><BR>
    <I>Mon Dec 26 04:31:08 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000253.html">[Happyboom-svn] r348 - in haypo/hachoir: . plugins stream
</A></li>
        <LI>Next message: <A HREF="000254.html">[Happyboom-svn] r350 - haypo/hachoir/tags
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#297">[ date ]</a>
              <a href="thread.html#297">[ thread ]</a>
              <a href="subject.html#297">[ subject ]</a>
              <a href="author.html#297">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: haypo
Date: 2005-12-26 04:31:06 +0100 (Mon, 26 Dec 2005)
New Revision: 349

Added:
   haypo/hachoir/tags/
   haypo/hachoir/trunk/
   haypo/hachoir/trunk/AUTHORS
   haypo/hachoir/trunk/BUGS
   haypo/hachoir/trunk/COPYING
   haypo/hachoir/trunk/ChangeLog
   haypo/hachoir/trunk/INSTALL
   haypo/hachoir/trunk/Makefile
   haypo/hachoir/trunk/README
   haypo/hachoir/trunk/bmp_filter.xml
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/config.py
   haypo/hachoir/trunk/default.py
   haypo/hachoir/trunk/error.py
   haypo/hachoir/trunk/export.template
   haypo/hachoir/trunk/fallback/
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/format.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/log.py
   haypo/hachoir/trunk/mime.py
   haypo/hachoir/trunk/ogg_page.xml
   haypo/hachoir/trunk/plugin.py
   haypo/hachoir/trunk/plugins/
   haypo/hachoir/trunk/program.py
   haypo/hachoir/trunk/release.sh
   haypo/hachoir/trunk/stream/
   haypo/hachoir/trunk/text_handler.py
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/
   haypo/hachoir/trunk/user_filter.py
Removed:
   haypo/hachoir/AUTHORS
   haypo/hachoir/BUGS
   haypo/hachoir/COPYING
   haypo/hachoir/ChangeLog
   haypo/hachoir/INSTALL
   haypo/hachoir/Makefile
   haypo/hachoir/README
   haypo/hachoir/bmp_filter.xml
   haypo/hachoir/chunk.py
   haypo/hachoir/config.py
   haypo/hachoir/default.py
   haypo/hachoir/error.py
   haypo/hachoir/export.template
   haypo/hachoir/fallback/
   haypo/hachoir/filter.py
   haypo/hachoir/format.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/log.py
   haypo/hachoir/mime.py
   haypo/hachoir/ogg_page.xml
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/
   haypo/hachoir/program.py
   haypo/hachoir/release.sh
   haypo/hachoir/stream/
   haypo/hachoir/text_handler.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui/
   haypo/hachoir/user_filter.py
Log:
Create subdirectories trunk and tags.


Deleted: haypo/hachoir/AUTHORS
===================================================================
--- haypo/hachoir/AUTHORS	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/AUTHORS	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-Aur&#233;lien Jacobs - &lt;aurel AT gnuage.org&gt;
-Victor Stinner - &lt;victor.stinner AT haypocalc.com&gt;

Deleted: haypo/hachoir/BUGS
===================================================================
--- haypo/hachoir/BUGS	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/BUGS	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-- Set format to last chunk in a sub-filter doesn't work
-  (last chunk always converted to &quot;!%ss&quot; % padding)

Deleted: haypo/hachoir/COPYING
===================================================================
--- haypo/hachoir/COPYING	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/COPYING	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The &quot;Program&quot;, below,
-refers to any such program or work, and a &quot;work based on the Program&quot;
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and &quot;any
-later version&quot;, you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the &quot;copyright&quot; line and a pointer to where the full notice is found.
-
-    &lt;one line to give the program's name and a brief idea of what it does.&gt;
-    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  &lt;signature of Ty Coon&gt;, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.

Deleted: haypo/hachoir/ChangeLog
===================================================================
--- haypo/hachoir/ChangeLog	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/ChangeLog	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-2005-10-20
-	- Creation of the project

Deleted: haypo/hachoir/INSTALL
===================================================================
--- haypo/hachoir/INSTALL	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/INSTALL	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,12 +0,0 @@
-To use Hachoir, you will need:
-- Python 2.2 (maybe 2.3 ?) 
-  <A HREF="http://www.python.org/">http://www.python.org/</A>
-- pyGTK 2.0 with Glade support
-  <A HREF="http://www.pygtk.org/">http://www.pygtk.org/</A>
-- Python module &quot;magic&quot; (*)
-  (part of libmagic)
-- Python XML DOM extension (&quot;xml.dom.ext&quot;)
-
-(*) If you don't have python module magic, download:
-      <A HREF="http://www.haypocalc.com/perso/prog/hachoir/magic.so.bz2">http://www.haypocalc.com/perso/prog/hachoir/magic.so.bz2</A>
-    Decompress it and move it to Hachoir directory.

Deleted: haypo/hachoir/Makefile
===================================================================
--- haypo/hachoir/Makefile	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/Makefile	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-clean:
-	rm -f *.pyc plugins/*.pyc hachoir.gladep *.bak

Deleted: haypo/hachoir/README
===================================================================
--- haypo/hachoir/README	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/README	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,10 +0,0 @@
-Hachoir
-=======
-
-Hachoir is a Python program which parse binary streams. It uses plugins
-to support new (file) formats using MIME type detection to choose right
-plugin. It can do uncompress bz2, gzip and deflate streams.
-
-If you had problems to install it, read INSTALL file.
-
-Website: <A HREF="http://www.haypocalc.com/wiki/Hachoir">http://www.haypocalc.com/wiki/Hachoir</A>

Deleted: haypo/hachoir/bmp_filter.xml
===================================================================
--- haypo/hachoir/bmp_filter.xml	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/bmp_filter.xml	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,18 +0,0 @@
-&lt;?xml version='1.0' encoding='UTF-8'?&gt;
-&lt;user_filter hachoir_version='2005-10-27' id='bmp_file' description='Bitmap picture file (BMP)'&gt;
-  &lt;chunk format='!2s' id='header' description='Header (&quot;BM&quot;)'/&gt;
-  &lt;chunk format='&lt;L' id='file_size' description='File size (bytes)'/&gt;
-  &lt;chunk format='&lt;L' id='notused' description='Reseved'/&gt;
-  &lt;chunk format='&lt;L' id='data_start' description='Data start position'/&gt;
-  &lt;chunk format='&lt;L' id='header_size' description='Header size'/&gt;
-  &lt;chunk format='&lt;L' id='width' description='Width (pixels)'/&gt;
-  &lt;chunk format='&lt;L' id='height' description='Height (pixels)'/&gt;
-  &lt;chunk format='&lt;H' id='nb_plan' description='Number of plan (=1)'/&gt;
-  &lt;chunk format='&lt;H' id='bits_pixel' description='Bits per pixel'/&gt;
-  &lt;chunk format='&lt;L' id='compression' description='Compression method'/&gt;
-  &lt;chunk format='&lt;L' id='image_size' description='Image size (bytes)'/&gt;
-  &lt;chunk format='&lt;L' id='horizontal_dpi' description='Horizontal DPI'/&gt;
-  &lt;chunk format='&lt;L' id='vertical_dpi' description='Vertical DPI'/&gt;
-  &lt;chunk format='&lt;L' id='used_colors' description='Number of color used'/&gt;
-  &lt;chunk format='&lt;L' id='important_color' description='Number of import colors'/&gt;
-&lt;/user_filter&gt;

Deleted: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/chunk.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,377 +0,0 @@
-import struct, re, types
-import config
-from format import checkFormat, splitFormat, getFormatSize 
-from error import warning, error
-from tools import convertDataToPrintableString
-
-class Chunk(object):
-    def __init__(self, id, description, stream, addr, size, parent):
-        self._id = id
-        self.description = description
-        self._size = size
-        self._addr = addr
-        self._parent = parent
-        self._stream = stream
-        self.post_process = None
-        self.display = None
-
-    def clone(self):
-        raise Exception(&quot;%s doesn't implement clone() method!&quot; % self)
-
-    def postProcess(self):        
-        if self.post_process != None:
-            self.display = self.post_process(self)
-
-    def getFormat(self):
-        return self.__class__.__name__
-
-    def getSmallFormat(self):
-        return self.__class__.__name__
-
-    def update(self):
-        self.display = None
-        self.postProcess()
-
-    def getStream(self):
-        return self._stream
-
-    def getStringValue(self):
-        value = self.getDisplayData()
-        if type(value) == types.TupleType:
-            return &quot;(%s)&quot; % &quot;, &quot;.join( map(str,value) )
-        else:
-            return &quot;%s&quot; % value
-
-    def getRaw(self, max_size=None):
-        oldpos = self._stream.tell()
-        self._stream.seek(self.addr)
-        size = self._size
-        if max_size != None and max_size&lt;size:
-            size = max_size
-        data = self._stream.getN(size)
-        self._stream.seek(oldpos)
-        return data
-
-    def getValue(self, max_size=None):
-        return self.getRaw(max_size)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        else:
-            return self.getRaw(40)
-
-    def setParent(self, parent):
-        self._parent = parent
-    def getParent(self): return self._parent
-    def _setAddr(self, addr): self._addr = addr
-    def _getAddr(self): return self._addr
-    def _getSize(self): return self._size
-    def _getId(self): return self._id
-    def _setId(self, id):
-        if self._id == id: return
-        self._parent.updateChunkId(self, id)
-        self._id = id
-    addr = property(_getAddr, _setAddr)        
-    size = property(_getSize)        
-    id = property(_getId, _setId)
-    value = property(getValue)
-    raw = property(getRaw)
-    
-class FilterChunk(Chunk):
-    def __init__(self, id, filter, parent, parent_addr):
-        self._description = None
-        self.parent_addr = parent_addr
-        self._filter = filter
-        self._filter.filter_chunk = self
-        self._parent = None
-        Chunk.__init__(self, id, \
-            filter.getDescription(), filter.getStream(), filter.getAddr(), \
-            filter.getSize(), parent)
-        self._description = filter.getDescription()
-    
-    def clone(self, addr=None):
-        filter_copy = self._filter.clone(addr=addr)
-        # TODO: Is it always alright? (or use parent_addr = self.parent_addr)
-        parent_addr = addr
-        return FilterChunk(self.id, filter_copy, self.getParent(), parent_addr)
-    
-    def getFormat(self):
-        return self.__class__.__name__ + &quot; (%s)&quot; % self._filter.__class__.__name__
-
-    def getSmallFormat(self):
-        return self._filter.__class__.__name__
-
-    def update(self):
-        new = self._filter.clone()
-        if new != None:
-            self.setFilter(new)
-        Chunk.update(self)
-
-    def setFilter(self, filter):
-        self._filter = filter
-        self._filter.updateParent(self)
-    
-    def _setAddr(self, addr):
-        self._addr = addr
-        self._filter.setAddr(addr)
-    addr = property(Chunk._getAddr, _setAddr)        
-        
-    def _getSize(self):
-        return self._filter.getSize()
-    size = property(_getSize)        
-        
-    def getDisplayData(self):
-        return &quot;(...)&quot; 
-        
-    def getValue(self, max_size=None):
-        return self._filter
-    value = property(getValue)
-
-    def getFilter(self):
-        return self._filter
-
-    def _setId(self, id):
-        Chunk._setId(self, id)
-        self._filter.setId(id)
-    id = property(Chunk._getId, _setId)
-
-    def _getDescription(self):
-        return self._description
-    def _setDescription(self, description):
-        if self._description != None:
-            self._description = description
-            self._filter.setDescription(description)
-            self._parent.updateChunkDescription(self._id, description)
-    description = property(_getDescription, _setDescription)
-
-class StringChunk(Chunk):
-    regex_eol_nr = re.compile(&quot;[\n\r]&quot;)
-    names = {
-        &quot;C&quot;: &quot;c-string&quot;,
-        &quot;MacLine&quot;: &quot;mac line&quot;,
-        &quot;UnixLine&quot;: &quot;unix line&quot;,
-        &quot;AutoLine&quot;: &quot;line&quot;,
-        &quot;Pascal16&quot;: &quot;pascal16&quot;,
-        &quot;Pascal32&quot;: &quot;pascal32&quot;,
-        &quot;WindowsLine&quot;: &quot;windows line&quot;
-    }
-
-    def __init__(self, id, description, stream, str_type, parent, strip=None):
-        &quot;&quot;&quot;
-        Strip: if strip=None, call read text.strip()
-               if strip is a string, call read text.strip(self.strip)
-        &quot;&quot;&quot;
-        assert str_type in StringChunk.names
-        Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
-        self._str_type = str_type
-        self.eol = None
-        self._findSize()
-        self._cache_addr = None
-        self._cache_max_size = None
-        self._cache_value = None
-        self.strip = strip
-
-    def getFormat(self):
-        return StringChunk.names[self._str_type]
-
-    def getSmallFormat(self):
-        return StringChunk.names[self._str_type]
-
-    def _findSize(self):
-        self._stream.seek(self.addr)
-        if self._str_type == &quot;Pascal16&quot;:
-            self.length = self._stream.getFormat(&quot;!H&quot;)[0]
-            self._size = 2 + self.length
-            self.eol = &quot;&quot;
-            return
-        if self._str_type == &quot;Pascal32&quot;:
-            self.length = self._stream.getFormat(&quot;!L&quot;)[0]
-            self._size = 4 + self.length
-            self.eol = &quot;&quot;
-            return
-            
-        if self._str_type == &quot;AutoLine&quot;:
-            self._size = self._stream.searchLength(StringChunk.regex_eol_nr, True)
-            assert self._size != -1
-            self._stream.seek(self.addr + self._size-1)
-            self.eol = self._stream.getN(1)
-            if self.eol == &quot;\r&quot; and self._stream.read(1) == &quot;\n&quot;:
-                self.eol = &quot;\r\n&quot;
-                self._size = self._size + 1
-            self.length = self._size - len(self.eol)
-            return
-
-        if self._str_type == &quot;UnixLine&quot;:
-            self.eol = &quot;\n&quot;
-        elif self._str_type == &quot;WindowsLine&quot;:
-            self.eol = &quot;\r\n&quot;
-        elif self._str_type == &quot;MacLine&quot;:
-            self.eol = &quot;\r&quot;
-        else: 
-            self.eol = &quot;\0&quot;
-        self._size = self._stream.searchLength(self.eol, True)
-        assert self._size != -1
-        self.length = self._size - len(self.eol)
-        self._stream.seek(self.addr + self._size)
-        
-    def _read(self, max_size):
-        if self._cache_addr==self.addr and self._cache_max_size==max_size:
-            return self._cache_value
-        self._cache_addr = self.addr
-        self._cache_max_size = max_size
-
-        self._stream.seek(self.addr)
-        if self._str_type == &quot;Pascal32&quot;:
-            self._stream.seek(4,1)
-            size = self.length
-        elif self._str_type == &quot;Pascal16&quot;:
-            self._stream.seek(2,1)
-            size = self.length
-        else:
-            size = self._size - len(self.eol)
-        if max_size != None and max_size&lt;size:
-            text = self._stream.getN(max_size)+&quot;(...)&quot;
-        else:
-            text = self._stream.getN(size)
-        self._stream.seek(self.addr + self._size)
-        if self.strip != None:
-            if self.strip == True:
-                text = text.strip()
-            else:
-                text = text.strip(self.strip)
-        self._cache_value = text
-        return text
-
-    def update(self):
-        Chunk.update(self)
-        self._findSize()
-
-    def getValue(self, max_size=None):
-        return self._read(None)
-    value = property(getValue)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        else:
-            text = self._read(config.max_string_length)
-            return convertDataToPrintableString(text)
-        
-class FormatChunk(Chunk):
-    regex_sub_format = re.compile(r'\{([^}]+)\}')
-
-    def __init__(self, id, description, stream, addr, format, parent):
-        Chunk.__init__(self, id, description, stream, addr, None, parent)
-        self._format = None
-        self._doSetFormat(format)
-
-    def _doSetFormat(self, format):
-        if format == self._format:
-            return
-        self._format = format
-        self._is_string = self.isString()
-        if not self._is_string:
-            count = splitFormat(self._format)[1]
-            self._is_array = (count != 1)
-        else:
-            self._is_array = False
-        self._size = getFormatSize(self._format)
-        self._value = {}
-       
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self._addr
-        return FormatChunk(self.id, self.description, self._stream, addr, self._format, self._parent)
-
-    def _setAddr(self, addr):
-        self._addr = addr
-        self._value = {}
-    addr = property(Chunk._getAddr, _setAddr)
-
-    def getFormat(self):
-        return self.__class__.__name__ + &quot; (%s)&quot; % self._format
-
-    def getSmallFormat(self):
-        return self._format
-
-    def isString(self):
-        return self._format[-1] == &quot;s&quot;
-
-    def convertToStringSize(self, size):
-        self._doSetFormat(&quot;%us&quot; % size)
-
-    def setFormat(self, format, method, new_id=None, new_description=None):
-        &quot;&quot;&quot; Method:
-        - split =&gt; create new raw array if chunk is smaller
-        - rescan =&gt; if size changed, rescan chunks&quot;&quot;&quot;
-
-        # Check format
-        if not checkFormat(format):
-            raise Exception(&quot;Invalid FormatChunk format: \&quot;%s\&quot;!&quot; % format)
-        
-        # Check new size
-        size = getFormatSize(format)
-        if self._stream.getLastPos() &lt; (self.addr + size - 1):
-            raise Exception(&quot;Can't set chunk %s to format \&quot;%s\&quot;: size too big!&quot; % (self.id, format))
-
-        # Update format
-        old_size = self._size
-        self._doSetFormat(format)
-        new_size = self._size
-        diff_size = new_size - old_size
-
-        # Update id and description
-        old_id = self.id
-        if new_id != None:
-            new_id = self.getParent().getUniqChunkId(new_id)
-            self.id = new_id
-        old_description = self.description
-        if new_description != None:
-            self.description = new_description
-
-        # Update filter if needed
-        if diff_size != 0:
-            if method == &quot;split&quot; and diff_size &lt; 0:
-                self._parent.addRawChunk(self, old_id, -diff_size, old_description)
-            else:
-                self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description, truncate=True)
-        self._parent.updateFormatChunk(self)
-
-    def _getRawData(self, max_size=None):
-        oldpos = self._stream.tell()
-        self._stream.seek(self._addr)
-        if (max_size == None or self._size&lt;=max_size) or not self._is_string:
-            data = self._stream.getN(self._size, False)
-            self._stream.seek(oldpos)
-            return data, False
-        else:
-            data = self._stream.getN(max_size, False)
-            self._stream.seek(oldpos)
-            return data, True
-
-    def getRaw(self, max_size=None):
-        return self._getRawData(max_size)[0]
-    raw = property(getRaw)
-   
-    def getValue(self, max_size=None):
-        if max_size not in self._value:
-            data, truncated = self._getRawData(max_size)
-            if not truncated:
-                data = struct.unpack(self._format, data)
-                if not self._is_array:
-                    data = data[0]
-            else:
-                data = data + &quot;(...)&quot;
-            self._value[max_size] = data
-        return self._value[max_size]
-    value = property(getValue)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        data = self.getValue(config.max_string_length)
-        if type(data)==types.StringType:
-            return convertDataToPrintableString(data)
-        else:
-            return data 

Deleted: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/config.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,5 +0,0 @@
-max_string_length = 10
-max_hexa_length = 4096 
-max_ascii_length = 4096 
-debug = False
-verbose = False

Deleted: haypo/hachoir/default.py
===================================================================
--- haypo/hachoir/default.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/default.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,10 +0,0 @@
-from filter import Filter
-
-class EmptyFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;empty&quot;, &quot;Empty filter&quot;, stream, parent)
-
-class DefaultFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;default&quot;, &quot;Default filter&quot;, stream, parent)
-        self.read(&quot;data&quot;, &quot;%us&quot; % stream.getSize(), &quot;Data&quot;)

Deleted: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/error.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,33 +0,0 @@
-import os
-import config
-from log import log
-import ui.ui
-from tools import getBacktrace
-
-def warning(message):
-    if config.debug:
-        message = message + &quot;\n\n&quot; + getBacktrace()
-    log.warning(message)   
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_WARNING,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()
-
-def error(message, backtrace=None):
-    if config.debug:
-        message = message + &quot;\n\n&quot; + getBacktrace()
-    log.error(message)
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_ERROR,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()

Deleted: haypo/hachoir/export.template
===================================================================
--- haypo/hachoir/export.template	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/export.template	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,16 +0,0 @@
-&quot;&quot;&quot;
-Exported filter.
-
-Description:
-{description}
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-
-class MyFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;{id}&quot;, &quot;{description}&quot;, stream, parent)
-{chunks}
-
-#registerPlugin(MyFilter, &quot;&quot;)

Deleted: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/filter.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,689 +0,0 @@
-&quot;&quot;&quot;
-Base class for all splitter filters.
-&quot;&quot;&quot;
-
-import struct, re, sys, string, types
-import config
-import ui.ui as ui
-from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
-from error import error
-from tools import getBacktrace
-from format import getFormatSize
-
-class BasicFilter:
-    def __init__(self, id, description, stream, parent, addr):
-        self._id = id
-        self._description = description
-        self._stream = stream
-        self._parent = parent
-        self._addr = addr 
-        self._chunks_counter = {}
-        self._chunks_dict = {}
-
-    def updateParent(self, chunk): pass
-    def getId(self): return self._id
-    def setId(self, id): self._id = id
-    def getDescription(self): return self._description
-    def setDescription(self, description): self._description = description
-    def getAddr(self): return self._addr
-    def setAddr(self, addr): self._addr = addr
-    def getParent(self): return self._parent
-    def getStream(self): return self._stream
-    def purgeCache(self): pass
-    def updateChunkDescription(self, id, desc): pass
-    def __len__(self): return len(self._chunks_dict)
-
-    def getPath(self):
-        &quot;&quot;&quot;
-        Get path to the filter.
-        Example: &quot;grandparent &gt; parent &gt; item&quot;
-        &quot;&quot;&quot;
-        text = &quot;&quot;
-        current = self
-        while current != None:
-            if text != &quot;&quot;: text = &quot;/&quot; + text
-            text = current.getId() + text
-            current = current.getParent()
-        return &quot;/&quot;+text
-
-    def _getUniqChunkId(self, root, index):
-        if root in self._chunks_counter:
-            self._chunks_counter[root] = self._chunks_counter[root] + 1
-        else:
-            self._chunks_counter[root] = index
-        return self._chunks_counter[root]
-
-    def getUniqChunkId(self, id):
-        # No collision
-        if id not in self._chunks_dict and id[-2:] != &quot;[]&quot;:
-            return id
-
-        # Pattern like &quot;block[]&quot;
-        if id[-2:] == &quot;[]&quot;:
-            root = id[:-2]
-            start = 0
-            pattern = &quot;%s[%u]&quot;
-        else:
-            # Manage id collision
-            m = Filter.regex_chunk_uniq_id.match(id)
-            if m != None:
-                root = m.group(1)
-                start = int(m.group(2)) + 1
-            else:
-                root = id
-                start = 2
-            pattern = &quot;%s%u&quot;
-        if root in self._chunks_counter:
-            self._chunks_counter[root] = self._chunks_counter[root] + 1
-        else:
-            self._chunks_counter[root] = start 
-        return pattern % (root, self._chunks_counter[root])
-        
-    def hasChunk(self, id):
-        return id in self._chunks_dict
-
-    # --- Pure virtual methods -----------
-    def getSize(self): assert False
-    def __getitem__(self, chunk_id): assert False
-    def getChunk(self, chunk_id): assert False
-    def display(self): assert False
-
-class OnDemandFilter(BasicFilter):
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self._size = 0
-        self._chunks = []
-        self._chunks_cache = {}
-    
-    def updateChunkDescription(self, id, desc):
-        pos = self._chunks.index(id)
-        assert pos != -1
-        self._chunks_dict[id][1] = desc
-
-        info = self.displayChunkInfo(id)
-        ui.window.update_table(self, pos, *info)
-
-    def purgeCache(self):
-        if len(self._chunks_cache) != 0:
-            print &quot;Purge cache: destroy %s chunks&quot; % len(self._chunks_cache)
-        self._chunks_cache = {}
-        
-    def doReadChild(self, id, description, filter_class, *args):
-        id = self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        return self.getChunk(id)
-        
-    def readChild(self, id, description, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        
-    def readSizedChild(self, id, description, size, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, size, filter_class, *args)
-        
-    def readStreamChild(self, id, description, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, None, filter_class, *args)
-
-    def readSizedStreamChild(self, id, description, size, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, size, filter_class, *args)
-
-    def _readStreamChild(self, id, description, filter_stream, size, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
-        filter_addr = filter_stream.tell()
-        
-        if size == None:
-            filter = filter_class(filter_stream, self, *args)
-            description = filter.getDescription()
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            size = filter.getSize()
-            if config.verbose:
-                print &quot;%s: Instanciate filter %s&quot; % (self.getPath(), id)
-        else:
-            chunk = None
-
-        chunk_info = [id, description, addr, size, \
-                (filter_class, filter_stream, filter_addr, args), None, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        if chunk != None:
-            filter.updateParent(chunk)
-            self._chunks_cache[id] = chunk
-        self._size = self._size + size
-        self._stream.seek(addr + size)
-        return id
-
-    def doRead(self, id, format, description, post=None):
-        id = self.read(id, format, description, post)
-        return self.getChunk(id)
-
-    def read(self, id, format, description, post=None):
-        id = self.getUniqChunkId(id)
-        size = getFormatSize(format)
-        addr = self._stream.tell()
-        chunk_info = [id, description, addr, size, \
-                (FormatChunk, id, description, self._stream, addr, format, self,), post, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
-
-    def readString(self, id, format, description, post=None, strip=None):
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
-
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        size = chunk.size
-
-        chunk_info = [id, description, addr, size, \
-                (StringChunk, id, description, self._stream, format, self,), post, {&quot;strip&quot;: strip}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._chunks_cache[id] = chunk
-#        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
-
-    def displayChunkInfo(self, id):
-        info = self._chunks_dict[id]
-        chunk_class = info[4][0]
-        if issubclass(chunk_class, BasicFilter):
-            display = &quot;(...)&quot;
-            format = chunk_class.__name__
-        else:
-            chunk = self.getChunk(id)
-            display = chunk.getDisplayData()
-            format = chunk.getSmallFormat()
-        addr = info[2]
-        size = info[3]
-        return (None, addr, size, format, info[0], info[1], display)
-
-    def display(self):
-        ui.window.enableParentButton(self.getParent() != None)
-        ui.window.clear_table()
-        for id in self._chunks:
-            info = self.displayChunkInfo(id)
-            ui.window.add_table(*info)
- 
-    def getSize(self): return self._size
-
-    def _createInstance(self, id):
-        addr = self._chunks_dict[id][2]
-        desc = self._chunks_dict[id][4]
-        post = self._chunks_dict[id][5]
-        chunks_kw = self._chunks_dict[id][6]
-        oldpos = self._stream.tell()
-        self._stream.seek(addr)
-        if config.verbose:
-            print &quot;%s: Instanciate %s (of type %s)&quot; % (self.getPath(), id, desc[0].__name__)
-        if not issubclass(desc[0], BasicFilter):
-            chunk_class = desc[0]
-            chunk_args = desc[1:]
-            chunk = chunk_class(*chunk_args, **chunks_kw)
-            if post != None:
-                chunk.display = post(chunk)
-        else:
-            filter_stream = desc[1]
-            if filter_stream != self._stream:
-                filter_stream.seek(desc[2])
-            filter = desc[0] (filter_stream, self, *desc[3])
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            if filter.getDescription() != desc[1]:
-                self.updateChunkDescription(id, filter.getDescription())
-            filter.updateParent(chunk)
-        self._stream.seek(oldpos)
-        return chunk
-
-    def getChunk(self, id):
-        if id not in self._chunks_dict:
-            return None
-        if id not in self._chunks_cache:
-            self._chunks_cache[id] = self._createInstance(id) 
-        return self._chunks_cache[id]
-
-    def __getitem__(self, id):
-        assert id in self._chunks_dict
-        chunk = self.getChunk(id)
-        if isinstance(chunk.__class__, FilterChunk):
-            return chunk.getFilter()
-        else:
-            return chunk.value
-
-class Filter(BasicFilter):
-    regex_chunk_uniq_id = re.compile(&quot;^(.*?)([0-9]+)$&quot;)
-
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self.filter_chunk = None 
-        self._chunks = []
-        self._chunks_dict = {}
-        self._cache_valid = False
-        self._cache_size = None
-
-    def __getitem__(self, chunk_id):
-        return self.getChunk(chunk_id).getValue()
-
-    def clone(self, addr=None):
-        if self.__class__ == Filter:
-            return None
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        try:
-            new = self.__class__(self.getStream(), self.getParent())
-        except:
-            error(&quot;Error while clone class of type %s!&quot; % self.__class__)
-            raise
-        new.filter_chunk = self.filter_chunk
-        return new
-
-    def _deleteChunk(self, pos):
-        self._cache_valid = False
-        chunk = self._chunks[pos]
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)        
-        del self._chunks[pos]
-
-    def deleteChunk(self, chunk):
-        if len(self._chunks) &lt; 2:
-            error(&quot;Can't not delete the chunk %s (there is only one chunk).&quot; % chunk.id)
-            return            
-        chunk_size = chunk.size
-        pos = self._chunks.index(chunk)
-        self._deleteChunk(pos)
-        # Delete last chunk of a sub filter? It true, truncate the sub filter
-        truncate = (self.getParent() != None and pos == len(self._chunks))
-        self.rescanFromPos(pos, -chunk_size, truncate=truncate)
-        self.redisplay()
-
-    def getChunks(self):
-        return self._chunks
-
-    def updateChunkId(self, chunk, new_id):
-        if chunk.id == new_id: return
-        if new_id in self._chunks_dict or hasattr(self, new_id):
-            raise Exception(&quot;Chunk identifier \&quot;%s\&quot; already exist!&quot; % new_id)
-        if hasattr(self, chunk.id):
-            value = getattr(self, chunk.id)
-            delattr(self, chunk.id)
-            setattr(self, new_id, value)
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        self._chunks_dict[new_id] = chunk
-        
-    def addRawChunk(self, prev_chunk, id, size, description):
-        if prev_chunk != None:
-            addr = prev_chunk.addr + prev_chunk.size
-            chunk_pos = self._chunks.index(prev_chunk)+1
-        else:
-            addr = self.getAddr()
-            chunk_pos = len(self._chunks)
-        chunk = FormatChunk(id, description, self.getStream(), addr, &quot;!%ss&quot; % size, self)
-        self.appendChunk(chunk, position=chunk_pos)
-
-    def rescan(self, from_chunk, diff_size, new_id=None, new_description=None, truncate=False):
-        if from_chunk != None:
-            start = self._chunks.index(from_chunk)+1
-        else:
-            start = 0
-        self.rescanFromPos(start, diff_size, new_id, new_description, truncate)
-            
-    def _rescanUpdateSize(self, diff_size, new_id=None, new_description=None):
-        # Only process diff_size &lt; 0
-        if 0 &lt;= diff_size: return
-
-        # Get last chunk
-        if 0 &lt; len(self._chunks):
-            prev_chunk = self._chunks[-1]
-        else:
-            prev_chunk = None
-        
-        if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
-            # If last chunk is a FormatChunk, update it's size
-            size = prev_chunk.size - diff_size
-            prev_chunk.convertToStringSize(size)
-            self._cache_valid = False
-        else:
-            # Get id
-            if new_id != None:
-                id = new_id
-            else:
-                id = &quot;raw&quot;
-            id = self.getUniqChunkId(id)
-
-            # Get description
-            if new_description != None:
-                description = new_description
-            else:
-                description = &quot;&quot;
-
-            # Get size
-            if self.getParent() == None:
-                size = self._stream.getSize() - self.getSize() 
-            else:
-                size = -diff_size
-            self.addRawChunk(prev_chunk, id, size, description)
-
-    def _rescanUpdateChunks(self, start, prev_chunk):
-        self._cache_valid = False
-        pos = start
-        try:
-            for chunk in self._chunks[start:]:
-                # Update start address
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error(&quot;Exception while updating a filter:\n%s\n%s&quot; \
-                % (msg,getBacktrace()))
-            iter = len(self._chunks)-1
-            while pos&lt;=iter:
-                self._deleteChunk(iter)
-                iter = iter - 1
-
-    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate=False):
-        assert 0&lt;=start and start &lt;= len(self._chunks)
-        self._cache_valid = False
-        if 0&lt;start:
-            prev_chunk = self._chunks[start-1]
-        else:
-            prev_chunk = None
-
-        # Update chunks address
-        old_size = self.getSize()
-        self._rescanUpdateChunks(start, prev_chunk)
-        diff_size = diff_size + (self.getSize() - old_size)
-
-        # Update last chunk size if needed
-        if not truncate:
-            self._rescanUpdateSize(diff_size, new_id, new_description)
-            diff_size = 0
-               
-        if self.getParent() != None:
-            self.getParent().rescan(self.filter_chunk, diff_size)
-
-    def getLastPos(self):
-        if len(self._array) == 0: return self.getAddr()
-        last_chunk = self._array[-1]
-        return last_chunk.addr + last_chunk.size
-
-    def getSize(self):
-        if not self._cache_valid:
-            self._cache_valid = True
-            size = 0
-            for chunk in self._chunks:
-                size = size + chunk.size
-            self._cache_size = size
-        return self._cache_size
-
-    def addString(self, str_type, before_chunk):
-        if before_chunk != None:
-            pos = self._chunks.index(before_chunk)
-            addr = before_chunk.addr
-        else:
-            pos = len(self._chunks)
-            addr = self.getAddr()
-        stream = self.getStream()
-        stream.seek(addr)
-        id = self.getUniqChunkId(&quot;str&quot;)
-        str_chunk = StringChunk(id, &quot;String&quot;, stream, str_type, self)
-        self.appendChunk(str_chunk, position=pos)
-        str_chunk.postProcess()
-        before_chunk.addr = before_chunk.addr + str_chunk.size
-        before_chunk.convertToStringSize(before_chunk.size - str_chunk.size)
-        self.redisplay()
-        return str_chunk
-
-    def updateParent(self, chunk):
-        pass
-
-    def getChunk(self, chunk_id):
-        chunk = self._chunks_dict.get(chunk_id, None)
-        if chunk == None:
-            raise Exception(&quot;Filter \&quot;%s\&quot; has no chunk with id \&quot;%s\&quot;.&quot; \
-                % (self.getId(), chunk_id))
-        return chunk
-
-    def displayChunk(self, chunk):
-        type = chunk.getSmallFormat()
-        if isinstance(chunk, FilterChunk):
-            addr = chunk.parent_addr
-        else:
-            addr = chunk.addr
-        ui.window.add_table(None, addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
-
-    def redisplay(self):  
-        self.display()
-    
-    def display(self):  
-        ui.window.enableParentButton(self.getParent() != None)
-            
-        # Update table
-        ui.window.clear_table()
-        for chunk in self._chunks:
-            self.displayChunk(chunk)
-
-    def readField(self, id, description, delimiter):
-        lg = self._stream.searchLength(delimiter, False)
-        if lg == -1:
-            raise Exception(&quot;Delimiter \&quot;%s\&quot; not found for %s (%s)!&quot; % (delimiter, id, description))
-        self.read(id, &quot;!%us&quot; % lg, description) 
-        self.read(id+&quot;_delimiter&quot;, &quot;!%us&quot; % len(delimiter), &quot;Delimiter of %s&quot; % id) 
-
-    def searchEol(self, eol):
-        lg = self._stream.searchLength(eol, True)
-        if lg == -1:
-            return self._stream.getLastPos() - self._stream.tell()
-        else:
-            return lg
-
-    def readLine(self, id, description, eol=&quot;\n&quot;, fails_if_not_found=False, can_truncate=False):
-        lg = self.searchEol(eol)
-        self.read(id, &quot;!%us&quot; % lg, description, truncate=can_truncate)
-        line = getattr(self, id)
-        setattr(self, id, line[:-len(eol)])
-
-    def updateFormatChunk(self, chunk):
-        if chunk.id == None: return
-        self._cache_valid = False
-        data = chunk.getValue(config.max_string_length)
-        setattr(self, chunk.id, data)       
-
-    def appendChunk(self, chunk, position=None):
-        self._cache_valid = False
-        if position == None:
-            self._chunks.append(chunk)
-        else:
-            self._chunks.insert(position, chunk)
-        self._chunks_dict[chunk.id] = chunk
-
-    def readLimitedChild(self, id, size, filter_class, *args):
-        start = self._stream.tell()
-        limited = self._stream.createLimited(start, size)
-        chunk = self.readStreamChild(id, limited, filter_class, *args)
-        assert self._stream.tell() == (start+size)
-        return chunk
-        
-    def readStreamChild(self, id, stream, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        oldpos = self._stream.tell()
-        filter = filter_class(stream, self, *args)
-        filter.setId(id)
-        chunk = self.addFilter(id, filter, oldpos)
-        chunk.postProcess()
-        self._stream.seek(oldpos + chunk.size)
-        return chunk
-        
-    def readChild(self, id, filter_class, *args): 
-        return self.readStreamChild(id, self._stream, filter_class, *args)
-    
-    def addFilter(self, id, filter, addr): 
-        chunk = FilterChunk(id, filter, self, addr)
-        self.appendChunk(chunk)
-        filter.updateParent(chunk)
-        return chunk
-
-    def readArray(self, id, entry_class, description, end_func): 
-        &quot;&quot;&quot;
-        end_func: def isEnd(stream, array, last_filter)
-        &quot;&quot;&quot;
-        addr = self._stream.tell()
-        filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
-        chunk = self.addFilter(id, filter, addr)
-        chunk.postProcess()
-        return chunk
-    
-    def readString(self, id, format, description, post=None, strip=None):
-        &quot;&quot;&quot; Returns chunk &quot;&quot;&quot;
-        id = self.getUniqChunkId(id)
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-    
-    def read(self, id, format, description, post=None):
-        &quot;&quot;&quot; Returns chunk &quot;&quot;&quot;
-        id = self.getUniqChunkId(id)
-        chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-
-    def __str__(self):
-        return &quot;Filter(%s) &lt;id=%s, description=%s&gt;&quot; % \
-            (self.__class__, self.getId(), self.getDescription())
-
-    def addNewFilter(self, chunk, id, size, desc):
-        chunk.setFormat(&quot;%us&quot; % size, &quot;split&quot;, id, desc)
-        self.convertChunkToFilter(chunk)
-
-    def convertFilterToChunk(self, chunk):
-        # Create new format chunk
-        filter = chunk.getFilter()
-        id = self.getUniqChunkId(filter.getId())
-        new_chunk = FormatChunk(id, filter.getDescription(), filter.getStream(), filter.getAddr(), &quot;!%us&quot; % filter.getSize(), self)
-
-        # Delete old chunk
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)
-
-        # Assign new chunk
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[id] = new_chunk
-        setattr(self, id, chunk.getValue(40))
-        self.redisplay()
-        return new_chunk 
-
-    def convertChunkToFilter(self, chunk):
-        # Create new filter
-        stream = self.getStream()
-        stream.seek(chunk.addr)
-        filter = Filter(chunk.id, chunk.description, stream, self)
-        chunk.setParent(filter)
-        filter.appendChunk(chunk)
-        
-        # Create new chunk and add it into self 
-        new_chunk = FilterChunk(chunk.id, filter, self, chunk.addr)
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[chunk.id] = new_chunk
-        self.redisplay()
-        return filter
-
-class ArrayFilter(Filter):
-    def __init__(self, id, description, stream, parent, entry_class, end_func):
-        Filter.__init__(self, id, description, stream, parent)
-        self._entry_class = entry_class
-        self._end_func = end_func
-        self._read()
-
-    def _read(self):
-        self._array = []
-        nb = 0
-        last_filter = None
-        while not self._end_func(self._stream, self._array, last_filter):
-            chunk_id = &quot;%s[%u]&quot; % (self.getId(), nb)
-            addr = self._stream.tell()
-            filter = self._entry_class(self._stream, self)
-            filter.setId(chunk_id)
-            nb = nb + 1
-            chunk = FilterChunk(chunk_id, filter, self, addr)
-            self._array.append( chunk )
-            self.appendChunk(chunk)
-            last_filter = filter
-
-        for chunk in self._array:
-            chunk.getFilter().updateParent(chunk)
-        if 1&lt;nb:
-            self.setDescription( &quot;%s (%s items)&quot; % (self.getDescription(), nb))
-        else:
-            self.setDescription( &quot;%s (%s item)&quot; % (self.getDescription(), nb))
-
-    def getArray(self):
-        return self._array
-    
-    def _deleteChunk(self, pos):
-        Filter._deleteChunk(self, pos)
-        if pos &lt; len(self._array):
-            del self._array[pos]
-
-    def update(self):
-        self._cache_valid = False
-        prev_chunk = None
-        pos = 0
-        try:
-            for chunk in self._array:
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error(&quot;Exception while updating an ArrayFilter:\n%s&quot; % msg)
-            chunk = self._array[pos]
-            addr = chunk.addr
-            size = self.getLastPos() - addr
-            del self._array[pos:]
-            if size != 0:
-                chunk = FormatChunk(&quot;raw&quot;, &quot;Raw data&quot;, chunk.getStream(), addr, &quot;!%us&quot; % size, self)
-                self._array.append(chunk)
-
-    def __len__(self):
-        return len(self._array)
-
-    def __getitem__(self, index):
-        return self._array[index]
-
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        new = ArrayFilter( self.getId(), self.getDescription(), \
-            self.getStream(), self.getParent(), self._entry_class, self._end_func)
-        new.filter_chunk = self.filter_chunk
-        return new
-
-class DeflateFilter(Filter):
-    def __init__(self, stream, parent, bz_stream, size, filter, *args):
-        Filter.__init__(self, &quot;deflate&quot;, &quot;Deflate&quot;, bz_stream, parent)
-        self._addr = stream.tell()
-        self.readChild(&quot;data&quot;, filter, *args)
-        self._compressed_size = size
-
-    def getSize(self):
-        return self._compressed_size

Deleted: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/format.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,40 +0,0 @@
-import re, struct
-
-_regex_format1 = re.compile(&quot;^[!&lt;&gt;]?(?:[0-9]+|\{[<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">a-z at _</A>]+\})?[BHLbhscfd]$&quot;)
-_regex_format2 = re.compile(&quot;^([!&lt;&gt;]?)((?:[0-9]+|\{[<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">a-z at _</A>]+\})?)([BHLbhscfd])$&quot;)
-_format_size_cache = {}
-
-def _getFormatCache(format):
-    global _format_size_cache
-    if format not in _format_size_cache:
-        assert checkFormat(format)
-        endian, count, type = _doSplitFormat(format)
-        size = count * struct.calcsize(type)
-        _format_size_cache[format] = (endian, count, type, size)
-    return _format_size_cache[format]   
-
-def getFormatSize(format):
-    cache = _getFormatCache(format)
-    return cache[3]   
-
-def checkFormat(format):
-    m = _regex_format1.match(format)
-    return m != None
-
-def splitFormat(format):
-    cache = _getFormatCache(format)
-    return cache[:3]   
-
-def _doSplitFormat(format):
-    m = _regex_format2.match(format)
-    assert m != None
-    endian = m.group(1)
-    count = m.group(2)
-    type = m.group(3)
-    if endian == &quot;&quot;:
-        endian = &quot;!&quot;
-    if count != &quot;&quot;:
-        count = long(count)
-    else:
-        count = 1
-    return (endian, count, type,)

Deleted: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/hachoir.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,137 +0,0 @@
-#!/usr/bin/python
-&quot;&quot;&quot;
-Hachoir: tool to split a binary file into human readable data.
-Because it's written in Python, it would be easy to write new plugins
-(supports new file format).
-
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-import sys, os, re, traceback
-import config
-from program import PROGRAM, VERSION, WEBSITE
-from log import log
-from error import error
-from hachoir_class import Hachoir
-import ui.ui as ui
-
-def usage(defval):
-    print &quot;%s version %s&quot; % (PROGRAM, VERSION)
-    print &quot;%s\n&quot; % WEBSITE
-    print &quot;Usage: %s [options] file&quot; % (sys.argv[0])
-    print &quot;&quot;
-    print &quot;Options:&quot;
-    print &quot;\t--script file.py  : Load python script&quot;
-    print &quot;\t--no-ui           : Don't load user interface&quot;
-    print &quot;\t--use-profiler    : Use profiler&quot;
-    print &quot;\t--version         : Show the program version&quot;
-    print &quot;\t--verbose         : Activate verbose mode&quot;
-    print &quot;\t--help            : Show this help&quot;
-    print &quot;\t--debug           : Enable debug mode (eg. display backtrace)&quot;
-
-def parseArgs(val):
-    import getopt
-    def_val = val.copy()
-    
-    try:
-        short = &quot;&quot;
-        long = [&quot;verbose&quot;, &quot;help&quot;, &quot;version&quot;, &quot;script=&quot;, &quot;no-ui&quot;, &quot;debug&quot;, &quot;use-profiler&quot;]
-        opts, args = getopt.getopt(sys.argv[1:], short, long)
-    except getopt.GetoptError:
-        usage(def_val)
-        sys.exit(2)
-   
-    if 1 &lt; len(args):
-        usage(def_val)
-        sys.exit(2)
-    if len(args) == 1:
-        filename = args[0]
-    else:
-        filename = None
-        
-    for o, a in opts:
-        if o == &quot;--help&quot;:
-            usage(def_val)
-            sys.exit()
-        elif o == &quot;--version&quot;:
-            print &quot;%s version %s&quot; % (PROGRAM, VERSION)
-            sys.exit()
-        elif o == &quot;--no-ui&quot;:
-            val[&quot;load_ui&quot;] = False
-        elif o == &quot;--script&quot;:
-            val[&quot;script&quot;] = a
-        elif o == &quot;--verbose&quot;:
-            config.verbose = True
-        elif o == &quot;--debug&quot;:
-            config.debug = True
-        elif o == &quot;--use-profiler&quot;:
-            val[&quot;use_profiler&quot;] = True
-    return (val, filename,)
-
-def main():
-    try:        
-        print &quot;%s version %s&quot; % (PROGRAM, VERSION)
-        print &quot;%s\n&quot; % WEBSITE
-    
-        import imp
-        plugins_dir = os.path.join(os.path.dirname(__file__), &quot;plugins&quot;)
-        plugins_files = os.listdir(plugins_dir)
-        file_py = re.compile(&quot;^([a-z0-9_]+)\.py$&quot;)
-        modules = []
-        for file in plugins_files:
-            m = file_py.match(file)
-            if file != &quot;__init__.py&quot; and m != None:
-                module = &quot;plugins.&quot;+m.group(1)
-                __import__(module)
-                modules.append(m.group(1))
-        log.info(&quot;Loaded: %u plugings (%s)&quot; % (len(modules), &quot;, &quot;.join(modules)))
-
-        opt = {
-            &quot;verbose&quot;: False,
-            &quot;script&quot;: None,
-            &quot;load_ui&quot;: True,
-            &quot;use_profiler&quot;: False
-        }
-        opt, filename = parseArgs(opt)
-        global hachoir 
-        hachoir = Hachoir()
-        for key in opt:
-            setattr(hachoir, key, opt[key])
-        if hachoir.load_ui:
-            try:
-                print &quot;Load user interface&quot;
-                ui.loadInterface(hachoir)
-            except ImportError, err:
-                error(&quot;&quot;&quot;Error: a Python module is missing:
-%s
-
-You can find PyGTK at: <A HREF="http://www.pygtk.org/">http://www.pygtk.org/</A>
-and PyGlade at: <A HREF="http://glade.gnome.org/">http://glade.gnome.org/</A>
-
-Gentoo: emerge pytgtk
-Debian: apt-get install python2.4-gtk python2.4-magic
-Ubuntu: apt-get install python-gtk2 python-glade2&quot;&quot;&quot; % (err))
-                sys.exit(1)
-        if opt[&quot;use_profiler&quot;]:
-            import profile, pstats
-            stat_filename = 'hachoir.pystat'
-            if filename != None:
-                str_filename = &quot;\&quot;%s\&quot;&quot; % filename
-            else:
-                str_filename = &quot;None&quot;
-            profile.run('global hachoir; hachoir.run(%s)' % str_filename, stat_filename)
-            #pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
-            pstats.Stats(stat_filename).sort_stats('time').print_stats()
-            os.unlink(stat_filename)
-        else:
-            hachoir.run(filename)
-
-    except SystemExit:
-        pass
-    except Exception, err:
-        where = &quot;&quot;.join(traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback))
-        error(&quot;Exception:\n%s\n%s&quot; % (err, where))
-	sys.exit(1)
-
-if __name__==&quot;__main__&quot;: main()    

Deleted: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/hachoir_class.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,142 +0,0 @@
-from stream.file import FileStream
-from plugin import getPluginByStream
-from chunk import FilterChunk
-from default import DefaultFilter
-from user_filter import UserFilterDescriptor, loadUserFilter
-from error import error, warning
-from mime import getStreamMime
-
-class Hachoir:
-    instance = None
-    
-    def __init__(self):
-        Hachoir.instance = self
-        self.display = True
-        self.depth = 5
-        self.ui = None 
-        self._main_filter = None
-        self._filter = None
-        self.script = None
-        self.load_ui = True
-
-    def getFilter(self):
-        return self._filter
-
-    def setFilter(self, filter):
-#        if self._filter != None:
-#            self._filter.purgeCache()
-        self._main_filter = filter
-        self._filter = filter
-        if filter != None:
-            if self.load_ui:
-                self._filter.display()
-                self.ui.window.info.updateFilter(filter)
-        else:
-            if self.load_ui:
-                self.ui.window.clear_table()
-        if self.load_ui:
-            self.ui.window.updateToolbar()
-
-    def onGoParent(self):
-        if self._filter.getParent() == None: return
-        self._filter = self._filter.getParent()
-        self.ui.window.info.updateFilter(self._filter)
-        self._filter.display()
-        
-    def onRowClick(self, chunk_id):
-        if chunk_id == None: return
-        chunk = self._filter.getChunk(chunk_id)
-        if issubclass(chunk.__class__, FilterChunk):
-            filter = chunk.getFilter()
-            self.setFilter (filter)
-
-    def loadUser(self, filename):
-        try:
-            old_filter = self._filter
-            old_size = old_filter.getSize()
-            user = UserFilterDescriptor(xml_file=filename)
-            stream = self._filter.getStream()
-            parent = self._filter.getParent()
-            stream.seek(self._filter.getAddr())
-            new_filter = loadUserFilter(user, stream, parent)
-        except Exception, err:
-            error(&quot;Error while loading user XML filter \&quot;%s\&quot;:\n%s&quot; % (filename, err))
-            return
-        self._filter = new_filter           
-        if parent == None:
-            self._main_filter = self._filter
-            self._addPadding()
-        else:
-            chunk = old_filter.filter_chunk
-            chunk.setFilter(self._filter)
-            diff_size = self._filter.getSize() - old_size
-            chunk.getParent().rescan(chunk, diff_size)
-        if self.load_ui:
-            self._filter.display()
-        self.ui.window.updateToolbar()
-    
-    def saveUser(self, filename):
-        my = UserFilterDescriptor(filter=self._filter)
-        my.writeIntoXML(filename)
-    
-    def exportUser(self, filename):
-        my = UserFilterDescriptor(filter=self._filter)
-        my.exportPython(filename)
-        
-    def _addPadding(self):
-        filter_size = self._main_filter.getSize()
-        stream_size = self._main_filter.getStream().getSize()
-        diff_size = filter_size - stream_size
-        if diff_size &lt; 0:
-            self._main_filter.read(&quot;end&quot;, &quot;%us&quot; % (-diff_size), &quot;Raw data&quot;)
-
-    def loadFile(self, filename):
-        try:
-            print &quot;Load file %s&quot; % filename
-            file = open(filename, 'r')
-            stream = FileStream(file, filename)
-        except IOError, err:
-            error(&quot;Can't load file %s:\n%s&quot; % (filename, err))
-            return
-        self.loadStream(stream, filename)
-
-    def loadStream(self, stream, filename=None):
-        # Look for a plugin
-        split_class = getPluginByStream(stream, filename, None)
-        if split_class == None:
-            mimes = [ item[0] for item in getStreamMime(stream, filename)]
-            warning(&quot;Warning: No plugin found for MIME %s.&quot; % &quot;, &quot;.join(mimes))
-            split_class = DefaultFilter
-            
-        # Split 
-        try:
-            stream.seek(0)
-            filter = split_class(stream, None)
-        except Exception, msg:
-            error(&quot;Exception while processing file %s:\n%s&quot; \
-                % (filename, msg))
-            stream.seek(0)
-            filter = DefaultFilter(stream)
-        self._main_filter = filter
-        self._addPadding()
-        self.setFilter(filter)
-
-    def loadScript(self, filename):
-        try:
-            f = open(self.script, 'r')
-            script = f.read()
-            f.close()
-            compiled = compile(script, self.script, 'exec')
-            exec compiled
-        except Exception, msg:
-            error(&quot;Exception while loading script \&quot;%s\&quot;:\n%s\n%s&quot; \
-                % (filename, msg))
-
-    def run(self, filename):
-        if self.script:
-            self.loadScript(self.script)
-        elif filename != None:
-            self.loadFile(filename)
-        if self.load_ui:
-            print &quot;Run user interface ...&quot;
-            self.ui.run()      

Deleted: haypo/hachoir/log.py
===================================================================
--- haypo/hachoir/log.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/log.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,93 +0,0 @@
-#!/usr/bin/python
-# -*- coding: UTF-8 -*-
-
-import time
-
-class Log:
-    LOG_INFO   = 0
-    LOG_WARN   = 1
-    LOG_ERROR  = 2
-
-    def __init__(self):
-        self.__buffer = {}
-        self.__file = None
-        self.use_print = True
-        self.on_new_message = None # (level, prefix, text)
-
-    def setFilename(self, filename):
-        &quot;&quot;&quot;
-        Use a file to store all messages. The
-        UTF-8 encoding will be used. Write an informative
-        message if the file can't be created.
-
-        @param filename: C{L{string}}
-        &quot;&quot;&quot;
-
-        try:
-            import codecs
-            self.__file = codecs.open(filename, &quot;w&quot;, &quot;utf-8&quot;)
-        except IOError, errno:
-            if errno[0] == 2:
-                self.__file = None
-                self.info(&quot;Log.setFilename(%s) fails : no such file.&quot; % filename)
-                return
-            raise
-
-    def getLevelPrefix(self, level):
-        &quot;&quot;&quot;
-        String prefix which depends on message level.
-        Eg. information returns &quot;[info]&quot;.
-        @return: C{str}
-        &quot;&quot;&quot;
-        if level==Log.LOG_WARN: return &quot;[warn]&quot;
-        if level==Log.LOG_ERROR: return &quot;[err!]&quot;
-        return &quot;[info]&quot;
-
-    def newMessage(self, level, str):
-        &quot;&quot;&quot;
-        Write a new message : append it in the buffer,
-        display it to the screen (if needed), and write
-        it in the log file (if needed).
-
-        @param level: Message level.
-        @type level: C{int}
-        @param str: Message content.
-        @type str: C{str}
-        &quot;&quot;&quot;
-
-        if not self.__buffer.has_key(level):
-            self.__buffer[level] = [str]
-        else:
-            self.__buffer[level].append(str)
-        prefix = self.getLevelPrefix(level)            
-        if self.use_print:
-            print &quot;%s %s&quot; % (prefix, str)
-        if self.__file:
-            self.__file.write(u&quot;%s - %s %s\n&quot; \
-                % (time.strftime(&quot;%Y-%M-%d %H:%M:%S&quot;),
-                   prefix, str))
-        if self.on_new_message:
-            self.on_new_message (level, prefix, str)
-
-    def info(self, str):
-        &quot;&quot;&quot;
-        New informative message.
-        @type str: C{str}
-        &quot;&quot;&quot;
-        self.newMessage(Log.LOG_INFO, str)
-
-    def warning(self, str):
-        &quot;&quot;&quot;
-        New warning message.
-        @type str: C{str}
-        &quot;&quot;&quot;
-        self.newMessage(Log.LOG_WARN, str)
-
-    def error(self, str):
-        &quot;&quot;&quot;
-        New error message.
-        @type str: C{str}
-        &quot;&quot;&quot;
-        self.newMessage(Log.LOG_ERROR, str)
-
-log = Log()        

Deleted: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/mime.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,141 +0,0 @@
-#!/usr/bin/python
-
-&quot;&quot;&quot;
-MIME type detection using libmagic library.
-
-See also:
-- <A HREF="ftp://ftp.astron.com/pub/file/">ftp://ftp.astron.com/pub/file/</A> (libmagic)
-- <A HREF="http://www.demonseed.net/~jp/code/magic.py">http://www.demonseed.net/~jp/code/magic.py</A> (100% Python)
-- <A HREF="http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup">http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup</A> (PHP)
-&quot;&quot;&quot;
-
-import os, sys, stat, string, re
-from error import warning
-
-instance = None
-
-class GuessMime:
-    def __init__(self):
-        self.use_fallback = False
-        self.func = None
-        try:
-            path = os.path.dirname(__file__)
-            sys.path.append(path)
-            import magic
-            self.func = magic.open(magic.MAGIC_MIME)
-            self.func.load()
-        except ImportError:
-            warning(&quot;Warning: The library libmagic for Python is unavailable. Using internal fallback engine.&quot;)
-            self.use_fallback = True
-        if self.use_fallback:
-            from  fallback.magic import whatis
-            self.func = whatis
-
-    def guess(self, buffer):
-        if not self.use_fallback:
-            return self.func.buffer(buffer)
-        else:
-            mime = self.func(buffer)
-            return mime
-
-def getFileMime(realname, filename=None):
-    if filename == None:
-        filename = realname
-    mode = os.stat(filename)[stat.ST_MODE]
-    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
-    
-    f = file(filename, &quot;rb&quot;)
-    buffer = f.read(4096)
-    f.close()
-    return getBufferMime(buffer, filename)
-
-def getMimeByExt(ext):    
-    if ext == '.gz':
-        return 'application/x-gzip'
-    return None        
-
-def getStreamMime(stream, filename):
-    oldpos = stream.tell()
-    stream.seek(0)
-    size = stream.getSize()
-    if 4096&lt;size:
-        size = 4096
-    data = stream.getN(size)
-    stream.seek(oldpos)
-    return getBufferMime(data, filename)
-
-def getAnotherBufferMime(buffer):    
-    if buffer[:2] == &quot;\x4d\x4d&quot; and buffer[6:12]==&quot;\x02\0\x0A\0\0\0&quot;:
-        return &quot;image/x-3ds&quot;
-    if 2&lt;=len(buffer) and ord(buffer[0])==31 and ord(buffer[1])==139:
-        return &quot;application/x-gzip&quot;
-    if buffer[:4] == &quot;%PDF&quot;:
-        return &quot;application/pdf&quot;
-    if buffer[:14] == &quot;gimp xcf file\0&quot;:
-        return &quot;image/x-xcf&quot;
-
-    if buffer[0] == &quot;\x0A&quot; \
-    and buffer[1] in &quot;\x00\x02\x03\x04\x05&quot; \
-    and buffer[64] == &quot;\0&quot;:
-        return &quot;image/x-pcx&quot;
-        
-    if 4096&lt;=len(buffer) \
-    and buffer[1080:1082]==&quot;\x53\xEF&quot; \
-    and buffer[1116:1120]==&quot;\x04\x00\x00\x00&quot;:
-        return &quot;hachoir/fs-ext2&quot;
-        
-    if buffer[0:3] == &quot;DIR&quot;:
-        return &quot;hachoir/worms2&quot;
-        
-    if 512&lt;=len(buffer) \
-    and buffer[0] in &quot;\xEB\xFA&quot; \
-    and buffer[510:512] == &quot;\x55\xAA&quot; \
-    and buffer[446] in &quot;\x00\x80&quot; \
-    and buffer[446+16*1] in &quot;\x00\x80&quot; \
-    and buffer[446+16*2] in &quot;\x00\x80&quot; \
-    and buffer[446+16*3] in &quot;\x00\x80&quot;:
-        return &quot;hachoir/master-boot-record&quot;
-    return None        
-
-def splitMimes(mimes):
-    &quot;&quot;&quot;
-    Split MIME types into a list.
-    Examples:
-    - &quot;text/plain; encoding=latin-1&quot; =&gt; [[&quot;text/plain&quot;, {&quot;encoding&quot;: latin-1&quot;}]
-    - &quot;text/plain, text/xml&quot; =&gt; [[&quot;text/plain&quot;],[&quot;text/xml&quot;]]
-    - &quot;text/plain; charset=ISO-8859-1; format=flowed&quot;
-      =&gt; [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
-    - &quot;application/x-archive application/x-debian-package&quot;
-    &quot;&quot;&quot;
-
-    regex = re.compile(&quot;[^/]+/[^; ]+(?:;[^;]+)*&quot;)
-    mimes = regex.findall(mimes)    
-    
-    list = []
-    for mime in mimes:
-        mime = mime.strip(&quot; ,&quot;)
-        parts = mime.split(&quot;;&quot;)
-        mime = parts[0]
-        parts = map(string.strip, parts[1:])
-        values = {}
-        for part in parts:
-            if part != &quot;&quot;:
-                split_part = part.split(&quot;=&quot;, 1)             
-                values[ split_part[0] ] = split_part[1]
-        list.append([mime,values])
-    return list
-
-def getBufferMime(buffer, filename):
-    global instance
-    if instance == None:
-        instance = GuessMime()
-    mimes = instance.guess(buffer)
-    mimes = splitMimes(mimes)
-    if len(mimes) == 0 or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
-        new_mime = getAnotherBufferMime(buffer)
-        if new_mime == None and filename != None:
-            ext = os.path.splitext(filename)[1]
-            new_mime = getMimeByExt(ext)
-        if new_mime != None:
-            mimes = ((new_mime,),)
-    return mimes

Deleted: haypo/hachoir/ogg_page.xml
===================================================================
--- haypo/hachoir/ogg_page.xml	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/ogg_page.xml	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,12 +0,0 @@
-&lt;?xml version='1.0' encoding='UTF-8'?&gt;
-&lt;user_filter hachoir_version='2005-10-27' id='ogg_page' description='ogg_page'&gt;
-  &lt;chunk format='!4s' id='header' description='Header (OggS)'/&gt;
-  &lt;chunk format='!1B' id='version' description='Version'/&gt;
-  &lt;chunk format='!1B' id='type' description='Type'/&gt;
-  &lt;chunk format='!8s' id='pos' description='Position'/&gt;
-  &lt;chunk format='!L' id='serial' description='Serial number'/&gt;
-  &lt;chunk format='!L' id='seq_nb' description='Sequence number'/&gt;
-  &lt;chunk format='!L' id='checksum' description='Checksum'/&gt;
-  &lt;chunk format='!1B' id='page_segm' description='Raw'/&gt;
-  &lt;chunk format='!31s' id='something' description='Raw'/&gt;
-&lt;/user_filter&gt;

Deleted: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/plugin.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,40 +0,0 @@
-import re
-from mime import getFileMime, getStreamMime
-from default import DefaultFilter
-from error import warning
-
-def guessPlugin(stream, filename, default=DefaultFilter):
-    return getPluginByStream(stream, filename, default)
-
-def getPluginByMime(mimes, default=DefaultFilter):
-    global hachoir_plugins
-    plugins = []
-    for mime in mimes:
-        mime = mime[0]
-        if mime in hachoir_plugins:
-            plugins = plugins + hachoir_plugins[mime]
-    if len(plugins)==0:
-        return default
-    if 1&lt;len(plugins):
-        warning(&quot;More than one plugin have same MIME...&quot;)
-    return plugins[0]
-    
-def getPluginByStream(stream, filename, default=DefaultFilter):
-    mime = getStreamMime(stream, filename)
-    return getPluginByMime(mime, default)
-
-def getPluginByFile(filename, realname=None, default=DefaultFilter):
-    mime = getFileMime(filename, realname)
-    return getPluginByMime(mime, default)
-    
-def registerPlugin(filter_class, mimes):
-    global hachoir_plugins
-    if isinstance(mimes, str):
-        mimes = [mimes]
-    for mime in mimes:
-        if mime in hachoir_plugins:
-            hachoir_plugins[mime].append(filter_class)
-        else:
-            hachoir_plugins[mime] = [filter_class]
-
-hachoir_plugins = {} 

Deleted: haypo/hachoir/program.py
===================================================================
--- haypo/hachoir/program.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/program.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,3 +0,0 @@
-PROGRAM=&quot;Hachoir&quot;
-VERSION=&quot;2005-12-11&quot;
-WEBSITE=&quot;<A HREF="http://www.haypocalc.com/wiki/Hachoir">http://www.haypocalc.com/wiki/Hachoir</A>&quot;

Deleted: haypo/hachoir/release.sh
===================================================================
--- haypo/hachoir/release.sh	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/release.sh	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,16 +0,0 @@
-PACKAGE=hachoir
-VERSION=20051115
-ARCHIVE=$PACKAGE-$VERSION.tar.bz2
-TMP_DIR=/tmp
-DIR=$PWD
-if [ -e $TMP_DIR/$PACKAGE ]; then
-        rm -rf $TMP_DIR/$PACKAGE
-fi
-
-echo &quot;* Export data&quot;
-svn export . $TMP_DIR/$PACKAGE
-
-echo &quot;* Create $ARCHIVE&quot;
-(cd $TMP_DIR &amp;&amp; tar cjf $DIR/$ARCHIVE $PACKAGE)
-
-echo &quot;$DIR/$ARCHIVE wrote.&quot;

Deleted: haypo/hachoir/text_handler.py
===================================================================
--- haypo/hachoir/text_handler.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/text_handler.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,10 +0,0 @@
-from tools import humanFilesize as doHumanFilesize
-
-def humanFilesize(chunk):
-    return doHumanFilesize(chunk.value)
-
-def hexadecimal(chunk):
-    size = chunk.size
-    assert size in (2, 4, 8)
-    pattern = &quot;%0&quot; + str(2*size) + &quot;X&quot;
-    return pattern % chunk.value

Deleted: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/tools.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,181 +0,0 @@
-import traceback, sys, string, re
-
-def _regexMaxLength(pattern, in_parenthesis=False):
-    &quot;&quot;&quot;
-    Don't use this function directly, use regexMagLength!
-    &quot;&quot;&quot;
-
-    re_letter = re.compile( r&quot;^[^][()|.?+*{}](.*)$&quot;)
-    re_set = re.compile( r&quot;^\[&quot; + r&quot;[^]]*&quot; + r&quot;\](.*)$&quot; )
-    re_min_repetition = re.compile( r&quot;^\{([0-9]+)\}(.*)$&quot; )
-    re_min_max_repetition = re.compile( r&quot;^\{([0-9]+),([0-9]+)\}(.*)$&quot; )
-
-    size = 0
-    atom_size = 0
-    state = 0 # get atom
-    is_end = len(pattern) == 0
-    if in_parenthesis and not is_end:
-        is_end = pattern[0] in (&quot;|&quot;, &quot;)&quot;)
-    while not is_end:
-        if state==0:
-            size = size + atom_size
-
-            # Pattern: [...] =&gt; size=1
-            if pattern[0] == '(':
-                pattern = pattern[1:]
-                atom_size = None
-                while True:
-                    tmp_atom_size, pattern = _regexMaxLength(pattern, True)
-                    if tmp_atom_size == None:
-                        return None, pattern
-                    if atom_size==None or atom_size&lt;tmp_atom_size:
-                        atom_size = tmp_atom_size
-                    if pattern[0] == ')':
-                        break
-                    assert pattern[0] == '|'
-                    pattern = pattern[1:]
-                pattern = pattern[1:]
-            else:
-                m = re_set.match(pattern)
-                if m != None:
-                    pattern = m.group(1)
-                    atom_size = 1
-                else:
-                    m = re_letter.match(pattern)
-                    if m == None:
-                        return (-1, pattern,)
-                    atom_size = 1
-                    pattern = m.group(1)
-            state = 1                
-        else:
-            assert state==1
-
-            # Repetiton: + or * =&gt; no limit
-            if pattern[0] in (&quot;*&quot;, &quot;+&quot;):
-                return (None, pattern,)
-            
-            # Repetition: {2}
-            m = re_min_repetition.match(pattern)
-            if m != None:
-                repetition = int(m.group(1))
-                print &quot;(rep=%sx%s)&quot; % (atom_size, repetition)
-                pattern = m.group(2)
-                atom_size = atom_size * repetition
-            else:
-                # Repetition: {1,2}
-                m = re_min_max_repetition.match(pattern)
-                if m != None:
-                    repetition = int(m.group(2))
-                    pattern = m.group(3)
-                    atom_size = atom_size * repetition
-            state = 0
-
-        is_end = len(pattern) == 0
-        if in_parenthesis and not is_end:
-            is_end = pattern[0] in (&quot;|&quot;, &quot;)&quot;)
-
-    return (size + atom_size, pattern,)
-
-def regexMaxLength(pattern):
-    &quot;&quot;&quot;
-    Get maximum size of a regular expression pattern.
-    Returns (size, pattern). If size=-1, an error occurs (pattern contains
-    the buggy pattern). If size=-1, no limit does exist.
-    &quot;&quot;&quot;
-
-    size, pattern = _regexMaxLength(pattern)
-    if size == -1:
-        raise &quot;Can't parse regular expression: %s&quot; % pattern 
-    return size 
-
-def humanDuration(ms):
-    # Milliseconds
-    if ms &lt; 1000:
-        return &quot;%u ms&quot; % ms
-        
-    # Seconds
-    sec = ms/1000
-    ms = ms%1000
-    if sec &lt; 60:
-        return  &quot;%u sec&quot; % sec
-
-    # Minutes
-    min = sec/60
-    sec = sec%60
-    if min&lt;60:
-        text = &quot;%u min %u sec&quot; % (min, sec)
-
-    # Hours
-    hour = min/60
-    min = min/60
-    if hour &lt; 24:
-        text = &quot;%u hour(s) %u min&quot; % (hour, min)
-
-    # Days
-    day = hour/24
-    hour = hour%24
-    if hour != 0:
-        text = &quot;%u day(s) %u hour(s)&quot; % (day, hour)    
-    else:
-        text = &quot;%u day(s)&quot; % (day)
-    return text
-
-def humanFilesize(size):
-    if size &lt; 1000:
-        return &quot;%u bytes&quot; % size
-    units = [&quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;]
-    size = float(size)
-    for unit in units:
-        size = size / 1024
-        if size &lt; 100:
-            return &quot;%.1f %s&quot; % (size, unit)
-        if size &lt; 1000:
-            return &quot;%u %s&quot; % (size, unit)
-        last_unit = unit
-    return &quot;%u %s&quot; % (size, unit)
-
-def convertDataToPrintableString(data, keep_n=False):
-    if len(data) == 0:
-        return &quot;(empty)&quot;
-    display = &quot;&quot;
-    for c in data:
-        if ord(c)&lt;32:
-            know = { \
-                &quot;\n&quot;: &quot;\\n&quot;,
-                &quot;\r&quot;: &quot;\\r&quot;,
-                &quot;\t&quot;: &quot;\\t&quot;,
-                &quot;\0&quot;: &quot;\\0&quot;}
-            if c in know:
-                if not keep_n or c != &quot;\n&quot;:
-                    display = display + know[c]
-                else:
-                    display = display + c
-            else:
-#                display = display + &quot;\\x%02X&quot; % ord(c)
-                display = display + &quot;.&quot;
-        elif c in string.printable:
-            display = display + c
-        else:
-            display = display + &quot;.&quot;
-    return &quot;\&quot;%s\&quot;&quot; % display
-
-def getBacktrace():
-    try:
-        bt = traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback)
-        return &quot;&quot;.join(bt)
-    except:
-        return &quot;Error while trying to get backtrace&quot;
-
-def getUnixRWX(mode):
-#-- TODO --
-#EXT2_S_ISUID  0x0800  SUID
-#EXT2_S_ISGID  0x0400  SGID
-#EXT2_S_ISVTX  0x0200  sticky bit
-    rwx = (&quot;---&quot;, &quot;rwx&quot;)
-    text = &quot;&quot;
-    for i in range(0,3):
-        for j in range(0,3):
-            mask = 1 &lt;&lt; (3*(2-i)) &lt;&lt; (2-j)
-            text = text + rwx[int(mode &amp; mask == mask)][j]
-    return text

Copied: haypo/hachoir/trunk/AUTHORS (from rev 348, haypo/hachoir/AUTHORS)

Copied: haypo/hachoir/trunk/BUGS (from rev 348, haypo/hachoir/BUGS)

Copied: haypo/hachoir/trunk/COPYING (from rev 348, haypo/hachoir/COPYING)

Copied: haypo/hachoir/trunk/ChangeLog (from rev 348, haypo/hachoir/ChangeLog)

Copied: haypo/hachoir/trunk/INSTALL (from rev 348, haypo/hachoir/INSTALL)

Copied: haypo/hachoir/trunk/Makefile (from rev 348, haypo/hachoir/Makefile)

Copied: haypo/hachoir/trunk/README (from rev 348, haypo/hachoir/README)

Copied: haypo/hachoir/trunk/bmp_filter.xml (from rev 348, haypo/hachoir/bmp_filter.xml)

Copied: haypo/hachoir/trunk/chunk.py (from rev 348, haypo/hachoir/chunk.py)

Copied: haypo/hachoir/trunk/config.py (from rev 348, haypo/hachoir/config.py)

Copied: haypo/hachoir/trunk/default.py (from rev 348, haypo/hachoir/default.py)

Copied: haypo/hachoir/trunk/error.py (from rev 348, haypo/hachoir/error.py)

Copied: haypo/hachoir/trunk/export.template (from rev 348, haypo/hachoir/export.template)

Copied: haypo/hachoir/trunk/fallback (from rev 348, haypo/hachoir/fallback)

Copied: haypo/hachoir/trunk/filter.py (from rev 348, haypo/hachoir/filter.py)

Copied: haypo/hachoir/trunk/format.py (from rev 348, haypo/hachoir/format.py)

Copied: haypo/hachoir/trunk/hachoir.py (from rev 348, haypo/hachoir/hachoir.py)

Copied: haypo/hachoir/trunk/hachoir_class.py (from rev 348, haypo/hachoir/hachoir_class.py)

Copied: haypo/hachoir/trunk/log.py (from rev 348, haypo/hachoir/log.py)

Copied: haypo/hachoir/trunk/mime.py (from rev 348, haypo/hachoir/mime.py)

Copied: haypo/hachoir/trunk/ogg_page.xml (from rev 348, haypo/hachoir/ogg_page.xml)

Copied: haypo/hachoir/trunk/plugin.py (from rev 348, haypo/hachoir/plugin.py)

Copied: haypo/hachoir/trunk/plugins (from rev 348, haypo/hachoir/plugins)

Copied: haypo/hachoir/trunk/program.py (from rev 348, haypo/hachoir/program.py)

Copied: haypo/hachoir/trunk/release.sh (from rev 348, haypo/hachoir/release.sh)

Copied: haypo/hachoir/trunk/stream (from rev 348, haypo/hachoir/stream)

Copied: haypo/hachoir/trunk/text_handler.py (from rev 348, haypo/hachoir/text_handler.py)

Copied: haypo/hachoir/trunk/tools.py (from rev 348, haypo/hachoir/tools.py)

Copied: haypo/hachoir/trunk/ui (from rev 348, haypo/hachoir/ui)

Copied: haypo/hachoir/trunk/user_filter.py (from rev 348, haypo/hachoir/user_filter.py)

Deleted: haypo/hachoir/user_filter.py
===================================================================
--- haypo/hachoir/user_filter.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/user_filter.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,136 +0,0 @@
-from filter import Filter
-from chunk import FilterChunk
-from xml.dom.minidom import getDOMImplementation, parse
-from program import VERSION
-from xml.dom.ext import PrettyPrint
-
-class UserChunk:
-    def __init__(self, id, format, description):
-        self.id = id
-        self.format = format
-        self.description = description
-        
-    def __str__(self):
-        return &quot;UserChunk &lt;id=%s, format=%s, description=%s&gt;&quot; % \
-            (self.id, self.format, self.description)
-
-class UserSubChunk(UserChunk):
-    def __init__(self, id, sub, sub_format, description):
-        UserChunk.__init__(self, id, &quot;sub&quot;, description)
-        self.sub = sub
-        self.sub_format = sub_format
-
-def loadUserFilter(desc, stream, parent):
-    filter = Filter(desc.id, desc.description, stream, parent)
-    for chunk in desc.chunks:
-        if chunk.format == &quot;sub&quot;:
-            modules = chunk.sub_format.split('.')
-            chunk_class = modules[-1]
-            module = &quot;.&quot;.join(modules[:-1])
-            mod = __import__(module, globals(), locals(), [chunk_class])
-            chunk_class = getattr(mod, chunk_class)
-            filter.readChild(chunk.id, chunk_class, chunk.description)
-        else:
-            filter.read(chunk.id, chunk.format, chunk.description)
-    return filter            
-
-class UserFilterDescriptor:
-    def __init__(self, filter=None, xml_file=None):
-        self.chunks = []
-        if filter != None:
-            self.createFromFilter(filter)
-        elif xml_file != None:
-            self.createFromXML(xml_file)
-        else:
-            self.id = None 
-            self.description = None 
-            
-    def exportPython(self, filename):
-        file = open(filename, &quot;w&quot;)
-        file.write(self.toPython())
-        file.close()
-            
-    def writeIntoXML(self, filename):
-        file = open(filename, &quot;w&quot;)
-        PrettyPrint(self.toXML(), file)
-        file.close()
-        
-    def createFromXML(self, filename):
-        xml = parse(filename)
-        self.chunks = []
-        root = xml.documentElement
-        self.id = root.getAttribute(&quot;id&quot;)
-        self.description = root.getAttribute(&quot;description&quot;)
-        self.__loadXML(root)
-        
-    def __loadXML(self, node):
-        for chunk in node.childNodes:
-            if chunk.nodeType == chunk.ELEMENT_NODE and chunk.tagName == &quot;chunk&quot;:
-                id = chunk.getAttribute(&quot;id&quot;) 
-                description = chunk.getAttribute(&quot;description&quot;) 
-                format = chunk.getAttribute(&quot;format&quot;)
-                
-                if format == &quot;sub&quot;:
-                    sub_format = chunk.getAttribute(&quot;sub_format&quot;) 
-                    sub = UserFilterDescriptor()
-                    sub.__loadXML(chunk)
-                    user_chunk = UserSubChunk(id, sub, sub_format, description)
-                else:
-                    user_chunk = UserChunk(id, format, description)
-                self.chunks.append(user_chunk)
-
-    def toPython(self):
-        f = open('export.template', 'r')
-        tpl = f.read()
-        f.close()
-
-        chunks = &quot;&quot;
-        for chunk in self.chunks:
-            if chunks != &quot;&quot;: chunks = chunks + &quot;\n&quot;
-            chunks = chunks \
-                + &quot; &quot; * 8 \
-                + &quot;self.read(\&quot;%s\&quot;, \&quot;%s\&quot;, \&quot;%s\&quot;)&quot; \
-                  % (chunk.id, chunk.format, chunk.description)
-        return tpl.replace(&quot;{id}&quot;, self.id).replace(&quot;{description}&quot;, self.description).replace(&quot;{chunks}&quot;, chunks)
-
-    def toXML(self):
-        impl = getDOMImplementation()
-        doc = impl.createDocument(None, &quot;user_filter&quot;, None)
-        root = doc.documentElement
-        root.setAttribute(&quot;hachoir_version&quot;, VERSION)
-        root.setAttribute(&quot;id&quot;, self.id)
-        root.setAttribute(&quot;description&quot;, self.id)
-        self.__toXML(doc, root)
-        return doc
-
-    def __toXML(self, doc, node):
-        for chunk in self.chunks:
-            item = doc.createElement(&quot;chunk&quot;)
-            item.setAttribute(&quot;id&quot;, chunk.id)
-            item.setAttribute(&quot;description&quot;, chunk.description)
-            item.setAttribute(&quot;format&quot;, chunk.format)
-            node.appendChild(item)
-            if issubclass(chunk.__class__, UserSubChunk):
-                item.setAttribute(&quot;sub_format&quot;, chunk.sub_format)
-#                chunk.sub.__toXML(doc, item)
-
-    def createFromFilter(self, filter):
-        self.id = filter.getId()
-        self.description = filter.getDescription()
-        self.chunks = []
-        self.__createFromChunks(filter.getChunks())
-
-    def __createFromChunks(self, chunks):
-        for chunk in chunks:
-            if False: #issubclass(chunk.__class__, ArrayChunk):
-                # TODO: Fix ArrayFilter
-                self.__createFromChunks(chunk)
-            else:
-                if issubclass(chunk.__class__, FilterChunk):
-                    format = str(chunk.getFilter().__class__)
-                    #sub = UserFilterDescriptor(filter=chunk.getFilter())
-                    sub = None
-                    user = UserSubChunk(chunk.id, sub, format, chunk.description)
-                else:
-                    user = UserChunk(chunk.id, chunk.getFormat(), chunk.description)
-                self.chunks.append(user)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000253.html">[Happyboom-svn] r348 - in haypo/hachoir: . plugins stream
</A></li>
	<LI>Next message: <A HREF="000254.html">[Happyboom-svn] r350 - haypo/hachoir/tags
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#297">[ date ]</a>
              <a href="thread.html#297">[ thread ]</a>
              <a href="subject.html#297">[ subject ]</a>
              <a href="author.html#297">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/happyboom-svn">More information about the Happyboom-svn
mailing list</a><br>
</body></html>
