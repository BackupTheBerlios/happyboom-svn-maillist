<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Happyboom-svn] r351 - in haypo/hachoir/trunk: . broken_plugins generic plugins ui
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/happyboom-svn/2005-December/index.html" >
   <LINK REL="made" HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r351%20-%20in%20haypo/hachoir/trunk%3A%20.%20broken_plugins%20generic%20plugins%20ui&In-Reply-To=%3C200512260353.jBQ3rWtr015356%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000254.html">
   <LINK REL="Next"  HREF="000255.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Happyboom-svn] r351 - in haypo/hachoir/trunk: . broken_plugins generic plugins ui</H1>
    <B>haypo at BerliOS</B> 
    <A HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r351%20-%20in%20haypo/hachoir/trunk%3A%20.%20broken_plugins%20generic%20plugins%20ui&In-Reply-To=%3C200512260353.jBQ3rWtr015356%40sheep.berlios.de%3E"
       TITLE="[Happyboom-svn] r351 - in haypo/hachoir/trunk: . broken_plugins generic plugins ui">haypo at berlios.de
       </A><BR>
    <I>Mon Dec 26 04:53:32 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000254.html">[Happyboom-svn] r350 - haypo/hachoir/tags
</A></li>
        <LI>Next message: <A HREF="000255.html">[Happyboom-svn] r352 - haypo/hachoir/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#298">[ date ]</a>
              <a href="thread.html#298">[ thread ]</a>
              <a href="subject.html#298">[ subject ]</a>
              <a href="author.html#298">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: haypo
Date: 2005-12-26 04:53:11 +0100 (Mon, 26 Dec 2005)
New Revision: 351

Added:
   haypo/hachoir/trunk/broken_plugins/
   haypo/hachoir/trunk/broken_plugins/3ds.py
   haypo/hachoir/trunk/broken_plugins/ar.py
   haypo/hachoir/trunk/broken_plugins/asn1.py
   haypo/hachoir/trunk/broken_plugins/bmp.py
   haypo/hachoir/trunk/broken_plugins/bzip2.py
   haypo/hachoir/trunk/broken_plugins/elf.py
   haypo/hachoir/trunk/broken_plugins/email.py
   haypo/hachoir/trunk/broken_plugins/exe.py
   haypo/hachoir/trunk/broken_plugins/exif.py
   haypo/hachoir/trunk/broken_plugins/ext2.py
   haypo/hachoir/trunk/broken_plugins/gif.py
   haypo/hachoir/trunk/broken_plugins/id3.py
   haypo/hachoir/trunk/broken_plugins/mbr.py
   haypo/hachoir/trunk/broken_plugins/mp3.py
   haypo/hachoir/trunk/broken_plugins/pcx.py
   haypo/hachoir/trunk/broken_plugins/pdf.py
   haypo/hachoir/trunk/broken_plugins/rpm.py
   haypo/hachoir/trunk/broken_plugins/worms2.py
   haypo/hachoir/trunk/broken_plugins/xcf.py
   haypo/hachoir/trunk/broken_plugins/zip.py
   haypo/hachoir/trunk/generic/
   haypo/hachoir/trunk/generic/__init__.py
   haypo/hachoir/trunk/generic/image.py
Removed:
   haypo/hachoir/trunk/plugins/3ds.py
   haypo/hachoir/trunk/plugins/ar.py
   haypo/hachoir/trunk/plugins/asn1.py
   haypo/hachoir/trunk/plugins/bmp.py
   haypo/hachoir/trunk/plugins/bzip2.py
   haypo/hachoir/trunk/plugins/elf.py
   haypo/hachoir/trunk/plugins/email.py
   haypo/hachoir/trunk/plugins/exe.py
   haypo/hachoir/trunk/plugins/exif.py
   haypo/hachoir/trunk/plugins/ext2.py
   haypo/hachoir/trunk/plugins/gif.py
   haypo/hachoir/trunk/plugins/id3.py
   haypo/hachoir/trunk/plugins/mbr.py
   haypo/hachoir/trunk/plugins/mp3.py
   haypo/hachoir/trunk/plugins/pcx.py
   haypo/hachoir/trunk/plugins/pdf.py
   haypo/hachoir/trunk/plugins/rpm.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/plugins/xcf.py
   haypo/hachoir/trunk/plugins/zip.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/default.py
   haypo/hachoir/trunk/error.py
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/format.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/plugins/avi.py
   haypo/hachoir/trunk/plugins/gzip.py
   haypo/hachoir/trunk/plugins/jpeg.py
   haypo/hachoir/trunk/plugins/png.py
   haypo/hachoir/trunk/plugins/tar.py
   haypo/hachoir/trunk/text_handler.py
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/ui_window.py
   haypo/hachoir/trunk/user_filter.py
Log:
- Rewrite Filter read*() methods, just use read() and doRead() yet
- Better result with humanFilesize() (which supports TB unit yet)
- Use new syntax for FormatChunk, more human readable (see below)
- Always display backtrace in log
- When chunk id/description is changed, tells the (filter) parent which can
  update display
- Create EnumChunk: FormatChunk + dictionnary to associate value to string
- Create BitsChunk: can be used to split bytes in bits ;-)

New read() method:
- replace self.read(id, format, desc) with self.read(id, desc, (FormatChunk, format))
- replace self.read(id, format, desc, post=func) with self.read(id, desc, (FormatChunk, format), {&quot;post&quot;: func})
- replace self.readChild(id, class, arg1, ...) with self.read(id, *desc*, (class, arg1, ...))
- replace self.readStreamChild(id, stream, class, arg1, ...) with self.read(id, *desc*, (class, arg1, ...), {&quot;stream&quot;: stream})

New FormatChunk syntax:
- use global endian for filter (be can be overridden)
- replace &quot;10s&quot; with &quot;string[10]&quot;
- replace &quot;c&quot; with &quot;char&quot;
- replace &quot;B&quot; with &quot;uint8&quot;
- replace &quot;H&quot; with &quot;unit16&quot;
- replace &quot;L&quot; with &quot;uint32&quot;
- replace &quot;f&quot; with &quot;float&quot;



Copied: haypo/hachoir/trunk/broken_plugins/3ds.py (from rev 349, haypo/hachoir/trunk/plugins/3ds.py)

Copied: haypo/hachoir/trunk/broken_plugins/ar.py (from rev 349, haypo/hachoir/trunk/plugins/ar.py)

Copied: haypo/hachoir/trunk/broken_plugins/asn1.py (from rev 349, haypo/hachoir/trunk/plugins/asn1.py)

Copied: haypo/hachoir/trunk/broken_plugins/bmp.py (from rev 349, haypo/hachoir/trunk/plugins/bmp.py)

Copied: haypo/hachoir/trunk/broken_plugins/bzip2.py (from rev 349, haypo/hachoir/trunk/plugins/bzip2.py)

Copied: haypo/hachoir/trunk/broken_plugins/elf.py (from rev 349, haypo/hachoir/trunk/plugins/elf.py)

Copied: haypo/hachoir/trunk/broken_plugins/email.py (from rev 349, haypo/hachoir/trunk/plugins/email.py)

Copied: haypo/hachoir/trunk/broken_plugins/exe.py (from rev 349, haypo/hachoir/trunk/plugins/exe.py)

Copied: haypo/hachoir/trunk/broken_plugins/exif.py (from rev 349, haypo/hachoir/trunk/plugins/exif.py)

Copied: haypo/hachoir/trunk/broken_plugins/ext2.py (from rev 349, haypo/hachoir/trunk/plugins/ext2.py)

Copied: haypo/hachoir/trunk/broken_plugins/gif.py (from rev 349, haypo/hachoir/trunk/plugins/gif.py)

Copied: haypo/hachoir/trunk/broken_plugins/id3.py (from rev 349, haypo/hachoir/trunk/plugins/id3.py)

Copied: haypo/hachoir/trunk/broken_plugins/mbr.py (from rev 349, haypo/hachoir/trunk/plugins/mbr.py)

Copied: haypo/hachoir/trunk/broken_plugins/mp3.py (from rev 349, haypo/hachoir/trunk/plugins/mp3.py)

Copied: haypo/hachoir/trunk/broken_plugins/pcx.py (from rev 349, haypo/hachoir/trunk/plugins/pcx.py)

Copied: haypo/hachoir/trunk/broken_plugins/pdf.py (from rev 349, haypo/hachoir/trunk/plugins/pdf.py)

Copied: haypo/hachoir/trunk/broken_plugins/rpm.py (from rev 349, haypo/hachoir/trunk/plugins/rpm.py)

Copied: haypo/hachoir/trunk/broken_plugins/worms2.py (from rev 349, haypo/hachoir/trunk/plugins/worms2.py)

Copied: haypo/hachoir/trunk/broken_plugins/xcf.py (from rev 349, haypo/hachoir/trunk/plugins/xcf.py)

Copied: haypo/hachoir/trunk/broken_plugins/zip.py (from rev 349, haypo/hachoir/trunk/plugins/zip.py)

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/chunk.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,6 +1,6 @@
 import struct, re, types
 import config
-from format import checkFormat, splitFormat, getFormatSize 
+from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsInteger
 from error import warning, error
 from tools import convertDataToPrintableString
 
@@ -67,11 +67,14 @@
     def _setAddr(self, addr): self._addr = addr
     def _getAddr(self): return self._addr
     def _getSize(self): return self._size
-    def _getId(self): return self._id
-    def _setId(self, id):
-        if self._id == id: return
-        self._parent.updateChunkId(self, id)
-        self._id = id
+    def _getId(self):
+        return self._id
+    def _setId(self, new_id):
+        old_id = self.id
+        if new_id == old_id:
+            return
+        self._id = new_id
+        self._parent.updateChunkId(old_id, new_id)
     addr = property(_getAddr, _setAddr)        
     size = property(_getSize)        
     id = property(_getId, _setId)
@@ -131,9 +134,11 @@
     def getFilter(self):
         return self._filter
 
-    def _setId(self, id):
-        Chunk._setId(self, id)
-        self._filter.setId(id)
+    def _setId(self, new_id):
+        if new_id == self.id:
+            return
+        self._filter.setId(new_id)
+        Chunk._setId(self, new_id)
     id = property(Chunk._getId, _setId)
 
     def _getDescription(self):
@@ -257,25 +262,31 @@
         else:
             text = self._read(config.max_string_length)
             return convertDataToPrintableString(text)
-        
+
 class FormatChunk(Chunk):
-    regex_sub_format = re.compile(r'\{([^}]+)\}')
-
-    def __init__(self, id, description, stream, addr, format, parent):
-        Chunk.__init__(self, id, description, stream, addr, None, parent)
+    def __init__(self, id, description, stream, format, parent):
+        Chunk.__init__(self, id, description, stream, stream.tell(), None, parent)
         self._format = None
         self._doSetFormat(format)
 
     def _doSetFormat(self, format):
         if format == self._format:
             return
+
+        # Add endian if needed
+        splited = splitFormat(format)
+        if splited[0] == None and splited[2] not in &quot;scbB&quot;:
+            endian = self._parent.endian
+            assert endian != None
+            format = endian + format
+            
         self._format = format
-        self._is_string = self.isString()
+        self._real_format = getRealFormat(format)
+        self._is_string = formatIsString(self._format)
         if not self._is_string:
-            count = splitFormat(self._format)[1]
-            self._is_array = (count != 1)
+            self._is_array = (1 &lt; splited[1])
         else:
-            self._is_array = False
+            self._is_array = False 
         self._size = getFormatSize(self._format)
         self._value = {}
        
@@ -295,9 +306,6 @@
     def getSmallFormat(self):
         return self._format
 
-    def isString(self):
-        return self._format[-1] == &quot;s&quot;
-
     def convertToStringSize(self, size):
         self._doSetFormat(&quot;%us&quot; % size)
 
@@ -358,7 +366,7 @@
         if max_size not in self._value:
             data, truncated = self._getRawData(max_size)
             if not truncated:
-                data = struct.unpack(self._format, data)
+                data = struct.unpack(self._real_format, data)
                 if not self._is_array:
                     data = data[0]
             else:
@@ -375,3 +383,102 @@
             return convertDataToPrintableString(data)
         else:
             return data 
+
+class EnumChunk(FormatChunk):
+    def __init__(self, id, description, stream, format, dict, parent):
+        assert formatIsInteger(format)
+        FormatChunk.__init__(self, id, description, stream, format, parent)
+        self._dict = dict
+
+    def getDisplayData(self):
+        value = self.getValue()
+        return self._dict.get(value, &quot;Unknow (%s)&quot; % value)
+
+class BitsStruct(object):
+    size_to_struct = {
+        1: &quot;B&quot;,
+        2: &quot;H&quot;,
+        3: &quot;L&quot;,
+        4: &quot;L&quot;}
+
+    def __init__(self, items=None):
+        self._items_list = []
+        self._items_dict = {}
+        self._size = 0
+        self._source = None
+        if items != None:
+            for item in items:
+                if 3&lt;len(item):
+                    type = item[3]
+                else:
+                    type = None
+                self.add(item[0], item[1], item[2], type)
+            assert self.isValid()
+
+    def isValid(self):
+        return (0 &lt; self._size) and ((self._size % 8) == 0)
+
+    def add(self, bits, id, description, type=None):
+        # TODO: (Maybe) Generate new id if another already exist
+        assert id not in self._items_dict
+        assert 0&lt;bits
+        assert bits &lt;= 32
+        if type == None:
+            if 1&lt;bits:
+                type = &quot;bits&quot;
+            else:
+                type = &quot;bit&quot;
+        self._items_list.append(id)
+        self._items_dict[id] = (self._size, bits, type, description)
+        self._size += bits
+
+    def __getitem__(self, id):
+        assert self.isValid() 
+        item = self._items_dict[id]
+        addr = item[0]
+        size = item[1]
+        data = self._source.getRaw()
+        start = addr / 8
+        shift = addr % 8
+        mask = (1 &lt;&lt; size) - 1
+        byte_size = (size + 7) / 8
+        data = data[start:start+byte_size]
+        type = BitsStruct.size_to_struct[byte_size]
+        value = struct.unpack(type, data)[0]
+        value = (value &gt;&gt; shift) &amp; mask
+        if size == 1:
+            return value == 1
+        else:
+            return value
+
+    def setSource(self, source):
+        self._source = source
+
+    def _getSize(self):
+        assert self.isValid() 
+        return self._size / 8
+    size = property(_getSize)
+
+    def display(self, ui, parent):
+        for id in self._items_list:
+            item = self._items_dict[id]
+            addr = item[0]
+            size = item[1]
+            format = item[2]
+            desc = item[3]
+            display = self[id]
+            ui.add_table(parent, addr, size, format, id, desc, display)
+
+class BitsChunk(Chunk):
+    def __init__(self, id, description, stream, struct, parent):
+        Chunk.__init__(self, id, description, stream, stream.tell(), struct.size, parent)
+        self._struct = struct
+        self._struct.setSource(self)
+        stream.seek(self.size, 1)
+
+    def uiDisplay(self, ui):
+        path = ui.add_table(None, self.addr, self.size, &quot;bits&quot;, self.id, self.description, &quot;*bits*&quot;)
+        self._struct.display(ui, path)
+
+    def __getitem__(self, id):
+        return self._struct[id]

Modified: haypo/hachoir/trunk/default.py
===================================================================
--- haypo/hachoir/trunk/default.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/default.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,10 +1,11 @@
-from filter import Filter
+from filter import OnDemandFilter
+from chunk import FormatChunk
 
-class EmptyFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;empty&quot;, &quot;Empty filter&quot;, stream, parent)
+#class EmptyFilter(OnDemandFilter):
+#    def __init__(self, stream, parent=None):
+#        OnDemandFilter.__init__(self, &quot;empty&quot;, &quot;Empty filter&quot;, stream, parent)
 
-class DefaultFilter(Filter):
+class DefaultFilter(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;default&quot;, &quot;Default filter&quot;, stream, parent)
-        self.read(&quot;data&quot;, &quot;%us&quot; % stream.getSize(), &quot;Data&quot;)
+        OnDemandFilter.__init__(self, &quot;default&quot;, &quot;Default filter&quot;, stream, parent)
+        self.read(&quot;data&quot;, &quot;Raw data&quot;, (FormatChunk, &quot;string[%u]&quot; % stream.getSize()))

Modified: haypo/hachoir/trunk/error.py
===================================================================
--- haypo/hachoir/trunk/error.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/error.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -5,9 +5,10 @@
 from tools import getBacktrace
 
 def warning(message):
+    log_message = message + &quot;\n\n&quot; + getBacktrace()
     if config.debug:
-        message = message + &quot;\n\n&quot; + getBacktrace()
-    log.warning(message)   
+        message = log_message
+    log.warning(log_message)   
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \
@@ -19,9 +20,10 @@
         dlg.destroy()
 
 def error(message, backtrace=None):
+    log_message = message + &quot;\n\n&quot; + getBacktrace()
     if config.debug:
-        message = message + &quot;\n\n&quot; + getBacktrace()
-    log.error(message)
+        message = log_message
+    log.error(log_message)
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \

Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/filter.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -5,13 +5,14 @@
 import struct, re, sys, string, types
 import config
 import ui.ui as ui
-from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
+from chunk import Chunk, FormatChunk, FilterChunk, StringChunk, BitsChunk
 from error import error
-from tools import getBacktrace
-from format import getFormatSize
+from format import getFormatSize, splitFormat
 
-class BasicFilter:
-    def __init__(self, id, description, stream, parent, addr):
+class BasicFilter(object):
+    regex_chunk_uniq_id = re.compile(&quot;^(.*?)([0-9]+)$&quot;)
+
+    def __init__(self, id, description, stream, parent, addr, endian):
         self._id = id
         self._description = description
         self._stream = stream
@@ -19,17 +20,24 @@
         self._addr = addr 
         self._chunks_counter = {}
         self._chunks_dict = {}
+        self._endian = endian
+        self.filter_chunk = None
 
     def updateParent(self, chunk): pass
     def getId(self): return self._id
-    def setId(self, id): self._id = id
+    def setId(self, id):
+        if self._id == id:
+            return
+        self._id = id
+        if self.filter_chunk != None:
+            self.filter_chunk.id = id
     def getDescription(self): return self._description
     def setDescription(self, description): self._description = description
     def getAddr(self): return self._addr
     def setAddr(self, addr): self._addr = addr
     def getParent(self): return self._parent
     def getStream(self): return self._stream
-    def purgeCache(self): pass
+    def updateChunkId(self, old_id, new_id): pass
     def updateChunkDescription(self, id, desc): pass
     def __len__(self): return len(self._chunks_dict)
 
@@ -65,7 +73,7 @@
             pattern = &quot;%s[%u]&quot;
         else:
             # Manage id collision
-            m = Filter.regex_chunk_uniq_id.match(id)
+            m = BasicFilter.regex_chunk_uniq_id.match(id)
             if m != None:
                 root = m.group(1)
                 start = int(m.group(2)) + 1
@@ -88,13 +96,38 @@
     def getChunk(self, chunk_id): assert False
     def display(self): assert False
 
+    def _getEndian(self): return self._endian
+    endian = property(_getEndian)
+
 class OnDemandFilter(BasicFilter):
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
+    def __init__(self, id, description, stream, parent, endian=None):
+        BasicFilter.__init__(self, id, description, stream, parent, stream.tell(), endian)
         self._size = 0
         self._chunks = []
         self._chunks_cache = {}
     
+    def updateChunkId(self, old_id, new_id):
+        # Update self._chunks
+        pos = self._chunks.index(old_id)
+        assert pos != -1
+        self._chunks[pos] = new_id
+
+        # Update self._chunks_dict
+        info = self._chunks_dict[old_id]
+        info[0] = new_id
+        del self._chunks_dict[old_id]
+        self._chunks_dict[new_id] = info
+        
+        # Update self._chunks_dict
+        if old_id in self._chunks_cache:
+            cache = self._chunks_cache[old_id]
+            del self._chunks_cache[old_id]
+            self._chunks_cache[new_id] = cache
+
+        # Update display
+        info = self.displayChunkInfo(new_id)
+        ui.window.update_table(self, pos, *info)
+
     def updateChunkDescription(self, id, desc):
         pos = self._chunks.index(id)
         assert pos != -1
@@ -108,81 +141,78 @@
             print &quot;Purge cache: destroy %s chunks&quot; % len(self._chunks_cache)
         self._chunks_cache = {}
         
-    def doReadChild(self, id, description, filter_class, *args):
-        id = self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        return self.getChunk(id)
-        
-    def readChild(self, id, description, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        
-    def readSizedChild(self, id, description, size, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, size, filter_class, *args)
-        
-    def readStreamChild(self, id, description, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, None, filter_class, *args)
-
-    def readSizedStreamChild(self, id, description, size, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, size, filter_class, *args)
-
-    def _readStreamChild(self, id, description, filter_stream, size, filter_class, *args): 
+    def read(self, id, description, info, optionnal={}): 
+        chunk_class = info[0]
         id = self.getUniqChunkId(id)
         addr = self._stream.tell()
-        filter_addr = filter_stream.tell()
-        
-        if size == None:
-            filter = filter_class(filter_stream, self, *args)
-            description = filter.getDescription()
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            size = filter.getSize()
-            if config.verbose:
-                print &quot;%s: Instanciate filter %s&quot; % (self.getPath(), id)
-        else:
-            chunk = None
+        if issubclass(chunk_class, BasicFilter):
+            filter_stream = optionnal.get(&quot;stream&quot;, self._stream)
+            size = optionnal.get(&quot;size&quot;, None)
+            filter_addr = filter_stream.tell()
+            args = info[1:]
 
-        chunk_info = [id, description, addr, size, \
-                (filter_class, filter_stream, filter_addr, args), None, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        if chunk != None:
-            filter.updateParent(chunk)
-            self._chunks_cache[id] = chunk
-        self._size = self._size + size
-        self._stream.seek(addr + size)
-        return id
+            if size == None:
+                filter = chunk_class(filter_stream, self, *args)
+                description = filter.getDescription()
+                filter.setId(id)
+                chunk = FilterChunk(id, filter, self, addr)
+                size = filter.getSize()
+                if config.verbose:
+                    print &quot;%s: Instanciate filter %s&quot; % (self.getPath(), id)
+            else:
+                chunk = None
 
-    def doRead(self, id, format, description, post=None):
-        id = self.read(id, format, description, post)
-        return self.getChunk(id)
+            chunk_info = [id, description, addr, size, \
+                    (chunk_class, filter_stream, filter_addr, args), None, {}]
+            self._chunks_dict[id] = chunk_info
+            self._chunks.append(id)
+            if chunk != None:
+                filter.updateParent(chunk)
+                self._chunks_cache[id] = chunk
+            self._size = self._size + size
+            self._stream.seek(addr + size)
+            return id
 
-    def read(self, id, format, description, post=None):
-        id = self.getUniqChunkId(id)
-        size = getFormatSize(format)
-        addr = self._stream.tell()
-        chunk_info = [id, description, addr, size, \
-                (FormatChunk, id, description, self._stream, addr, format, self,), post, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
+        else:
+            post = optionnal.get(&quot;post&quot;, None)
+            if &quot;post&quot; in optionnal:
+                del optionnal[&quot;post&quot;]
+            if isinstance(info, list):
+                args = info[1:]
+            else:
+                args = [ i for i in info[1:] ]
+            instance_info = [info[0], id, description, self._stream]+args+[self]
+            # TODO: Use static method to get chunk fixed size (if existing)
+            if chunk_class == FormatChunk:
+                size = getFormatSize(info[1])
+                self._stream.seek(size, 1)
+            else:
+                seek = False
+                chunk = info[0] (*instance_info[1:], **optionnal)
+                size = chunk.size
+                id = chunk.id
+                self._chunks_cache[id] = chunk
+            chunk_info = [id, description, addr, size, instance_info, post, optionnal]
+#            else:       
+#                assert chunk_class == StringChunk
+#                strip = optionnal.get(&quot;strip&quot;, None)
+#                chunk = chunk_class (id, description, self._stream, info[1:], self, strip=strip)
+#                chunk_info = [id, description, addr, size, \
+#                        (info[0], id, description, self._stream, info[1:], self,), post, optionnal]
+#                self._chunks_cache[id] = chunk
+            self._chunks_dict[id] = chunk_info
+            self._chunks.append(id)
+            self._size = self._size + size
+            return id
 
-    def readString(self, id, format, description, post=None, strip=None):
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
+    def doRead(self, id, description, info, optionnal={}):
+        id = self.read(id, description, info, optionnal)
+        chunk = self.getChunk(id)
+        if isinstance(chunk, FilterChunk):
+            return chunk.getFilter()
+        else:
+            return chunk
 
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        size = chunk.size
-
-        chunk_info = [id, description, addr, size, \
-                (StringChunk, id, description, self._stream, format, self,), post, {&quot;strip&quot;: strip}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._chunks_cache[id] = chunk
-#        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
-
     def displayChunkInfo(self, id):
         info = self._chunks_dict[id]
         chunk_class = info[4][0]
@@ -202,7 +232,10 @@
         ui.window.clear_table()
         for id in self._chunks:
             info = self.displayChunkInfo(id)
-            ui.window.add_table(*info)
+            if self._chunks_dict[id][4][0] == BitsChunk:
+                self.getChunk(id).uiDisplay(ui.window)
+            else:
+                ui.window.add_table(*info)
  
     def getSize(self): return self._size
 
@@ -238,8 +271,11 @@
         if id not in self._chunks_dict:
             return None
         if id not in self._chunks_cache:
-            self._chunks_cache[id] = self._createInstance(id) 
-        return self._chunks_cache[id]
+            chunk = self._createInstance(id) 
+            self._chunks_cache[chunk.id] = chunk 
+            return chunk
+        else:
+            return self._chunks_cache[id]
 
     def __getitem__(self, id):
         assert id in self._chunks_dict
@@ -249,440 +285,11 @@
         else:
             return chunk.value
 
-class Filter(BasicFilter):
-    regex_chunk_uniq_id = re.compile(&quot;^(.*?)([0-9]+)$&quot;)
-
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self.filter_chunk = None 
-        self._chunks = []
-        self._chunks_dict = {}
-        self._cache_valid = False
-        self._cache_size = None
-
-    def __getitem__(self, chunk_id):
-        return self.getChunk(chunk_id).getValue()
-
-    def clone(self, addr=None):
-        if self.__class__ == Filter:
-            return None
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        try:
-            new = self.__class__(self.getStream(), self.getParent())
-        except:
-            error(&quot;Error while clone class of type %s!&quot; % self.__class__)
-            raise
-        new.filter_chunk = self.filter_chunk
-        return new
-
-    def _deleteChunk(self, pos):
-        self._cache_valid = False
-        chunk = self._chunks[pos]
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)        
-        del self._chunks[pos]
-
-    def deleteChunk(self, chunk):
-        if len(self._chunks) &lt; 2:
-            error(&quot;Can't not delete the chunk %s (there is only one chunk).&quot; % chunk.id)
-            return            
-        chunk_size = chunk.size
-        pos = self._chunks.index(chunk)
-        self._deleteChunk(pos)
-        # Delete last chunk of a sub filter? It true, truncate the sub filter
-        truncate = (self.getParent() != None and pos == len(self._chunks))
-        self.rescanFromPos(pos, -chunk_size, truncate=truncate)
-        self.redisplay()
-
-    def getChunks(self):
-        return self._chunks
-
-    def updateChunkId(self, chunk, new_id):
-        if chunk.id == new_id: return
-        if new_id in self._chunks_dict or hasattr(self, new_id):
-            raise Exception(&quot;Chunk identifier \&quot;%s\&quot; already exist!&quot; % new_id)
-        if hasattr(self, chunk.id):
-            value = getattr(self, chunk.id)
-            delattr(self, chunk.id)
-            setattr(self, new_id, value)
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        self._chunks_dict[new_id] = chunk
-        
-    def addRawChunk(self, prev_chunk, id, size, description):
-        if prev_chunk != None:
-            addr = prev_chunk.addr + prev_chunk.size
-            chunk_pos = self._chunks.index(prev_chunk)+1
-        else:
-            addr = self.getAddr()
-            chunk_pos = len(self._chunks)
-        chunk = FormatChunk(id, description, self.getStream(), addr, &quot;!%ss&quot; % size, self)
-        self.appendChunk(chunk, position=chunk_pos)
-
-    def rescan(self, from_chunk, diff_size, new_id=None, new_description=None, truncate=False):
-        if from_chunk != None:
-            start = self._chunks.index(from_chunk)+1
-        else:
-            start = 0
-        self.rescanFromPos(start, diff_size, new_id, new_description, truncate)
-            
-    def _rescanUpdateSize(self, diff_size, new_id=None, new_description=None):
-        # Only process diff_size &lt; 0
-        if 0 &lt;= diff_size: return
-
-        # Get last chunk
-        if 0 &lt; len(self._chunks):
-            prev_chunk = self._chunks[-1]
-        else:
-            prev_chunk = None
-        
-        if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
-            # If last chunk is a FormatChunk, update it's size
-            size = prev_chunk.size - diff_size
-            prev_chunk.convertToStringSize(size)
-            self._cache_valid = False
-        else:
-            # Get id
-            if new_id != None:
-                id = new_id
-            else:
-                id = &quot;raw&quot;
-            id = self.getUniqChunkId(id)
-
-            # Get description
-            if new_description != None:
-                description = new_description
-            else:
-                description = &quot;&quot;
-
-            # Get size
-            if self.getParent() == None:
-                size = self._stream.getSize() - self.getSize() 
-            else:
-                size = -diff_size
-            self.addRawChunk(prev_chunk, id, size, description)
-
-    def _rescanUpdateChunks(self, start, prev_chunk):
-        self._cache_valid = False
-        pos = start
-        try:
-            for chunk in self._chunks[start:]:
-                # Update start address
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error(&quot;Exception while updating a filter:\n%s\n%s&quot; \
-                % (msg,getBacktrace()))
-            iter = len(self._chunks)-1
-            while pos&lt;=iter:
-                self._deleteChunk(iter)
-                iter = iter - 1
-
-    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate=False):
-        assert 0&lt;=start and start &lt;= len(self._chunks)
-        self._cache_valid = False
-        if 0&lt;start:
-            prev_chunk = self._chunks[start-1]
-        else:
-            prev_chunk = None
-
-        # Update chunks address
-        old_size = self.getSize()
-        self._rescanUpdateChunks(start, prev_chunk)
-        diff_size = diff_size + (self.getSize() - old_size)
-
-        # Update last chunk size if needed
-        if not truncate:
-            self._rescanUpdateSize(diff_size, new_id, new_description)
-            diff_size = 0
-               
-        if self.getParent() != None:
-            self.getParent().rescan(self.filter_chunk, diff_size)
-
-    def getLastPos(self):
-        if len(self._array) == 0: return self.getAddr()
-        last_chunk = self._array[-1]
-        return last_chunk.addr + last_chunk.size
-
-    def getSize(self):
-        if not self._cache_valid:
-            self._cache_valid = True
-            size = 0
-            for chunk in self._chunks:
-                size = size + chunk.size
-            self._cache_size = size
-        return self._cache_size
-
-    def addString(self, str_type, before_chunk):
-        if before_chunk != None:
-            pos = self._chunks.index(before_chunk)
-            addr = before_chunk.addr
-        else:
-            pos = len(self._chunks)
-            addr = self.getAddr()
-        stream = self.getStream()
-        stream.seek(addr)
-        id = self.getUniqChunkId(&quot;str&quot;)
-        str_chunk = StringChunk(id, &quot;String&quot;, stream, str_type, self)
-        self.appendChunk(str_chunk, position=pos)
-        str_chunk.postProcess()
-        before_chunk.addr = before_chunk.addr + str_chunk.size
-        before_chunk.convertToStringSize(before_chunk.size - str_chunk.size)
-        self.redisplay()
-        return str_chunk
-
-    def updateParent(self, chunk):
-        pass
-
-    def getChunk(self, chunk_id):
-        chunk = self._chunks_dict.get(chunk_id, None)
-        if chunk == None:
-            raise Exception(&quot;Filter \&quot;%s\&quot; has no chunk with id \&quot;%s\&quot;.&quot; \
-                % (self.getId(), chunk_id))
-        return chunk
-
-    def displayChunk(self, chunk):
-        type = chunk.getSmallFormat()
-        if isinstance(chunk, FilterChunk):
-            addr = chunk.parent_addr
-        else:
-            addr = chunk.addr
-        ui.window.add_table(None, addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
-
-    def redisplay(self):  
-        self.display()
-    
-    def display(self):  
-        ui.window.enableParentButton(self.getParent() != None)
-            
-        # Update table
-        ui.window.clear_table()
-        for chunk in self._chunks:
-            self.displayChunk(chunk)
-
-    def readField(self, id, description, delimiter):
-        lg = self._stream.searchLength(delimiter, False)
-        if lg == -1:
-            raise Exception(&quot;Delimiter \&quot;%s\&quot; not found for %s (%s)!&quot; % (delimiter, id, description))
-        self.read(id, &quot;!%us&quot; % lg, description) 
-        self.read(id+&quot;_delimiter&quot;, &quot;!%us&quot; % len(delimiter), &quot;Delimiter of %s&quot; % id) 
-
-    def searchEol(self, eol):
-        lg = self._stream.searchLength(eol, True)
-        if lg == -1:
-            return self._stream.getLastPos() - self._stream.tell()
-        else:
-            return lg
-
-    def readLine(self, id, description, eol=&quot;\n&quot;, fails_if_not_found=False, can_truncate=False):
-        lg = self.searchEol(eol)
-        self.read(id, &quot;!%us&quot; % lg, description, truncate=can_truncate)
-        line = getattr(self, id)
-        setattr(self, id, line[:-len(eol)])
-
-    def updateFormatChunk(self, chunk):
-        if chunk.id == None: return
-        self._cache_valid = False
-        data = chunk.getValue(config.max_string_length)
-        setattr(self, chunk.id, data)       
-
-    def appendChunk(self, chunk, position=None):
-        self._cache_valid = False
-        if position == None:
-            self._chunks.append(chunk)
-        else:
-            self._chunks.insert(position, chunk)
-        self._chunks_dict[chunk.id] = chunk
-
-    def readLimitedChild(self, id, size, filter_class, *args):
-        start = self._stream.tell()
-        limited = self._stream.createLimited(start, size)
-        chunk = self.readStreamChild(id, limited, filter_class, *args)
-        assert self._stream.tell() == (start+size)
-        return chunk
-        
-    def readStreamChild(self, id, stream, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        oldpos = self._stream.tell()
-        filter = filter_class(stream, self, *args)
-        filter.setId(id)
-        chunk = self.addFilter(id, filter, oldpos)
-        chunk.postProcess()
-        self._stream.seek(oldpos + chunk.size)
-        return chunk
-        
-    def readChild(self, id, filter_class, *args): 
-        return self.readStreamChild(id, self._stream, filter_class, *args)
-    
-    def addFilter(self, id, filter, addr): 
-        chunk = FilterChunk(id, filter, self, addr)
-        self.appendChunk(chunk)
-        filter.updateParent(chunk)
-        return chunk
-
-    def readArray(self, id, entry_class, description, end_func): 
-        &quot;&quot;&quot;
-        end_func: def isEnd(stream, array, last_filter)
-        &quot;&quot;&quot;
-        addr = self._stream.tell()
-        filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
-        chunk = self.addFilter(id, filter, addr)
-        chunk.postProcess()
-        return chunk
-    
-    def readString(self, id, format, description, post=None, strip=None):
-        &quot;&quot;&quot; Returns chunk &quot;&quot;&quot;
-        id = self.getUniqChunkId(id)
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-    
-    def read(self, id, format, description, post=None):
-        &quot;&quot;&quot; Returns chunk &quot;&quot;&quot;
-        id = self.getUniqChunkId(id)
-        chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-
-    def __str__(self):
-        return &quot;Filter(%s) &lt;id=%s, description=%s&gt;&quot; % \
-            (self.__class__, self.getId(), self.getDescription())
-
-    def addNewFilter(self, chunk, id, size, desc):
-        chunk.setFormat(&quot;%us&quot; % size, &quot;split&quot;, id, desc)
-        self.convertChunkToFilter(chunk)
-
-    def convertFilterToChunk(self, chunk):
-        # Create new format chunk
-        filter = chunk.getFilter()
-        id = self.getUniqChunkId(filter.getId())
-        new_chunk = FormatChunk(id, filter.getDescription(), filter.getStream(), filter.getAddr(), &quot;!%us&quot; % filter.getSize(), self)
-
-        # Delete old chunk
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)
-
-        # Assign new chunk
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[id] = new_chunk
-        setattr(self, id, chunk.getValue(40))
-        self.redisplay()
-        return new_chunk 
-
-    def convertChunkToFilter(self, chunk):
-        # Create new filter
-        stream = self.getStream()
-        stream.seek(chunk.addr)
-        filter = Filter(chunk.id, chunk.description, stream, self)
-        chunk.setParent(filter)
-        filter.appendChunk(chunk)
-        
-        # Create new chunk and add it into self 
-        new_chunk = FilterChunk(chunk.id, filter, self, chunk.addr)
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[chunk.id] = new_chunk
-        self.redisplay()
-        return filter
-
-class ArrayFilter(Filter):
-    def __init__(self, id, description, stream, parent, entry_class, end_func):
-        Filter.__init__(self, id, description, stream, parent)
-        self._entry_class = entry_class
-        self._end_func = end_func
-        self._read()
-
-    def _read(self):
-        self._array = []
-        nb = 0
-        last_filter = None
-        while not self._end_func(self._stream, self._array, last_filter):
-            chunk_id = &quot;%s[%u]&quot; % (self.getId(), nb)
-            addr = self._stream.tell()
-            filter = self._entry_class(self._stream, self)
-            filter.setId(chunk_id)
-            nb = nb + 1
-            chunk = FilterChunk(chunk_id, filter, self, addr)
-            self._array.append( chunk )
-            self.appendChunk(chunk)
-            last_filter = filter
-
-        for chunk in self._array:
-            chunk.getFilter().updateParent(chunk)
-        if 1&lt;nb:
-            self.setDescription( &quot;%s (%s items)&quot; % (self.getDescription(), nb))
-        else:
-            self.setDescription( &quot;%s (%s item)&quot; % (self.getDescription(), nb))
-
-    def getArray(self):
-        return self._array
-    
-    def _deleteChunk(self, pos):
-        Filter._deleteChunk(self, pos)
-        if pos &lt; len(self._array):
-            del self._array[pos]
-
-    def update(self):
-        self._cache_valid = False
-        prev_chunk = None
-        pos = 0
-        try:
-            for chunk in self._array:
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error(&quot;Exception while updating an ArrayFilter:\n%s&quot; % msg)
-            chunk = self._array[pos]
-            addr = chunk.addr
-            size = self.getLastPos() - addr
-            del self._array[pos:]
-            if size != 0:
-                chunk = FormatChunk(&quot;raw&quot;, &quot;Raw data&quot;, chunk.getStream(), addr, &quot;!%us&quot; % size, self)
-                self._array.append(chunk)
-
-    def __len__(self):
-        return len(self._array)
-
-    def __getitem__(self, index):
-        return self._array[index]
-
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        new = ArrayFilter( self.getId(), self.getDescription(), \
-            self.getStream(), self.getParent(), self._entry_class, self._end_func)
-        new.filter_chunk = self.filter_chunk
-        return new
-
-class DeflateFilter(Filter):
+class DeflateFilter(OnDemandFilter):
     def __init__(self, stream, parent, bz_stream, size, filter, *args):
-        Filter.__init__(self, &quot;deflate&quot;, &quot;Deflate&quot;, bz_stream, parent)
+        OnDemandFilter.__init__(self, &quot;deflate&quot;, &quot;Deflate&quot;, bz_stream, parent)
         self._addr = stream.tell()
-        self.readChild(&quot;data&quot;, filter, *args)
+        self.read(&quot;data&quot;, &quot;Data&quot;, [filter]+[i for i in args])
         self._compressed_size = size
 
     def getSize(self):

Modified: haypo/hachoir/trunk/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/format.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,40 +1,74 @@
 import re, struct
 
-_regex_format1 = re.compile(&quot;^[!&lt;&gt;]?(?:[0-9]+|\{[<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">a-z at _</A>]+\})?[BHLbhscfd]$&quot;)
-_regex_format2 = re.compile(&quot;^([!&lt;&gt;]?)((?:[0-9]+|\{[<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">a-z at _</A>]+\})?)([BHLbhscfd])$&quot;)
+_regex_array =  re.compile(&quot;^([a-z]+[0-9]*)\[([0-9]+)\]$&quot;)
 _format_size_cache = {}
+_format_type = {
+    &quot;string&quot;: &quot;s&quot;,
+    &quot;char&quot;: &quot;c&quot;,
+    &quot;float&quot;: &quot;f&quot;,
+    &quot;double&quot;: &quot;d&quot;,
+    &quot;int8&quot;: &quot;b&quot;,
+    &quot;uint8&quot;: &quot;B&quot;,
+    &quot;int16&quot;: &quot;h&quot;,
+    &quot;uint16&quot;: &quot;H&quot;,
+    &quot;int32&quot;: &quot;l&quot;,
+    &quot;uint32&quot;: &quot;L&quot;
+}
 
+def _convertNewFormat(format):
+    old_format = format
+    if format[0] in &quot;!&lt;&gt;&quot;:
+        endian = format[0]
+        str_endian = format[0]
+        format = format[1:]
+    else:
+        endian = None
+        str_endian = &quot;&quot;
+    m = _regex_array.match(format)
+    if m != None:
+        format = m.group(1)
+        str_count = m.group(2)
+        count = int(str_count)
+    else:
+        str_count = &quot;&quot; 
+        count = 1
+    if format not in _format_type:
+        raise Exception(&quot;Format \&quot;%s\&quot; is invalid!&quot; % old_format)
+    type = _format_type[format]
+    return (str_endian + str_count + type, endian, count, type)
+
 def _getFormatCache(format):
     global _format_size_cache
     if format not in _format_size_cache:
-        assert checkFormat(format)
-        endian, count, type = _doSplitFormat(format)
+        real_format, endian, count, type = _convertNewFormat(format)
         size = count * struct.calcsize(type)
-        _format_size_cache[format] = (endian, count, type, size)
+        _format_size_cache[format] = (real_format, endian, count, type, size)
     return _format_size_cache[format]   
 
+def formatIsString(format):
+    cache = _getFormatCache(format)
+    return cache[3] == &quot;s&quot;
+
+def formatIsInteger(format):
+    cache = _getFormatCache(format)
+    return cache[3] in &quot;bBhHlL&quot;
+
 def getFormatSize(format):
     cache = _getFormatCache(format)
-    return cache[3]   
+    return cache[4]   
 
+def getRealFormat(format):
+    cache = _getFormatCache(format)
+    return cache[0]   
+
 def checkFormat(format):
-    m = _regex_format1.match(format)
-    return m != None
+    # TODO: Don't use try/except, but something better
+    try:
+        conv = _convertNewFormat(format)
+        return True
+    except:
+        return False
 
 def splitFormat(format):
     cache = _getFormatCache(format)
-    return cache[:3]   
-
-def _doSplitFormat(format):
-    m = _regex_format2.match(format)
-    assert m != None
-    endian = m.group(1)
-    count = m.group(2)
-    type = m.group(3)
-    if endian == &quot;&quot;:
-        endian = &quot;!&quot;
-    if count != &quot;&quot;:
-        count = long(count)
-    else:
-        count = 1
-    return (endian, count, type,)
+    return cache[1:4]   

Added: haypo/hachoir/trunk/generic/__init__.py
===================================================================

Added: haypo/hachoir/trunk/generic/image.py
===================================================================
--- haypo/hachoir/trunk/generic/image.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/generic/image.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -0,0 +1,20 @@
+from chunk import FormatChunk
+from filter import OnDemandFilter
+
+class RGB(OnDemandFilter):
+    name = {
+        0x000000: &quot;Black&quot;,
+        0xFFFFFF: &quot;White&quot;
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, &quot;rgb_color&quot;, &quot;RGB color&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;red&quot;, &quot;Red&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;green&quot;, &quot;Green&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;blue&quot;, &quot;Blue&quot;, (FormatChunk, &quot;uint8&quot;))
+
+    def updateParent(self, chunk):
+        value = self[&quot;red&quot;] &lt;&lt; 16 + self[&quot;green&quot;] &lt;&lt; 8 + self[&quot;blue&quot;]
+        if value in RGB.name:
+            chunk.description = &quot;RGB color: &quot;+RGB.name[value]
+        else:
+            chunk.description = &quot;RGB color: #%02X%02X%02X&quot; % (self[&quot;red&quot;], self[&quot;green&quot;], self[&quot;blue&quot;])

Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/hachoir.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -129,9 +129,7 @@
     except SystemExit:
         pass
     except Exception, err:
-        where = &quot;&quot;.join(traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback))
-        error(&quot;Exception:\n%s\n%s&quot; % (err, where))
+        error(&quot;Python Exception: %s&quot; % err)
 	sys.exit(1)
 
 if __name__==&quot;__main__&quot;: main()    

Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/hachoir_class.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,6 +1,6 @@
 from stream.file import FileStream
 from plugin import getPluginByStream
-from chunk import FilterChunk
+from chunk import FilterChunk, FormatChunk
 from default import DefaultFilter
 from user_filter import UserFilterDescriptor, loadUserFilter
 from error import error, warning
@@ -88,7 +88,8 @@
         stream_size = self._main_filter.getStream().getSize()
         diff_size = filter_size - stream_size
         if diff_size &lt; 0:
-            self._main_filter.read(&quot;end&quot;, &quot;%us&quot; % (-diff_size), &quot;Raw data&quot;)
+            print &quot;Pad&quot;, &quot;string[%u]&quot; % -diff_size
+            self._main_filter.read(&quot;end&quot;, &quot;Raw data&quot;, (FormatChunk, &quot;string[%u]&quot; % -diff_size))
 
     def loadFile(self, filename):
         try:

Deleted: haypo/hachoir/trunk/plugins/3ds.py
===================================================================
--- haypo/hachoir/trunk/plugins/3ds.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/3ds.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,175 +0,0 @@
-&quot;&quot;&quot;
-3D Studio Max file (.3ds) parser.
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter, OnDemandFilter
-from plugin import registerPlugin
-
-def readTextureFilename(filter, stream, last_pos):
-    filter.readString(&quot;filename&quot;, &quot;C&quot;, &quot;Texture filename&quot;)
-
-def readVersion(filter, stream, last_pos):
-    filter.read(&quot;version&quot;, &quot;&lt;L&quot;, &quot;Version&quot;)
-
-def readMaterialName(filter, stream, last_pos):
-    filter.readString(&quot;name&quot;, &quot;C&quot;, &quot;Material name&quot;)
-
-def readObject(filter, stream, last_pos):
-    chunk = filter.readString(&quot;name&quot;, &quot;C&quot;, &quot;Object name&quot;)
-    while stream.tell() &lt; last_pos:
-        filter.readChild(&quot;chunk[]&quot;, &quot;Chunk&quot;, Filter_3DS_Chunk)
-
-class Filter_3DS_MapUV(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;3ds_map&quot;, &quot;3DS UV map&quot;, stream, parent)
-        self.read(&quot;u&quot;, &quot;f&quot;, &quot;Map U&quot;)
-        self.read(&quot;v&quot;, &quot;f&quot;, &quot;Map V&quot;)
-
-class Filter_3DS_Vertex(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;3ds_vertex&quot;, &quot;3DS vertex&quot;, stream, parent)
-        self.read(&quot;x&quot;, &quot;f&quot;, &quot;X&quot;)
-        self.read(&quot;y&quot;, &quot;f&quot;, &quot;Y&quot;)
-        self.read(&quot;z&quot;, &quot;f&quot;, &quot;Z&quot;)
-
-class Filter_3DS_Polygon(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;3ds_polygon&quot;, &quot;3DS polygon&quot;, stream, parent)
-        self.read(&quot;a&quot;, &quot;&lt;H&quot;, &quot;Vertex A&quot;)
-        self.read(&quot;b&quot;, &quot;&lt;H&quot;, &quot;Vertex B&quot;)
-        self.read(&quot;c&quot;, &quot;&lt;H&quot;, &quot;Vertex C&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;Flags&quot;)
-    
-def readMapList(filter, stream, last_pos):
-    filter.read(&quot;count&quot;, &quot;&lt;H&quot;, &quot;Map count&quot;)
-    for i in range(0, filter[&quot;count&quot;]):
-        filter.readSizedChild(&quot;map[]&quot;, &quot;Map UV&quot;, 2*4, Filter_3DS_MapUV)
-
-def readColor(filter, stream, last_pos):
-    filter.read(&quot;red&quot;, &quot;B&quot;, &quot;Red componant&quot;)
-    filter.read(&quot;green&quot;, &quot;B&quot;, &quot;Green componant&quot;)
-    filter.read(&quot;blue&quot;, &quot;B&quot;, &quot;Blue componant&quot;)
-
-def readVertexList(filter, stream, last_pos):
-    filter.read(&quot;count&quot;, &quot;&lt;H&quot;, &quot;Vertex count&quot;)
-    for i in range(0, filter[&quot;count&quot;]):
-        filter.readSizedChild(&quot;vertex[]&quot;, &quot;Vertex&quot;, 3*4, Filter_3DS_Vertex)
-    
-def readPolygonList(filter, stream, last_pos):
-    filter.read(&quot;count&quot;, &quot;&lt;H&quot;, &quot;Vertex count&quot;)
-    for i in range(0, filter[&quot;count&quot;]):
-        filter.readSizedChild(&quot;polygon[]&quot;, &quot;Polygon&quot;, 4*2, Filter_3DS_Polygon)
-    while stream.tell() &lt; last_pos:
-        filter.readChild(&quot;chunk[]&quot;, &quot;Chunk&quot;, Filter_3DS_Chunk)
-
-class Filter_3DS_Chunk(OnDemandFilter):
-    # List of chunk type name
-    type_name = {
-        0x0011: &quot;Color&quot;,
-        0x4D4D: &quot;Main chunk&quot;,
-        0x0002: &quot;File version&quot;,
-        0x3D3D: &quot;Materials and objects&quot;,
-        0x4000: &quot;Object&quot;,
-        0x4100: &quot;Mesh (triangular)&quot;,
-        0x4110: &quot;Vertices list&quot;,
-        0x4120: &quot;Polygon (faces) list&quot;,
-        0x4140: &quot;Map UV list&quot;,
-        0x4130: &quot;Object material&quot;,
-        0xAFFF: &quot;New material&quot;,
-        0xA000: &quot;Material name&quot;,
-        0xA010: &quot;Material ambiant&quot;,
-        0xA020: &quot;Material diffuse&quot;,
-        0xA030: &quot;Texture specular&quot;,
-        0xA200: &quot;Texture&quot;,
-        0xA300: &quot;Texture filename&quot;,
-
-        # Key frames
-        0xB000: &quot;Keyframes&quot;,
-        0xB002: &quot;Object node tag&quot;,
-        0xB006: &quot;Light target node tag&quot;,
-        0xB007: &quot;Spot light node tag&quot;,
-        0xB00A: &quot;Keyframes header&quot;,
-        0xB009: &quot;Keyframe current time&quot;,
-        0xB030: &quot;Node identifier&quot;,
-        0xB010: &quot;Node header&quot;,
-        0x7001: &quot;Viewport layout&quot;
-    }
-
-    chunk_id_by_type = {
-        0x4d4d: &quot;main&quot;,
-        0x0002: &quot;version&quot;,
-        0x3d3d: &quot;obj_mat&quot;,
-        0xb000: &quot;keyframes&quot;,
-        0xafff: &quot;material&quot;,
-        0x4000: &quot;object&quot;
-    }
-
-    # List of chunks which contains other chunks
-    sub_chunks = \
-        (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
-         0xB002, 0xB006, 0xB007,
-         0xA010, 0xA030, 0xA020, 0xB000)
-
-    # List of chunk type handlers
-    handlers = {
-        0xA000: readMaterialName,
-        0x4000: readObject,
-        0xA300: readTextureFilename,
-        0x0011: readColor,
-        0x0002: readVersion,
-# TODO: Uncomment these functions, it's too slow yet            
-         0x4110: readVertexList,
-         0x4120: readPolygonList,
-         0x4140: readMapList
-    }
-    
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;3ds_chunk&quot;, &quot;3DS chunk&quot;, stream, parent)
-        chunk = self.doRead(&quot;type&quot;, &quot;&lt;H&quot;, &quot;Chunk type&quot;, post=self.toHex)
-        chunk.description = &quot;Chunk type (%s)&quot; % self.getType()
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Chunk size&quot;)
-        size = self[&quot;size&quot;] - 6
-        type = self[&quot;type&quot;] 
-        end = stream.tell() + size
-        if type in Filter_3DS_Chunk.sub_chunks:
-            while stream.tell() &lt; end:
-                self.readChild(&quot;chunk[]&quot;, &quot;Chunk&quot;, Filter_3DS_Chunk)
-            assert stream.tell() == end 
-        else:
-            if type in Filter_3DS_Chunk.handlers: 
-                end = stream.tell() + size
-                Filter_3DS_Chunk.handlers[type] (self, stream, end)
-                assert stream.tell() == end
-            else:
-                self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;Raw data&quot;)
-
-    def checkEnd(self, stream, array, last):
-        return stream.eof()
-
-    def updateParent(self, chunk):
-        type = self.getType()
-        chunk.description = &quot;Chunk of type \&quot;%s\&quot;&quot; % type
-        self.setDescription(&quot;Chunk type (%s)&quot; % type)
-        if self[&quot;type&quot;] in Filter_3DS_Chunk.chunk_id_by_type:
-            id = Filter_3DS_Chunk.chunk_id_by_type[self[&quot;type&quot;]]
-# TODO: Re-enable that            
-#            chunk.id = id
-            self.setId(id) 
-        else:
-            self.setId(&quot;chunk_%04x&quot; % self[&quot;type&quot;])
-
-    def toHex(self, chunk):
-        return &quot;%04X&quot; % chunk.value
-        
-    def getType(self):
-        type = self[&quot;type&quot;]
-        return Filter_3DS_Chunk.type_name.get(type, &quot;%04X&quot; % type)
-
-class Filter_3DS_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;3ds_file&quot;, &quot;3DS file&quot;, stream, parent)
-        while not stream.eof():
-            self.readChild(&quot;chunk[]&quot;, Filter_3DS_Chunk)
-
-registerPlugin(Filter_3DS_File, &quot;image/x-3ds&quot;)

Deleted: haypo/hachoir/trunk/plugins/ar.py
===================================================================
--- haypo/hachoir/trunk/plugins/ar.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/ar.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,39 +0,0 @@
-&quot;&quot;&quot;
-GNU ar archive : archive file (.a) and Debian (.deb) archive.
-&quot;&quot;&quot;
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin, guessPlugin
-from error import error
-   
-class ArchiveFileEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;file_entry&quot;, &quot;File entry&quot;, stream, parent)
-        self.readString(&quot;header&quot;, &quot;UnixLine&quot;, &quot;Header&quot;)
-        info = self[&quot;header&quot;].split()
-        assert len(info) == 7
-        self.filename = info[0]
-        self.size = int(info[5])
-        dataio = stream.createSub(stream.tell(), self.size)
-        plugin = guessPlugin(dataio, self.filename)
-        self.readChild(&quot;data&quot;, DeflateFilter, dataio, self.size, plugin)
-
-    def updateParent(self, chunk):
-        desc = &quot;File entry (%s)&quot; % self.filename
-        chunk.description = desc
-        self.setDescription(desc)
-        
-class ArchiveFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;ar_file&quot;, &quot;GNU ar file&quot;, stream, parent)
-        self.readString(&quot;id&quot;, &quot;UnixLine&quot;, &quot;ar archive identifier&quot;)
-        while not stream.eof():
-            while True:
-                data = stream.read(1, False)
-                if data == &quot;\n&quot;:
-                    self.readString(&quot;empty_line[]&quot;, &quot;UnixLine&quot;, &quot;Empty line&quot;)
-                else:
-                    break
-            self.readChild(&quot;file[]&quot;, ArchiveFileEntry)
-        
-registerPlugin(ArchiveFile, [&quot;application/x-debian-package&quot;, &quot;application/x-archive&quot;])

Deleted: haypo/hachoir/trunk/plugins/asn1.py
===================================================================
--- haypo/hachoir/trunk/plugins/asn1.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/asn1.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,92 +0,0 @@
-&quot;&quot;&quot;
-ASN1 Parser
-
-Information: <A HREF="http://www.openssl.org/docs/apps/asn1parse.html">http://www.openssl.org/docs/apps/asn1parse.html</A>
-
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-
-class ASN1_Sequence(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;asn1_seq&quot;, &quot;ASN1 sequence&quot;, stream, parent)
-        self.readArray(&quot;item&quot;, ASN1_Object, &quot;Items&quot;, self.checkEnd)
-
-    def checkEnd(self, stream, array, last):        
-        return stream.eof()
-
-class ASN1_Object(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;asn1_obj&quot;, &quot;ASN1 object&quot;, stream, parent)
-        
-        import sys
-        sys.stdout.write(&quot;%s: &quot; % stream.tell())
-        
-        self.read(&quot;type&quot;, &quot;B&quot;, &quot;type&quot;)
-        tag = self.type &amp; 0x1f
-        if tag == 0x1f:
-            raise Exception(&quot;Error in ASN1 parser: TODO ...&quot;)
-        else:
-            length = stream.getFormat(&quot;B&quot;, False)[0]
-            if 128 &lt;= length:
-                size = length &amp; 0x7f 
-                length = 0
-                oldpos = stream.tell()
-                for i in range(0,size):
-                    stream.seek(oldpos+1+i)
-                    new = stream.getFormat(&quot;B&quot;, False)[0]
-                    length = length * 256 + new
-                    assert length &lt; (1 &lt;&lt; 32)
-                stream.seek(oldpos)
-                self.length = length
-                self.read(&quot;dummylength&quot;, &quot;%uB&quot; % (1+size), &quot;Length&quot;)
-            else:
-                self.read(&quot;length&quot;, &quot;B&quot;, &quot;Length&quot;)
-            print &quot;Length = %s&quot; % self.length
-            self.getChunk(&quot;type&quot;).description = &quot;type (tag=%s)&quot; % tag
-            handler = {
-                0: self.readEOC,
-                1: self.readBoolean,
-                4: self.readOctetString,
-#                6: self.readObject,
-                10: self.readEnum,
-                12: self.readUTF8,
-                16: self.readSequence
-            }
-            if tag in handler:
-                handler[tag]()
-            else:
-                self.read(&quot;value&quot;, &quot;%us&quot; % length, \
-                    &quot;Value (don't know tag %s)&quot; % tag)
-
-    def readEnum(self):
-        self.read(&quot;value&quot;, &quot;%us&quot; % self.length, &quot;Value (EOC)&quot;)
-
-    def readObject(self):
-        self.readChild(&quot;object&quot;, ASN1_Object)
-
-    def readEOC(self):
-        self.read(&quot;value&quot;, &quot;%us&quot; % self.length, &quot;Value (EOC)&quot;)
-
-    def readOctetString(self):
-        self.read(&quot;value&quot;, &quot;%us&quot; % self.length, &quot;Value (octet string)&quot;)
-
-    def readBoolean(self):
-        self.read(&quot;value&quot;, &quot;B&quot;, &quot;Value (boolean)&quot;)
-
-    def readUTF8(self):
-        self.read(&quot;value&quot;, &quot;%us&quot; % self.length, &quot;Value (string)&quot;)
-        
-    def readSequence(self):
-        self.readLimitedChild(&quot;sequence&quot;, self.length, ASN1_Sequence)
-
-class ASN1_Parser(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;asn1&quot;, &quot;ASN1 parser&quot;, stream, parent)
-        #self.readArray(&quot;item&quot;, ASN1_Object, &quot;Items&quot;, self.checkEnd)
-        self.readChild(&quot;a&quot;, ASN1_Object)
-#        self.readChild(&quot;b&quot;, ASN1_Object)
-
-    def checkEnd(self, stream, array, last):        
-        return stream.eof()

Modified: haypo/hachoir/trunk/plugins/avi.py
===================================================================
--- haypo/hachoir/trunk/plugins/avi.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/avi.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -6,9 +6,10 @@
 Author: Victor Stinner
 &quot;&quot;&quot;
 
-from filter import Filter, OnDemandFilter
+from filter import OnDemandFilter
 from plugin import registerPlugin
 from tools import humanFilesize
+from chunk import FormatChunk
 
 class MovieChunk(OnDemandFilter):
     twocc_description = {
@@ -19,9 +20,9 @@
     }
 
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;movie_chunk&quot;, &quot;Movie chunk&quot;, stream, parent)
-        self.read(&quot;fourcc&quot;, &quot;4s&quot;, &quot;Stream chunk four character code&quot;)
-        size = self.doRead(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;).value
+        OnDemandFilter.__init__(self, &quot;movie_chunk&quot;, &quot;Movie chunk&quot;, stream, parent, &quot;&lt;&quot;)
+        self.read(&quot;fourcc&quot;, &quot;Stream chunk four character code&quot;, (FormatChunk, &quot;string[4]&quot;))
+        size = self.doRead(&quot;size&quot;, &quot;Size&quot;, (FormatChunk, &quot;uint32&quot;)).value
         if size == 0:
             self.type = &quot;(empty)&quot;
             return
@@ -33,10 +34,10 @@
             desc = &quot;Junk&quot;
         else:
             desc = &quot;Raw data&quot;
-        self.read(&quot;data&quot;, &quot;%us&quot; % size, desc)
+        self.read(&quot;data&quot;, desc, (FormatChunk, &quot;string[%u]&quot; % size))
         self.type = desc
         if size &amp; 1:
-            self.read(&quot;padding&quot;, &quot;%us&quot; % 1, &quot;Padding&quot;)
+            self.read(&quot;padding&quot;, &quot;Padding&quot;, (FormatChunk, &quot;uint8&quot;))
 
     def updateParent(self, chunk):
         desc = &quot;Movie chunk: %s&quot; % self.type
@@ -55,97 +56,97 @@
         self.chunk_count = 0
         start = stream.tell()
         while 8 &lt;= end - stream.tell():
-            #&#160;Little hack to read chunk size
+            # Little hack to read chunk size
             stream.seek(4, 1)
-            chunk_size = stream.getFormat(&quot;&lt;L&quot;, False)[0]
+            chunk_size = stream.getFormat(&quot;&lt;uint32&quot;, False)
             stream.seek(-4, 1)
             chunk_size = 8 + chunk_size + chunk_size % 2
             # End of little hack :-)
-            self.readSizedChild(&quot;chunk[]&quot;, &quot;Movie chunk&quot;, chunk_size, MovieChunk)
+            self.read(&quot;chunk[]&quot;, &quot;Movie chunk&quot;, (MovieChunk,), {&quot;size&quot;: chunk_size})
             self.chunk_count += 1
             if self.chunk_count % 1000 == 0:
                 print &quot;Parse stream: %u %%&quot; % ((stream.tell() - start) * 100 / size)
         size = end - stream.tell()
         if size &gt; 0:
-            self.read(&quot;end&quot;, &quot;%us&quot; % size, &quot;Raw data&quot;)
+            self.read(&quot;end&quot;, &quot;Raw data&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
         print &quot; ********* END OF STREAM PARSING ************&quot;
 
     def updateParent(self, chunk):
         chunk.description = &quot;Movie stream: %u chunks&quot; % self.chunk_count
 
-class Header(Filter):
+class Header(OnDemandFilter):
     def __init__(self, stream, parent, stream_type):
-        Filter.__init__(self, &quot;header&quot;, &quot;Header&quot;, stream, parent)
-        tag = self.read(&quot;tag&quot;, &quot;4s&quot;, &quot;Tag&quot;).value
-        size = self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;).value
+        OnDemandFilter.__init__(self, &quot;header&quot;, &quot;Header&quot;, stream, parent, &quot;&lt;&quot;)
+        tag = self.doRead(&quot;tag&quot;, &quot;Tag&quot;, (FormatChunk, &quot;string[4]&quot;)).value
+        size = self.doRead(&quot;size&quot;, &quot;Size&quot;, (FormatChunk, &quot;uint32&quot;)).value
         self.type = &quot;Unknow&quot;
         if tag == &quot;strh&quot; and size &gt;= 56:
             # Stream header
             self.type = &quot;Stream header&quot;
             hend = stream.tell() + size
-            self.read(&quot;type_fourcc&quot;, &quot;4s&quot;, &quot;Stream type four character code&quot;)
-            self.read(&quot;fourcc&quot;, &quot;4s&quot;, &quot;Stream four character code&quot;)
-            self.read(&quot;flags&quot;, &quot;&lt;L&quot;, &quot;Stream flags&quot;)
-            self.read(&quot;priority&quot;, &quot;&lt;H&quot;, &quot;Stream priority&quot;)
-            self.read(&quot;langage&quot;, &quot;2s&quot;, &quot;Stream language&quot;)
-            self.read(&quot;init_frames&quot;, &quot;&lt;L&quot;, &quot;InitialFrames&quot;)
-            self.read(&quot;scale&quot;, &quot;&lt;L&quot;, &quot;Time scale&quot;)
-            self.read(&quot;rate&quot;, &quot;&lt;L&quot;, &quot;Divide by scale to give frame rate&quot;)
-            self.read(&quot;start&quot;, &quot;&lt;L&quot;, &quot;Stream start time (unit: rate/scale)&quot;)
-            self.read(&quot;length&quot;, &quot;&lt;L&quot;, &quot;Stream length (unit: rate/scale)&quot;)
-            self.read(&quot;buf_size&quot;, &quot;&lt;L&quot;, &quot;Suggested buffer size&quot;)
-            self.read(&quot;quality&quot;, &quot;&lt;L&quot;, &quot;Stream quality&quot;)
-            self.read(&quot;sample_size&quot;, &quot;&lt;L&quot;, &quot;Size of samples&quot;)
-            self.read(&quot;left&quot;, &quot;&lt;H&quot;, &quot;Destination rectangle (left)&quot;)
-            self.read(&quot;top&quot;, &quot;&lt;H&quot;, &quot;Destination rectangle (top)&quot;)
-            self.read(&quot;right&quot;, &quot;&lt;H&quot;, &quot;Destination rectangle (right)&quot;)
-            self.read(&quot;bottom&quot;, &quot;&lt;H&quot;, &quot;Destination rectangle (bottom)&quot;)
+            self.read(&quot;type_fourcc&quot;, &quot;Stream type four character code&quot;, (FormatChunk, &quot;string[4]&quot;))
+            self.read(&quot;fourcc&quot;, &quot;Stream four character code&quot;, (FormatChunk, &quot;string[4]&quot;))
+            self.read(&quot;flags&quot;, &quot;Stream flags&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;priority&quot;, &quot;Stream priority&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;langage&quot;, &quot;Stream language&quot;, (FormatChunk, &quot;string[2]&quot;))
+            self.read(&quot;init_frames&quot;, &quot;InitialFrames&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;scale&quot;, &quot;Time scale&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;rate&quot;, &quot;Divide by scale to give frame rate&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;start&quot;, &quot;Stream start time (unit: rate/scale)&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;length&quot;, &quot;Stream length (unit: rate/scale)&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;buf_size&quot;, &quot;Suggested buffer size&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;quality&quot;, &quot;Stream quality&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;sample_size&quot;, &quot;Size of samples&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;left&quot;, &quot;Destination rectangle (left)&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;top&quot;, &quot;Destination rectangle (top)&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;right&quot;, &quot;Destination rectangle (right)&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;bottom&quot;, &quot;Destination rectangle (bottom)&quot;, (FormatChunk, &quot;uint16&quot;))
             diff = hend-stream.tell()
             if 0 &lt; diff:
-                self.read(&quot;h_extra&quot;, &quot;%us&quot; % diff, &quot;Extra junk&quot;)
+                self.read(&quot;h_extra&quot;, &quot;Extra junk&quot;, (FormatChunk, &quot;string[%u]&quot; % diff))
             assert stream.tell() == hend
         elif tag == &quot;strf&quot; and stream_type == &quot;vids&quot; and size == 40:
             # Video header
             self.type = &quot;Video header&quot;
-            self.read(&quot;v_size&quot;, &quot;&lt;L&quot;, &quot;Video format: Size&quot;)                    
-            self.read(&quot;v_width&quot;, &quot;&lt;L&quot;, &quot;Video format: Width&quot;)                    
-            self.read(&quot;v_height&quot;, &quot;&lt;L&quot;, &quot;Video format: Height&quot;)                    
-            self.read(&quot;v_panes&quot;, &quot;&lt;H&quot;, &quot;Video format: Panes&quot;)                    
-            self.read(&quot;v_depth&quot;, &quot;&lt;H&quot;, &quot;Video format: Depth&quot;)                    
-            self.read(&quot;v_tag1&quot;, &quot;&lt;L&quot;, &quot;Video format: Tag1&quot;)                    
-            self.read(&quot;v_img_size&quot;, &quot;&lt;L&quot;, &quot;Video format: Image size&quot;)                    
-            self.read(&quot;v_xpels_meter&quot;, &quot;&lt;L&quot;, &quot;Video format: XPelsPerMeter&quot;)
-            self.read(&quot;v_ypels_meter&quot;, &quot;&lt;L&quot;, &quot;Video format: YPelsPerMeter&quot;)
-            self.read(&quot;v_clr_used&quot;, &quot;&lt;L&quot;, &quot;Video format: ClrUsed&quot;)
-            self.read(&quot;v_clr_importand&quot;, &quot;&lt;L&quot;, &quot;Video format: ClrImportant&quot;)
+            self.read(&quot;v_size&quot;, &quot;Video format: Size&quot;, (FormatChunk, &quot;uint32&quot;))                    
+            self.read(&quot;v_width&quot;, &quot;Video format: Width&quot;, (FormatChunk, &quot;uint32&quot;))                    
+            self.read(&quot;v_height&quot;, &quot;Video format: Height&quot;, (FormatChunk, &quot;uint32&quot;))                    
+            self.read(&quot;v_panes&quot;, &quot;Video format: Panes&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;v_depth&quot;, &quot;Video format: Depth&quot;, (FormatChunk, &quot;uint16&quot;))                    
+            self.read(&quot;v_tag1&quot;, &quot;Video format: Tag1&quot;, (FormatChunk, &quot;uint32&quot;))                    
+            self.read(&quot;v_img_size&quot;, &quot;Video format: Image size&quot;, (FormatChunk, &quot;uint32&quot;))                    
+            self.read(&quot;v_xpels_meter&quot;, &quot;Video format: XPelsPerMeter&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;v_ypels_meter&quot;, &quot;Video format: YPelsPerMeter&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;v_clr_used&quot;, &quot;Video format: ClrUsed&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;v_clr_importand&quot;, &quot;Video format: ClrImportant&quot;, (FormatChunk, &quot;uint32&quot;))
         elif tag == &quot;strf&quot; and stream_type == &quot;auds&quot;:
             # Audio (wav) header
             self.type = &quot;Audio header&quot;
             aend = stream.tell() + size
-            self.read(&quot;a_id&quot;, &quot;&lt;H&quot;, &quot;Audio format: Codec id&quot;)                    
-            a_chan = self.read(&quot;a_channel&quot;, &quot;&lt;H&quot;, &quot;Audio format: Channels&quot;).value
-            self.read(&quot;a_sample_rate&quot;, &quot;&lt;L&quot;, &quot;Audio format: Sample rate&quot;)                    
-            self.read(&quot;a_bit_rate&quot;, &quot;&lt;L&quot;, &quot;Audio format: Bit rate&quot;)
-            self.read(&quot;a_block_align&quot;, &quot;&lt;H&quot;, &quot;Audio format: Block align&quot;)
+            self.read(&quot;a_id&quot;, &quot;Audio format: Codec id&quot;, (FormatChunk, &quot;uint16&quot;))
+            a_chan = self.doRead(&quot;a_channel&quot;, &quot;Audio format: Channels&quot;, (FormatChunk, &quot;uint16&quot;)).value
+            self.read(&quot;a_sample_rate&quot;, &quot;Audio format: Sample rate&quot;, (FormatChunk, &quot;uint32&quot;))                    
+            self.read(&quot;a_bit_rate&quot;, &quot;Audio format: Bit rate&quot;, (FormatChunk, &quot;uint32&quot;))
+            self.read(&quot;a_block_align&quot;, &quot;Audio format: Block align&quot;, (FormatChunk, &quot;uint16&quot;))
             if size &gt;= 16:
-                self.read(&quot;a_bits_per_sample&quot;, &quot;&lt;H&quot;, &quot;Audio format: Bits per sample&quot;)
+                self.read(&quot;a_bits_per_sample&quot;, &quot;Audio format: Bits per sample&quot;, (FormatChunk, &quot;uint16&quot;))
             if size &gt;= 18:
-                self.read(&quot;ext_size&quot;, &quot;&lt;H&quot;, &quot;Audio format: Size of extra information&quot;)
+                self.read(&quot;ext_size&quot;, &quot;Audio format: Size of extra information&quot;, (FormatChunk, &quot;uint16&quot;))
             if a_chan &gt; 2 and size &gt;= 28:
-                self.read(&quot;reserved&quot;, &quot;&lt;H&quot;, &quot;Audio format: &quot;)
-                self.read(&quot;channel_mask&quot;, &quot;&lt;L&quot;, &quot;Audio format: channels placement bitmask&quot;)
-                self.read(&quot;subformat&quot;, &quot;&lt;L&quot;, &quot;Audio format: Subformat id&quot;)
+                self.read(&quot;reserved&quot;, &quot;Audio format: &quot;, (FormatChunk, &quot;uint16&quot;))
+                self.read(&quot;channel_mask&quot;, &quot;Audio format: channels placement bitmask&quot;, (FormatChunk, &quot;uint32&quot;))
+                self.read(&quot;subformat&quot;, &quot;Audio format: Subformat id&quot;, (FormatChunk, &quot;uint32&quot;))
             diff = aend-stream.tell()
             if 0 &lt; diff:
-                self.read(&quot;a_extra&quot;, &quot;%us&quot; % diff, &quot;Audio format: Extra&quot;)
+                self.read(&quot;a_extra&quot;, &quot;Audio format: Extra&quot;, (FormatChunk, &quot;string[%u]&quot; % diff))
             assert stream.tell() == aend
         elif tag == &quot;strn&quot;:
             # Stream description
-            self.read(&quot;desc&quot;, &quot;%us&quot; % size, &quot;Stream description&quot;)
+            self.read(&quot;desc&quot;, &quot;Stream description&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
         else:
             if tag == &quot;JUNK&quot;:
                 self.type = &quot;Junk&quot;
-            self.read(&quot;svalue[]&quot;, &quot;%us&quot; % size, &quot;String value&quot;)
+            self.read(&quot;junk&quot;, &quot;Junk&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
 
     def updateParent(self, chunk):
         chunk.description = &quot;Header: %s&quot; % self.type
@@ -157,35 +158,34 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, &quot;avi_chunk&quot;, &quot;AVI chunk&quot;, stream, parent)
         self.type = &quot;Unknow&quot;
-        tag = self.doRead(&quot;tag&quot;, &quot;4s&quot;, &quot;Tag&quot;).value
+        tag = self.doRead(&quot;tag&quot;, &quot;Tag&quot;, (FormatChunk, &quot;string[4]&quot;)).value
         size = stream.getSize()-4
         end = stream.tell() + size
         if tag in ChunkList.handler:
             # Handler
             sub = stream.createSub(size=size)
-            self.readSizedStreamChild(&quot;data&quot;, &quot;Chunk data&quot;, size, sub, ChunkList.handler[tag])
+            self.read(&quot;data&quot;, &quot;Chunk data&quot;, (ChunkList.handler[tag],), {&quot;size&quot;: size, &quot;stream&quot;: sub})
         elif tag in (&quot;hdrl&quot;, &quot;INFO&quot;):
-            #&#160;(Headers) Chunks
+            # (Headers) Chunks
             self.type = &quot;List of chunks&quot;
             while 8 &lt; end - stream.tell():
-                size = self.doReadChild(&quot;chunk[]&quot;, &quot;Chunk&quot;, Chunk).size
-                padding = size % 2
-                if padding != 0:
-                    self.read(&quot;padding[]&quot;, &quot;%us&quot; % padding, &quot;Padding&quot;)
+                size = self.doRead(&quot;chunk[]&quot;, &quot;Chunk&quot;, (Chunk,)).getSize()
+                if size % 2 != 0:
+                    self.read(&quot;padding[]&quot;, &quot;Padding&quot;, (FormatChunk, &quot;uint8&quot;))
         elif tag == &quot;strl&quot;:
             # Headers
             self.type = &quot;Headers&quot;
             stream_type = None
             while 8 &lt;= end - stream.tell():
-                header = self.doReadChild(&quot;header[]&quot;, &quot;Header&quot;, Header, stream_type).getFilter()
+                header = self.doRead(&quot;header[]&quot;, &quot;Header&quot;, (Header, stream_type))
                 if header.hasChunk(&quot;type_fourcc&quot;):
                     stream_type = header[&quot;type_fourcc&quot;]
         else:
-            #&#160;Raw data
-            self.read(&quot;raw&quot;, &quot;%us&quot; % size, &quot;Raw data&quot;)
+            # Raw data
+            self.read(&quot;raw&quot;, &quot;Raw data&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
         padding = end - stream.tell()
         if padding != 0:
-            self.read(&quot;padding[]&quot;, &quot;%us&quot; % padding, &quot;Padding&quot;)
+            self.read(&quot;padding[]&quot;, &quot;Padding&quot;, (FormatChunk, &quot;string[%u]&quot; % padding))
         assert stream.tell() == end
 
     def updateParent(self, chunk):
@@ -209,39 +209,39 @@
     }
 
     def __init__(self, stream, parent=None):
-        OnDemandFilter.__init__(self, &quot;avi_chunk&quot;, &quot;AVI chunk&quot;, stream, parent)
-        tag = self.doRead(&quot;tag&quot;, &quot;4s&quot;, &quot;Tag&quot;).value
-        size = self.doRead(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;).value
+        OnDemandFilter.__init__(self, &quot;chunk&quot;, &quot;Chunk&quot;, stream, parent, &quot;&lt;&quot;)
+        tag = self.doRead(&quot;tag&quot;, &quot;Tag&quot;, (FormatChunk, &quot;string[4]&quot;)).value
+        size = self.doRead(&quot;size&quot;, &quot;Size&quot;, (FormatChunk, &quot;uint32&quot;)).value
         if tag in Chunk.handler:
             end = stream.tell() + size
             sub = stream.createSub(size=size)
-            self.readSizedStreamChild(&quot;data&quot;, &quot;Data&quot;, size, sub, Chunk.handler[tag])
+            self.read(&quot;data&quot;, &quot;Data&quot;, (Chunk.handler[tag],), {&quot;size&quot;: size, &quot;stream&quot;: sub})
             assert stream.tell() == end
         else:
-            self.read(&quot;content&quot;, &quot;%us&quot; % size, &quot;Raw data content&quot;)
+            self.read(&quot;content&quot;, &quot;Raw data content&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
 
     def updateParent(self, parent):
-        tag = self[&quot;tag&quot;]
+        tag = self[&quot;tag&quot;].strip(&quot;\0&quot;)
         if tag == &quot;LIST&quot;:
             tag = self[&quot;data&quot;][&quot;tag&quot;]
             type = &quot;LIST (%s)&quot; % Chunk.tag_description.get(tag, tag)
         else:
-            type = Chunk.tag_description.get(tag, tag)
+            type = Chunk.tag_description.get(tag, &quot;\&quot;%s\&quot;&quot; % tag)
         if tag in Chunk.tag_name:
             parent.id = Chunk.tag_name[tag]
         desc = &quot;Chunk: %s&quot; % type
         self.setDescription(desc)
         parent.description = desc
 
-class AVI_File(Filter):
+class AVI_File(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;avi_file&quot;, &quot;AVI file&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;4s&quot;, &quot;AVI header (RIFF)&quot;)
+        OnDemandFilter.__init__(self, &quot;avi_file&quot;, &quot;AVI file&quot;, stream, parent, &quot;&lt;&quot;)
+        self.read(&quot;header&quot;, &quot;AVI header (RIFF)&quot;, (FormatChunk, &quot;string[4]&quot;))
         assert self[&quot;header&quot;] == &quot;RIFF&quot;
-        self.read(&quot;filesize&quot;, &quot;&lt;L&quot;, &quot;File size&quot;)
-        self.read(&quot;avi&quot;, &quot;4s&quot;, &quot;\&quot;AVI \&quot; string&quot;)
+        self.read(&quot;filesize&quot;, &quot;File size&quot;, (FormatChunk, &quot;uint32&quot;))
+        self.read(&quot;avi&quot;, &quot;\&quot;AVI \&quot; string&quot;, (FormatChunk, &quot;string[4]&quot;))
         assert self[&quot;avi&quot;] == &quot;AVI &quot;
         while not stream.eof():
-            self.readChild(&quot;chunk[]&quot;, Chunk)
+            self.read(&quot;chunk[]&quot;, &quot;Chunk&quot;, (Chunk,))
 
 registerPlugin(AVI_File, &quot;video/x-msvideo&quot;)

Deleted: haypo/hachoir/trunk/plugins/bmp.py
===================================================================
--- haypo/hachoir/trunk/plugins/bmp.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/bmp.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,32 +0,0 @@
-&quot;&quot;&quot;
-Microsoft Bitmap picture parseer.
-
-Author: Victor Stinner
-Creation: 16 december 2005
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-
-class BitmapFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;bmp_file&quot;, &quot;Bitmap picture file (BMP)&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;!2s&quot;, &quot;Header (\&quot;BM\&quot;)&quot;)
-        self.read(&quot;file_size&quot;, &quot;&lt;L&quot;, &quot;File size (bytes)&quot;)
-        self.read(&quot;notused&quot;, &quot;&lt;L&quot;, &quot;Reseved&quot;)
-        self.read(&quot;data_start&quot;, &quot;&lt;L&quot;, &quot;Data start position&quot;)
-        header_size = self.read(&quot;header_size&quot;, &quot;&lt;L&quot;, &quot;Header size&quot;).value
-        assert header_size in (12, 40)
-        self.read(&quot;width&quot;, &quot;&lt;L&quot;, &quot;Width (pixels)&quot;)
-        self.read(&quot;height&quot;, &quot;&lt;L&quot;, &quot;Height (pixels)&quot;)
-        self.read(&quot;nb_plan&quot;, &quot;&lt;H&quot;, &quot;Number of plan (=1)&quot;)
-        self.read(&quot;bits_pixel&quot;, &quot;&lt;H&quot;, &quot;Bits per pixel&quot;)
-        if header_size == 40:
-            self.read(&quot;compression&quot;, &quot;&lt;L&quot;, &quot;Compression method&quot;)
-            self.read(&quot;image_size&quot;, &quot;&lt;L&quot;, &quot;Image size (bytes)&quot;)
-            self.read(&quot;horizontal_dpi&quot;, &quot;&lt;L&quot;, &quot;Horizontal DPI&quot;)
-            self.read(&quot;vertical_dpi&quot;, &quot;&lt;L&quot;, &quot;Vertical DPI&quot;)
-            self.read(&quot;used_colors&quot;, &quot;&lt;L&quot;, &quot;Number of color used&quot;)
-            self.read(&quot;important_color&quot;, &quot;&lt;L&quot;, &quot;Number of import colors&quot;)
-
-registerPlugin(BitmapFile, &quot;image/x-ms-bmp&quot;)

Deleted: haypo/hachoir/trunk/plugins/bzip2.py
===================================================================
--- haypo/hachoir/trunk/plugins/bzip2.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/bzip2.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,41 +0,0 @@
-&quot;&quot;&quot;
-BZIP2 archive file
-&quot;&quot;&quot;
-
-from plugin import guessPlugin
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-from stream.bunzip import BunzipStream
-
-class Bzip2_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;bz2_file&quot;, &quot;Bzip2 archive file&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;3s&quot;, &quot;Identifier (BZh)&quot;)
-        assert self[&quot;id&quot;] == &quot;BZh&quot;
-        self.read(&quot;blocksize&quot;, &quot;c&quot;, &quot;Block size&quot;)
-        assert &quot;1&quot; &lt;= self[&quot;blocksize&quot;] and self[&quot;blocksize&quot;] &lt;= &quot;9&quot;
-        # Size of memory needed to decompress (on classic mode, not &quot;small&quot; mode)
-        size = (ord(self[&quot;blocksize&quot;]) - ord(&quot;0&quot;)) * 100
-        self.getChunk(&quot;blocksize&quot;).description = &quot;Block size (will need %u KB of memory)&quot; % size
-        self.read(&quot;blockheader&quot;, &quot;B&quot;, &quot;Block header&quot;)
-        assert self[&quot;blockheader&quot;] in (0x17, 0x31)
-        if self[&quot;blockheader&quot;] == 0x17:
-            self.readA()
-        else: # blockheader = 0x31 (&quot;1&quot;)
-            self.readB()
-        dataio = BunzipStream(stream)
-        plugin = guessPlugin(dataio, None)
-        size = stream.getSize()-stream.tell()
-        self.readChild(&quot;data&quot;, DeflateFilter, dataio, size, plugin)
-
-    def readB(self):
-        self.read(&quot;id2&quot;, &quot;5s&quot;, &quot;Identifier 2 (AY&amp;SY)&quot;)
-        assert self[&quot;id2&quot;] == &quot;AY&amp;SY&quot;
-        self.read(&quot;crc&quot;, &quot;&lt;L&quot;, &quot;CRC32&quot;)
-        
-    def readA(self):
-        self.read(&quot;id2&quot;, &quot;4s&quot;, &quot;Identifier2 (re8P)&quot;)
-        self.read(&quot;id3&quot;, &quot;B&quot;, &quot;Identifier3 (0x90)&quot;)
-        self.read(&quot;crc&quot;, &quot;&lt;L&quot;, &quot;CRC32&quot;)
-         
-registerPlugin(Bzip2_File, &quot;application/x-bzip2&quot;)

Deleted: haypo/hachoir/trunk/plugins/elf.py
===================================================================
--- haypo/hachoir/trunk/plugins/elf.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/elf.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,171 +0,0 @@
-&quot;&quot;&quot;
-ELF filter.
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-
-def processAddr(chunk):
-    return &quot;%08X&quot; % chunk.value
-
-class ElfHeader(Filter):
-    machine = {
-        0: &quot;No machine&quot;,
-        1: &quot;AT&amp;T WE 32100&quot;,
-        2: &quot;SPARC&quot;,
-        3: &quot;Intel 80386&quot;,
-        4: &quot;Motorolla 68000&quot;,
-        5: &quot;Motorolla 88000&quot;,
-        7: &quot;Intel 80860&quot;,
-        8: &quot;MIPS RS3000&quot;
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;elf_header&quot;, &quot;ELF header&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;4s&quot;, &quot;Identifier&quot;)
-        assert self[&quot;id&quot;] == (chr(127) + &quot;ELF&quot;)
-        self.read(&quot;class&quot;, &quot;B&quot;, &quot;Class&quot;)
-        self.read(&quot;encoding&quot;, &quot;B&quot;, &quot;Encoding&quot;)
-        self.read(&quot;file_version&quot;, &quot;B&quot;, &quot;File version&quot;)
-        self.read(&quot;pad&quot;, &quot;8s&quot;, &quot;Pad&quot;)
-        self.read(&quot;nident&quot;, &quot;B&quot;, &quot;Size of ident[]&quot;)
-        self.read(&quot;type&quot;, &quot;&lt;H&quot;, &quot;File type&quot;, post=self.getType)
-        self.read(&quot;machine&quot;, &quot;&lt;H&quot;, &quot;Machine type&quot;, post=self.getMachine)
-        self.read(&quot;version&quot;, &quot;&lt;L&quot;, &quot;ELF format version&quot;)
-        self.read(&quot;entry&quot;, &quot;&lt;L&quot;, &quot;Number of entries&quot;)
-        self.read(&quot;phoff&quot;, &quot;&lt;L&quot;, &quot;Program header offset&quot;)
-        self.read(&quot;shoff&quot;, &quot;&lt;L&quot;, &quot;Section header offset&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;L&quot;, &quot;Flags&quot;)
-        self.read(&quot;ehsize&quot;, &quot;&lt;H&quot;, &quot;Elf header size (this header)&quot;)
-        self.read(&quot;phentsize&quot;, &quot;&lt;H&quot;, &quot;Program header entry size&quot;)
-        self.read(&quot;phnum&quot;, &quot;&lt;H&quot;, &quot;Program header entry count&quot;)
-        self.read(&quot;shentsize&quot;, &quot;&lt;H&quot;, &quot;Section header entry size&quot;)
-        self.read(&quot;shnum&quot;, &quot;&lt;H&quot;, &quot;Section header entre count&quot;)
-        self.read(&quot;shstrndx&quot;, &quot;&lt;H&quot;, &quot;Section header strtab index&quot;)
-
-    def getType(self, chunk):
-        type = chunk.value
-        types = {
-            0: &quot;No file type&quot;,
-            1: &quot;Relocable file&quot;,
-            2: &quot;Executable file&quot;,
-            3: &quot;Shared object file&quot;,
-            4: &quot;Core file&quot;,
-            0xFF00: &quot;Processor-specific (0xFF00)&quot;,
-            0xFFFF: &quot;Processor-specific (0xFFFF)&quot;
-        }
-        return types.get(type, &quot;Unknow type (%u)&quot; % type)
-
-    def getMachine(self, chunk):
-        type = chunk.value
-        return ElfHeader.machine.get(type, &quot;Unknow machine (%u)&quot; % type)
-
-class SectionHeader32(Filter):
-    types = {
-        8: &quot;BSS&quot;
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;section_header&quot;, &quot;Section header&quot;, stream, parent)
-        self.read(&quot;name&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;type&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;VMA&quot;, &quot;&lt;L&quot;, &quot;Virtual memory address&quot;)#, post=processAddr)
-        self.read(&quot;LMA&quot;, &quot;&lt;L&quot;, &quot;Logical memory address (in file)&quot;)#, post=processAddr)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;&quot;, post=processAddr)
-        self.read(&quot;link&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;info&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;addralign&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;entsize&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-
-    def getType(self):
-        type = self[&quot;type&quot;]
-        return SectionHeader32.types.get(type, &quot;unknow type=%u&quot; % type)
-
-    def getName(self):
-        #&#160;TODO: Look in symbol name
-        return self[&quot;name&quot;]
-
-    def updateParent(self, chunk):
-        desc = &quot;Section header (name: %s, type: %s)&quot; % (self.getName(), self.getType())
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ProgramHeader32(Filter):
-    type = {
-        3: &quot;Dynamic library&quot;
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;prg_header&quot;, &quot;Program header&quot;, stream, parent)
-        self.read(&quot;type&quot;, &quot;&lt;H&quot;, &quot;&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;&quot;)
-        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;vaddr&quot;, &quot;&lt;L&quot;, &quot;&quot;, post=processAddr)
-        self.read(&quot;paddr&quot;, &quot;&lt;L&quot;, &quot;&quot;, post=processAddr)
-        self.read(&quot;file_size&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;mem_size&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;align&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        self.read(&quot;padding&quot;, &quot;&lt;L&quot;, &quot;(padding?)&quot;)
-
-    def getType(self):
-        type = self[&quot;type&quot;]
-        return ProgramHeader32.type.get(type, &quot;unknow, %u&quot; % type)
-
-    def updateParent(self, chunk):
-        desc = &quot;Program Header (%s)&quot; % self.getType() 
-        self.setDescription(desc)
-        chunk.description = desc 
-
-def seek(filter, stream, offset):
-    current = stream.tell()
-    if current != offset:
-        filter.read(&quot;padding[]&quot;, &quot;%us&quot; % (offset-current), &quot;Padding&quot;)
-
-def sortSection(a, b):
-    return int(a[&quot;offset&quot;] - b[&quot;offset&quot;])
-
-class Section(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;elf_section&quot;, &quot;Elf section&quot;, stream, parent)
-        # TODO ...
-        self.read(&quot;raw&quot;, &quot;%us&quot; % stream.getSize(), &quot;Raw data&quot;)
-        
-class Sections(Filter):
-    def __init__(self, stream, parent, sections):
-        Filter.__init__(self, &quot;elf_sections&quot;, &quot;ELF sections&quot;, stream, parent)
-        for section in sections:
-            ofs = section[&quot;offset&quot;]
-            size = section[&quot;file_size&quot;]
-            sub = stream.createSub(ofs, size)
-            #self.readChild(&quot;section[]&quot;, DeflateFilter, sub, size, Section) 
-            chunk = self.readStreamChild(&quot;section[]&quot;, sub, Section) 
-            chunk.description = &quot;ELF section (in file: %s..%s)&quot; % (ofs, ofs+size)
-
-class ElfFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;elf_file&quot;, &quot;ELF file&quot;, stream, parent)
-        self.readChild(&quot;elf_header&quot;, ElfHeader)
-        elf = self[&quot;elf_header&quot;]
-        sections = []
-        for i in range(0, elf[&quot;phnum&quot;]):
-            section = self.readChild(&quot;prg_header[]&quot;, ProgramHeader32)
-            sections.append(section.getFilter())
-
-#        i = 1
-#        for section in sections:
-#            print &quot;Section %u: type %u, data in %u..%u &quot; % (i, section[&quot;type&quot;], section[&quot;offset&quot;], section[&quot;offset&quot;]+section[&quot;file_size&quot;])
-#            i = i + 1
-            
-        size = elf[&quot;shoff&quot;] - stream.tell()
-        newstream = stream.clone()
-        chunk = self.readChild(&quot;data&quot;, DeflateFilter, newstream, size, Sections, sections) 
-        chunk.description = &quot;Sections (use an evil hack to manage share same data on differents parts)&quot;
-        assert stream.tell() == elf[&quot;shoff&quot;]
-
-        for i in range(0, elf[&quot;shnum&quot;]):
-            chunk = self.readChild(&quot;section_header[]&quot;, SectionHeader32)
-            assert chunk.size == 40
-
-registerPlugin(ElfFile, [&quot;application/x-executable&quot;, &quot;application/x-object&quot;, &quot;application/x-sharedlib&quot;])

Deleted: haypo/hachoir/trunk/plugins/email.py
===================================================================
--- haypo/hachoir/trunk/plugins/email.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/email.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,223 +0,0 @@
-&quot;&quot;&quot;
-Email parser
-
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin, guessPlugin, getPluginByMime
-from default import DefaultFilter
-from mime import splitMimes
-from error import warning, error
-from stream.base_64 import Base64Stream
-import re
-
-class EmailHeader(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;email_hdr&quot;, &quot;Email header&quot;, stream, parent)
-        self._dict = {}
-        regex_new = re.compile(&quot;^([A-Za-z][A-Za-z0-9-]*): (.*)$&quot;)
-        regex_continue = re.compile(&quot;^[\t ]+(.*)$&quot;)
-        linenb = 1
-        last_key = None
-        last_index = None
-        while True:
-            id = &quot;header[%u]&quot; % linenb
-            chunk = self.readString(id, &quot;AutoLine&quot;, &quot;Header line&quot;)
-            if chunk.length == 0: return
-            line = chunk.value
-
-            m = regex_new.match(line)
-            if m != None:
-                last_key = m.group(1)
-                last_index = self._newHeader(last_key, m.group(2))
-            else:
-                m = regex_continue.match(line)
-                if m != None:
-                    assert last_key != None
-                    self._appendHeader(last_key, last_index, m.group(1))
-                else:
-                    warning(&quot;Can't parse email header: %s&quot; % line)
-
-            linenb = linenb + 1
-
-    def __contains__(self, key):
-        key = key.lower()
-        return key in self._dict
-
-    def _appendHeader(self, key, index, value):
-        key = key.lower()
-        self._dict[key][index] = self._dict[key][index] + &quot; &quot; + value
-        
-    def _newHeader(self, key, value):
-        key = key.lower()
-        if key in self._dict:
-            index = len(self._dict[key])
-            self._dict[key].append(value)
-        else:
-            index = 0
-            self._dict[key] = [value]
-        return index
-
-    def __getitem__(self, index):
-        index = index.lower()
-        return self._dict[index]
-
-class EmailPart(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;email_part&quot;, &quot;Email part&quot;, stream, parent)
-        self.readChild(&quot;header&quot;, EmailHeader)
-        readEmailContent(self, stream.createSub())
-
-class EmailBody(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;email_body&quot;, &quot;Email body&quot;, stream, parent)
-        linenb = 1 
-        while not stream.eof():
-            guess = stream.read(5, False)
-            if guess==&quot;From &quot;:
-                break
-            id = &quot;body[%u]&quot; % linenb
-            chunk = self.readString(id, &quot;AutoLine&quot;, &quot;Body text&quot;)
-            linenb = linenb + 1
-
-def readEmailContent(self, stream):
-    mime = getEmailMime(self)
-    if mime != None and re.match(&quot;^multipart/&quot;, mime[0]) != None:
-        readMultipartEmail(self, stream, mime[1][&quot;boundary&quot;])
-    else:
-        if mime == None:
-            warning(&quot;Can't get MIME type for email %s&quot; % self)
-        readBody(self, stream, mime)
-
-def readBody(self, stream, mime):
-    # Read encoding
-    header = self[&quot;header&quot;]
-    if &quot;Content-Transfer-Encoding&quot; in header:
-        encoding = header[&quot;Content-Transfer-Encoding&quot;][0]
-    else:
-        encoding = None
-
-    # Get filename
-    if mime != None:
-        filename = mime[1].get(&quot;name&quot;, None)
-    else:
-        raise Exception(&quot;No MIME in readBody()&quot;)
-        filename = None
-    if filename == None:
-        if &quot;Content-Disposition&quot; in header:
-            disp = header[&quot;Content-Disposition&quot;][0].split(&quot;;&quot;)
-            regex = re.compile(&quot;filename=\&quot;([^\&quot;]+)\&quot;&quot;)
-            for item in disp:
-                m = regex.match(item.strip())
-                if m != None:
-                    filename = m.group(1)
-                    break
-    elif filename[0] == '&quot;':
-        filename = filename[1:-1]
-
-    # Handler base64 encodocing
-    if encoding == &quot;base64&quot;:
-        size = stream.getSize() - stream.tell()
-        data = stream.getN(size, False)
-        substream = Base64Stream(data)
-        deflate = True
-    else:
-#        regex_new_mail = re.compile(&quot;[\r\n]From &quot;)
-#        pos = stream.search(regex_new_mail)
-#        if pos != -1:
-#            substream = stream.createSub(size=pos)
-#        else:
-#            substream = stream
-        substream = stream.createSub()
-        deflate = False
-
-    # Guess plugin
-    if mime != None:
-        plugin = getPluginByMime((mime,), None)
-    else:
-        plugin = None
-    if plugin == None:
-        plugin = guessPlugin(substream, filename, None)
-    if plugin == None or plugin == EmailFilter:
-        plugin = EmailBody
-
-    # Finally read data
-    try:
-        if deflate:
-            self.readChild(&quot;body&quot;, DeflateFilter, substream, size, plugin) 
-        else:
-            self.readStreamChild(&quot;body&quot;, substream, plugin)
-    except Exception, msg:
-        error(&quot;Error while parsing email body: %s&quot; % msg)
-        substream.seek(0)
-        self.readStreamChild(&quot;body&quot;, substream, DefaultFilter)
-
-def readMultipartEmail(self, stream, boundary):
-    assert boundary[0] == '&quot;' and boundary[-1] == '&quot;'
-    boundary = &quot;--&quot; + boundary[1:-1]
-    end_boundary = boundary + &quot;--&quot;
-    count = 1
-    while True:
-        id = &quot;multipart_space[%u]&quot; % count
-        chunk = self.readString(id, &quot;AutoLine&quot;, &quot;Space before first email parts&quot;)
-        value = chunk.value
-        if value == boundary:
-            break
-        count = count + 1
-
-    part = 1
-    boundary_index = 1
-    while True:
-        start = stream.tell()
-        size = stream.searchLength(boundary, False)
-        sub = stream.createSub(start, size)
-        self.readStreamChild(&quot;part[%u]&quot; % part, sub, EmailPart)
-        stream.seek(start+size)
-        chunk = self.readString(&quot;boundary[%u]&quot; % boundary_index, &quot;AutoLine&quot;, &quot;Boundary&quot;)
-        part = part + 1
-        boundary_index = boundary_index + 1
-        if chunk.value == boundary+&quot;--&quot;:
-            break
-
-def getEmailMime(self):
-    header = self[&quot;header&quot;]
-    if not(&quot;Content-Type&quot; in header):
-        raise Exception(&quot;No mime&quot;)
-        return None
-    content_type = header[&quot;Content-Type&quot;]
-    assert len(content_type) == 1
-    mimes = splitMimes(content_type[0])
-    assert len(mimes) == 1
-    return mimes[0]
-
-class Email(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;email&quot;, &quot;Email&quot;, stream, parent)
-        self.readString(&quot;id&quot;, &quot;AutoLine&quot;, &quot;Email identifier&quot;)
-        self.readChild(&quot;header&quot;, EmailHeader)
-        readEmailContent(self, stream.createSub())
-
-    def __str__(self):
-        header = self[&quot;header&quot;]
-        text = &quot;Email&quot;
-        if &quot;From&quot; in header:
-            text = text + &quot; from %s&quot; % header[&quot;From&quot;]
-        if &quot;Date&quot; in header:
-            text = text + &quot; (date %s)&quot; % header[&quot;Date&quot;]
-        return text
-
-class EmailFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;email&quot;, &quot;Email maildir parser&quot;, stream, parent)
-        while not stream.eof():
-            chunk = self.readChild(&quot;email[]&quot;, Email)
-            if stream.eof():
-                break
-            while not stream.eof():
-                guess = stream.read(5, False)
-                if guess == &quot;From &quot;:
-                    break
-                self.readString(&quot;space[]&quot;, &quot;AutoLine&quot;, &quot;Space&quot;)
-
-registerPlugin(EmailFilter, [&quot;message/rfc822&quot;, &quot;text/x-mail&quot;])

Deleted: haypo/hachoir/trunk/plugins/exe.py
===================================================================
--- haypo/hachoir/trunk/plugins/exe.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/exe.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,196 +0,0 @@
-&quot;&quot;&quot;
-EXE filter.
-
-Status: read ms-dos and pe headers
-Todo: support resources ... and disassembler ? :-)
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-
-class PE_ResourceData(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_rsrc_data&quot;, &quot;PE resource data&quot;, stream, parent)
-        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;Offset&quot;)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
-        self.read(&quot;page_code&quot;, &quot;&lt;L&quot;, &quot;Page code (language)&quot;)
-        self.read(&quot;language&quot;, &quot;&lt;l&quot;, &quot;Page code (language)&quot;)
-#        self.language = -self[&quot;language&quot;]
-        self.read(&quot;reserved&quot;, &quot;!L&quot;, &quot;Reserverd&quot;)
-
-        oldpos = stream.tell()
-        
-        #stream.seek(XXX + self.offset - self.offset_res_section)
-        stream.seek(self[&quot;offset&quot;])
-        stream.seek(oldpos)
-
-class PE_ResourceEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_rsrc_entry&quot;, &quot;PE resource entry&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;&lt;L&quot;, &quot;ID or name&quot;)
-        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;Offset&quot;)
-        
-class PE_ResourceDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_rsrc_dir&quot;, &quot;PE resource directory&quot;, stream, parent)
-        self.offset_res_section = stream.tell()
-        self.read(&quot;option&quot;, &quot;&lt;L&quot;, &quot;Options&quot;)
-        self.read(&quot;creation_date&quot;, &quot;&lt;L&quot;, &quot;Creation date&quot;)
-        self.read(&quot;maj_ver&quot;, &quot;&lt;H&quot;, &quot;Major version&quot;)
-        self.read(&quot;named_entries&quot;, &quot;&lt;H&quot;, &quot;Named entries&quot;)
-        self.read(&quot;indexed_entries&quot;, &quot;&lt;H&quot;, &quot;Indexed entries&quot;)
-
-        stream.seek( stream.tell() + 0x10)
-        self.readArray(&quot;item&quot;, PE_ResourceEntry, &quot;PE resource entry&quot;, self.checkEndOfRes)
-    
-    def checkEndOfRes(self, stream, array, dir):
-        return len(array) == (self[&quot;named_entries&quot;] + self[&quot;indexed_entries&quot;])
-
-class PE_Section(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_section&quot;, &quot;PE section&quot;, stream, parent)
-        self.read(&quot;name&quot;, &quot;8s&quot;, &quot;Name&quot;)
-        # TODO: use chunk post proces
-        self.name = self[&quot;name&quot;].strip(&quot; \0&quot;)
-        self.read(&quot;rva&quot;, &quot;&lt;L&quot;, &quot;RVA&quot;)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
-        self.read(&quot;file_size&quot;, &quot;&lt;L&quot;, &quot;File size&quot;)
-        self.read(&quot;file_offset&quot;, &quot;&lt;L&quot;, &quot;File offset&quot;)
-        self.read(&quot;reloc_ptr&quot;, &quot;&lt;L&quot;, &quot;Relocation pointer&quot;)
-        self.read(&quot;lines_ptr&quot;, &quot;&lt;L&quot;, &quot;File line numbers pointer&quot;)
-        self.read(&quot;nb_reloc&quot;, &quot;&lt;H&quot;, &quot;Number of relocations&quot;)
-        self.read(&quot;nb_lines&quot;, &quot;&lt;H&quot;, &quot;Number of file line&quot;)
-        self.read(&quot;options&quot;, &quot;&lt;L&quot;, &quot;Options&quot;)
-
-class PE_Directory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_dir&quot;, &quot;PE directory&quot;, stream, parent)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
-        self.read(&quot;rva&quot;, &quot;&lt;L&quot;, &quot;RVA&quot;)
-
-class PE_OptionnalHeader(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_opt_hdr&quot;, &quot;PE optionnal header&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;&lt;H&quot;, &quot;Header&quot;)
-        assert self[&quot;header&quot;] == 0x010B
-        self.read(&quot;linker_maj_ver&quot;, &quot;B&quot;, &quot;Linker major version&quot;)
-        self.read(&quot;linker_min_ver&quot;, &quot;B&quot;, &quot;Linker minor version&quot;)
-        self.read(&quot;code_size&quot;, &quot;&lt;L&quot;, &quot;Code size (bytes)&quot;)
-        self.read(&quot;data_size&quot;, &quot;&lt;L&quot;, &quot;Data size (bytes)&quot;)
-        self.read(&quot;heap_size&quot;, &quot;&lt;L&quot;, &quot;Heap size (bytes)&quot;)
-        self.read(&quot;entry_point_rva&quot;, &quot;&lt;L&quot;, &quot;Entry point offset (RVA)&quot;)
-        self.read(&quot;code_rva&quot;, &quot;&lt;L&quot;, &quot;Code offset (RVA)&quot;)
-        self.read(&quot;data_rva&quot;, &quot;&lt;L&quot;, &quot;Data offset (RVA)&quot;)
-        self.read(&quot;base_image_rva&quot;, &quot;&lt;L&quot;, &quot;Base image offset (RVA)&quot;)
-        self.read(&quot;memory_alignment&quot;, &quot;&lt;L&quot;, &quot;Memory alignment&quot;)
-        self.read(&quot;file_alignment&quot;, &quot;&lt;L&quot;, &quot;File alignment&quot;)
-        self.read(&quot;os_maj_ver&quot;, &quot;&lt;H&quot;, &quot;OS major version&quot;)
-        self.read(&quot;os_min_ver&quot;, &quot;&lt;H&quot;, &quot;OS minor version&quot;)
-        self.read(&quot;prog_maj_ver&quot;, &quot;&lt;H&quot;, &quot;Program major version&quot;)
-        self.read(&quot;prog_min_ver&quot;, &quot;&lt;H&quot;, &quot;Program minor version&quot;)
-        self.read(&quot;api_maj_ver&quot;, &quot;&lt;H&quot;, &quot;API major version?!&quot;)
-        self.read(&quot;api_min_ver&quot;, &quot;&lt;H&quot;, &quot;API minor version?!&quot;)
-        self.read(&quot;windows_ver&quot;, &quot;&lt;L&quot;, &quot;Windows version?!&quot;)
-        self.read(&quot;image_size&quot;, &quot;&lt;L&quot;, &quot;Image size&quot;)
-        self.read(&quot;headers_size&quot;, &quot;&lt;L&quot;, &quot;Headers size&quot;)
-        self.read(&quot;checksum&quot;, &quot;&lt;L&quot;, &quot;Checkum&quot;)
-        self.read(&quot;neeed_api&quot;, &quot;&lt;H&quot;, &quot;Needed API?!&quot;)
-        self.read(&quot;dll_options&quot;, &quot;&lt;H&quot;, &quot;DLL options (only for DLL)&quot;)
-        self.read(&quot;reserved_stack_size&quot;, &quot;&lt;L&quot;, &quot;Reserved stack size&quot;)
-        self.read(&quot;common_stack_size&quot;, &quot;&lt;L&quot;, &quot;Common stack size&quot;)
-        self.read(&quot;reserved_heap_size&quot;, &quot;&lt;L&quot;, &quot;Reserved heap size&quot;)
-        self.read(&quot;common_heap_size&quot;, &quot;&lt;L&quot;, &quot;Common heap size&quot;)
-        self.read(&quot;loader_options&quot;, &quot;&lt;L&quot;, &quot;Loader options&quot;)
-        self.read(&quot;nb_directories&quot;, &quot;&lt;L&quot;, &quot;Number of directories (16)&quot;)
-        assert self[&quot;nb_directories&quot;] == 16
-        self.readArray(&quot;directories&quot;, PE_Directory, &quot;PE directories&quot;, self.checkEndOfDir)
-
-    def checkEndOfDir(self, stream, array, dir):
-        return len(array) == self.nb_directories
-
-class PE_Filter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pe_header&quot;, &quot;PE header&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;4s&quot;, &quot;File header&quot;)
-        assert self[&quot;header&quot;] == &quot;PE\0\0&quot;
-        self.read(&quot;cpu_type&quot;, &quot;&lt;H&quot;, &quot;CPU type&quot;)
-        self.read(&quot;nb_sections&quot;, &quot;&lt;H&quot;, &quot;Number of sections&quot;)
-        self.read(&quot;creation_date&quot;, &quot;&lt;L&quot;, &quot;Creation date&quot;)
-        self.read(&quot;ptr_to_symbols&quot;, &quot;&lt;L&quot;, &quot;Pointer to symbol table&quot;)
-        self.read(&quot;nb_symbols&quot;, &quot;&lt;L&quot;, &quot;Number of symbols&quot;)
-        self.read(&quot;opt_header_size&quot;, &quot;&lt;H&quot;, &quot;Optionnal header size&quot;)
-        self.read(&quot;options&quot;, &quot;&lt;H&quot;, &quot;Options&quot;)
-
-    def getCpuType(self):
-        cpu_name = {
-            0x014C: &quot;Intel 80386 or greater&quot;,
-            0x014D: &quot;Intel 80486 or greater&quot;,
-            0x014E: &quot;Intel Pentium or greader&quot;, 
-            0x0160: &quot;R3000 (MIPS), big endian&quot;,
-            0x0162: &quot;R3000 (MIPS), little endian&quot;,
-            0x0166: &quot;R4000 (MIPS), little endian&quot;,
-            0x0168: &quot;R10000 (MIPS), little endian&quot;,
-            0x0184: &quot;DEC Alpha AXP&quot;,
-            0x01F0: &quot;IBM Power PC, little endian&quot;}
-        return cpu_name.get(self[&quot;cpu_type&quot;], &quot;unknow&quot;)
-
-class MS_Dos(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;msdos_header&quot;, &quot;MS-Dos executable header&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;2s&quot;, &quot;File header&quot;)
-        assert self[&quot;header&quot;] == &quot;MZ&quot;
-        self.read(&quot;filesize_mod_512&quot;, &quot;&gt;H&quot;, &quot;Filesize mod 512&quot;)
-        self.read(&quot;filesize_div_512&quot;, &quot;&gt;H&quot;, &quot;Filesize div 512&quot;)
-        self.filesize = self[&quot;filesize_div_512&quot;] * 512 + self[&quot;filesize_mod_512&quot;]
-        self.read(&quot;reloc_entries&quot;, &quot;&gt;H&quot;, &quot;Number of relocation entries&quot;)
-        self.read(&quot;code_offset&quot;, &quot;&lt;H&quot;, &quot;Offset to the code in the file (div 16)&quot;)
-        self.code_offset = self[&quot;code_offset&quot;] * 16
-        self.read(&quot;needed_memory&quot;, &quot;&gt;H&quot;, &quot;Memory needed to run (div 16)&quot;)
-        self.needed_memory = self[&quot;needed_memory&quot;] * 16
-        self.read(&quot;max_memory&quot;, &quot;&gt;H&quot;, &quot;Maximum memory needed to run (div 16)&quot;)
-        self.max_memory = self[&quot;max_memory&quot;] * 16
-        self.read(&quot;init_ss_sp&quot;, &quot;&gt;L&quot;, &quot;Initial value of SP:SS registers.&quot;)
-        self.read(&quot;checksum&quot;, &quot;&gt;H&quot;, &quot;Checksum&quot;)
-        self.read(&quot;init_cs_ip&quot;, &quot;&gt;L&quot;, &quot;Initial value of CS:IP registers.&quot;)
-        self.read(&quot;reloc_offset&quot;, &quot;&lt;H&quot;, &quot;Offset in file to relocation table.&quot;)
-        self.read(&quot;overlay_number&quot;, &quot;&gt;H&quot;, &quot;Overlay number&quot;)
-        self.read(&quot;reserved&quot;, &quot;&gt;4H&quot;, &quot;Reserverd&quot;)
-        self.read(&quot;oem_id&quot;, &quot;&gt;H&quot;, &quot;OEM id&quot;)
-        self.read(&quot;oem_info&quot;, &quot;&gt;H&quot;, &quot;OEM info&quot;)
-        self.read(&quot;reserved2&quot;, &quot;!10H&quot;, &quot;Reserved&quot;)
-        self.read(&quot;pe_offset&quot;, &quot;&lt;L&quot;, &quot;Offset to PE header&quot;)
-
-class ExeFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;exe_file&quot;, &quot;EXE file&quot;, stream, parent)
-
-        self.readChild(&quot;ms_dos&quot;, MS_Dos)
-
-        if self[&quot;ms_dos&quot;][&quot;reloc_offset&quot;] == 0x40:
-            stream.seek(self[&quot;ms_dos&quot;][&quot;pe_offset&quot;], 0)
-
-            self.readChild(&quot;pe&quot;, PE_Filter)
-            self.pe = self[&quot;pe&quot;]
-            self.readChild(&quot;pe_opt&quot;, PE_OptionnalHeader)
-            self.readArray(&quot;pe_sections&quot;, PE_Section, &quot;PE sections&quot;, self.checkEndOfSections)
-
-            # TODO: Fix this ...
-            
-            offset_res_section = None
-            for section in self[&quot;pe_sections&quot;]:
-                section = section.getFilter()
-                if section.name == &quot;.rsrc&quot;:
-                    offset_res_section = section.file_offset
-                    self.getStream().seek( offset_res_section )
-                    break
-            if offset_res_section != None:
-                #for i in range(1): #range(self.pe.nb_sections):
-                self.readChild(&quot;pe_resources&quot;, PE_ResourceDirectory)
-        else:
-            self.pe = None
-
-    def checkEndOfSections(self, stream, array, section):
-        return len(array) == self[&quot;pe&quot;][&quot;nb_sections&quot;]
-
-registerPlugin(ExeFile, &quot;application/x-dosexec&quot;)

Deleted: haypo/hachoir/trunk/plugins/exif.py
===================================================================
--- haypo/hachoir/trunk/plugins/exif.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/exif.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,238 +0,0 @@
-&quot;&quot;&quot;
-Exif filter.
-
-Informations about Exif at:
-- <A HREF="http://www.exif.org/">http://www.exif.org/</A>
-- <A HREF="http://libexif.sourceforge.net/">http://libexif.sourceforge.net/</A>
-
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-from format import getFormatSize
-import struct
-
-class ExifEntry(Filter):
-    format = {
-        1: (1, &quot;B&quot;),
-        2: (1, &quot;s&quot;),
-        3: (1, &quot;H&quot;),
-        4: (1, &quot;L&quot;),
-        5: (2, &quot;L&quot;),
-        7: (1, &quot;s&quot;),
-#        9: (1, &quot;l&quot;),
-#        10: (2, &quot;l&quot;)
-        9: (1, &quot;L&quot;),
-        10: (2, &quot;L&quot;)
-    }
-
-    type_name = {    
-        1: &quot;BYTE (8 bits)&quot;,
-        2: &quot;ASCII (8 bits)&quot;,
-        3: &quot;SHORT (16 bits)&quot;,
-        4: &quot;LONG (32 bits)&quot;,
-        5: &quot;RATIONAL (two LONGs)&quot;,
-        7: &quot;UNDEFINED (8 bits)&quot;,
-        9: &quot;SLONG (32 bits)&quot;,
-        10: &quot;SRATIONTAL (two SLONGs)&quot;
-    }
-
-    tag_name = {    
-        0x0100: &quot;Image width&quot;,
-        0x0101: &quot;Image height&quot;,
-        0x0102: &quot;Number of bits per component&quot;,
-        0x0103: &quot;Compression scheme&quot;,
-        0x0106: &quot;Pixel composition&quot;,
-        0x0112: &quot;Orientation of image&quot;,
-        0x0115: &quot;Number of components&quot;,
-        0x011C: &quot;Image data arrangement&quot;,
-        0x0212: &quot;Subsampling ratio Y to C&quot;,
-        0x0213: &quot;Y and C positioning&quot;,
-        0x011A: &quot;Image resolution width direction&quot;,
-        0x011B: &quot;Image resolution in height direction&quot;,
-        0x0128: &quot;Unit of X and Y resolution&quot;,
-        
-        0x0111: &quot;Image data location&quot;,
-        0x0116: &quot;Number of rows per strip&quot;,
-        0x0117: &quot;Bytes per compressed strip&quot;,
-        0x0201: &quot;Offset to JPEG SOI&quot;,
-        0x0202: &quot;Bytes of JPEG data&quot;,
-        
-        0x012D: &quot;Transfer function&quot;,
-        0x013E: &quot;White point chromaticity&quot;,
-        0x013F: &quot;Chromaticities of primaries&quot;,
-        0x0211: &quot;Color space transformation matrix coefficients&quot;,
-        0x0214: &quot;Pair of blank and white reference values&quot;,
-        
-        0x0132: &quot;File change date and time&quot;,
-        0x010e: &quot;Image title&quot;,
-        0x010f: &quot;Camera (Image input equipment) manufacturer&quot;,
-        0x0110: &quot;Camera (Input input equipment) model&quot;,
-        0x0131: &quot;Software&quot;,
-        0x013B: &quot;File change date and time&quot;,
-        0x8298: &quot;Copyright holder&quot;,
-        0x8769: &quot;Exif IFD Pointer&quot;,
-
-        0x829A: &quot;Exposure time&quot;,
-        0x829D: &quot;F number&quot;,
-        0x8822: &quot;Exposure program&quot;,
-        0x8824: &quot;Spectral sensitivity&quot;,
-        0x8827: &quot;ISO speed rating&quot;,
-        0x8828: &quot;Optoelectric conversion factor OECF&quot;,
-        0x9201: &quot;Shutter speed&quot;,
-        0x9202: &quot;Aperture&quot;,
-        0x9203: &quot;Brightness&quot;,
-        0x9204: &quot;Exposure bias&quot;,
-        0x9205: &quot;Maximum lens aperture&quot;,
-        0x9206: &quot;Subject distance&quot;,
-        0x9207: &quot;Metering mode&quot;,
-        0x9208: &quot;Light source&quot;,
-        0x9209: &quot;Flash&quot;,
-        0x920A: &quot;Lens focal length&quot;,
-        0x9214: &quot;Subject area&quot;,
-        0xA20B: &quot;Flash energy&quot;,
-        0xA20C: &quot;Spatial frequency response&quot;,
-        0xA20E: &quot;Focal plane X resolution&quot;,
-        0xA20F: &quot;Focal plane Y resolution&quot;,
-        0xA210: &quot;Focal plane resolution unit&quot;,
-        0xA214: &quot;Subject location&quot;,
-        0xA215: &quot;Exposure index&quot;,
-        0xA217: &quot;Sensing method&quot;,
-        0xA300: &quot;File source&quot;,
-        0xA301: &quot;Scene type&quot;,
-        0xA302: &quot;CFA pattern&quot;,
-        0xA401: &quot;Custom image processing&quot;,
-        0xA402: &quot;Exposure mode&quot;,
-        0xA403: &quot;White balance&quot;,
-        0xA404: &quot;Digital zoom ratio&quot;,
-        0xA405: &quot;Focal length in 35 mm film&quot;,
-        0xA406: &quot;Scene capture type&quot;,
-        0xA407: &quot;Gain control&quot;,
-        0xA408: &quot;Contrast&quot;,
-
-        0x9000: &quot;Exif version&quot;,
-        0xA000: &quot;Supported Flashpix version&quot;,
-        0xA001: &quot;Color space information&quot;,
-        0x9101: &quot;Meaning of each component&quot;,
-        0x9102: &quot;Image compression mode&quot;,
-        0xA002: &quot;Valid image width&quot;,
-        0xA003: &quot;Valid image height&quot;,
-        0x927C: &quot;Manufacturer notes&quot;,
-        0x9286: &quot;User comments&quot;,
-        0xA004: &quot;Related audio file&quot;,
-        0x9003: &quot;Date and time of original data generation&quot;,
-        0x9004: &quot;Date and time of digital data generation&quot;,
-        0x9290: &quot;DateTime subseconds&quot;,
-        0x9291: &quot;DateTimeOriginal subseconds&quot;,
-        0x9292: &quot;DateTimeDigitized subseconds&quot;,
-        0xA420: &quot;Unique image ID&quot;,
-        0xA005: &quot;Interoperability IFD Pointer&quot;
-    }
-
-    def __init__(self, stream, parent, endian):
-        Filter.__init__(self, &quot;exif_entry&quot;, &quot;Exif entry&quot;, stream, parent)
-        self.endian = endian
-        self.read(&quot;tag&quot;, endian+&quot;H&quot;, &quot;Tag&quot;, post=self.processTag)
-        self.read(&quot;type&quot;, endian+&quot;H&quot;, &quot;Type&quot;, post=self.processType)
-        self.read(&quot;count&quot;, endian+&quot;L&quot;, &quot;Count&quot;)
-
-        # Create format
-        format = ExifEntry.format.get(self[&quot;type&quot;], (1, &quot;B&quot;))
-        self.format = &quot;%s%u%s&quot; % (self.endian, format[0]*self[&quot;count&quot;], format[1])
-
-        # Get size
-        self.size = getFormatSize(self.format)
-
-        # Get offset/value
-        if 4 &lt; self.size:
-            self.read(&quot;offset&quot;, endian+&quot;L&quot;, &quot;Value offset&quot;)
-        else:
-            self.read(&quot;value&quot;, self.format, &quot;Value&quot;)
-            if self.size &lt; 4:
-                self.read(&quot;padding&quot;, &quot;%us&quot; % (4-self.size), &quot;Padding&quot;)
-
-    def updateParent(self, parent):
-        parent.description = &quot;Exif entry (%s)&quot; % self.getTag() 
-
-    def getTag(self):
-        return ExifEntry.tag_name.get(self[&quot;tag&quot;], &quot;Unknown tag (0x%04X)&quot; % self[&quot;tag&quot;])
-
-    def processType(self, chunk):
-        return ExifEntry.type_name.get(chunk.value, &quot;%u&quot; % chunk.value) 
-
-    def processTag(self, chunk):
-        chunk.description = self.getTag()
-        return &quot;0x%04X&quot; % chunk.value 
-
-def sortExifEntry(a,b):
-    return int( a[&quot;offset&quot;] - b[&quot;offset&quot;] )
-
-class ExifIFD(Filter):
-    def __init__(self, stream, parent, endian, offset_diff):
-        Filter.__init__(self, &quot;exif&quot;, &quot;Exif IFD&quot;, stream, parent)
-        self.endian = endian
-        self.read(&quot;id&quot;, endian+&quot;H&quot;, &quot;IFD identifier&quot;)
-        entries = []
-        next_chunk_offset = None
-        while True:
-            next = stream.getFormat(&quot;!L&quot;, False)[0]
-            if next in (0, 0xF0000000):
-                break
-            chunk = self.readChild(&quot;entry[]&quot;, ExifEntry, endian)
-            entry = chunk.getFilter()
-            if entry[&quot;tag&quot;] in (0x8769, 0x0201):
-                next_chunk_offset = entry[&quot;value&quot;]+offset_diff
-                break
-            if 4 &lt; entry.size:
-                entries.append(entry)
-        self.read(&quot;next&quot;, endian+&quot;L&quot;, &quot;Next IFD offset&quot;)
-        entries.sort( sortExifEntry )
-        for entry in entries:
-            offset = entry[&quot;offset&quot;]+offset_diff
-            padding = offset - stream.tell()
-            if 0 &lt; padding:
-                self.read(&quot;padding[]&quot;, &quot;%us&quot; % padding, &quot;Padding (?)&quot;)
-            assert offset == stream.tell()
-            self.read(&quot;entry_value[]&quot;, entry.format, &quot;Value of %s&quot; % entry.getId())
-        if next_chunk_offset != None:
-            padding = next_chunk_offset - stream.tell()
-            if 0 &lt; padding:
-                self.read(&quot;padding[]&quot;, &quot;%us&quot; % padding, &quot;Padding (?)&quot;)
-
-    def updateParent(self, chunk):
-        desc = &quot;Exif IFD (id %s)&quot; % self[&quot;id&quot;]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ExifFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;exif&quot;, &quot;Exif&quot;, stream, parent)
-
-        # Headers
-        self.read(&quot;header&quot;, &quot;6s&quot;, &quot;Header (Exif\\0\\0)&quot;)
-        assert self[&quot;header&quot;] == &quot;Exif\0\0&quot;
-        self.read(&quot;byte_order&quot;, &quot;2s&quot;, &quot;Byte order&quot;)
-        assert self[&quot;byte_order&quot;] in (&quot;II&quot;, &quot;MM&quot;)
-        if self[&quot;byte_order&quot;] == &quot;II&quot;:
-           endian = &quot;&lt;&quot;
-        else:
-           endian = &quot;&gt;&quot;
-        self.read(&quot;header2&quot;, endian+&quot;H&quot;, &quot;Header2 (42)&quot;)
-
-        self.read(&quot;nb_entry&quot;, endian+&quot;H&quot;, &quot;Number of entries&quot;)
-        self.read(&quot;whatsthis?&quot;, endian+&quot;H&quot;, &quot;What's this ??&quot;)
-        while True:
-            tag = stream.getN(2, False)
-            if tag == &quot;\xFF\xD8&quot;:
-                size = stream.getSize() - stream.tell()
-                sub = stream.createLimited(size=size)
-                from jpeg import JpegFile
-                self.readStreamChild(&quot;thumbnail&quot;, sub, JpegFile)
-                break
-            if tag == &quot;\xFF\xFF&quot;:
-                break
-            self.readChild(&quot;ifd[]&quot;, ExifIFD, endian, 6)
-        size = stream.getSize() - stream.tell()
-        if 0 &lt; size:
-            self.read(&quot;end&quot;, &quot;%us&quot; % size, &quot;End&quot;)
-        assert self.getSize() == stream.getSize()

Deleted: haypo/hachoir/trunk/plugins/ext2.py
===================================================================
--- haypo/hachoir/trunk/plugins/ext2.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/ext2.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,424 +0,0 @@
-&quot;&quot;&quot;
-EXT2 (Linux) file system parser.
-
-Sources:
-- EXT2FS source code
-  <A HREF="http://ext2fsd.sourceforge.net/">http://ext2fsd.sourceforge.net/</A>
-- Analysis of the Ext2fs structure
-  <A HREF="http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/">http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/</A>
-&quot;&quot;&quot;
-
-from datetime import datetime
-from filter import Filter, OnDemandFilter
-from plugin import registerPlugin
-from tools import humanDuration, getUnixRWX, humanFilesize
-
-class DirectoryEntry(OnDemandFilter):
-    file_type = {
-        1: &quot;Regular&quot;,
-        2: &quot;Directory&quot;,
-        3: &quot;Char. dev.&quot;,
-        4: &quot;Block dev.&quot;,
-        5: &quot;Fifo&quot;,
-        6: &quot;Socket&quot;,
-        7: &quot;Symlink&quot;,
-        8: &quot;Max&quot;
-    }
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;dir&quot;, &quot;EXT2 directory entry&quot;, stream, parent)
-        self.read(&quot;inode&quot;, &quot;&lt;L&quot;, &quot;Inode&quot;)
-        self.read(&quot;rec_len&quot;, &quot;&lt;H&quot;, &quot;Record length&quot;)
-        name_length = self.doRead(&quot;name_len&quot;, &quot;B&quot;, &quot;Name length&quot;).value
-        self.read(&quot;file_type&quot;, &quot;B&quot;, &quot;File type&quot;, post=self.postFileType)
-        self.read(&quot;name&quot;, &quot;%us&quot; % name_length, &quot;Name&quot;)
-        size = self[&quot;rec_len&quot;]-8-name_length 
-        if size != 0:
-            self.read(&quot;padding&quot;, &quot;%us&quot; % size, &quot;Padding&quot;)
-
-    def updateParent(self, chunk):        
-        name = self[&quot;name&quot;].strip(&quot;\0&quot;)
-        if name != &quot;&quot;:
-            desc = &quot;Directory entry: %s&quot; % name
-        else:
-            desc = &quot;Directory entry (empty)&quot;
-        chunk.description = desc
-        self.setDescription(desc)
-
-    def postFileType(self, chunk):
-        type = chunk.value
-        return DirectoryEntry.file_type.get(type, &quot;Unknow (%02X)&quot; % type)
-
-class Inode(OnDemandFilter):
-    name = {
-        1: &quot;list of bad blocks&quot;,
-        2: &quot;Root directory&quot;,
-        3: &quot;ACL inode&quot;,
-        4: &quot;ACL inode&quot;,
-        5: &quot;Boot loader&quot;,
-        6: &quot;Undelete directory&quot;,
-        8: &quot;EXT3 journal&quot;
-    }
-    
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, &quot;inode&quot;, &quot;EXT2 inode&quot;, stream, parent)
-        self.index = index
-        self.read(&quot;mode&quot;, &quot;&lt;H&quot;, &quot;Mode&quot;, post=self.postMode)
-        self.read(&quot;uid&quot;, &quot;&lt;H&quot;, &quot;User ID&quot;)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;File size&quot;)
-        self.read(&quot;atime&quot;, &quot;&lt;L&quot;, &quot;Last access time&quot;, post=self.getTime)
-        self.read(&quot;ctime&quot;, &quot;&lt;L&quot;, &quot;Creation time&quot;, post=self.getTime)
-        self.read(&quot;mtime&quot;, &quot;&lt;L&quot;, &quot;Last modification time&quot;, post=self.getTime)
-        self.read(&quot;dtime&quot;, &quot;&lt;L&quot;, &quot;Delete time&quot;, post=self.getTime)
-        self.read(&quot;gid&quot;, &quot;&lt;H&quot;, &quot;Group ID&quot;)
-        self.read(&quot;links_count&quot;, &quot;&lt;H&quot;, &quot;Links count&quot;)
-        self.read(&quot;blocks&quot;, &quot;&lt;L&quot;, &quot;Number of blocks&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;L&quot;, &quot;Flags&quot;)
-        self.read(&quot;reserved1&quot;, &quot;&lt;L&quot;, &quot;Reserved&quot;)
-        for i in range(0,15):
-            self.read(&quot;block[]&quot;, &quot;&lt;L&quot;, &quot;Block %i&quot; % i)
-        self.read(&quot;version&quot;, &quot;&lt;L&quot;, &quot;Version&quot;)
-        self.read(&quot;file_acl&quot;, &quot;&lt;L&quot;, &quot;File ACL&quot;)
-        self.read(&quot;dir_acl&quot;, &quot;&lt;L&quot;, &quot;Directory ACL&quot;)
-        self.read(&quot;faddr&quot;, &quot;&lt;L&quot;, &quot;Block where the fragment of the file resides&quot;)
-        os = parent.getParent().getParent().superblock[&quot;creator_os&quot;]
-        if os == SuperBlock.OS_LINUX:
-            self.read(&quot;frag&quot;, &quot;B&quot;, &quot;Number of fragments in the block&quot;)
-            self.read(&quot;fsize&quot;, &quot;B&quot;, &quot;Fragment size&quot;)
-            self.read(&quot;padding&quot;, &quot;&lt;H&quot;, &quot;Padding&quot;)
-            self.read(&quot;uid_high&quot;, &quot;&lt;H&quot;, &quot;High 16 bits of user ID&quot;)
-            self.read(&quot;gid_high&quot;, &quot;&lt;H&quot;, &quot;High 16 bits of group ID&quot;)
-            self.read(&quot;reserved&quot;, &quot;&lt;L&quot;, &quot;Reserved&quot;)
-        elif os == SuperBlock.OS_HURD:
-            self.read(&quot;frag&quot;, &quot;B&quot;, &quot;Number of fragments in the block&quot;)
-            self.read(&quot;fsize&quot;, &quot;B&quot;, &quot;Fragment size&quot;)
-            self.read(&quot;mode_high&quot;, &quot;&lt;H&quot;, &quot;High 16 bits of mode&quot;)
-            self.read(&quot;uid_high&quot;, &quot;&lt;H&quot;, &quot;High 16 bits of user ID&quot;)
-            self.read(&quot;gid_high&quot;, &quot;&lt;H&quot;, &quot;High 16 bits of group ID&quot;)
-            self.read(&quot;author&quot;, &quot;&lt;L&quot;, &quot;Author ID (?)&quot;)
-        else:
-            self.read(&quot;raw&quot;, &quot;12s&quot;, &quot;Reserved&quot;)
-
-    def updateParent(self, chunk):
-        desc = &quot;Inode %s: &quot; % self.index
-        size = humanFilesize(self[&quot;size&quot;])
-        if 11 &lt;= self.index:
-            desc = desc + &quot;file, size=%s, mode=%s&quot; % (size, self.getChunk(&quot;mode&quot;).display)
-        else:
-            if self.index in Inode.name:
-                desc = desc + Inode.name[self.index]
-                if self.index == 2:
-                    desc = desc + &quot; (%s)&quot; % getUnixRWX(self[&quot;mode&quot;])
-            else:
-                desc = desc + &quot;special&quot;
-            if size == 0:
-                desc = desc + &quot; (unused)&quot;
-        chunk.description = desc
-        self.setDescription(desc)
-
-    def postMode(self, chunk):
-        mode = chunk.value
-        text = &quot;&quot;
-        if mode &amp; 0100000 != 0:
-            text = &quot;regular (%s)&quot; % getUnixRWX(mode)
-        elif mode &amp; 0040000:
-            text = &quot;directory (%s)&quot; % getUnixRWX(mode)
-        elif mode &amp; 0020000:
-            text = &quot;char. dev.&quot;
-        elif mode &amp; 0060000:
-            text = &quot;block dev.&quot;
-        elif mode &amp; 0010000:
-            text = &quot;fifo&quot;
-        elif mode &amp; 0120000:
-            text = &quot;sym. link&quot;
-        elif mode &amp; 0140000:
-            text = &quot;socket&quot;
-        elif mode == 0:
-            text = &quot;(empty)&quot;
-        else:
-            text = &quot;???&quot;
-        return text
-
-    def getTime(self, chunk):
-        if chunk.value != 0:
-            return datetime.fromtimestamp(chunk.value)
-        else:
-            return &quot;(empty)&quot;
-
-class Bitmap(OnDemandFilter):
-    def __init__(self, stream, parent, description, count, start):
-        OnDemandFilter.__init__(self, &quot;bitmap&quot;, &quot;%s: %s items&quot; % (description, count), stream, parent)
-        self.start = start
-        size = count / 8
-        self.read(&quot;block_bitmap&quot;, &quot;%us&quot; % size, &quot;Bitmap&quot;)
-
-    def showFree(self, type=&quot;Block&quot;):
-        data = self[&quot;block_bitmap&quot;]
-        cpt = self.start
-        for octet in data:
-            octet = ord(octet)
-            mask = 1
-            for i in range(0,8):
-                if octet &amp; mask == 0:
-                    print &quot;%s %s free.&quot; % (type, cpt)
-                cpt = cpt + 1
-                mask = mask &lt;&lt; 1
-
-BlockBitmap = Bitmap
-InodeBitmap = Bitmap
-
-class GroupDescriptor(OnDemandFilter):
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, &quot;group&quot;, &quot;Group descriptor&quot;, stream, parent)
-        self.index = index
-        self.read(&quot;block_bitmap&quot;, &quot;&lt;L&quot;, &quot;Points to the blocks bitmap block&quot;)
-        self.read(&quot;inode_bitmap&quot;, &quot;&lt;L&quot;, &quot;Points to the inodes bitmap block&quot;)
-        self.read(&quot;inode_table&quot;, &quot;&lt;L&quot;, &quot;Points to the inodes table first block&quot;)
-        self.read(&quot;free_blocks_count&quot;, &quot;&lt;H&quot;, &quot;Number of free blocks&quot;)
-        self.read(&quot;free_inodes_count&quot;, &quot;&lt;H&quot;, &quot;Number of free inodes&quot;)
-        self.read(&quot;used_dirs_count&quot;, &quot;&lt;H&quot;, &quot;Number of inodes allocated to directories&quot;)
-        self.read(&quot;padding&quot;, &quot;&lt;H&quot;, &quot;Padding&quot;)
-        self.read(&quot;reserved&quot;, &quot;12s&quot;, &quot;Reserved&quot;)
-
-    def updateParent(self, chunk):
-        superblock = self.getParent().getParent().superblock
-        blocks_per_group = superblock[&quot;blocks_per_group&quot;]
-        start = self.index * blocks_per_group
-        end = start + blocks_per_group 
-        chunk.description = &quot;Group descriptor: blocks %s-%s&quot; % (start, end)
-    
-
-class SuperBlock(OnDemandFilter):
-    error_handling = {
-        1: &quot;Continue&quot;
-    }
-    OS_LINUX = 0
-    OS_HURD = 1
-    os_name = {
-        0: &quot;Linux&quot;,
-        1: &quot;Hurd&quot;,
-        2: &quot;Masix&quot;,
-        3: &quot;FreeBSD&quot;,
-        4: &quot;Lites&quot;,
-        5: &quot;WinNT&quot;
-    }
-    state = {
-        1: &quot;Valid&quot;,
-        2: &quot;Error&quot;
-    }
-    
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;super_block&quot;, &quot;Super block&quot;, stream, parent)
-        self.read(&quot;inodes_count&quot;, &quot;&lt;L&quot;, &quot;Inodes count&quot;)
-        self.read(&quot;blocks_count&quot;, &quot;&lt;L&quot;, &quot;Blocks count&quot;)
-        self.read(&quot;r_blocks_count&quot;, &quot;&lt;L&quot;, &quot;Reserved blocks count&quot;)
-        self.read(&quot;free_blocks_count&quot;, &quot;&lt;L&quot;, &quot;Free blocks count&quot;)
-        self.read(&quot;free_inodes_count&quot;, &quot;&lt;L&quot;, &quot;Free inodes count&quot;)
-        first = self.doRead(&quot;first_data_block&quot;, &quot;&lt;L&quot;, &quot;First data block&quot;).value
-        assert (first == 0)
-        self.read(&quot;log_block_size&quot;, &quot;&lt;L&quot;, &quot;Block size&quot;)
-        self.read(&quot;log_frag_size&quot;, &quot;&lt;L&quot;, &quot;Fragment size&quot;)
-        self.read(&quot;blocks_per_group&quot;, &quot;&lt;L&quot;, &quot;Blocks per group&quot;)
-        self.read(&quot;frags_per_group&quot;, &quot;&lt;L&quot;, &quot;Fragments per group&quot;)
-        self.read(&quot;inodes_per_group&quot;, &quot;&lt;L&quot;, &quot;Inodes per group&quot;)
-        self.read(&quot;mtime&quot;, &quot;&lt;L&quot;, &quot;Mount time&quot;, post=self.getTime)
-        self.read(&quot;wtime&quot;, &quot;&lt;L&quot;, &quot;Write time&quot;, post=self.getTime)
-        self.read(&quot;mnt_count&quot;, &quot;&lt;H&quot;, &quot;Mount count&quot;)
-        self.read(&quot;max_mnt_count&quot;, &quot;&lt;h&quot;, &quot;Max mount count&quot;)
-        id = self.doRead(&quot;magic&quot;, &quot;&gt;H&quot;, &quot;Magic number (0x53EF)&quot;).value
-        assert id == 0x53EF
-
-        # Read state
-        chunk = self.doRead(&quot;state&quot;, &quot;&lt;H&quot;, &quot;File system state&quot;)
-        chunk.description = &quot;Behaviour when detecting errors: %s&quot; % \
-            SuperBlock.state.get(chunk.value, &quot;Unknow (%s)&quot; % chunk.value)
-
-        # Read error handling
-        chunk = self.doRead(&quot;errors&quot;, &quot;&lt;H&quot;, &quot;&quot;)
-        desc = &quot;Behaviour when detecting errors&quot;
-        if chunk.value in SuperBlock.error_handling:
-            desc = &quot;%s: %s&quot; % (desc, SuperBlock.error_handling[chunk.value])
-        chunk.description = desc
-        
-        self.read(&quot;minor_rev_level&quot;, &quot;&lt;H&quot;, &quot;Minor revision level&quot;)
-        self.read(&quot;last_check&quot;, &quot;&lt;L&quot;, &quot;Time of last check&quot;, post=self.getTime)
-        self.read(&quot;check_interval&quot;, &quot;&lt;L&quot;, &quot;Maximum time between checks&quot;, post=self.postMaxTime)
-        
-        chunk = self.doRead(&quot;creator_os&quot;, &quot;&lt;L&quot;, &quot;&quot;)
-        desc = &quot;Creator OS&quot;
-        if chunk.value in SuperBlock.os_name:
-            desc = &quot;%s: %s&quot; % (desc, SuperBlock.os_name[chunk.value])
-        chunk.description = desc
-        
-        self.read(&quot;rev_level&quot;, &quot;&lt;L&quot;, &quot;Revision level&quot;)
-        self.read(&quot;def_resuid&quot;, &quot;&lt;H&quot;, &quot;Default uid for reserved blocks&quot;)
-        self.read(&quot;def_resgid&quot;, &quot;&lt;H&quot;, &quot;Default guid for reserverd blocks&quot;)
-
-        # ---------
-
-        self.read(&quot;first_ino&quot;, &quot;&lt;L&quot;, &quot;First non-reserved inode&quot;)
-        inode_size = self.doRead(&quot;inode_size&quot;, &quot;&lt;H&quot;, &quot;Size of inode structure&quot;).value
-        assert inode_size == (68 + 15*4)
-        self.read(&quot;block_group_nr&quot;, &quot;&lt;H&quot;, &quot;Block group # of this superblock&quot;)
-        self.read(&quot;feature_compat&quot;, &quot;&lt;L&quot;, &quot;Compatible feature set&quot;)
-        self.read(&quot;feature_incompat&quot;, &quot;&lt;L&quot;, &quot;Incompatible feature set&quot;)
-        self.read(&quot;feature_ro_compat&quot;, &quot;&lt;L&quot;, &quot;Read-only compatible feature set&quot;)
-        self.read(&quot;uuid&quot;, &quot;16s&quot;, &quot;128-bit uuid for volume&quot;)
-        self.read(&quot;volume_name&quot;, &quot;16s&quot;, &quot;Volume name&quot;)
-        self.read(&quot;last_mounted&quot;, &quot;64s&quot;, &quot;Directory where last mounted&quot;)
-        self.read(&quot;compression&quot;, &quot;&lt;L&quot;, &quot;For compression (algorithm usage bitmap)&quot;)
-        
-        self.read(&quot;prealloc_blocks&quot;, &quot;B&quot;, &quot;Number of blocks to try to preallocate&quot;)
-        self.read(&quot;prealloc_dir_blocks&quot;, &quot;B&quot;, &quot;Number to preallocate for directories&quot;)
-        self.read(&quot;padding&quot;, &quot;H&quot;, &quot;Padding&quot;)
-        
-        self.read(&quot;journal_uuid&quot;, &quot;16s&quot;, &quot;uuid of journal superblock&quot;)
-        self.read(&quot;journal_inum&quot;, &quot;&lt;L&quot;, &quot;inode number of journal file&quot;)
-        self.read(&quot;journal_dev&quot;, &quot;&lt;L&quot;, &quot;device number of journal file&quot;)
-        self.read(&quot;last_orphan&quot;, &quot;&lt;L&quot;, &quot;start of list of inodes to delete&quot;)
-        
-        self.read(&quot;reserved&quot;, &quot;197s&quot;, &quot;Padding to the end of the block&quot;)
-
-        blocks_per_group = self[&quot;blocks_per_group&quot;]
-        self.group_count = (self[&quot;blocks_count&quot;] - self[&quot;first_data_block&quot;] + blocks_per_group - 1) / blocks_per_group
-
-    def updateParent(self, chunk):
-        if self[&quot;feature_compat&quot;] &amp; 4 == 4:
-            type = &quot;ext3&quot;
-        else:
-            type = &quot;ext2&quot;
-        desc = &quot;Superblock: %s file system&quot; % type
-        self.setDescription(desc)
-        chunk.description = desc
-
-    def postMaxTime(self, chunk):
-        return humanDuration(chunk.value * 1000)
-
-    def getTime(self, chunk):
-        return datetime.fromtimestamp(chunk.value)
-
-class GroupDescriptors(OnDemandFilter):
-    def __init__(self, stream, parent, count, start):
-        OnDemandFilter.__init__(self, &quot;groups&quot;, &quot;Group descriptors: %s items&quot; % count, stream, parent)
-        self.start = start
-        for i in range(0, count):
-            self.readSizedChild(&quot;group[]&quot;, &quot;Group&quot;, 32, GroupDescriptor, i)
-
-    def getGroup(self, index):
-        return self[&quot;group[%s]&quot; % (self.start + index)]
-
-class InodeTable(OnDemandFilter):
-    def __init__(self, stream, parent, start, count):
-        OnDemandFilter.__init__(self, &quot;ino_table&quot;, &quot;Inode table: %s inodes&quot; % count, stream, parent)
-        self.start = start
-        chunk_size = parent.getParent().superblock[&quot;inode_size&quot;]
-        for index in range(self.start, self.start+count):
-            self.readSizedChild(&quot;inode[]&quot;, &quot;Inode %s&quot; % index, chunk_size, Inode, index)
-
-    def __getitem__(self, index):
-        index = index - self.start - 1
-        return self.getChunk(&quot;inode[%u]&quot; % index).getFilter()
-
-def testSuperblock(stream):
-    oldpos = stream.tell()
-    stream.seek(80-24, 1)
-    is_super = stream.getN(2) == &quot;\x53\xEF&quot;    
-    stream.seek(oldpos)
-    return is_super
-
-class Group(OnDemandFilter):
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, &quot;group&quot;, &quot;Group %u&quot; % index, stream, parent)
-        self.index = index
-        group = parent[&quot;group_desc&quot;].getGroup(index)
-        superblock = parent.superblock
-        block_size = parent.block_size
-    
-        # Read block bitmap
-        self.superblock_copy = False
-        if testSuperblock(stream):
-            self.readChild(&quot;superblock_copy&quot;, &quot;Superblock&quot;, SuperBlock)
-            self.superblock_copy = True
-        self.seek(group[&quot;block_bitmap&quot;] * block_size)
-            
-        count = superblock[&quot;blocks_per_group&quot;]
-        self.readSizedChild(&quot;block_bitmap[]&quot;, &quot;Block bitmap&quot;, count / 8, BlockBitmap, &quot;Block bitmap&quot;, count, 0)
-
-        # Read inode bitmap
-        assert (group[&quot;inode_bitmap&quot;] * block_size) == stream.tell()
-        count = superblock[&quot;inodes_per_group&quot;]
-        self.readSizedChild(&quot;inode_bitmap[]&quot;, &quot;Inode bitmap&quot;, count / 8, InodeBitmap, &quot;Inode bitmap&quot;, count, 1)
-        addr = stream.tell() % 4096
-        if addr != 0:
-            addr = stream.tell() + (4096 - addr % 4096)
-            self.seek(addr)
-             
-        count = superblock[&quot;inodes_per_group&quot;]
-        size = superblock[&quot;inode_size&quot;] * count
-        inode_index = 1 + index * count
-        self.readSizedChild(&quot;inode_table[]&quot;, &quot;Inode table&quot;, size, InodeTable, inode_index, count)
-
-        size = (index+1) * superblock[&quot;blocks_per_group&quot;] * block_size
-        if stream.getSize() &lt; size:
-            size = stream.getSize()
-        size = size - stream.tell() 
-        self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;Data&quot;)
-
-    def updateParent(self, chunk):
-        desc = &quot;Group %s: %s&quot; % (self.index, humanFilesize(self.getSize()))
-        if self.superblock_copy:
-            desc = desc + &quot; (with superblock copy)&quot;
-        chunk.description = desc 
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 &lt;= size
-        if 0 &lt; size:
-            self.read(&quot;raw[]&quot;, &quot;%us&quot; % size, &quot;Raw&quot;)
-
-
-class EXT2_FS(OnDemandFilter):
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;ext2&quot;, &quot;EXT2 file system&quot;, stream, parent)
-        
-        # Read superblock
-        self.seek(1024) 
-        self.superblock = self.doReadChild(&quot;superblock&quot;, &quot;Super block&quot;, SuperBlock).getFilter()
-        self.block_size = 1024 &lt;&lt; self.superblock[&quot;log_block_size&quot;]
-
-        # Read groups
-        self.seek(4096) 
-        groups = self.doReadChild(&quot;group_desc&quot;, &quot;Group descriptors&quot;, GroupDescriptors, self.superblock.group_count, 0).getFilter()
-        self.seek(groups.getGroup(0)[&quot;block_bitmap&quot;] * self.block_size)
-        for i in range(0,self.superblock.group_count):
-            self.readChild(&quot;group[]&quot;, &quot;Group&quot;, Group, i)
-
-        size = stream.getSize() - stream.tell()
-        if size != 0:
-            self.read(&quot;end&quot;, &quot;%us&quot; % size, &quot;End (raw)&quot;)
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 &lt;= size
-        if 0 &lt; size:
-            self.read(&quot;raw[]&quot;, &quot;%us&quot; % size, &quot;Raw&quot;)
-
-    def readDirectory(self, inode):
-        stream = self.getStream()
-        block_index = 0
-        while True:
-            assert block_index &lt; 12
-            block = inode[&quot;block[%u]&quot; % block_index]
-            if block == 0:
-                return
-            self.seek(block * self.block_size)
-
-            total = 0
-            while total &lt; self.block_size:
-                entry = self.doReadChild(&quot;directory[]&quot;, &quot;Directory entry&quot;, DirectoryEntry).getFilter()
-                if entry[&quot;inode&quot;] == 0:
-                    return
-                total = total + entry.getSize()
-            assert total == self.block_size
-            block_index = block_index + 1
-
-registerPlugin(EXT2_FS, &quot;hachoir/fs-ext2&quot;)

Deleted: haypo/hachoir/trunk/plugins/gif.py
===================================================================
--- haypo/hachoir/trunk/plugins/gif.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/gif.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,130 +0,0 @@
-&quot;&quot;&quot;
-GIF splitter.
-
-Status: loads header, don't load image data (stop filter), and is buggy ...
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-from error import warning
-
-class GifColor(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;gif_color&quot;, &quot;GIF color (RGB)&quot;, stream, parent)
-        self.read(&quot;red&quot;, &quot;&lt;B&quot;, &quot;Red&quot;)
-        self.read(&quot;green&quot;, &quot;&lt;B&quot;, &quot;Green&quot;)
-        self.read(&quot;blue&quot;, &quot;&lt;B&quot;, &quot;Blue&quot;)
-
-class GifImage(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;gif_image&quot;, &quot;GIF image data&quot;, stream, parent)
-        self.read(&quot;left&quot;, &quot;&lt;H&quot;, &quot;Left&quot;)
-        self.read(&quot;top&quot;, &quot;&lt;H&quot;, &quot;Top&quot;)
-        self.read(&quot;width&quot;, &quot;&lt;H&quot;, &quot;Width&quot;)
-        self.read(&quot;height&quot;, &quot;&lt;H&quot;, &quot;Height&quot;)
-
-        # TODO: Fix this ...
-        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;Flags&quot;)
-        self.global_map = ((self[&quot;flags&quot;] &amp; 0x80) == 0x80)
-        self.interlaced = ((self[&quot;flags&quot;] &amp; 0x40) == 0x40)
-        self.bits_per_pixel = 1 + (self[&quot;flags&quot;] &amp; 0x07)
-        if not self.global_map:
-            self.readChild(&quot;local_map&quot;, GifColorMap)
-            self.local_map = self[&quot;local_map&quot;]
-        else:
-            self.local_map = None
-        # -- End of TODO
-
-class GifColorMap(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;gif_colormap&quot;, &quot;GIF color map&quot;, stream, parent)
-        if issubclass(parent.__class__, GifImage):
-            self._nb_colors = (1 &lt;&lt; parent.bits_per_pixel)
-        else:
-            assert issubclass(parent.__class__, GifFile)
-            screen = parent.getChunk(&quot;screen&quot;).getFilter()
-            self._nb_colors = (1 &lt;&lt; screen.bits_per_pixel)
-        n = 0
-        while n&lt;self._nb_colors:
-            self.readChild(&quot;color[]&quot;, GifColor)
-            n = n + 1
-
-    def checkEndOfMap(self, stream, array, color):
-        return len(array) == self._nb_colors 
-
-class GifExtensionChunk(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;gif_ext_data&quot;, &quot;GIF extension data&quot;, stream, parent)
-        self.read(&quot;size&quot;, &quot;B&quot;, &quot;Size (in bytes)&quot;)
-        self.read(&quot;content&quot;, &quot;%us&quot; % self[&quot;size&quot;], &quot;Content&quot;)
-
-class GifExtension(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;gif_ext&quot;, &quot;GIF extension&quot;, stream, parent)
-        self.read(&quot;func&quot;, &quot;&lt;B&quot;, &quot;Function&quot;)
-        while True:
-            chunk = self.readChild(&quot;chunk[]&quot;, GifExtensionChunk)
-            if chunk.getFilter()[&quot;size&quot;] == 0:
-                break
-        
-class GifScreenDescriptor(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;gif_screen_desc&quot;, &quot;GIF screen descriptor&quot;, stream, parent)
-        self.read(&quot;width&quot;, &quot;&lt;H&quot;, &quot;Width&quot;)
-        self.read(&quot;height&quot;, &quot;&lt;H&quot;, &quot;Height&quot;)
-
-        # TODO: Fix this
-        self.read(&quot;flags&quot;, &quot;&lt;B&quot;, &quot;Flags&quot;, post=self.processFlags)
-        # -- End of TODO
-        
-        self.read(&quot;background&quot;, &quot;&lt;B&quot;, &quot;Background color&quot;)
-        self.read(&quot;notused&quot;, &quot;&lt;B&quot;, &quot;Not used (zero)&quot;)
-
-    def processFlags(self, chunk):
-        flags = chunk.value
-        self.global_map = ((flags &amp; 0x80) == 0x80) # ok
-        self.color_res = 1 + ((flags &gt;&gt; 4) &amp; 0x7) # ??
-        self.bits_per_pixel = 1 + (flags &amp; 0x7) # ok
-        if self.global_map:
-            text = &quot;global map, &quot;
-        else:
-            text = &quot;&quot;
-        return text + &quot;color res=%u, bits/pixel=%u&quot; % (self.color_res, self.bits_per_pixel)
-        
-class GifFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;gif_file&quot;, &quot;GIF picture file&quot;, stream, parent)
-        # Header
-        self.read(&quot;header&quot;, &quot;6s&quot;, &quot;File header&quot;)
-        assert (self[&quot;header&quot;] == &quot;GIF87a&quot;) or (self[&quot;header&quot;] == &quot;GIF89a&quot;)
-        
-        self.readChild(&quot;screen&quot;, GifScreenDescriptor)
-        if self[&quot;screen&quot;].global_map:
-            self.readChild(&quot;color_map&quot;, GifColorMap)
-            self.color_map = self[&quot;color_map&quot;]
-        else:
-            self.color_map = None
-            
-        self.images = []
-        while True:
-            code = self.read(&quot;separator[]&quot;, &quot;c&quot;, &quot;Separator code&quot;)
-            code = code.getValue()
-            if code == &quot;!&quot;:
-                self.readChild(&quot;extensions[]&quot;, GifExtension)
-            elif code == &quot;,&quot;:
-                self.readChild(&quot;images[]&quot;, GifImage)
-                # TODO: Write Huffman parser code :-)
-#                self.readImage(stream)
-                return
-            elif code == &quot;;&quot;:
-                # GIF Terminator
-                return
-            else:
-                raise Exception(&quot;Wrong GIF image separator: ASCII %02X.&quot; % ord(code))
-
-    def readImage(self, stream):              
-        size = stream.getSize() - stream.tell()
-        self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;Image data&quot;)
-
-registerPlugin(GifFile, &quot;image/gif&quot;)

Modified: haypo/hachoir/trunk/plugins/gzip.py
===================================================================
--- haypo/hachoir/trunk/plugins/gzip.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/gzip.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,95 +1,90 @@
 &quot;&quot;&quot;
-Exported filter.
+GZIP archive parser.
 
-Description:
-GZIP archive file
+Author: Victor Stinner
 &quot;&quot;&quot;
 
 import datetime
-from filter import Filter, DeflateFilter
+from filter import OnDemandFilter, DeflateFilter
+from chunk import FormatChunk, StringChunk, EnumChunk, BitsChunk, BitsStruct
 from plugin import registerPlugin
 from stream.gunzip import GunzipStream
 from plugin import getPluginByStream
 from error import error
 from default import DefaultFilter
-from tools import getBacktrace
+from text_handler import hexadecimal, humanFilesize, unixTimestamp
    
-class GzipFile(Filter):
+class GzipFile(OnDemandFilter):
+    os_name = {
+        0: &quot;FAT filesystem&quot;,
+        1: &quot;Amiga&quot;,
+        2: &quot;VMS (or OpenVMS)&quot;,
+        3: &quot;Unix&quot;,
+        4: &quot;VM/CMS&quot;,
+        5: &quot;Atari TOS&quot;,
+        6: &quot;HPFS filesystem (OS/2, NT)&quot;,
+        7: &quot;Macintosh&quot;,
+        8: &quot;Z-System&quot;,
+        9: &quot;CP/M&quot;,
+        10: &quot;TOPS-20&quot;,
+        11: &quot;NTFS filesystem (NT)&quot;,
+        12: &quot;QDOS&quot;,
+        13: &quot;Acorn RISCOS&quot;} 
+
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;gzip_file&quot;, &quot;GZIP archive file&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;!2B&quot;, &quot;Identifier (31,139)&quot;)
+        OnDemandFilter.__init__(self, &quot;gzip_file&quot;, &quot;GZIP archive file&quot;, stream, parent, &quot;&lt;&quot;)
+
+        # Gzip header
+        self.read(&quot;id&quot;, &quot;Identifier (31,139)&quot;, (FormatChunk, &quot;uint8[2]&quot;))
         assert self[&quot;id&quot;] == (31, 139)
-        self.read(&quot;comp_method&quot;, &quot;!B&quot;, &quot;Compression method&quot;, post=self.getCompressionMethod)
-        self.read(&quot;flags&quot;, &quot;!B&quot;, &quot;Flags&quot;, post=self.getFlags)
-        self.read(&quot;mtime&quot;, &quot;&lt;1L&quot;, &quot;Modification time&quot;, post=self.getMTime)
-        self.read(&quot;extra&quot;, &quot;!B&quot;, &quot;Extra flags&quot;)
-        self.read(&quot;os&quot;, &quot;!B&quot;, &quot;OS&quot;, post=self.getOS)
+        self.read(&quot;compression&quot;, &quot;Compression method&quot;, (FormatChunk, &quot;uint8&quot;), {&quot;post&quot;: self.getCompressionMethod})
+        bits = (
+            (1, &quot;text&quot;, &quot;Text (?)&quot;),
+            (1, &quot;crc16&quot;, &quot;CRC16&quot;),
+            (1, &quot;extra&quot;, &quot;Extra informations (variable size)&quot;),
+            (1, &quot;filename&quot;, &quot;Contains filename?&quot;),
+            (1, &quot;comment&quot;, &quot;Contains comment?&quot;),
+            (3, &quot;unused&quot;, &quot;Unused bits&quot;))
+        flags = self.doRead(&quot;flags&quot;, &quot;Flags&quot;, (BitsChunk, BitsStruct(bits)))
+        self.read(&quot;mtime&quot;, &quot;Modification time&quot;, (FormatChunk, &quot;uint32&quot;), {&quot;post&quot;: unixTimestamp})
+        self.read(&quot;extra&quot;, &quot;Extra flags&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;os&quot;, &quot;Operating system&quot;, (EnumChunk, &quot;uint8&quot;, GzipFile.os_name))
 
+        # Optionnal fields
         if self[&quot;extra&quot;] &amp; 4 == 4:
-            self.read(&quot;extra_length&quot;, &quot;&lt;2H&quot;, &quot;Extra length&quot;)
-            self.read(&quot;extra&quot;, &quot;%us&quot; % self[&quot;extra_length&quot;], &quot;Extra&quot;)
-        if self[&quot;flags&quot;] &amp; 8 == 8:
-            self.readString(&quot;filename&quot;, &quot;C&quot;, &quot;Filename&quot;)
-        if self[&quot;flags&quot;] &amp; 16 == 16:
-            self.readString(&quot;comment&quot;, &quot;C&quot;, &quot;Comment&quot;)
-        if self[&quot;flags&quot;] &amp; 2 == 2:
-            self.read(&quot;crc16&quot;, &quot;!H&quot;, &quot;CRC16&quot;)
+            self.read(&quot;extra_length&quot;, &quot;Extra length&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;extra&quot;, &quot;Extra&quot;, (FormatChunk, &quot;string[%u]&quot;  % self[&quot;extra_length&quot;]))
+        if flags[&quot;filename&quot;]:
+            self.read(&quot;filename&quot;, &quot;Filename&quot;, (StringChunk, &quot;C&quot;))
+        if flags[&quot;comment&quot;]:
+            self.read(&quot;comment&quot;, &quot;Comment&quot;, (StringChunk, &quot;C&quot;))
+        if flags[&quot;crc16&quot;]:
+            self.read(&quot;crc16&quot;, &quot;CRC16&quot;, (FormatChunk, &quot;uint16&quot;), post=hexadecimal)
 
+        # Read content           
         oldpos = stream.tell()
         size = stream.getSize() - oldpos - 8
         try:
             gz_stream = GunzipStream(stream)
-            if hasattr(self, &quot;filename&quot;):
+            if self.hasChunk(&quot;filename&quot;):
                 plugin = getPluginByStream(gz_stream, self[&quot;filename&quot;])
             else:
                 plugin = getPluginByStream(gz_stream, None)
 
-            self.readChild(&quot;data&quot;, DeflateFilter, gz_stream, size, plugin) 
+            self.read(&quot;data&quot;, &quot;Data&quot;, (DeflateFilter, gz_stream, size, plugin)) 
         except Exception, msg:
-            error(&quot;Error while processing file in gzip: %s\ns%s&quot; % (msg, getBacktrace()))
+            error(&quot;Error while processing file in gzip: %s&quot; % msg)
             stream.seek(oldpos)
-            self.read(&quot;data&quot;, &quot;!%us&quot; % size, &quot;Compressed data&quot;)
-        
-        self.read(&quot;crc32&quot;, &quot;&lt;L&quot;, &quot;CRC32&quot;)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size&quot;)
+            self.read(&quot;data&quot;, &quot;Compressed data&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
 
-    def getFlags(self, chunk):
-        val = chunk.value
-        flags = []
-        if val &amp; 1 == 1: flags.append(&quot;text&quot;)
-        if val &amp; 2 == 2: flags.append(&quot;crc16&quot;)
-        if val &amp; 4 == 4: flags.append(&quot;extra&quot;)
-        if val &amp; 8 == 8: flags.append(&quot;filename&quot;)
-        if val &amp; 16 == 16: flags.append(&quot;comment&quot;)
-        return &quot;|&quot;.join(flags)
-        
+        # Footer
+        self.read(&quot;crc32&quot;, &quot;CRC32&quot;, (FormatChunk, &quot;uint32&quot;), {&quot;post&quot;: hexadecimal})
+        self.read(&quot;size&quot;, &quot;Uncompressed size&quot;, (FormatChunk, &quot;uint32&quot;), {&quot;post&quot;: humanFilesize})
+
     def getCompressionMethod(self, chunk):
         val = chunk.value
         if val &lt; 8: return &quot;reserved&quot;
         if val == 8: return &quot;deflate&quot;
         return &quot;Unknow (%s)&quot; % val
 
-    def getMTime(self, chunk):
-        dt = datetime.datetime.fromtimestamp(chunk.value)
-        return str(dt)
-
-    def getOS(self, chunk):
-        os = { \
-            0: &quot;FAT filesystem&quot;,
-            1: &quot;Amiga&quot;,
-            2: &quot;VMS (or OpenVMS)&quot;,
-            3: &quot;Unix&quot;,
-            4: &quot;VM/CMS&quot;,
-            5: &quot;Atari TOS&quot;,
-            6: &quot;HPFS filesystem (OS/2, NT)&quot;,
-            7: &quot;Macintosh&quot;,
-            8: &quot;Z-System&quot;,
-            9: &quot;CP/M&quot;,
-            10: &quot;TOPS-20&quot;,
-            11: &quot;NTFS filesystem (NT)&quot;,
-            12: &quot;QDOS&quot;,
-            13: &quot;Acorn RISCOS&quot;}            
-        val = chunk.value
-        return os.get(val, &quot;Unknow (%s)&quot; % val)
-        
 registerPlugin(GzipFile, &quot;application/x-gzip&quot;)

Deleted: haypo/hachoir/trunk/plugins/id3.py
===================================================================
--- haypo/hachoir/trunk/plugins/id3.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/id3.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,120 +0,0 @@
-&quot;&quot;&quot;
-AVI splitter.
-
-Creation: 12 decembre 2005
-Status: alpha
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-from tools import humanDuration
-
-class ID3_String(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;id3_string&quot;, &quot;ID3 string&quot;, stream, parent)
-        self.read(&quot;zero&quot;, &quot;B&quot;, &quot;Zero&quot;)
-        assert self[&quot;zero&quot;] == 0
-        size = stream.getSize()-1
-        self.read(&quot;content&quot;, &quot;%us&quot; % size, &quot;Content&quot;)
-
-class ID3_Private(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;id3_priv&quot;, &quot;ID3 private&quot;, stream, parent)
-        size = stream.getSize()
-        if stream.read(9, False) == &quot;PeakValue&quot;:
-            self.read(&quot;text&quot;, &quot;%us&quot; % 9, &quot;Text&quot;)
-            size = size - 9
-            self.read(&quot;content&quot;, &quot;%us&quot; % size, &quot;Content&quot;)
-        else:
-            self.read(&quot;content&quot;, &quot;%us&quot; % size, &quot;Content&quot;)
-
-class ID3_TrackLength(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;id3_tlen&quot;, &quot;ID3 track length&quot;, stream, parent)
-        self.read(&quot;zero&quot;, &quot;B&quot;, &quot;Zero&quot;)
-        assert self[&quot;zero&quot;] == 0
-        size = stream.getSize()-1
-        self.read(&quot;length&quot;, &quot;%us&quot; % size, &quot;Length in ms&quot;, post=self.computeLength)
-
-    def computeLength(self, chunk):
-        try:
-            ms = int(chunk.value)
-            return humanDuration(ms)
-        except:
-            return chunk.value
-        
-
-class ID3_Chunk(Filter):
-    name = {
-        &quot;COMM&quot;: &quot;Comment&quot;,
-        &quot;PRIV&quot;: &quot;Private&quot;,
-        &quot;TPE1&quot;: &quot;Artist&quot;,
-        &quot;TCOP&quot;: &quot;Copyright&quot;,
-        &quot;TALB&quot;: &quot;Album&quot;,
-        &quot;TENC&quot;: &quot;Encoder&quot;,
-        &quot;TYER&quot;: &quot;Year&quot;,
-        &quot;TSSE&quot;: &quot;Encoder settings&quot;,
-        &quot;TCOM&quot;: &quot;Composer&quot;,
-        &quot;TRCK&quot;: &quot;Track number&quot;,
-        &quot;PCNT&quot;: &quot;Play counter&quot;,
-        &quot;TCON&quot;: &quot;Content type&quot;,
-        &quot;TLEN&quot;: &quot;Track length&quot;,
-        &quot;TIT2&quot;: &quot;Track title&quot;
-    }
-    handler = {
-        &quot;TYER&quot;: ID3_String,
-        &quot;TALB&quot;: ID3_String,
-        &quot;TCON&quot;: ID3_String,
-        &quot;TPE1&quot;: ID3_String,
-        &quot;TCOP&quot;: ID3_String,
-        &quot;TRCK&quot;: ID3_String,
-        &quot;TIT2&quot;: ID3_String,
-        &quot;TSSE&quot;: ID3_String,
-        &quot;PRIV&quot;: ID3_Private,
-        &quot;TLEN&quot;: ID3_TrackLength
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;id3_chunk&quot;, &quot;ID3 Chunk&quot;, stream, parent)
-        tag = self.read(&quot;tag&quot;, &quot;!4s&quot;, &quot;Tag&quot;).value
-        self.read(&quot;size&quot;, &quot;&gt;L&quot;, &quot;Size&quot;)
-        self.read(&quot;flags&quot;, &quot;&gt;H&quot;, &quot;Flags&quot;)
-        size = self[&quot;size&quot;]
-        if tag in ID3_Chunk.handler:
-            end = stream.tell() + size
-            if size != 0:
-                substream = stream.createLimited(size=size)
-                self.readStreamChild(&quot;content&quot;, substream, ID3_Chunk.handler[tag])
-            assert stream.tell() == end
-        else:
-            self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;Raw data&quot;)
-
-    def updateParent(self, chunk):
-        type = self[&quot;tag&quot;].strip(&quot;\0&quot;)
-        if type != &quot;&quot;:
-            type = ID3_Chunk.name.get(type, &quot;Unknow (\&quot;%s\&quot;)&quot; % type)
-            desc = &quot;ID3 Chunk: %s&quot; % type
-        else:
-            desc = &quot;(empty ID3 chunk)&quot;
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ID3_Parser(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;id3&quot;, &quot;ID3&quot;, stream, parent)
-        header = self.read(&quot;header&quot;, &quot;!3s&quot;, &quot;Header (ID3)&quot;).value
-        assert header == &quot;ID3&quot;
-        ver_major = self.read(&quot;ver_major&quot;, &quot;!1B&quot;, &quot;Version (major)&quot;).value
-        assert ver_major in (3,4)
-        ver_minor = self.read(&quot;ver_minor&quot;, &quot;!B&quot;, &quot;Version (minor)&quot;).value
-#        assert ver_minor == 0
-        self.read(&quot;flags&quot;, &quot;!B&quot;, &quot;Flags&quot;)
-        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Size&quot;)
-        end = stream.tell() + self[&quot;size&quot;]
-        while stream.tell() &lt; end:
-            chunk = self.readChild(&quot;chunk[]&quot;, ID3_Chunk)
-            if chunk.getFilter()[&quot;size&quot;] == 0:
-                break
-        padding = end - stream.tell()
-        if 0 &lt; padding:
-            self.read(&quot;padding&quot;, &quot;%us&quot; % padding, &quot;Padding&quot;)
-#        assert stream.tell() == end

Modified: haypo/hachoir/trunk/plugins/jpeg.py
===================================================================
--- haypo/hachoir/trunk/plugins/jpeg.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/jpeg.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,32 +1,32 @@
 &quot;&quot;&quot;
-Exported filter.
+JPEG picture parser.
 
-Description:
-Default filter
+Author: Victor Stinner
 &quot;&quot;&quot;
 
-from filter import Filter, OnDemandFilter
+from filter import OnDemandFilter
 from plugin import registerPlugin
-from exif import ExifFilter
+from chunk import FormatChunk
+#from exif import ExifFilter
 
 class JpegChunkApp0(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;jpeg_chunk&quot;, &quot;JPEG chunk App0&quot;, stream, parent)
-        self.read(&quot;jfif&quot;, &quot;5s&quot;, &quot;JFIF string&quot;)
-        self.read(&quot;ver_maj&quot;, &quot;B&quot;, &quot;Major version&quot;)
-        self.read(&quot;ver_min&quot;, &quot;B&quot;, &quot;Minor version&quot;)
-        self.read(&quot;units&quot;, &quot;B&quot;, &quot;Units (=0)&quot;)
+        OnDemandFilter.__init__(self, &quot;app0&quot;, &quot;JPEG APP0&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;jfif&quot;, &quot;JFIF string&quot;, (FormatChunk, &quot;string[5]&quot;))
+        self.read(&quot;ver_maj&quot;, &quot;Major version&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;ver_min&quot;, &quot;Minor version&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;units&quot;, &quot;Units (=0)&quot;, (FormatChunk, &quot;uint8&quot;))
         if self[&quot;units&quot;] == 0:
-            self.read(&quot;aspect_x&quot;, &quot;!H&quot;, &quot;Aspect ratio (X)&quot;)
-            self.read(&quot;aspect_y&quot;, &quot;!H&quot;, &quot;Aspect ratio (Y)&quot;)
+            self.read(&quot;aspect_x&quot;, &quot;Aspect ratio (X)&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;aspect_y&quot;, &quot;Aspect ratio (Y)&quot;, (FormatChunk, &quot;uint16&quot;))
         else:
-            self.read(&quot;x_density&quot;, &quot;!H&quot;, &quot;X density&quot;)
-            self.read(&quot;y_density&quot;, &quot;!H&quot;, &quot;Y density&quot;)
-        self.read(&quot;thumb_w&quot;, &quot;B&quot;, &quot;Thumbnail width&quot;)
-        self.read(&quot;thumb_h&quot;, &quot;B&quot;, &quot;Thumbnail height&quot;)
+            self.read(&quot;x_density&quot;, &quot;X density&quot;, (FormatChunk, &quot;uint16&quot;))
+            self.read(&quot;y_density&quot;, &quot;Y density&quot;, (FormatChunk, &quot;uint16&quot;))
+        self.read(&quot;thumb_w&quot;, &quot;Thumbnail width&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;thumb_h&quot;, &quot;Thumbnail height&quot;, (FormatChunk, &quot;uint8&quot;))
         thumb = self[&quot;thumb_w&quot;] * self[&quot;thumb_h&quot;]
         if thumb != 0:
-            self.read(&quot;thumb_data&quot;, &quot;%us&quot; % size, &quot;Thumbnail data&quot;)
+            self.read(&quot;thumb_data&quot;, &quot;Thumbnail data&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
 
 class JpegChunk(OnDemandFilter):
     type_name = {
@@ -44,28 +44,28 @@
     }
     handler = {
         0xE0: JpegChunkApp0,
-        0xE1: ExifFilter
+#        0xE1: ExifFilter
     }
 
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, &quot;jpeg_chunk&quot;, &quot;JPEG chunk&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;B&quot;, &quot;Header&quot;)
+        OnDemandFilter.__init__(self, &quot;chunk&quot;, &quot;Chunk&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;header&quot;, &quot;Header&quot;, (FormatChunk, &quot;uint8&quot;))
         assert self[&quot;header&quot;] == 0xFF
-        self.read(&quot;type&quot;, &quot;B&quot;, &quot;Type&quot;, post=self.postType)
-        self.read(&quot;size&quot;, &quot;!H&quot;, &quot;Size&quot;)
+        self.read(&quot;type&quot;, &quot;Type&quot;, (FormatChunk, &quot;uint8&quot;), {&quot;post&quot;: self.postType})
+        self.read(&quot;size&quot;, &quot;Size&quot;, (FormatChunk, &quot;uint16&quot;))
         type = self[&quot;type&quot;]
         size = self[&quot;size&quot;] - 2
         if type in JpegChunk.handler:
             end = stream.tell() + size
             sub = stream.createSub(size=size)
-            self.readStreamChild(&quot;content&quot;, &quot;Chunk content&quot;, sub, JpegChunk.handler[type])
+            self.read(&quot;content&quot;, &quot;Chunk content&quot;, (JpegChunk.handler[type],), {&quot;stream&quot;: sub, &quot;size&quot;: size})
             assert stream.tell() == end
         else:
-            self.read(&quot;data&quot;, &quot;!%us&quot; % size, &quot;Data&quot;)
+            self.read(&quot;data&quot;, &quot;Data&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
             
     def updateParent(self, chunk):
         type = self.getChunk(&quot;type&quot;).display
-        desc = &quot;JPEG chunk \&quot;%s\&quot;&quot; % type
+        desc = &quot;Chunk: %s&quot; % type
         chunk.description = desc
 
     def postType(self, chunk):
@@ -75,13 +75,13 @@
 class JpegFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
         OnDemandFilter.__init__(self, &quot;jpeg_file&quot;, &quot;JPEG file&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;2s&quot;, &quot;Header \&quot;start of image\&quot; (0xFF xD8)&quot;)
+        self.read(&quot;header&quot;, &quot;Header \&quot;start of image\&quot; (0xFF xD8)&quot;, (FormatChunk, &quot;string[2]&quot;))
         assert self[&quot;header&quot;] == &quot;\xFF\xD8&quot;
         while not stream.eof():
-            id = self.readChild(&quot;chunk[]&quot;, &quot;Jpeg Chunk&quot;, JpegChunk)
-            if self[id][&quot;type&quot;] == 0xDA:
+            chunk = self.doRead(&quot;chunk[]&quot;, &quot;Chunk&quot;, (JpegChunk,))
+            if chunk[&quot;type&quot;] == 0xDA:
                 break
         size = stream.getSize() - self.getSize()
-        self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;JPEG data&quot;)
+        self.read(&quot;data&quot;, &quot;JPEG data&quot;, (FormatChunk, &quot;string[%u]&quot; % size))
         
 registerPlugin(JpegFile, &quot;image/jpeg&quot;)

Deleted: haypo/hachoir/trunk/plugins/mbr.py
===================================================================
--- haypo/hachoir/trunk/plugins/mbr.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/mbr.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,66 +0,0 @@
-&quot;&quot;&quot;
-Master Boot Record.
-
-
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-
-class PartitionEntry(Filter):
-    system_name = {
-        0x00: &quot;Unused&quot;,
-        0x05: &quot;Extended&quot;,
-        0x06: &quot;FAT16&quot;,
-        0x0E: &quot;FAT16&quot;,
-        0x0B: &quot;FAT32&quot;,
-        0x0C: &quot;FAT32&quot;,
-        0x82: &quot;Linux swap&quot;,
-        0x83: &quot;Linux&quot;
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;default&quot;, &quot;Default filter&quot;, stream, parent)
-        bootable = self.read(&quot;bootable&quot;, &quot;B&quot;, &quot;Bootable flag (true if equals to 0x80)&quot;).value
-        assert bootable in (0x00, 0x80)
-        self.read(&quot;start_head&quot;, &quot;B&quot;, &quot;Starting head number of the partition&quot;)
-        self.read(&quot;start_sector&quot;, &quot;B&quot;, &quot;Starting sector number of the partition&quot;)
-        self.read(&quot;start_low_cylinder&quot;, &quot;B&quot;, &quot;Lower 8 bits of starting cylinder number of the partition&quot;)
-        self.read(&quot;system&quot;, &quot;B&quot;, &quot;System indicator&quot;, post=self.postSystem)
-        self.read(&quot;end_head&quot;, &quot;B&quot;, &quot;Ending head number of the partition&quot;)
-        self.read(&quot;end_sector&quot;, &quot;B&quot;, &quot;Ending sector number of the partition&quot;)
-        self.read(&quot;end_low_cylinder&quot;, &quot;B&quot;, &quot;Lower 8 bits of ending cylinder number of the partition&quot;)
-        self.read(&quot;LBA&quot;, &quot;&lt;L&quot;, &quot;LBA (number of sectors before this partition)&quot;)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
-
-    def updateParent(self, parent):
-        block_size = self.getParent().block_size
-        size_mb = self[&quot;size&quot;] / ((1 &lt;&lt; 20) / block_size)
-
-        desc = &quot;Partition entry (type %s, %u MB)&quot; % (self.type, size_mb)
-        parent.description = desc
-        self.setDescription(desc)        
-
-    def postSystem(self, chunk):
-        type = chunk.value
-        self.type = PartitionEntry.system_name.get(type, &quot;Unknow (%02X)&quot; % type)
-        return self.type      
-
-class MasterBootRecordFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;default&quot;, &quot;Default filter&quot;, stream, parent)
-        # TODO: Get right block size!
-        self.block_size = 512
-        assert 512&lt;=stream.getSize()
-        jmp = self.read(&quot;jmp&quot;, &quot;B&quot;, &quot;Jump instruction&quot;).value
-        assert jmp in (0xEB, 0xFA)
-        size = 446 - stream.tell()
-        self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;Raw data&quot;)
-        self.readChild(&quot;partition[]&quot;, PartitionEntry)
-        self.readChild(&quot;partition[]&quot;, PartitionEntry)
-        self.readChild(&quot;partition[]&quot;, PartitionEntry)
-        self.readChild(&quot;partition[]&quot;, PartitionEntry)
-        id = self.read(&quot;id&quot;, &quot;&lt;H&quot;, &quot;Identifier (0xAA55)&quot;).value
-        assert id == 0xAA55
-
-registerPlugin(MasterBootRecordFilter, &quot;hachoir/master-boot-record&quot;)

Deleted: haypo/hachoir/trunk/plugins/mp3.py
===================================================================
--- haypo/hachoir/trunk/plugins/mp3.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/mp3.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,244 +0,0 @@
-&quot;&quot;&quot;
-AVI splitter.
-
-Creation: 12 decembre 2005
-Status: alpha
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-from id3 import ID3_Parser
-
-class MP3_File(Filter):
-    version = {
-        0: &quot;2.5&quot;,
-        2: &quot;2&quot;,
-        3: &quot;1&quot;
-    }
-    layer = {
-        0: &quot;(reserved)&quot;,
-        1: &quot;III&quot;,
-        2: &quot;II&quot;,
-        3: &quot;I&quot;
-    }
-    bit_rate = {
-        # MPEG1
-        1: {
-            # MPEG1, layer I
-            3: {
-                1: 32,
-                2: 64,
-                3: 96,
-                4: 128,
-                5: 160,
-                6: 192,
-                7: 224,
-                8: 256,
-                9: 288,
-                10: 320,
-                11: 352,
-                12: 384,
-                13: 416,
-                14: 448
-            },
-
-            # MPEG1, layer II
-            2: {
-                1: 32,
-                2: 48,
-                3: 56,
-                4: 64,
-                5: 80,
-                6: 96,
-                7: 112,
-                8: 128,
-                9: 160,
-                10: 192,
-                11: 224,
-                12: 256,
-                13: 320,
-                14: 384
-            },
-
-            # MPEG1, layer III
-            1: {
-                1: 32,
-                2: 40,
-                3: 48,
-                4: 56,
-                5: 64,
-                6: 80,
-                7: 96,
-                8: 112,
-                9: 128,
-                10: 160,
-                11: 192,
-                12: 224,
-                13: 256,
-                14: 320
-            }
-        },
-        
-        # MPEG2 / MPEG2.5
-        2: {
-            # MPEG2 / MPEG2.5, layer I
-            3: {
-                1: 32,
-                2: 64,
-                3: 96,
-                4: 128,
-                5: 160,
-                6: 192,
-                7: 224,
-                8: 256,
-                9: 288,
-                10: 320,
-                11: 352,
-                12: 384,
-                13: 416,
-                14: 448},
-
-            # MPEG2 / MPEG2.5, layer II
-            2: {
-                1: 32,
-                2: 48,
-                3: 56,
-                4: 64,
-                5: 80,
-                6: 96,
-                7: 112,
-                8: 128,
-                9: 160,
-                10: 192,
-                11: 224,
-                12: 256,
-                13: 320,
-                14: 384},
-
-            # MPEG2 / MPEG2.5, layer III
-            1: {
-                1: 8, # 8
-                2: 16, # 16
-                3: 24, # 24
-                4: 32, # 32
-                5: 64, # 40
-                6: 80, # 48
-                7: 56, # 56
-                8: 64, # 64
-                9: 128, # 80
-                10: 160, # 96
-                11: 112, # 112
-                12: 128, # 128
-                13: 256, # 144 
-                14: 320} # 160
-        }
-    }
-    sampling_rate = {
-        # MPEG1
-        3: {
-            0: 44100,
-            1: 48000,
-            2: 32000},
-        # MPEG2
-        2: {
-            0: 22050,
-            1: 24000,
-            2: 16000},
-        # MPEG2.5
-        1: {
-            0: 11025,
-            1: 12000,
-            2: 8000}
-    }
-    emphasis = {
-        0: &quot;none&quot;,
-        1: &quot;50/15 ms&quot;,
-        3: &quot;CCIT J.17&quot;
-    }
-    channel_mode = {
-        0: &quot;Stereo&quot;,
-        1: &quot;Joint stereo&quot;,
-        2: &quot;Dual channel&quot;,
-        3: &quot;Single channel&quot;
-    }
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;mp3&quot;, &quot;MP3 file&quot;, stream, parent)
-        if stream.getN(3, False)==&quot;ID3&quot;:
-            self.readChild(&quot;id3&quot;, ID3_Parser)
-        self.read(&quot;header&quot;, &quot;!H&quot;, &quot;Header&quot;, post=self.postHeader)
-        self.read(&quot;rate&quot;, &quot;B&quot;, &quot;Rates and padding&quot;, post=self.postRate)
-        self.read(&quot;various&quot;, &quot;B&quot;, &quot;Channel mode, mode extension, copyright, original&quot;, post=self.postVarious)
-
-        print (self.sampling_rate, self.bit_rate, self.padding)
-        frame_size = (144 * self.sampling_rate) / self.bit_rate + self.padding
-        print &quot;Frame size=%s&quot; % frame_size
-        
-    def postVarious(self, chunk):
-        # Get channel mode
-        channel_mode = chunk.value &gt;&gt; 6 &amp; 3
-        text = MP3_File.channel_mode[channel_mode]
-
-#        mode_extension = chunk.value &gt;&gt; 4 &amp; 3
-
-        # Get copyright bit
-        copyright = chunk.value &gt;&gt; 3 &amp; 1
-        if copyright == 1:
-            text = text + &quot;, copyrighted&quot;
-
-        # Get original bit
-        original = chunk.value &gt;&gt; 2 &amp; 1
-        if original == 1:
-            text = text + &quot;, is original&quot;
-        else:
-            text = text + &quot;, copied&quot;
-
-        # Get emphasis
-        emphasis = chunk.value &amp; 3
-        assert emphasis in MP3_File.emphasis
-        emphasis = MP3_File.emphasis[emphasis]
-        if emphasis != &quot;none&quot;:
-            text = text + &quot;, emphasis=%s&quot; % emphasis
-        return text 
-
-    def postHeader(self, chunk):
-        header = chunk.value
-        sync = header &gt;&gt; 5
-        assert sync == 2047
-        self.version = header &gt;&gt; 3 &amp; 3
-        assert self.version in MP3_File.version
-        self.layer = header &gt;&gt; 1 &amp; 3
-        protection = header &amp; 1
-        text = &quot;MPEG%s, layer %s&quot; % (\
-            MP3_File.version[self.version],
-            MP3_File.layer[self.layer])
-        if protection==1:
-            text = &quot;%s, protected&quot; % text
-        return text
-
-    def postRate(self, chunk):
-        # Get bit rates
-        bit_rate = chunk.value &gt;&gt; 4
-        if self.version == 3: # MPEG1
-            rates = MP3_File.bit_rate[1] # MPEG1
-        else:
-            rates = MP3_File.bit_rate[2] # MPEG2 / MPEG2.5
-        assert self.layer in rates
-        rates = rates[self.layer]
-        assert bit_rate in rates
-        self.bit_rate = rates[bit_rate]
-        
-        # Get sampling rate
-        sampling_rate = chunk.value &gt;&gt; 2 &amp; 3
-        rates = MP3_File.sampling_rate[self.version]
-        assert sampling_rate in rates
-        self.sampling_rate = rates[sampling_rate]
-        text = &quot;%u bps, %s Hz&quot; % (self.bit_rate, self.sampling_rate)
-        
-        # Get Padding
-        self.padding = chunk.value &gt;&gt; 1 &amp; 1
-        if self.padding==1:
-            text = text + &quot;, padded&quot;
-        return text
-
-registerPlugin(MP3_File, &quot;audio/mpeg&quot;)

Deleted: haypo/hachoir/trunk/plugins/pcx.py
===================================================================
--- haypo/hachoir/trunk/plugins/pcx.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/pcx.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,94 +0,0 @@
-&quot;&quot;&quot;
-PCX picture filter.
-&quot;&quot;&quot;
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-from stream.file import FileStream
-from cStringIO import StringIO
-
-class RGB(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;rgb_color&quot;, &quot;RGB color&quot;, stream, parent)
-        self.read(&quot;red&quot;, &quot;B&quot;, &quot;Red&quot;)
-        self.read(&quot;green&quot;, &quot;B&quot;, &quot;Green&quot;)
-        self.read(&quot;blue&quot;, &quot;B&quot;, &quot;Blue&quot;)
-    def updateParent(self, chunk):
-        chunk.description = &quot;RGB color: #%02X%02X%02X&quot; % (self[&quot;red&quot;], self[&quot;green&quot;], self[&quot;blue&quot;])
-
-class Palette(Filter):
-    def __init__(self, stream, parent, count):
-        Filter.__init__(self, &quot;rgb_color&quot;, &quot;RGB color (8 bits/component)&quot;, stream, parent)
-        for i in range(0, count):
-            self.readChild(&quot;color[]&quot;, RGB)
-
-def StreamDeflateRLE(filter, stream, size):
-    start = stream.tell()
-    end = start + size - 1
-    data = &quot;&quot;
-    width = filter.width
-    for y in range(0, filter.height):
-        line = &quot;&quot;
-        while len(line) &lt; width:
-            character = stream.getN(1)
-            byte = ord(character)
-            if byte &amp; 192 == 192:
-                repeat = byte &amp; 63
-                character = stream.getN(1)
-                line = line + character * repeat                
-            else:
-                line = line + character
-        assert len(line) == width
-        data = data + line
-    assert stream.tell() == end
-    stream.seek(start)
-    return FileStream(StringIO(data),None)
-
-class PCX_Content(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pcx_content&quot;, &quot;PCX content&quot;, stream, parent)
-        pcx = parent.getParent()
-        bytes_per_line = pcx[&quot;bytes_per_line&quot;]
-        height = pcx[&quot;bytes_per_line&quot;]
-        for y in range(0, height):
-            self.read(&quot;line[]&quot;, &quot;%us&quot; % bytes_per_line, &quot;Line&quot;)
-
-class PCX_File(Filter):
-    compression_name = {
-        1: &quot;RLE&quot;
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pcx_file&quot;, &quot;PCX picture&quot;, stream, parent)
-        id = self.read(&quot;id&quot;, &quot;B&quot;, &quot;PCX identifier (10)&quot;).value
-        assert id == 10
-        self.read(&quot;version&quot;, &quot;B&quot;, &quot;PCX version&quot;)
-        self.read(&quot;compression&quot;, &quot;B&quot;, &quot;Compression&quot;, post=self.postCompression)
-        self.bpp = self.read(&quot;bpp&quot;, &quot;B&quot;, &quot;Bits / pixel&quot;).value
-        # TODO: Support 4 and 24 bits/pxiel
-        assert self.bpp == 8
-        self.read(&quot;xmin&quot;, &quot;&lt;H&quot;, &quot;Minimum X&quot;)
-        self.read(&quot;ymin&quot;, &quot;&lt;H&quot;, &quot;Minimum Y&quot;)
-        self.width = self.read(&quot;width&quot;, &quot;&lt;H&quot;, &quot;Width minus one&quot;).value+1
-        self.height = self.read(&quot;height&quot;, &quot;&lt;H&quot;, &quot;Height minus one&quot;).value+1
-        self.read(&quot;horiz_dpi&quot;, &quot;&lt;H&quot;, &quot;Horizontal DPI&quot;)
-        self.read(&quot;vert_dpi&quot;, &quot;&lt;H&quot;, &quot;Vertical DPI&quot;)
-        self.readChild(&quot;palette_4bits&quot;, Palette, 16)
-        self.read(&quot;reserved&quot;, &quot;B&quot;, &quot;Reserved&quot;)
-        self.read(&quot;nb_color_plan&quot;, &quot;B&quot;, &quot;Number of color plans&quot;)
-        self.read(&quot;bytes_per_line&quot;, &quot;&lt;H&quot;, &quot;Bytes per line&quot;)
-        self.read(&quot;color_mode&quot;, &quot;&lt;H&quot;, &quot;Color mode&quot;)
-        self.read(&quot;reserved2&quot;, &quot;58s&quot;, &quot;Reserved&quot;)
-
-        size = stream.getSize() - stream.tell()
-        if self.bpp == 8:
-            size = size - 256*3
-        deflate = StreamDeflateRLE(self, stream, size)
-        self.readChild(&quot;data&quot;, DeflateFilter, deflate, size, PCX_Content)
-        if self.bpp == 8:
-            self.readChild(&quot;palette_8bits&quot;, Palette, 256)
-
-    def postCompression(self, chunk):
-        mode = chunk.value
-        return PCX_File.compression_name.get(mode, &quot;Unknow (%s)&quot; % mode)
-
-registerPlugin(PCX_File, &quot;image/x-pcx&quot;)

Deleted: haypo/hachoir/trunk/plugins/pdf.py
===================================================================
--- haypo/hachoir/trunk/plugins/pdf.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/pdf.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,140 +0,0 @@
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-import re
-from stream.error import StreamError
-from stream.deflate import DeflateStream
-from tools import convertDataToPrintableString, getBacktrace
-from error import warning
-from default import DefaultFilter
-
-def isEnd(stream, array, last):
-    return stream.eof()
-
-class PdfObject(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;pdf_obj&quot;, &quot;PDF object&quot;, stream, parent)
-        self.metadata = {}
-        chunk = self.readString(&quot;header&quot;, &quot;AutoLine&quot;, &quot;Object header&quot;, strip=True)
-        header = chunk.value 
-        assert header != &quot;&quot;
-        if header == &quot;xref&quot;:
-            self.type = &quot;xref&quot;
-            self.readXref()
-        else: 
-            self.type = &quot;obj&quot;
-            m = re.match(r&quot;([0-9]+) [0-9]+ obj&quot;, header)
-            if m != None:
-                id = int(m.group(1))
-                self.metadata[&quot;id&quot;] = id
-                self.setDescription(&quot;Object (id %s)&quot; % id)
-            else:
-                self.metadata[&quot;id&quot;] = header
-                self.setDescription(&quot;Object (%s)&quot; % header)
-            self.readObj()                
-        self.updateDescription()
-
-    def updateDescription(self):
-        if self.type == &quot;obj&quot;:
-            info = &quot;id %s&quot; % self.metadata[&quot;id&quot;]
-            if &quot;type&quot; in self.metadata:
-                info = info + &quot;, %s&quot; % self.metadata[&quot;type&quot;]
-                if &quot;fontname&quot; in self.metadata:
-                    info = info + &quot;, name: %s&quot; % self.metadata[&quot;fontname&quot;]
-        else:
-            info = &quot;XREF&quot;
-        self.setDescription(&quot;Object (%s)&quot; % info)
-
-    def readContent(self):
-        text = &quot;&quot; 
-        deflate = False
-        while text not in (&quot;endobj&quot;, &quot;stream&quot;):
-            self.processLine(text)
-            chunk = self.readString(&quot;line[]&quot;, &quot;AutoLine&quot;, &quot;&quot;, strip=True)
-            text = chunk.value
-            if re.match(r&quot;.*/Filter /FlateDecode.*&quot;, chunk.value) != None:
-                deflate = True
-            if self.getStream().eof():
-                return &quot;eof&quot;
-        if chunk.value == &quot;endobj&quot;:
-            chunk.id = &quot;endobj&quot;
-            chunk.description = &quot;Object end&quot;
-            return &quot;end&quot;
-        elif deflate:
-            return &quot;deflate&quot;
-        else:
-            return &quot;stream&quot;
-    
-    def readObj(self):
-        what = self.readContent()
-        if what == &quot;eof&quot;:
-            return
-        if what in (&quot;stream&quot;,&quot;deflate&quot;):
-            start = self.getStream().tell()
-            size = self._stream.searchLength(&quot;endstream&quot;, False)
-            if size == -1:
-                raise Exception(&quot;Delimiter \&quot;%s\&quot; not found for %s (%s)!&quot; % (delimiter, id, description))
-
-            if what==&quot;deflate&quot;:
-                try:
-                    old = self.getStream().tell()
-                    new_stream = DeflateStream( self.getStream().getN(size,False) )
-                    self.readChild(&quot;deflate&quot;, DeflateFilter, new_stream, size, DefaultFilter)
-                except:
-                    warning(&quot;Error while decompressing data of an objet.&quot;)
-                    self.getStream().seek(start)
-                    self.read(&quot;data&quot;, &quot;!%us&quot; % size, &quot;Data (compressed with deflate)&quot;)
-            else:
-                self.read(&quot;data&quot;, &quot;!%us&quot; % size, &quot;Data&quot;)
-            assert self.getStream().tell() == (start+size)
-            
-            self.readString(&quot;data_end[]&quot;, &quot;AutoLine&quot;, &quot;Data end&quot;)
-            self.readString(&quot;endobj&quot;, &quot;AutoLine&quot;, &quot;Object end&quot;, strip=True)
-        ver = self.getParent().version
-        eol = self.getStream().read(1, seek=False)
-        if eol in (&quot;\n&quot;, &quot;\r&quot;):
-            self.readString(&quot;emptyline&quot;, &quot;AutoLine&quot;, &quot;&quot;)
-
-    def readXref(self):
-        chunk = self.readString(&quot;xref_header&quot;, &quot;AutoLine&quot;, &quot;XRef header&quot;, strip=True)
-        m = re.match(r&quot;^[0-9]+ ([0-9]+)$&quot;, chunk.value)
-        assert m != None
-        nb_ref = int(m.group(1)) - 1
-        n = 0
-        while n&lt;nb_ref:
-            chunk = self.readString(&quot;ref[]&quot;, &quot;AutoLine&quot;, &quot;Reference&quot;, strip=True)
-            n = n + 1
-        self.readString(&quot;endobj&quot;, &quot;AutoLine&quot;, &quot;Object end&quot;, strip=True)
-
-    def processLine(self, line):
-        tests = {
-            &quot;type&quot;:  r&quot;^.*Type /([A-Za-z]+)$&quot;,
-            &quot;fontname&quot;:  r&quot;^.*(?:BaseFont|FontName) /(?:[A-Z]A+\+)?([A-Za-z-]+)$&quot;
-        }
-        for field in tests:
-            m = re.match(tests[field], line)
-            if m != None:
-                self.metadata[field] = m.group(1)
-                break 
-
-class PdfFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;id&quot;, &quot;&quot;, stream, parent)
-        self.readString(&quot;pdf_version&quot;, &quot;AutoLine&quot;, &quot;PDF version&quot;)
-        m = re.match(&quot;^%PDF-([0-9]+)\.([0-9]+)$&quot;, self[&quot;pdf_version&quot;])
-        assert m != None
-        self.version = ( int(m.group(1)), int(m.group(2)) )
-        if self.version[0] == 1 and self.version[1] &gt; 0:
-            # PDF &gt; 1.0
-            self.readString(&quot;header&quot;, &quot;AutoLine&quot;, &quot;PDF header&quot;)
-        self.nb_ref = None
-        while not stream.eof():
-            try:
-                self.readChild(&quot;obj[]&quot;, PdfObject)
-            except StreamError, err:
-                return
-            except Exception, err:
-                print &quot;Exception in PDF: %s&quot; % err
-                print getBacktrace()
-                return
-
-registerPlugin(PdfFile, &quot;application/pdf&quot;)

Modified: haypo/hachoir/trunk/plugins/png.py
===================================================================
--- haypo/hachoir/trunk/plugins/png.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/png.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,121 +1,126 @@
 &quot;&quot;&quot;
-PNG splitter.
+PNG picture parser.
 
-Status: split into chunks, can only resplit tIME chunk.
 Author: Victor Stinner
 &quot;&quot;&quot;
 
-from filter import Filter
+import datetime
+from filter import OnDemandFilter
+from chunk import FormatChunk, StringChunk
 from plugin import registerPlugin
+from text_handler import hexadecimal
+from generic.image import RGB
 
-class PngHeader(Filter):
+class Palette(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;png_header&quot;, &quot;PNG header&quot;, stream, parent)
-        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Width (pixels)&quot;)
-        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Height (pixels)&quot;)
-        self.read(&quot;bit_depth&quot;, &quot;!B&quot;, &quot;Bit depth&quot;)
-        self.read(&quot;color_type&quot;, &quot;!B&quot;, &quot;Color type&quot;)
-        self.read(&quot;compression_method&quot;, &quot;!B&quot;, &quot;Compression method&quot;)
-        self.read(&quot;filter_method&quot;, &quot;!B&quot;, &quot;Filter method&quot;)
-        self.read(&quot;interlace_method&quot;, &quot;!B&quot;, &quot;Interlace method&quot;)
+        size = stream.getSize()
+        assert (size % 3) == 0
+        count = size / 3
+        OnDemandFilter.__init__(self, &quot;palette&quot;, &quot;Palette: %u colors&quot; % count, stream, parent, &quot;!&quot;)
+        for i in range(0, count):
+            self.read(&quot;color[]&quot;, &quot;Color&quot;, (RGB,))
 
-    def __str__(self):
-        return &quot;PNG header &lt;size=%ux%u, depth=%u bits/pixel&gt;&quot; % \
-            (self[&quot;width&quot;], self[&quot;height&quot;],
-             self[&quot;bit_depth&quot;])
+class Header(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, &quot;header&quot;, &quot;Header&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;width&quot;, &quot;Width (pixels)&quot;, (FormatChunk, &quot;uint32&quot;))
+        self.read(&quot;height&quot;, &quot;Height (pixels)&quot;, (FormatChunk, &quot;uint32&quot;))
+        self.read(&quot;bit_depth&quot;, &quot;Bit depth&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;color_type&quot;, &quot;Color type&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;compression&quot;, &quot;Compression method&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;filter&quot;, &quot;Filter method&quot;, (FormatChunk, &quot;uint8&quot;))
+        self.read(&quot;interlace&quot;, &quot;Interlace method&quot;, (FormatChunk, &quot;uint8&quot;))
 
-class PngPhysical(Filter):
+class Physical(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;png_physical&quot;, &quot;PNG physical&quot;, stream, parent)
-        self.read(&quot;pixel_per_unit_x&quot;, &quot;!L&quot;, &quot;Pixel per unit, X axis&quot;)
-        self.read(&quot;pixel_per_unit_y&quot;, &quot;!L&quot;, &quot;Pixel per unit, Y axis&quot;)
-        self.read(&quot;unit_type&quot;, &quot;!B&quot;, &quot;Unit type&quot;)
+        OnDemandFilter.__init__(self, &quot;physical&quot;, &quot;Physical&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;pixel_per_unit_x&quot;, &quot;Pixel per unit, X axis&quot;, (FormatChunk, &quot;uint32&quot;))
+        self.read(&quot;pixel_per_unit_y&quot;, &quot;Pixel per unit, Y axis&quot;, (FormatChunk, &quot;uint32&quot;))
+        self.read(&quot;unit_type&quot;, &quot;Unit type&quot;, (FormatChunk, &quot;uint8&quot;))
 
-    def __str__(self):
-        if self[&quot;unit_type&quot;] == 0:
-            unit = &quot;unknow&quot;
-        else:
-            unit = &quot;meter&quot;
-        return &quot;PNG physical chunk &lt;pixel per unit=(%u,%u), unit=%s&gt;&quot; % \
-            (self[&quot;pixel_per_unit_x&quot;], self[&quot;pixel_per_unit_y&quot;], unit)
-
-class PngGamma(Filter):
+class Gamma(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;png_gamma&quot;, &quot;PNG gamma&quot;, stream, parent)
-        self.read(&quot;gamma&quot;, &quot;!L&quot;, &quot;Gamma (x10,000)&quot;, post=self.getGamma)
+        OnDemandFilter.__init__(self, &quot;gamma&quot;, &quot;Gamma&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;gamma&quot;, &quot;Gamma (x10,000)&quot;, (FormatChunk, &quot;uint32&quot;), {&quot;post&quot;: self.getGamma})
 
     def getGamma(self, chunk):
         return float(chunk.value) / 10000
 
-    def __str__(self):
-        return &quot;PNG gamma &lt;gamma=%0.2f&gt;&quot; % (self[&quot;gamma&quot;])
-
-class PngText(Filter):
+class Text(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;png_text&quot;, &quot;PNG text&quot;, stream, parent)
-        chunk = self.readString(&quot;keyword&quot;, &quot;C&quot;, &quot;Keyword&quot;)
+        OnDemandFilter.__init__(self, &quot;text&quot;, &quot;Text&quot;, stream, parent)
+        chunk = self.read(&quot;keyword&quot;, &quot;Keyword&quot;, (StringChunk, &quot;C&quot;))
         lg = stream.getSize() - chunk.size
-        self.read(&quot;text&quot;, &quot;!%us&quot; % lg, &quot;Text&quot;)
+        self.read(&quot;text&quot;, &quot;Text&quot;, (FormatChunk, &quot;string[%u]&quot; % lg))
 
-    def __str__(self):
-        return &quot;PNG text &lt;keyword=\&quot;%s\&quot;, text=\&quot;%s\&quot;&gt;&quot; % \
-            (self[&quot;keyword&quot;], self[&quot;text&quot;])
-
-class PngTime(Filter):
+class Time(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;png_time&quot;, &quot;PNG time&quot;, stream, parent)
-        self.read(&quot;year&quot;, &quot;!H&quot;, &quot;Year&quot;)
-        self.read(&quot;month&quot;, &quot;!B&quot;, &quot;Month&quot;)
-        self.read(&quot;day&quot;, &quot;!B&quot;, &quot;Day&quot;)
-        self.read(&quot;hour&quot;, &quot;!B&quot;, &quot;Hour&quot;)
-        self.read(&quot;minute&quot;, &quot;!B&quot;, &quot;Minute&quot;)
-        self.read(&quot;second&quot;, &quot;!B&quot;, &quot;Second&quot;)
+        OnDemandFilter.__init__(self, &quot;time&quot;, &quot;Time&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;year&quot;, &quot;Year&quot;, [FormatChunk, &quot;H&quot;])
+        self.read(&quot;month&quot;, &quot;Month&quot;, [FormatChunk, &quot;uint8&quot;])
+        self.read(&quot;day&quot;, &quot;Day&quot;, [FormatChunk, &quot;uint8&quot;])
+        self.read(&quot;hour&quot;, &quot;Hour&quot;, [FormatChunk, &quot;uint8&quot;])
+        self.read(&quot;minute&quot;, &quot;Minute&quot;, [FormatChunk, &quot;uint8&quot;])
+        self.read(&quot;second&quot;, &quot;Second&quot;, [FormatChunk, &quot;uint8&quot;])
 
-    def __str__(self):
-        return &quot;PNG time chunk &lt;%04u-%02u-%02u %02u:%02u:%02u&gt;&quot; % \
-            (self[&quot;year&quot;], self[&quot;month&quot;], self[&quot;day&quot;],
-             self[&quot;hour&quot;], self[&quot;minute&quot;], self[&quot;second&quot;])
-        
-class PngChunk(Filter):
+    def updateParent(self, chunk):
+        time = datetime.datetime(self[&quot;year&quot;], self[&quot;month&quot;], self[&quot;day&quot;], self[&quot;hour&quot;], self[&quot;minute&quot;], self[&quot;second&quot;])
+        chunk.description = &quot;Time: %s&quot; % time
+
+class Chunk(OnDemandFilter):
     handler = {
-        &quot;tIME&quot;: PngTime,
-        &quot;pHYs&quot;: PngPhysical,
-        &quot;IHDR&quot;: PngHeader,
-        &quot;gAMA&quot;: PngGamma,
-        &quot;tEXt&quot;: PngText
+        &quot;tIME&quot;: Time,
+        &quot;pHYs&quot;: Physical,
+        &quot;IHDR&quot;: Header,
+        &quot;PLTE&quot;: Palette,
+        &quot;gAMA&quot;: Gamma,
+        &quot;tEXt&quot;: Text
     }
+    name = {
+        &quot;tIME&quot;: (&quot;time&quot;, &quot;Creation time&quot;),
+        &quot;pHYs&quot;: (&quot;physical&quot;, &quot;Physical informations&quot;),
+        &quot;IHDR&quot;: (&quot;header&quot;, &quot;Header&quot;),
+        &quot;PLTE&quot;: (&quot;palette&quot;, &quot;Palette&quot;),
+        &quot;gAMA&quot;: (&quot;gamma&quot;, &quot;Gamma&quot;),
+        &quot;IDAT&quot;: (&quot;data[]&quot;, &quot;Image data&quot;),
+        &quot;IEND&quot;: (&quot;end&quot;, &quot;End&quot;),
+        &quot;tEXt&quot;: (&quot;text&quot;, &quot;Text&quot;)
+    }
     def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;png_chunk&quot;, &quot;PNG chunk&quot;, stream, parent)
-        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Chunk size&quot;)
-        self.read(&quot;type&quot;, &quot;!4s&quot;, &quot;Chunk type&quot;)
+        OnDemandFilter.__init__(self, &quot;chunk&quot;, &quot;Chunk&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;size&quot;, &quot;Size&quot;, (FormatChunk, &quot;uint32&quot;))
+        self.read(&quot;type&quot;, &quot;Type&quot;, (FormatChunk, &quot;string[4]&quot;))
         type = self[&quot;type&quot;]
-        if type in PngChunk.handler:
+        if type in Chunk.handler:
             size = self[&quot;size&quot;]
+            print &quot;%s.SIZE=%s&quot; % (self.getId(), size)
             oldpos = self._stream.tell()
             sub = stream.createSub(size=size)
-            self.readStreamChild(&quot;chunk_data&quot;, sub, PngChunk.handler[type])
+            handler = Chunk.handler[type]
+            self.read(&quot;data&quot;, &quot;Data&quot;, (handler,), {&quot;stream&quot;: sub, &quot;size&quot;: size})
             assert stream.tell() == (oldpos + size) 
         else:
-            self.read(&quot;data&quot;, &quot;%us&quot; % self[&quot;size&quot;], &quot;Chunk data&quot;)
-        self.read(&quot;crc32&quot;, &quot;!L&quot;, &quot;Chunk CRC32&quot;)
+            self.read(&quot;data&quot;, &quot;Data&quot;, [FormatChunk, &quot;string[%u]&quot; % self[&quot;size&quot;]])
+        self.read(&quot;crc32&quot;, &quot;CRC32&quot;, (FormatChunk, &quot;uint32&quot;), {&quot;post&quot;: hexadecimal})
 
     def updateParent(self, chunk):
-        self.description = &quot;PNG chunk (type %s)&quot; % self[&quot;type&quot;]
-        chunk.description = &quot;PNG chunk (type %s)&quot; % self[&quot;type&quot;]
+        type = self[&quot;type&quot;]
+        if type in Chunk.name:
+            name = Chunk.name[type]
+            id = self.getParent().getUniqChunkId(name[0])
+            self.setId(id)
+            type = name[1] 
+        else:
+            type = &quot;Unknow (%s)&quot; % type
+        chunk.description = &quot;Chunk: %s&quot; % type
 
-    def __str__(self):
-        return &quot;PngChunk &lt;size=%u, type=%s&gt;&quot; % (self[&quot;size&quot;], self[&quot;type&quot;])
-
-class PngFile(Filter):
-    &quot;&quot;&quot;
-    Split a PNG file into chunks.
-    &quot;&quot;&quot;
-
+class PngFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;png_file&quot;, &quot;PNG file&quot;, stream, parent)
-        self.read(&quot;header&quot;, &quot;!8s&quot;, &quot;File header&quot;)
-        assert self[&quot;header&quot;] == &quot;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&quot;
+        OnDemandFilter.__init__(self, &quot;png&quot;, &quot;PNG picture&quot;, stream, parent, &quot;!&quot;)
+        self.read(&quot;id&quot;, &quot;PNG identifier&quot;, [FormatChunk, &quot;string[8]&quot;])
+        assert self[&quot;id&quot;] == &quot;\x89PNG\r\n\x1A\n&quot;
         while not stream.eof():
-            self.readChild(&quot;chunks[]&quot;, PngChunk)
+            size = 4*3 + stream.getFormat(&quot;!uint32&quot;, False)
+            self.read(&quot;chunks[]&quot;, &quot;Chunk&quot;, (Chunk,), {&quot;size&quot;: size})
 
 registerPlugin(PngFile, [&quot;image/png&quot;, &quot;image/x-png&quot;])

Deleted: haypo/hachoir/trunk/plugins/rpm.py
===================================================================
--- haypo/hachoir/trunk/plugins/rpm.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/rpm.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,261 +0,0 @@
-&quot;&quot;&quot;
-RPM archive parser.
-
-Author: Victor Stinner, 1st December 2005.
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-from format import getFormatSize
-from gzip import GzipFile
-
-class RpmItem(Filter):
-    format = {
-        #  (use FormatChunk? else use StringChunk, chunk format, count)
-        0: (True, &quot;B&quot;, 1),
-        1: (True, &quot;c&quot;, 1),
-        2: (True, &quot;B&quot;, 1),
-        3: (True, &quot;H&quot;, 1),
-        4: (True, &quot;L&quot;, 1),
-        5: (True, &quot;L&quot;, 2),
-        6: (False, &quot;C&quot;, 1),
-        7: (True, &quot;s&quot;, 1),
-        8: (True, &quot;s&quot;, 1),
-        9: (False, &quot;C&quot;, 1)
-    }
-    type_name = {
-        0: &quot;NULL&quot;,
-        1: &quot;CHAR&quot;,
-        2: &quot;INT8&quot;,
-        3: &quot;INT16&quot;,
-        4: &quot;INT32&quot;,
-        5: &quot;INT64&quot;,
-        6: &quot;STRING&quot;,
-        7: &quot;BIN&quot;,
-        8: &quot;STRING_ARRAY&quot;,
-        9: &quot;STRING?&quot;
-    }
-    tag_name = {
-        1000: &quot;File size&quot;,
-        1001: &quot;(Broken) MD5 signature&quot;,
-        1002: &quot;PGP 2.6.3 signature&quot;,
-        1003: &quot;(Broken) MD5 signature&quot;,
-        1004: &quot;MD5 signature&quot;,
-        1005: &quot;GnuPG signature&quot;,
-        1006: &quot;PGP5 signature&quot;,
-        1007: &quot;Uncompressed payload size (bytes)&quot;,
-        256+8: &quot;Broken SHA1 header digest&quot;,
-        256+9: &quot;Broken SHA1 header digest&quot;,
-        256+13: &quot;Broken SHA1 header digest&quot;,
-        256+11: &quot;DSA header signature&quot;,
-        256+12: &quot;RSA header signature&quot;
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;rpm_item&quot;, &quot;RPM item&quot;, stream, parent)
-        self.read(&quot;tag&quot;, &quot;!L&quot;, &quot;Tag&quot;)
-        self.read(&quot;type&quot;, &quot;!L&quot;, &quot;Type&quot;, post=self.postType)
-        self.read(&quot;offset&quot;, &quot;!L&quot;, &quot;Offset&quot;)
-        self.read(&quot;count&quot;, &quot;!L&quot;, &quot;Count&quot;)
-
-    def postType(self, chunk):
-        return self.getType(chunk.value)
-
-    def updateParent(self, chunk):
-        type = self.getType(self[&quot;type&quot;])
-        tag = self.getTagName()
-        chunk.description = &quot;RPM item: %s (%s)&quot; % (tag, type)
-        
-    def getTagName(self):
-        tag = self[&quot;tag&quot;]
-        return RpmItem.tag_name.get(tag, &quot;Unknow tag (%s)&quot; % tag)
-
-    def doRead(self, filter):
-        type = self[&quot;type&quot;]
-        desc = &quot;Value of item %s, %s&quot; % (self.getId(), self.getDescription())
-        if type != 8:
-            format = RpmItem.format[type]
-            if format[0]:
-                if 2 &lt; self[&quot;count&quot;] and format[1] != &quot;s&quot;:
-                    format = &quot;!&quot; + str(format[2] * self[&quot;count&quot;] * getFormatSize(format[1])) + &quot;s&quot;
-                else:
-                    format = &quot;!&quot; + str(format[2] * self[&quot;count&quot;]) + format[1]
-                filter.read(&quot;data[]&quot;, format, desc)
-            else:     
-                format = format[1]
-                filter.readString(&quot;data[]&quot;, format, desc)
-        else:
-            id = filter.getUniqChunkId(&quot;data[]&quot;)
-            for i in range(0, self[&quot;count&quot;]):
-                filter.readString(id+&quot;[]&quot;, &quot;C&quot;, desc)
-    
-    def getType(self, type):
-        return RpmItem.type_name.get(type, &quot;Unknow type (%s)&quot; % type)
-
-class RpmHeaderItem(RpmItem):
-    tag_name = {
-        61: &quot;Current image&quot;,
-        62: &quot;Signatures&quot;,
-        63: &quot;Immutable&quot;,
-        64: &quot;Regions&quot;,
-        100: &quot;I18N string locales&quot;,
-        1000: &quot;Name&quot;,
-        1001: &quot;Version&quot;,
-        1002: &quot;Release&quot;,
-        1003: &quot;Epoch&quot;,
-        1004: &quot;Summary&quot;,
-        1005: &quot;Description&quot;,
-        1006: &quot;Build time&quot;,
-        1007: &quot;Build host&quot;,
-        1008: &quot;Install time&quot;,
-        1009: &quot;Size&quot;,
-        1010: &quot;Distribution&quot;,
-        1011: &quot;Vendor&quot;,
-        1012: &quot;Gif&quot;,
-        1013: &quot;Xpm&quot;,
-        1014: &quot;Licence&quot;,
-        1015: &quot;Packager&quot;,
-        1016: &quot;Group&quot;,
-        1017: &quot;Changelog&quot;,
-        1018: &quot;Source&quot;,
-        1019: &quot;Patch&quot;,
-        1020: &quot;Url&quot;,
-        1021: &quot;OS&quot;,
-        1022: &quot;Arch&quot;,
-        1023: &quot;Prein&quot;,
-        1024: &quot;Postin&quot;,
-        1025: &quot;Preun&quot;,
-        1026: &quot;Postun&quot;,
-        1027: &quot;Old filenames&quot;,
-        1028: &quot;File sizes&quot;,
-        1029: &quot;File states&quot;,
-        1030: &quot;File modes&quot;,
-        1031: &quot;File uids&quot;,
-        1032: &quot;File gids&quot;,
-        1033: &quot;File rdevs&quot;,
-        1034: &quot;File mtimes&quot;,
-        1035: &quot;File MD5s&quot;,
-        1036: &quot;File link to's&quot;,
-        1037: &quot;File flags&quot;,
-        1038: &quot;Root&quot;,
-        1039: &quot;File username&quot;,
-        1040: &quot;File groupname&quot;,
-        1043: &quot;Icon&quot;,
-        1044: &quot;Source rpm&quot;,
-        1045: &quot;File verify flags&quot;,
-        1046: &quot;Archive size&quot;,
-        1047: &quot;Provide name&quot;,
-        1048: &quot;Require flags&quot;,
-        1049: &quot;Require name&quot;,
-        1050: &quot;Require version&quot;,
-        1051: &quot;No source&quot;,
-        1052: &quot;No patch&quot;,
-        1053: &quot;Conflict flags&quot;,
-        1054: &quot;Conflict name&quot;,
-        1055: &quot;Conflict version&quot;,
-        1056: &quot;Default prefix&quot;,
-        1057: &quot;Build root&quot;,
-        1058: &quot;Install prefix&quot;,
-        1059: &quot;Exclude arch&quot;,
-        1060: &quot;Exclude OS&quot;,
-        1061: &quot;Exclusive arch&quot;,
-        1062: &quot;Exclusive OS&quot;,
-        1064: &quot;RPM version&quot;,
-        1065: &quot;Trigger scripts&quot;,
-        1066: &quot;Trigger name&quot;,
-        1067: &quot;Trigger version&quot;,
-        1068: &quot;Trigger flags&quot;,
-        1069: &quot;Trigger index&quot;,
-        1079: &quot;Verify script&quot;,
-        #TODO: Finish the list (id 1070..1162 using rpm library source code)
-    }
-        
-    def getTagName(self):
-        tag = self[&quot;tag&quot;]
-        return RpmHeaderItem.tag_name.get(tag, &quot;Unknow tag (%s)&quot; % tag)
-            
-def sortRpmItem(a,b):
-    return int( a[&quot;offset&quot;] - b[&quot;offset&quot;] )
-
-class Header(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;header&quot;, &quot;Header&quot;, stream, parent)
-        id = self.read(&quot;id&quot;, &quot;4s&quot;, &quot;Identifier&quot;).value
-        assert id == &quot;\x8E\xAD\xE8\x01&quot;
-        self.read(&quot;padding&quot;, &quot;4s&quot;, &quot;Padding&quot;)
-        self.read(&quot;count&quot;, &quot;!L&quot;, &quot;Count&quot;)
-        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Store size&quot;)
-        items = []
-        for i in range(0, self[&quot;count&quot;]):
-            item = self.readChild(&quot;item[]&quot;, RpmHeaderItem).getFilter()
-            items.append(item)
-        items.sort( sortRpmItem )
-
-        start = stream.tell()
-        end = stream.tell() + self[&quot;size&quot;]
-        for item in items:
-            offset = item[&quot;offset&quot;]
-            diff = offset - (stream.tell() - start)
-            if 0 &lt; diff:
-                self.read(&quot;padding[]&quot;, &quot;%us&quot; % diff, &quot;Padding&quot;)
-
-            print &quot;Read %s&quot; % item.getId()                
-            item.doRead(self)
-        size = end - stream.tell()
-        if 0 &lt; size:    
-            self.read(&quot;padding[]&quot;, &quot;%us&quot; % size, &quot;Padding&quot;)
-
-class RpmSignature(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;rpm_sig&quot;, &quot;RPM signature&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;!3B&quot;, &quot;Identifier&quot;)
-        assert self[&quot;id&quot;] == (142, 173, 232)
-        self.read(&quot;version&quot;, &quot;!B&quot;, &quot;Signature version&quot;)
-        self.read(&quot;reserved&quot;, &quot;4s&quot;, &quot;Reserved&quot;)
-        self.read(&quot;count&quot;, &quot;!L&quot;, &quot;Count&quot;)
-        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Size&quot;)
-        items = []
-        for i in range(0, self[&quot;count&quot;]):
-            item = self.readChild(&quot;item[]&quot;, RpmItem).getFilter()
-            items.append(item)
-        items.sort( sortRpmItem )
-
-        start = stream.tell()
-        end = stream.tell() + self[&quot;size&quot;]
-        for item in items:
-            offset = item[&quot;offset&quot;]
-            diff = offset - (stream.tell() - start)
-            if 0 &lt; diff:
-                self.read(&quot;padding[]&quot;, &quot;%us&quot; % diff, &quot;Padding&quot;)
-            item.doRead(self)
-        size = end - stream.tell()
-        if 0 &lt; size:    
-            self.read(&quot;padding[]&quot;, &quot;%us&quot; % size, &quot;Padding&quot;)
-
-class RpmFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;rpm_file&quot;, &quot;RPM File&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;!4B&quot;, &quot;Identifier&quot;)
-        assert self[&quot;id&quot;] == (237, 171, 238, 219)
-        self.read(&quot;major_ver&quot;, &quot;!B&quot;, &quot;Major version&quot;)
-        self.read(&quot;minor_ver&quot;, &quot;!B&quot;, &quot;Minor version&quot;)
-        self.read(&quot;type&quot;, &quot;!H&quot;, &quot;RPM type&quot;, post=self.postType)
-        self.read(&quot;architecture&quot;, &quot;!H&quot;, &quot;Architecture&quot;)
-        self.read(&quot;name&quot;, &quot;!66s&quot;, &quot;Archive name&quot;)
-        self.read(&quot;osnum&quot;, &quot;!H&quot;, &quot;OS&quot;)
-        self.read(&quot;signature_type&quot;, &quot;!H&quot;, &quot;Type of signature&quot;)
-        self.read(&quot;reserved&quot;, &quot;16s&quot;, &quot;Reserved&quot;)
-        self.readChild(&quot;signature&quot;, RpmSignature)
-        self.readChild(&quot;header&quot;, Header)
-        sub = stream.createSub()
-        self.readStreamChild(&quot;gz_content&quot;, sub, GzipFile)
-
-    def postType(self, chunk):
-        if chunk.value == 0:
-            return &quot;Binary&quot;
-        elif chunk.value == 1:
-            return &quot;Source&quot;
-        else:
-            return &quot;Unknown (%s)&quot; % chunk.value
-
-registerPlugin(RpmFile, &quot;application/x-rpm&quot;)

Modified: haypo/hachoir/trunk/plugins/tar.py
===================================================================
--- haypo/hachoir/trunk/plugins/tar.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/tar.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -7,10 +7,11 @@
 
 import re
 from datetime import datetime
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
+from filter import OnDemandFilter, DeflateFilter
 from tools import convertDataToPrintableString
-from default import EmptyFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk
+from default import DefaultFilter
 from plugin import guessPlugin 
 from error import error
 from tools import getBacktrace, humanFilesize
@@ -46,10 +47,53 @@
         print &quot;[ File %s ]&quot; % file.name
         displayFile(file)
 
-class TarFileEntry(Filter):
-    def stripNul(self, chunk):
-        return chunk.value.strip(&quot;\0&quot;)
+class FileEntry(OnDemandFilter):
+    type_name = {
+        0: &quot;Normal disk file (old format)&quot;,
+        # 48 is &quot;0&quot;, 49 is &quot;1&quot;, ...
+        48: &quot;Normal disk file&quot;,
+        49: &quot;Link to previously dumped file&quot;,
+        50: &quot;Symbolic link&quot;,
+        51: &quot;Character special file&quot;,
+        52: &quot;Block special file&quot;,
+        53: &quot;Directory&quot;,
+        54: &quot;FIFO special file&quot;,
+        55: &quot;Contiguous file&quot;
+    }
 
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, &quot;file&quot;, &quot;File entry&quot;, stream, parent)
+        self.read(&quot;name&quot;, &quot;Name&quot;, (FormatChunk, &quot;string[100]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;mode&quot;, &quot;Mode&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.convertOctal})
+        self.read(&quot;uid&quot;, &quot;User ID&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.convertOctal})
+        self.read(&quot;gid&quot;, &quot;Group ID&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.convertOctal})
+        self.read(&quot;size&quot;, &quot;Size&quot;, (FormatChunk, &quot;string[12]&quot;), {&quot;post&quot;: self.convertOctal})
+        self.read(&quot;mtime&quot;, &quot;Modification time&quot;, (FormatChunk, &quot;string[12]&quot;), {&quot;post&quot;: self.getTime})
+        self.read(&quot;check_sum&quot;, &quot;Check sum&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.convertOctal})
+        self.read(&quot;type&quot;, &quot;Type&quot;, (EnumChunk, &quot;uint8&quot;, FileEntry.type_name))
+        self.read(&quot;lname&quot;, &quot;Link name&quot;, (FormatChunk, &quot;string[100]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;magic&quot;, &quot;Magic&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;uname&quot;, &quot;User name&quot;, (FormatChunk, &quot;string[32]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;gname&quot;, &quot;Group name&quot;, (FormatChunk, &quot;string[32]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;devmajor&quot;, &quot;Dev major&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;devminor&quot;, &quot;Dev minor&quot;, (FormatChunk, &quot;string[8]&quot;), {&quot;post&quot;: self.printable})
+        self.read(&quot;padding&quot;, &quot;Padding (zero)&quot;, (FormatChunk, &quot;string[167]&quot;))
+
+        self.name = self[&quot;name&quot;].strip(&quot;\0&quot;)
+        self.size = self.octal2int(self[&quot;size&quot;])
+        if self[&quot;type&quot;] in (0, ord(&quot;0&quot;)) and self.size != 0:
+            substream = stream.createSub(stream.tell(), self.size)
+            plugin = guessPlugin(substream, self.name)
+            self.read(&quot;content&quot;, &quot;Compressed file content&quot;, (DeflateFilter, substream, self.size, plugin), {&quot;stream&quot;: substream, &quot;size&quot;: self.size})
+
+        padding = 512 - stream.tell() % 512
+        if padding != 512:
+            self.read(&quot;padding_end&quot;, &quot;Padding (512 align)&quot;, (FormatChunk, &quot;string[%u]&quot; % padding))
+
+    def printable(self, chunk):
+        value = chunk.value.strip(&quot; \0&quot;)
+        return convertDataToPrintableString(value)
+
     def getMode(self, chunk):
         mode = self.octal2int(chunk.value)
         owner = self._getModeItem(mode &gt;&gt; 6 &amp; 7)
@@ -69,57 +113,15 @@
     def convertOctal(self, chunk):
         return self.octal2int(chunk.value)
 
-    def stripNul(self, chunk):
-        val = chunk.value.strip(&quot;\0&quot;)
-        return convertDataToPrintableString(val)
-
     def getTime(self, chunk):
         value = self.octal2int(chunk.value) 
-        return datetime.fromtimestamp(value)
+        return str(datetime.fromtimestamp(value))
 
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;tar_file_entry&quot;,&quot;Tar file entry&quot;, stream, parent)
-        self.read(&quot;name&quot;, &quot;!100s&quot;, &quot;Name&quot;, post=self.stripNul)
-        self.name = self[&quot;name&quot;].strip(&quot;\0&quot;)
-        self.read(&quot;mode&quot;, &quot;!8s&quot;, &quot;Mode&quot;, post=self.convertOctal)
-        self.read(&quot;uid&quot;, &quot;!8s&quot;, &quot;User ID&quot;, post=self.convertOctal)
-        self.read(&quot;gid&quot;, &quot;!8s&quot;, &quot;Group ID&quot;, post=self.convertOctal)
-        self.read(&quot;size&quot;, &quot;!12s&quot;, &quot;Size&quot;, post=self.convertOctal)
-        self.size = self.octal2int(self[&quot;size&quot;])
-        self.read(&quot;mtime&quot;, &quot;!12s&quot;, &quot;Modification time&quot;, self.getTime)
-        self.read(&quot;check_sum&quot;, &quot;!8s&quot;, &quot;Check sum&quot;)
-        self.read(&quot;type&quot;, &quot;!c&quot;, &quot;Type&quot;)
-        self.read(&quot;lname&quot;, &quot;!100s&quot;, &quot;Link name&quot;, post=self.stripNul)
-        self.read(&quot;magic&quot;, &quot;!8s&quot;, &quot;Magic&quot;, post=self.stripNul)
-        self.read(&quot;uname&quot;, &quot;!32s&quot;, &quot;User name&quot;, post=self.stripNul)
-        self.read(&quot;gname&quot;, &quot;!32s&quot;, &quot;Group name&quot;, post=self.stripNul)
-        self.read(&quot;devmajor&quot;, &quot;!8s&quot;, &quot;Dev major&quot;)
-        self.read(&quot;devminor&quot;, &quot;!8s&quot;, &quot;Dev minor&quot;)
-        self.read(&quot;header_padding&quot;, &quot;!167s&quot;, &quot;Padding (zero)&quot;)
-        if self[&quot;type&quot;] in (&quot;\0&quot;, &quot;0&quot;) and self.size != 0:
-            substream = stream.createSub(stream.tell(), self.size)
-            plugin = guessPlugin(substream, self.name)
-
-            oldpos = stream.tell()
-            try:
-                chunk = self.readChild(&quot;filedata&quot;, DeflateFilter, substream, self.size, plugin)
-#                chunk = self.readLimitedChild(&quot;filedata&quot;, stream, self.size, plugin)
-            except Exception, msg:
-                error(&quot;Error while processing tar file \&quot;%s\&quot;: %s\n%s&quot; % (self.name, msg, getBacktrace()))
-                stream.seek(oldpos)
-                chunk = self.readChild(&quot;filedata&quot;, EmptyFilter)
-                filter = chunk.getFilter()
-                filter.read(&quot;filedata&quot;, &quot;!%us&quot; % self.size, &quot;File data&quot;)
-
-        if stream.tell() % 512 != 0:
-            padding = 512 - stream.tell() % 512
-            self.read(&quot;padding&quot;, &quot;!%ss&quot; % padding, &quot;Padding (512 align)&quot;)
-
     def isEmpty(self):
         return self.name == &quot;&quot;
 
     def octal2int(self, str):
-        str = str.strip(&quot;\0&quot;)
+        str = str.strip(&quot; \0&quot;)
         if str==&quot;&quot;: return 0
         assert re.match(&quot;^[0-7]+$&quot;, str)
         try:
@@ -127,38 +129,23 @@
         except:
             return 0
 
-    def getType(self):
-        name = { \
-            &quot;\0&quot;: &quot;Normal disk file (old format), Unix compatible&quot;,
-            &quot;0&quot;: &quot;Normal disk file&quot;,
-            &quot;1&quot;: &quot;Link to previously dumped file&quot;,
-            &quot;2&quot;: &quot;Symbolic link&quot;,
-            &quot;3&quot;: &quot;Character special file&quot;,
-            &quot;4&quot;: &quot;Block special file&quot;,
-            &quot;5&quot;: &quot;Directory&quot;,
-            &quot;6&quot;: &quot;FIFO special file&quot;,
-            &quot;7&quot;: &quot;Contiguous file&quot;
-        }
-        name.get(self[&quot;type&quot;], &quot;Unknow type (%02X)&quot; % ord(self[&quot;type&quot;]))
-
     def updateParent(self, chunk):
         if not self.isEmpty():
             text = &quot;Tar File (%s: %s, %s)&quot; \
-                % (self.name, self.getType(), humanFilesize(self.size))
+                % (self.name, self.getChunk(&quot;type&quot;).display, humanFilesize(self.size))
         else:
             text = &quot;Tar File (terminator, empty header)&quot;
         chunk.description = text
         self.setDescription(text)
 
-class TarFile(Filter):
+class TarFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, &quot;tar_file&quot;, &quot;TAR archive file&quot;, stream, parent)
+        OnDemandFilter.__init__(self, &quot;tar_file&quot;, &quot;TAR archive file&quot;, stream, parent)
         while not stream.eof():
-            chunk = self.readChild(&quot;file[]&quot;, TarFileEntry)
-            if chunk.getFilter().isEmpty():
+            file = self.doRead(&quot;file[]&quot;, &quot;File&quot;, (FileEntry,))
+            if file.isEmpty():
                 break
-        
         padding = stream.getSize() - stream.tell()
-        self.read(&quot;padding&quot;, &quot;!%ss&quot; % padding, &quot;Padding (4096 align)&quot;)
-        
+        self.read(&quot;padding&quot;, &quot;Padding&quot;, (FormatChunk, &quot;string[%u]&quot; % padding))
+
 registerPlugin(TarFile, [&quot;application/x-gtar&quot;, &quot;application/x-tar&quot;])

Deleted: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,83 +0,0 @@
-&quot;&quot;&quot;
-Worms2 DIR file.
-&quot;&quot;&quot;
-
-from plugin import registerPlugin 
-from filter import Filter
-from plugin import registerPlugin
-from tools import humanFilesize
-
-class Worms2_Image(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;worms2_image&quot;, &quot;Worms2 image&quot;, stream, parent)
-        nb_color = 244/3
-        self.read(&quot;palette&quot;, &quot;%us&quot; % (nb_color*3), &quot;Palette (%u colors)&quot; % nb_color)
-        self.read(&quot;padding&quot;, &quot;B&quot;, &quot;Padding&quot;)
-        self.read(&quot;width&quot;, &quot;&lt;H&quot;, &quot;Width&quot;)
-        self.read(&quot;height&quot;, &quot;&lt;H&quot;, &quot;Height&quot;)
-        size = self[&quot;width&quot;] * self[&quot;height&quot;]
-        self.read(&quot;img_data&quot;, &quot;%us&quot; % size, &quot;Data&quot;)
-        size = stream.getSize() - stream.tell()
-        self.read(&quot;end&quot;, &quot;%us&quot; % size, &quot;Raw end&quot;)
-
-class Worms2_Sprite(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;worms2_sprite&quot;, &quot;Worms2 sprite&quot;, stream, parent)
-        # TODO ...
-        size = stream.getSize() - stream.tell()
-        self.read(&quot;end&quot;, &quot;%us&quot; % size, &quot;Raw end&quot;)
-
-class Worms2_Font(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;worms2_sprite&quot;, &quot;Worms2 sprite&quot;, stream, parent)
-        self.read(&quot;palette&quot;, &quot;%us&quot; % (244+33), &quot;Palette (?)&quot;)
-        self.read(&quot;charset&quot;, &quot;%us&quot; % (32), &quot;Charset&quot;)
-        self.read(&quot;data&quot;, &quot;%us&quot; % (32+30+4+136), &quot;Data&quot;)
-        # TODO ...
-        size = stream.getSize() - stream.tell()
-        self.read(&quot;end&quot;, &quot;%us&quot; % size, &quot;Raw end&quot;)
-
-class Worms2_Resource(Filter):
-    handler = {
-        &quot;IMG&quot;: Worms2_Image,
-        &quot;SPR&quot;: Worms2_Sprite,
-        &quot;FNT&quot;: Worms2_Font
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;worms2_res&quot;, &quot;Worms2 resource&quot;, stream, parent)
-        pos = stream.tell()
-        self.tag = self.read(&quot;tag&quot;, &quot;3s&quot;, &quot;Type&quot;).value.strip(&quot;\0\n&quot;)
-        self.valid = self.tag.strip(&quot;\0\n&quot;) != &quot;&quot;
-        self.read(&quot;tag_end&quot;, &quot;1s&quot;, &quot;Type end&quot;)
-        size = self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;).value
-        if not self.valid:
-            return
-        self.readString(&quot;name&quot;, &quot;C&quot;, &quot;Name&quot;)
-        size = pos + size + 1 - stream.tell()
-        if self.tag in Worms2_Resource.handler:
-            sub = stream.createSub(size=size)
-            self.readStreamChild(&quot;data&quot;, sub, Worms2_Resource.handler[self.tag])
-        else:
-            self.read(&quot;data&quot;, &quot;%us&quot; % size, &quot;Data&quot;)
-
-    def updateParent(self, chunk):            
-        size = humanFilesize(self[&quot;size&quot;])
-        tag = self.tag
-        if tag != &quot;&quot;:
-            name = self[&quot;name&quot;]
-        else:
-            tag = &quot;(invalid)&quot;
-            name = &quot;(invalid)&quot;
-        chunk.description = &quot;Resource \&quot;%s\&quot; (type=%s, size=%s)&quot; % (name, tag, size)
-
-class Worms2_Dir_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;worms2_dir_file&quot;, &quot;Worms2 directory (.dir) file&quot;, stream, parent)
-        self.read(&quot;id&quot;, &quot;3s&quot;, &quot;Identifier (DIR)&quot;)
-        self.read(&quot;raw&quot;, &quot;%us&quot; % (12-stream.tell()), &quot;Raw data&quot;)
-        while stream.tell() &lt; 3432805:
-            file = self.readChild(&quot;file[]&quot;, Worms2_Resource).getFilter()
-            if not file.valid:
-                break
-         
-registerPlugin(Worms2_Dir_File, &quot;hachoir/worms2&quot;)

Deleted: haypo/hachoir/trunk/plugins/xcf.py
===================================================================
--- haypo/hachoir/trunk/plugins/xcf.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/xcf.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,226 +0,0 @@
-&quot;&quot;&quot;
-Exif filter.
-
-Informations about Exif at:
-- <A HREF="http://www.exif.org/">http://www.exif.org/</A>
-- <A HREF="http://libexif.sourceforge.net/">http://libexif.sourceforge.net/</A>
-
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-from filter import Filter
-from plugin import registerPlugin
-
-class XcfCompression(Filter):
-    name = {
-        0: &quot;None&quot;,
-        1: &quot;RLE&quot;,
-        2: &quot;Zlib&quot;,
-        3: &quot;Fractal&quot;
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;compression&quot;, &quot;Compression&quot;, stream, parent)
-        chunk = self.read(&quot;compression&quot;, &quot;B&quot;, &quot;&quot;)
-        type = XcfCompression.name.get(chunk.value, &quot;Unknow (%s)&quot; % chunk.value)
-        chunk.description = &quot;Compress type (%s)&quot; % type
-
-class XcfResolution(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;resolution&quot;, &quot;Resolution&quot;, stream, parent)
-        self.read(&quot;xres&quot;, &quot;f&quot;, &quot;X resolution&quot;)
-        self.read(&quot;yres&quot;, &quot;f&quot;, &quot;Y resolution&quot;)
-
-class XcfTattoo(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;tattoo&quot;, &quot;Tattoo&quot;, stream, parent)
-        self.read(&quot;tattoo&quot;, &quot;!L&quot;, &quot;Tattoo&quot;)
-
-class XcfUnit(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;unit&quot;, &quot;Unit&quot;, stream, parent)
-        self.read(&quot;unit&quot;, &quot;!L&quot;, &quot;Unit&quot;)
-
-def readString(filter, stream, name, description):
-    filter.readString(name, &quot;Pascal32&quot;, description, strip=&quot;\0&quot;)
-    return
-    
-    chunk = filter.read(name+&quot;_size&quot;, &quot;!L&quot;, description+&quot; length&quot;)
-    filter.read(name, &quot;%us&quot; % chunk.value, description)
-
-class XcfParasiteEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf_para&quot;, &quot;XCF parasite&quot;, stream, parent)
-        readString(self, stream, &quot;name&quot;, &quot;Name&quot;)
-        self.read(&quot;flags&quot;, &quot;!L&quot;, &quot;Flags&quot;)
-        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Size&quot;)
-        if 0 &lt; self[&quot;size&quot;]:
-            self.read(&quot;data&quot;, &quot;%us&quot; % self[&quot;size&quot;], &quot;Data&quot;)
-
-class XcfLevel(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf_level&quot;, &quot;XCF level&quot;, stream, parent)
-        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Width&quot;)
-        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Height&quot;)
-        self.read(&quot;offset&quot;, &quot;!L&quot;, &quot;Offset&quot;)
-        offset = self[&quot;offset&quot;]
-        if offset == 0:
-            return
-        data_offsets = []
-        while stream.tell() &lt; offset:
-            chunk = self.read(&quot;data_offset[]&quot;, &quot;!L&quot;, &quot;Data offset&quot;)
-            if chunk.value == 0:
-                break
-            data_offsets.append(chunk.value)
-        assert stream.tell() == offset
-        previous = offset
-        for data_offset in data_offsets:
-            size = data_offset - previous
-            self.read(&quot;data[]&quot;, &quot;%us&quot; % size, &quot;Data&quot;)
-            previous = data_offset
-
-class XcfHierarchie(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf_hier&quot;, &quot;XCF hierarchie&quot;, stream, parent)
-        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Width&quot;)
-        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Height&quot;)
-        self.read(&quot;bpp&quot;, &quot;!L&quot;, &quot;Bits/pixel&quot;)
-            
-        offsets = []
-        while True:
-            chunk = self.read(&quot;offset[]&quot;, &quot;!L&quot;, &quot;Level offset&quot;)
-            if chunk.value == 0:
-                break
-            offsets.append(chunk.value)
-        for offset in offsets:
-            seek(self, stream, offset)
-            self.readChild(&quot;level[]&quot;, XcfLevel)
-#        self.readChild(&quot;channel[]&quot;, XcfChannel)
-
-class XcfChannel(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf_channel&quot;, &quot;XCF channel&quot;, stream, parent)
-        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Channel width&quot;)
-        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Channel height&quot;)
-        readString(self, stream, &quot;name&quot;, &quot;Channel name&quot;)
-        readProperties(self, stream)
-        self.read(&quot;hierarchie_ofs&quot;, &quot;!L&quot;, &quot;Hierarchie offset&quot;)
-        self.readChild(&quot;hierarchie&quot;, XcfHierarchie)
-
-class XcfLayer(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf_layer&quot;, &quot;XCF layer&quot;, stream, parent)
-        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Layer width&quot;)
-        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Layer height&quot;)
-        self.read(&quot;type&quot;, &quot;!L&quot;, &quot;Layer type&quot;)
-        readString(self, stream, &quot;name&quot;, &quot;Layer name&quot;)
-        readProperties(self, stream)
-        # TODO: Hack for Gimp 1.2 files
-        self.read(&quot;hierarchie_ofs&quot;, &quot;!L&quot;, &quot;Hierarchie offset&quot;)
-        self.read(&quot;mask_ofs&quot;, &quot;!L&quot;, &quot;Layer mask offset&quot;)
-        seek(self, stream, self[&quot;hierarchie_ofs&quot;])
-        self.readChild(&quot;hierarchie&quot;, XcfHierarchie)
-        # TODO: Read layer mask if needed: self[&quot;mask_ofs&quot;] != 0
-
-    def updateParent(self, chunk):
-        desc = &quot;Layer \&quot;%s\&quot;&quot; % self[&quot;name&quot;]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class XcfParasites(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;parasites&quot;, &quot;Parasites&quot;, stream, parent)
-        while not stream.eof():
-            self.readChild(&quot;parasite[]&quot;, XcfParasiteEntry)
-
-class XcfProperty(Filter):
-    known_types = {
-        0: &quot;End&quot;,
-        1: &quot;Colormap&quot;,
-        2: &quot;Active layer&quot;,
-        3: &quot;Active channel&quot;,
-        4: &quot;Selection&quot;,
-        5: &quot;Floating selection&quot;,
-        6: &quot;Opacity&quot;,
-        7: &quot;Mode&quot;,
-        8: &quot;Visible&quot;,
-        9: &quot;Linked&quot;,
-        10: &quot;Lock alpha&quot;,
-        11: &quot;Apply mask&quot;,
-        12: &quot;Edit mask&quot;,
-        13: &quot;Show mask&quot;,
-        14: &quot;Show masked&quot;,
-        15: &quot;Offsets&quot;,
-        16: &quot;Color&quot;,
-        17: &quot;Compression&quot;,
-        18: &quot;Guides&quot;,
-        19: &quot;Resolution&quot;,
-        20: &quot;Tattoo&quot;,
-        21: &quot;Parasites&quot;,
-        22: &quot;Unit&quot;,
-        23: &quot;Paths&quot;,
-        24: &quot;User unit&quot;,
-        25: &quot;Vectors&quot;,
-        26: &quot;Text layer flags&quot;
-    }
-    handler = {
-        17: XcfCompression,
-        19: XcfResolution,
-        20: XcfTattoo,
-        21: XcfParasites,
-        22: XcfUnit
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf_prop&quot;, &quot;XCF property&quot;, stream, parent)
-        chunk = self.read(&quot;type&quot;, &quot;!L&quot;, &quot;&quot;)
-        chunk.description = &quot;Property type (%s)&quot; % self.getType()
-        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Property size&quot;)
-        type = self[&quot;type&quot;]
-        if type in XcfProperty.handler:
-            end = stream.tell() + self[&quot;size&quot;]
-            substream = stream.createSub(size=self[&quot;size&quot;])
-            self.readStreamChild(&quot;data&quot;, substream, XcfProperty.handler[type])
-            assert stream.tell() == end
-        elif 0 &lt; self[&quot;size&quot;]:
-            self.read(&quot;data&quot;, &quot;%us&quot; % self[&quot;size&quot;], &quot;Data&quot;)
-
-    def updateParent(self, parent):
-        parent.description = &quot;XCF property (%s)&quot; % self.getType()
-
-    def getType(self):
-        return XcfProperty.known_types.get(self[&quot;type&quot;], &quot;Unknow type (%u)&quot; % self[&quot;type&quot;])
-
-def readProperties(filter, stream):        
-    while True:
-        chunk = filter.readChild(&quot;property[]&quot;, XcfProperty)
-        type = chunk.getFilter()[&quot;type&quot;]
-        if type == 0:
-            break
-
-def seek(filter, stream, offset):
-    current = stream.tell()
-    if current != offset:
-        filter.read(&quot;padding[]&quot;, &quot;%us&quot; % (offset-current), &quot;Padding&quot;)
-
-class XcfFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;xcf&quot;, &quot;XCF file&quot;, stream, parent)
-        self.readString(&quot;header&quot;, &quot;C&quot;, &quot;Header&quot;)
-        assert self[&quot;header&quot;] == &quot;gimp xcf file&quot;
-        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Image width&quot;)
-        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Image height&quot;)
-        self.read(&quot;type&quot;, &quot;!L&quot;, &quot;Image type&quot;)
-        readProperties(self, stream)
-
-        offsets = []
-        while True:
-            chunk = self.read(&quot;layer_offset[]&quot;, &quot;!L&quot;, &quot;Layer offset&quot;)
-            if chunk.value == 0:
-                break
-            offsets.append(chunk.value)
-        for offset in offsets:
-            seek(self, stream, offset)
-            self.readChild(&quot;layer[]&quot;, XcfLayer)
-
-registerPlugin(XcfFile, &quot;image/x-xcf&quot;)

Deleted: haypo/hachoir/trunk/plugins/zip.py
===================================================================
--- haypo/hachoir/trunk/plugins/zip.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/zip.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,115 +0,0 @@
-&quot;&quot;&quot;
-Zip splitter.
-
-Status: can read most important headers
-Author: Victor Stinner
-&quot;&quot;&quot;
-
-import sys
-from filter import Filter
-from plugin import registerPlugin
-from error import error
-from text_handler import humanFilesize, hexadecimal
-
-class ZipCentralDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;zip_central_dir&quot;, &quot;ZIP central directory&quot;, stream, parent)
-        self.read(&quot;version_made_by&quot;, &quot;&lt;H&quot;, &quot;Version made by&quot;)
-        self.read(&quot;version_needed&quot;, &quot;&lt;H&quot;, &quot;Version neede&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;General purpose flag&quot;)
-        self.read(&quot;compression_method&quot;, &quot;&lt;H&quot;, &quot;Compression method&quot;)
-        self.read(&quot;last_mod_file_time&quot;, &quot;&lt;H&quot;, &quot;Last moditication file time&quot;)
-        self.read(&quot;last_mod_file_date&quot;, &quot;&lt;H&quot;, &quot;Last moditication file date&quot;)
-        self.read(&quot;crc32&quot;, &quot;&lt;L&quot;, &quot;CRC-32&quot;)
-        self.read(&quot;compressed_size&quot;, &quot;&lt;L&quot;, &quot;Compressed size&quot;)
-        self.read(&quot;uncompressed_size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size&quot;)
-        self.read(&quot;filename_length&quot;, &quot;&lt;H&quot;, &quot;Filename length&quot;)
-        self.read(&quot;extra_length&quot;, &quot;&lt;H&quot;, &quot;Extra fields length&quot;)
-        self.read(&quot;file_comment_length&quot;, &quot;&lt;H&quot;, &quot;File comment length&quot;)
-        self.read(&quot;disk_number_start&quot;, &quot;&lt;H&quot;, &quot;Disk number start&quot;)
-        self.read(&quot;internal_attr&quot;, &quot;&lt;H&quot;, &quot;Internal file attributes&quot;)
-        self.read(&quot;external_attr&quot;, &quot;&lt;L&quot;, &quot;External file attributes&quot;)
-        self.read(&quot;offset_header&quot;, &quot;&lt;L&quot;, &quot;Relative offset of local header&quot;)
-        self.read(&quot;filename&quot;, &quot;%us&quot; % self[&quot;filename_length&quot;], &quot;Filename&quot;)
-        self.read(&quot;extra&quot;, &quot;%us&quot; % self[&quot;extra_length&quot;], &quot;Extra fields&quot;)
-        self.read(&quot;file_comment&quot;, &quot;%us&quot; % self[&quot;file_comment_length&quot;], &quot;File comment&quot;)
-
-    def updateParent(self, chunk):
-        desc = &quot;Central directory: %s&quot; % self[&quot;filename&quot;]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ZipEndCentralDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;zip_end_dir&quot;, &quot;ZIP end central directory&quot;, stream, parent)
-        self.read(&quot;number_disk&quot;, &quot;&lt;H&quot;, &quot;Number of this disk&quot;)
-        self.read(&quot;number_disk2&quot;, &quot;&lt;H&quot;, &quot;Number of this disk2&quot;)
-        self.read(&quot;total_number_disk&quot;, &quot;&lt;H&quot;, &quot;Total number of entries&quot;)
-        self.read(&quot;total_number_disk2&quot;, &quot;&lt;H&quot;, &quot;Total number of entries2&quot;)
-        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size of the central directory&quot;)
-        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;Offset of start of central directory&quot;)
-        self.readString(&quot;comment&quot;, &quot;Pascal16&quot;, &quot;ZIP comment&quot;)
-
-#class ZipZip64(Filter):
-#    def __init__(self, stream, parent):
-#        Filter.__init__(self, &quot;zip_zip64, &quot;ZIP ZIP64&quot;, stream, parent)
-#        self.read(&quot;size&quot;, &quot;&lt;Q&quot;, &quot;Directory size&quot;)
-#        self.read(&quot;version_made_by&quot;, &quot;&lt;H&quot;, &quot;Version made by&quot;)
-#        self.read(&quot;version_needed&quot;, &quot;&lt;H&quot;, &quot;Version neede&quot;)
-#        self.read(&quot;disk_index&quot;, &quot;&lt;L&quot;, &quot;Disk index&quot;)
-#        self.read(&quot;disk_index2&quot;, &quot;&lt;L&quot;, &quot;Disk index2&quot;)
-#        self.read(&quot;disk_number&quot;, &quot;&lt;Q&quot;, &quot;Disk number&quot;)
-#        self.read(&quot;disk_number2&quot;, &quot;&lt;Q&quot;, &quot;Disk number2&quot;)
-#        self.read(&quot;size2&quot;, &quot;&lt;Q&quot;, &quot;Directory size2&quot;)
-#        self.read(&quot;offset&quot;, &quot;&lt;Q&quot;, &quot;Offset&quot;)
-        
-class ZipFileEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;zip_file_entry&quot;, &quot;ZIP file entry&quot;, stream, parent)
-        self.read(&quot;version&quot;, &quot;&lt;H&quot;, &quot;Version&quot;)
-        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;Flags&quot;)
-        self.read(&quot;compression_method&quot;, &quot;&lt;H&quot;, &quot;Compression method&quot;)
-        self.read(&quot;last_mod_time&quot;, &quot;&lt;H&quot;, &quot;Last modification time&quot;)
-        self.read(&quot;last_mod_date&quot;, &quot;&lt;H&quot;, &quot;Last modification date&quot;)
-        self.read(&quot;crc32&quot;, &quot;&lt;L&quot;, &quot;Checksum (CRC32)&quot;)
-        self.read(&quot;compressed_size&quot;, &quot;&lt;L&quot;, &quot;Compressed size (bytes)&quot;, post=humanFilesize)
-        self.read(&quot;uncompressed_size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size (bytes)&quot;, post=humanFilesize)
-        self.read(&quot;filename_length&quot;, &quot;&lt;H&quot;, &quot;Filename length&quot;)
-        self.read(&quot;extra_length&quot;, &quot;&lt;H&quot;, &quot;Extra length&quot;)
-        self.read(&quot;filename&quot;, &quot;%us&quot; % self[&quot;filename_length&quot;], &quot;Filename&quot;)
-        self.read(&quot;extra&quot;, &quot;%us&quot; % self[&quot;extra_length&quot;], &quot;Extra&quot;)
-        self.read(&quot;compressed_data&quot;, &quot;%us&quot; % self[&quot;compressed_size&quot;], &quot;Compressed data&quot;)
-        if (self[&quot;flags&quot;] &amp; 4) == 4:
-            self.read(&quot;file_crc32&quot;, &quot;&lt;L&quot;, &quot;Checksum (CRC32)&quot;)
-            self.read(&quot;file_compressed_size&quot;, &quot;&lt;L&quot;, &quot;Compressed size (bytes)&quot;)
-            self.read(&quot;file_uncompressed_size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size (bytes)&quot;)
-
-    def updateParent(self, chunk):
-        size = self.getChunk(&quot;compressed_size&quot;).display
-        desc = &quot;File entry: %s (%s)&quot; % (self[&quot;filename&quot;], size)
-        chunk.description = desc
-        self.setDescription(desc)
-        
-class ZipFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, &quot;zip_file&quot;, &quot;ZIP archive file&quot;, stream, parent)
-        # File data
-        self.signature = None
-        self.central_directory = []
-        self.files = []
-        while not stream.eof():
-            header = self.read(&quot;header[]&quot;, &quot;&lt;L&quot;, &quot;Header&quot;, post=hexadecimal).value
-            if header == 0x04034B50:
-                self.readChild(&quot;files[]&quot;, ZipFileEntry)
-            elif header == 0x02014b50:
-                self.readChild(&quot;central_directory[]&quot;, ZipCentralDirectory)
-            elif header == 0x06054b50:
-                self.readChild(&quot;end_central_directory&quot;, ZipEndCentralDirectory)
-            elif header == 0x05054b50:
-                self.readString(&quot;signature&quot;, &quot;Pascal16&quot;, &quot;Signature&quot;)
-            else:
-                error(&quot;Error, unknow ZIP header (0x%08X).&quot; % header)
-                size = stream.getSize() - stream.tell()
-                self.read(&quot;raw&quot;, &quot;%us&quot; % size, &quot;Raw&quot;)
-        
-registerPlugin(ZipFile, &quot;application/x-zip&quot;)

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/text_handler.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,8 +1,12 @@
-from tools import humanFilesize as doHumanFilesize
-
 def humanFilesize(chunk):
+    from tools import humanFilesize as doHumanFilesize
     return doHumanFilesize(chunk.value)
 
+def unixTimestamp(chunk):
+    import datetime
+    timestamp = datetime.datetime.fromtimestamp(chunk.value)
+    return str(timestamp) 
+
 def hexadecimal(chunk):
     size = chunk.size
     assert size in (2, 4, 8)

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/tools.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -123,15 +123,12 @@
 def humanFilesize(size):
     if size &lt; 1000:
         return &quot;%u bytes&quot; % size
-    units = [&quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;]
+    units = [&quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;]
     size = float(size)
     for unit in units:
         size = size / 1024
-        if size &lt; 100:
+        if size &lt; 1024:
             return &quot;%.1f %s&quot; % (size, unit)
-        if size &lt; 1000:
-            return &quot;%u %s&quot; % (size, unit)
-        last_unit = unit
     return &quot;%u %s&quot; % (size, unit)
 
 def convertDataToPrintableString(data, keep_n=False):

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/ui/ui_window.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -152,7 +152,7 @@
     def add_table(self, parent, addr, size, format, id, description, value):
         addr = str(addr)
         size = str(size)
-        self.table_store.append(parent, (addr, format, size, id, value, description, ))
+        return self.table_store.append(parent, (addr, format, size, id, value, description, ))
 
     def onKeyUp(self, widget, key, data=None):
         if key.keyval == gtk.keysyms.Escape:

Modified: haypo/hachoir/trunk/user_filter.py
===================================================================
--- haypo/hachoir/trunk/user_filter.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/user_filter.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,4 +1,4 @@
-from filter import Filter
+from filter import OnDemandFilter
 from chunk import FilterChunk
 from xml.dom.minidom import getDOMImplementation, parse
 from program import VERSION
@@ -21,7 +21,7 @@
         self.sub_format = sub_format
 
 def loadUserFilter(desc, stream, parent):
-    filter = Filter(desc.id, desc.description, stream, parent)
+    filter = OnDemandFilter(desc.id, desc.description, stream, parent)
     for chunk in desc.chunks:
         if chunk.format == &quot;sub&quot;:
             modules = chunk.sub_format.split('.')


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000254.html">[Happyboom-svn] r350 - haypo/hachoir/tags
</A></li>
	<LI>Next message: <A HREF="000255.html">[Happyboom-svn] r352 - haypo/hachoir/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#298">[ date ]</a>
              <a href="thread.html#298">[ thread ]</a>
              <a href="subject.html#298">[ subject ]</a>
              <a href="author.html#298">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/happyboom-svn">More information about the Happyboom-svn
mailing list</a><br>
</body></html>
