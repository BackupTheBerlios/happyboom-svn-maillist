From haypo at berlios.de  Sat Mar  4 01:16:05 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:16:05 +0100
Subject: [Happyboom-svn] r419 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/field branches/hachoir-yield/file branches/hachoir-yield/file/image branches/hachoir-yield/generic
Message-ID: <200603040016.k240G590029802@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:15:36 +0100 (Sat, 04 Mar 2006)
New Revision: 419

Added:
   haypo/hachoir/branches/hachoir-yield/file/__init__.py
   haypo/hachoir/branches/hachoir-yield/file/image/__init__.py
   haypo/hachoir/branches/hachoir-yield/generic/
   haypo/hachoir/branches/hachoir-yield/generic/__init__.py
   haypo/hachoir/branches/hachoir-yield/generic/image.py
   haypo/hachoir/branches/hachoir-yield/metadata.py
Removed:
   haypo/hachoir/branches/hachoir-yield/field/bits_field.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/field/field.py
   haypo/hachoir/branches/hachoir-yield/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/file/image/png.py
   haypo/hachoir/branches/hachoir-yield/hachoir.py
Log:
 r13 at haypopc:  haypo | 2006-03-01 01:47:35 +0100
  * Create MetaData and ImageMetaData classes
  * Create PngMetaData which read PNG file meta data
  * PNG parser can read the palette
  * Delete now useless Bits field (replaced by Integer and bit address
    granularity)
  * Field constructor check parent type
  * Create error 'ParserError' which should be used in file parser



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:11
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:13

Modified: haypo/hachoir/branches/hachoir-yield/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/__init__.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/field/__init__.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -1,5 +1,4 @@
 from field import Field
-#from bits_field import Bits
 from integer import Integer, IntegerHex, Bits, Bit
 from string_field import String
-from field_set import FieldSet
+from field_set import FieldSet, ParserError

Deleted: haypo/hachoir/branches/hachoir-yield/field/bits_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/bits_field.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/field/bits_field.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -1,74 +0,0 @@
-from bits import sized_long2bin, str2long
-from field import Field
-from cIOString import IOString
-from indexed_dict import IndexedDict
-
-class BitField(Field):
-    def __init__(self, parent, name, size, description=None):
-        assert 0 < size
-        Field.__init__(self, parent, name, None, size, description=description)
-
-    def _getDisplay(self):
-        return sized_long2bin(self.size, self.value)
-    display = property(_getDisplay)
-
-    def _getValue(self):
-        if self._value == None:
-            self._value = self.parent.readBits(self.address, self.size)
-        return self._value
-    value = property(_getValue, Field._setValue)
-
-class BitsSet(object):
-    def __init__(self, source, items=None, do_reverse=False):
-        self._items = IndexedDict()
-        self._size = 0
-        self._source = source
-        if do_reverse:
-            items = reversed(items)
-        for item in items:
-            field = BitField(self, item[1], item[0], item[2])
-            self._items.append(field.name, field)
-            self._size += field.size
-        assert (0 < self._size) and ((self._size % 8) == 0)
-
-    def newFieldAskAddress(self):
-        return self._size
-
-    def readBits(self, address, size):
-        data = self._source.readRawContent()
-        start = address / 8
-        mask = (1 << size) - 1
-        byte_size = (size + (address % 8) + 7) / 8
-        shift = address - start*8
-        data = data[start:start+byte_size]
-        value = str2long(data)
-        value = (value >> shift) & mask
-        if size == 1:
-            return value == 1
-        else:
-            return value
-
-    def _getSize(self):
-        return self._size / 8
-    size = property(_getSize)
-
-    def __iter__(self):
-        return iter(self._items)
-
-class BitsSet(Field):
-    is_field_set = True
-
-    def __init__(self, parent, name, bits, description=None):
-        self.bits = BitsSet(self, bits)
-        Field.__init__(self, parent, name, None, self.bits.size, description=description)
-
-    def __iter__(self):
-        return iter(self.bits)
-
-    def __getitem__(self, name):
-        return self.bits[name]
-
-    def _getDisplay(self):
-        return "<bits>"
-    display = property(_getDisplay)
-

Modified: haypo/hachoir/branches/hachoir-yield/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/field/field.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -2,6 +2,7 @@
     is_field_set = False
     
     def __init__(self, parent, name, value, size=None, address=None, description=None):
+        assert parent == None or issubclass(parent.__class__, Field)
         self.parent = parent
         self._name = name 
         self._value = value

Modified: haypo/hachoir/branches/hachoir-yield/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -5,6 +5,9 @@
 class FieldDoesExist(KeyError):
     pass
 
+class ParserError(Exception):
+    pass
+
 class FieldSet(Field):
     """
     Ordered list of fields. Use operator [] to access fields using their

Added: haypo/hachoir/branches/hachoir-yield/file/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/file/image/__init__.py
===================================================================

Modified: haypo/hachoir/branches/hachoir-yield/file/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -1,5 +1,28 @@
-from field import FieldSet, Integer, String, IntegerHex, Bit, Bits
+from field import FieldSet, Integer, String, IntegerHex, Bit, Bits, ParserError
+from generic.image import RGB
+from bits import str2hex
+from metadata import ImageMetaData
 
+class PngMetaData(ImageMetaData):
+    def __init__(self, png):
+        header = png["/header/content"]
+        color_type = header["color_type"]
+        width, height = header["width"].value, header["height"].value
+        bpp = header["bpp"].value
+        if color_type["palette"].value:
+            nb_colors = png["/palette/content"].nb_colors
+        else:
+            nb_colors = None
+        if color_type["alpha"].value:
+            format = "RGBA"
+        else:
+            format = "RGB"
+#        if header["compression"].value != 0:
+#            compression = "(compressed)"
+#        else:
+#            compression = "No"
+        ImageMetaData.__init__(self, format, width, height, bpp, nb_colors=nb_colors)
+
 class HeaderFlags(FieldSet):
     def createFields(self):
         yield Bit(self, "palette", "Palette used?")
@@ -21,12 +44,26 @@
         chunk.description = "Header: %ux%u pixels and %u bits/pixel" \
             % (self["width"], self["height"], self["bpp"])
 
+class Palette(FieldSet):
+    def __init__(self, parent, name, stream, description=None):
+        size = parent["size"].value
+        if (size % 3) != 0:
+            raise ParserError("Palette have invalid size (%s), should be 3*n." % size)
+        self.nb_colors = size / 3
+        if description == None:
+            description = "Palette: %u colors" % self.nb_colors
+        FieldSet.__init__(self, parent, name, stream, description)
+
+    def createFields(self):
+        for i in range(self.nb_colors):
+            yield RGB(self, "color[]", self.stream)
+
 class Chunk(FieldSet):
     handler = {
 #        "tIME": Time,
 #        "pHYs": Physical,
         "IHDR": Header,
-#        "PLTE": Palette,
+        "PLTE": Palette,
 #        "gAMA": Gamma,
 #        "tEXt": Text
     }
@@ -60,16 +97,18 @@
 #            oldpos = self._stream.tell()
 #            sub = stream.createLimited(size=size)
             cls = self.handler[type]
-            yield cls(self, "data", self.stream)
+            yield cls(self, "content", self.stream)
 #            assert stream.tell() == (oldpos + size) 
         else:
-            yield String(self, "data", "string[%u]" % self["size"].value, "Data")
+            yield String(self, "content", "string[%u]" % self["size"].value, "Data")
         yield IntegerHex(self, "crc32", "uint32", "CRC32")
 
 class PngFile(FieldSet):
     def createFields(self):
         yield String(self, "id", "string[8]", "PNG identifier") 
-        assert self["id"].value == "\x89PNG\r\n\x1A\n"
+        if self["id"].value != "\x89PNG\r\n\x1A\n":
+            raise ParserError("Png parser: file identifier looks wrong (%s instead of %s)" % \
+                (str2hex(self["id"].value), str2hex("\x89PNG\r\n\x1A\n")))
         while True:
             field = Chunk(self, "chunks[]", self.stream)
             yield field

Added: haypo/hachoir/branches/hachoir-yield/generic/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/generic/image.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/generic/image.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/generic/image.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -0,0 +1,27 @@
+from field import FieldSet, Integer
+
+class RGB(FieldSet):
+    color_name = {
+        0x000000: "Black",
+        0xFFFFFF: "White"
+    }
+    
+    def __init__(self, parent, name, stream, description=None):
+        FieldSet.__init__(self, parent, name, stream, description)
+        if self.description == None:
+            self.description = self.getColorName()
+        self._size = 3
+
+    def createFields(self):
+        yield Integer(self, "red", "uint8", "Red")
+        yield Integer(self, "green", "uint8", "Green")
+        yield Integer(self, "blue", "uint8", "Blue")
+
+    def getColorName(self):
+        value = (self["red"].value << 16) + (self["green"].value << 8) + self["blue"].value
+        if value in RGB.color_name:
+            return "RGB color: "+RGB.color_name[value]
+        else:
+            return "RGB color: #%02X%02X%02X" % \
+                (self["red"].value, self["green"].value, self["blue"].value)
+

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -1,14 +1,20 @@
 #!/usr/bin/env python
 
-from file.image.png import PngFile
+from file.image.png import PngFile, PngMetaData
 from stream.file import FileStream
 from text_ui import displayFieldSet
+import sys
 
 def main():
-    filename = "/home/haypo/exemple/png.png"
+    if 2 <= len(sys.argv):
+        filename = sys.argv[1]
+    else:
+        filename = "/home/haypo/exemple/png.png"
     stream = FileStream(open(filename, 'r'), filename)
     png = PngFile(None, "png_file", stream)
-    displayFieldSet(png)
+    print "[Picture %s]" % filename
+    meta = PngMetaData(png) ; print meta
+#    displayFieldSet(png)
 
 if __name__ == "__main__":
     main()

Added: haypo/hachoir/branches/hachoir-yield/metadata.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/metadata.py	2006-02-28 12:52:41 UTC (rev 418)
+++ haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:15:36 UTC (rev 419)
@@ -0,0 +1,24 @@
+class MetaData:
+    pass
+
+class ImageMetaData(MetaData):
+    def __init__(self, format, width, height, bits_per_pixel, **kw):
+        self.format = format
+        self.width = width
+        self.height = height
+        self.bits_per_pixel = bits_per_pixel
+
+        # Optionnals
+        self.nb_colors = kw.get("nb_colors", None)
+        self.compression = kw.get("compression", None)
+
+    def __str__(self):
+        text = "ImageMetaData <format=%s, size=%sx%s, bpp=%s" % \
+            (self.format, self.width, self.height, self.bits_per_pixel)
+        if self.nb_colors != None:
+            text += ", nb_colors=%s" % self.nb_colors
+        if self.compression != None:
+            text += ", compression=%s" % self.compression
+        return text+">"
+    
+



From haypo at berlios.de  Sat Mar  4 01:16:51 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:16:51 +0100
Subject: [Happyboom-svn] r420 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/field branches/hachoir-yield/file/image branches/hachoir-yield/generic
Message-ID: <200603040016.k240GphG029946@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:16:19 +0100 (Sat, 04 Mar 2006)
New Revision: 420

Added:
   haypo/hachoir/branches/hachoir-yield/file/image/pcx.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/file/image/png.py
   haypo/hachoir/branches/hachoir-yield/generic/image.py
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/metadata.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r14 at haypopc:  haypo | 2006-03-01 02:27:01 +0100
  * Add BMP and PCX image parser (with their MetaData class)
  * 'endian' becomes a class member and not more a class instance member,
    so it's not necessary to write a constructor to set endian
  * displayFieldSet() has now max_depth optionnal argument



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:13
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:14

Modified: haypo/hachoir/branches/hachoir-yield/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -15,6 +15,7 @@
     document).
     """
     is_field_set = True
+    endian = "!"
 
     def __init__(self, parent, name, stream, description=None):
         Field.__init__(self, parent, name, self, description=description)
@@ -25,7 +26,6 @@
         self._field_array_count = {}
         self._size = None
         self._total_field_size = 0
-        self.endian = "!"
         if parent != None:
             self.root = parent.root
         else:

Added: haypo/hachoir/branches/hachoir-yield/file/image/pcx.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/pcx.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/file/image/pcx.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -0,0 +1,49 @@
+"""
+PCX picture filter.
+"""
+
+from field import FieldSet, Integer, String
+from generic.image import Palette
+from metadata import ImageMetaData
+
+class PcxMetaData(ImageMetaData):
+    def __init__(self, pcx):
+        width, height = pcx["xmax"].value+1, pcx["ymax"].value+1
+        bpp = pcx["bpp"].value
+        ImageMetaData.__init__(self, width, height, bpp)
+
+class PcxFile(FieldSet):
+    endian = "<"
+    mime_types = "image/x-pcx"
+    compression_name = { 1: "RLE" }
+
+    def createFields(self):
+        yield Integer(self, "id", "uint8", "PCX identifier (10)")
+        if self["id"].value != 10:
+            raise ParserError("PCX parser: wrong identifier (%u instead of 10)" \
+                % self["id"].value)
+        yield Integer(self, "version", "uint8", "PCX version")
+        yield Integer(self, "compression", "uint8", "Compression") # (EnumChunk, , PCX_File.compression_name)
+        yield Integer(self, "bpp", "uint8", "Bits / pixel")
+        yield Integer(self, "xmin", "uint16", "Minimum X")
+        yield Integer(self, "ymin", "uint16", "Minimum Y")
+        yield Integer(self, "xmax", "uint16", "Width minus one") # value + 1
+        yield Integer(self, "ymax", "uint16", "Height minus one") # value + 1
+        yield Integer(self, "horiz_dpi", "uint16", "Horizontal DPI")
+        yield Integer(self, "vert_dpi", "uint16", "Vertical DPI")
+        yield Palette(self, "palette_4bits", 16, "Palette (4 bits)")
+        yield Integer(self, "reserved", "uint8", "Reserved")
+        yield Integer(self, "nb_color_plan", "uint8", "Number of color plans")
+        yield Integer(self, "bytes_per_line", "uint16", "Bytes per line")
+        yield Integer(self, "color_mode", "uint16", "Color mode")
+        yield String(self, "reserved2", "string[58]", "Reserved")
+
+        size = self.stream.getSize() - self.stream.tell()
+        has_palette = (self["bpp"].value == 8)
+        if has_palette:
+            size -= 256*3*8            
+        yield String(self, "data", "string[%u]" % size, "Image data")
+
+        if has_palette:
+            yield Palette(self, "palette_8bits", 256, "Palette (8 bit)")
+

Modified: haypo/hachoir/branches/hachoir-yield/file/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -21,7 +21,8 @@
 #            compression = "(compressed)"
 #        else:
 #            compression = "No"
-        ImageMetaData.__init__(self, format, width, height, bpp, nb_colors=nb_colors)
+        ImageMetaData.__init__(self, width, height, bpp, \
+            nb_colors=nb_colors, format=format)
 
 class HeaderFlags(FieldSet):
     def createFields(self):

Modified: haypo/hachoir/branches/hachoir-yield/generic/image.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/generic/image.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/generic/image.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -6,8 +6,8 @@
         0xFFFFFF: "White"
     }
     
-    def __init__(self, parent, name, stream, description=None):
-        FieldSet.__init__(self, parent, name, stream, description)
+    def __init__(self, parent, name, description=None):
+        FieldSet.__init__(self, parent, name, parent.stream, description)
         if self.description == None:
             self.description = self.getColorName()
         self._size = 3
@@ -25,3 +25,14 @@
             return "RGB color: #%02X%02X%02X" % \
                 (self["red"].value, self["green"].value, self["blue"].value)
 
+class Palette(FieldSet):
+    def __init__(self, parent, name, nb_colors, description=None):
+        self.nb_colors = nb_colors
+        if description == None:
+            description = "Palette of %u RGB colors" % self.nb_colors
+        FieldSet.__init__(self, parent, name, parent.stream, description=description)
+
+    def createFields(self):
+        for i in range(0, self.nb_colors):
+            yield RGB(self, "color[]")
+

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -1,6 +1,8 @@
 #!/usr/bin/env python
 
 from file.image.png import PngFile, PngMetaData
+from file.image.bmp import BmpFile, BmpMetaData
+from file.image.pcx import PcxFile, PcxMetaData
 from stream.file import FileStream
 from text_ui import displayFieldSet
 import sys
@@ -11,10 +13,19 @@
     else:
         filename = "/home/haypo/exemple/png.png"
     stream = FileStream(open(filename, 'r'), filename)
-    png = PngFile(None, "png_file", stream)
-    print "[Picture %s]" % filename
-    meta = PngMetaData(png) ; print meta
-#    displayFieldSet(png)
+    if filename.endswith(".png"):
+        png = PngFile(None, "png_file", stream)
+        print "[Picture %s]" % filename
+        meta = PngMetaData(png) ; print meta
+#        displayFieldSet(png)
+    elif filename.endswith(".pcx"):
+        pcx = PcxFile(None, "pcx_file", stream)
+        displayFieldSet(pcx, 2)
+        meta = PcxMetaData(pcx) ; print meta
+    else:
+        bmp = BmpFile(None, "bmp_file", stream)
+        displayFieldSet(bmp)
+        meta = BmpMetaData(bmp) ; print meta
 
 if __name__ == "__main__":
     main()

Modified: haypo/hachoir/branches/hachoir-yield/metadata.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -2,8 +2,7 @@
     pass
 
 class ImageMetaData(MetaData):
-    def __init__(self, format, width, height, bits_per_pixel, **kw):
-        self.format = format
+    def __init__(self, width, height, bits_per_pixel, **kw):
         self.width = width
         self.height = height
         self.bits_per_pixel = bits_per_pixel
@@ -11,10 +10,14 @@
         # Optionnals
         self.nb_colors = kw.get("nb_colors", None)
         self.compression = kw.get("compression", None)
+        self.format = kw.get("format", None)
 
     def __str__(self):
-        text = "ImageMetaData <format=%s, size=%sx%s, bpp=%s" % \
-            (self.format, self.width, self.height, self.bits_per_pixel)
+        text = "ImageMetaData <"
+        if self.format != None:
+            text += "format=%s, " % self.format 
+        text += "size=%sx%s, bpp=%s" % \
+            (self.width, self.height, self.bits_per_pixel)
         if self.nb_colors != None:
             text += ", nb_colors=%s" % self.nb_colors
         if self.compression != None:

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:15:36 UTC (rev 419)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:16:19 UTC (rev 420)
@@ -1,14 +1,17 @@
-def displayFieldSet(field_set, depth=0):
+def displayFieldSet(field_set, max_depth=None, depth=0):
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     print "%s--- %s --- (addr=%u.%u, size=%s bits)" \
         % (indent, field_set.name, addr/8, addr%8, field_set.size)
-    for field in field_set:
-        if not field.is_field_set:
-            print "%s%u.%u) %s = %s (%s) (size=%s bits)" % \
-                (indent, field.address/8, field.address%8, field._name, field.display, field.description, field.size)
-        else:
-            displayFieldSet(field, depth+1)
+    if max_depth == None or depth < max_depth:
+        for field in field_set:
+            if not field.is_field_set:
+                print "%s%u.%u) %s = %s (%s) (size=%s bits)" % \
+                    (indent, field.address/8, field.address%8, field._name, field.display, field.description, field.size)
+            else:
+                displayFieldSet(field, max_depth, depth+1)
+    else:
+        print "%s(...)" % indent
     if depth == 0:
         print
 



From haypo at berlios.de  Sat Mar  4 01:17:40 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:17:40 +0100
Subject: [Happyboom-svn] r421 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/field
Message-ID: <200603040017.k240HeDr030160@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:17:26 +0100 (Sat, 04 Mar 2006)
New Revision: 421

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r15 at haypopc:  haypo | 2006-03-01 02:43:49 +0100
 FieldSet.__iter__() now use yield too



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:14
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:15

Modified: haypo/hachoir/branches/hachoir-yield/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:16:19 UTC (rev 420)
+++ haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:17:26 UTC (rev 421)
@@ -169,8 +169,14 @@
 
     def __iter__(self):
         if self._field_generator != None:
-            self._feedAll()
-        return iter(self.fields)
+            try:
+                while True:
+                    yield self._feed()
+            except StopIteration:
+                self._stopFeeding()
+        else:
+            for field in self.fields:
+                yield field
 
     def createFields(self):
         raise NotImplementedError

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:16:19 UTC (rev 420)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:17:26 UTC (rev 421)
@@ -16,8 +16,8 @@
     if filename.endswith(".png"):
         png = PngFile(None, "png_file", stream)
         print "[Picture %s]" % filename
+        displayFieldSet(png, 3)
         meta = PngMetaData(png) ; print meta
-#        displayFieldSet(png)
     elif filename.endswith(".pcx"):
         pcx = PcxFile(None, "pcx_file", stream)
         displayFieldSet(pcx, 2)

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:16:19 UTC (rev 420)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:17:26 UTC (rev 421)
@@ -1,4 +1,4 @@
-def displayFieldSet(field_set, max_depth=None, depth=0):
+def displayFieldSet(field_set, max_depth=2, depth=0):
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     print "%s--- %s --- (addr=%u.%u, size=%s bits)" \



From haypo at berlios.de  Sat Mar  4 01:18:30 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:18:30 +0100
Subject: [Happyboom-svn] r423 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/field branches/hachoir-yield/file/system
Message-ID: <200603040018.k240IUju030357@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:18:28 +0100 (Sat, 04 Mar 2006)
New Revision: 423

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/field/integer.py
   haypo/hachoir/branches/hachoir-yield/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/file/system/ext2.py
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r17 at haypopc:  haypo | 2006-03-02 02:28:51 +0100
  * Add assertion to check parent argument in constructor of Integer, String
    and Bits class
  * Continue to convert EXT2/EXT3 parser to new syntax
  * displayFieldSet() can now display values in bits or bytes



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:16
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:17

Modified: haypo/hachoir/branches/hachoir-yield/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/__init__.py	2006-03-04 00:18:07 UTC (rev 422)
+++ haypo/hachoir/branches/hachoir-yield/field/__init__.py	2006-03-04 00:18:28 UTC (rev 423)
@@ -1,4 +1,4 @@
 from field import Field
-from integer import Integer, IntegerHex, Bits, Bit
+from integer import Integer, IntegerHex, Enum, Bits, Bit
 from string_field import String
 from field_set import FieldSet, ParserError

Modified: haypo/hachoir/branches/hachoir-yield/field/integer.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/integer.py	2006-03-04 00:18:07 UTC (rev 422)
+++ haypo/hachoir/branches/hachoir-yield/field/integer.py	2006-03-04 00:18:28 UTC (rev 423)
@@ -4,6 +4,7 @@
 
 class Bits(Field):
     def __init__(self, parent, name, size, description=None):
+        assert issubclass(parent.__class__, Field)
         Field.__init__(self, parent, name, None, size, description=description)
 
     def _getValue(self):
@@ -31,6 +32,7 @@
    
 class Integer(Field):
     def __init__(self, parent, name, format, description=None):
+        assert issubclass(parent.__class__, Field)
         if format[0] not in "!<>":
             self.format = parent.endian + format
         else:

Modified: haypo/hachoir/branches/hachoir-yield/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/string_field.py	2006-03-04 00:18:07 UTC (rev 422)
+++ haypo/hachoir/branches/hachoir-yield/field/string_field.py	2006-03-04 00:18:28 UTC (rev 423)
@@ -4,6 +4,7 @@
 
 class String(Field):
     def __init__(self, parent, name, format, description=None):
+        assert issubclass(parent.__class__, Field)
         self.format = format
         size = getFormatSize(format)*8
         Field.__init__(self, parent, name, None, size, description=description)

Modified: haypo/hachoir/branches/hachoir-yield/file/system/ext2.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/system/ext2.py	2006-03-04 00:18:07 UTC (rev 422)
+++ haypo/hachoir/branches/hachoir-yield/file/system/ext2.py	2006-03-04 00:18:28 UTC (rev 423)
@@ -9,9 +9,20 @@
 """
 
 from text_handler import unixTimestamp
-from field import FieldSet, Integer, String
+from field import FieldSet, Integer, Enum, String, ParserError
 from tools import humanDuration, getUnixRWX, humanFilesize
+from bits import str2hex
 
+class FieldSetWithSeek(FieldSet):
+    def seekField(self, to):
+        size = to - self._total_field_size 
+        assert 0 <= size
+        if 0 < size:
+            assert (size % 8) == 0
+            return String(self, "raw[]", "string[%u]" % (size / 8))
+        else:
+            return None
+
 class DirectoryEntry(FieldSet):
     file_type = {
         1: "Regular",
@@ -24,25 +35,29 @@
         8: "Max"
     }
     endian = "<"
+
+    # TODO: write constructor to set: self._size = self["rec_len"].value * 8 (or something like that)
     
     def createFields(self):
-        yield Integer("inode", "uint32", "Inode")
-        yield Integer("rec_len", "uint16", "Record length")
-        name_length = self.doRead("name_len", "B", "Name length", (FormatChunk, "uint8")).value
-        yield Integer("file_type", "uint8", DirectoryEntry.file_type, "File type")
-        self.read("name", "File name", (FormatChunk, "string[%u]" % name_length))
-        size = self["rec_len"]-8-name_length 
+        yield Integer(self, "inode", "uint32", "Inode")
+        yield Integer(self, "rec_len", "uint16", "Record length")
+        name_length = Integer(self, "name_len", "B", "Name length", (FormatChunk, "uint8")).value
+        yield name_length
+        yield Enum(self, "file_type", "uint8", DirectoryEntry.file_type, "File type")
+        yield String(self, "name", "string[%u]" % name_length, "File name")
+        size = self["rec_len"].value-8-name_length 
         if size != 0:
-            self.read("padding", "Padding", (FormatChunk, "string[%u]" % size))
+            yield String(self, "padding", "string[%u]" % size, "Padding")
 
-    def updateParent(self, chunk):        
-        name = self["name"].strip("\0")
-        if name != "":
-            desc = "Directory entry: %s" % name
-        else:
-            desc = "Directory entry (empty)"
-        chunk.description = desc
-        self.setDescription(desc)
+#  TODO: Re-enable that, maybe using event 'all fields are read'
+#    def updateParent(self, chunk):        
+#        name = self["name"].strip("\0")
+#        if name != "":
+#            desc = "Directory entry: %s" % name
+#        else:
+#            desc = "Directory entry (empty)"
+#        chunk.description = desc
+#        self.setDescription(desc)
 
 class Inode(FieldSet):
     name = {
@@ -80,42 +95,42 @@
             self.description = desc
 
     def createFields(self):
-        self.read("mode", "Mode", (FormatChunk, "uint16"), {"post": self.postMode})
-        yield Integer("uid", "uint16", "User ID")
-        yield Integer("size", "uint32", "File size (in bytes)")
-        yield Integer("atime", "uint32", "Last access time") # {"post": unixTimestamp}
-        yield Integer("ctime", "uint32", "Creation time") # {"post": unixTimestamp}
-        yield Integer("mtime", "uint32", "Last modification time") # {"post": unixTimestamp}
-        yield Integer("dtime", "uint32", "Delete time") #  {"post": unixTimestamp}
-        yield Integer("gid", "uint16", "Group ID")
-        yield Integer("links_count", "uint16", "Links count")
-        yield Integer("blocks", "uint32", "Number of blocks")
-        yield Integer("flags", "uint32", "Flags")
-        yield Integer("reserved1", "uint32", "Reserved")
+        yield Integer(self, "mode", "uint16", "Mode") # {"post": self.postMode}
+        yield Integer(self, "uid", "uint16", "User ID")
+        yield Integer(self, "size", "uint32", "File size (in bytes)")
+        yield Integer(self, "atime", "uint32", "Last access time") # {"post": unixTimestamp}
+        yield Integer(self, "ctime", "uint32", "Creation time") # {"post": unixTimestamp}
+        yield Integer(self, "mtime", "uint32", "Last modification time") # {"post": unixTimestamp}
+        yield Integer(self, "dtime", "uint32", "Delete time") #  {"post": unixTimestamp}
+        yield Integer(self, "gid", "uint16", "Group ID")
+        yield Integer(self, "links_count", "uint16", "Links count")
+        yield Integer(self, "blocks", "uint32", "Number of blocks")
+        yield Integer(self, "flags", "uint32", "Flags")
+        yield Integer(self, "reserved1", "uint32", "Reserved")
         for i in range(0,15):
-            yield Integer("block[]", "uint32", "Block %i" % i)
-        yield Integer("version", "uint32", "Version")
-        yield Integer("file_acl", "uint32", "File ACL")
-        yield Integer("dir_acl", "uint32", "Directory ACL")
-        yield Integer("faddr", "uint32", "Block where the fragment of the file resides")
+            yield Integer(self, "block[]", "uint32", "Block %i" % i)
+        yield Integer(self, "version", "uint32", "Version")
+        yield Integer(self, "file_acl", "uint32", "File ACL")
+        yield Integer(self, "dir_acl", "uint32", "Directory ACL")
+        yield Integer(self, "faddr", "uint32", "Block where the fragment of the file resides")
         
         os = self["/superblock/creator_os"].value
         if os == SuperBlock.OS_LINUX:
-            yield Integer("frag", "uint8", "Number of fragments in the block")
-            yield Integer("fsize", "uint8", "Fragment size")
-            yield Integer("padding", "uint16", "Padding")
-            yield Integer("uid_high", "uint16", "High 16 bits of user ID")
-            yield Integer("gid_high", "uint16", "High 16 bits of group ID")
-            yield Integer("reserved", "uint32", "Reserved")
+            yield Integer(self, "frag", "uint8", "Number of fragments in the block")
+            yield Integer(self, "fsize", "uint8", "Fragment size")
+            yield Integer(self, "padding", "uint16", "Padding")
+            yield Integer(self, "uid_high", "uint16", "High 16 bits of user ID")
+            yield Integer(self, "gid_high", "uint16", "High 16 bits of group ID")
+            yield Integer(self, "reserved", "uint32", "Reserved")
         elif os == SuperBlock.OS_HURD:
-            yield Integer("frag", "uint8", "Number of fragments in the block")
-            yield Integer("fsize", "uint8", "Fragment size")
-            yield Integer("mode_high", "uint16", "High 16 bits of mode")
-            yield Integer("uid_high", "uint16", "High 16 bits of user ID")
-            yield Integer("gid_high", "uint16", "High 16 bits of group ID")
-            yield Integer("author", "uint32", "Author ID (?)")
+            yield Integer(self, "frag", "uint8", "Number of fragments in the block")
+            yield Integer(self, "fsize", "uint8", "Fragment size")
+            yield Integer(self, "mode_high", "uint16", "High 16 bits of mode")
+            yield Integer(self, "uid_high", "uint16", "High 16 bits of user ID")
+            yield Integer(self, "gid_high", "uint16", "High 16 bits of group ID")
+            yield Integer(self, "author", "uint32", "Author ID (?)")
         else:
-            yield String("raw", "string[12]", "Reserved")
+            yield String(self, "raw", "string[12]", "Reserved")
 
     def postMode(self, chunk):
         mode = chunk.value
@@ -146,12 +161,12 @@
             description = "%s: %s items" % (description, count)
         FieldSet.__init__(self, parent, name, stream, description)
         assert (count % 8) == 0
-        self._size = count / 8
+        self._size = count
         self.start = start
         self.count = count
 
     def createFields(self):
-        yield String("block_bitmap", "string[%u]" % self._size, "Bitmap")
+        yield String(self, "block_bitmap", "string[%u]" % self._size, "Bitmap")
 
 #    def showFree(self, type="Block"):
 #        data = self["block_bitmap"]
@@ -184,14 +199,14 @@
         self.description = "Group descriptor: blocks %s-%s" % (start, end)
 
     def createFields(self):
-        yield Integer("block_bitmap", "uint32", "Points to the blocks bitmap block")
-        yield Integer("inode_bitmap", "uint32", "Points to the inodes bitmap block")
-        yield Integer("inode_table", "uint32", "Points to the inodes table first block")
-        yield Integer("free_blocks_count", "uint16", "Number of free blocks")
-        yield Integer("free_inodes_count", "uint16", "Number of free inodes")
-        yield Integer("used_dirs_count", "uint16", "Number of inodes allocated to directories")
-        yield Integer("padding", "uint16", "Padding")
-        yield String("reserved", "string[12]", "Reserved")
+        yield Integer(self, "block_bitmap", "uint32", "Points to the blocks bitmap block")
+        yield Integer(self, "inode_bitmap", "uint32", "Points to the inodes bitmap block")
+        yield Integer(self, "inode_table", "uint32", "Points to the inodes table first block")
+        yield Integer(self, "free_blocks_count", "uint16", "Number of free blocks")
+        yield Integer(self, "free_inodes_count", "uint16", "Number of free inodes")
+        yield Integer(self, "used_dirs_count", "uint16", "Number of inodes allocated to directories")
+        yield Integer(self, "padding", "uint16", "Padding")
+        yield String(self, "reserved", "string[12]", "Reserved")
    
 class SuperBlock(FieldSet):
     error_handling = {
@@ -213,6 +228,7 @@
     }
  
     static_size = 433*8
+    endian = "<"
  
     def __init__(self, parent, name, stream, description="Super block"):
         FieldSet.__init__(self, parent, name, stream, description)
@@ -221,68 +237,74 @@
         else:
             type = "ext2"
         self.description = "Superblock: %s file system" % type
+        self._group_count = None
 
     def createFields(self):
-        yield Integer("inodes_count", "uint32", "Inodes count")
-        yield Integer("blocks_count", "uint32", "Blocks count")
-        yield Integer("r_blocks_count", "uint32", "Reserved blocks count")
-        yield Integer("free_blocks_count", "uint32", "Free blocks count")
-        yield Integer("free_inodes_count", "uint32", "Free inodes count")
-        yield Integer("first_data_block", "uint32", "First data block")
+        yield Integer(self, "inodes_count", "uint32", "Inodes count")
+        yield Integer(self, "blocks_count", "uint32", "Blocks count")
+        yield Integer(self, "r_blocks_count", "uint32", "Reserved blocks count")
+        yield Integer(self, "free_blocks_count", "uint32", "Free blocks count")
+        yield Integer(self, "free_inodes_count", "uint32", "Free inodes count")
+        yield Integer(self, "first_data_block", "uint32", "First data block")
         if self["first_data_block"].value != 0:
             raise ParserError(
                 "Stream doesn't looks like EXT2/EXT3 partition "
                 "(first data block is %s instead of 0)" %
                 self["first_data_block"].value)                
-        yield Integer("log_block_size", "uint32", "Block size")
-        yield Integer("log_frag_size", "uint32", "Fragment size")
-        yield Integer("blocks_per_group", "uint32", "Blocks per group")
-        yield Integer("frags_per_group", "uint32", "Fragments per group")
-        yield Integer("inodes_per_group", "uint32", "Inodes per group")
-        yield Integer("mtime", "uint32", "Mount time") #  {"post": unixTimestamp}
-        yield Integer("wtime", "uint32", "Write time") #  {"post": unixTimestamp}
-        yield Integer("mnt_count", "uint16", "Mount count")
-        yield Integer("max_mnt_count", "int16", "Max mount count")
-        yield String("magic", "string[2]", "Magic number (0x53EF)")
+        yield Integer(self, "log_block_size", "uint32", "Block size")
+        yield Integer(self, "log_frag_size", "uint32", "Fragment size")
+        yield Integer(self, "blocks_per_group", "uint32", "Blocks per group")
+        yield Integer(self, "frags_per_group", "uint32", "Fragments per group")
+        yield Integer(self, "inodes_per_group", "uint32", "Inodes per group")
+        yield Integer(self, "mtime", "uint32", "Mount time") #  {"post": unixTimestamp}
+        yield Integer(self, "wtime", "uint32", "Write time") #  {"post": unixTimestamp}
+        yield Integer(self, "mnt_count", "uint16", "Mount count")
+        yield Integer(self, "max_mnt_count", "int16", "Max mount count")
+        yield String(self, "magic", "string[2]", "Magic number (0x53EF)")
         if self["magic"].value != "\x53\xEF":
             raise ParserError(
                 "Stream doesn't looks like EXT2/EXT3 partition "
-                "(invalid magic value)")
-        yield Integer("state", "uint16", SuperBlock.state, "File system state")
-        yield Enum("errors", "uint16", SuperBlock.error_handling, "Behaviour when detecting errors")
-        yield Integer("minor_rev_level", "uint16", "Minor revision level")
-        yield Integer("last_check", "uint32", "Time of last check") #  {"post": unixTimestamp}
-        yield Integer("check_interval", "uint32", "Maximum time between checks") #  {"post": self.postMaxTime}
-        yield Enum("creator_os", "uint32", SuperBlock.os_name, "Creator OS")        
-        yield Integer("rev_level", "uint32", "Revision level")
-        yield Integer("def_resuid", "uint16", "Default uid for reserved blocks")
-        yield Integer("def_resgid", "uint16", "Default guid for reserverd blocks")
-        yield Integer("first_ino", "uint32", "First non-reserved inode")
-        yield Integer("inode_size", "uint16", "Size of inode structure")
+                "(invalid magic value: %s instead of %s)" %
+                (str2hex(self["magic"].value), str2hex("\x53\xEF")))
+        yield Enum(self, "state", "uint16", SuperBlock.state, "File system state")
+        yield Enum(self, "errors", "uint16", SuperBlock.error_handling, "Behaviour when detecting errors")
+        yield Integer(self, "minor_rev_level", "uint16", "Minor revision level")
+        yield Integer(self, "last_check", "uint32", "Time of last check") #  {"post": unixTimestamp}
+        yield Integer(self, "check_interval", "uint32", "Maximum time between checks") #  {"post": self.postMaxTime}
+        yield Enum(self, "creator_os", "uint32", SuperBlock.os_name, "Creator OS")        
+        yield Integer(self, "rev_level", "uint32", "Revision level")
+        yield Integer(self, "def_resuid", "uint16", "Default uid for reserved blocks")
+        yield Integer(self, "def_resgid", "uint16", "Default guid for reserverd blocks")
+        yield Integer(self, "first_ino", "uint32", "First non-reserved inode")
+        yield Integer(self, "inode_size", "uint16", "Size of inode structure")
         if self["inode_size"].value != (68 + 15*4):
             raise ParserError(
                 "EXT2/EXT3 parser error: inode of size %s are not supported" \
                 % self["inode_size"].value)
-        yield Integer("block_group_nr", "uint16", "Block group # of this superblock")
-        yield Integer("feature_compat", "uint32", "Compatible feature set")
-        yield Integer("feature_incompat", "uint32", "Incompatible feature set")
-        yield Integer("feature_ro_compat", "uint32", "Read-only compatible feature set")
-        yield String("uuid", "string[16]", "128-bit uuid for volume")
-        yield String("volume_name", "string[16]", "Volume name")
-        yield String("last_mounted", "string[64]", "Directory where last mounted")
-        yield Integer("compression", "uint32", "For compression (algorithm usage bitmap)")
-        yield Integer("prealloc_blocks", "uint8", "Number of blocks to try to preallocate")
-        yield Integer("prealloc_dir_blocks", "uint8", "Number to preallocate for directories")
-        yield Integer("padding", "uint16", "Padding")
-        yield String("journal_uuid", "string[16]", "uuid of journal superblock")
-        yield Integer("journal_inum", "uint32", "inode number of journal file")
-        yield Integer("journal_dev", "uint32", "device number of journal file")
-        yield Integer("last_orphan", "uint32", "start of list of inodes to delete")
-        yield String("reserved", "string[197]", "Padding to the end of the block")
+        yield Integer(self, "block_group_nr", "uint16", "Block group # of this superblock")
+        yield Integer(self, "feature_compat", "uint32", "Compatible feature set")
+        yield Integer(self, "feature_incompat", "uint32", "Incompatible feature set")
+        yield Integer(self, "feature_ro_compat", "uint32", "Read-only compatible feature set")
+        yield String(self, "uuid", "string[16]", "128-bit uuid for volume")
+        yield String(self, "volume_name", "string[16]", "Volume name")
+        yield String(self, "last_mounted", "string[64]", "Directory where last mounted")
+        yield Integer(self, "compression", "uint32", "For compression (algorithm usage bitmap)")
+        yield Integer(self, "prealloc_blocks", "uint8", "Number of blocks to try to preallocate")
+        yield Integer(self, "prealloc_dir_blocks", "uint8", "Number to preallocate for directories")
+        yield Integer(self, "padding", "uint16", "Padding")
+        yield String(self, "journal_uuid", "string[16]", "uuid of journal superblock")
+        yield Integer(self, "journal_inum", "uint32", "inode number of journal file")
+        yield Integer(self, "journal_dev", "uint32", "device number of journal file")
+        yield Integer(self, "last_orphan", "uint32", "start of list of inodes to delete")
+        yield String(self, "reserved", "string[197]", "Padding to the end of the block")
 
-        # Calculate number of groups
-        blocks_per_group = self["blocks_per_group"].value
-        self.group_count = (self["blocks_count"].value - self["first_data_block"].value + (blocks_per_group - 1)) / blocks_per_group
+    def _getGroupCount(self):
+        if self._group_count == None:
+            # Calculate number of groups
+            blocks_per_group = self["blocks_per_group"].value
+            self._group_count = (self["blocks_count"].value - self["first_data_block"].value + (blocks_per_group - 1)) / blocks_per_group
+        return self._group_count
+    group_count = property(_getGroupCount)        
  
 #    def postMaxTime(self, chunk):
 #        return humanDuration(chunk.value * 1000)
@@ -309,77 +331,77 @@
         FieldSet.__init__(self, parent, name, stream, description)
         self.start = start
         self.count = count
+        self._size = self.count * self["/superblock/inode_size"].value * 8
 
     def createFields(self):
         for index in range(self.start, self.start+self.count):
             yield Inode(self, "inode[]", index, description="Inode %s" % index)
 
-    def __getitem__(self, index):
+    def getInode(self, index):
         index = index - self.start - 1
         return self.getChunk("inode[%u]" % index).getFilter()
 
 def testSuperblock(stream):
     oldpos = stream.tell()
-    stream.seek(56, 1)
+    stream.seek(56*8, 1)
     magic = stream.getN(2)    
     stream.seek(oldpos)
     return (magic == "\x53\xEF")
 
-class Group(FieldSet):
-    def __init__(self, stream, parent, index, description=None):
+class Group(FieldSetWithSeek):
+    def __init__(self, parent, name, stream, index, description=None):
         if description == None:
             description = "Group %u" % index
-        FieldSet.__init__(self, parent, name, stream, description)
+        FieldSetWithSeek.__init__(self, parent, name, stream, description)
         self.index = index
 
+# TODO: Re-enable that using event (event like "all fields are read)
+#    def updateParent(self, chunk):
+#        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
+#        if "superblock_copy" in self:
+#            desc += " (with superblock copy)"
+#        self.description = desc 
+
     def createFields(self):
-        group = self["../group_desc"].getGroup(index)
+        group = self["../group_desc"].getGroup(self.index)
         superblock = self["/superblock"]
         block_size = self["/"].block_size
     
         # Read block bitmap
         self.superblock_copy = False
-        if testSuperblock(stream):
+        if testSuperblock(self.stream):
             self.superblock_copy = True
             yield SuperBlock(self, "superblock_copy", self.stream, "Superblock")
-        self.seek(group["block_bitmap"] * block_size)
+        field = self.seekField(group["block_bitmap"].value * block_size * 8)
+        if field != None:
+            yield field
             
-        count = superblock["blocks_per_group"]
+        count = superblock["blocks_per_group"].value
         yield BlockBitmap(self, "block_bitmap[]", self.stream, count, 0, "Block bitmap")
 
         # Read inode bitmap
-        assert (group["inode_bitmap"] * block_size) == stream.tell()
-        count = superblock["inodes_per_group"]
-        self.read("inode_bitmap[]", "Inode bitmap", (InodeBitmap, "Inode bitmap", count, 1), {"size": count / 8})
-        addr = stream.tell() % 4096
+        assert (group["inode_bitmap"].value * block_size * 8) == self._total_field_size 
+        count = superblock["inodes_per_group"].value
+        yield InodeBitmap(self, "inode_bitmap[]", self.stream, count, 1, "Inode bitmap")
+        addr = self._total_field_size % 4096
         if addr != 0:
-            addr = stream.tell() + (4096 - addr % 4096)
-            self.seek(addr)
+            addr = self._total_field_size + (4096 - addr % 4096) * 8
+            field = self.seekField(addr)
+            if field != None:
+                yield field
              
-        count = superblock["inodes_per_group"]
-        size = superblock["inode_size"] * count
-        inode_index = 1 + index * count
-        self.read("inode_table[]", "Inode table", (InodeTable, inode_index, count), {"size": size})
+        count = superblock["inodes_per_group"].value
+        inode_index = 1 + self.index * count
+        yield InodeTable(self, "inode_table[]", self.stream, inode_index, count)
 
-        size = (index+1) * superblock["blocks_per_group"] * block_size
-        if stream.getSize() < size:
-            size = stream.getSize()
-        size = size - stream.tell() 
-        self.read("data", "Data", (FormatChunk, "string[%u]" % size))
+        size = (self.index+1) * superblock["blocks_per_group"].value * block_size
+        if self.stream.getSize() < size:
+            size = self.stream.getSize()
+        assert (self._total_field_size % 8) == 0
+        size = size - self._total_field_size / 8
+        yield String(self, "data", "string[%u]" % size, "Data")
 
-    def updateParent(self, chunk):
-        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
-        if self.superblock_copy:
-            desc = desc + " (with superblock copy)"
-        chunk.description = desc 
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 <= size
-        if 0 < size:
-            self.read("raw[]", "Raw", (FormatChunk, "string[%u]" % size))
-
-class EXT2_FS(FieldSet):
+class EXT2_FS(FieldSetWithSeek):
     """
     Parse an EXT2 or EXT3 partition.
 
@@ -393,11 +415,13 @@
     mime_types = "hachoir/fs-ext2"
 
     def __init__(self, parent, name, stream, description="EXT2 file system"):
-        FieldSet.__init__(self, parent, name, stream, description)
+        FieldSetWithSeek.__init__(self, parent, name, stream, description)
 
     def createFields(self):
         # Skip something (what is stored here? MBR?) 
-        self.seek(1024) 
+        field = self.seekField(1024 * 8) 
+        if field != None:
+            yield field
         
         # Read superblock
         superblock = SuperBlock(self, "superblock", self.stream)
@@ -405,27 +429,26 @@
         self.block_size = 1024 << superblock["log_block_size"].value # in bytes
 
         # Read groups' descriptor
-        self.seek(4096) 
+        field = self.seekField(4096 * 8) 
+        if field != None:
+            yield field
         groups = GroupDescriptors(self, "group_desc", self.stream, 0, superblock.group_count)
         yield groups
 
         # Read groups
         address = groups.getGroup(0)["block_bitmap"].value * self.block_size * 8
-        self.seek(address)
+        field = self.seekField(address)
+        if field != None:
+            yield field
         for i in range(0, superblock.group_count):
-            self.read("group[]", "Group", (Group, i))
+            yield Group(self, "group[]", self.stream, i)
 
         # Padding (?)
-        size = stream.getSize() - stream.tell()
-        if size != 0:
-            self.read("end", "End (raw)", (FormatChunk, "string[%u]" % size))
+#        size = self.stream.getSize()*8 - self._total_field_size
+#        if size != 0:
+#            assert (size % 8) == 0
+#            yield String(self, "end", "string[%u]" % size, "End (raw)")
 
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 <= size
-        if 0 < size:
-            yield String(self, "raw[]", "string[%u]" % size, raw)
-
 #    def readDirectory(self, inode):
 #        stream = self.getStream()
 #        block_index = 0

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:18:07 UTC (rev 422)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:18:28 UTC (rev 423)
@@ -35,7 +35,7 @@
     if plugin != None:
         # Create field set and display it
         field_set = plugin(None, "file", stream)
-        displayFieldSet(field_set, None)
+        displayFieldSet(field_set, 1)
 #        meta = PngMetaData(png) ; print meta
 #        meta = PcxMetaData(pcx) ; print meta
 #        meta = BmpMetaData(bmp) ; print meta

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:18:07 UTC (rev 422)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:18:28 UTC (rev 423)
@@ -1,17 +1,35 @@
 def displayFieldSet(field_set, max_depth=2, depth=0):
     parent_details = False
+    display_bits = False
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     text = "%s--- %s ---" % (indent, field_set.name) 
     if parent_details:
-        text += "(addr=%u.%u, size=%s bits)" \
-            % (addr/8, addr%8, field_set.size)
+        if display_bits:
+            text += "(addr=%u.%u, size=%s bits)" \
+                % (addr/8, addr%8, field_set.size)
+        else:
+            assert (addr % 8) == 0
+            assert (field_set.size % 8) == 0
+            text += "(addr=%u, size=%s bytes)" \
+                % (addr/8, field_set.size/8)
     print text
     if max_depth == None or depth < max_depth:
         for field in field_set:
             if not field.is_field_set:
-                print "%s%u.%u) %s = %s (%s) (size=%s bits)" % \
-                    (indent, field.address/8, field.address%8, field._name, field.display, field.description, field.size)
+                text = indent
+                if display_bits:
+                    text += "%u.%u" % (field.address/8, field.address%8)
+                else:
+                    assert (field.address % 8) == 0
+                    text += "%u" % (field.address/8)
+                text += ") %s = %s (%s)" % \
+                    (field._name, field.display, field.description)
+                if display_bits:
+                    text += "(size=%s bits)" % field.size
+                else:
+                    assert (field.size % 8) == 0
+                    text += "(size=%s bytes)" % (field.size / 8)
             else:
                 displayFieldSet(field, max_depth, depth+1)
     else:



From haypo at berlios.de  Sat Mar  4 01:20:02 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:20:02 +0100
Subject: [Happyboom-svn] r424 - in haypo/hachoir: . branches/hachoir-yield/stream
Message-ID: <200603040020.k240K2PJ030627@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:18:56 +0100 (Sat, 04 Mar 2006)
New Revision: 424

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/stream/file.py
Log:
 r18 at haypopc:  haypo | 2006-03-03 00:19:26 +0100
  * Fix in FileStream: size is in bits and not bytes



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:17
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:18

Modified: haypo/hachoir/branches/hachoir-yield/stream/file.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/stream/file.py	2006-03-04 00:18:28 UTC (rev 423)
+++ haypo/hachoir/branches/hachoir-yield/stream/file.py	2006-03-04 00:18:56 UTC (rev 424)
@@ -1,7 +1,6 @@
 import os
 from error import StreamError
 from stream import Stream
-from bits import str2long, str2hex # TODO: <== don't need this anymore!
 #from config import config
 
 class FileStream(Stream):
@@ -19,7 +18,7 @@
             self._cache = copy._cache
         else:
             self._file.seek(0,2) # Seek to end
-            self._size = self._file.tell()
+            self._size = self._file.tell() * 8
             self._file.seek(0,0) # Seel to beginning
             if self._size == 0:
                 raise Exception("Error: file %s is empty!" % filename)
@@ -68,7 +67,6 @@
         return self._seed
 
     def getBits(self, address, nbits, big_endian=False):
-#        print "* Read %s bits at %s.%s" % (nbits, address / 8, address % 8)
         data = self._getRawBits(address, nbits)        
         if (address % 8) != 0 or (nbits % 8) != 0:
             mask = (1 << nbits) - 1
@@ -124,7 +122,6 @@
     
     def _getRawBits(self, address, nbits):
         nbytes = (nbits + (address & 7) + 7) / 8
-#        print " * Read %s bytes (%s bits) at %s.%s" % (nbytes, nbits, address / 8, address % 8)
         self.seek(address / 8)
         return self.getN(nbytes)
         
@@ -141,6 +138,7 @@
         return data
 
     def getSize(self):
+        """ Size of the stream in bits """
         return self._size
 
     def getLastPos(self):



From haypo at berlios.de  Sat Mar  4 01:24:50 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:24:50 +0100
Subject: [Happyboom-svn] r425 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/field
Message-ID: <200603040024.k240OoMR031995@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:24:41 +0100 (Sat, 04 Mar 2006)
New Revision: 425

Added:
   haypo/hachoir/branches/hachoir-yield/doc.txt
   haypo/hachoir/branches/hachoir-yield/test_doc.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/field/field.py
   haypo/hachoir/branches/hachoir-yield/field/field_set.py
Log:
 r19 at haypopc:  haypo | 2006-03-03 00:20:49 +0100
 Begin to write user documentation using (in french) "la documentation agile",
 a method which learn me Tarek Ziad?\195?\169 with it's great book ;-)



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:18
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:19

Added: haypo/hachoir/branches/hachoir-yield/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:18:56 UTC (rev 424)
+++ haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:24:41 UTC (rev 425)
@@ -0,0 +1,142 @@
+Introduction
+------------
+
+Hachoir is a library written in Python to access binary streams using
+nice API. It aims to be easy to use (hide complex mechanisms) and only read
+or compute data when it's really needed.
+
+Examples of Hachoir use: extract some informations from a file (size of an
+image, author of a music, comment of an archive, etc.), edit some fields of
+a file, convert a format to another one.
+
+Write your own format FieldSet class
+====================================
+
+Input stream
+------------
+
+For different reasons (eg. addresses with bit granularity), Hachoir uses it's
+own stream classes. The most interesting class is FileStream. It's constructor
+need a file and a filename (optionnal, can be None).
+
+Here is a small example to create a stream:
+
+>>> from stream.file import FileStream
+>>> from StringIO import StringIO
+>>> stream = FileStream(StringIO("\x03abc"), None)
+
+StringIO is a class which works like a file object but using a string as input
+data. Most interesting methods are:
+
+>>> stream.getSize()       # get size in bits
+32
+>>> stream.getBits(0, 8)   # get 8 bits at address 0
+3
+>>> stream.getBytes(8, 3)  # get 3 bytes at address 8
+'abc'
+
+Support your own format using FieldSet
+--------------------------------------
+
+In the Hachoir, everything is stored in a field. The parent of all classes is
+the class Field, but it can't be used directly. They are four different types
+of fields:
+ * Bits: number with a size in bits ;
+ * Integer: number with a size in bytes ;
+ * String: string of characters with a size in bytes ;
+ * FieldSet: a ordered list of fields (contains other fields).
+
+A stream is splitted in several fields which are organised in a tree. So all
+fields have a parent, except of the root. Small example which will be used to
+parse the string "\x03abc" (stream of previous paragraph):
+
+>>> from field import FieldSet, Integer, String
+>>> class MyFormat(FieldSet):
+...     def createFields(self):
+...             yield Integer(self, "length", "uint8", "String length")
+...             yield String(self, "text", "string[%u]" % self["length"].value)
+...
+
+One goal in Hachoir is to make the write of a parser the more easy that it
+could be. You just have to write one method, createFields, which will create
+all fields.
+
+Another goal is to create the less fields as possible. In most cases, no field
+is created when a field set in instanciated. Fields are created when you access
+them by their name. That's why, the special Python keyword ''yield'' is used
+which permit to create only fields "on demand" (get more details about
+FieldSet internals in later section).
+
+Prototype of field classes are almost different, but the two first parameters
+are always the same:
+ * First one is the parent, of type FieldSet (is None for the root) ;
+ * The second is the name of the field.
+
+Ok, let's play with our new field set:
+
+>>> format = MyFormat(None, "myformat", stream)
+>>> format.size               # get size in bits
+32
+>>> format["text"].value
+'abc'
+>>> "length" in format        # test if the field 'length' does exist
+True
+>>> # Easiest way to display a field set content
+>>> for field in format:
+...     print "%s=%s" % (field.name, field.display)
+...
+length=3
+text="abc"
+
+Details about Field class
+-------------------------
+
+A field contains a lot of informations, attributes are:
+ * name: Field name, unique in his parent field set and can't be changed. It
+   is used as key to access to the field from the field set ;
+ * size: Size in bits, can't be changed ;
+ * address: Address in bits, relative to parent address, can't be changed ;
+ * absolute_address: Address in bits from the beginning of the stream ;
+ * parent: Parent of the field (is None for root field set) ;
+ * root: Root of all field sets ;
+ * value: Formatted value (integer, string, boolean, ...) value of the field.
+   Don't use this argument with print function, better use display attribute ;
+ * display: A string representing field value, has limited size ;
+ * path: Full "path" of the field from the root (eg. "/png/header/content") ;
+ * is_field_set: If the value is True, the field contains other fields, it's
+   a field set.
+
+Example:
+>>> field = format["text"]
+>>> field.name
+'text'
+>>> field.path
+'/myformat/text'
+>>> field.value
+'abc'
+>>> field.size
+24
+>>> field.address
+8
+
+Documentation: TODO
+===================
+
+Internals of a FieldSet
+-----------------------
+
+... static_size ... endian ...
+
+... create of the fields: get len, get size, iterator, contains, ...
+
+Explore a field set using it's path
+-----------------------------------
+
+... path ... image["/header/width"] ...
+
+... root, parent ...
+
+Event handling
+--------------
+
+... connect(event, handler) .... raiseEvent(event,  arg1, arg2, ...) ...

Modified: haypo/hachoir/branches/hachoir-yield/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field.py	2006-03-04 00:18:56 UTC (rev 424)
+++ haypo/hachoir/branches/hachoir-yield/field/field.py	2006-03-04 00:24:41 UTC (rev 425)
@@ -21,7 +21,7 @@
         return stream.getN(self.size)
 
     def __str__(self):
-        return str(self.display)
+        return self.display
 
     def _getValue(self):
         return self._value

Modified: haypo/hachoir/branches/hachoir-yield/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:18:56 UTC (rev 424)
+++ haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:24:41 UTC (rev 425)
@@ -78,16 +78,16 @@
         return "(...)" 
     display = property(_getDisplay)
 
-    def raiseEvent(self, event_name, *args):
-        if self._event_handler == None:
-            return
-        self._event_handler.raiseEvent(event_name, *args)
-
     def connect(self, event_name, handler):
         if self._event_handler == None:
             self._event_handler = EventHandler()
         self._event_handler.connect(event_name, handler)
 
+    def raiseEvent(self, event_name, *args):
+        if self._event_handler == None:
+            return
+        self._event_handler.raiseEvent(event_name, *args)
+
     def __len__(self):
         if self._field_generator != None:
             self._feedAll()
@@ -153,7 +153,6 @@
             field = field[name]
         return field
 
-    
     def __getitem__(self, name):
         """
         Get an item with it's name or it's path.

Added: haypo/hachoir/branches/hachoir-yield/test_doc.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:18:56 UTC (rev 424)
+++ haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:24:41 UTC (rev 425)
@@ -0,0 +1,6 @@
+import doctest
+filename = 'mydoc.txt'
+print "Run test in %s" % filename
+doctest.testfile(filename, optionflags=doctest.ELLIPSIS)
+print "End of all tests of %s" % filename
+



From haypo at berlios.de  Sat Mar  4 01:25:38 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:25:38 +0100
Subject: [Happyboom-svn] r426 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/field
Message-ID: <200603040025.k240PcNH032347@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:25:12 +0100 (Sat, 04 Mar 2006)
New Revision: 426

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/doc.txt
   haypo/hachoir/branches/hachoir-yield/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/test_doc.py
Log:
 r20 at haypopc:  haypo | 2006-03-03 01:11:17 +0100
  * Rename exception FieldDoesExist to MissingField
  * Improve String field class: store it's value when it's read by _getDisplay
    (but only if full value is read, not truncated)
  * Write new sections in documentation



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:19
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:20

Modified: haypo/hachoir/branches/hachoir-yield/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:24:41 UTC (rev 425)
+++ haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:25:12 UTC (rev 426)
@@ -119,24 +119,137 @@
 >>> field.address
 8
 
-Documentation: TODO
-===================
+Some Hachoir internals
+======================
 
-Internals of a FieldSet
------------------------
+When a field is really created?
+-------------------------------
 
-... static_size ... endian ...
+A field is created when someone ask to access it, or when another field is
+asked and the field is before it. So if you use a field in your field set
+constructor, one or more fields will be created.
 
-... create of the fields: get len, get size, iterator, contains, ...
+Example:
+>>> from field import FieldSet, Integer, String
+>>> class Point(FieldSet):
+...     def __init__(self, parent, name, stream, description="Point"):
+...         FieldSet.__init__(self, parent, name, stream, description)
+...         if self["color"].value == -1:
+...             self.description += " (no color)"
+...
+...     def createFields(self):
+...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
+...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
+...         yield Integer(self, "x", "int8", "X axis value")
+...         yield Integer(self, "y", "int8", "Y axis value")
+...         if self["use_3d"] == 1:
+...             yield Integer(self, "z", "int8", "Z axis value")
+...
 
+In the constructor, the field "color" is asked. So the field list will
+contains one field (color):
+>>> stream = FileStream(StringIO("\x2A\x00\x04\x05"), None)
+>>> p = Point(None, "point", stream)
+>>> len(p.fields)
+1
+
+WARNING: Only access 'fields' attribute if you know what you are doing.
+
+If you access another field, the field list will grow up until the requested
+field is reached:
+>>> x = p["x"].value
+>>> len(p.fields)
+3
+
+Some field set methods which create new fields:
+ * __getitem__(): feed field list until requested field is reached
+   (or raise MissingField exception) ;
+ * __len__(): create all fields ;
+ * __iter__(): begin to iterate in existing fields, and the iterate in new
+   fields until all fields are created ;
+ * __contains__(): feed field list until requested field is reached, may
+   create all fields if the field is missing.
+
+The size attribute also interact with field list creation, but it's mechanism
+is little bit more complex. By default, the whole field list have to be built
+before size value can be read. But you can specify field list size:
+ * if field list is fixed, use class attribute static_size ;
+ * else you can set _size instance attribute in the constructor.
+
+Two examples:
+>>> class FourBytes(FieldSet):
+...     static_size = 32
+...     def createFields(self):
+...         yield Integer(self, "four", "uint32")
+...
+>>> class DynamicSize(FieldSet):
+...     def __init__(self, parent, name, stream, nb_items, description="Point"):
+...         FieldSet.__init__(self, parent, name, stream, description)
+...         self.nb_items = nb_items
+...         self._size = nb_items * 32   # 32 is the size of one item
+...
+...     def createFields(self):
+...         for index in range(self.nb_items):
+...             yield Integer(self, "item[]", "uint32")
+...
+
+When the value of a field is read?
+----------------------------------
+
+When a field is created, the value of the field doesn't exist (equals to
+None). The value is really read when you read the field value using '.value'
+or '.display' field attributes. The value is then stored in the field.
+
+Details about field name
+------------------------
+
+The name of a field have to be unique in a field set because it is used as
+key in the field list. The argument 'name' of the Field constructor can be
+changed in the the constructor, but should not (and can no) be changed after
+that.
+
+For arrays, you can use the 'magic' prefix ? [] ? (eg. "item[]") which will
+be replaced by ? [index] ? where the number index is a counter starting a
+zero.
+
+Endian
+------
+
+The "endian" is the way in which ''bytes'' are stored. There are two important
+orders:
+ * ? Big endian ? in which _big_ numbers are written first (Intel x86 CPU)
+ * ? Little endian ? in which _little_ numbers are written first (PowerPC CPU)
+
+The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
+little endian.
+
+The endian is global to a FieldSet and is a class attribute. Two allowed
+values are "<" (little endian) and ">" (big endian). Default value is the
+international network order: "<", big endian.
+
+Example to set endian:
+>>> class UseLittleEndian(FieldSet):
+...     endian = ">"
+...     # (...)
+...
+
 Explore a field set using it's path
 -----------------------------------
 
-... path ... image["/header/width"] ...
+Fields are stored in a tree. To explore the tree you have differents tools:
+ * attribute root of a field which go to tree root ;
+ * attribute parent go to field parent (is None for tree root) ;
+ * and you can specify a path in __getitem__() argument.
 
-... root, parent ...
+There are differents valid syntax of a path:
+ * path to a child of current node: field["content"] ;
+ * path to a child of the parent: field["../brother"] ;
+ * path from the root: field["/header/key"].
 
 Event handling
 --------------
 
-... connect(event, handler) .... raiseEvent(event,  arg1, arg2, ...) ...
+Code is not finished yet, so don't need documentation :-) See:
+ * FieldSet.connect(event, handler)
+ * FieldSet.raiseEvent(event,  arg1, arg2, ...)
+

Modified: haypo/hachoir/branches/hachoir-yield/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:24:41 UTC (rev 425)
+++ haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:25:12 UTC (rev 426)
@@ -3,7 +3,7 @@
 from indexed_dict import IndexedDict
 import config
 
-class FieldDoesExist(KeyError):
+class MissingField(KeyError):
     pass
 
 class ParserError(Exception):
@@ -137,7 +137,7 @@
             names = names[1:]
         elif names[0] == '..':
             if self.parent == None:
-                raise FieldDoesExist("Field '%s' has no parent (can't get field %s)!" \
+                raise MissingField("Field '%s' has no parent (can't get field %s)!" \
                     % (path, self.path))
             field = self.parent
             names = names[1:]
@@ -148,7 +148,7 @@
             del names[-1]
         for name in names:
             if name=="" or not field.is_field_set:
-                raise FieldDoesExist("Field '%s' doesn't exist in %s" \
+                raise MissingField("Field '%s' doesn't exist in %s" \
                     % (path, self.path))
             field = field[name]
         return field
@@ -172,7 +172,7 @@
             field = self._feedUntil(name)
             if field != None:
                 return field
-        raise FieldDoesExist("Field '%s' doesn't exist in %s" \
+        raise MissingField("Field '%s' doesn't exist in %s" \
             % (name, self.path))
 
     def __contains__(self, name):
@@ -180,7 +180,7 @@
             try:
                 field = self.getChunkByPath(name)
                 return True
-            except FieldDoesExist:
+            except MissingField:
                 return False
         else:
             if self._field_generator != None:

Modified: haypo/hachoir/branches/hachoir-yield/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/string_field.py	2006-03-04 00:24:41 UTC (rev 425)
+++ haypo/hachoir/branches/hachoir-yield/field/string_field.py	2006-03-04 00:25:12 UTC (rev 426)
@@ -10,19 +10,21 @@
         Field.__init__(self, parent, name, None, size, description=description)
         
     def _getDisplay(self):
-        max = 20*8
+        max = 20
         if self._value == None:
             assert (self.size % 8) == 0
-            if max < self._size:
+            if max < self._size/8:
                 display = self.parent.stream.getBytes( \
-                    self.absolute_address, max / 8)
+                    self.absolute_address, max)
+                display += "(...)"
             else:
-                display = self.parent.stream.getBytes( \
+                self._value = self.parent.stream.getBytes( \
                     self.absolute_address, self._size / 8)
+                display = self._value
         else:
             display = self._value[:max]
-        if max < self._size:
-            display += "(...)"
+            if max < self._size/8:
+                display += "(...)"
         return convertDataToPrintableString(display)
     display = property(_getDisplay)        
     

Modified: haypo/hachoir/branches/hachoir-yield/test_doc.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:24:41 UTC (rev 425)
+++ haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:25:12 UTC (rev 426)
@@ -1,5 +1,5 @@
 import doctest
-filename = 'mydoc.txt'
+filename = 'doc.txt'
 print "Run test in %s" % filename
 doctest.testfile(filename, optionflags=doctest.ELLIPSIS)
 print "End of all tests of %s" % filename



From haypo at berlios.de  Sat Mar  4 01:26:07 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:26:07 +0100
Subject: [Happyboom-svn] r427 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/file/image
Message-ID: <200603040026.k240Q7gH032616@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:25:53 +0100 (Sat, 04 Mar 2006)
New Revision: 427

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/doc.txt
   haypo/hachoir/branches/hachoir-yield/file/image/bmp.py
   haypo/hachoir/branches/hachoir-yield/file/image/pcx.py
   haypo/hachoir/branches/hachoir-yield/file/image/png.py
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/metadata.py
Log:
 r21 at haypopc:  haypo | 2006-03-03 01:25:02 +0100
  * Move all metadata things to metadata.py file
  * Write a function to create meta datas from a FieldSet instance (choose
    right class by the instance class)



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:20
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:21

Modified: haypo/hachoir/branches/hachoir-yield/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:25:12 UTC (rev 426)
+++ haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:25:53 UTC (rev 427)
@@ -1,5 +1,5 @@
 Introduction
-------------
+============
 
 Hachoir is a library written in Python to access binary streams using
 nice API. It aims to be easy to use (hide complex mechanisms) and only read
@@ -106,7 +106,7 @@
  * is_field_set: If the value is True, the field contains other fields, it's
    a field set.
 
-Example:
+Examples:
 >>> field = format["text"]
 >>> field.name
 'text'
@@ -253,3 +253,9 @@
  * FieldSet.connect(event, handler)
  * FieldSet.raiseEvent(event,  arg1, arg2, ...)
 
+Get more informations
+=====================
+
+Hachoir website:
+   http://www.haypocalc.com/wiki/Hachoir
+

Modified: haypo/hachoir/branches/hachoir-yield/file/image/bmp.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/bmp.py	2006-03-04 00:25:12 UTC (rev 426)
+++ haypo/hachoir/branches/hachoir-yield/file/image/bmp.py	2006-03-04 00:25:53 UTC (rev 427)
@@ -7,22 +7,7 @@
 """
 
 from field import FieldSet, Integer, String, ParserError
-from metadata import ImageMetaData
 
-class BmpMetaData(ImageMetaData):
-    def __init__(self, bmp):
-        width, height = bmp["width"].value, bmp["height"].value
-        bpp = bmp["bpp"].value
-        if "used_colors" in bmp:
-            nb_colors = bmp["used_colors"].value 
-        else:
-            nb_colors = None
-        if bmp["compression"].value != 0:
-            compression = "(compressed)"
-        else:
-            compression = "No"
-        ImageMetaData.__init__(self, width, height, bpp, nb_colors=nb_colors)
-
 class BmpFile(FieldSet):
     mime_types = ["image/x-ms-bmp", "image/x-bmp"]
     endian = "<"

Modified: haypo/hachoir/branches/hachoir-yield/file/image/pcx.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/pcx.py	2006-03-04 00:25:12 UTC (rev 426)
+++ haypo/hachoir/branches/hachoir-yield/file/image/pcx.py	2006-03-04 00:25:53 UTC (rev 427)
@@ -4,14 +4,7 @@
 
 from field import FieldSet, Integer, String
 from generic.image import Palette
-from metadata import ImageMetaData
 
-class PcxMetaData(ImageMetaData):
-    def __init__(self, pcx):
-        width, height = pcx["xmax"].value+1, pcx["ymax"].value+1
-        bpp = pcx["bpp"].value
-        ImageMetaData.__init__(self, width, height, bpp)
-
 class PcxFile(FieldSet):
     endian = "<"
     mime_types = "image/x-pcx"

Modified: haypo/hachoir/branches/hachoir-yield/file/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:25:12 UTC (rev 426)
+++ haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:25:53 UTC (rev 427)
@@ -1,29 +1,7 @@
 from field import FieldSet, Integer, String, IntegerHex, Bit, Bits, ParserError
 from generic.image import RGB
 from bits import str2hex
-from metadata import ImageMetaData
 
-class PngMetaData(ImageMetaData):
-    def __init__(self, png):
-        header = png["/header/content"]
-        color_type = header["color_type"]
-        width, height = header["width"].value, header["height"].value
-        bpp = header["bpp"].value
-        if color_type["palette"].value:
-            nb_colors = png["/palette/content"].nb_colors
-        else:
-            nb_colors = None
-        if color_type["alpha"].value:
-            format = "RGBA"
-        else:
-            format = "RGB"
-#        if header["compression"].value != 0:
-#            compression = "(compressed)"
-#        else:
-#            compression = "No"
-        ImageMetaData.__init__(self, width, height, bpp, \
-            nb_colors=nb_colors, format=format)
-
 class HeaderFlags(FieldSet):
     def createFields(self):
         yield Bit(self, "palette", "Palette used?")

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:25:12 UTC (rev 426)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:25:53 UTC (rev 427)
@@ -8,6 +8,7 @@
 from log import log
 from error import error
 from mime import getStreamMime
+from metadata import createMetaData
 import sys, os
 
 def usage():
@@ -32,18 +33,25 @@
 
     # Look for right plugin
     plugin = guessPlugin(stream, filename, None)
-    if plugin != None:
-        # Create field set and display it
-        field_set = plugin(None, "file", stream)
-        displayFieldSet(field_set, 1)
-#        meta = PngMetaData(png) ; print meta
-#        meta = PcxMetaData(pcx) ; print meta
-#        meta = BmpMetaData(bmp) ; print meta
-    else:
+    if plugin == None:
         msg  = "Sorry, can't find plugin for file \"%s\"!" % filename
         mimes = [ mime[0] for mime in getStreamMime(stream, filename) ]
         msg += "\n\nFile mimes: %s" % ", ".join(mimes)
         error(msg)
+        sys.exit(1)
 
+    # Create field set and display it
+    field_set = plugin(None, "file", stream)
+
+    # Display the field set 
+#    displayFieldSet(field_set, 1)
+
+    # Metadata
+    metadata = createMetaData(field_set)
+    if metadata != None:
+        print metadata
+    else:
+        warning("Can't create meta datas")
+
 if __name__ == "__main__":
     main()

Modified: haypo/hachoir/branches/hachoir-yield/metadata.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:25:12 UTC (rev 426)
+++ haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:25:53 UTC (rev 427)
@@ -1,5 +1,10 @@
+from file.image.png import PngFile
+from file.image.pcx import PcxFile
+from file.image.bmp import BmpFile
+
 class MetaData:
-    pass
+    def __str__(self):
+        raise NotImplementedError()
 
 class ImageMetaData(MetaData):
     def __init__(self, width, height, bits_per_pixel, **kw):
@@ -13,7 +18,7 @@
         self.format = kw.get("format", None)
 
     def __str__(self):
-        text = "ImageMetaData <"
+        text = "Image: "
         if self.format != None:
             text += "format=%s, " % self.format 
         text += "size=%sx%s, bpp=%s" % \
@@ -22,6 +27,62 @@
             text += ", nb_colors=%s" % self.nb_colors
         if self.compression != None:
             text += ", compression=%s" % self.compression
-        return text+">"
-    
+        return text
 
+class BmpMetaData(ImageMetaData):
+    def __init__(self, bmp):
+        width, height = bmp["width"].value, bmp["height"].value
+        bpp = bmp["bpp"].value
+        if "used_colors" in bmp:
+            nb_colors = bmp["used_colors"].value 
+        else:
+            nb_colors = None
+        if bmp["compression"].value != 0:
+            compression = "(compressed)"
+        else:
+            compression = "No"
+        ImageMetaData.__init__(self, width, height, bpp, nb_colors=nb_colors)
+
+class PcxMetaData(ImageMetaData):
+    def __init__(self, pcx):
+        width, height = pcx["xmax"].value+1, pcx["ymax"].value+1
+        bpp = pcx["bpp"].value
+        ImageMetaData.__init__(self, width, height, bpp)
+
+class PngMetaData(ImageMetaData):
+    def __init__(self, png):
+        header = png["/header/content"]
+        color_type = header["color_type"]
+        width, height = header["width"].value, header["height"].value
+        bpp = header["bpp"].value
+        if color_type["palette"].value:
+            nb_colors = png["/palette/content"].nb_colors
+        else:
+            nb_colors = None
+        if color_type["alpha"].value:
+            format = "RGBA"
+        else:
+            format = "RGB"
+#        if header["compression"].value != 0:
+#            compression = "(compressed)"
+#        else:
+#            compression = "No"
+        ImageMetaData.__init__(self, width, height, bpp, \
+            nb_colors=nb_colors, format=format)
+
+_metadata_class = {
+    PngFile: PngMetaData,
+    PcxFile: PcxMetaData,
+    BmpFile: BmpMetaData
+}    
+
+def createMetaData(field_set):
+    """
+    Create a MetaData class from a FieldSet instance.
+    Returns None if we don't know about this format
+    """
+    cls = field_set.__class__
+    if cls not in _metadata_class:
+        return None
+    return _metadata_class[cls] (field_set)
+



From haypo at berlios.de  Sat Mar  4 01:26:20 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:26:20 +0100
Subject: [Happyboom-svn] r428 - in haypo/hachoir: . branches/hachoir-yield
Message-ID: <200603040026.k240QKgk032723@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:26:16 +0100 (Sat, 04 Mar 2006)
New Revision: 428

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/metadata.py
Log:
 r22 at haypopc:  haypo | 2006-03-03 19:11:31 +0100
 Small code cleanup



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:21
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:22

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:25:53 UTC (rev 427)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:26:16 UTC (rev 428)
@@ -17,8 +17,6 @@
     print "Usage: %s filename" % sys.argv[0]
 
 def main():
-    root_dir = os.path.dirname(__file__)
-
     # Create input stream (read filename from command line first argument)
     if len(sys.argv) < 2:
         usage()
@@ -26,7 +24,8 @@
     filename = sys.argv[1]
     stream = FileStream(open(filename, 'r'), filename)
 
-    # Load plugings
+    # Load all plugings from 'file' directory
+    root_dir = os.path.dirname(__file__)
     modules = loadPlugins(os.path.join(root_dir, "file"))
     modules.sort()
     log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
@@ -55,3 +54,4 @@
 
 if __name__ == "__main__":
     main()
+

Modified: haypo/hachoir/branches/hachoir-yield/metadata.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:25:53 UTC (rev 427)
+++ haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:26:16 UTC (rev 428)
@@ -63,10 +63,6 @@
             format = "RGBA"
         else:
             format = "RGB"
-#        if header["compression"].value != 0:
-#            compression = "(compressed)"
-#        else:
-#            compression = "No"
         ImageMetaData.__init__(self, width, height, bpp, \
             nb_colors=nb_colors, format=format)
 



From haypo at berlios.de  Sat Mar  4 01:27:09 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:27:09 +0100
Subject: [Happyboom-svn] r430 - in haypo/hachoir: . branches/hachoir-yield/libhachoir/stream
Message-ID: <200603040027.k240R9tC000223@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:26:57 +0100 (Sat, 04 Mar 2006)
New Revision: 430

Removed:
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py
Log:
 r24 at haypopc:  haypo | 2006-03-03 19:59:01 +0100
 Rename FileStream to Stream



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:23
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:24

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py	2006-03-04 00:26:40 UTC (rev 429)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py	2006-03-04 00:26:57 UTC (rev 430)
@@ -1 +1 @@
-from stream import Stream
+from stream import Stream, StreamError

Deleted: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py	2006-03-04 00:26:40 UTC (rev 429)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py	2006-03-04 00:26:57 UTC (rev 430)
@@ -1,3 +0,0 @@
-class StreamError(Exception):
-    def __init__(self, msg):
-        Exception.__init__(self, msg)

Deleted: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py	2006-03-04 00:26:40 UTC (rev 429)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py	2006-03-04 00:26:57 UTC (rev 430)
@@ -1,89 +0,0 @@
-import os
-from error import StreamError
-from stream import Stream
-#from config import config
-
-def getFileSize(stream):
-    """ Get file size in bits """
-    oldpos = stream.tell()
-    stream.seek(0,2)
-    size = stream.tell() * 8
-    stream.seek(oldpos)
-    return size
-
-class FileStream(Stream):
-    def __init__(self, file, size, filename=None, copy=None):
-        Stream.__init__(self, filename)
-        self._file = file 
-        if copy != None:
-            self._size = copy._size
-        else:
-            self._size = size
-            self._file.seek(0)
-            if self._size == 0:
-                raise Exception("Error: file %s is empty!" % filename)
-        
-    def _getSize(self):
-        """ Size of the stream in bits """
-        return self._size
-    size = property(_getSize)
-
-    def getBits(self, address, nbits, big_endian=False):
-        data = self._getRawBits(address, nbits)        
-        if (address % 8) != 0 or (nbits % 8) != 0:
-            mask = (1 << nbits) - 1
-            shift = address & 7 
-        else:
-            shift = 0
-            mask = None
-        value = 0
-        if not big_endian:
-            if shift != 0:
-                byte = ord(data[0])
-                value += (byte >> shift)
-                data = data[1:]
-                shift = nbits-shift
-            else:
-                shift = nbits-8
-                if shift < 0:
-                    shift += 8
-            for character in data:
-                byte = ord(character)
-                value += (byte << shift) 
-                shift -= 8
-        else:
-            if shift != 0:
-                byte = ord(data[0])
-                value += (byte >> shift)
-                data = data[1:]
-            for character in data:
-                byte = ord(character)
-                value += (byte << shift) 
-                shift += 8
-        if mask != None:
-            value = value & mask
-        return value
-
-    def getBytes(self, address, nbytes):
-        if address % 8 != 0:
-            data = self._getRawBits(address, nbytes*8)
-            nbits = address % 8
-            shift1 = nbits
-            shift2 = 8 - nbits
-            mask = (1 << nbits) - 1
-            newdata = ""
-            for i in range(0, len(data)-1):
-                byte1 = ord(data[i])
-                byte2 = ord(data[i+1])
-                new = chr((byte1 >> shift1) + ((byte2 & mask) << shift2))
-                newdata += new 
-            data = newdata
-        else:
-            data = self._getRawBits(address, nbytes*8)
-        return data
-    
-    def _getRawBits(self, address, nbits):
-        nbytes = (nbits + (address & 7) + 7) / 8
-        self.seek(address / 8)
-        return self.getN(nbytes)
-

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py	2006-03-04 00:26:40 UTC (rev 429)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py	2006-03-04 00:26:57 UTC (rev 430)
@@ -1 +1,86 @@
+def getFileSize(stream):
+    """ Get file size in bits """
+    oldpos = stream.tell()
+    stream.seek(0,2)
+    size = stream.tell() * 8
+    stream.seek(oldpos)
+    return size
 
+class StreamError(Exception):
+    pass
+
+class Stream:
+    def __init__(self, input, size, filename=None, copy=None):
+        Stream.__init__(self, filename)
+        self._input = input 
+        self.filename = filename
+        if copy == None:
+            if self._size == 0:
+                raise StreamError("Error: input size is nul (filename='%s')!" % filename)
+            self._size = size
+        else:
+            self._size = copy._size
+        
+    def _getSize(self):
+        return self._size
+    size = property(_getSize, doc="Size of the stream in bits")
+
+    def getBits(self, address, nbits, big_endian=False):
+        data = self._getRawBits(address, nbits)        
+        if (address % 8) != 0 or (nbits % 8) != 0:
+            mask = (1 << nbits) - 1
+            shift = address & 7 
+        else:
+            shift = 0
+            mask = None
+        value = 0
+        if not big_endian:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+                shift = nbits-shift
+            else:
+                shift = nbits-8
+                if shift < 0:
+                    shift += 8
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift -= 8
+        else:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift += 8
+        if mask != None:
+            value = value & mask
+        return value
+
+    def getBytes(self, address, nbytes):
+        if address % 8 != 0:
+            data = self._getRawBits(address, nbytes*8)
+            nbits = address % 8
+            shift1 = nbits
+            shift2 = 8 - nbits
+            mask = (1 << nbits) - 1
+            newdata = ""
+            for i in range(0, len(data)-1):
+                byte1 = ord(data[i])
+                byte2 = ord(data[i+1])
+                new = chr((byte1 >> shift1) + ((byte2 & mask) << shift2))
+                newdata += new 
+            data = newdata
+        else:
+            data = self._getRawBits(address, nbytes*8)
+        return data
+    
+    def _getRawBits(self, address, nbits):
+        nbytes = (nbits + (address & 7) + 7) / 8
+        self.seek(address / 8)
+        return self.getN(nbytes)
+



From haypo at berlios.de  Sat Mar  4 01:27:32 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:27:32 +0100
Subject: [Happyboom-svn] r431 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir
Message-ID: <200603040027.k240RWbb000314@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:27:27 +0100 (Sat, 04 Mar 2006)
New Revision: 431

Added:
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
Removed:
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
Log:
 r25 at haypopc:  haypo | 2006-03-03 20:06:37 +0100
 Finish to simplify InputStream class.



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:24
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:25

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:26:57 UTC (rev 430)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:27:27 UTC (rev 431)
@@ -59,8 +59,8 @@
 
     import libhachoir
 
-    from libhachoir.stream.file import FileStream
-    from text_ui import displayFieldSet
+    from libhachoir.stream import InputStream
+#    from text_ui import displayFieldSet
     from libhachoir.plugin import loadPlugins, guessPlugin
     from libhachoir.log import log
     from libhachoir.error import error
@@ -69,7 +69,7 @@
 
     # Create input stream (read filename from command line first argument)
     filename = parseArgs()
-    stream = FileStream(open(filename, 'r'), filename)
+    stream = InputStream(open(filename, 'r'), filename)
 
     # Load all parser plugings from 'file' directory
     root_dir = libhachoir_path
@@ -81,7 +81,7 @@
     plugin = guessPlugin(stream, filename, None)
     if plugin == None:
         msg  = "Sorry, can't find plugin for file \"%s\"!" % filename
-        mimes = [ mime[0] for mime in getStreamMime(stream, filename) ]
+        mimes = [ mime[0] for mime in getStreamMime(stream) ]
         msg += "\n\nFile mimes: %s" % ", ".join(mimes)
         error(msg)
         sys.exit(1)

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py	2006-03-04 00:26:57 UTC (rev 430)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py	2006-03-04 00:27:27 UTC (rev 431)
@@ -69,25 +69,20 @@
     """
     return _mime_by_ext.get(ext, None)
 
-def getStreamMime(stream, filename):
+def getStreamMime(stream):
     """ Guess MIME type of a stream using first 4 KB
 
     @parameter stream: Stream containing data
-    @type: C{Stream}
-    @parameter filename: Filename of the stream source, can be None
-    @type: C{str}
+    @type: C{InputStream}
     @return: MIME type, or None if fails
     @rtype: C{str}
     """
 
-    oldpos = stream.tell()
-    stream.seek(0)
-    size = stream.getSize()
-    if 4096 < size:
-        size = 4096
-    data = stream.getN(size)
-    stream.seek(oldpos)
-    return getBufferMime(data, filename)
+    nb_bytes = stream.size/8
+    if 4096 < nb_bytes:
+        nb_bytes = 4096
+    data = stream.getBytes(0, nb_bytes)
+    return getBufferMime(data, stream.filename)
 
 def getAnotherBufferMime(content):    
     """ Another method (L{guessMime}) to guess MIME type. This

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:26:57 UTC (rev 430)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:27:27 UTC (rev 431)
@@ -62,7 +62,7 @@
     return plugins[0]
     
 def getPluginByStream(stream, filename, default=None):
-    mime = getStreamMime(stream, filename)
+    mime = getStreamMime(stream)
     return getPluginByMime(mime, default)
 
 def getPluginByFile(filename, realname=None, default=None):

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:26:57 UTC (rev 430)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:27:27 UTC (rev 431)
@@ -0,0 +1,92 @@
+def getFileSize(stream):
+    """ Get file size in bits """
+    oldpos = stream.tell()
+    stream.seek(0,2)
+    size = stream.tell() * 8
+    stream.seek(oldpos)
+    return size
+
+class InputStreamError(Exception):
+    pass
+
+class InputStream:
+    def __init__(self, input, filename=None, size=None, copy=None):
+        self._input = input 
+        self.filename = filename
+        if copy == None:
+            if size == None:
+                size = getFileSize(input)
+            if size == 0:
+                raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
+            self._size = size
+        else:
+            self._size = copy._size
+        
+    def _getSize(self):
+        return self._size
+    size = property(_getSize, doc="Size of the stream in bits")
+
+    def getBits(self, address, nbits, big_endian=False):
+        data = self._getRawBits(address, nbits)        
+        if (address % 8) != 0 or (nbits % 8) != 0:
+            mask = (1 << nbits) - 1
+            shift = address & 7 
+        else:
+            shift = 0
+            mask = None
+        value = 0
+        if not big_endian:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+                shift = nbits-shift
+            else:
+                shift = nbits-8
+                if shift < 0:
+                    shift += 8
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift -= 8
+        else:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift += 8
+        if mask != None:
+            value = value & mask
+        return value
+
+    def getBytes(self, address, nbytes):
+        if address % 8 != 0:
+            data = self._getRawBits(address, nbytes*8)
+            nbits = address % 8
+            shift1 = nbits
+            shift2 = 8 - nbits
+            mask = (1 << nbits) - 1
+            newdata = ""
+            for i in range(0, len(data)-1):
+                byte1 = ord(data[i])
+                byte2 = ord(data[i+1])
+                new = chr((byte1 >> shift1) + ((byte2 & mask) << shift2))
+                newdata += new 
+            data = newdata
+        else:
+            data = self._getRawBits(address, nbytes*8)
+        return data
+    
+    def _getRawBits(self, address, nb_bits):
+        nb_bytes = (nb_bits + (address & 7) + 7) / 8
+        self._input.seek(address / 8)
+        data = self._input.read(nb_bytes)
+        if len(data) != nb_bytes:
+            raise InputStreamError(
+                "Can't read %u bytes at address %u (got %u bytes)!" % \
+                (nb_bytes, address/8, len(data)))
+        return data
+



From haypo at berlios.de  Sat Mar  4 01:28:28 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:28:28 +0100
Subject: [Happyboom-svn] r432 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir
Message-ID: <200603040028.k240SSef000542@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:27:53 +0100 (Sat, 04 Mar 2006)
New Revision: 432

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/doc.txt
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
   haypo/hachoir/branches/hachoir-yield/test_doc.py
Log:
 r26 at haypopc:  haypo | 2006-03-03 20:11:24 +0100
  * Create StringInputStream class
  * Update documentation (FileStream => StringInputStream)



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:25
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:26

Modified: haypo/hachoir/branches/hachoir-yield/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:27:27 UTC (rev 431)
+++ haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:27:53 UTC (rev 432)
@@ -21,14 +21,13 @@
 
 Here is a small example to create a stream:
 
->>> from stream.file import FileStream
->>> from StringIO import StringIO
->>> stream = FileStream(StringIO("\x03abc"), None)
+>>> from stream import StringInputStream
+>>> stream = StringInputStream("\x03abc")
 
 StringIO is a class which works like a file object but using a string as input
 data. Most interesting methods are:
 
->>> stream.getSize()       # get size in bits
+>>> stream.size            # get size in bits
 32
 >>> stream.getBits(0, 8)   # get 8 bits at address 0
 3
@@ -148,7 +147,7 @@
 
 In the constructor, the field "color" is asked. So the field list will
 contains one field (color):
->>> stream = FileStream(StringIO("\x2A\x00\x04\x05"), None)
+>>> stream = StringInputStream("\x2A\x00\x04\x05")
 >>> p = Point(None, "point", stream)
 >>> len(p.fields)
 1

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:27:27 UTC (rev 431)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:27:53 UTC (rev 432)
@@ -1,3 +1,5 @@
+from cStringIO import StringIO
+
 def getFileSize(stream):
     """ Get file size in bits """
     oldpos = stream.tell()
@@ -9,18 +11,19 @@
 class InputStreamError(Exception):
     pass
 
+def StringInputStream(content):
+    input = StringIO(content)
+    return InputStream(input, filename=None, size=len(content)*8)
+
 class InputStream:
-    def __init__(self, input, filename=None, size=None, copy=None):
+    def __init__(self, input, filename=None, size=None):
+        self.filename = filename
+        if size == None:
+            size = getFileSize(input) * 8
+        if size == 0:
+            raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
+        self._size = size
         self._input = input 
-        self.filename = filename
-        if copy == None:
-            if size == None:
-                size = getFileSize(input)
-            if size == 0:
-                raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
-            self._size = size
-        else:
-            self._size = copy._size
         
     def _getSize(self):
         return self._size

Modified: haypo/hachoir/branches/hachoir-yield/test_doc.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:27:27 UTC (rev 431)
+++ haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:27:53 UTC (rev 432)
@@ -1,6 +1,16 @@
-import doctest
-filename = 'doc.txt'
-print "Run test in %s" % filename
-doctest.testfile(filename, optionflags=doctest.ELLIPSIS)
-print "End of all tests of %s" % filename
+import doctest, sys, os
 
+def testDoc(filename, name=None):
+    print "Run test in %s" % filename
+    doctest.testfile(filename, optionflags=doctest.ELLIPSIS, name=name)
+    print "End of all tests of %s" % filename
+
+def main():
+    root_dir = os.path.dirname(__file__)
+    hachoir_path = "libhachoir"
+    sys.path.append(hachoir_path)
+
+    testDoc('doc.txt', "Main document")
+
+if __name__ == "__main__":
+    main()



From haypo at berlios.de  Sat Mar  4 01:29:06 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:29:06 +0100
Subject: [Happyboom-svn] r433 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir
Message-ID: <200603040029.k240T6lv000761@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:28:52 +0100 (Sat, 04 Mar 2006)
New Revision: 433

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/config.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/error.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
Log:
 r27 at haypopc:  haypo | 2006-03-03 20:21:49 +0100
  * loadPlugins() renamed to loadParserPlugins() and don't need any argument anymore
  * All functions about plugins renamed to "(...)Parser" (eg.
    guessPlugin() becomes guessParser())
  * Add command line argument "--quiet" which hide warnings



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:26
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:27

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:27:53 UTC (rev 432)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:28:52 UTC (rev 433)
@@ -7,6 +7,7 @@
 cmd_line_options = ( \
     ("verbose", "Activate verbose mode"),
     ("help", "Show this help"),
+    ("quiet", "Be quiet (don't display warning)"),
     ("version", "Display version"),
     ("debug", "Enable debug mode (eg. display backtrace)")
 )
@@ -47,6 +48,8 @@
         elif option == "--version":
             print "Hachoir version %s" % VERSION
             sys.exit(0)
+        elif option == "--quiet":
+            config.quiet = True
         elif option == "--verbose":
             config.verbose = True
         elif option == "--debug":
@@ -54,31 +57,35 @@
     return filename 
 
 def main():
+    # Get libhachoir directory
     libhachoir_path = os.path.join(os.getcwd(), "libhachoir")
     sys.path.append(libhachoir_path)
+    
+    # Parser command line arguments
+    filename = parseArgs()
 
-    import libhachoir
-
+    # Get tools that we need from libhachoir
     from libhachoir.stream import InputStream
-#    from text_ui import displayFieldSet
-    from libhachoir.plugin import loadPlugins, guessPlugin
+    from text_ui import displayFieldSet
+    from libhachoir.plugin import loadParserPlugins, guessParser
     from libhachoir.log import log
     from libhachoir.error import error
     from libhachoir.mime import getStreamMime
     from metadata import createMetaData
+    import libhachoir.config as config
 
     # Create input stream (read filename from command line first argument)
-    filename = parseArgs()
     stream = InputStream(open(filename, 'r'), filename)
 
     # Load all parser plugings from 'file' directory
     root_dir = libhachoir_path
-    modules = loadPlugins(os.path.join(root_dir, "parser"))
-    modules.sort()
-    log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
+    modules = loadParserPlugins()
+    if config.verbose:
+        modules.sort()
+        log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 
     # Look for right plugin
-    plugin = guessPlugin(stream, filename, None)
+    plugin = guessParser(stream, filename, None)
     if plugin == None:
         msg  = "Sorry, can't find plugin for file \"%s\"!" % filename
         mimes = [ mime[0] for mime in getStreamMime(stream) ]

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/config.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/config.py	2006-03-04 00:27:53 UTC (rev 432)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/config.py	2006-03-04 00:28:52 UTC (rev 433)
@@ -6,6 +6,7 @@
 # Global options
 debug = False 
 verbose = False
+quiet = False
 
 # Size of file cache (for each opened file)
 file_cache_block_size = 4096  # 4 KB

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/error.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/error.py	2006-03-04 00:27:53 UTC (rev 432)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/error.py	2006-03-04 00:28:52 UTC (rev 433)
@@ -5,6 +5,8 @@
 from tools import getBacktrace
 
 def warning(message):
+    if config.quiet:
+        return
     if config.verbose or config.debug:
         message += "\n\n" + getBacktrace()
     log.warning(message)   

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:27:53 UTC (rev 432)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:28:52 UTC (rev 433)
@@ -3,9 +3,11 @@
 from mime import getFileMime, getStreamMime
 from error import warning
 
+hachoir_parsers = {} 
+
 regex_plugin_filename = re.compile(r"^([a-z0-9_]+)\.py$")
 
-def loadPluginFromFile(module_path, loaded):
+def loadParser(module_path, loaded):
     try:
         module = __import__(module_path)
         for get in module_path.split(".")[1:]:
@@ -17,38 +19,42 @@
     for attr in module.__dict__:
         item = getattr(module, attr)
         if hasattr(item, "mime_types"):
-            registerPlugin(item, item.mime_types)
+            registerParser(item, item.mime_types)
             loaded.append(module_path)
 
-def loadPlugins(dir, module_path="libhachoir.parser", loaded=[]):
+def loadParserPlugins(dir=None, module_path="libhachoir.parser", loaded=[]):
     """
-    Load all plugings from directory dir.
+    Load all plugings from directory dir. Don't give any argument, they are
+    used internally.
 
-    Do not set module_path or loaded, they are used internally.
+    Returns a list of loaded plugins.
     """
+    if dir == None:
+        rootdir = os.path.dirname(__file__)
+        dir = os.path.join(rootdir, "parser")
     if module_path == None:
         module_path = os.path.basename(dir)
     for file in os.listdir(dir):
         fullpath = os.path.join(dir, file)
         if S_ISDIR(os.stat(fullpath)[ST_MODE]):
-            loadPlugins(fullpath, module_path+"."+file, loaded)
+            loadParserPlugins(fullpath, module_path+"."+file, loaded)
         else:
             m = regex_plugin_filename.match(file)
             if m != None and m.group(1) != "__init__":
                 path = module_path + "." + m.group(1)
-                loadPluginFromFile(path, loaded)
+                loadParser(path, loaded)
     return loaded                    
 
-def guessPlugin(stream, filename, default=None):
-    return getPluginByStream(stream, filename, default)
+def guessParser(stream, filename, default=None):
+    return getParserByStream(stream, filename, default)
 
-def getPluginByMime(mimes, default=None):
-    global hachoir_plugins
+def getParserByMime(mimes, default=None):
+    global hachoir_parsers
     plugins = []
     for mime in mimes:
         mime = mime[0]
-        if mime in hachoir_plugins:
-            for plugin in hachoir_plugins[mime]:
+        if mime in hachoir_parsers:
+            for plugin in hachoir_parsers[mime]:
                 if plugin not in plugins:
                     plugins.append(plugin)
     if len(plugins)==0:
@@ -61,22 +67,21 @@
         warning("More than one plugin have same MIME:\n%s" % plist)
     return plugins[0]
     
-def getPluginByStream(stream, filename, default=None):
+def getParserByStream(stream, filename, default=None):
     mime = getStreamMime(stream)
-    return getPluginByMime(mime, default)
+    return getParserByMime(mime, default)
 
-def getPluginByFile(filename, realname=None, default=None):
+def getParserByFile(filename, realname=None, default=None):
     mime = getFileMime(filename, realname)
-    return getPluginByMime(mime, default)
+    return getParserByMime(mime, default)
     
-def registerPlugin(filter_class, mimes):
-    global hachoir_plugins
+def registerParser(filter_class, mimes):
+    global hachoir_parsers
     if isinstance(mimes, str):
         mimes = [mimes]
     for mime in mimes:
-        if mime in hachoir_plugins:
-            hachoir_plugins[mime].append(filter_class)
+        if mime in hachoir_parsers:
+            hachoir_parsers[mime].append(filter_class)
         else:
-            hachoir_plugins[mime] = [filter_class]
+            hachoir_parsers[mime] = [filter_class]
 
-hachoir_plugins = {} 



From haypo at berlios.de  Sat Mar  4 01:29:34 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:29:34 +0100
Subject: [Happyboom-svn] r434 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/doc branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/unit_test
Message-ID: <200603040029.k240TYKH001157@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:29:19 +0100 (Sat, 04 Mar 2006)
New Revision: 434

Added:
   haypo/hachoir/branches/hachoir-yield/doc/
   haypo/hachoir/branches/hachoir-yield/doc/doc.txt
   haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/tools.py
Removed:
   haypo/hachoir/branches/hachoir-yield/doc.txt
   haypo/hachoir/branches/hachoir-yield/text_handler.py
   haypo/hachoir/branches/hachoir-yield/tools.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
   haypo/hachoir/branches/hachoir-yield/run_unit_test.py
   haypo/hachoir/branches/hachoir-yield/test_doc.py
   haypo/hachoir/branches/hachoir-yield/unit_test/create_fields.py
   haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py
Log:
 r28 at haypopc:  haypo | 2006-03-03 20:33:03 +0100
  * Move last files to Hachoir library directory
  * Fix unit tests



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:27
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:28

Added: haypo/hachoir/branches/hachoir-yield/doc/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/doc.txt	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/doc/doc.txt	2006-03-04 00:29:19 UTC (rev 434)
@@ -0,0 +1,260 @@
+Introduction
+============
+
+Hachoir is a library written in Python to access binary streams using
+nice API. It aims to be easy to use (hide complex mechanisms) and only read
+or compute data when it's really needed.
+
+Examples of Hachoir use: extract some informations from a file (size of an
+image, author of a music, comment of an archive, etc.), edit some fields of
+a file, convert a format to another one.
+
+Write your own format FieldSet class
+====================================
+
+Input stream
+------------
+
+For different reasons (eg. addresses with bit granularity), Hachoir uses it's
+own stream classes. The most interesting class is FileStream. It's constructor
+need a file and a filename (optionnal, can be None).
+
+Here is a small example to create a stream:
+
+>>> from stream import StringInputStream
+>>> stream = StringInputStream("\x03abc")
+
+StringIO is a class which works like a file object but using a string as input
+data. Most interesting methods are:
+
+>>> stream.size            # get size in bits
+32
+>>> stream.getBits(0, 8)   # get 8 bits at address 0
+3
+>>> stream.getBytes(8, 3)  # get 3 bytes at address 8
+'abc'
+
+Support your own format using FieldSet
+--------------------------------------
+
+In the Hachoir, everything is stored in a field. The parent of all classes is
+the class Field, but it can't be used directly. They are four different types
+of fields:
+ * Bits: number with a size in bits ;
+ * Integer: number with a size in bytes ;
+ * String: string of characters with a size in bytes ;
+ * FieldSet: a ordered list of fields (contains other fields).
+
+A stream is splitted in several fields which are organised in a tree. So all
+fields have a parent, except of the root. Small example which will be used to
+parse the string "\x03abc" (stream of previous paragraph):
+
+>>> from field import FieldSet, Integer, String
+>>> class MyFormat(FieldSet):
+...     def createFields(self):
+...             yield Integer(self, "length", "uint8", "String length")
+...             yield String(self, "text", "string[%u]" % self["length"].value)
+...
+
+One goal in Hachoir is to make the write of a parser the more easy that it
+could be. You just have to write one method, createFields, which will create
+all fields.
+
+Another goal is to create the less fields as possible. In most cases, no field
+is created when a field set in instanciated. Fields are created when you access
+them by their name. That's why, the special Python keyword ''yield'' is used
+which permit to create only fields "on demand" (get more details about
+FieldSet internals in later section).
+
+Prototype of field classes are almost different, but the two first parameters
+are always the same:
+ * First one is the parent, of type FieldSet (is None for the root) ;
+ * The second is the name of the field.
+
+Ok, let's play with our new field set:
+
+>>> format = MyFormat(None, "myformat", stream)
+>>> format.size               # get size in bits
+32
+>>> format["text"].value
+'abc'
+>>> "length" in format        # test if the field 'length' does exist
+True
+>>> # Easiest way to display a field set content
+>>> for field in format:
+...     print "%s=%s" % (field.name, field.display)
+...
+length=3
+text="abc"
+
+Details about Field class
+-------------------------
+
+A field contains a lot of informations, attributes are:
+ * name: Field name, unique in his parent field set and can't be changed. It
+   is used as key to access to the field from the field set ;
+ * size: Size in bits, can't be changed ;
+ * address: Address in bits, relative to parent address, can't be changed ;
+ * absolute_address: Address in bits from the beginning of the stream ;
+ * parent: Parent of the field (is None for root field set) ;
+ * root: Root of all field sets ;
+ * value: Formatted value (integer, string, boolean, ...) value of the field.
+   Don't use this argument with print function, better use display attribute ;
+ * display: A string representing field value, has limited size ;
+ * path: Full "path" of the field from the root (eg. "/png/header/content") ;
+ * is_field_set: If the value is True, the field contains other fields, it's
+   a field set.
+
+Examples:
+>>> field = format["text"]
+>>> field.name
+'text'
+>>> field.path
+'/myformat/text'
+>>> field.value
+'abc'
+>>> field.size
+24
+>>> field.address
+8
+
+Some Hachoir internals
+======================
+
+When a field is really created?
+-------------------------------
+
+A field is created when someone ask to access it, or when another field is
+asked and the field is before it. So if you use a field in your field set
+constructor, one or more fields will be created.
+
+Example:
+>>> from field import FieldSet, Integer, String
+>>> class Point(FieldSet):
+...     def __init__(self, parent, name, stream, description="Point"):
+...         FieldSet.__init__(self, parent, name, stream, description)
+...         if self["color"].value == -1:
+...             self.description += " (no color)"
+...
+...     def createFields(self):
+...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
+...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
+...         yield Integer(self, "x", "int8", "X axis value")
+...         yield Integer(self, "y", "int8", "Y axis value")
+...         if self["use_3d"] == 1:
+...             yield Integer(self, "z", "int8", "Z axis value")
+...
+
+In the constructor, the field "color" is asked. So the field list will
+contains one field (color):
+>>> stream = StringInputStream("\x2A\x00\x04\x05")
+>>> p = Point(None, "point", stream)
+>>> len(p.fields)
+1
+
+WARNING: Only access 'fields' attribute if you know what you are doing.
+
+If you access another field, the field list will grow up until the requested
+field is reached:
+>>> x = p["x"].value
+>>> len(p.fields)
+3
+
+Some field set methods which create new fields:
+ * __getitem__(): feed field list until requested field is reached
+   (or raise MissingField exception) ;
+ * __len__(): create all fields ;
+ * __iter__(): begin to iterate in existing fields, and the iterate in new
+   fields until all fields are created ;
+ * __contains__(): feed field list until requested field is reached, may
+   create all fields if the field is missing.
+
+The size attribute also interact with field list creation, but it's mechanism
+is little bit more complex. By default, the whole field list have to be built
+before size value can be read. But you can specify field list size:
+ * if field list is fixed, use class attribute static_size ;
+ * else you can set _size instance attribute in the constructor.
+
+Two examples:
+>>> class FourBytes(FieldSet):
+...     static_size = 32
+...     def createFields(self):
+...         yield Integer(self, "four", "uint32")
+...
+>>> class DynamicSize(FieldSet):
+...     def __init__(self, parent, name, stream, nb_items, description="Point"):
+...         FieldSet.__init__(self, parent, name, stream, description)
+...         self.nb_items = nb_items
+...         self._size = nb_items * 32   # 32 is the size of one item
+...
+...     def createFields(self):
+...         for index in range(self.nb_items):
+...             yield Integer(self, "item[]", "uint32")
+...
+
+When the value of a field is read?
+----------------------------------
+
+When a field is created, the value of the field doesn't exist (equals to
+None). The value is really read when you read the field value using '.value'
+or '.display' field attributes. The value is then stored in the field.
+
+Details about field name
+------------------------
+
+The name of a field have to be unique in a field set because it is used as
+key in the field list. The argument 'name' of the Field constructor can be
+changed in the the constructor, but should not (and can no) be changed after
+that.
+
+For arrays, you can use the 'magic' prefix ? [] ? (eg. "item[]") which will
+be replaced by ? [index] ? where the number index is a counter starting a
+zero.
+
+Endian
+------
+
+The "endian" is the way in which ''bytes'' are stored. There are two important
+orders:
+ * ? Big endian ? in which _big_ numbers are written first (Intel x86 CPU)
+ * ? Little endian ? in which _little_ numbers are written first (PowerPC CPU)
+
+The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
+little endian.
+
+The endian is global to a FieldSet and is a class attribute. Two allowed
+values are "<" (little endian) and ">" (big endian). Default value is the
+international network order: "<", big endian.
+
+Example to set endian:
+>>> class UseLittleEndian(FieldSet):
+...     endian = ">"
+...     # (...)
+...
+
+Explore a field set using it's path
+-----------------------------------
+
+Fields are stored in a tree. To explore the tree you have differents tools:
+ * attribute root of a field which go to tree root ;
+ * attribute parent go to field parent (is None for tree root) ;
+ * and you can specify a path in __getitem__() argument.
+
+There are differents valid syntax of a path:
+ * path to a child of current node: field["content"] ;
+ * path to a child of the parent: field["../brother"] ;
+ * path from the root: field["/header/key"].
+
+Event handling
+--------------
+
+Code is not finished yet, so don't need documentation :-) See:
+ * FieldSet.connect(event, handler)
+ * FieldSet.raiseEvent(event,  arg1, arg2, ...)
+
+Get more informations
+=====================
+
+Hachoir website:
+   http://www.haypocalc.com/wiki/Hachoir
+

Deleted: haypo/hachoir/branches/hachoir-yield/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/doc.txt	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,260 +0,0 @@
-Introduction
-============
-
-Hachoir is a library written in Python to access binary streams using
-nice API. It aims to be easy to use (hide complex mechanisms) and only read
-or compute data when it's really needed.
-
-Examples of Hachoir use: extract some informations from a file (size of an
-image, author of a music, comment of an archive, etc.), edit some fields of
-a file, convert a format to another one.
-
-Write your own format FieldSet class
-====================================
-
-Input stream
-------------
-
-For different reasons (eg. addresses with bit granularity), Hachoir uses it's
-own stream classes. The most interesting class is FileStream. It's constructor
-need a file and a filename (optionnal, can be None).
-
-Here is a small example to create a stream:
-
->>> from stream import StringInputStream
->>> stream = StringInputStream("\x03abc")
-
-StringIO is a class which works like a file object but using a string as input
-data. Most interesting methods are:
-
->>> stream.size            # get size in bits
-32
->>> stream.getBits(0, 8)   # get 8 bits at address 0
-3
->>> stream.getBytes(8, 3)  # get 3 bytes at address 8
-'abc'
-
-Support your own format using FieldSet
---------------------------------------
-
-In the Hachoir, everything is stored in a field. The parent of all classes is
-the class Field, but it can't be used directly. They are four different types
-of fields:
- * Bits: number with a size in bits ;
- * Integer: number with a size in bytes ;
- * String: string of characters with a size in bytes ;
- * FieldSet: a ordered list of fields (contains other fields).
-
-A stream is splitted in several fields which are organised in a tree. So all
-fields have a parent, except of the root. Small example which will be used to
-parse the string "\x03abc" (stream of previous paragraph):
-
->>> from field import FieldSet, Integer, String
->>> class MyFormat(FieldSet):
-...     def createFields(self):
-...             yield Integer(self, "length", "uint8", "String length")
-...             yield String(self, "text", "string[%u]" % self["length"].value)
-...
-
-One goal in Hachoir is to make the write of a parser the more easy that it
-could be. You just have to write one method, createFields, which will create
-all fields.
-
-Another goal is to create the less fields as possible. In most cases, no field
-is created when a field set in instanciated. Fields are created when you access
-them by their name. That's why, the special Python keyword ''yield'' is used
-which permit to create only fields "on demand" (get more details about
-FieldSet internals in later section).
-
-Prototype of field classes are almost different, but the two first parameters
-are always the same:
- * First one is the parent, of type FieldSet (is None for the root) ;
- * The second is the name of the field.
-
-Ok, let's play with our new field set:
-
->>> format = MyFormat(None, "myformat", stream)
->>> format.size               # get size in bits
-32
->>> format["text"].value
-'abc'
->>> "length" in format        # test if the field 'length' does exist
-True
->>> # Easiest way to display a field set content
->>> for field in format:
-...     print "%s=%s" % (field.name, field.display)
-...
-length=3
-text="abc"
-
-Details about Field class
--------------------------
-
-A field contains a lot of informations, attributes are:
- * name: Field name, unique in his parent field set and can't be changed. It
-   is used as key to access to the field from the field set ;
- * size: Size in bits, can't be changed ;
- * address: Address in bits, relative to parent address, can't be changed ;
- * absolute_address: Address in bits from the beginning of the stream ;
- * parent: Parent of the field (is None for root field set) ;
- * root: Root of all field sets ;
- * value: Formatted value (integer, string, boolean, ...) value of the field.
-   Don't use this argument with print function, better use display attribute ;
- * display: A string representing field value, has limited size ;
- * path: Full "path" of the field from the root (eg. "/png/header/content") ;
- * is_field_set: If the value is True, the field contains other fields, it's
-   a field set.
-
-Examples:
->>> field = format["text"]
->>> field.name
-'text'
->>> field.path
-'/myformat/text'
->>> field.value
-'abc'
->>> field.size
-24
->>> field.address
-8
-
-Some Hachoir internals
-======================
-
-When a field is really created?
--------------------------------
-
-A field is created when someone ask to access it, or when another field is
-asked and the field is before it. So if you use a field in your field set
-constructor, one or more fields will be created.
-
-Example:
->>> from field import FieldSet, Integer, String
->>> class Point(FieldSet):
-...     def __init__(self, parent, name, stream, description="Point"):
-...         FieldSet.__init__(self, parent, name, stream, description)
-...         if self["color"].value == -1:
-...             self.description += " (no color)"
-...
-...     def createFields(self):
-...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
-...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
-...         yield Integer(self, "x", "int8", "X axis value")
-...         yield Integer(self, "y", "int8", "Y axis value")
-...         if self["use_3d"] == 1:
-...             yield Integer(self, "z", "int8", "Z axis value")
-...
-
-In the constructor, the field "color" is asked. So the field list will
-contains one field (color):
->>> stream = StringInputStream("\x2A\x00\x04\x05")
->>> p = Point(None, "point", stream)
->>> len(p.fields)
-1
-
-WARNING: Only access 'fields' attribute if you know what you are doing.
-
-If you access another field, the field list will grow up until the requested
-field is reached:
->>> x = p["x"].value
->>> len(p.fields)
-3
-
-Some field set methods which create new fields:
- * __getitem__(): feed field list until requested field is reached
-   (or raise MissingField exception) ;
- * __len__(): create all fields ;
- * __iter__(): begin to iterate in existing fields, and the iterate in new
-   fields until all fields are created ;
- * __contains__(): feed field list until requested field is reached, may
-   create all fields if the field is missing.
-
-The size attribute also interact with field list creation, but it's mechanism
-is little bit more complex. By default, the whole field list have to be built
-before size value can be read. But you can specify field list size:
- * if field list is fixed, use class attribute static_size ;
- * else you can set _size instance attribute in the constructor.
-
-Two examples:
->>> class FourBytes(FieldSet):
-...     static_size = 32
-...     def createFields(self):
-...         yield Integer(self, "four", "uint32")
-...
->>> class DynamicSize(FieldSet):
-...     def __init__(self, parent, name, stream, nb_items, description="Point"):
-...         FieldSet.__init__(self, parent, name, stream, description)
-...         self.nb_items = nb_items
-...         self._size = nb_items * 32   # 32 is the size of one item
-...
-...     def createFields(self):
-...         for index in range(self.nb_items):
-...             yield Integer(self, "item[]", "uint32")
-...
-
-When the value of a field is read?
-----------------------------------
-
-When a field is created, the value of the field doesn't exist (equals to
-None). The value is really read when you read the field value using '.value'
-or '.display' field attributes. The value is then stored in the field.
-
-Details about field name
-------------------------
-
-The name of a field have to be unique in a field set because it is used as
-key in the field list. The argument 'name' of the Field constructor can be
-changed in the the constructor, but should not (and can no) be changed after
-that.
-
-For arrays, you can use the 'magic' prefix ? [] ? (eg. "item[]") which will
-be replaced by ? [index] ? where the number index is a counter starting a
-zero.
-
-Endian
-------
-
-The "endian" is the way in which ''bytes'' are stored. There are two important
-orders:
- * ? Big endian ? in which _big_ numbers are written first (Intel x86 CPU)
- * ? Little endian ? in which _little_ numbers are written first (PowerPC CPU)
-
-The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
-little endian.
-
-The endian is global to a FieldSet and is a class attribute. Two allowed
-values are "<" (little endian) and ">" (big endian). Default value is the
-international network order: "<", big endian.
-
-Example to set endian:
->>> class UseLittleEndian(FieldSet):
-...     endian = ">"
-...     # (...)
-...
-
-Explore a field set using it's path
------------------------------------
-
-Fields are stored in a tree. To explore the tree you have differents tools:
- * attribute root of a field which go to tree root ;
- * attribute parent go to field parent (is None for tree root) ;
- * and you can specify a path in __getitem__() argument.
-
-There are differents valid syntax of a path:
- * path to a child of current node: field["content"] ;
- * path to a child of the parent: field["../brother"] ;
- * path from the root: field["/header/key"].
-
-Event handling
---------------
-
-Code is not finished yet, so don't need documentation :-) See:
- * FieldSet.connect(event, handler)
- * FieldSet.raiseEvent(event,  arg1, arg2, ...)
-
-Get more informations
-=====================
-
-Hachoir website:
-   http://www.haypocalc.com/wiki/Hachoir
-

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -58,7 +58,8 @@
 
 def main():
     # Get libhachoir directory
-    libhachoir_path = os.path.join(os.getcwd(), "libhachoir")
+    current_dir = os.path.dirname(__file__)
+    libhachoir_path = os.path.join(current_dir, "libhachoir")
     sys.path.append(libhachoir_path)
     
     # Parser command line arguments

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,4 +1,4 @@
-from field import Field
-from integer import Integer, IntegerHex, Enum, Bits, Bit
-from string_field import String
-from field_set import FieldSet, ParserError
+from libhachoir.field.field import Field
+from libhachoir.field.integer import Integer, IntegerHex, Enum, Bits, Bit
+from libhachoir.field.string_field import String
+from libhachoir.field.field_set import FieldSet, ParserError

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,7 +1,7 @@
-from event_handler import EventHandler
 from field import Field
-from indexed_dict import IndexedDict
-import config
+from libhachoir.event_handler import EventHandler
+from libhachoir.indexed_dict import IndexedDict
+import libhachoir.config as config
 
 class MissingField(KeyError):
     pass

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,6 +1,6 @@
 from field import Field
-from format import getFormatSize
-from text_handler import hexadecimal
+from libhachoir.format import getFormatSize
+from libhachoir.text_handler import hexadecimal
 
 class Bits(Field):
     def __init__(self, parent, name, size, description=None):

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,6 +1,6 @@
 from field import Field
-from format import getFormatSize
-from tools import convertDataToPrintableString
+from libhachoir.format import getFormatSize
+from libhachoir.tools import convertDataToPrintableString
 
 class String(Field):
     def __init__(self, parent, name, format, description=None):

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -11,6 +11,10 @@
 class InputStreamError(Exception):
     pass
 
+def FileInputStream(input, filename):
+    size = getFileSize(input) * 8
+    return InputStream(input, filename=filename, size=size)
+
 def StringInputStream(content):
     input = StringIO(content)
     return InputStream(input, filename=None, size=len(content)*8)
@@ -18,8 +22,6 @@
 class InputStream:
     def __init__(self, input, filename=None, size=None):
         self.filename = filename
-        if size == None:
-            size = getFileSize(input) * 8
         if size == 0:
             raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
         self._size = size

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -0,0 +1,33 @@
+import datetime
+from tools import humanFilesize as doHumanFilesize
+from bits import str2bin
+
+def msdosDatetime(chunk):
+    assert chunk.size == 4
+    val = chunk.value
+    sec = 2 * (val & 31)              # 5 bits: second
+    minute = (val >> 5) & 63          # 6 bits: minute
+    hour = (val >> 11) & 31           # 5 bits: hour
+    day = (val >> 16) & 31            # 5 bits: day of the month
+    month = (val >> 21) & 15          # 4 bits: month
+    year = 1980 + ((val >> 25) & 127) # 7 bits: year
+    try:
+        return str(datetime.datetime(year, month, day, hour, minute, sec))
+    except:
+        return "invalid msdos datetime (%s)" % val
+    
+def humanFilesize(chunk):
+    return doHumanFilesize(chunk.value)
+
+def unixTimestamp(chunk):
+    timestamp = datetime.datetime.fromtimestamp(chunk.value)
+    return str(timestamp) 
+
+def binary(chunk):
+    return str2bin(chunk.getRaw()) + " (%s)" % chunk.value
+
+def hexadecimal(chunk):
+    size = chunk.size
+    assert size in (8, 16, 32, 64)
+    pattern = "0x%0" + str(size/4) + "X"
+    return pattern % chunk.value

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/tools.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/tools.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/tools.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -0,0 +1,195 @@
+import traceback, sys, string, re
+
+def alignValue(value, align):
+    if value % align != 0:
+        return value + align - (value % align)
+    else:
+        return value        
+
+def _regexMaxLength(pattern, in_parenthesis=False):
+    """
+    Don't use this function directly, use regexMagLength!
+    """
+
+    re_letter = re.compile( r"^[^][()|.?+*{}](.*)$")
+    re_set = re.compile( r"^\[" + r"[^]]*" + r"\](.*)$" )
+    re_min_repetition = re.compile( r"^\{([0-9]+)\}(.*)$" )
+    re_min_max_repetition = re.compile( r"^\{([0-9]+),([0-9]+)\}(.*)$" )
+
+    size = 0
+    atom_size = 0
+    state = 0 # get atom
+    is_end = len(pattern) == 0
+    if in_parenthesis and not is_end:
+        is_end = pattern[0] in ("|", ")")
+    while not is_end:
+        if state==0:
+            size = size + atom_size
+
+            # Pattern: [...] => size=1
+            if pattern[0] == '(':
+                pattern = pattern[1:]
+                atom_size = None
+                while True:
+                    tmp_atom_size, pattern = _regexMaxLength(pattern, True)
+                    if tmp_atom_size == None:
+                        return None, pattern
+                    if atom_size==None or atom_size<tmp_atom_size:
+                        atom_size = tmp_atom_size
+                    if pattern[0] == ')':
+                        break
+                    assert pattern[0] == '|'
+                    pattern = pattern[1:]
+                pattern = pattern[1:]
+            else:
+                m = re_set.match(pattern)
+                if m != None:
+                    pattern = m.group(1)
+                    atom_size = 1
+                else:
+                    m = re_letter.match(pattern)
+                    if m == None:
+                        return (-1, pattern,)
+                    atom_size = 1
+                    pattern = m.group(1)
+            state = 1                
+        else:
+            assert state==1
+
+            # Repetiton: + or * => no limit
+            if pattern[0] in ("*", "+"):
+                return (None, pattern,)
+            
+            # Repetition: {2}
+            m = re_min_repetition.match(pattern)
+            if m != None:
+                repetition = int(m.group(1))
+                pattern = m.group(2)
+                atom_size = atom_size * repetition
+            else:
+                # Repetition: {1,2}
+                m = re_min_max_repetition.match(pattern)
+                if m != None:
+                    repetition = int(m.group(2))
+                    pattern = m.group(3)
+                    atom_size = atom_size * repetition
+            state = 0
+
+        is_end = len(pattern) == 0
+        if in_parenthesis and not is_end:
+            is_end = pattern[0] in ("|", ")")
+
+    return (size + atom_size, pattern,)
+
+def regexMaxLength(pattern):
+    """
+    Get maximum size of a regular expression pattern.
+    Returns (size, pattern). If size=-1, an error occurs (pattern contains
+    the buggy pattern). If size=-1, no limit does exist.
+    """
+
+    size, pattern = _regexMaxLength(pattern)
+    if size == -1:
+        raise "Can't parse regular expression: %s" % pattern 
+    return size 
+
+def humanDuration(ms):
+    # Milliseconds
+    if ms < 1000:
+        return "%u ms" % ms
+        
+    # Seconds
+    sec = ms/1000
+    ms = ms%1000
+    if sec < 60:
+        return  "%u sec" % sec
+
+    # Minutes
+    min = sec/60
+    sec = sec%60
+    if min<60:
+        return "%u min %u sec" % (min, sec)
+
+    # Hours
+    hour = min/60
+    min = min/60
+    if hour < 24:
+        return "%u hour(s) %u min" % (hour, min)
+
+    # Days
+    day = hour/24
+    hour = hour%24
+    if day < 365:
+        return "%u day(s) %u hour(s)" % (day, hour)    
+
+    # Years
+    # TODO: Better estimation !?
+    year = day / 365
+    day = day % 365
+    if hour != 0:
+        text = "%u year(s) %u day(s)" % (year, day)    
+    else:
+        text = "%u year(s)" % (year)
+    return text
+
+def humanFilesize(size):
+    if size < 1000:
+        return "%u bytes" % size
+    units = ["KB", "MB", "GB", "TB"]
+    size = float(size)
+    for unit in units:
+        size = size / 1024
+        if size < 1024:
+            return "%.1f %s" % (size, unit)
+    return "%u %s" % (size, unit)
+
+def convertDataToPrintableString(data, keep_n=False):
+    if len(data) == 0:
+        return "(empty)"
+    if not isinstance(data, unicode):
+        data = re.sub("[^\x00-\x7F]", ".", data)
+        data = unicode(data, "ascii")
+    display = ""
+    for c in data:
+        if ord(c)<32:
+            know = { \
+                "\n": "\\n",
+                "\r": "\\r",
+                "\t": "\\t",
+                "\0": "\\0"}
+            if c == "\n" and keep_n:                
+                display = display + "\\n\n"
+            elif c in know:
+                display = display + know[c]
+            else:
+                display = display + "."
+        elif c == "\"":
+            display = display + "\\\""
+        else:
+            display = display + c
+    return u"\"%s\"" % display
+
+def getBacktrace():
+    try:
+        info = sys.exc_info()
+        bt = traceback.format_exception(*info)
+        sys.exc_clear()
+        if bt[0] != "None\n":
+            return "".join(bt)
+        else:
+            return "Empty backtrace."
+    except:
+        return "Error while trying to get backtrace"
+
+def getUnixRWX(mode):
+#-- TODO --
+#EXT2_S_ISUID  0x0800  SUID
+#EXT2_S_ISGID  0x0400  SGID
+#EXT2_S_ISVTX  0x0200  sticky bit
+    rwx = ("---", "rwx")
+    text = ""
+    for i in range(0,3):
+        for j in range(0,3):
+            mask = 1 << (3*(2-i)) << (2-j)
+            text = text + rwx[int(mode & mask == mask)][j]
+    return text

Modified: haypo/hachoir/branches/hachoir-yield/run_unit_test.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/run_unit_test.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/run_unit_test.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,9 +1,20 @@
 from unit_test import create_fields
 from unit_test import field_set_get_item
+import sys, os
 
 def runAllTests():
     create_fields.runTests()
     field_set_get_item.runTests()
 
+def main():
+    # Load Hachoir library
+    current_dir = os.path.dirname(__file__)
+    libhachoir_path = os.path.join(current_dir, "libhachoir")
+    sys.path.append(libhachoir_path)
+
+    # Run tests
+    runAllTests()
+
 if __name__ == "__main__":
-    runAllTests()
+    main()
+

Modified: haypo/hachoir/branches/hachoir-yield/test_doc.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -10,7 +10,7 @@
     hachoir_path = "libhachoir"
     sys.path.append(hachoir_path)
 
-    testDoc('doc.txt', "Main document")
+    testDoc('doc/doc.txt', "Main document")
 
 if __name__ == "__main__":
     main()

Deleted: haypo/hachoir/branches/hachoir-yield/text_handler.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_handler.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/text_handler.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,33 +0,0 @@
-import datetime
-from tools import humanFilesize as doHumanFilesize
-from bits import str2bin
-
-def msdosDatetime(chunk):
-    assert chunk.size == 4
-    val = chunk.value
-    sec = 2 * (val & 31)              # 5 bits: second
-    minute = (val >> 5) & 63          # 6 bits: minute
-    hour = (val >> 11) & 31           # 5 bits: hour
-    day = (val >> 16) & 31            # 5 bits: day of the month
-    month = (val >> 21) & 15          # 4 bits: month
-    year = 1980 + ((val >> 25) & 127) # 7 bits: year
-    try:
-        return str(datetime.datetime(year, month, day, hour, minute, sec))
-    except:
-        return "invalid msdos datetime (%s)" % val
-    
-def humanFilesize(chunk):
-    return doHumanFilesize(chunk.value)
-
-def unixTimestamp(chunk):
-    timestamp = datetime.datetime.fromtimestamp(chunk.value)
-    return str(timestamp) 
-
-def binary(chunk):
-    return str2bin(chunk.getRaw()) + " (%s)" % chunk.value
-
-def hexadecimal(chunk):
-    size = chunk.size
-    assert size in (8, 16, 32, 64)
-    pattern = "0x%0" + str(size/4) + "X"
-    return pattern % chunk.value

Deleted: haypo/hachoir/branches/hachoir-yield/tools.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/tools.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/tools.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,195 +0,0 @@
-import traceback, sys, string, re
-
-def alignValue(value, align):
-    if value % align != 0:
-        return value + align - (value % align)
-    else:
-        return value        
-
-def _regexMaxLength(pattern, in_parenthesis=False):
-    """
-    Don't use this function directly, use regexMagLength!
-    """
-
-    re_letter = re.compile( r"^[^][()|.?+*{}](.*)$")
-    re_set = re.compile( r"^\[" + r"[^]]*" + r"\](.*)$" )
-    re_min_repetition = re.compile( r"^\{([0-9]+)\}(.*)$" )
-    re_min_max_repetition = re.compile( r"^\{([0-9]+),([0-9]+)\}(.*)$" )
-
-    size = 0
-    atom_size = 0
-    state = 0 # get atom
-    is_end = len(pattern) == 0
-    if in_parenthesis and not is_end:
-        is_end = pattern[0] in ("|", ")")
-    while not is_end:
-        if state==0:
-            size = size + atom_size
-
-            # Pattern: [...] => size=1
-            if pattern[0] == '(':
-                pattern = pattern[1:]
-                atom_size = None
-                while True:
-                    tmp_atom_size, pattern = _regexMaxLength(pattern, True)
-                    if tmp_atom_size == None:
-                        return None, pattern
-                    if atom_size==None or atom_size<tmp_atom_size:
-                        atom_size = tmp_atom_size
-                    if pattern[0] == ')':
-                        break
-                    assert pattern[0] == '|'
-                    pattern = pattern[1:]
-                pattern = pattern[1:]
-            else:
-                m = re_set.match(pattern)
-                if m != None:
-                    pattern = m.group(1)
-                    atom_size = 1
-                else:
-                    m = re_letter.match(pattern)
-                    if m == None:
-                        return (-1, pattern,)
-                    atom_size = 1
-                    pattern = m.group(1)
-            state = 1                
-        else:
-            assert state==1
-
-            # Repetiton: + or * => no limit
-            if pattern[0] in ("*", "+"):
-                return (None, pattern,)
-            
-            # Repetition: {2}
-            m = re_min_repetition.match(pattern)
-            if m != None:
-                repetition = int(m.group(1))
-                pattern = m.group(2)
-                atom_size = atom_size * repetition
-            else:
-                # Repetition: {1,2}
-                m = re_min_max_repetition.match(pattern)
-                if m != None:
-                    repetition = int(m.group(2))
-                    pattern = m.group(3)
-                    atom_size = atom_size * repetition
-            state = 0
-
-        is_end = len(pattern) == 0
-        if in_parenthesis and not is_end:
-            is_end = pattern[0] in ("|", ")")
-
-    return (size + atom_size, pattern,)
-
-def regexMaxLength(pattern):
-    """
-    Get maximum size of a regular expression pattern.
-    Returns (size, pattern). If size=-1, an error occurs (pattern contains
-    the buggy pattern). If size=-1, no limit does exist.
-    """
-
-    size, pattern = _regexMaxLength(pattern)
-    if size == -1:
-        raise "Can't parse regular expression: %s" % pattern 
-    return size 
-
-def humanDuration(ms):
-    # Milliseconds
-    if ms < 1000:
-        return "%u ms" % ms
-        
-    # Seconds
-    sec = ms/1000
-    ms = ms%1000
-    if sec < 60:
-        return  "%u sec" % sec
-
-    # Minutes
-    min = sec/60
-    sec = sec%60
-    if min<60:
-        return "%u min %u sec" % (min, sec)
-
-    # Hours
-    hour = min/60
-    min = min/60
-    if hour < 24:
-        return "%u hour(s) %u min" % (hour, min)
-
-    # Days
-    day = hour/24
-    hour = hour%24
-    if day < 365:
-        return "%u day(s) %u hour(s)" % (day, hour)    
-
-    # Years
-    # TODO: Better estimation !?
-    year = day / 365
-    day = day % 365
-    if hour != 0:
-        text = "%u year(s) %u day(s)" % (year, day)    
-    else:
-        text = "%u year(s)" % (year)
-    return text
-
-def humanFilesize(size):
-    if size < 1000:
-        return "%u bytes" % size
-    units = ["KB", "MB", "GB", "TB"]
-    size = float(size)
-    for unit in units:
-        size = size / 1024
-        if size < 1024:
-            return "%.1f %s" % (size, unit)
-    return "%u %s" % (size, unit)
-
-def convertDataToPrintableString(data, keep_n=False):
-    if len(data) == 0:
-        return "(empty)"
-    if not isinstance(data, unicode):
-        data = re.sub("[^\x00-\x7F]", ".", data)
-        data = unicode(data, "ascii")
-    display = ""
-    for c in data:
-        if ord(c)<32:
-            know = { \
-                "\n": "\\n",
-                "\r": "\\r",
-                "\t": "\\t",
-                "\0": "\\0"}
-            if c == "\n" and keep_n:                
-                display = display + "\\n\n"
-            elif c in know:
-                display = display + know[c]
-            else:
-                display = display + "."
-        elif c == "\"":
-            display = display + "\\\""
-        else:
-            display = display + c
-    return u"\"%s\"" % display
-
-def getBacktrace():
-    try:
-        info = sys.exc_info()
-        bt = traceback.format_exception(*info)
-        sys.exc_clear()
-        if bt[0] != "None\n":
-            return "".join(bt)
-        else:
-            return "Empty backtrace."
-    except:
-        return "Error while trying to get backtrace"
-
-def getUnixRWX(mode):
-#-- TODO --
-#EXT2_S_ISUID  0x0800  SUID
-#EXT2_S_ISGID  0x0400  SGID
-#EXT2_S_ISVTX  0x0200  sticky bit
-    rwx = ("---", "rwx")
-    text = ""
-    for i in range(0,3):
-        for j in range(0,3):
-            mask = 1 << (3*(2-i)) << (2-j)
-            text = text + rwx[int(mode & mask == mask)][j]
-    return text

Modified: haypo/hachoir/branches/hachoir-yield/unit_test/create_fields.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/unit_test/create_fields.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/unit_test/create_fields.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,11 +1,9 @@
-from StringIO import StringIO
-from field import FieldSet, Integer, String, Bits, Bit
-from stream.file import FileStream
-from bits import long2raw, str2hex
+from libhachoir.field import FieldSet, Integer, String, Bits, Bit
+from libhachoir.stream import StringInputStream
+from libhachoir.bits import long2raw, str2hex
 
 def test1():
-    data = "\x02\x01abc\x09"
-    stream = FileStream(StringIO(data), None)
+    stream = StringInputStream("\x02\x01abc\x09")
     class TestInteger(FieldSet):
         def __init__(self, a, b, c):
             FieldSet.__init__(self, a, b, c)
@@ -34,8 +32,8 @@
     assert field.value == 9
 
 def test2():
-    data = "\x21\x43" # concat(0x01, 0x23, 0x4)
-    stream = FileStream(StringIO(data), None)
+    # data: concat numbers (0x01, 0x23, 0x4)
+    stream = StringInputStream("\x21\x43")
     class TestInteger(FieldSet):
         def createFields(self):
             yield Bits(self, "a", 4)
@@ -48,9 +46,8 @@
     assert test["c"].value == 4 
 
 def test2_str():
-    data = "\x19\x46" # concat(0x09, 0x61, 0x4)
-    
-    stream = FileStream(StringIO(data), None)
+    # data: concat numbers (0x09, 0x61, 0x4)
+    stream = StringInputStream("\x19\x46")
     class TestInteger(FieldSet):
         def createFields(self):
             yield Bits(self, "a", 4)
@@ -69,7 +66,7 @@
     data  += 3
     data = long2raw(data, big_endian=False)
     
-    stream = FileStream(StringIO(data), None)
+    stream = StringInputStream(data)
     class TestInteger(FieldSet):
         def createFields(self):
             yield Bits(self, "a", 2)
@@ -89,7 +86,7 @@
     data += (0 & 0x3) << 4
     data += (2 & 0x3) << 6
     data = chr(data)
-    stream = FileStream(StringIO(data), None)
+    stream = StringInputStream(data)
     class TestInteger(FieldSet):
         def createFields(self):
             yield Bit(self, "a")

Modified: haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py	2006-03-04 00:28:52 UTC (rev 433)
+++ haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py	2006-03-04 00:29:19 UTC (rev 434)
@@ -1,6 +1,6 @@
 from StringIO import StringIO
-from field import FieldSet, Integer, String, Bits, Bit
-from stream.file import FileStream
+from libhachoir.field import FieldSet, Integer, String, Bits, Bit
+from libhachoir.stream import StringInputStream
 
 class Header(FieldSet):
     def createFields(self):
@@ -18,8 +18,7 @@
         yield Body(self, "body", self.stream)
 
 def test():
-    data = "\x00\x0A\x00\x0B\x05\x07"
-    stream = FileStream(StringIO(data), None)
+    stream = StringInputStream("\x00\x0A\x00\x0B\x05\x07")
     document = Document(None, "document", stream)
     
     # Test path starting with "/"



From haypo at berlios.de  Sat Mar  4 01:30:10 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:30:10 +0100
Subject: [Happyboom-svn] r435 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/doc
Message-ID: <200603040030.k240UAeW001826@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:29:54 +0100 (Sat, 04 Mar 2006)
New Revision: 435

Added:
   haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt
Removed:
   haypo/hachoir/branches/hachoir-yield/doc/doc.txt
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/test_doc.py
Log:
 r29 at haypopc:  haypo | 2006-03-03 20:38:33 +0100
  * Split documentation in four files



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:28
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:29

Added: haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt	2006-03-04 00:29:19 UTC (rev 434)
+++ haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt	2006-03-04 00:29:54 UTC (rev 435)
@@ -0,0 +1,109 @@
+Write your own format FieldSet class
+====================================
+
+Input stream
+------------
+
+For different reasons (eg. addresses with bit granularity), Hachoir uses it's
+own stream classes. The most interesting class is FileStream. It's constructor
+need a file and a filename (optionnal, can be None).
+
+Here is a small example to create a stream:
+
+>>> from stream import StringInputStream
+>>> stream = StringInputStream("\x03abc")
+
+StringIO is a class which works like a file object but using a string as input
+data. Most interesting methods are:
+
+>>> stream.size            # get size in bits
+32
+>>> stream.getBits(0, 8)   # get 8 bits at address 0
+3
+>>> stream.getBytes(8, 3)  # get 3 bytes at address 8
+'abc'
+
+Support your own format using FieldSet
+--------------------------------------
+
+In the Hachoir, everything is stored in a field. The parent of all classes is
+the class Field, but it can't be used directly. They are four different types
+of fields:
+ * Bits: number with a size in bits ;
+ * Integer: number with a size in bytes ;
+ * String: string of characters with a size in bytes ;
+ * FieldSet: a ordered list of fields (contains other fields).
+
+A stream is splitted in several fields which are organised in a tree. So all
+fields have a parent, except of the root. Small example which will be used to
+parse the string "\x03abc" (stream of previous paragraph):
+
+>>> from field import FieldSet, Integer, String
+>>> class MyFormat(FieldSet):
+...     def createFields(self):
+...             yield Integer(self, "length", "uint8", "String length")
+...             yield String(self, "text", "string[%u]" % self["length"].value)
+...
+
+One goal in Hachoir is to make the write of a parser the more easy that it
+could be. You just have to write one method, createFields, which will create
+all fields.
+
+Another goal is to create the less fields as possible. In most cases, no field
+is created when a field set in instanciated. Fields are created when you access
+them by their name. That's why, the special Python keyword ''yield'' is used
+which permit to create only fields "on demand" (get more details about
+FieldSet internals in later section).
+
+Prototype of field classes are almost different, but the two first parameters
+are always the same:
+ * First one is the parent, of type FieldSet (is None for the root) ;
+ * The second is the name of the field.
+
+Ok, let's play with our new field set:
+
+>>> format = MyFormat(None, "myformat", stream)
+>>> format.size               # get size in bits
+32
+>>> format["text"].value
+'abc'
+>>> "length" in format        # test if the field 'length' does exist
+True
+>>> # Easiest way to display a field set content
+>>> for field in format:
+...     print "%s=%s" % (field.name, field.display)
+...
+length=3
+text="abc"
+
+Details about Field class
+-------------------------
+
+A field contains a lot of informations, attributes are:
+ * name: Field name, unique in his parent field set and can't be changed. It
+   is used as key to access to the field from the field set ;
+ * size: Size in bits, can't be changed ;
+ * address: Address in bits, relative to parent address, can't be changed ;
+ * absolute_address: Address in bits from the beginning of the stream ;
+ * parent: Parent of the field (is None for root field set) ;
+ * root: Root of all field sets ;
+ * value: Formatted value (integer, string, boolean, ...) value of the field.
+   Don't use this argument with print function, better use display attribute ;
+ * display: A string representing field value, has limited size ;
+ * path: Full "path" of the field from the root (eg. "/png/header/content") ;
+ * is_field_set: If the value is True, the field contains other fields, it's
+   a field set.
+
+Examples:
+>>> field = format["text"]
+>>> field.name
+'text'
+>>> field.path
+'/myformat/text'
+>>> field.value
+'abc'
+>>> field.size
+24
+>>> field.address
+8
+

Deleted: haypo/hachoir/branches/hachoir-yield/doc/doc.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/doc.txt	2006-03-04 00:29:19 UTC (rev 434)
+++ haypo/hachoir/branches/hachoir-yield/doc/doc.txt	2006-03-04 00:29:54 UTC (rev 435)
@@ -1,260 +0,0 @@
-Introduction
-============
-
-Hachoir is a library written in Python to access binary streams using
-nice API. It aims to be easy to use (hide complex mechanisms) and only read
-or compute data when it's really needed.
-
-Examples of Hachoir use: extract some informations from a file (size of an
-image, author of a music, comment of an archive, etc.), edit some fields of
-a file, convert a format to another one.
-
-Write your own format FieldSet class
-====================================
-
-Input stream
-------------
-
-For different reasons (eg. addresses with bit granularity), Hachoir uses it's
-own stream classes. The most interesting class is FileStream. It's constructor
-need a file and a filename (optionnal, can be None).
-
-Here is a small example to create a stream:
-
->>> from stream import StringInputStream
->>> stream = StringInputStream("\x03abc")
-
-StringIO is a class which works like a file object but using a string as input
-data. Most interesting methods are:
-
->>> stream.size            # get size in bits
-32
->>> stream.getBits(0, 8)   # get 8 bits at address 0
-3
->>> stream.getBytes(8, 3)  # get 3 bytes at address 8
-'abc'
-
-Support your own format using FieldSet
---------------------------------------
-
-In the Hachoir, everything is stored in a field. The parent of all classes is
-the class Field, but it can't be used directly. They are four different types
-of fields:
- * Bits: number with a size in bits ;
- * Integer: number with a size in bytes ;
- * String: string of characters with a size in bytes ;
- * FieldSet: a ordered list of fields (contains other fields).
-
-A stream is splitted in several fields which are organised in a tree. So all
-fields have a parent, except of the root. Small example which will be used to
-parse the string "\x03abc" (stream of previous paragraph):
-
->>> from field import FieldSet, Integer, String
->>> class MyFormat(FieldSet):
-...     def createFields(self):
-...             yield Integer(self, "length", "uint8", "String length")
-...             yield String(self, "text", "string[%u]" % self["length"].value)
-...
-
-One goal in Hachoir is to make the write of a parser the more easy that it
-could be. You just have to write one method, createFields, which will create
-all fields.
-
-Another goal is to create the less fields as possible. In most cases, no field
-is created when a field set in instanciated. Fields are created when you access
-them by their name. That's why, the special Python keyword ''yield'' is used
-which permit to create only fields "on demand" (get more details about
-FieldSet internals in later section).
-
-Prototype of field classes are almost different, but the two first parameters
-are always the same:
- * First one is the parent, of type FieldSet (is None for the root) ;
- * The second is the name of the field.
-
-Ok, let's play with our new field set:
-
->>> format = MyFormat(None, "myformat", stream)
->>> format.size               # get size in bits
-32
->>> format["text"].value
-'abc'
->>> "length" in format        # test if the field 'length' does exist
-True
->>> # Easiest way to display a field set content
->>> for field in format:
-...     print "%s=%s" % (field.name, field.display)
-...
-length=3
-text="abc"
-
-Details about Field class
--------------------------
-
-A field contains a lot of informations, attributes are:
- * name: Field name, unique in his parent field set and can't be changed. It
-   is used as key to access to the field from the field set ;
- * size: Size in bits, can't be changed ;
- * address: Address in bits, relative to parent address, can't be changed ;
- * absolute_address: Address in bits from the beginning of the stream ;
- * parent: Parent of the field (is None for root field set) ;
- * root: Root of all field sets ;
- * value: Formatted value (integer, string, boolean, ...) value of the field.
-   Don't use this argument with print function, better use display attribute ;
- * display: A string representing field value, has limited size ;
- * path: Full "path" of the field from the root (eg. "/png/header/content") ;
- * is_field_set: If the value is True, the field contains other fields, it's
-   a field set.
-
-Examples:
->>> field = format["text"]
->>> field.name
-'text'
->>> field.path
-'/myformat/text'
->>> field.value
-'abc'
->>> field.size
-24
->>> field.address
-8
-
-Some Hachoir internals
-======================
-
-When a field is really created?
--------------------------------
-
-A field is created when someone ask to access it, or when another field is
-asked and the field is before it. So if you use a field in your field set
-constructor, one or more fields will be created.
-
-Example:
->>> from field import FieldSet, Integer, String
->>> class Point(FieldSet):
-...     def __init__(self, parent, name, stream, description="Point"):
-...         FieldSet.__init__(self, parent, name, stream, description)
-...         if self["color"].value == -1:
-...             self.description += " (no color)"
-...
-...     def createFields(self):
-...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
-...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
-...         yield Integer(self, "x", "int8", "X axis value")
-...         yield Integer(self, "y", "int8", "Y axis value")
-...         if self["use_3d"] == 1:
-...             yield Integer(self, "z", "int8", "Z axis value")
-...
-
-In the constructor, the field "color" is asked. So the field list will
-contains one field (color):
->>> stream = StringInputStream("\x2A\x00\x04\x05")
->>> p = Point(None, "point", stream)
->>> len(p.fields)
-1
-
-WARNING: Only access 'fields' attribute if you know what you are doing.
-
-If you access another field, the field list will grow up until the requested
-field is reached:
->>> x = p["x"].value
->>> len(p.fields)
-3
-
-Some field set methods which create new fields:
- * __getitem__(): feed field list until requested field is reached
-   (or raise MissingField exception) ;
- * __len__(): create all fields ;
- * __iter__(): begin to iterate in existing fields, and the iterate in new
-   fields until all fields are created ;
- * __contains__(): feed field list until requested field is reached, may
-   create all fields if the field is missing.
-
-The size attribute also interact with field list creation, but it's mechanism
-is little bit more complex. By default, the whole field list have to be built
-before size value can be read. But you can specify field list size:
- * if field list is fixed, use class attribute static_size ;
- * else you can set _size instance attribute in the constructor.
-
-Two examples:
->>> class FourBytes(FieldSet):
-...     static_size = 32
-...     def createFields(self):
-...         yield Integer(self, "four", "uint32")
-...
->>> class DynamicSize(FieldSet):
-...     def __init__(self, parent, name, stream, nb_items, description="Point"):
-...         FieldSet.__init__(self, parent, name, stream, description)
-...         self.nb_items = nb_items
-...         self._size = nb_items * 32   # 32 is the size of one item
-...
-...     def createFields(self):
-...         for index in range(self.nb_items):
-...             yield Integer(self, "item[]", "uint32")
-...
-
-When the value of a field is read?
-----------------------------------
-
-When a field is created, the value of the field doesn't exist (equals to
-None). The value is really read when you read the field value using '.value'
-or '.display' field attributes. The value is then stored in the field.
-
-Details about field name
-------------------------
-
-The name of a field have to be unique in a field set because it is used as
-key in the field list. The argument 'name' of the Field constructor can be
-changed in the the constructor, but should not (and can no) be changed after
-that.
-
-For arrays, you can use the 'magic' prefix ? [] ? (eg. "item[]") which will
-be replaced by ? [index] ? where the number index is a counter starting a
-zero.
-
-Endian
-------
-
-The "endian" is the way in which ''bytes'' are stored. There are two important
-orders:
- * ? Big endian ? in which _big_ numbers are written first (Intel x86 CPU)
- * ? Little endian ? in which _little_ numbers are written first (PowerPC CPU)
-
-The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
-little endian.
-
-The endian is global to a FieldSet and is a class attribute. Two allowed
-values are "<" (little endian) and ">" (big endian). Default value is the
-international network order: "<", big endian.
-
-Example to set endian:
->>> class UseLittleEndian(FieldSet):
-...     endian = ">"
-...     # (...)
-...
-
-Explore a field set using it's path
------------------------------------
-
-Fields are stored in a tree. To explore the tree you have differents tools:
- * attribute root of a field which go to tree root ;
- * attribute parent go to field parent (is None for tree root) ;
- * and you can specify a path in __getitem__() argument.
-
-There are differents valid syntax of a path:
- * path to a child of current node: field["content"] ;
- * path to a child of the parent: field["../brother"] ;
- * path from the root: field["/header/key"].
-
-Event handling
---------------
-
-Code is not finished yet, so don't need documentation :-) See:
- * FieldSet.connect(event, handler)
- * FieldSet.raiseEvent(event,  arg1, arg2, ...)
-
-Get more informations
-=====================
-
-Hachoir website:
-   http://www.haypocalc.com/wiki/Hachoir
-

Modified: haypo/hachoir/branches/hachoir-yield/test_doc.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:29:19 UTC (rev 434)
+++ haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-04 00:29:54 UTC (rev 435)
@@ -1,16 +1,23 @@
 import doctest, sys, os
+from stat import S_ISREG, ST_MODE
 
 def testDoc(filename, name=None):
-    print "Run test in %s" % filename
+    print "--- %s: Run tests" % filename
     doctest.testfile(filename, optionflags=doctest.ELLIPSIS, name=name)
-    print "End of all tests of %s" % filename
+    print "--- %s: End of tests" % filename
 
 def main():
     root_dir = os.path.dirname(__file__)
     hachoir_path = "libhachoir"
     sys.path.append(hachoir_path)
 
-    testDoc('doc/doc.txt', "Main document")
+    doc_dir = 'doc'
+    documents = os.listdir(doc_dir)
+    documents.sort()
+    for doc in documents:
+        filename = os.path.join(doc_dir, doc)
+        if S_ISREG(os.stat(filename)[ST_MODE]):
+            testDoc(filename)
 
 if __name__ == "__main__":
     main()



From haypo at berlios.de  Sat Mar  4 01:30:32 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:30:32 +0100
Subject: [Happyboom-svn] r436 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/parser/image
Message-ID: <200603040030.k240UWoe002129@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:30:28 +0100 (Sat, 04 Mar 2006)
New Revision: 436

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
   haypo/hachoir/branches/hachoir-yield/metadata.py
Log:
 r30 at haypopc:  haypo | 2006-03-03 20:52:55 +0100
  * Create FileInputStream, it's constructor just takes a filename
  * Improve metadata from PCX and BMP images
  * MetaData.__str__() returns multi-line text



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:29
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:30

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:29:54 UTC (rev 435)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:30:28 UTC (rev 436)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-VERSION = "0.2veryalpha"
+VERSION = "0.2 (alpha)"
 
 import sys, os, getopt
 
@@ -66,7 +66,7 @@
     filename = parseArgs()
 
     # Get tools that we need from libhachoir
-    from libhachoir.stream import InputStream
+    from libhachoir.stream import FileInputStream
     from text_ui import displayFieldSet
     from libhachoir.plugin import loadParserPlugins, guessParser
     from libhachoir.log import log
@@ -76,7 +76,7 @@
     import libhachoir.config as config
 
     # Create input stream (read filename from command line first argument)
-    stream = InputStream(open(filename, 'r'), filename)
+    stream = FileInputStream(filename)
 
     # Load all parser plugings from 'file' directory
     root_dir = libhachoir_path

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-04 00:29:54 UTC (rev 435)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-04 00:30:28 UTC (rev 436)
@@ -6,11 +6,16 @@
 Creation: 16 december 2005
 """
 
-from field import FieldSet, Integer, String, ParserError
+from field import FieldSet, Integer, String, ParserError, Enum
 
 class BmpFile(FieldSet):
     mime_types = ["image/x-ms-bmp", "image/x-bmp"]
     endian = "<"
+
+    compression_name = {
+        0: "Uncopressed",
+        1: "RLE"
+    }        
     
     def createFields(self):
         yield String(self, "header", "string[2]", "Header (\"BM\")")
@@ -31,7 +36,7 @@
         yield Integer(self, "nb_plan", "uint16", "Number of plan (=1)")
         yield Integer(self, "bpp", "uint16", "Bits per pixel")
         if self["header_size"].value == 40:
-            yield Integer(self, "compression", "uint32", "Compression method")
+            yield Enum(self, "compression", "uint32", BmpFile.compression_name, "Compression method")
             yield Integer(self, "image_size", "uint32", "Image size (bytes)")
             yield Integer(self, "horizontal_dpi", "uint32", "Horizontal DPI")
             yield Integer(self, "vertical_dpi", "uint32", "Vertical DPI")

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:29:54 UTC (rev 435)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:30:28 UTC (rev 436)
@@ -3,16 +3,16 @@
 def getFileSize(stream):
     """ Get file size in bits """
     oldpos = stream.tell()
-    stream.seek(0,2)
-    size = stream.tell() * 8
-    stream.seek(oldpos)
     return size
 
 class InputStreamError(Exception):
     pass
 
-def FileInputStream(input, filename):
-    size = getFileSize(input) * 8
+def FileInputStream(filename):
+    input = open(filename, 'r')
+    input.seek(0, 2)
+    size = input.tell() * 8
+    input.seek(0)
     return InputStream(input, filename=filename, size=size)
 
 def StringInputStream(content):

Modified: haypo/hachoir/branches/hachoir-yield/metadata.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:29:54 UTC (rev 435)
+++ haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:30:28 UTC (rev 436)
@@ -18,16 +18,16 @@
         self.format = kw.get("format", None)
 
     def __str__(self):
-        text = "Image: "
+        attributes = [""]
         if self.format != None:
-            text += "format=%s, " % self.format 
-        text += "size=%sx%s, bpp=%s" % \
-            (self.width, self.height, self.bits_per_pixel)
+            attributes.append ("format: %s, " % self.format)
+        attributes.append ("size: %sx%s (pixels)" % (self.width, self.height))
+        attributes.append ("bits/pixel: %s" % self.bits_per_pixel)
         if self.nb_colors != None:
-            text += ", nb_colors=%s" % self.nb_colors
+            attributes.append("number of colors: %s" % self.nb_colors)
         if self.compression != None:
-            text += ", compression=%s" % self.compression
-        return text
+            attributes.append("compression: %s" % self.compression)
+        return "Image:"+"\n  - ".join(attributes)
 
 class BmpMetaData(ImageMetaData):
     def __init__(self, bmp):
@@ -37,17 +37,15 @@
             nb_colors = bmp["used_colors"].value 
         else:
             nb_colors = None
-        if bmp["compression"].value != 0:
-            compression = "(compressed)"
-        else:
-            compression = "No"
-        ImageMetaData.__init__(self, width, height, bpp, nb_colors=nb_colors)
+        compression = bmp["compression"].display
+        ImageMetaData.__init__(self, width, height, bpp, nb_colors=nb_colors, compression=compression)
 
 class PcxMetaData(ImageMetaData):
     def __init__(self, pcx):
         width, height = pcx["xmax"].value+1, pcx["ymax"].value+1
         bpp = pcx["bpp"].value
-        ImageMetaData.__init__(self, width, height, bpp)
+        compression = "RLE"
+        ImageMetaData.__init__(self, width, height, bpp, compression=compression)
 
 class PngMetaData(ImageMetaData):
     def __init__(self, png):



From haypo at berlios.de  Sat Mar  4 01:30:59 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:30:59 +0100
Subject: [Happyboom-svn] r437 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser branches/hachoir-yield/libhachoir/parser/3d branches/hachoir-yield/libhachoir/parser/image branches/hachoir-yield/unit_test
Message-ID: <200603040030.k240UxQK002411@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:30:47 +0100 (Sat, 04 Mar 2006)
New Revision: 437

Added:
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/__init__.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
   haypo/hachoir/branches/hachoir-yield/run_unit_test.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
   haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py
Log:
 r31 at haypopc:  haypo | 2006-03-03 22:59:44 +0100
  * Add command line options: --max-depth and --metadata
  * Integer now inherit from Bits (like Bit)
  * Remove IntegerHex because Integer now have 'text_handler' optionnal argument
  * Create RawBytes class and String now accept 'C' string format
  * Add method searchBytes() to InputStream class
  * Write unit test for InputStream.searchBytes()



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:30
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:31

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -5,6 +5,8 @@
 import sys, os, getopt
 
 cmd_line_options = ( \
+    ("metadata", "Read meta dats"),
+    ("max-depth=", "Maximum depth of displayed tree"),
     ("verbose", "Activate verbose mode"),
     ("help", "Show this help"),
     ("quiet", "Be quiet (don't display warning)"),
@@ -26,8 +28,9 @@
         else:
             print "   --%s : %s" % (opt[0].ljust(width), opt[1])
 
-def parseArgs():
+def parseArgs(options):
     import libhachoir.config as config
+    from libhachoir.log import log
 
     try:
         allowed = [ option[0] for option in cmd_line_options ]
@@ -54,6 +57,14 @@
             config.verbose = True
         elif option == "--debug":
             config.debug = True
+        elif option == "--metadata":
+            options["metadata"] = value
+        elif option == "--max-depth":   
+            try:
+                options["max-depth"] = int(value)
+            except ValueError:
+                log.warning("Invalid value for maximum depth: \"%s\"!" % value)
+
     return filename 
 
 def main():
@@ -63,7 +74,12 @@
     sys.path.append(libhachoir_path)
     
     # Parser command line arguments
-    filename = parseArgs()
+    options = {
+        "max-depth": 3,
+        "display": True,
+        "metadata": False 
+    }
+    filename = parseArgs(options)
 
     # Get tools that we need from libhachoir
     from libhachoir.stream import FileInputStream
@@ -98,14 +114,17 @@
     field_set = plugin(None, "file", stream)
 
     # Display the field set 
-#    displayFieldSet(field_set, 1)
+    if options["display"]:
+        max_depth = options["max-depth"]
+        displayFieldSet(field_set, max_depth) # , options={"parent-details": True})
 
     # Metadata
-    metadata = createMetaData(field_set)
-    if metadata != None:
-        print metadata
-    else:
-        warning("Can't create meta datas")
+    if options["metadata"]:
+        metadata = createMetaData(field_set)
+        if metadata != None:
+            print metadata
+        else:
+            warning("Can't create meta datas")
 
 if __name__ == "__main__":
     main()

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,4 +1,4 @@
 from libhachoir.field.field import Field
-from libhachoir.field.integer import Integer, IntegerHex, Enum, Bits, Bit
-from libhachoir.field.string_field import String
+from libhachoir.field.integer import Integer, Enum, Bits, Bit
+from libhachoir.field.string_field import RawBytes, String
 from libhachoir.field.field_set import FieldSet, ParserError

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,7 +1,10 @@
+class FieldError(Exception):
+    pass
+
 class Field(object):
     is_field_set = False
     
-    def __init__(self, parent, name, value, size=None, address=None, description=None):
+    def __init__(self, parent, name, value=None, size=None, address=None, description=None):
         assert parent == None or issubclass(parent.__class__, Field)
         self.parent = parent
         self._name = name 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -5,12 +5,13 @@
 class Bits(Field):
     def __init__(self, parent, name, size, description=None):
         assert issubclass(parent.__class__, Field)
-        Field.__init__(self, parent, name, None, size, description=description)
+        Field.__init__(self, parent, name, size=size, description=description)
+        self.big_endian = True
 
     def _getValue(self):
         if self._value == None:
             self._value = self.parent.stream.getBits(
-                self.absolute_address, self.size, True) 
+                self.absolute_address, self.size, self.big_endian) 
         return self._value
     value = property(_getValue, Field._setValue)
    
@@ -25,44 +26,38 @@
     def _getValue(self):
         if self._value == None:
             data = self.parent.stream.getBits(
-                self.absolute_address, self.size, True) 
+                self.absolute_address, 1, True) 
             self._value = (data == 1)
         return self._value
     value = property(_getValue, Field._setValue)
    
-class Integer(Field):
-    def __init__(self, parent, name, format, description=None):
-        assert issubclass(parent.__class__, Field)
+class Integer(Bits):
+    def __init__(self, parent, name, format, description=None, text_handler=None):
         if format[0] not in "!<>":
             self.format = parent.endian + format
         else:
             self.format = format
-        size = getFormatSize(format)*8
-        Field.__init__(self, parent, name, None, size, description=description)
+        Bits.__init__(self, parent, name, getFormatSize(format)*8, description)
+        self.big_endian = (self.format[0] == "<") 
+        self.text_handler = text_handler
 
-    def _getValue(self):
-        if self._value == None:
-            self._value = self.parent.stream.getBits(
-                self.absolute_address, self.size, self.parent.endian=="<")
-        return self._value
-    value = property(_getValue, Field._setValue)
-   
     def _getDisplay(self):
-        return self.value
+        if self.text_handler != None:
+            return self.text_handler(self)
+        else:
+            return self.value
     display = property(_getDisplay)
 
-class IntegerHex(Integer):   
-    def _getDisplay(self):
-        return hexadecimal(self)
-    display = property(_getDisplay)
-
 class Enum(Integer):   
-    def __init__(self, parent, name, format, enum, description=None):
+    def __init__(self, parent, name, format, enum, description=None, text_handler=None):
         self.enum = enum
-        Integer.__init__(self, parent, name, format, description)
+        Integer.__init__(self, parent, name, format, description, text_handler)
     
     def _getDisplay(self):
-        value = self.value
-        return self.enum.get(value, value)
+        key = self.value 
+        if key in self.enum:
+            return self.enum[key]
+        else:
+            return Integer._getDisplay(self)
     display = property(_getDisplay)
 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,37 +1,73 @@
-from field import Field
+from field import Field, FieldError
 from libhachoir.format import getFormatSize
 from libhachoir.tools import convertDataToPrintableString
 
-class String(Field):
-    def __init__(self, parent, name, format, description=None):
+class RawBytes(Field):
+    def __init__(self, parent, name, length, description="Raw data"):
         assert issubclass(parent.__class__, Field)
-        self.format = format
-        size = getFormatSize(format)*8
-        Field.__init__(self, parent, name, None, size, description=description)
+        Field.__init__(self, parent, name, size=length*8, description=description)
         
-    def _getDisplay(self):
-        max = 20
+    def _getTruncated(self, address, length, max_bytes=20):
         if self._value == None:
-            assert (self.size % 8) == 0
-            if max < self._size/8:
+            if max_bytes < length:
                 display = self.parent.stream.getBytes( \
-                    self.absolute_address, max)
+                    address, max_bytes)
                 display += "(...)"
             else:
                 self._value = self.parent.stream.getBytes( \
-                    self.absolute_address, self._size / 8)
+                    address, length)
                 display = self._value
         else:
-            display = self._value[:max]
-            if max < self._size/8:
+            display = self._value[:max_bytes]
+            if max_bytes < length:
                 display += "(...)"
         return convertDataToPrintableString(display)
+    
+    def _getDisplay(self):
+        return self._getTruncated(self.absolute_address, self._size/8)
     display = property(_getDisplay)        
     
     def _getValue(self):
         if self._value == None:
-            assert (self.size % 8) == 0
+            assert (self._size % 8) == 0
             self._value = self.parent.stream.getBytes( \
-                self.absolute_address, self.size / 8)
+                self.absolute_address, self._size / 8)
         return self._value
-    value = property(_getValue, Field._setValue)
+    value = property(_getValue, Field._setValue)        
+
+class String(RawBytes):
+    def __init__(self, parent, name, format, description=None):
+        RawBytes.__init__(self, parent, name, 0, description)
+        self._begin_offset = 0 # in bytes
+        self._end_offset = 0 # in bytes
+        if format == "C":
+            self._end_offset = 1
+            start = self.absolute_address
+            stop = parent.stream.searchBytes("\0", start)
+            if stop is None:
+                raise FieldError("Can't find end of string %s ('\\0')!" \
+                    % self.path)
+            self._size = stop - start + 8 
+        else:
+            self._size = getFormatSize(format) * 8
+        self._length = (self._size / 8) - self._begin_offset - self._end_offset
+        assert 0 <= self._length
+
+    def _getLength(self):
+        return self._length
+    length = property(_getLength)
+    
+    def _getDisplay(self):
+        return self._getTruncated( \
+            self.absolute_address + self._begin_offset, \
+            self._length)
+    display = property(_getDisplay)        
+
+    def _getValue(self):
+        if self._value == None:
+            assert (self._size % 8) == 0
+            self._value = self.parent.stream.getBytes( \
+                self.absolute_address + self._begin_offset*8, self._length)
+        return self._value
+    value = property(_getValue, Field._setValue)        
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/__init__.py
===================================================================

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -6,7 +6,7 @@
 Creation: 16 december 2005
 """
 
-from field import FieldSet, Integer, String, ParserError, Enum
+from field import FieldSet, Integer, RawBytes, ParserError, Enum
 
 class BmpFile(FieldSet):
     mime_types = ["image/x-ms-bmp", "image/x-bmp"]
@@ -18,7 +18,7 @@
     }        
     
     def createFields(self):
-        yield String(self, "header", "string[2]", "Header (\"BM\")")
+        yield RawBytes(self, "header", "string[2]", "Header (\"BM\")")
         if self["header"].value != "BM": 
             raise ParserError(
                 "BMP picture parser error: indentifier is uncorrect")

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -2,7 +2,7 @@
 PCX picture filter.
 """
 
-from field import FieldSet, Integer, String
+from field import FieldSet, Integer, RawBytes 
 from common import Palette
 
 class PcxFile(FieldSet):
@@ -29,13 +29,13 @@
         yield Integer(self, "nb_color_plan", "uint8", "Number of color plans")
         yield Integer(self, "bytes_per_line", "uint16", "Bytes per line")
         yield Integer(self, "color_mode", "uint16", "Color mode")
-        yield String(self, "reserved2", "string[58]", "Reserved")
+        yield RawBytes(self, "reserved2", 58, "Reserved")
 
         size = self.stream.getSize() - self.stream.tell()
         has_palette = (self["bpp"].value == 8)
         if has_palette:
             size -= 256*3*8            
-        yield String(self, "data", "string[%u]" % size, "Image data")
+        yield RawBytes(self, "data", size, "Image data")
 
         if has_palette:
             yield Palette(self, "palette_8bits", 256, "Palette (8 bit)")

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,6 +1,7 @@
-from field import FieldSet, Integer, String, IntegerHex, Bit, Bits, ParserError
+from field import FieldSet, Integer, RawBytes, Bit, Bits, ParserError
 from common import RGB
 from bits import str2hex
+from text_handler import hexadecimal
 
 class HeaderFlags(FieldSet):
     def createFields(self):
@@ -68,7 +69,7 @@
 
     def createFields(self):
         yield Integer(self, "size", "uint32", "Size")
-        yield String(self, "type", "string[4]", "Type")
+        yield RawBytes(self, "type", 4, "Type")
 
         type = self["type"].value
         if type in self.handler:
@@ -79,14 +80,14 @@
             yield cls(self, "content", self.stream)
 #            assert stream.tell() == (oldpos + size) 
         else:
-            yield String(self, "content", "string[%u]" % self["size"].value, "Data")
-        yield IntegerHex(self, "crc32", "uint32", "CRC32")
+            yield RawBytes(self, "content", self["size"].value, "Data")
+        yield Integer(self, "crc32", "uint32", "CRC32", text_handler=hexadecimal)
 
 class PngFile(FieldSet):
     mime_types = ["image/png", "image/x-png"]
 
     def createFields(self):
-        yield String(self, "id", "string[8]", "PNG identifier") 
+        yield RawBytes(self, "id", 8, "PNG identifier") 
         if self["id"].value != "\x89PNG\r\n\x1A\n":
             raise ParserError("Png parser: file identifier looks wrong (%s instead of %s)" % \
                 (str2hex(self["id"].value), str2hex("\x89PNG\r\n\x1A\n")))

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,7 +1,7 @@
 import re, os
 from stat import S_ISDIR, ST_MODE
 from mime import getFileMime, getStreamMime
-from error import warning
+from error import error 
 
 hachoir_parsers = {} 
 
@@ -13,7 +13,7 @@
         for get in module_path.split(".")[1:]:
             module = getattr(module, get)
     except Exception, msg:
-        warning("Error while loading the plugin \"%s\": %s" \
+        error("Error while loading the plugin \"%s\": %s" \
             % (module_path, msg))
         return
     for attr in module.__dict__:

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,10 +1,5 @@
 from cStringIO import StringIO
 
-def getFileSize(stream):
-    """ Get file size in bits """
-    oldpos = stream.tell()
-    return size
-
 class InputStreamError(Exception):
     pass
 
@@ -25,6 +20,11 @@
         if size == 0:
             raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
         self._size = size
+
+        # TODO: Doesn't support computation of last byte address with bit
+        # address
+        assert (self._size % 8) == 0
+        self._last_byte_address = self._size / 8 - 1
         self._input = input 
         
     def _getSize(self):
@@ -95,3 +95,45 @@
                 (nb_bytes, address/8, len(data)))
         return data
 
+    def searchBytes(self, needle, start_address=0, end_address=None):
+        """
+        Search some bytes between start_address and end_address
+
+        Returns the address of the bytes if founded, None else
+        """
+
+        if end_address == None:
+            end_address = self._last_byte_address * 8
+        if end_address < start_address:
+            return None
+        
+        # TODO: Doesn't suppport bit address yet :-(
+        assert (start_address % 8) == 0
+        assert (end_address % 8) == 0
+
+        size = 2048 
+        if size <= len(needle):
+            raise InputStreamError("Search string too big.")
+        doublesize = size * 2
+
+        address = start_address 
+        max = end_address - start_address + 1
+        if max<doublesize:
+            doublesize = max/8 
+            size = 0 
+        buffer = self.getBytes(address, doublesize)
+
+        new_address = address + size
+        while len(buffer) != 0:
+            found = buffer.find(needle)
+            if found != -1:
+                return address + found*8
+            address = new_address
+            if end_address < address + size:
+                size = end_address - address
+            if size == 0:
+                break
+            buffer = buffer[size:] + self.getBytes(address, size)
+            new_address = address + size 
+        return None
+

Modified: haypo/hachoir/branches/hachoir-yield/run_unit_test.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/run_unit_test.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/run_unit_test.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,10 +1,12 @@
 from unit_test import create_fields
 from unit_test import field_set_get_item
+from unit_test import stream_search
 import sys, os
 
 def runAllTests():
     create_fields.runTests()
     field_set_get_item.runTests()
+    stream_search.runTests()
 
 def main():
     # Load Hachoir library

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,20 +1,27 @@
-def displayFieldSet(field_set, max_depth=2, depth=0):
-    parent_details = False
-    display_bits = False
+def displayFieldSet(field_set, max_depth=2, depth=0, options={}):
+    display_parent_addr = options.get("parent-addr", False)
+    display_parent_size = options.get("parent-size", True)
+    display_bits = options.get("bit-addr", False)
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     text = "%s--- %s ---" % (indent, field_set.name) 
-    if parent_details:
+    if display_parent_addr or display_parent_size:
+        info = []
         if display_bits:
-            text += "(addr=%u.%u, size=%s bits)" \
-                % (addr/8, addr%8, field_set.size)
+            if display_parent_addr:
+                info.append( "addr=%u.%u" % (addr/8, addr%8) )
+            if display_parent_size:
+                info.append( "size=%s bits" % field_set.size )
         else:
             assert (addr % 8) == 0
             assert (field_set.size % 8) == 0
-            text += "(addr=%u, size=%s bytes)" \
-                % (addr/8, field_set.size/8)
+            if display_parent_addr:
+                info.append( "addr=%u" % (addr/8) )
+            if display_parent_size:
+                info.append( "size=%s bytes" % (field_set.size/8) )
+        text += " (%s)" % (", ".join(info))
     print text
-    if max_depth == None or depth < max_depth:
+    if max_depth == None or max_depth < 0 or depth < max_depth:
         for field in field_set:
             if not field.is_field_set:
                 text = indent
@@ -23,15 +30,16 @@
                 else:
                     assert (field.address % 8) == 0
                     text += "%u" % (field.address/8)
-                text += ") %s = %s (%s)" % \
+                text += ") %s = %s: %s " % \
                     (field._name, field.display, field.description)
                 if display_bits:
                     text += "(size=%s bits)" % field.size
                 else:
                     assert (field.size % 8) == 0
                     text += "(size=%s bytes)" % (field.size / 8)
+                print text
             else:
-                displayFieldSet(field, max_depth, depth+1)
+                displayFieldSet(field, max_depth, depth+1, options)
     else:
         print "%s(...)" % indent
     if depth == 0:

Modified: haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py	2006-03-04 00:30:28 UTC (rev 436)
+++ haypo/hachoir/branches/hachoir-yield/unit_test/field_set_get_item.py	2006-03-04 00:30:47 UTC (rev 437)
@@ -1,4 +1,3 @@
-from StringIO import StringIO
 from libhachoir.field import FieldSet, Integer, String, Bits, Bit
 from libhachoir.stream import StringInputStream
 



From haypo at berlios.de  Sat Mar  4 02:36:21 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 02:36:21 +0100
Subject: [Happyboom-svn] r438 - in haypo/hachoir: . branches/hachoir-yield/doc branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser/3d branches/hachoir-yield/unit_test
Message-ID: <200603040136.k241aLkj021442@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 02:36:12 +0100 (Sat, 04 Mar 2006)
New Revision: 438

Added:
   haypo/hachoir/branches/hachoir-yield/doc/0-intro.txt
   haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt
   haypo/hachoir/branches/hachoir-yield/doc/3-end.txt
   haypo/hachoir/branches/hachoir-yield/libhachoir/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py
   haypo/hachoir/branches/hachoir-yield/unit_test/stream_search.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
Log:
Send changes from svk to svn using 'svk smerge -f'


Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:31
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:51

Added: haypo/hachoir/branches/hachoir-yield/doc/0-intro.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/0-intro.txt	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/doc/0-intro.txt	2006-03-04 01:36:12 UTC (rev 438)
@@ -0,0 +1,11 @@
+Introduction
+============
+
+Hachoir is a library written in Python to access binary streams using
+nice API. It aims to be easy to use (hide complex mechanisms) and only read
+or compute data when it's really needed.
+
+Examples of Hachoir use: extract some informations from a file (size of an
+image, author of a music, comment of an archive, etc.), edit some fields of
+a file, convert a format to another one.
+

Added: haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt	2006-03-04 01:36:12 UTC (rev 438)
@@ -0,0 +1,135 @@
+Some Hachoir internals
+======================
+
+When a field is really created?
+-------------------------------
+
+A field is created when someone ask to access it, or when another field is
+asked and the field is before it. So if you use a field in your field set
+constructor, one or more fields will be created.
+
+Example:
+>>> from field import FieldSet, Integer, String
+>>> class Point(FieldSet):
+...     def __init__(self, parent, name, stream, description="Point"):
+...         FieldSet.__init__(self, parent, name, stream, description)
+...         if self["color"].value == -1:
+...             self.description += " (no color)"
+...
+...     def createFields(self):
+...         yield Integer(self, "color", "int8", "Point color (-1 for none)")
+...         yield Integer(self, "use_3d", "int8", "Does it use Z axis?")
+...         yield Integer(self, "x", "int8", "X axis value")
+...         yield Integer(self, "y", "int8", "Y axis value")
+...         if self["use_3d"] == 1:
+...             yield Integer(self, "z", "int8", "Z axis value")
+...
+
+In the constructor, the field "color" is asked. So the field list will
+contains one field (color):
+>>> from stream import StringInputStream
+>>> stream = StringInputStream("\x2A\x00\x04\x05")
+>>> p = Point(None, "point", stream)
+>>> len(p.fields)
+1
+
+WARNING: Only access 'fields' attribute if you know what you are doing.
+
+If you access another field, the field list will grow up until the requested
+field is reached:
+>>> x = p["x"].value
+>>> len(p.fields)
+3
+
+Some field set methods which create new fields:
+ * __getitem__(): feed field list until requested field is reached
+   (or raise MissingField exception) ;
+ * __len__(): create all fields ;
+ * __iter__(): begin to iterate in existing fields, and the iterate in new
+   fields until all fields are created ;
+ * __contains__(): feed field list until requested field is reached, may
+   create all fields if the field is missing.
+
+The size attribute also interact with field list creation, but it's mechanism
+is little bit more complex. By default, the whole field list have to be built
+before size value can be read. But you can specify field list size:
+ * if field list is fixed, use class attribute static_size ;
+ * else you can set _size instance attribute in the constructor.
+
+Two examples:
+>>> class FourBytes(FieldSet):
+...     static_size = 32
+...     def createFields(self):
+...         yield Integer(self, "four", "uint32")
+...
+>>> class DynamicSize(FieldSet):
+...     def __init__(self, parent, name, stream, nb_items, description="Point"):
+...         FieldSet.__init__(self, parent, name, stream, description)
+...         self.nb_items = nb_items
+...         self._size = nb_items * 32   # 32 is the size of one item
+...
+...     def createFields(self):
+...         for index in range(self.nb_items):
+...             yield Integer(self, "item[]", "uint32")
+...
+
+When the value of a field is read?
+----------------------------------
+
+When a field is created, the value of the field doesn't exist (equals to
+None). The value is really read when you read the field value using '.value'
+or '.display' field attributes. The value is then stored in the field.
+
+Details about field name
+------------------------
+
+The name of a field have to be unique in a field set because it is used as
+key in the field list. The argument 'name' of the Field constructor can be
+changed in the the constructor, but should not (and can no) be changed after
+that.
+
+For arrays, you can use the 'magic' prefix ? [] ? (eg. "item[]") which will
+be replaced by ? [index] ? where the number index is a counter starting a
+zero.
+
+Endian
+------
+
+The "endian" is the way in which ''bytes'' are stored. There are two important
+orders:
+ * ? Big endian ? in which _big_ numbers are written first (Intel x86 CPU)
+ * ? Little endian ? in which _little_ numbers are written first (PowerPC CPU)
+
+The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
+little endian.
+
+The endian is global to a FieldSet and is a class attribute. Two allowed
+values are "<" (little endian) and ">" (big endian). Default value is the
+international network order: "<", big endian.
+
+Example to set endian:
+>>> class UseLittleEndian(FieldSet):
+...     endian = ">"
+...     # (...)
+...
+
+Explore a field set using it's path
+-----------------------------------
+
+Fields are stored in a tree. To explore the tree you have differents tools:
+ * attribute root of a field which go to tree root ;
+ * attribute parent go to field parent (is None for tree root) ;
+ * and you can specify a path in __getitem__() argument.
+
+There are differents valid syntax of a path:
+ * path to a child of current node: field["content"] ;
+ * path to a child of the parent: field["../brother"] ;
+ * path from the root: field["/header/key"].
+
+Event handling
+--------------
+
+Code is not finished yet, so don't need documentation :-) See:
+ * FieldSet.connect(event, handler)
+ * FieldSet.raiseEvent(event,  arg1, arg2, ...)
+

Added: haypo/hachoir/branches/hachoir-yield/doc/3-end.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/3-end.txt	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/doc/3-end.txt	2006-03-04 01:36:12 UTC (rev 438)
@@ -0,0 +1,6 @@
+Get more informations
+=====================
+
+Hachoir website:
+   http://www.haypocalc.com/wiki/Hachoir
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/__init__.py
===================================================================

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 01:36:12 UTC (rev 438)
@@ -1,4 +1,5 @@
 from libhachoir.field.field import Field
-from libhachoir.field.integer import Integer, Enum, Bits, Bit
+from libhachoir.field.bit_field import Bits, Bit
+from libhachoir.field.integer import Integer, Enum 
 from libhachoir.field.string_field import RawBytes, String
 from libhachoir.field.field_set import FieldSet, ParserError

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-04 01:36:12 UTC (rev 438)
@@ -0,0 +1,31 @@
+from libhachoir.field.field import Field
+
+class Bits(Field):
+    def __init__(self, parent, name, size, description=None):
+        assert issubclass(parent.__class__, Field)
+        Field.__init__(self, parent, name, size=size, description=description)
+        self.big_endian = True
+
+    def _getValue(self):
+        if self._value == None:
+            self._value = self.parent.stream.getBits(
+                self.absolute_address, self.size, self.big_endian) 
+        return self._value
+    value = property(_getValue, Field._setValue)
+   
+    def _getDisplay(self):
+        return self.value
+    display = property(_getDisplay)
+
+class Bit(Bits):
+    def __init__(self, parent, name, description=None):
+        Bits.__init__(self, parent, name, 1, description=description)
+
+    def _getValue(self):
+        if self._value == None:
+            data = self.parent.stream.getBits(
+                self.absolute_address, 1, True) 
+            self._value = (data == 1)
+        return self._value
+    value = property(_getValue, Field._setValue)
+ 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 01:36:12 UTC (rev 438)
@@ -1,36 +1,7 @@
-from field import Field
 from libhachoir.format import getFormatSize
 from libhachoir.text_handler import hexadecimal
-
-class Bits(Field):
-    def __init__(self, parent, name, size, description=None):
-        assert issubclass(parent.__class__, Field)
-        Field.__init__(self, parent, name, size=size, description=description)
-        self.big_endian = True
-
-    def _getValue(self):
-        if self._value == None:
-            self._value = self.parent.stream.getBits(
-                self.absolute_address, self.size, self.big_endian) 
-        return self._value
-    value = property(_getValue, Field._setValue)
-   
-    def _getDisplay(self):
-        return self.value
-    display = property(_getDisplay)
-
-class Bit(Bits):
-    def __init__(self, parent, name, description=None):
-        Bits.__init__(self, parent, name, 1, description=description)
-
-    def _getValue(self):
-        if self._value == None:
-            data = self.parent.stream.getBits(
-                self.absolute_address, 1, True) 
-            self._value = (data == 1)
-        return self._value
-    value = property(_getValue, Field._setValue)
-   
+from libhachoir.field.bit_field import Bits
+  
 class Integer(Bits):
     def __init__(self, parent, name, format, description=None, text_handler=None):
         if format[0] not in "!<>":

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py	2006-03-04 01:36:12 UTC (rev 438)
@@ -0,0 +1,189 @@
+"""
+3D Studio Max file (.3ds) parser.
+Author: Victor Stinner
+"""
+
+from libhachoir.field import FieldSet, Integer, RawBytes, Enum, String
+from libhachoir.parser.image.common import RGB
+
+#def readObject(self, stream, last_pos):
+#    yield String(self, "name", "C", "Object name")
+#    while self._total_field_size < last_pos:
+#        yield Chunk(self)
+#
+def readTextureFilename(parent):
+    yield String(parent, "filename", "C", "Texture filename")
+
+def readVersion(parent):
+    yield Integer(parent, "version", "uint32", "3DS file format version")
+
+def readMaterialName(parent):
+    yield String(parent, "name", "C", "Material name")
+
+#class Filter_3DS_MapUV(OnDemandFilter):
+#    def __init__(self, stream, parent):
+#        OnDemandFilter.__init__(self, "3ds_map", "3DS UV map", stream, parent, "<")
+#        self.read("u", "Map U", (FormatChunk, "float"))
+#        self.read("v", "Map V", (FormatChunk, "float"))
+#
+#    @staticmethod
+#    def getStaticSize(stream, args):
+#        return 4*2
+# 
+class Filter_3DS_Vertex(FieldSet):
+    static_size = 4*3*8
+    def __init__(self, parent, name="vertex[]", description="Vertex"):
+        FieldSet.__init__(self, parent, name, parent.stream, description=description)
+
+    def createFields(self):
+        self.read("x", "X", (FormatChunk, "float"))
+        self.read("y", "Y", (FormatChunk, "float"))
+        self.read("z", "Z", (FormatChunk, "float"))
+#
+#    @staticmethod
+#    def getStaticSize(stream, args):
+#        return 4*3
+#
+#class Filter_3DS_Polygon(OnDemandFilter):
+#    def __init__(self, stream, parent):
+#        OnDemandFilter.__init__(self, "3ds_polygon", "3DS polygon", stream, parent, "<")
+#        self.read("a", "Vertex A", (FormatChunk, "uint16"))
+#        self.read("b", "Vertex B", (FormatChunk, "uint16"))
+#        self.read("c", "Vertex C", (FormatChunk, "uint16"))
+#        self.read("flags", "Flags", (FormatChunk, "uint16"))
+#
+#    @staticmethod
+#    def getStaticSize(stream, args):
+#        return 4*2
+#    
+#def readMapList(filter, stream, last_pos):
+#    filter.read("count", "Map count", (FormatChunk, "uint16"))
+#    for i in range(0, filter["count"]):
+#        filter.read("map[]", "Map UV", (Filter_3DS_MapUV,))
+#
+def readColor(parent):
+    yield RGB(parent, "color", parent.stream)
+
+def readVertexList(parent):
+    count = Integer(parent, "count", "uint16", "Vertex count")
+    for i in range(0, count.value):
+        yield Vertex(parent)
+    
+#def readPolygonList(filter, stream, last_pos):
+#    filter.read("count", "Vertex count", (FormatChunk, "uint16"))
+#    for i in range(0, filter["count"]):
+#        filter.read("polygon[]", "Polygon", (Filter_3DS_Polygon,))
+#    while stream.tell() < last_pos:
+#        filter.read("chunk[]", "Chunk", (Filter_3DS_Chunk,))
+#
+class Chunk(FieldSet):
+    # List of chunk type name
+    type_name = {
+        0x0011: "Color",
+        0x4D4D: "Main chunk",
+        0x0002: "File version",
+        0x3D3D: "Materials and objects",
+        0x4000: "Object",
+        0x4100: "Mesh (triangular)",
+        0x4110: "Vertices list",
+        0x4120: "Polygon (faces) list",
+        0x4140: "Map UV list",
+        0x4130: "Object material",
+        0xAFFF: "New material",
+        0xA000: "Material name",
+        0xA010: "Material ambiant",
+        0xA020: "Material diffuse",
+        0xA030: "Texture specular",
+        0xA200: "Texture",
+        0xA300: "Texture filename",
+
+        # Key frames
+        0xB000: "Keyframes",
+        0xB002: "Object node tag",
+        0xB006: "Light target node tag",
+        0xB007: "Spot light node tag",
+        0xB00A: "Keyframes header",
+        0xB009: "Keyframe current time",
+        0xB030: "Node identifier",
+        0xB010: "Node header",
+        0x7001: "Viewport layout"
+    }
+
+    chunk_id_by_type = {
+        0x4d4d: "main",
+        0x0002: "version",
+        0x3d3d: "obj_mat",
+        0xb000: "keyframes",
+        0xafff: "material[]",
+        0x4000: "object",
+        0x4110: "vertices_list",
+        0x4120: "polygon_list",
+        0x4140: "mapuv_list",
+        0x4100: "mesh"
+    }
+
+    # List of chunks which contains other chunks
+    sub_chunks = \
+        (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
+         0xB002, 0xB006, 0xB007,
+         0xA010, 0xA030, 0xA020, 0xB000)
+
+    # List of chunk type handlers
+    handlers = {
+        0xA000: readMaterialName,
+#        0x4000: readObject,
+        0xA300: readTextureFilename,
+        0x0011: readColor,
+        0x0002: readVersion,
+        0x4110: readVertexList,
+#        0x4120: readPolygonList,
+#        0x4140: readMapList
+    }
+
+    endian = "<"
+    
+    def __init__(self, parent, name="chunk[]"):
+        FieldSet.__init__(self, parent, name, parent.stream)
+
+        # Set description
+        self.description = "Chunk: %s" % self["type"].display
+
+        # Set name based on type field
+        type = self["type"].value 
+        if type in Chunk.chunk_id_by_type:
+            self._name = Chunk.chunk_id_by_type[type]
+        else:
+            self._name = "chunk_%04x" % type
+
+        # Guess chunk size
+        self._size = self["size"].value * 8
+
+    def hexadecimal(self, field):
+        return "%04X" % field.value    
+
+    def createFields(self):        
+        yield Enum(self, "type", "uint16", Chunk.type_name, "Chunk type", text_handler=self.hexadecimal)
+        yield Integer(self, "size", "uint32", "Chunk size (in bytes)")
+        chunk_size = self["size"].value
+        content_size = chunk_size - 6
+        type = self["type"].value
+        if type in Chunk.sub_chunks:
+            while self._total_field_size < chunk_size*8:
+                yield Chunk(self)
+            assert self._total_field_size == (chunk_size * 8)
+        else:
+            if type in Chunk.handlers: 
+                fields = Chunk.handlers[type] (self)
+                for field in fields:
+                    yield field
+                assert self._total_field_size == (chunk_size * 8)
+            else:
+                yield RawBytes(self, "data", content_size)
+
+class Parser3dsFile(FieldSet):
+    mime_types = "image/x-3ds"
+
+    def createFields(self):
+        while self._total_field_size < self.stream.size:
+            yield Chunk(self)
+

Added: haypo/hachoir/branches/hachoir-yield/unit_test/stream_search.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/unit_test/stream_search.py	2006-03-04 00:30:47 UTC (rev 437)
+++ haypo/hachoir/branches/hachoir-yield/unit_test/stream_search.py	2006-03-04 01:36:12 UTC (rev 438)
@@ -0,0 +1,18 @@
+from libhachoir.field import FieldSet, Integer, String, Bits, Bit
+from libhachoir.stream import StringInputStream
+
+def test1():
+    stream = StringInputStream("\x00\x0A\x00\x0B\x05\x07")
+    assert stream.searchBytes("\x0A", 0) == 8
+    assert stream.searchBytes("\xFF", 0) == None
+    assert stream.searchBytes("\x00", 8) == 16
+
+def runTests():
+    print "Test FieldSet.__getitem__"
+    try:
+        test1()
+        print "Test FieldSet.__getitem__: done"
+    except Exception, msg:
+        print "Test FieldSet.__getitem__: error!"
+        print msg
+        raise



From haypo at berlios.de  Sat Mar  4 03:51:22 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 03:51:22 +0100
Subject: [Happyboom-svn] r439 - in haypo/hachoir: . branches/hachoir-yield/doc
Message-ID: <200603040251.k242pMAp006970@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 03:51:10 +0100 (Sat, 04 Mar 2006)
New Revision: 439

Added:
   haypo/hachoir/branches/hachoir-yield/doc/Makefile
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt
   haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt
Log:
Update documentation


Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:51
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:54

Modified: haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt	2006-03-04 01:36:12 UTC (rev 438)
+++ haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt	2006-03-04 02:51:10 UTC (rev 439)
@@ -5,16 +5,14 @@
 ------------
 
 For different reasons (eg. addresses with bit granularity), Hachoir uses it's
-own stream classes. The most interesting class is FileStream. It's constructor
-need a file and a filename (optionnal, can be None).
+own stream classes: ``InputStream``. But don't use it directly, use
+``FileInputStream`` function (needs a filename) or ``StringInputStream``
+(needs a string). Here is a small example to create a stream:
 
-Here is a small example to create a stream:
-
 >>> from stream import StringInputStream
 >>> stream = StringInputStream("\x03abc")
 
-StringIO is a class which works like a file object but using a string as input
-data. Most interesting methods are:
+Most interesting methods are:
 
 >>> stream.size            # get size in bits
 32
@@ -29,10 +27,10 @@
 In the Hachoir, everything is stored in a field. The parent of all classes is
 the class Field, but it can't be used directly. They are four different types
 of fields:
- * Bits: number with a size in bits ;
- * Integer: number with a size in bytes ;
- * String: string of characters with a size in bytes ;
- * FieldSet: a ordered list of fields (contains other fields).
+* Bits: number with a size in bits ;
+* Integer: number with a size in bytes ;
+* String: string of characters with a size in bytes ;
+* FieldSet: a ordered list of fields (contains other fields).
 
 A stream is splitted in several fields which are organised in a tree. So all
 fields have a parent, except of the root. Small example which will be used to
@@ -57,9 +55,10 @@
 
 Prototype of field classes are almost different, but the two first parameters
 are always the same:
- * First one is the parent, of type FieldSet (is None for the root) ;
- * The second is the name of the field.
 
+* First one is the parent, of type FieldSet (is None for the root) ;
+* The second is the name of the field.
+
 Ok, let's play with our new field set:
 
 >>> format = MyFormat(None, "myformat", stream)
@@ -80,21 +79,22 @@
 -------------------------
 
 A field contains a lot of informations, attributes are:
- * name: Field name, unique in his parent field set and can't be changed. It
+ * *name*: Field name, unique in his parent field set and can't be changed. It
    is used as key to access to the field from the field set ;
- * size: Size in bits, can't be changed ;
- * address: Address in bits, relative to parent address, can't be changed ;
- * absolute_address: Address in bits from the beginning of the stream ;
- * parent: Parent of the field (is None for root field set) ;
- * root: Root of all field sets ;
- * value: Formatted value (integer, string, boolean, ...) value of the field.
+ * *size*: Size in bits, can't be changed ;
+ * *address*: Address in bits, relative to parent address, can't be changed ;
+ * *absolute_address*: Address in bits from the beginning of the stream ;
+ * *parent*: Parent of the field (is None for root field set) ;
+ * *root*: Root of all field sets ;
+ * *value*: Formatted value (integer, string, boolean, ...) value of the field.
    Don't use this argument with print function, better use display attribute ;
- * display: A string representing field value, has limited size ;
- * path: Full "path" of the field from the root (eg. "/png/header/content") ;
- * is_field_set: If the value is True, the field contains other fields, it's
+ * *display*: A string representing field value, has limited size ;
+ * *path*: Full "path" of the field from the root (eg. "/png/header/content") ;
+ * *is_field_set*: If the value is True, the field contains other fields, it's
    a field set.
 
 Examples:
+
 >>> field = format["text"]
 >>> field.name
 'text'

Modified: haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt	2006-03-04 01:36:12 UTC (rev 438)
+++ haypo/hachoir/branches/hachoir-yield/doc/2-internals.txt	2006-03-04 02:51:10 UTC (rev 439)
@@ -6,9 +6,8 @@
 
 A field is created when someone ask to access it, or when another field is
 asked and the field is before it. So if you use a field in your field set
-constructor, one or more fields will be created.
+constructor, one or more fields will be created. Example:
 
-Example:
 >>> from field import FieldSet, Integer, String
 >>> class Point(FieldSet):
 ...     def __init__(self, parent, name, stream, description="Point"):
@@ -27,36 +26,40 @@
 
 In the constructor, the field "color" is asked. So the field list will
 contains one field (color):
+
 >>> from stream import StringInputStream
 >>> stream = StringInputStream("\x2A\x00\x04\x05")
 >>> p = Point(None, "point", stream)
 >>> len(p.fields)
 1
 
-WARNING: Only access 'fields' attribute if you know what you are doing.
+.. WARNING::
+   Only access 'fields' attribute if you know what you are doing.
 
 If you access another field, the field list will grow up until the requested
 field is reached:
+
 >>> x = p["x"].value
 >>> len(p.fields)
 3
 
 Some field set methods which create new fields:
- * __getitem__(): feed field list until requested field is reached
+ * ``__getitem__()``: feed field list until requested field is reached
    (or raise MissingField exception) ;
- * __len__(): create all fields ;
- * __iter__(): begin to iterate in existing fields, and the iterate in new
+ * ``__len__()``: create all fields ;
+ * ``__iter__()``: begin to iterate in existing fields, and the iterate in new
    fields until all fields are created ;
- * __contains__(): feed field list until requested field is reached, may
+ * ``__contains__()``: feed field list until requested field is reached, may
    create all fields if the field is missing.
 
 The size attribute also interact with field list creation, but it's mechanism
 is little bit more complex. By default, the whole field list have to be built
 before size value can be read. But you can specify field list size:
- * if field list is fixed, use class attribute static_size ;
- * else you can set _size instance attribute in the constructor.
+* if field list is fixed, use class attribute static_size ;
+* else you can set _size instance attribute in the constructor.
 
 Two examples:
+
 >>> class FourBytes(FieldSet):
 ...     static_size = 32
 ...     def createFields(self):
@@ -97,9 +100,10 @@
 
 The "endian" is the way in which ''bytes'' are stored. There are two important
 orders:
- * ? Big endian ? in which _big_ numbers are written first (Intel x86 CPU)
- * ? Little endian ? in which _little_ numbers are written first (PowerPC CPU)
 
+* ? Big endian ? in which *big* numbers are written first (Intel x86 CPU) ;
+* ? Little endian ? in which *little* numbers are written first (PowerPC CPU).
+
 The number 0x1020 whill be stored "\x10\x20" in big endian and "\x20\x10" in
 little endian.
 
@@ -108,28 +112,28 @@
 international network order: "<", big endian.
 
 Example to set endian:
+
 >>> class UseLittleEndian(FieldSet):
 ...     endian = ">"
-...     # (...)
 ...
 
 Explore a field set using it's path
 -----------------------------------
 
 Fields are stored in a tree. To explore the tree you have differents tools:
- * attribute root of a field which go to tree root ;
- * attribute parent go to field parent (is None for tree root) ;
- * and you can specify a path in __getitem__() argument.
+ * attribute *root* of a field which go to tree root ;
+ * attribute *parent* go to field parent (is None for tree root) ;
+ * and you can specify a path in *__getitem__()* argument.
 
 There are differents valid syntax of a path:
- * path to a child of current node: field["content"] ;
- * path to a child of the parent: field["../brother"] ;
- * path from the root: field["/header/key"].
+ * path to a child of current node: ``field["content"]`` ;
+ * path to a child of the parent: ``field["../brother"]`` ;
+ * path from the root: ``field["/header/key"]``.
 
 Event handling
 --------------
 
 Code is not finished yet, so don't need documentation :-) See:
- * FieldSet.connect(event, handler)
- * FieldSet.raiseEvent(event,  arg1, arg2, ...)
+ * ``FieldSet.connect(event, handler)`` ;
+ * ``FieldSet.raiseEvent(event,  arg1, arg2, ...)``.
 

Added: haypo/hachoir/branches/hachoir-yield/doc/Makefile
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/Makefile	2006-03-04 01:36:12 UTC (rev 438)
+++ haypo/hachoir/branches/hachoir-yield/doc/Makefile	2006-03-04 02:51:10 UTC (rev 439)
@@ -0,0 +1,13 @@
+SOURCES=$(wildcard *.txt)
+HTML=$(patsubst %.txt,%.html,$(SOURCES))
+
+all: $(HTML)
+	@echo "Documentation updated."
+
+%.html: %.txt
+	@echo "Compile documentation $<"
+	@rst2html.py > $@ < $<
+
+clean:
+	@echo "Clean (remove *.html)"
+	@rm -f $(HTML)



From haypo at berlios.de  Sat Mar  4 01:18:15 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:18:15 +0100
Subject: [Happyboom-svn] r422 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/fallback branches/hachoir-yield/field branches/hachoir-yield/file branches/hachoir-yield/file/image branches/hachoir-yield/file/system branches/hachoir-yield/generic
Message-ID: <200603040018.k240IFYK030299@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:18:07 +0100 (Sat, 04 Mar 2006)
New Revision: 422

Added:
   haypo/hachoir/branches/hachoir-yield/config.py
   haypo/hachoir/branches/hachoir-yield/error.py
   haypo/hachoir/branches/hachoir-yield/fallback/
   haypo/hachoir/branches/hachoir-yield/fallback/__init__.py
   haypo/hachoir/branches/hachoir-yield/fallback/magic.py
   haypo/hachoir/branches/hachoir-yield/file/image/bmp.py
   haypo/hachoir/branches/hachoir-yield/file/system/
   haypo/hachoir/branches/hachoir-yield/file/system/__init__.py
   haypo/hachoir/branches/hachoir-yield/file/system/ext2.py
   haypo/hachoir/branches/hachoir-yield/log.py
   haypo/hachoir/branches/hachoir-yield/mime.py
   haypo/hachoir/branches/hachoir-yield/plugin.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/field/integer.py
   haypo/hachoir/branches/hachoir-yield/file/image/png.py
   haypo/hachoir/branches/hachoir-yield/generic/image.py
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r16 at haypopc:  haypo | 2006-03-02 01:42:33 +0100
  * Import log.py, error.py, config.py, mime.py, fallback/magic.py from
    old Hachoir code
  * Write function to load all plugins from 'file' sub-directory.
    Function 'registerPlugin' is not needed anymore, class just have to
    have mime_types attribute ;-)
  * Class attribute static_size replace static method in FieldSet
  * Fix FieldSet.__len__: class _feedAll() if needed
  * Fix FieldSet.__iter__: iterate in existing fields, and then finish to
    feed field list
  * Create Enum class (inherite Integer class)
  * Add Microsoft and OS/2 bitmap parser
  * Add missing mime types to PCX picture parser
  * Add EXT2/EXT3 partition parser (not yet tested :-P)
  * Fix RGB static size (was in bytes and not in bits)
  * Set generic.Palette size in constructor



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:15
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:16

Added: haypo/hachoir/branches/hachoir-yield/config.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/config.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/config.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,13 @@
+# UI: display options
+max_string_length = 10    # Max. length of displayed string
+max_hexa_length = 4096    # Max. length of raw data displayed in hex
+max_ascii_length = 4096   # Max. length of raw data displayed in ASCII
+
+# Global options
+debug = False 
+verbose = False
+
+# Size of file cache (for each opened file)
+file_cache_block_size = 4096  # 4 KB
+file_cache_block_count = 10   # Buffer = 10 * 4 KB
+best_stream_buffer_size = 64 * 1024  # 64 KB

Added: haypo/hachoir/branches/hachoir-yield/error.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/error.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/error.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,33 @@
+import os
+import config
+from log import log
+#import ui.ui
+from tools import getBacktrace
+
+def warning(message):
+    if config.verbose or config.debug:
+        message += "\n\n" + getBacktrace()
+    log.warning(message)   
+#    if (config.verbose or config.debug) and ui.ui.ui != None:
+#        import gtk
+#        dlg = gtk.MessageDialog( \
+#            parent=ui.ui.ui.window.window,
+#            type=gtk.MESSAGE_WARNING,
+#            buttons=gtk.BUTTONS_OK,
+#            message_format=message)
+#        dlg.run()
+#        dlg.destroy()
+
+def error(message, backtrace=None):
+    if config.verbose or config.debug:
+        message += "\n\n" + getBacktrace()
+    log.error(message)
+#    if ui.ui.ui != None:
+#        import gtk
+#        dlg = gtk.MessageDialog( \
+#            parent=ui.ui.ui.window.window,
+#            type=gtk.MESSAGE_ERROR,
+#            buttons=gtk.BUTTONS_OK,
+#            message_format=message)
+#        dlg.run()
+#        dlg.destroy()

Added: haypo/hachoir/branches/hachoir-yield/fallback/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/fallback/magic.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/fallback/magic.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/fallback/magic.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,1119 @@
+#!/usr/bin/env python 
+'''
+magic.py
+ determines a file type by its magic number
+
+ (C)opyright 2000 Jason Petrone <jp_py at demonseed.net>
+ All Rights Reserved
+
+ Command Line Usage: running as `python magic.py file` will print
+                     a description of what 'file' is.
+
+ Module Usage:
+     magic.whatis(data): when passed a string 'data' containing 
+                         binary or text data, a description of
+                         what the data is will be returned.
+
+     magic.file(filename): returns a description of what the file
+                           'filename' contains.
+'''
+
+import re, struct, string
+
+__version__ = '0.1'
+
+magic = [
+  [0L, 'leshort', '=', 1538L, 'application/x-alan-adventure-game'],
+  [0L, 'string', '=', 'TADS', 'application/x-tads-game'],
+  [0L, 'short', '=', 420L, 'application/x-executable-file'],
+  [0L, 'short', '=', 421L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 603L, 'application/x-executable-file'],
+  [0L, 'string', '=', 'Core\001', 'application/x-executable-file'],
+  [0L, 'string', '=', 'AMANDA: TAPESTART DATE', 'application/x-amanda-header'],
+  [0L, 'belong', '=', 1011L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 999L, 'application/x-library-file'],
+  [0L, 'belong', '=', 435L, 'video/mpeg'],
+  [0L, 'belong', '=', 442L, 'video/mpeg'],
+  [0L, 'beshort&0xfff0', '=', 65520L, 'audio/mpeg'],
+  [4L, 'leshort', '=', 44817L, 'video/fli'],
+  [4L, 'leshort', '=', 44818L, 'video/flc'],
+  [0L, 'string', '=', 'MOVI', 'video/x-sgi-movie'],
+  [4L, 'string', '=', 'moov', 'video/quicktime'],
+  [4L, 'string', '=', 'mdat', 'video/quicktime'],
+  [0L, 'long', '=', 100554L, 'application/x-apl-workspace'],
+  [0L, 'string', '=', 'FiLeStArTfIlEsTaRt', 'text/x-apple-binscii'],
+  [0L, 'string', '=', '\012GL', 'application/data'],
+  [0L, 'string', '=', 'v\377', 'application/data'],
+  [0L, 'string', '=', 'NuFile', 'application/data'],
+  [0L, 'string', '=', 'N\365F\351l\345', 'application/data'],
+  [0L, 'belong', '=', 333312L, 'application/data'],
+  [0L, 'belong', '=', 333319L, 'application/data'],
+  [257L, 'string', '=', 'ustar\000', 'application/x-tar'],
+  [257L, 'string', '=', 'ustar  \000', 'application/x-gtar'],
+  [0L, 'short', '=', 70707L, 'application/x-cpio'],
+  [0L, 'short', '=', 143561L, 'application/x-bcpio'],
+  [0L, 'string', '=', '070707', 'application/x-cpio'],
+  [0L, 'string', '=', '070701', 'application/x-cpio'],
+  [0L, 'string', '=', '070702', 'application/x-cpio'],
+  [0L, 'string', '=', '!<arch>\012debian', 'application/x-dpkg'],
+  [0L, 'long', '=', 177555L, 'application/x-ar'],
+  [0L, 'short', '=', 177555L, 'application/data'],
+  [0L, 'long', '=', 177545L, 'application/data'],
+  [0L, 'short', '=', 177545L, 'application/data'],
+  [0L, 'long', '=', 100554L, 'application/x-apl-workspace'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'string', '=', '!<arch>\012__________E', 'application/x-ar'],
+  [0L, 'string', '=', '-h-', 'application/data'],
+  [0L, 'string', '=', '!<arch>', 'application/x-ar'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'belong', '=', 1711210496L, 'application/x-ar'],
+  [0L, 'belong', '=', 1013019198L, 'application/x-ar'],
+  [0L, 'long', '=', 557605234L, 'application/x-ar'],
+  [0L, 'lelong', '=', 177555L, 'application/data'],
+  [0L, 'leshort', '=', 177555L, 'application/data'],
+  [0L, 'lelong', '=', 177545L, 'application/data'],
+  [0L, 'leshort', '=', 177545L, 'application/data'],
+  [0L, 'lelong', '=', 236525L, 'application/data'],
+  [0L, 'lelong', '=', 236526L, 'application/data'],
+  [0L, 'lelong&0x8080ffff', '=', 2074L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 2330L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 538L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 794L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 1050L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 1562L, 'application/x-arc'],
+  [0L, 'string', '=', '\032archive', 'application/data'],
+  [0L, 'leshort', '=', 60000L, 'application/x-arj'],
+  [0L, 'string', '=', 'HPAK', 'application/data'],
+  [0L, 'string', '=', '\351,\001JAM application/data', ''],
+  [2L, 'string', '=', '-lh0-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh1-', 'application/x-lha'],
+  [2L, 'string', '=', '-lz4-', 'application/x-lha'],
+  [2L, 'string', '=', '-lz5-', 'application/x-lha'],
+  [2L, 'string', '=', '-lzs-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh -', 'application/x-lha'],
+  [2L, 'string', '=', '-lhd-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh2-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh3-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh4-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh5-', 'application/x-lha'],
+  [0L, 'string', '=', 'Rar!', 'application/x-rar'],
+  [0L, 'string', '=', 'SQSH', 'application/data'],
+  [0L, 'string', '=', 'UC2\032', 'application/data'],
+  [0L, 'string', '=', 'PK\003\004', 'application/zip'],
+  [20L, 'lelong', '=', 4257523676L, 'application/x-zoo'],
+  [10L, 'string', '=', '# This is a shell archive', 'application/x-shar'],
+  [0L, 'string', '=', '*STA', 'application/data'],
+  [0L, 'string', '=', '2278', 'application/data'],
+  [0L, 'beshort', '=', 560L, 'application/x-executable-file'],
+  [0L, 'beshort', '=', 561L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\000\004\036\212\200', 'application/core'],
+  [0L, 'string', '=', '.snd', 'audio/basic'],
+  [0L, 'lelong', '=', 6583086L, 'audio/basic'],
+  [0L, 'string', '=', 'MThd', 'audio/midi'],
+  [0L, 'string', '=', 'CTMF', 'audio/x-cmf'],
+  [0L, 'string', '=', 'SBI', 'audio/x-sbi'],
+  [0L, 'string', '=', 'Creative Voice File', 'audio/x-voc'],
+  [0L, 'belong', '=', 1314148939L, 'audio/x-multitrack'],
+  [8L, 'string', '=', 'AVI ', 'video/x-msvideo'],
+  [0L, 'string', '=', 'RIFF', 'audio/x-wav'],
+  [0L, 'string', '=', 'EMOD', 'audio/x-emod'],
+  [0L, 'belong', '=', 779248125L, 'audio/x-pn-realaudio'],
+  [0L, 'string', '=', 'MTM', 'audio/x-multitrack'],
+  [0L, 'string', '=', 'if', 'audio/x-669-mod'],
+  [0L, 'string', '=', 'FAR', 'audio/mod'],
+  [0L, 'string', '=', 'MAS_U', 'audio/x-multimate-mod'],
+  [44L, 'string', '=', 'SCRM', 'audio/x-st3-mod'],
+  [0L, 'string', '=', 'GF1PATCH110\000ID#000002\000', 'audio/x-gus-patch'],
+  [0L, 'string', '=', 'GF1PATCH100\000ID#000002\000', 'audio/x-gus-patch'],
+  [0L, 'string', '=', 'JN', 'audio/x-669-mod'],
+  [0L, 'string', '=', 'UN05', 'audio/x-mikmod-uni'],
+  [0L, 'string', '=', 'Extended Module:', 'audio/x-ft2-mod'],
+  [21L, 'string', '=', '!SCREAM!', 'audio/x-st2-mod'],
+  [1080L, 'string', '=', 'M.K.', 'audio/x-protracker-mod'],
+  [1080L, 'string', '=', 'M!K!', 'audio/x-protracker-mod'],
+  [1080L, 'string', '=', 'FLT4', 'audio/x-startracker-mod'],
+  [1080L, 'string', '=', '4CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', '6CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', '8CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', 'CD81', 'audio/x-oktalyzer-mod'],
+  [1080L, 'string', '=', 'OKTA', 'audio/x-oktalyzer-mod'],
+  [1080L, 'string', '=', '16CN', 'audio/x-taketracker-mod'],
+  [1080L, 'string', '=', '32CN', 'audio/x-taketracker-mod'],
+  [0L, 'string', '=', 'TOC', 'audio/x-toc'],
+  [0L, 'short', '=', 3401L, 'application/x-executable-file'],
+  [0L, 'long', '=', 406L, 'application/x-executable-file'],
+  [0L, 'short', '=', 406L, 'application/x-executable-file'],
+  [0L, 'short', '=', 3001L, 'application/x-executable-file'],
+  [0L, 'lelong', '=', 314L, 'application/x-executable-file'],
+  [0L, 'string', '=', '//', 'text/cpp'],
+  [0L, 'string', '=', '\\\\1cw\\', 'application/data'],
+  [0L, 'string', '=', '\\\\1cw', 'application/data'],
+  [0L, 'belong&0xffffff00', '=', 2231440384L, 'application/data'],
+  [0L, 'belong&0xffffff00', '=', 2231487232L, 'application/data'],
+  [0L, 'short', '=', 575L, 'application/x-executable-file'],
+  [0L, 'short', '=', 577L, 'application/x-executable-file'],
+  [4L, 'string', '=', 'pipe', 'application/data'],
+  [4L, 'string', '=', 'prof', 'application/data'],
+  [0L, 'string', '=', ': shell', 'application/data'],
+  [0L, 'string', '=', '#!/bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#!/bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#! /bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#! /bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#!/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#!/usr/local/bin/ash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/ash', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/ash', 'application/x-zsh'],
+  [0L, 'string', '=', '#!/usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#! /usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#! /usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#!/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', 'BEGIN', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/bin/env python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/env python', 'application/x-python'],
+  [0L, 'string', '=', '#!/bin/rc', 'text/script'],
+  [0L, 'string', '=', '#! /bin/rc', 'text/script'],
+  [0L, 'string', '=', '#! /bin/rc', 'text/script'],
+  [0L, 'string', '=', '#!/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#!/usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /', 'text/script'],
+  [0L, 'string', '=', '#! /', 'text/script'],
+  [0L, 'string', '=', '#!/', 'text/script'],
+  [0L, 'string', '=', '#! text/script', ''],
+  [0L, 'string', '=', '\037\235', 'application/compress'],
+  [0L, 'string', '=', '\037\213', 'application/x-gzip'],
+  [0L, 'string', '=', '\037\036', 'application/data'],
+  [0L, 'short', '=', 17437L, 'application/data'],
+  [0L, 'short', '=', 8191L, 'application/data'],
+  [0L, 'string', '=', '\377\037', 'application/data'],
+  [0L, 'short', '=', 145405L, 'application/data'],
+  [0L, 'string', '=', 'BZh', 'application/x-bzip2'],
+  [0L, 'leshort', '=', 65398L, 'application/data'],
+  [0L, 'leshort', '=', 65142L, 'application/data'],
+  [0L, 'leshort', '=', 64886L, 'application/x-lzh'],
+  [0L, 'string', '=', '\037\237', 'application/data'],
+  [0L, 'string', '=', '\037\236', 'application/data'],
+  [0L, 'string', '=', '\037\240', 'application/data'],
+  [0L, 'string', '=', 'BZ', 'application/x-bzip'],
+  [0L, 'string', '=', '\211LZO\000\015\012\032\012', 'application/data'],
+  [0L, 'belong', '=', 507L, 'application/x-object-file'],
+  [0L, 'belong', '=', 513L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 515L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 517L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 70231L, 'application/core'],
+  [24L, 'belong', '=', 60011L, 'application/data'],
+  [24L, 'belong', '=', 60012L, 'application/data'],
+  [24L, 'belong', '=', 60013L, 'application/data'],
+  [24L, 'belong', '=', 60014L, 'application/data'],
+  [0L, 'belong', '=', 601L, 'application/x-object-file'],
+  [0L, 'belong', '=', 607L, 'application/data'],
+  [0L, 'belong', '=', 324508366L, 'application/x-gdbm'],
+  [0L, 'lelong', '=', 324508366L, 'application/x-gdbm'],
+  [0L, 'string', '=', 'GDBM', 'application/x-gdbm'],
+  [0L, 'belong', '=', 398689L, 'application/x-db'],
+  [0L, 'belong', '=', 340322L, 'application/x-db'],
+  [0L, 'string', '=', '<list>\012<protocol bbn-m', 'application/data'],
+  [0L, 'string', '=', 'diff text/x-patch', ''],
+  [0L, 'string', '=', '*** text/x-patch', ''],
+  [0L, 'string', '=', 'Only in text/x-patch', ''],
+  [0L, 'string', '=', 'Common subdirectories: text/x-patch', ''],
+  [0L, 'string', '=', '!<arch>\012________64E', 'application/data'],
+  [0L, 'leshort', '=', 387L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 392L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 399L, 'application/x-object-file'],
+  [0L, 'string', '=', '\377\377\177', 'application/data'],
+  [0L, 'string', '=', '\377\377|', 'application/data'],
+  [0L, 'string', '=', '\377\377~', 'application/data'],
+  [0L, 'string', '=', '\033c\033', 'application/data'],
+  [0L, 'long', '=', 4553207L, 'image/x11'],
+  [0L, 'string', '=', '!<PDF>!\012', 'application/x-prof'],
+  [0L, 'short', '=', 1281L, 'application/x-locale'],
+  [24L, 'belong', '=', 60012L, 'application/x-dump'],
+  [24L, 'belong', '=', 60011L, 'application/x-dump'],
+  [24L, 'lelong', '=', 60012L, 'application/x-dump'],
+  [24L, 'lelong', '=', 60011L, 'application/x-dump'],
+  [0L, 'string', '=', '\177ELF', 'application/x-executable-file'],
+  [0L, 'short', '=', 340L, 'application/data'],
+  [0L, 'short', '=', 341L, 'application/x-executable-file'],
+  [1080L, 'leshort', '=', 61267L, 'application/x-linux-ext2fs'],
+  [0L, 'string', '=', '\366\366\366\366', 'application/x-pc-floppy'],
+  [774L, 'beshort', '=', 55998L, 'application/data'],
+  [510L, 'leshort', '=', 43605L, 'application/data'],
+  [1040L, 'leshort', '=', 4991L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 5007L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 9320L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 9336L, 'application/x-filesystem'],
+  [0L, 'string', '=', '-rom1fs-\000', 'application/x-filesystem'],
+  [395L, 'string', '=', 'OS/2', 'application/x-bootable'],
+  [0L, 'string', '=', 'FONT', 'font/x-vfont'],
+  [0L, 'short', '=', 436L, 'font/x-vfont'],
+  [0L, 'short', '=', 17001L, 'font/x-vfont'],
+  [0L, 'string', '=', '%!PS-AdobeFont-1.0', 'font/type1'],
+  [6L, 'string', '=', '%!PS-AdobeFont-1.0', 'font/type1'],
+  [0L, 'belong', '=', 4L, 'font/x-snf'],
+  [0L, 'lelong', '=', 4L, 'font/x-snf'],
+  [0L, 'string', '=', 'STARTFONT font/x-bdf', ''],
+  [0L, 'string', '=', '\001fcp', 'font/x-pcf'],
+  [0L, 'string', '=', 'D1.0\015', 'font/x-speedo'],
+  [0L, 'string', '=', 'flf', 'font/x-figlet'],
+  [0L, 'string', '=', 'flc', 'application/x-font'],
+  [0L, 'belong', '=', 335698201L, 'font/x-libgrx'],
+  [0L, 'belong', '=', 4282797902L, 'font/x-dos'],
+  [7L, 'belong', '=', 4540225L, 'font/x-dos'],
+  [7L, 'belong', '=', 5654852L, 'font/x-dos'],
+  [4098L, 'string', '=', 'DOSFONT', 'font/x-dos'],
+  [0L, 'string', '=', '<MakerFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MIFFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MakerDictionary', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MakerScreenFont', 'font/x-framemaker'],
+  [0L, 'string', '=', '<MML', 'application/x-framemaker'],
+  [0L, 'string', '=', '<BookFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<Maker', 'application/x-framemaker'],
+  [0L, 'lelong&0377777777', '=', 41400407L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400410L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400413L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400314L, 'application/x-executable-file'],
+  [7L, 'string', '=', '\357\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000', 'application/core'],
+  [0L, 'lelong', '=', 11421044151L, 'application/data'],
+  [0L, 'string', '=', 'GIMP Gradient', 'application/x-gimp-gradient'],
+  [0L, 'string', '=', 'gimp xcf', 'application/x-gimp-image'],
+  [20L, 'string', '=', 'GPAT', 'application/x-gimp-pattern'],
+  [20L, 'string', '=', 'GIMP', 'application/x-gimp-brush'],
+  [0L, 'string', '=', '\336\022\004\225', 'application/x-locale'],
+  [0L, 'string', '=', '\225\004\022\336', 'application/x-locale'],
+  [0L, 'beshort', '=', 627L, 'application/x-executable-file'],
+  [0L, 'beshort', '=', 624L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\000\001\000\000\000', 'font/ttf'],
+  [0L, 'long', '=', 1203604016L, 'application/data'],
+  [0L, 'long', '=', 1702407010L, 'application/data'],
+  [0L, 'long', '=', 1003405017L, 'application/data'],
+  [0L, 'long', '=', 1602007412L, 'application/data'],
+  [0L, 'belong', '=', 34603270L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34603271L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603272L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603275L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603278L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34603277L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34865414L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34865415L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865416L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865419L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865422L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34865421L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34275590L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34275591L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275592L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275595L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275598L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34275597L, 'application/x-library-file'],
+  [0L, 'belong', '=', 557605234L, 'application/x-ar'],
+  [0L, 'long', '=', 34078982L, 'application/x-executable-file'],
+  [0L, 'long', '=', 34078983L, 'application/x-executable-file'],
+  [0L, 'long', '=', 34078984L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341128L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341127L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341131L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341126L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34210056L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34210055L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341134L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34341133L, 'application/x-library-file'],
+  [0L, 'long', '=', 65381L, 'application/x-library-file'],
+  [0L, 'long', '=', 34275173L, 'application/x-library-file'],
+  [0L, 'long', '=', 34406245L, 'application/x-library-file'],
+  [0L, 'long', '=', 34144101L, 'application/x-library-file'],
+  [0L, 'long', '=', 22552998L, 'application/core'],
+  [0L, 'long', '=', 1302851304L, 'font/x-hp-windows'],
+  [0L, 'string', '=', 'Bitmapfile', 'image/unknown'],
+  [0L, 'string', '=', 'IMGfile', 'CIS image/unknown'],
+  [0L, 'long', '=', 34341132L, 'application/x-lisp'],
+  [0L, 'string', '=', 'msgcat01', 'application/x-locale'],
+  [0L, 'string', '=', 'HPHP48-', 'HP48 binary'],
+  [0L, 'string', '=', '%%HP:', 'HP48 text'],
+  [0L, 'beshort', '=', 200L, 'hp200 (68010) BSD'],
+  [0L, 'beshort', '=', 300L, 'hp300 (68020+68881) BSD'],
+  [0L, 'beshort', '=', 537L, '370 XA sysV executable'],
+  [0L, 'beshort', '=', 532L, '370 XA sysV pure executable'],
+  [0L, 'beshort', '=', 54001L, '370 sysV pure executable'],
+  [0L, 'beshort', '=', 55001L, '370 XA sysV pure executable'],
+  [0L, 'beshort', '=', 56401L, '370 sysV executable'],
+  [0L, 'beshort', '=', 57401L, '370 XA sysV executable'],
+  [0L, 'beshort', '=', 531L, 'SVR2 executable (Amdahl-UTS)'],
+  [0L, 'beshort', '=', 534L, 'SVR2 pure executable (Amdahl-UTS)'],
+  [0L, 'beshort', '=', 530L, 'SVR2 pure executable (USS/370)'],
+  [0L, 'beshort', '=', 535L, 'SVR2 executable (USS/370)'],
+  [0L, 'beshort', '=', 479L, 'executable (RISC System/6000 V3.1) or obj module'],
+  [0L, 'beshort', '=', 260L, 'shared library'],
+  [0L, 'beshort', '=', 261L, 'ctab data'],
+  [0L, 'beshort', '=', 65028L, 'structured file'],
+  [0L, 'string', '=', '0xabcdef', 'AIX message catalog'],
+  [0L, 'belong', '=', 505L, 'AIX compiled message catalog'],
+  [0L, 'string', '=', '<aiaff>', 'archive'],
+  [0L, 'string', '=', 'FORM', 'IFF data'],
+  [0L, 'string', '=', 'P1', 'image/x-portable-bitmap'],
+  [0L, 'string', '=', 'P2', 'image/x-portable-graymap'],
+  [0L, 'string', '=', 'P3', 'image/x-portable-pixmap'],
+  [0L, 'string', '=', 'P4', 'image/x-portable-bitmap'],
+  [0L, 'string', '=', 'P5', 'image/x-portable-graymap'],
+  [0L, 'string', '=', 'P6', 'image/x-portable-pixmap'],
+  [0L, 'string', '=', 'IIN1', 'image/tiff'],
+  [0L, 'string', '=', 'MM\000*', 'image/tiff'],
+  [0L, 'string', '=', 'II*\000', 'image/tiff'],
+  [0L, 'string', '=', '\211PNG', 'image/x-png'],
+  [1L, 'string', '=', 'PNG', 'image/x-png'],
+  [0L, 'string', '=', 'GIF8', 'image/gif'],
+  [0L, 'string', '=', '\361\000@\273', 'image/x-cmu-raster'],
+  [0L, 'string', '=', 'id=ImageMagick', 'MIFF image data'],
+  [0L, 'long', '=', 1123028772L, 'Artisan image data'],
+  [0L, 'string', '=', '#FIG', 'FIG image text'],
+  [0L, 'string', '=', 'ARF_BEGARF', 'PHIGS clear text archive'],
+  [0L, 'string', '=', '@(#)SunPHIGS', 'SunPHIGS'],
+  [0L, 'string', '=', 'GKSM', 'GKS Metafile'],
+  [0L, 'string', '=', 'BEGMF', 'clear text Computer Graphics Metafile'],
+  [0L, 'beshort&0xffe0', '=', 32L, 'binary Computer Graphics Metafile'],
+  [0L, 'beshort', '=', 12320L, 'character Computer Graphics Metafile'],
+  [0L, 'string', '=', 'yz', 'MGR bitmap, modern format, 8-bit aligned'],
+  [0L, 'string', '=', 'zz', 'MGR bitmap, old format, 1-bit deep, 16-bit aligned'],
+  [0L, 'string', '=', 'xz', 'MGR bitmap, old format, 1-bit deep, 32-bit aligned'],
+  [0L, 'string', '=', 'yx', 'MGR bitmap, modern format, squeezed'],
+  [0L, 'string', '=', '%bitmap\000', 'FBM image data'],
+  [1L, 'string', '=', 'PC Research, Inc', 'group 3 fax data'],
+  [0L, 'beshort', '=', 65496L, 'image/jpeg'],
+  [0L, 'string', '=', 'hsi1', 'image/x-jpeg-proprietary'],
+  [0L, 'string', '=', 'BM', 'image/x-bmp'],
+  [0L, 'string', '=', 'IC', 'image/x-ico'],
+  [0L, 'string', '=', 'PI', 'PC pointer image data'],
+  [0L, 'string', '=', 'CI', 'PC color icon data'],
+  [0L, 'string', '=', 'CP', 'PC color pointer image data'],
+  [0L, 'string', '=', '/* XPM */', 'X pixmap image text'],
+  [0L, 'leshort', '=', 52306L, 'RLE image data,'],
+  [0L, 'string', '=', 'Imagefile version-', 'iff image data'],
+  [0L, 'belong', '=', 1504078485L, 'x/x-image-sun-raster'],
+  [0L, 'beshort', '=', 474L, 'x/x-image-sgi'],
+  [0L, 'string', '=', 'IT01', 'FIT image data'],
+  [0L, 'string', '=', 'IT02', 'FIT image data'],
+  [2048L, 'string', '=', 'PCD_IPI', 'x/x-photo-cd-pack-file'],
+  [0L, 'string', '=', 'PCD_OPA', 'x/x-photo-cd-overfiew-file'],
+  [0L, 'string', '=', 'SIMPLE  =', 'FITS image data'],
+  [0L, 'string', '=', 'This is a BitMap file', 'Lisp Machine bit-array-file'],
+  [0L, 'string', '=', '!!', 'Bennet Yee\'s "face" format'],
+  [0L, 'beshort', '=', 4112L, 'PEX Binary Archive'],
+  [3000L, 'string', '=', 'Visio (TM) Drawing', '%s'],
+  [0L, 'leshort', '=', 502L, 'basic-16 executable'],
+  [0L, 'leshort', '=', 503L, 'basic-16 executable (TV)'],
+  [0L, 'leshort', '=', 510L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 511L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 512L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 522L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 514L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\210OPS', 'Interleaf saved data'],
+  [0L, 'string', '=', '<!OPS', 'Interleaf document text'],
+  [4L, 'string', '=', 'pgscriptver', 'IslandWrite document'],
+  [13L, 'string', '=', 'DrawFile', 'IslandDraw document'],
+  [0L, 'leshort&0xFFFC', '=', 38400L, 'little endian ispell'],
+  [0L, 'beshort&0xFFFC', '=', 38400L, 'big endian ispell'],
+  [0L, 'belong', '=', 3405691582L, 'compiled Java class data,'],
+  [0L, 'beshort', '=', 44269L, 'Java serialization data'],
+  [0L, 'string', '=', 'KarmaRHD', 'Version Karma Data Structure Version'],
+  [0L, 'string', '=', 'lect', 'DEC SRC Virtual Paper Lectern file'],
+  [53L, 'string', '=', 'yyprevious', 'C program text (from lex)'],
+  [21L, 'string', '=', 'generated by flex', 'C program text (from flex)'],
+  [0L, 'string', '=', '%{', 'lex description text'],
+  [0L, 'short', '=', 32768L, 'lif file'],
+  [0L, 'lelong', '=', 6553863L, 'Linux/i386 impure executable (OMAGIC)'],
+  [0L, 'lelong', '=', 6553864L, 'Linux/i386 pure executable (NMAGIC)'],
+  [0L, 'lelong', '=', 6553867L, 'Linux/i386 demand-paged executable (ZMAGIC)'],
+  [0L, 'lelong', '=', 6553804L, 'Linux/i386 demand-paged executable (QMAGIC)'],
+  [0L, 'string', '=', '\007\001\000', 'Linux/i386 object file'],
+  [0L, 'string', '=', '\001\003\020\004', 'Linux-8086 impure executable'],
+  [0L, 'string', '=', '\001\003 \004', 'Linux-8086 executable'],
+  [0L, 'string', '=', '\243\206\001\000', 'Linux-8086 object file'],
+  [0L, 'string', '=', '\001\003\020\020', 'Minix-386 impure executable'],
+  [0L, 'string', '=', '\001\003 \020', 'Minix-386 executable'],
+  [0L, 'string', '=', '*nazgul*', 'Linux compiled message catalog'],
+  [216L, 'lelong', '=', 421L, 'Linux/i386 core file'],
+  [2L, 'string', '=', 'LILO', 'Linux/i386 LILO boot/chain loader'],
+  [0L, 'string', '=', '0.9', ''],
+  [0L, 'leshort', '=', 1078L, 'font/linux-psf'],
+  [4086L, 'string', '=', 'SWAP-SPACE', 'Linux/i386 swap file'],
+  [0L, 'leshort', '=', 387L, 'ECOFF alpha'],
+  [514L, 'string', '=', 'HdrS', 'Linux kernel'],
+  [0L, 'belong', '=', 3099592590L, 'Linux kernel'],
+  [0L, 'string', '=', 'Begin3', 'Linux Software Map entry text'],
+  [0L, 'string', '=', ';;', 'Lisp/Scheme program text'],
+  [0L, 'string', '=', '\012(', 'byte-compiled Emacs-Lisp program data'],
+  [0L, 'string', '=', ';ELC\023\000\000\000', 'byte-compiled Emacs-Lisp program data'],
+  [0L, 'string', '=', "(SYSTEM::VERSION '", 'CLISP byte-compiled Lisp program text'],
+  [0L, 'long', '=', 1886817234L, 'CLISP memory image data'],
+  [0L, 'long', '=', 3532355184L, 'CLISP memory image data, other endian'],
+  [0L, 'long', '=', 3725722773L, 'GNU-format message catalog data'],
+  [0L, 'long', '=', 2500072158L, 'GNU-format message catalog data'],
+  [0L, 'belong', '=', 3405691582L, 'mach-o fat file'],
+  [0L, 'belong', '=', 4277009102L, 'mach-o'],
+  [11L, 'string', '=', 'must be converted with BinHex', 'BinHex binary text'],
+  [0L, 'string', '=', 'SIT!', 'StuffIt Archive (data)'],
+  [65L, 'string', '=', 'SIT!', 'StuffIt Archive (rsrc + data)'],
+  [0L, 'string', '=', 'SITD', 'StuffIt Deluxe (data)'],
+  [65L, 'string', '=', 'SITD', 'StuffIt Deluxe (rsrc + data)'],
+  [0L, 'string', '=', 'Seg', 'StuffIt Deluxe Segment (data)'],
+  [65L, 'string', '=', 'Seg', 'StuffIt Deluxe Segment (rsrc + data)'],
+  [0L, 'string', '=', 'APPL', 'Macintosh Application (data)'],
+  [65L, 'string', '=', 'APPL', 'Macintosh Application (rsrc + data)'],
+  [0L, 'string', '=', 'zsys', 'Macintosh System File (data)'],
+  [65L, 'string', '=', 'zsys', 'Macintosh System File(rsrc + data)'],
+  [0L, 'string', '=', 'FNDR', 'Macintosh Finder (data)'],
+  [65L, 'string', '=', 'FNDR', 'Macintosh Finder(rsrc + data)'],
+  [0L, 'string', '=', 'libr', 'Macintosh Library (data)'],
+  [65L, 'string', '=', 'libr', 'Macintosh Library(rsrc + data)'],
+  [0L, 'string', '=', 'shlb', 'Macintosh Shared Library (data)'],
+  [65L, 'string', '=', 'shlb', 'Macintosh Shared Library(rsrc + data)'],
+  [0L, 'string', '=', 'cdev', 'Macintosh Control Panel (data)'],
+  [65L, 'string', '=', 'cdev', 'Macintosh Control Panel(rsrc + data)'],
+  [0L, 'string', '=', 'INIT', 'Macintosh Extension (data)'],
+  [65L, 'string', '=', 'INIT', 'Macintosh Extension(rsrc + data)'],
+  [0L, 'string', '=', 'FFIL', 'font/ttf'],
+  [65L, 'string', '=', 'FFIL', 'font/ttf'],
+  [0L, 'string', '=', 'LWFN', 'font/type1'],
+  [65L, 'string', '=', 'LWFN', 'font/type1'],
+  [0L, 'string', '=', 'PACT', 'Macintosh Compact Pro Archive (data)'],
+  [65L, 'string', '=', 'PACT', 'Macintosh Compact Pro Archive(rsrc + data)'],
+  [0L, 'string', '=', 'ttro', 'Macintosh TeachText File (data)'],
+  [65L, 'string', '=', 'ttro', 'Macintosh TeachText File(rsrc + data)'],
+  [0L, 'string', '=', 'TEXT', 'Macintosh TeachText File (data)'],
+  [65L, 'string', '=', 'TEXT', 'Macintosh TeachText File(rsrc + data)'],
+  [0L, 'string', '=', 'PDF', 'Macintosh PDF File (data)'],
+  [65L, 'string', '=', 'PDF', 'Macintosh PDF File(rsrc + data)'],
+  [0L, 'string', '=', '# Magic', 'magic text file for file(1) cmd'],
+  [0L, 'string', '=', 'Relay-Version:', 'old news text'],
+  [0L, 'string', '=', '#! rnews', 'batched news text'],
+  [0L, 'string', '=', 'N#! rnews', 'mailed, batched news text'],
+  [0L, 'string', '=', 'Forward to', 'mail forwarding text'],
+  [0L, 'string', '=', 'Pipe to', 'mail piping text'],
+  [0L, 'string', '=', 'Return-Path:', 'message/rfc822'],
+  [0L, 'string', '=', 'Path:', 'message/news'],
+  [0L, 'string', '=', 'Xref:', 'message/news'],
+  [0L, 'string', '=', 'From:', 'message/rfc822'],
+  [0L, 'string', '=', 'Article', 'message/news'],
+  [0L, 'string', '=', 'BABYL', 'message/x-gnu-rmail'],
+  [0L, 'string', '=', 'Received:', 'message/rfc822'],
+  [0L, 'string', '=', 'MIME-Version:', 'MIME entity text'],
+  [0L, 'string', '=', 'Content-Type: ', ''],
+  [0L, 'string', '=', 'Content-Type:', ''],
+  [0L, 'long', '=', 31415L, 'Mirage Assembler m.out executable'],
+  [0L, 'string', '=', '\311\304', 'ID tags data'],
+  [0L, 'string', '=', '\001\001\001\001', 'MMDF mailbox'],
+  [4L, 'string', '=', 'Research,', 'Digifax-G3-File'],
+  [0L, 'short', '=', 256L, 'raw G3 data, byte-padded'],
+  [0L, 'short', '=', 5120L, 'raw G3 data'],
+  [0L, 'string', '=', 'RMD1', 'raw modem data'],
+  [0L, 'string', '=', 'PVF1\012', 'portable voice format'],
+  [0L, 'string', '=', 'PVF2\012', 'portable voice format'],
+  [0L, 'beshort', '=', 520L, 'mc68k COFF'],
+  [0L, 'beshort', '=', 521L, 'mc68k executable (shared)'],
+  [0L, 'beshort', '=', 522L, 'mc68k executable (shared demand paged)'],
+  [0L, 'beshort', '=', 554L, '68K BCS executable'],
+  [0L, 'beshort', '=', 555L, '88K BCS executable'],
+  [0L, 'string', '=', 'S0', 'Motorola S-Record; binary data in text format'],
+  [0L, 'string', '=', '@echo off', 'MS-DOS batch file text'],
+  [128L, 'string', '=', 'PE\000\000', 'MS Windows PE'],
+  [0L, 'leshort', '=', 332L, 'MS Windows COFF Intel 80386 object file'],
+  [0L, 'leshort', '=', 358L, 'MS Windows COFF MIPS R4000 object file'],
+  [0L, 'leshort', '=', 388L, 'MS Windows COFF Alpha object file'],
+  [0L, 'leshort', '=', 616L, 'MS Windows COFF Motorola 68000 object file'],
+  [0L, 'leshort', '=', 496L, 'MS Windows COFF PowerPC object file'],
+  [0L, 'leshort', '=', 656L, 'MS Windows COFF PA-RISC object file'],
+  [0L, 'string', '=', 'MZ', 'application/x-ms-dos-executable'],
+  [0L, 'string', '=', 'LZ', 'MS-DOS executable (built-in)'],
+  [0L, 'string', '=', 'regf', 'Windows NT Registry file'],
+  [2080L, 'string', '=', 'Microsoft Word 6.0 Document', 'text/vnd.ms-word'],
+  [2080L, 'string', '=', 'Documento Microsoft Word 6', 'text/vnd.ms-word'],
+  [2112L, 'string', '=', 'MSWordDoc', 'text/vnd.ms-word'],
+  [0L, 'belong', '=', 834535424L, 'text/vnd.ms-word'],
+  [0L, 'string', '=', 'PO^Q`', 'text/vnd.ms-word'],
+  [2080L, 'string', '=', 'Microsoft Excel 5.0 Worksheet', 'application/vnd.ms-excel'],
+  [2114L, 'string', '=', 'Biff5', 'application/vnd.ms-excel'],
+  [0L, 'belong', '=', 6656L, 'Lotus 1-2-3'],
+  [0L, 'belong', '=', 512L, 'Lotus 1-2-3'],
+  [1L, 'string', '=', 'WPC', 'text/vnd.wordperfect'],
+  [0L, 'beshort', '=', 610L, 'Tower/XP rel 2 object'],
+  [0L, 'beshort', '=', 615L, 'Tower/XP rel 2 object'],
+  [0L, 'beshort', '=', 620L, 'Tower/XP rel 3 object'],
+  [0L, 'beshort', '=', 625L, 'Tower/XP rel 3 object'],
+  [0L, 'beshort', '=', 630L, 'Tower32/600/400 68020 object'],
+  [0L, 'beshort', '=', 640L, 'Tower32/800 68020'],
+  [0L, 'beshort', '=', 645L, 'Tower32/800 68010'],
+  [0L, 'lelong', '=', 407L, 'NetBSD little-endian object file'],
+  [0L, 'belong', '=', 407L, 'NetBSD big-endian object file'],
+  [0L, 'belong&0377777777', '=', 41400413L, 'NetBSD/i386 demand paged'],
+  [0L, 'belong&0377777777', '=', 41400410L, 'NetBSD/i386 pure'],
+  [0L, 'belong&0377777777', '=', 41400407L, 'NetBSD/i386'],
+  [0L, 'belong&0377777777', '=', 41400507L, 'NetBSD/i386 core'],
+  [0L, 'belong&0377777777', '=', 41600413L, 'NetBSD/m68k demand paged'],
+  [0L, 'belong&0377777777', '=', 41600410L, 'NetBSD/m68k pure'],
+  [0L, 'belong&0377777777', '=', 41600407L, 'NetBSD/m68k'],
+  [0L, 'belong&0377777777', '=', 41600507L, 'NetBSD/m68k core'],
+  [0L, 'belong&0377777777', '=', 42000413L, 'NetBSD/m68k4k demand paged'],
+  [0L, 'belong&0377777777', '=', 42000410L, 'NetBSD/m68k4k pure'],
+  [0L, 'belong&0377777777', '=', 42000407L, 'NetBSD/m68k4k'],
+  [0L, 'belong&0377777777', '=', 42000507L, 'NetBSD/m68k4k core'],
+  [0L, 'belong&0377777777', '=', 42200413L, 'NetBSD/ns32532 demand paged'],
+  [0L, 'belong&0377777777', '=', 42200410L, 'NetBSD/ns32532 pure'],
+  [0L, 'belong&0377777777', '=', 42200407L, 'NetBSD/ns32532'],
+  [0L, 'belong&0377777777', '=', 42200507L, 'NetBSD/ns32532 core'],
+  [0L, 'belong&0377777777', '=', 42400413L, 'NetBSD/sparc demand paged'],
+  [0L, 'belong&0377777777', '=', 42400410L, 'NetBSD/sparc pure'],
+  [0L, 'belong&0377777777', '=', 42400407L, 'NetBSD/sparc'],
+  [0L, 'belong&0377777777', '=', 42400507L, 'NetBSD/sparc core'],
+  [0L, 'belong&0377777777', '=', 42600413L, 'NetBSD/pmax demand paged'],
+  [0L, 'belong&0377777777', '=', 42600410L, 'NetBSD/pmax pure'],
+  [0L, 'belong&0377777777', '=', 42600407L, 'NetBSD/pmax'],
+  [0L, 'belong&0377777777', '=', 42600507L, 'NetBSD/pmax core'],
+  [0L, 'belong&0377777777', '=', 43000413L, 'NetBSD/vax demand paged'],
+  [0L, 'belong&0377777777', '=', 43000410L, 'NetBSD/vax pure'],
+  [0L, 'belong&0377777777', '=', 43000407L, 'NetBSD/vax'],
+  [0L, 'belong&0377777777', '=', 43000507L, 'NetBSD/vax core'],
+  [0L, 'lelong', '=', 459141L, 'ECOFF NetBSD/alpha binary'],
+  [0L, 'belong&0377777777', '=', 43200507L, 'NetBSD/alpha core'],
+  [0L, 'belong&0377777777', '=', 43400413L, 'NetBSD/mips demand paged'],
+  [0L, 'belong&0377777777', '=', 43400410L, 'NetBSD/mips pure'],
+  [0L, 'belong&0377777777', '=', 43400407L, 'NetBSD/mips'],
+  [0L, 'belong&0377777777', '=', 43400507L, 'NetBSD/mips core'],
+  [0L, 'belong&0377777777', '=', 43600413L, 'NetBSD/arm32 demand paged'],
+  [0L, 'belong&0377777777', '=', 43600410L, 'NetBSD/arm32 pure'],
+  [0L, 'belong&0377777777', '=', 43600407L, 'NetBSD/arm32'],
+  [0L, 'belong&0377777777', '=', 43600507L, 'NetBSD/arm32 core'],
+  [0L, 'string', '=', 'StartFontMetrics', 'font/x-sunos-news'],
+  [0L, 'string', '=', 'StartFont', 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773060L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773063L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773072L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773073L, 'font/x-sunos-news'],
+  [8L, 'belong', '=', 326773573L, 'font/x-sunos-news'],
+  [8L, 'belong', '=', 326773576L, 'font/x-sunos-news'],
+  [0L, 'string', '=', 'Octave-1-L', 'Octave binary data (little endian)'],
+  [0L, 'string', '=', 'Octave-1-B', 'Octave binary data (big endian)'],
+  [0L, 'string', '=', '\177OLF', 'OLF'],
+  [0L, 'beshort', '=', 34765L, 'OS9/6809 module:'],
+  [0L, 'beshort', '=', 19196L, 'OS9/68K module:'],
+  [0L, 'long', '=', 61374L, 'OSF/Rose object'],
+  [0L, 'short', '=', 565L, 'i386 COFF object'],
+  [0L, 'short', '=', 10775L, '"compact bitmap" format (Poskanzer)'],
+  [0L, 'string', '=', '%PDF-', 'PDF document'],
+  [0L, 'lelong', '=', 101555L, 'PDP-11 single precision APL workspace'],
+  [0L, 'lelong', '=', 101554L, 'PDP-11 double precision APL workspace'],
+  [0L, 'leshort', '=', 407L, 'PDP-11 executable'],
+  [0L, 'leshort', '=', 401L, 'PDP-11 UNIX/RT ldp'],
+  [0L, 'leshort', '=', 405L, 'PDP-11 old overlay'],
+  [0L, 'leshort', '=', 410L, 'PDP-11 pure executable'],
+  [0L, 'leshort', '=', 411L, 'PDP-11 separate I&D executable'],
+  [0L, 'leshort', '=', 437L, 'PDP-11 kernel overlay'],
+  [0L, 'beshort', '=', 39168L, 'PGP key public ring'],
+  [0L, 'beshort', '=', 38145L, 'PGP key security ring'],
+  [0L, 'beshort', '=', 38144L, 'PGP key security ring'],
+  [0L, 'beshort', '=', 42496L, 'PGP encrypted data'],
+  [0L, 'string', '=', '-----BEGIN PGP', 'PGP armored data'],
+  [0L, 'string', '=', '# PaCkAgE DaTaStReAm', 'pkg Datastream (SVR4)'],
+  [0L, 'short', '=', 601L, 'mumps avl global'],
+  [0L, 'short', '=', 602L, 'mumps blt global'],
+  [0L, 'string', '=', '%!', 'application/postscript'],
+  [0L, 'string', '=', '\004%!', 'application/postscript'],
+  [0L, 'belong', '=', 3318797254L, 'DOS EPS Binary File'],
+  [0L, 'string', '=', '*PPD-Adobe:', 'PPD file'],
+  [0L, 'string', '=', '\033%-12345X at PJL', 'HP Printer Job Language data'],
+  [0L, 'string', '=', '\033%-12345X at PJL', 'HP Printer Job Language data'],
+  [0L, 'string', '=', '\033E\033', 'image/x-pcl-hp'],
+  [0L, 'string', '=', '@document(', 'Imagen printer'],
+  [0L, 'string', '=', 'Rast', 'RST-format raster font data'],
+  [0L, 'belong&0xff00ffff', '=', 1442840576L, 'ps database'],
+  [0L, 'long', '=', 1351614727L, 'Pyramid 90x family executable'],
+  [0L, 'long', '=', 1351614728L, 'Pyramid 90x family pure executable'],
+  [0L, 'long', '=', 1351614731L, 'Pyramid 90x family demand paged pure executable'],
+  [0L, 'beshort', '=', 60843L, ''],
+  [0L, 'string', '=', '{\\\\rtf', 'Rich Text Format data,'],
+  [38L, 'string', '=', 'Spreadsheet', 'sc spreadsheet file'],
+  [8L, 'string', '=', '\001s SCCS', 'archive data'],
+  [0L, 'byte', '=', 46L, 'Sendmail frozen configuration'],
+  [0L, 'short', '=', 10012L, 'Sendmail frozen configuration'],
+  [0L, 'lelong', '=', 234L, 'BALANCE NS32000 .o'],
+  [0L, 'lelong', '=', 4330L, 'BALANCE NS32000 executable (0 @ 0)'],
+  [0L, 'lelong', '=', 8426L, 'BALANCE NS32000 executable (invalid @ 0)'],
+  [0L, 'lelong', '=', 12522L, 'BALANCE NS32000 standalone executable'],
+  [0L, 'leshort', '=', 4843L, 'SYMMETRY i386 .o'],
+  [0L, 'leshort', '=', 8939L, 'SYMMETRY i386 executable (0 @ 0)'],
+  [0L, 'leshort', '=', 13035L, 'SYMMETRY i386 executable (invalid @ 0)'],
+  [0L, 'leshort', '=', 17131L, 'SYMMETRY i386 standalone executable'],
+  [0L, 'string', '=', 'kbd!map', 'kbd map file'],
+  [0L, 'belong', '=', 407L, 'old SGI 68020 executable'],
+  [0L, 'belong', '=', 410L, 'old SGI 68020 pure executable'],
+  [0L, 'beshort', '=', 34661L, 'disk quotas file'],
+  [0L, 'beshort', '=', 1286L, 'IRIS Showcase file'],
+  [0L, 'beshort', '=', 550L, 'IRIS Showcase template'],
+  [0L, 'belong', '=', 1396917837L, 'IRIS Showcase file'],
+  [0L, 'belong', '=', 1413695053L, 'IRIS Showcase template'],
+  [0L, 'belong', '=', 3735927486L, 'IRIX Parallel Arena'],
+  [0L, 'beshort', '=', 352L, 'MIPSEB COFF executable'],
+  [0L, 'beshort', '=', 354L, 'MIPSEL COFF executable'],
+  [0L, 'beshort', '=', 24577L, 'MIPSEB-LE COFF executable'],
+  [0L, 'beshort', '=', 25089L, 'MIPSEL-LE COFF executable'],
+  [0L, 'beshort', '=', 355L, 'MIPSEB MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 358L, 'MIPSEL MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 25345L, 'MIPSEB-LE MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 26113L, 'MIPSEL-LE MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 320L, 'MIPSEB MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 322L, 'MIPSEL MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 16385L, 'MIPSEB-LE MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 16897L, 'MIPSEL-LE MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 384L, 'MIPSEB Ucode'],
+  [0L, 'beshort', '=', 386L, 'MIPSEL Ucode'],
+  [0L, 'belong', '=', 3735924144L, 'IRIX core dump'],
+  [0L, 'belong', '=', 3735924032L, 'IRIX 64-bit core dump'],
+  [0L, 'belong', '=', 3133063355L, 'IRIX N32 core dump'],
+  [0L, 'string', '=', 'CrshDump', 'IRIX vmcore dump of'],
+  [0L, 'string', '=', 'SGIAUDIT', 'SGI Audit file'],
+  [0L, 'string', '=', 'WNGZWZSC', 'Wingz compiled script'],
+  [0L, 'string', '=', 'WNGZWZSS', 'Wingz spreadsheet'],
+  [0L, 'string', '=', 'WNGZWZHP', 'Wingz help file'],
+  [0L, 'string', '=', '\\#Inventor', 'V IRIS Inventor 1.0 file'],
+  [0L, 'string', '=', '\\#Inventor', 'V2 Open Inventor 2.0 file'],
+  [0L, 'string', '=', 'glfHeadMagic();', 'GLF_TEXT'],
+  [4L, 'belong', '=', 1090584576L, 'GLF_BINARY_LSB_FIRST'],
+  [4L, 'belong', '=', 321L, 'GLF_BINARY_MSB_FIRST'],
+  [0L, 'string', '=', '<!DOCTYPE HTML', 'text/html'],
+  [0L, 'string', '=', '<!doctype html', 'text/html'],
+  [0L, 'string', '=', '<HEAD', 'text/html'],
+  [0L, 'string', '=', '<head', 'text/html'],
+  [0L, 'string', '=', '<TITLE', 'text/html'],
+  [0L, 'string', '=', '<title', 'text/html'],
+  [0L, 'string', '=', '<html', 'text/html'],
+  [0L, 'string', '=', '<HTML', 'text/html'],
+  [0L, 'string', '=', '<!DOCTYPE', 'exported SGML document text'],
+  [0L, 'string', '=', '<!doctype', 'exported SGML document text'],
+  [0L, 'string', '=', '<!SUBDOC', 'exported SGML subdocument text'],
+  [0L, 'string', '=', '<!subdoc', 'exported SGML subdocument text'],
+  [0L, 'string', '=', '<!--', 'exported SGML document text'],
+  [0L, 'string', '=', 'RTSS', 'NetMon capture file'],
+  [0L, 'string', '=', 'TRSNIFF data    \032', 'Sniffer capture file'],
+  [0L, 'string', '=', 'XCP\000', 'NetXRay capture file'],
+  [0L, 'ubelong', '=', 2712847316L, 'tcpdump capture file (big-endian)'],
+  [0L, 'ulelong', '=', 2712847316L, 'tcpdump capture file (little-endian)'],
+  [0L, 'string', '=', '<!SQ DTD>', 'Compiled SGML rules file'],
+  [0L, 'string', '=', '<!SQ A/E>', 'A/E SGML Document binary'],
+  [0L, 'string', '=', '<!SQ STS>', 'A/E SGML binary styles file'],
+  [0L, 'short', '=', 49374L, 'Compiled PSI (v1) data'],
+  [0L, 'short', '=', 49370L, 'Compiled PSI (v2) data'],
+  [0L, 'short', '=', 125252L, 'SoftQuad DESC or font file binary'],
+  [0L, 'string', '=', 'SQ BITMAP1', 'SoftQuad Raster Format text'],
+  [0L, 'string', '=', 'X SoftQuad', 'troff Context intermediate'],
+  [0L, 'belong&077777777', '=', 600413L, 'sparc demand paged'],
+  [0L, 'belong&077777777', '=', 600410L, 'sparc pure'],
+  [0L, 'belong&077777777', '=', 600407L, 'sparc'],
+  [0L, 'belong&077777777', '=', 400413L, 'mc68020 demand paged'],
+  [0L, 'belong&077777777', '=', 400410L, 'mc68020 pure'],
+  [0L, 'belong&077777777', '=', 400407L, 'mc68020'],
+  [0L, 'belong&077777777', '=', 200413L, 'mc68010 demand paged'],
+  [0L, 'belong&077777777', '=', 200410L, 'mc68010 pure'],
+  [0L, 'belong&077777777', '=', 200407L, 'mc68010'],
+  [0L, 'belong', '=', 407L, 'old sun-2 executable'],
+  [0L, 'belong', '=', 410L, 'old sun-2 pure executable'],
+  [0L, 'belong', '=', 413L, 'old sun-2 demand paged executable'],
+  [0L, 'belong', '=', 525398L, 'SunOS core file'],
+  [0L, 'long', '=', 4197695630L, 'SunPC 4.0 Hard Disk'],
+  [0L, 'string', '=', '#SUNPC_CONFIG', 'SunPC 4.0 Properties Values'],
+  [0L, 'string', '=', 'snoop', 'Snoop capture file'],
+  [36L, 'string', '=', 'acsp', 'Kodak Color Management System, ICC Profile'],
+  [0L, 'string', '=', '#!teapot\012xdr', 'teapot work sheet (XDR format)'],
+  [0L, 'string', '=', '\032\001', 'Compiled terminfo entry'],
+  [0L, 'short', '=', 433L, 'Curses screen image'],
+  [0L, 'short', '=', 434L, 'Curses screen image'],
+  [0L, 'string', '=', '\367\002', 'TeX DVI file'],
+  [0L, 'string', '=', '\367\203', 'font/x-tex'],
+  [0L, 'string', '=', '\367Y', 'font/x-tex'],
+  [0L, 'string', '=', '\367\312', 'font/x-tex'],
+  [0L, 'string', '=', 'This is TeX,', 'TeX transcript text'],
+  [0L, 'string', '=', 'This is METAFONT,', 'METAFONT transcript text'],
+  [2L, 'string', '=', '\000\021', 'font/x-tex-tfm'],
+  [2L, 'string', '=', '\000\022', 'font/x-tex-tfm'],
+  [0L, 'string', '=', '\\\\input\\', 'texinfo Texinfo source text'],
+  [0L, 'string', '=', 'This is Info file', 'GNU Info text'],
+  [0L, 'string', '=', '\\\\input', 'TeX document text'],
+  [0L, 'string', '=', '\\\\section', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\setlength', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\documentstyle', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\chapter', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\documentclass', 'LaTeX 2e document text'],
+  [0L, 'string', '=', '\\\\relax', 'LaTeX auxiliary file'],
+  [0L, 'string', '=', '\\\\contentsline', 'LaTeX table of contents'],
+  [0L, 'string', '=', '\\\\indexentry', 'LaTeX raw index file'],
+  [0L, 'string', '=', '\\\\begin{theindex}', 'LaTeX sorted index'],
+  [0L, 'string', '=', '\\\\glossaryentry', 'LaTeX raw glossary'],
+  [0L, 'string', '=', '\\\\begin{theglossary}', 'LaTeX sorted glossary'],
+  [0L, 'string', '=', 'This is makeindex', 'Makeindex log file'],
+  [0L, 'string', '=', '**TI82**', 'TI-82 Graphing Calculator'],
+  [0L, 'string', '=', '**TI83**', 'TI-83 Graphing Calculator'],
+  [0L, 'string', '=', '**TI85**', 'TI-85 Graphing Calculator'],
+  [0L, 'string', '=', '**TI92**', 'TI-92 Graphing Calculator'],
+  [0L, 'string', '=', '**TI80**', 'TI-80 Graphing Calculator File.'],
+  [0L, 'string', '=', '**TI81**', 'TI-81 Graphing Calculator File.'],
+  [0L, 'string', '=', 'TZif', 'timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000', 'old timezone data'],
+  [0L, 'string', '=', '.\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\'\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\'.\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', 'x T', 'ditroff text'],
+  [0L, 'string', '=', '@\357', 'very old (C/A/T) troff output data'],
+  [0L, 'string', '=', 'Interpress/Xerox', 'Xerox InterPress data'],
+  [0L, 'short', '=', 263L, 'unknown machine executable'],
+  [0L, 'short', '=', 264L, 'unknown pure executable'],
+  [0L, 'short', '=', 265L, 'PDP-11 separate I&D'],
+  [0L, 'short', '=', 267L, 'unknown pure executable'],
+  [0L, 'long', '=', 268L, 'unknown demand paged pure executable'],
+  [0L, 'long', '=', 269L, 'unknown demand paged pure executable'],
+  [0L, 'long', '=', 270L, 'unknown readable demand paged pure executable'],
+  [0L, 'string', '=', 'begin uuencoded', 'or xxencoded text'],
+  [0L, 'string', '=', 'xbtoa Begin', "btoa'd text"],
+  [0L, 'string', '=', '$\012ship', "ship'd binary text"],
+  [0L, 'string', '=', 'Decode the following with bdeco', 'bencoded News text'],
+  [11L, 'string', '=', 'must be converted with BinHex', 'BinHex binary text'],
+  [0L, 'short', '=', 610L, 'Perkin-Elmer executable'],
+  [0L, 'beshort', '=', 572L, 'amd 29k coff noprebar executable'],
+  [0L, 'beshort', '=', 1572L, 'amd 29k coff prebar executable'],
+  [0L, 'beshort', '=', 160007L, 'amd 29k coff archive'],
+  [6L, 'beshort', '=', 407L, 'unicos (cray) executable'],
+  [596L, 'string', '=', 'X\337\377\377', 'Ultrix core file'],
+  [0L, 'string', '=', 'Joy!peffpwpc', 'header for PowerPC PEF executable'],
+  [0L, 'lelong', '=', 101557L, 'VAX single precision APL workspace'],
+  [0L, 'lelong', '=', 101556L, 'VAX double precision APL workspace'],
+  [0L, 'lelong', '=', 407L, 'VAX executable'],
+  [0L, 'lelong', '=', 410L, 'VAX pure executable'],
+  [0L, 'lelong', '=', 413L, 'VAX demand paged pure executable'],
+  [0L, 'leshort', '=', 570L, 'VAX COFF executable'],
+  [0L, 'leshort', '=', 575L, 'VAX COFF pure executable'],
+  [0L, 'string', '=', 'LBLSIZE=', 'VICAR image data'],
+  [43L, 'string', '=', 'SFDU_LABEL', 'VICAR label file'],
+  [0L, 'short', '=', 21845L, 'VISX image file'],
+  [0L, 'string', '=', '\260\0000\000', 'VMS VAX executable'],
+  [0L, 'belong', '=', 50331648L, 'VMS Alpha executable'],
+  [1L, 'string', '=', 'WPC', '(Corel/WP)'],
+  [0L, 'string', '=', 'core', 'core file (Xenix)'],
+  [0L, 'byte', '=', 128L, '8086 relocatable (Microsoft)'],
+  [0L, 'leshort', '=', 65381L, 'x.out'],
+  [0L, 'leshort', '=', 518L, 'Microsoft a.out'],
+  [0L, 'leshort', '=', 320L, 'old Microsoft 8086 x.out'],
+  [0L, 'lelong', '=', 518L, 'b.out'],
+  [0L, 'leshort', '=', 1408L, 'XENIX 8086 relocatable or 80286 small model'],
+  [0L, 'long', '=', 59399L, 'object file (z8000 a.out)'],
+  [0L, 'long', '=', 59400L, 'pure object file (z8000 a.out)'],
+  [0L, 'long', '=', 59401L, 'separate object file (z8000 a.out)'],
+  [0L, 'long', '=', 59397L, 'overlay object file (z8000 a.out)'],
+  [0L, 'string', '=', 'ZyXEL\002', 'ZyXEL voice data'],
+]
+
+magicNumbers = []
+
+def strToNum(n):
+  val = 0
+  col = long(1)
+  if n[:1] == 'x': n = '0' + n
+  if n[:2] == '0x':
+    # hex
+    n = string.lower(n[2:])
+    while len(n) > 0:
+      l = n[len(n) - 1]
+      val = val + string.hexdigits.index(l) * col
+      col = col * 16
+      n = n[:len(n)-1]
+  elif n[0] == '\\':
+    # octal
+    n = n[1:]
+    while len(n) > 0:
+      l = n[len(n) - 1]
+      if ord(l) < 48 or ord(l) > 57: break
+      val = val + int(l) * col
+      col = col * 8
+      n = n[:len(n)-1]
+  else:
+    val = string.atol(n)
+  return val
+       
+def unescape(s):
+  # replace string escape sequences
+  while 1:
+    m = re.search(r'\\', s)
+    if not m: break
+    x = m.start()+1
+    if m.end() == len(s): 
+      # escaped space at end
+      s = s[:len(s)-1] + ' '
+    elif s[x:x+2] == '0x':
+      # hex ascii value
+      c = chr(strToNum(s[x:x+4]))
+      s = s[:x-1] + c + s[x+4:]
+    elif s[m.start()+1] == 'x':
+      # hex ascii value
+      c = chr(strToNum(s[x:x+3]))
+      s = s[:x-1] + c + s[x+3:]
+    elif ord(s[x]) > 47 and ord(s[x]) < 58:
+      # octal ascii value
+      end = x
+      while (ord(s[end]) > 47 and ord(s[end]) < 58):
+        end = end + 1
+        if end > len(s) - 1: break
+      c = chr(strToNum(s[x-1:end]))
+      s = s[:x-1] + c + s[end:]
+    elif s[x] == 'n':
+      # newline
+      s = s[:x-1] + '\n' + s[x+1:]
+    else:
+      break
+  return s
+
+class magicTest:
+  def __init__(self, offset, t, op, value, msg, mask = None):
+    if t.count('&') > 0:
+      mask = strToNum(t[t.index('&')+1:])  
+      t = t[:t.index('&')]
+    if type(offset) == type('a'):
+      self.offset = strToNum(offset)
+    else:
+      self.offset = offset
+    self.type = t
+    self.msg = msg
+    self.subTests = []
+    self.op = op
+    self.mask = mask
+    self.value = value
+      
+
+  def test(self, data):
+    if self.mask:
+      data = data & self.mask
+    if self.op == '=': 
+      if self.value == data: return self.msg
+    elif self.op ==  '<':
+      pass
+    elif self.op ==  '>':
+      pass
+    elif self.op ==  '&':
+      pass
+    elif self.op ==  '^':
+      pass
+    return None
+
+  def compare(self, data):
+    #print str([self.type, self.value, self.msg])
+    try: 
+      if self.type == 'string':
+        c = ''; s = ''
+        for i in range(0, len(self.value)+1):
+          if i + self.offset > len(data) - 1: break
+          s = s + c
+          [c] = struct.unpack('c', data[self.offset + i])
+        data = s
+      elif self.type == 'short':
+        [data] = struct.unpack('h', data[self.offset : self.offset + 2])
+      elif self.type == 'leshort':
+        [data] = struct.unpack('<h', data[self.offset : self.offset + 2])
+      elif self.type == 'beshort':
+        [data] = struct.unpack('>H', data[self.offset : self.offset + 2])
+      elif self.type == 'long':
+        [data] = struct.unpack('l', data[self.offset : self.offset + 4])
+      elif self.type == 'lelong':
+        [data] = struct.unpack('<l', data[self.offset : self.offset + 4])
+      elif self.type == 'belong':
+        [data] = struct.unpack('>l', data[self.offset : self.offset + 4])
+      else:
+        #print 'UNKNOWN TYPE: ' + self.type
+        pass
+    except:
+      return None
+  
+#    print str([self.msg, self.value, data])
+    return self.test(data)
+    
+
+def load(file):
+  global magicNumbers
+  lines = open(file).readlines()
+  last = { 0: None }
+  for line in lines:
+    if re.match(r'\s*#', line):
+      # comment
+      continue
+    else:
+      # split up by space delimiters, and remove trailing space
+      line = string.rstrip(line)
+      line = re.split(r'\s*', line)
+      if len(line) < 3:
+        # bad line
+        continue
+      offset = line[0]
+      type = line[1]
+      value = line[2]
+      level = 0
+      while offset[0] == '>':
+        # count the level of the type
+        level = level + 1
+        offset = offset[1:]
+      l = magicNumbers
+      if level > 0:
+        l = last[level - 1].subTests
+      if offset[0] == '(':
+        # don't handle indirect offsets just yet
+        print 'SKIPPING ' + string.join(list(line[3:]))
+        pass
+      elif offset[0] == '&':
+        # don't handle relative offsets just yet
+        print 'SKIPPING ' + string.join(list(line[3:]))
+        pass
+      else:
+        operands = ['=', '<', '>', '&']
+        if operands.count(value[0]) > 0:
+          # a comparison operator is specified
+          op = value[0] 
+          value = value[1:]
+        else:
+          print str([value, operands])
+          if len(value) >1 and value[0] == '\\' and operands.count(value[1]) >0:
+            # literal value that collides with operands is escaped
+            value = value[1:]
+          op = '='
+
+        mask = None
+        if type == 'string':
+          while 1:
+            value = unescape(value)
+            if value[len(value)-1] == ' ' and len(line) > 3:
+              # last value was an escaped space, join
+              value = value + line[3]
+              del line[3]
+            else:
+              break
+        else:
+          if value.count('&') != 0:
+            mask = value[(value.index('&') + 1):]
+            print 'MASK: ' + mask
+            value = value[:(value.index('&')+1)]
+          try: value = strToNum(value)
+          except: continue
+          msg = string.join(list(line[3:]))
+        new = magicTest(offset, type, op, value, msg, mask)
+        last[level] = new
+        l.append(new)
+
+def whatis(data):
+  for test in magicNumbers:
+     m = test.compare(data)
+     if m: return m
+  # no matching, magic number. is it binary or text?
+  for c in data:
+    if ord(c) > 128:
+      return 'data'
+  # its ASCII, now do text tests
+  if string.find('The', data, 0, 8192) > -1:
+    return 'English text'
+  if string.find('def', data, 0, 8192) > -1:
+    return 'Python Source'
+  return 'ASCII text'
+      
+    
+def file(file):
+  try:
+    return whatis(open(file, 'r').read(8192))
+  except Exception, e:
+    if str(e) == '[Errno 21] Is a directory':
+      return 'directory'
+    else:
+      raise e
+  
+
+#### BUILD DATA ####
+#load('mime-magic')
+#f = open('out', 'w')
+#for m in magicNumbers:
+#  f.write(str([m.offset, m.type, m.op, m.value, m.msg]) + ',\n')
+#f.close
+
+import sys
+for m in magic:
+  magicNumbers.append(magicTest(m[0], m[1], m[2], m[3], m[4]))
+
+if __name__ == '__main__':
+  import sys
+  for arg in sys.argv[1:]:
+    msg = file(arg)
+    if msg:
+      print arg + ': ' + msg
+    else:
+      print arg + ': unknown'


Property changes on: haypo/hachoir/branches/hachoir-yield/fallback/magic.py
___________________________________________________________________
Name: svn:mime-type
   + text/script

Modified: haypo/hachoir/branches/hachoir-yield/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/field/field_set.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -1,6 +1,7 @@
 from event_handler import EventHandler
 from field import Field
 from indexed_dict import IndexedDict
+import config
 
 class FieldDoesExist(KeyError):
     pass
@@ -13,18 +14,57 @@
     Ordered list of fields. Use operator [] to access fields using their
     name (field names are unique in a field set, but not in the whole
     document).
+
+    Class attributes:
+       * endian: Default endian of integer fields ("!" by default,
+         network order). Values can be "!" (network order, little endian),
+         ">" (same than "!"), or ">" (big endian)
+       * static_size: Size of FieldSet in bits (optionnal attribute).
+         This attribute is optionnal and should be used in parser when
+         the size is constant
+
+    Instance attributes/methods:
+       * fields: Ordered dictionnary of all fields, may be incomplete
+         because feeded when a field is requested
+       * stream: Input stream used to feed fields' value
+       * root: The root of all field sets
+       * __len__(): Number of fields, may need to create field set 
+       * __getitem(): Get an field by it's name or it's path
+
+    And attributes inherited from Field class:
+       * parent: Parent field (may be None if it's the root)
+       * name: Field name (unique in parent field set)
+       * value: The field set
+       * address: Field address (in bits) relative to parent
+       * description: A string describing the content (can be None)
+       * size: Size of field set in bits, may need to create field set
+
+    Event handling:
+       * connect: Connect an handler to an event
+       * raiseEvent: Raise an event 
+   
+    To implement a new field set, you need to:
+       * create a class which inherite from FieldSet
+       * write createFields() method using lines like:
+         "yield <field class>(self, <field name>, ...)"
+       * and maybe set endian/static_size class attributes
     """
+
     is_field_set = True
     endian = "!"
 
-    def __init__(self, parent, name, stream, description=None):
-        Field.__init__(self, parent, name, self, description=description)
+    def __init__(self, parent, name, stream, description=None, size=None):
+        if hasattr(self, "static_size"):
+            self._size = self.static_size
+        else:
+            self._size = size 
+        assert self.endian in ("!", "<", ">")
+        Field.__init__(self, parent, name, self, size=self._size, description=description)
         self.stream = stream
         self.fields = IndexedDict()
         self._event_handler = None
         self._field_generator = self.createFields()
         self._field_array_count = {}
-        self._size = None
         self._total_field_size = 0
         if parent != None:
             self.root = parent.root
@@ -49,6 +89,8 @@
         self._event_handler.connect(event_name, handler)
 
     def __len__(self):
+        if self._field_generator != None:
+            self._feedAll()
         return len(self.fields)
 
     def _getSize(self):
@@ -65,7 +107,7 @@
         stream_address = self.absolute_address + self._total_field_size
         field = self._field_generator.next()
 
-        if False:
+        if config.debug:
             addr = field.absolute_address
             print "* Instanciate %s (addr=%s.%s, size=%s bits)" \
                 % (field.path, addr/8, addr%8, field.size)
@@ -168,15 +210,17 @@
             self._stopFeeding()
 
     def __iter__(self):
+        # Iterate in existing fields
+        for field in self.fields:
+            yield field
+        
+        # If field set in not yet complete, continue to feed it
         if self._field_generator != None:
             try:
                 while True:
                     yield self._feed()
             except StopIteration:
                 self._stopFeeding()
-        else:
-            for field in self.fields:
-                yield field
 
     def createFields(self):
         raise NotImplementedError

Modified: haypo/hachoir/branches/hachoir-yield/field/integer.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/field/integer.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/field/integer.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -54,3 +54,13 @@
         return hexadecimal(self)
     display = property(_getDisplay)
 
+class Enum(Integer):   
+    def __init__(self, parent, name, format, enum, description=None):
+        self.enum = enum
+        Integer.__init__(self, parent, name, format, description)
+    
+    def _getDisplay(self):
+        value = self.value
+        return self.enum.get(value, value)
+    display = property(_getDisplay)
+

Added: haypo/hachoir/branches/hachoir-yield/file/image/bmp.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/bmp.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/file/image/bmp.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,56 @@
+"""
+Microsoft Bitmap picture parser.
+- file extension: ".bmp"
+
+Author: Victor Stinner
+Creation: 16 december 2005
+"""
+
+from field import FieldSet, Integer, String, ParserError
+from metadata import ImageMetaData
+
+class BmpMetaData(ImageMetaData):
+    def __init__(self, bmp):
+        width, height = bmp["width"].value, bmp["height"].value
+        bpp = bmp["bpp"].value
+        if "used_colors" in bmp:
+            nb_colors = bmp["used_colors"].value 
+        else:
+            nb_colors = None
+        if bmp["compression"].value != 0:
+            compression = "(compressed)"
+        else:
+            compression = "No"
+        ImageMetaData.__init__(self, width, height, bpp, nb_colors=nb_colors)
+
+class BmpFile(FieldSet):
+    mime_types = ["image/x-ms-bmp", "image/x-bmp"]
+    endian = "<"
+    
+    def createFields(self):
+        yield String(self, "header", "string[2]", "Header (\"BM\")")
+        if self["header"].value != "BM": 
+            raise ParserError(
+                "BMP picture parser error: indentifier is uncorrect")
+        yield Integer(self, "file_size", "uint32", "File size (bytes)")
+        yield Integer(self, "notused", "uint32", "Reseved")
+        yield Integer(self, "data_start", "uint32", "Data start position")
+        yield Integer(self, "header_size", "uint32", "Header size")
+        if self["header_size"].value not in (12, 40):
+            raise ParserError(
+                "BMP picture parser error: header size is uncorrect " \
+                "(%s instead of 12 or 40)" % \
+                self["header_size"].value)
+        yield Integer(self, "width", "uint32", "Width (pixels)")
+        yield Integer(self, "height", "uint32", "Height (pixels)")
+        yield Integer(self, "nb_plan", "uint16", "Number of plan (=1)")
+        yield Integer(self, "bpp", "uint16", "Bits per pixel")
+        if self["header_size"].value == 40:
+            yield Integer(self, "compression", "uint32", "Compression method")
+            yield Integer(self, "image_size", "uint32", "Image size (bytes)")
+            yield Integer(self, "horizontal_dpi", "uint32", "Horizontal DPI")
+            yield Integer(self, "vertical_dpi", "uint32", "Vertical DPI")
+            yield Integer(self, "used_colors", "uint32", "Number of color used")
+            yield Integer(self, "important_color", "uint32", "Number of import colors")
+#        self.addPadding("data", "Image raw data")
+

Modified: haypo/hachoir/branches/hachoir-yield/file/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/file/image/png.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -105,6 +105,8 @@
         yield IntegerHex(self, "crc32", "uint32", "CRC32")
 
 class PngFile(FieldSet):
+    mime_types = ["image/png", "image/x-png"]
+
     def createFields(self):
         yield String(self, "id", "string[8]", "PNG identifier") 
         if self["id"].value != "\x89PNG\r\n\x1A\n":

Added: haypo/hachoir/branches/hachoir-yield/file/system/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/file/system/ext2.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/file/system/ext2.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/file/system/ext2.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,447 @@
+"""
+EXT2 (Linux) file system parser.
+
+Sources:
+- EXT2FS source code
+  http://ext2fsd.sourceforge.net/
+- Analysis of the Ext2fs structure
+  http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
+"""
+
+from text_handler import unixTimestamp
+from field import FieldSet, Integer, String
+from tools import humanDuration, getUnixRWX, humanFilesize
+
+class DirectoryEntry(FieldSet):
+    file_type = {
+        1: "Regular",
+        2: "Directory",
+        3: "Char. dev.",
+        4: "Block dev.",
+        5: "Fifo",
+        6: "Socket",
+        7: "Symlink",
+        8: "Max"
+    }
+    endian = "<"
+    
+    def createFields(self):
+        yield Integer("inode", "uint32", "Inode")
+        yield Integer("rec_len", "uint16", "Record length")
+        name_length = self.doRead("name_len", "B", "Name length", (FormatChunk, "uint8")).value
+        yield Integer("file_type", "uint8", DirectoryEntry.file_type, "File type")
+        self.read("name", "File name", (FormatChunk, "string[%u]" % name_length))
+        size = self["rec_len"]-8-name_length 
+        if size != 0:
+            self.read("padding", "Padding", (FormatChunk, "string[%u]" % size))
+
+    def updateParent(self, chunk):        
+        name = self["name"].strip("\0")
+        if name != "":
+            desc = "Directory entry: %s" % name
+        else:
+            desc = "Directory entry (empty)"
+        chunk.description = desc
+        self.setDescription(desc)
+
+class Inode(FieldSet):
+    name = {
+        1: "list of bad blocks",
+        2: "Root directory",
+        3: "ACL inode",
+        4: "ACL inode",
+        5: "Boot loader",
+        6: "Undelete directory",
+        8: "EXT3 journal"
+    }
+
+    endian = "<"
+    static_size = (68 + 15*4)*8
+
+    def __init__(self, parent, name, stream, index, description=None):
+        self.index = index
+        FieldSet.__init__(self, parent, name, stream, description)
+        
+        if self.description == None:
+            desc = "Inode %s: " % self.index
+
+            if 11 <= self.index:
+                size = humanFilesize(self["size"].value)
+                desc += "file, size=%s, mode=%s" % (size, self["mode"].display)
+            else:
+                if self.index in Inode.name:
+                    desc += Inode.name[self.index]
+                    if self.index == 2:
+                        desc += " (%s)" % getUnixRWX(self["mode"].value)
+                else:
+                    desc += "special"
+                if self["size"].value == 0:
+                    desc += " (unused)"
+            self.description = desc
+
+    def createFields(self):
+        self.read("mode", "Mode", (FormatChunk, "uint16"), {"post": self.postMode})
+        yield Integer("uid", "uint16", "User ID")
+        yield Integer("size", "uint32", "File size (in bytes)")
+        yield Integer("atime", "uint32", "Last access time") # {"post": unixTimestamp}
+        yield Integer("ctime", "uint32", "Creation time") # {"post": unixTimestamp}
+        yield Integer("mtime", "uint32", "Last modification time") # {"post": unixTimestamp}
+        yield Integer("dtime", "uint32", "Delete time") #  {"post": unixTimestamp}
+        yield Integer("gid", "uint16", "Group ID")
+        yield Integer("links_count", "uint16", "Links count")
+        yield Integer("blocks", "uint32", "Number of blocks")
+        yield Integer("flags", "uint32", "Flags")
+        yield Integer("reserved1", "uint32", "Reserved")
+        for i in range(0,15):
+            yield Integer("block[]", "uint32", "Block %i" % i)
+        yield Integer("version", "uint32", "Version")
+        yield Integer("file_acl", "uint32", "File ACL")
+        yield Integer("dir_acl", "uint32", "Directory ACL")
+        yield Integer("faddr", "uint32", "Block where the fragment of the file resides")
+        
+        os = self["/superblock/creator_os"].value
+        if os == SuperBlock.OS_LINUX:
+            yield Integer("frag", "uint8", "Number of fragments in the block")
+            yield Integer("fsize", "uint8", "Fragment size")
+            yield Integer("padding", "uint16", "Padding")
+            yield Integer("uid_high", "uint16", "High 16 bits of user ID")
+            yield Integer("gid_high", "uint16", "High 16 bits of group ID")
+            yield Integer("reserved", "uint32", "Reserved")
+        elif os == SuperBlock.OS_HURD:
+            yield Integer("frag", "uint8", "Number of fragments in the block")
+            yield Integer("fsize", "uint8", "Fragment size")
+            yield Integer("mode_high", "uint16", "High 16 bits of mode")
+            yield Integer("uid_high", "uint16", "High 16 bits of user ID")
+            yield Integer("gid_high", "uint16", "High 16 bits of group ID")
+            yield Integer("author", "uint32", "Author ID (?)")
+        else:
+            yield String("raw", "string[12]", "Reserved")
+
+    def postMode(self, chunk):
+        mode = chunk.value
+        text = ""
+        if mode & 0100000 != 0:
+            text = "regular (%s)" % getUnixRWX(mode)
+        elif mode & 0040000:
+            text = "directory (%s)" % getUnixRWX(mode)
+        elif mode & 0020000:
+            text = "char. dev."
+        elif mode & 0060000:
+            text = "block dev."
+        elif mode & 0010000:
+            text = "fifo"
+        elif mode & 0120000:
+            text = "sym. link"
+        elif mode & 0140000:
+            text = "socket"
+        elif mode == 0:
+            text = "(empty)"
+        else:
+            text = "???"
+        return text
+
+class Bitmap(FieldSet):
+    def __init__(self, parent, name, stream, count, start, description=None):
+        if description != None:
+            description = "%s: %s items" % (description, count)
+        FieldSet.__init__(self, parent, name, stream, description)
+        assert (count % 8) == 0
+        self._size = count / 8
+        self.start = start
+        self.count = count
+
+    def createFields(self):
+        yield String("block_bitmap", "string[%u]" % self._size, "Bitmap")
+
+#    def showFree(self, type="Block"):
+#        data = self["block_bitmap"]
+#        cpt = self.start
+#        for octet in data:
+#            octet = ord(octet)
+#            mask = 1
+#            for i in range(0,8):
+#                if octet & mask == 0:
+#                    print "%s %s free." % (type, cpt)
+#                cpt = cpt + 1
+#                mask = mask << 1
+
+BlockBitmap = Bitmap
+InodeBitmap = Bitmap
+
+class GroupDescriptor(FieldSet):
+    endian = "<"
+    static_size = 32*8
+
+    def __init__(self, parent, name, stream, index, description="Group descriptor"):
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.index = index
+
+        # Set description
+        superblock = self["/superblock"]
+        blocks_per_group = superblock["blocks_per_group"].value
+        start = self.index * blocks_per_group
+        end = start + blocks_per_group 
+        self.description = "Group descriptor: blocks %s-%s" % (start, end)
+
+    def createFields(self):
+        yield Integer("block_bitmap", "uint32", "Points to the blocks bitmap block")
+        yield Integer("inode_bitmap", "uint32", "Points to the inodes bitmap block")
+        yield Integer("inode_table", "uint32", "Points to the inodes table first block")
+        yield Integer("free_blocks_count", "uint16", "Number of free blocks")
+        yield Integer("free_inodes_count", "uint16", "Number of free inodes")
+        yield Integer("used_dirs_count", "uint16", "Number of inodes allocated to directories")
+        yield Integer("padding", "uint16", "Padding")
+        yield String("reserved", "string[12]", "Reserved")
+   
+class SuperBlock(FieldSet):
+    error_handling = {
+        1: "Continue"
+    }
+    OS_LINUX = 0
+    OS_HURD = 1
+    os_name = {
+        0: "Linux",
+        1: "Hurd",
+        2: "Masix",
+        3: "FreeBSD",
+        4: "Lites",
+        5: "WinNT"
+    }
+    state = {
+        1: "Valid",
+        2: "Error"
+    }
+ 
+    static_size = 433*8
+ 
+    def __init__(self, parent, name, stream, description="Super block"):
+        FieldSet.__init__(self, parent, name, stream, description)
+        if self["feature_compat"].value & 4 == 4:
+            type = "ext3"
+        else:
+            type = "ext2"
+        self.description = "Superblock: %s file system" % type
+
+    def createFields(self):
+        yield Integer("inodes_count", "uint32", "Inodes count")
+        yield Integer("blocks_count", "uint32", "Blocks count")
+        yield Integer("r_blocks_count", "uint32", "Reserved blocks count")
+        yield Integer("free_blocks_count", "uint32", "Free blocks count")
+        yield Integer("free_inodes_count", "uint32", "Free inodes count")
+        yield Integer("first_data_block", "uint32", "First data block")
+        if self["first_data_block"].value != 0:
+            raise ParserError(
+                "Stream doesn't looks like EXT2/EXT3 partition "
+                "(first data block is %s instead of 0)" %
+                self["first_data_block"].value)                
+        yield Integer("log_block_size", "uint32", "Block size")
+        yield Integer("log_frag_size", "uint32", "Fragment size")
+        yield Integer("blocks_per_group", "uint32", "Blocks per group")
+        yield Integer("frags_per_group", "uint32", "Fragments per group")
+        yield Integer("inodes_per_group", "uint32", "Inodes per group")
+        yield Integer("mtime", "uint32", "Mount time") #  {"post": unixTimestamp}
+        yield Integer("wtime", "uint32", "Write time") #  {"post": unixTimestamp}
+        yield Integer("mnt_count", "uint16", "Mount count")
+        yield Integer("max_mnt_count", "int16", "Max mount count")
+        yield String("magic", "string[2]", "Magic number (0x53EF)")
+        if self["magic"].value != "\x53\xEF":
+            raise ParserError(
+                "Stream doesn't looks like EXT2/EXT3 partition "
+                "(invalid magic value)")
+        yield Integer("state", "uint16", SuperBlock.state, "File system state")
+        yield Enum("errors", "uint16", SuperBlock.error_handling, "Behaviour when detecting errors")
+        yield Integer("minor_rev_level", "uint16", "Minor revision level")
+        yield Integer("last_check", "uint32", "Time of last check") #  {"post": unixTimestamp}
+        yield Integer("check_interval", "uint32", "Maximum time between checks") #  {"post": self.postMaxTime}
+        yield Enum("creator_os", "uint32", SuperBlock.os_name, "Creator OS")        
+        yield Integer("rev_level", "uint32", "Revision level")
+        yield Integer("def_resuid", "uint16", "Default uid for reserved blocks")
+        yield Integer("def_resgid", "uint16", "Default guid for reserverd blocks")
+        yield Integer("first_ino", "uint32", "First non-reserved inode")
+        yield Integer("inode_size", "uint16", "Size of inode structure")
+        if self["inode_size"].value != (68 + 15*4):
+            raise ParserError(
+                "EXT2/EXT3 parser error: inode of size %s are not supported" \
+                % self["inode_size"].value)
+        yield Integer("block_group_nr", "uint16", "Block group # of this superblock")
+        yield Integer("feature_compat", "uint32", "Compatible feature set")
+        yield Integer("feature_incompat", "uint32", "Incompatible feature set")
+        yield Integer("feature_ro_compat", "uint32", "Read-only compatible feature set")
+        yield String("uuid", "string[16]", "128-bit uuid for volume")
+        yield String("volume_name", "string[16]", "Volume name")
+        yield String("last_mounted", "string[64]", "Directory where last mounted")
+        yield Integer("compression", "uint32", "For compression (algorithm usage bitmap)")
+        yield Integer("prealloc_blocks", "uint8", "Number of blocks to try to preallocate")
+        yield Integer("prealloc_dir_blocks", "uint8", "Number to preallocate for directories")
+        yield Integer("padding", "uint16", "Padding")
+        yield String("journal_uuid", "string[16]", "uuid of journal superblock")
+        yield Integer("journal_inum", "uint32", "inode number of journal file")
+        yield Integer("journal_dev", "uint32", "device number of journal file")
+        yield Integer("last_orphan", "uint32", "start of list of inodes to delete")
+        yield String("reserved", "string[197]", "Padding to the end of the block")
+
+        # Calculate number of groups
+        blocks_per_group = self["blocks_per_group"].value
+        self.group_count = (self["blocks_count"].value - self["first_data_block"].value + (blocks_per_group - 1)) / blocks_per_group
+ 
+#    def postMaxTime(self, chunk):
+#        return humanDuration(chunk.value * 1000)
+
+class GroupDescriptors(FieldSet):
+    def __init__(self, parent, name, stream, start, count, description=None):
+        if description == None:
+            description = "Group descriptors: %s items" % count
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.start = start
+        self.count = count
+
+    def createFields(self):
+        for index in range(0, self.count):
+            yield GroupDescriptor(self, "group[]", self.stream, index)
+
+    def getGroup(self, index):
+        return self["group[%s]" % (self.start + index)]
+
+class InodeTable(FieldSet):
+    def __init__(self, parent, name, stream, start, count, description=None):
+        if description == None:
+            description = "Inode table: %s inodes" % count
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.start = start
+        self.count = count
+
+    def createFields(self):
+        for index in range(self.start, self.start+self.count):
+            yield Inode(self, "inode[]", index, description="Inode %s" % index)
+
+    def __getitem__(self, index):
+        index = index - self.start - 1
+        return self.getChunk("inode[%u]" % index).getFilter()
+
+def testSuperblock(stream):
+    oldpos = stream.tell()
+    stream.seek(56, 1)
+    magic = stream.getN(2)    
+    stream.seek(oldpos)
+    return (magic == "\x53\xEF")
+
+class Group(FieldSet):
+    def __init__(self, stream, parent, index, description=None):
+        if description == None:
+            description = "Group %u" % index
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.index = index
+
+    def createFields(self):
+        group = self["../group_desc"].getGroup(index)
+        superblock = self["/superblock"]
+        block_size = self["/"].block_size
+    
+        # Read block bitmap
+        self.superblock_copy = False
+        if testSuperblock(stream):
+            self.superblock_copy = True
+            yield SuperBlock(self, "superblock_copy", self.stream, "Superblock")
+        self.seek(group["block_bitmap"] * block_size)
+            
+        count = superblock["blocks_per_group"]
+        yield BlockBitmap(self, "block_bitmap[]", self.stream, count, 0, "Block bitmap")
+
+        # Read inode bitmap
+        assert (group["inode_bitmap"] * block_size) == stream.tell()
+        count = superblock["inodes_per_group"]
+        self.read("inode_bitmap[]", "Inode bitmap", (InodeBitmap, "Inode bitmap", count, 1), {"size": count / 8})
+        addr = stream.tell() % 4096
+        if addr != 0:
+            addr = stream.tell() + (4096 - addr % 4096)
+            self.seek(addr)
+             
+        count = superblock["inodes_per_group"]
+        size = superblock["inode_size"] * count
+        inode_index = 1 + index * count
+        self.read("inode_table[]", "Inode table", (InodeTable, inode_index, count), {"size": size})
+
+        size = (index+1) * superblock["blocks_per_group"] * block_size
+        if stream.getSize() < size:
+            size = stream.getSize()
+        size = size - stream.tell() 
+        self.read("data", "Data", (FormatChunk, "string[%u]" % size))
+
+    def updateParent(self, chunk):
+        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
+        if self.superblock_copy:
+            desc = desc + " (with superblock copy)"
+        chunk.description = desc 
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        assert 0 <= size
+        if 0 < size:
+            self.read("raw[]", "Raw", (FormatChunk, "string[%u]" % size))
+
+class EXT2_FS(FieldSet):
+    """
+    Parse an EXT2 or EXT3 partition.
+
+    Attributes:
+       * block_size: Size of a block (in bytes)
+
+    Fields:
+       * superblock: Most important block, store most important informations
+       * ...
+    """
+    mime_types = "hachoir/fs-ext2"
+
+    def __init__(self, parent, name, stream, description="EXT2 file system"):
+        FieldSet.__init__(self, parent, name, stream, description)
+
+    def createFields(self):
+        # Skip something (what is stored here? MBR?) 
+        self.seek(1024) 
+        
+        # Read superblock
+        superblock = SuperBlock(self, "superblock", self.stream)
+        yield superblock
+        self.block_size = 1024 << superblock["log_block_size"].value # in bytes
+
+        # Read groups' descriptor
+        self.seek(4096) 
+        groups = GroupDescriptors(self, "group_desc", self.stream, 0, superblock.group_count)
+        yield groups
+
+        # Read groups
+        address = groups.getGroup(0)["block_bitmap"].value * self.block_size * 8
+        self.seek(address)
+        for i in range(0, superblock.group_count):
+            self.read("group[]", "Group", (Group, i))
+
+        # Padding (?)
+        size = stream.getSize() - stream.tell()
+        if size != 0:
+            self.read("end", "End (raw)", (FormatChunk, "string[%u]" % size))
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        assert 0 <= size
+        if 0 < size:
+            yield String(self, "raw[]", "string[%u]" % size, raw)
+
+#    def readDirectory(self, inode):
+#        stream = self.getStream()
+#        block_index = 0
+#        while True:
+#            assert block_index < 12
+#            block = inode["block[%u]" % block_index]
+#            if block == 0:
+#                return
+#            self.seek(block * self.block_size)
+#
+#            total = 0
+#            while total < self.block_size:
+#                entry = self.doRead("directory[]", "Directory entry", (DirectoryEntry,))
+#                if entry["inode"] == 0:
+#                    return
+#                total = total + entry.getSize()
+#            assert total == self.block_size
+#            block_index = block_index + 1
+

Modified: haypo/hachoir/branches/hachoir-yield/generic/image.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/generic/image.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/generic/image.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -5,12 +5,12 @@
         0x000000: "Black",
         0xFFFFFF: "White"
     }
+    static_size = 3*8
     
-    def __init__(self, parent, name, description=None):
-        FieldSet.__init__(self, parent, name, parent.stream, description)
+    def __init__(self, parent, name, stream, description=None):
+        FieldSet.__init__(self, parent, name, stream, description)
         if self.description == None:
             self.description = self.getColorName()
-        self._size = 3
 
     def createFields(self):
         yield Integer(self, "red", "uint8", "Red")
@@ -28,11 +28,12 @@
 class Palette(FieldSet):
     def __init__(self, parent, name, nb_colors, description=None):
         self.nb_colors = nb_colors
+        size = self.nb_colors * RGB.static_size
         if description == None:
             description = "Palette of %u RGB colors" % self.nb_colors
-        FieldSet.__init__(self, parent, name, parent.stream, description=description)
+        FieldSet.__init__(self, parent, name, parent.stream, size=size, description=description)
 
     def createFields(self):
         for i in range(0, self.nb_colors):
-            yield RGB(self, "color[]")
+            yield RGB(self, "color[]", self.stream)
 

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -1,31 +1,49 @@
 #!/usr/bin/env python
 
-from file.image.png import PngFile, PngMetaData
-from file.image.bmp import BmpFile, BmpMetaData
-from file.image.pcx import PcxFile, PcxMetaData
+VERSION = "0.2veryalpha"
+
 from stream.file import FileStream
 from text_ui import displayFieldSet
-import sys
+from plugin import loadPlugins, guessPlugin
+from log import log
+from error import error
+from mime import getStreamMime
+import sys, os
 
+def usage():
+    print "Hachoir version %s" % VERSION
+    print
+    print "Usage: %s filename" % sys.argv[0]
+
 def main():
-    if 2 <= len(sys.argv):
-        filename = sys.argv[1]
-    else:
-        filename = "/home/haypo/exemple/png.png"
+    root_dir = os.path.dirname(__file__)
+
+    # Create input stream (read filename from command line first argument)
+    if len(sys.argv) < 2:
+        usage()
+        sys.exit(1)
+    filename = sys.argv[1]
     stream = FileStream(open(filename, 'r'), filename)
-    if filename.endswith(".png"):
-        png = PngFile(None, "png_file", stream)
-        print "[Picture %s]" % filename
-        displayFieldSet(png, 3)
-        meta = PngMetaData(png) ; print meta
-    elif filename.endswith(".pcx"):
-        pcx = PcxFile(None, "pcx_file", stream)
-        displayFieldSet(pcx, 2)
-        meta = PcxMetaData(pcx) ; print meta
+
+    # Load plugings
+    modules = loadPlugins(os.path.join(root_dir, "file"))
+    modules.sort()
+    log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
+
+    # Look for right plugin
+    plugin = guessPlugin(stream, filename, None)
+    if plugin != None:
+        # Create field set and display it
+        field_set = plugin(None, "file", stream)
+        displayFieldSet(field_set, None)
+#        meta = PngMetaData(png) ; print meta
+#        meta = PcxMetaData(pcx) ; print meta
+#        meta = BmpMetaData(bmp) ; print meta
     else:
-        bmp = BmpFile(None, "bmp_file", stream)
-        displayFieldSet(bmp)
-        meta = BmpMetaData(bmp) ; print meta
+        msg  = "Sorry, can't find plugin for file \"%s\"!" % filename
+        mimes = [ mime[0] for mime in getStreamMime(stream, filename) ]
+        msg += "\n\nFile mimes: %s" % ", ".join(mimes)
+        error(msg)
 
 if __name__ == "__main__":
     main()

Added: haypo/hachoir/branches/hachoir-yield/log.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/log.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/log.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,93 @@
+#!/usr/bin/env python
+# -*- coding: UTF-8 -*-
+
+import time
+
+class Log:
+    LOG_INFO   = 0
+    LOG_WARN   = 1
+    LOG_ERROR  = 2
+
+    def __init__(self):
+        self.__buffer = {}
+        self.__file = None
+        self.use_print = True
+        self.on_new_message = None # (level, prefix, text)
+
+    def setFilename(self, filename):
+        """
+        Use a file to store all messages. The
+        UTF-8 encoding will be used. Write an informative
+        message if the file can't be created.
+
+        @param filename: C{L{string}}
+        """
+
+        try:
+            import codecs
+            self.__file = codecs.open(filename, "w", "utf-8")
+        except IOError, errno:
+            if errno[0] == 2:
+                self.__file = None
+                self.info("Log.setFilename(%s) fails : no such file." % filename)
+                return
+            raise
+
+    def getLevelPrefix(self, level):
+        """
+        String prefix which depends on message level.
+        Eg. information returns "[info]".
+        @return: C{str}
+        """
+        if level==Log.LOG_WARN: return "[warn]"
+        if level==Log.LOG_ERROR: return "[err!]"
+        return "[info]"
+
+    def newMessage(self, level, str):
+        """
+        Write a new message : append it in the buffer,
+        display it to the screen (if needed), and write
+        it in the log file (if needed).
+
+        @param level: Message level.
+        @type level: C{int}
+        @param str: Message content.
+        @type str: C{str}
+        """
+
+        if not self.__buffer.has_key(level):
+            self.__buffer[level] = [str]
+        else:
+            self.__buffer[level].append(str)
+        prefix = self.getLevelPrefix(level)            
+        if self.use_print:
+            print "%s %s" % (prefix, str)
+        if self.__file:
+            self.__file.write(u"%s - %s %s\n" \
+                % (time.strftime("%Y-%M-%d %H:%M:%S"),
+                   prefix, str))
+        if self.on_new_message:
+            self.on_new_message (level, prefix, str)
+
+    def info(self, str):
+        """
+        New informative message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_INFO, str)
+
+    def warning(self, str):
+        """
+        New warning message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_WARN, str)
+
+    def error(self, str):
+        """
+        New error message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_ERROR, str)
+
+log = Log()        


Property changes on: haypo/hachoir/branches/hachoir-yield/log.py
___________________________________________________________________
Name: svn:mime-type
   + text/script

Added: haypo/hachoir/branches/hachoir-yield/mime.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/mime.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/mime.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,206 @@
+"""
+MIME type detection using libmagic library.
+
+See also:
+- ftp://ftp.astron.com/pub/file/ (libmagic)
+- http://www.demonseed.net/~jp/code/magic.py (100% Python)
+- http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
+- files in /usr/share/misc/file/* (on Unix/BSD systems)
+"""
+
+import os, sys, stat, re
+from error import warning
+
+_mime_by_ext = {
+    '.gz':  'application/x-gzip',
+    '.ico': 'image/x-ico'
+}
+
+# Regular expression used to split a list of MIME types
+_mime_splitter_regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
+
+def getGuessFunc():
+    """
+    Find a function to guess MIME type of a buffer. Try to load libmagic
+    (python module "magic"), or use internal fallback.
+    @return: Function used to guess MIME type
+    @rtype: C{func}
+    """
+    try:
+        path = os.path.dirname(__file__)
+        sys.path.append(path)
+        import magic
+        func = magic.open(magic.MAGIC_MIME)
+        func.load()
+        return func.buffer
+    except ImportError:
+        warning("Warning: The library libmagic for Python is unavailable. "
+        "Using internal fallback engine.")
+        from fallback.magic import whatis
+        return whatis
+
+guessMime = getGuessFunc()
+
+def getFileMime(realname, filename=None):
+    """ Guess MIME type of a file.
+
+    @parameter realname: Physical filename (used to open the file)
+    @type host: C{str}
+    @parameter filename: Filename used to detect MIME type using its extension
+    @type host: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+    if filename == None:
+        filename = realname
+    mode = os.stat(filename)[stat.ST_MODE]
+    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
+    
+    content = file(filename, "rb").read(4096)
+    return getBufferMime(content, filename)
+
+def getMimeByExt(ext):    
+    """ Guess MIME type of a file using its extension
+
+    @parameter ext: Filename extension (eg. ".zip")
+    @type: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+    return _mime_by_ext.get(ext, None)
+
+def getStreamMime(stream, filename):
+    """ Guess MIME type of a stream using first 4 KB
+
+    @parameter stream: Stream containing data
+    @type: C{Stream}
+    @parameter filename: Filename of the stream source, can be None
+    @type: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+
+    oldpos = stream.tell()
+    stream.seek(0)
+    size = stream.getSize()
+    if 4096 < size:
+        size = 4096
+    data = stream.getN(size)
+    stream.seek(oldpos)
+    return getBufferMime(data, filename)
+
+def getAnotherBufferMime(content):    
+    """ Another method (L{guessMime}) to guess MIME type. This
+    function is used for uncommon MIME types like Gimp picture
+    (image/x-xcf).
+
+    @parameter content: First 4 KB of file/stream content.
+    @type: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+
+    if content[:2] == "\x4d\x4d" and content[6:12] == "\x02\0\x0A\0\0\0":
+        return "image/x-3ds"
+
+    if 2 <= len(content) and ord(content[0]) == 31 and ord(content[1]) == 139:
+        return "application/x-gzip"
+
+    # Text
+    if content[0:4] == "%PDF":
+        return "application/pdf"
+
+    # Pictures
+    if content[0:14] == "gimp xcf file\0":
+        return "image/x-xcf"
+
+    if content[0:2] == "\0\0" \
+    and content[2:4] in ("\x01\0", "\x02\0") \
+    and content[9] == "\0":
+        return "image/x-ico"
+
+    if content[0] == "\x0A" \
+    and content[1] in "\x00\x02\x03\x04\x05" \
+    and content[64] == "\0":
+        return "image/x-pcx"
+
+    # File system        
+    if 4096 <= len(content) \
+    and content[1080:1082] == "\x53\xEF" \
+    and content[1116:1120] == "\x04\x00\x00\x00":
+        return "hachoir/fs-ext2"
+        
+    if 512 <= len(content) \
+    and content[0] in "\xEB\xFA" \
+    and content[510:512] == "\x55\xAA" \
+    and content[446] in "\x00\x80" \
+    and content[446+16*1] in "\x00\x80" \
+    and content[446+16*2] in "\x00\x80" \
+    and content[446+16*3] in "\x00\x80":
+        return "hachoir/master-boot-record"
+    
+    # Worms2 files
+    if content[0:4] == "IMG\x1A":
+        return "hachoir/worms2-image"
+    if content[0:4] == "SPR\x1A":
+        return "hachoir/worms2-sprite"
+    if content[0:4] == "FNT\x1A":
+        return "hachoir/worms2-font"
+    if content[0:4] == "DIR\x1A":
+        return "hachoir/worms2-directory"
+    return None        
+
+def splitMimes(mimes):
+    """ Split flat MIME type string into a list in which each entry has
+    the following format: ["type", {"key1": value1, "key2": value2, ...}]
+
+    Examples:
+    - "text/plain; encoding=latin-1" => [["text/plain", {"encoding": latin-1"}]
+    - "text/plain, text/xml" => [["text/plain", {}],["text/xml", {}]]
+    - "text/plain; charset=ISO-8859-1; format=flowed"
+      => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
+
+    @parameter mimes: Flat MIME type string
+    @type: C{str}
+    @return: MIME type in a list
+    @rtype: C{list}
+    """
+
+    mimes = _mime_splitter_regex.findall(mimes)    
+    
+    mime_list = []
+    for mime in mimes:
+        parts = mime.strip(" ,").split(";")
+        mime = parts[0]
+        parts = [ item.strip() for item in parts[1:] ]
+        values = {}
+        for part in parts:
+            if part != "":
+                split_part = part.split("=", 1)             
+                values[ split_part[0] ] = split_part[1]
+        mime_list.append([mime, values])
+    return mime_list
+
+def getBufferMime(content, filename):
+    """ Main function used to guess the MIME types. It calls L{guessMime},
+    and then L{getAnotherBufferMime} if needed.
+
+    @parameter content: First 4 KB of file/stream content.
+    @type: C{str}
+    @parameter filename: Filename of the file/stream, can be None.
+    @type: C{str}
+    @return: MIME type list (same format than L{splitMimes} result)
+    @rtype: C{str}
+    """
+
+    mimes = guessMime(content)
+    mimes = splitMimes(mimes)
+    if len(mimes) == 0 \
+    or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
+        new_mime = getAnotherBufferMime(content)
+        if new_mime == None and filename != None:
+            ext = os.path.splitext(filename)[1]
+            new_mime = getMimeByExt(ext)
+        if new_mime != None:
+            mimes = ((new_mime, {}),)
+    return mimes

Added: haypo/hachoir/branches/hachoir-yield/plugin.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/plugin.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/plugin.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -0,0 +1,82 @@
+import re, os
+from stat import S_ISDIR, ST_MODE
+from mime import getFileMime, getStreamMime
+from error import warning
+
+regex_plugin_filename = re.compile(r"^([a-z0-9_]+)\.py$")
+
+def loadPluginFromFile(module_path, loaded):
+    try:
+        module = __import__(module_path)
+        for get in module_path.split(".")[1:]:
+            module = getattr(module, get)
+    except Exception, msg:
+        warning("Error while loading the plugin \"%s\": %s" \
+            % (module_path, msg))
+        return
+    for attr in module.__dict__:
+        item = getattr(module, attr)
+        if hasattr(item, "mime_types"):
+            registerPlugin(item, item.mime_types)
+            loaded.append(module_path)
+
+def loadPlugins(dir, module_path=None, loaded=[]):
+    """
+    Load all plugings from directory dir.
+
+    Do not set module_path or loaded, they are used internally.
+    """
+    if module_path == None:
+        module_path = os.path.basename(dir)
+    for file in os.listdir(dir):
+        fullpath = os.path.join(dir, file)
+        if S_ISDIR(os.stat(fullpath)[ST_MODE]):
+            loadPlugins(fullpath, module_path+"."+file, loaded)
+        else:
+            m = regex_plugin_filename.match(file)
+            if m != None and m.group(1) != "__init__":
+                path = module_path + "." + m.group(1)
+                loadPluginFromFile(path, loaded)
+    return loaded                    
+
+def guessPlugin(stream, filename, default=None):
+    return getPluginByStream(stream, filename, default)
+
+def getPluginByMime(mimes, default=None):
+    global hachoir_plugins
+    plugins = []
+    for mime in mimes:
+        mime = mime[0]
+        if mime in hachoir_plugins:
+            for plugin in hachoir_plugins[mime]:
+                if plugin not in plugins:
+                    plugins.append(plugin)
+    if len(plugins)==0:
+        return default
+    if 1<len(plugins):
+        plist = []
+        for plugin in plugins:
+            plist.append(plugin.__name__)
+        plist = ", ".join(plist)
+        warning("More than one plugin have same MIME:\n%s" % plist)
+    return plugins[0]
+    
+def getPluginByStream(stream, filename, default=None):
+    mime = getStreamMime(stream, filename)
+    return getPluginByMime(mime, default)
+
+def getPluginByFile(filename, realname=None, default=None):
+    mime = getFileMime(filename, realname)
+    return getPluginByMime(mime, default)
+    
+def registerPlugin(filter_class, mimes):
+    global hachoir_plugins
+    if isinstance(mimes, str):
+        mimes = [mimes]
+    for mime in mimes:
+        if mime in hachoir_plugins:
+            hachoir_plugins[mime].append(filter_class)
+        else:
+            hachoir_plugins[mime] = [filter_class]
+
+hachoir_plugins = {} 

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:17:26 UTC (rev 421)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 00:18:07 UTC (rev 422)
@@ -1,8 +1,12 @@
 def displayFieldSet(field_set, max_depth=2, depth=0):
+    parent_details = False
     indent = " " * (3*depth)
     addr = field_set.absolute_address
-    print "%s--- %s --- (addr=%u.%u, size=%s bits)" \
-        % (indent, field_set.name, addr/8, addr%8, field_set.size)
+    text = "%s--- %s ---" % (indent, field_set.name) 
+    if parent_details:
+        text += "(addr=%u.%u, size=%s bits)" \
+            % (addr/8, addr%8, field_set.size)
+    print text
     if max_depth == None or depth < max_depth:
         for field in field_set:
             if not field.is_field_set:



From haypo at berlios.de  Sat Mar  4 01:26:45 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 4 Mar 2006 01:26:45 +0100
Subject: [Happyboom-svn] r429 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/fallback branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser branches/hachoir-yield/libhachoir/parser/file_system branches/hachoir-yield/libhachoir/parser/image branches/hachoir-yield/libhachoir/stream
Message-ID: <200603040026.k240QjM2000082@sheep.berlios.de>

Author: haypo
Date: 2006-03-04 01:26:40 +0100 (Sat, 04 Mar 2006)
New Revision: 429

Added:
   haypo/hachoir/branches/hachoir-yield/libhachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/bits.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/cache.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/config.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/error.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/event_handler.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/
   haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/magic.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/format.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/log.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py
Removed:
   haypo/hachoir/branches/hachoir-yield/bits.py
   haypo/hachoir/branches/hachoir-yield/cache.py
   haypo/hachoir/branches/hachoir-yield/config.py
   haypo/hachoir/branches/hachoir-yield/error.py
   haypo/hachoir/branches/hachoir-yield/event_handler.py
   haypo/hachoir/branches/hachoir-yield/fallback/
   haypo/hachoir/branches/hachoir-yield/field/
   haypo/hachoir/branches/hachoir-yield/file/
   haypo/hachoir/branches/hachoir-yield/format.py
   haypo/hachoir/branches/hachoir-yield/generic/
   haypo/hachoir/branches/hachoir-yield/indexed_dict.py
   haypo/hachoir/branches/hachoir-yield/log.py
   haypo/hachoir/branches/hachoir-yield/mime.py
   haypo/hachoir/branches/hachoir-yield/plugin.py
   haypo/hachoir/branches/hachoir-yield/stream/
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/metadata.py
Log:
 r23 at haypopc:  haypo | 2006-03-03 19:55:12 +0100
 Move hachoir core to libhachoir subdirectory



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:22
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:23

Deleted: haypo/hachoir/branches/hachoir-yield/bits.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/bits.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/bits.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,112 +0,0 @@
-def str2hex(value):
-    text = ""
-    for character in value:
-        if text != "":
-            text += " "
-        text += "%02X" % ord(character)
-    return text
-
-def countBits(value):
-    """
-    0 -> 0 bit
-    1 -> 1 bit
-    2 -> 2 bits
-    4 -> 3 bits
-    ...
-    """
-    bits = 0
-    if value < 0:
-        bits += 1
-        value = -value
-    while value >= 1:
-        bits += 1
-        value >>= 1
-    return bits        
-
-def byte2bin(x, reverse=True):
-    text = ""
-    for i in range(0,8):
-        if reverse:
-            mask = 1 << (7-i)
-        else:
-            mask = 1 << i
-        if (x & mask) == mask:
-            text += "1"
-        else:
-            text += "0"
-    return text            
-
-def long2raw(value, big_endian=True):
-    """
-    Convert a number to a raw string in big endian order
-    Eg. 1 => "\x01"
-        0x1234 => "\x12\x34"
-
-    Use big_endian=False to get result in little endian order.
-    Eg. 0x1234 => "\x34\x12"
-    """
-    text = ""
-    while (value != 0 or text == ""):
-        byte = value & 0xFF            
-        text += chr(byte)
-        value >>= 8
-    if big_endian:
-        return text[::-1]
-    else:
-        return text        
-
-def long2bin(value, reverse=True):
-    text = ""
-    while (value != 0 or text == ""):
-        if text != "":
-            text += " "
-        byte = value & 0xFF            
-        text += byte2bin(byte, not reverse)
-        print "val=%s > %s" % (value, value >> 8)
-        value >>= 8
-    return text        
-
-def sized_long2bin(size, value, reverse=True):
-    text = ""
-    for i in range(size):
-        if (value & 1) == 1:
-            text += "1"
-        else:
-            text += "0"
-        value >>= 1
-    if reverse:
-        return text[::-1]
-    else:
-        return text        
-
-def str2bin(value, reverse=False):
-    text = ""
-    for character in value:
-        if text != "":
-            text += " "
-        byte = ord(character)
-        text += byte2bin(byte, not reverse)
-    return text
-
-def reverseBits(x):
-    y = 0
-    for i in range(0,8):
-        mask = (1 << i)
-        if (x & mask) == mask:
-            y |= (1 << (7-i))
-    return y
-
-def str2long(data, reverse_byte=False):
-    """
-    Convert a string into a number with big endian order.
-    Eg. "\0\1\2" => 0x001020
-    """
-    shift = 0
-    value = 0
-    for character in data:
-        byte = ord(character)
-        if reverse_byte:
-            byte = reverseBits(byte)
-        value += (byte << shift) 
-        shift += 8
-    return value        

Deleted: haypo/hachoir/branches/hachoir-yield/cache.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/cache.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/cache.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,53 +0,0 @@
-import gc
-
-class CacheList:
-    _instance = None
-
-    def __init__(self):
-        assert CacheList._instance == None
-        self._list = []
-
-    def purgeCaches(self):
-        size = self.getSize()
-        for value in self._list:
-            item, name = value
-            item.purgeCache()
-        gc.collect()            
-        print "Purge caches: clear %s item(s)" % size
-
-    def output(self):
-        size = 0
-        nb_obj = 0
-        print "--- Caches"
-        for value in self._list:
-            item, name = value
-            size = item.getCacheSize()
-            nb_obj += size
-            if size != 0:
-                print "o %s: %s item(s)" % (name, size)
-        print "--- Total = %s item(s)" % (nb_obj)
-
-    def getSize(self):
-        size = 0
-        for value in self._list:
-            size += value[0].getCacheSize()
-        return size           
-
-    def register(self, item, name):
-        self._list.append( (item,name) )
-
-    def getInstance():
-        if CacheList._instance == None:
-            CacheList._instance = CacheList()
-        return CacheList._instance
-    getInstance = staticmethod(getInstance)
-
-class Cache:
-    def __init__(self, name):
-        CacheList.getInstance().register(self, name)
-
-    def getCacheSize(self):
-        raise NotImplementedError()
-
-    def purgeCache(self):
-        raise NotImplementedError()

Deleted: haypo/hachoir/branches/hachoir-yield/config.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/config.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/config.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,13 +0,0 @@
-# UI: display options
-max_string_length = 10    # Max. length of displayed string
-max_hexa_length = 4096    # Max. length of raw data displayed in hex
-max_ascii_length = 4096   # Max. length of raw data displayed in ASCII
-
-# Global options
-debug = False 
-verbose = False
-
-# Size of file cache (for each opened file)
-file_cache_block_size = 4096  # 4 KB
-file_cache_block_count = 10   # Buffer = 10 * 4 KB
-best_stream_buffer_size = 64 * 1024  # 64 KB

Deleted: haypo/hachoir/branches/hachoir-yield/error.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/error.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/error.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,33 +0,0 @@
-import os
-import config
-from log import log
-#import ui.ui
-from tools import getBacktrace
-
-def warning(message):
-    if config.verbose or config.debug:
-        message += "\n\n" + getBacktrace()
-    log.warning(message)   
-#    if (config.verbose or config.debug) and ui.ui.ui != None:
-#        import gtk
-#        dlg = gtk.MessageDialog( \
-#            parent=ui.ui.ui.window.window,
-#            type=gtk.MESSAGE_WARNING,
-#            buttons=gtk.BUTTONS_OK,
-#            message_format=message)
-#        dlg.run()
-#        dlg.destroy()
-
-def error(message, backtrace=None):
-    if config.verbose or config.debug:
-        message += "\n\n" + getBacktrace()
-    log.error(message)
-#    if ui.ui.ui != None:
-#        import gtk
-#        dlg = gtk.MessageDialog( \
-#            parent=ui.ui.ui.window.window,
-#            type=gtk.MESSAGE_ERROR,
-#            buttons=gtk.BUTTONS_OK,
-#            message_format=message)
-#        dlg.run()
-#        dlg.destroy()

Deleted: haypo/hachoir/branches/hachoir-yield/event_handler.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/event_handler.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/event_handler.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,24 +0,0 @@
-class EventHandler(object):
-    _instance = None
-
-    # Singleton design pattern
-    def __new__(cls):
-        if cls._instance == None:
-            cls._instance = object.__new__(cls)
-        return cls._instance
-
-    def __init__(self):
-        self.handlers = {}
-
-    def connect(self, event_name, handler):
-        if event_name in self.handlers:
-            self.handlers[event_name].append(handler)
-        else:
-            self.handlers[event_name] = [handler]
-
-    def raiseEvent(self, event_name, *args):
-        if event_name not in self.handlers:
-            return
-        for handler in self.handlers[event_name]:
-            handler(*args)
-

Deleted: haypo/hachoir/branches/hachoir-yield/format.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/format.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/format.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,108 +0,0 @@
-import re, struct
-from cache import Cache
-
-class FormatCache(Cache):
-    # Uniq instance of the class
-    _instance = None
-
-    # Check if a format is an array or not
-    # "string[4]" is an array, "char" isn't
-    regex_array =  re.compile("^([a-z]+[0-9]*)\[([0-9]+)\]$")
-
-    # Convert Hachoir syntax to struct module syntax
-    format_type = {
-        "string": "s",
-        "char": "c",
-        "float": "f",
-        "double": "d",
-        "int8": "b",
-        "uint8": "B",
-        "int16": "h",
-        "uint16": "H",
-        "int32": "l",
-        "uint32": "L"
-    }
-
-    # Singleton design pattern
-    def __new__(cls):
-        if cls._instance == None:
-            cls._instance = object.__new__(cls)
-        return cls._instance
-    
-    def __init__(self):
-        Cache.__init__(self, "FormatCache")
-        self._dict = {}
-
-    def getCacheSize(self):
-        return len(self._dict)
-
-    def purgeCache(self):
-        self._dict = {}
-
-    def convertNewFormat(self, format):
-        old_format = format
-        if format[0] in "!<>":
-            endian = format[0]
-            str_endian = format[0]
-            format = format[1:]
-        else:
-            endian = None
-            str_endian = ""
-        m = FormatCache.regex_array.match(format)
-        if m != None:
-            format = m.group(1)
-            str_count = m.group(2)
-            count = int(str_count)
-        else:
-            str_count = "" 
-            count = 1
-        if format not in FormatCache.format_type:
-            raise Exception("Format \"%s\" is invalid!" % old_format)
-        type = FormatCache.format_type[format]
-        return (str_endian + str_count + type, endian, count, type)
-
-    def __getitem__(self, format):
-        if format not in self._dict:
-            real_format, endian, count, type = self.convertNewFormat(format)
-            size = count * struct.calcsize(type)
-            self._dict[format] = (real_format, endian, count, type, size)
-        return self._dict[format]   
-
-_format_size_cache = {}
-
-def formatIsString(format):
-    cache = FormatCache()[format]
-    return cache[3] == "s"
-
-def formatIsInteger(format):
-    cache = FormatCache()[format]
-    return cache[3] in "bBhHlL"
-
-def getFormatEndian(format):
-    cache = FormatCache()[format]
-    return cache[1]   
-
-def getFormatSize(format):
-    cache = FormatCache()[format]
-    return cache[4]   
-
-def getRealFormat(format):
-    cache = FormatCache()[format]
-    return cache[0]   
-
-def checkFormat(format):
-    # TODO: Don't use try/except, but something better
-    try:
-        cache = FormatCache()
-        conv = cache.convertNewFormat(format)
-        return True
-    except:
-        return False
-
-def splitFormat(format):
-    cache = FormatCache()[format]
-    return cache[1:4]   
-
-def formatIsArray(format):
-    cache = FormatCache()[format]
-    return (1 < cache[2]) and (cache[3] != "s")

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -2,31 +2,78 @@
 
 VERSION = "0.2veryalpha"
 
-from stream.file import FileStream
-from text_ui import displayFieldSet
-from plugin import loadPlugins, guessPlugin
-from log import log
-from error import error
-from mime import getStreamMime
-from metadata import createMetaData
-import sys, os
+import sys, os, getopt
 
+cmd_line_options = ( \
+    ("verbose", "Activate verbose mode"),
+    ("help", "Show this help"),
+    ("version", "Display version"),
+    ("debug", "Enable debug mode (eg. display backtrace)")
+)
+
 def usage():
+#    global command_line_options
     print "Hachoir version %s" % VERSION
+    print "Usage: %s [options] filename" % sys.argv[0]
     print
-    print "Usage: %s filename" % sys.argv[0]
+    width = max([len(option[0]) for option in cmd_line_options])
+    for opt in cmd_line_options:
+        if isinstance(opt[1], tuple):
+            print "   --%s : %s" % (opt[0].ljust(width), opt[1][0])
+            for line in opt[1][1:]:
+                print "   %s%s" % (" " * (width+5), line)
+        else:
+            print "   --%s : %s" % (opt[0].ljust(width), opt[1])
 
+def parseArgs():
+    import libhachoir.config as config
+
+    try:
+        allowed = [ option[0] for option in cmd_line_options ]
+        opts, args = getopt.getopt(sys.argv[1:], "", allowed)
+    except getopt.GetoptError:
+        usage()
+        sys.exit(2)
+   
+    if len(args) != 1:
+        usage()
+        sys.exit(2)
+    filename = args[0]
+        
+    for option, value in opts:
+        if option == "--help":
+            usage()
+            sys.exit(0)
+        elif option == "--version":
+            print "Hachoir version %s" % VERSION
+            sys.exit(0)
+        elif option == "--verbose":
+            config.verbose = True
+        elif option == "--debug":
+            config.debug = True
+    return filename 
+
 def main():
+    libhachoir_path = os.path.join(os.getcwd(), "libhachoir")
+    sys.path.append(libhachoir_path)
+
+    import libhachoir
+
+    from libhachoir.stream.file import FileStream
+    from text_ui import displayFieldSet
+    from libhachoir.plugin import loadPlugins, guessPlugin
+    from libhachoir.log import log
+    from libhachoir.error import error
+    from libhachoir.mime import getStreamMime
+    from metadata import createMetaData
+
     # Create input stream (read filename from command line first argument)
-    if len(sys.argv) < 2:
-        usage()
-        sys.exit(1)
-    filename = sys.argv[1]
+    filename = parseArgs()
     stream = FileStream(open(filename, 'r'), filename)
 
-    # Load all plugings from 'file' directory
-    root_dir = os.path.dirname(__file__)
-    modules = loadPlugins(os.path.join(root_dir, "file"))
+    # Load all parser plugings from 'file' directory
+    root_dir = libhachoir_path
+    modules = loadPlugins(os.path.join(root_dir, "parser"))
     modules.sort()
     log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 

Deleted: haypo/hachoir/branches/hachoir-yield/indexed_dict.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/indexed_dict.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/indexed_dict.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,26 +0,0 @@
-class UniqKeyError(KeyError):
-    pass
-
-class IndexedDict:
-    def __init__(self):
-        self._dict = {}
-        self._list = []
-
-    def __getitem__(self, key):
-        return self._dict[key]
-
-    def append(self, key, value):
-        if key in self._dict:
-            raise UniqKeyError("Key '%s' already exists" % key)
-        self._dict[key] = value
-        self._list.append(value)
-
-    def __len__(self):
-        return len(self._list)
-
-    def __contains__(self, key):
-        return key in self._dict
-
-    def __iter__(self):
-        return iter(self._list)
-

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/bits.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/bits.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/bits.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,112 @@
+def str2hex(value):
+    text = ""
+    for character in value:
+        if text != "":
+            text += " "
+        text += "%02X" % ord(character)
+    return text
+
+def countBits(value):
+    """
+    0 -> 0 bit
+    1 -> 1 bit
+    2 -> 2 bits
+    4 -> 3 bits
+    ...
+    """
+    bits = 0
+    if value < 0:
+        bits += 1
+        value = -value
+    while value >= 1:
+        bits += 1
+        value >>= 1
+    return bits        
+
+def byte2bin(x, reverse=True):
+    text = ""
+    for i in range(0,8):
+        if reverse:
+            mask = 1 << (7-i)
+        else:
+            mask = 1 << i
+        if (x & mask) == mask:
+            text += "1"
+        else:
+            text += "0"
+    return text            
+
+def long2raw(value, big_endian=True):
+    """
+    Convert a number to a raw string in big endian order
+    Eg. 1 => "\x01"
+        0x1234 => "\x12\x34"
+
+    Use big_endian=False to get result in little endian order.
+    Eg. 0x1234 => "\x34\x12"
+    """
+    text = ""
+    while (value != 0 or text == ""):
+        byte = value & 0xFF            
+        text += chr(byte)
+        value >>= 8
+    if big_endian:
+        return text[::-1]
+    else:
+        return text        
+
+def long2bin(value, reverse=True):
+    text = ""
+    while (value != 0 or text == ""):
+        if text != "":
+            text += " "
+        byte = value & 0xFF            
+        text += byte2bin(byte, not reverse)
+        print "val=%s > %s" % (value, value >> 8)
+        value >>= 8
+    return text        
+
+def sized_long2bin(size, value, reverse=True):
+    text = ""
+    for i in range(size):
+        if (value & 1) == 1:
+            text += "1"
+        else:
+            text += "0"
+        value >>= 1
+    if reverse:
+        return text[::-1]
+    else:
+        return text        
+
+def str2bin(value, reverse=False):
+    text = ""
+    for character in value:
+        if text != "":
+            text += " "
+        byte = ord(character)
+        text += byte2bin(byte, not reverse)
+    return text
+
+def reverseBits(x):
+    y = 0
+    for i in range(0,8):
+        mask = (1 << i)
+        if (x & mask) == mask:
+            y |= (1 << (7-i))
+    return y
+
+def str2long(data, reverse_byte=False):
+    """
+    Convert a string into a number with big endian order.
+    Eg. "\0\1\2" => 0x001020
+    """
+    shift = 0
+    value = 0
+    for character in data:
+        byte = ord(character)
+        if reverse_byte:
+            byte = reverseBits(byte)
+        value += (byte << shift) 
+        shift += 8
+    return value        

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/cache.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/cache.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/cache.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,53 @@
+import gc
+
+class CacheList:
+    _instance = None
+
+    def __init__(self):
+        assert CacheList._instance == None
+        self._list = []
+
+    def purgeCaches(self):
+        size = self.getSize()
+        for value in self._list:
+            item, name = value
+            item.purgeCache()
+        gc.collect()            
+        print "Purge caches: clear %s item(s)" % size
+
+    def output(self):
+        size = 0
+        nb_obj = 0
+        print "--- Caches"
+        for value in self._list:
+            item, name = value
+            size = item.getCacheSize()
+            nb_obj += size
+            if size != 0:
+                print "o %s: %s item(s)" % (name, size)
+        print "--- Total = %s item(s)" % (nb_obj)
+
+    def getSize(self):
+        size = 0
+        for value in self._list:
+            size += value[0].getCacheSize()
+        return size           
+
+    def register(self, item, name):
+        self._list.append( (item,name) )
+
+    def getInstance():
+        if CacheList._instance == None:
+            CacheList._instance = CacheList()
+        return CacheList._instance
+    getInstance = staticmethod(getInstance)
+
+class Cache:
+    def __init__(self, name):
+        CacheList.getInstance().register(self, name)
+
+    def getCacheSize(self):
+        raise NotImplementedError()
+
+    def purgeCache(self):
+        raise NotImplementedError()

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/config.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/config.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/config.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,12 @@
+# UI: display options
+max_string_length = 10    # Max. length of displayed string
+max_hexa_length = 4096    # Max. length of raw data displayed in hex
+max_ascii_length = 4096   # Max. length of raw data displayed in ASCII
+
+# Global options
+debug = False 
+verbose = False
+
+# Size of file cache (for each opened file)
+file_cache_block_size = 4096  # 4 KB
+file_cache_block_count = 10   # Buffer = 10 * 4 KB

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/error.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/error.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/error.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,16 @@
+import os
+import config
+from log import log
+#import ui.ui
+from tools import getBacktrace
+
+def warning(message):
+    if config.verbose or config.debug:
+        message += "\n\n" + getBacktrace()
+    log.warning(message)   
+
+def error(message, backtrace=None):
+    if config.verbose or config.debug:
+        message += "\n\n" + getBacktrace()
+    log.error(message)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/event_handler.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/event_handler.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/event_handler.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,24 @@
+class EventHandler(object):
+    _instance = None
+
+    # Singleton design pattern
+    def __new__(cls):
+        if cls._instance == None:
+            cls._instance = object.__new__(cls)
+        return cls._instance
+
+    def __init__(self):
+        self.handlers = {}
+
+    def connect(self, event_name, handler):
+        if event_name in self.handlers:
+            self.handlers[event_name].append(handler)
+        else:
+            self.handlers[event_name] = [handler]
+
+    def raiseEvent(self, event_name, *args):
+        if event_name not in self.handlers:
+            return
+        for handler in self.handlers[event_name]:
+            handler(*args)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/magic.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/magic.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/magic.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,1119 @@
+#!/usr/bin/env python 
+'''
+magic.py
+ determines a file type by its magic number
+
+ (C)opyright 2000 Jason Petrone <jp_py at demonseed.net>
+ All Rights Reserved
+
+ Command Line Usage: running as `python magic.py file` will print
+                     a description of what 'file' is.
+
+ Module Usage:
+     magic.whatis(data): when passed a string 'data' containing 
+                         binary or text data, a description of
+                         what the data is will be returned.
+
+     magic.file(filename): returns a description of what the file
+                           'filename' contains.
+'''
+
+import re, struct, string
+
+__version__ = '0.1'
+
+magic = [
+  [0L, 'leshort', '=', 1538L, 'application/x-alan-adventure-game'],
+  [0L, 'string', '=', 'TADS', 'application/x-tads-game'],
+  [0L, 'short', '=', 420L, 'application/x-executable-file'],
+  [0L, 'short', '=', 421L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 603L, 'application/x-executable-file'],
+  [0L, 'string', '=', 'Core\001', 'application/x-executable-file'],
+  [0L, 'string', '=', 'AMANDA: TAPESTART DATE', 'application/x-amanda-header'],
+  [0L, 'belong', '=', 1011L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 999L, 'application/x-library-file'],
+  [0L, 'belong', '=', 435L, 'video/mpeg'],
+  [0L, 'belong', '=', 442L, 'video/mpeg'],
+  [0L, 'beshort&0xfff0', '=', 65520L, 'audio/mpeg'],
+  [4L, 'leshort', '=', 44817L, 'video/fli'],
+  [4L, 'leshort', '=', 44818L, 'video/flc'],
+  [0L, 'string', '=', 'MOVI', 'video/x-sgi-movie'],
+  [4L, 'string', '=', 'moov', 'video/quicktime'],
+  [4L, 'string', '=', 'mdat', 'video/quicktime'],
+  [0L, 'long', '=', 100554L, 'application/x-apl-workspace'],
+  [0L, 'string', '=', 'FiLeStArTfIlEsTaRt', 'text/x-apple-binscii'],
+  [0L, 'string', '=', '\012GL', 'application/data'],
+  [0L, 'string', '=', 'v\377', 'application/data'],
+  [0L, 'string', '=', 'NuFile', 'application/data'],
+  [0L, 'string', '=', 'N\365F\351l\345', 'application/data'],
+  [0L, 'belong', '=', 333312L, 'application/data'],
+  [0L, 'belong', '=', 333319L, 'application/data'],
+  [257L, 'string', '=', 'ustar\000', 'application/x-tar'],
+  [257L, 'string', '=', 'ustar  \000', 'application/x-gtar'],
+  [0L, 'short', '=', 70707L, 'application/x-cpio'],
+  [0L, 'short', '=', 143561L, 'application/x-bcpio'],
+  [0L, 'string', '=', '070707', 'application/x-cpio'],
+  [0L, 'string', '=', '070701', 'application/x-cpio'],
+  [0L, 'string', '=', '070702', 'application/x-cpio'],
+  [0L, 'string', '=', '!<arch>\012debian', 'application/x-dpkg'],
+  [0L, 'long', '=', 177555L, 'application/x-ar'],
+  [0L, 'short', '=', 177555L, 'application/data'],
+  [0L, 'long', '=', 177545L, 'application/data'],
+  [0L, 'short', '=', 177545L, 'application/data'],
+  [0L, 'long', '=', 100554L, 'application/x-apl-workspace'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'string', '=', '!<arch>\012__________E', 'application/x-ar'],
+  [0L, 'string', '=', '-h-', 'application/data'],
+  [0L, 'string', '=', '!<arch>', 'application/x-ar'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'belong', '=', 1711210496L, 'application/x-ar'],
+  [0L, 'belong', '=', 1013019198L, 'application/x-ar'],
+  [0L, 'long', '=', 557605234L, 'application/x-ar'],
+  [0L, 'lelong', '=', 177555L, 'application/data'],
+  [0L, 'leshort', '=', 177555L, 'application/data'],
+  [0L, 'lelong', '=', 177545L, 'application/data'],
+  [0L, 'leshort', '=', 177545L, 'application/data'],
+  [0L, 'lelong', '=', 236525L, 'application/data'],
+  [0L, 'lelong', '=', 236526L, 'application/data'],
+  [0L, 'lelong&0x8080ffff', '=', 2074L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 2330L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 538L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 794L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 1050L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 1562L, 'application/x-arc'],
+  [0L, 'string', '=', '\032archive', 'application/data'],
+  [0L, 'leshort', '=', 60000L, 'application/x-arj'],
+  [0L, 'string', '=', 'HPAK', 'application/data'],
+  [0L, 'string', '=', '\351,\001JAM application/data', ''],
+  [2L, 'string', '=', '-lh0-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh1-', 'application/x-lha'],
+  [2L, 'string', '=', '-lz4-', 'application/x-lha'],
+  [2L, 'string', '=', '-lz5-', 'application/x-lha'],
+  [2L, 'string', '=', '-lzs-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh -', 'application/x-lha'],
+  [2L, 'string', '=', '-lhd-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh2-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh3-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh4-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh5-', 'application/x-lha'],
+  [0L, 'string', '=', 'Rar!', 'application/x-rar'],
+  [0L, 'string', '=', 'SQSH', 'application/data'],
+  [0L, 'string', '=', 'UC2\032', 'application/data'],
+  [0L, 'string', '=', 'PK\003\004', 'application/zip'],
+  [20L, 'lelong', '=', 4257523676L, 'application/x-zoo'],
+  [10L, 'string', '=', '# This is a shell archive', 'application/x-shar'],
+  [0L, 'string', '=', '*STA', 'application/data'],
+  [0L, 'string', '=', '2278', 'application/data'],
+  [0L, 'beshort', '=', 560L, 'application/x-executable-file'],
+  [0L, 'beshort', '=', 561L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\000\004\036\212\200', 'application/core'],
+  [0L, 'string', '=', '.snd', 'audio/basic'],
+  [0L, 'lelong', '=', 6583086L, 'audio/basic'],
+  [0L, 'string', '=', 'MThd', 'audio/midi'],
+  [0L, 'string', '=', 'CTMF', 'audio/x-cmf'],
+  [0L, 'string', '=', 'SBI', 'audio/x-sbi'],
+  [0L, 'string', '=', 'Creative Voice File', 'audio/x-voc'],
+  [0L, 'belong', '=', 1314148939L, 'audio/x-multitrack'],
+  [8L, 'string', '=', 'AVI ', 'video/x-msvideo'],
+  [0L, 'string', '=', 'RIFF', 'audio/x-wav'],
+  [0L, 'string', '=', 'EMOD', 'audio/x-emod'],
+  [0L, 'belong', '=', 779248125L, 'audio/x-pn-realaudio'],
+  [0L, 'string', '=', 'MTM', 'audio/x-multitrack'],
+  [0L, 'string', '=', 'if', 'audio/x-669-mod'],
+  [0L, 'string', '=', 'FAR', 'audio/mod'],
+  [0L, 'string', '=', 'MAS_U', 'audio/x-multimate-mod'],
+  [44L, 'string', '=', 'SCRM', 'audio/x-st3-mod'],
+  [0L, 'string', '=', 'GF1PATCH110\000ID#000002\000', 'audio/x-gus-patch'],
+  [0L, 'string', '=', 'GF1PATCH100\000ID#000002\000', 'audio/x-gus-patch'],
+  [0L, 'string', '=', 'JN', 'audio/x-669-mod'],
+  [0L, 'string', '=', 'UN05', 'audio/x-mikmod-uni'],
+  [0L, 'string', '=', 'Extended Module:', 'audio/x-ft2-mod'],
+  [21L, 'string', '=', '!SCREAM!', 'audio/x-st2-mod'],
+  [1080L, 'string', '=', 'M.K.', 'audio/x-protracker-mod'],
+  [1080L, 'string', '=', 'M!K!', 'audio/x-protracker-mod'],
+  [1080L, 'string', '=', 'FLT4', 'audio/x-startracker-mod'],
+  [1080L, 'string', '=', '4CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', '6CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', '8CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', 'CD81', 'audio/x-oktalyzer-mod'],
+  [1080L, 'string', '=', 'OKTA', 'audio/x-oktalyzer-mod'],
+  [1080L, 'string', '=', '16CN', 'audio/x-taketracker-mod'],
+  [1080L, 'string', '=', '32CN', 'audio/x-taketracker-mod'],
+  [0L, 'string', '=', 'TOC', 'audio/x-toc'],
+  [0L, 'short', '=', 3401L, 'application/x-executable-file'],
+  [0L, 'long', '=', 406L, 'application/x-executable-file'],
+  [0L, 'short', '=', 406L, 'application/x-executable-file'],
+  [0L, 'short', '=', 3001L, 'application/x-executable-file'],
+  [0L, 'lelong', '=', 314L, 'application/x-executable-file'],
+  [0L, 'string', '=', '//', 'text/cpp'],
+  [0L, 'string', '=', '\\\\1cw\\', 'application/data'],
+  [0L, 'string', '=', '\\\\1cw', 'application/data'],
+  [0L, 'belong&0xffffff00', '=', 2231440384L, 'application/data'],
+  [0L, 'belong&0xffffff00', '=', 2231487232L, 'application/data'],
+  [0L, 'short', '=', 575L, 'application/x-executable-file'],
+  [0L, 'short', '=', 577L, 'application/x-executable-file'],
+  [4L, 'string', '=', 'pipe', 'application/data'],
+  [4L, 'string', '=', 'prof', 'application/data'],
+  [0L, 'string', '=', ': shell', 'application/data'],
+  [0L, 'string', '=', '#!/bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#!/bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#! /bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#! /bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#!/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#!/usr/local/bin/ash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/ash', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/ash', 'application/x-zsh'],
+  [0L, 'string', '=', '#!/usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#! /usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#! /usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#!/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', 'BEGIN', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/bin/env python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/env python', 'application/x-python'],
+  [0L, 'string', '=', '#!/bin/rc', 'text/script'],
+  [0L, 'string', '=', '#! /bin/rc', 'text/script'],
+  [0L, 'string', '=', '#! /bin/rc', 'text/script'],
+  [0L, 'string', '=', '#!/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#!/usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /', 'text/script'],
+  [0L, 'string', '=', '#! /', 'text/script'],
+  [0L, 'string', '=', '#!/', 'text/script'],
+  [0L, 'string', '=', '#! text/script', ''],
+  [0L, 'string', '=', '\037\235', 'application/compress'],
+  [0L, 'string', '=', '\037\213', 'application/x-gzip'],
+  [0L, 'string', '=', '\037\036', 'application/data'],
+  [0L, 'short', '=', 17437L, 'application/data'],
+  [0L, 'short', '=', 8191L, 'application/data'],
+  [0L, 'string', '=', '\377\037', 'application/data'],
+  [0L, 'short', '=', 145405L, 'application/data'],
+  [0L, 'string', '=', 'BZh', 'application/x-bzip2'],
+  [0L, 'leshort', '=', 65398L, 'application/data'],
+  [0L, 'leshort', '=', 65142L, 'application/data'],
+  [0L, 'leshort', '=', 64886L, 'application/x-lzh'],
+  [0L, 'string', '=', '\037\237', 'application/data'],
+  [0L, 'string', '=', '\037\236', 'application/data'],
+  [0L, 'string', '=', '\037\240', 'application/data'],
+  [0L, 'string', '=', 'BZ', 'application/x-bzip'],
+  [0L, 'string', '=', '\211LZO\000\015\012\032\012', 'application/data'],
+  [0L, 'belong', '=', 507L, 'application/x-object-file'],
+  [0L, 'belong', '=', 513L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 515L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 517L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 70231L, 'application/core'],
+  [24L, 'belong', '=', 60011L, 'application/data'],
+  [24L, 'belong', '=', 60012L, 'application/data'],
+  [24L, 'belong', '=', 60013L, 'application/data'],
+  [24L, 'belong', '=', 60014L, 'application/data'],
+  [0L, 'belong', '=', 601L, 'application/x-object-file'],
+  [0L, 'belong', '=', 607L, 'application/data'],
+  [0L, 'belong', '=', 324508366L, 'application/x-gdbm'],
+  [0L, 'lelong', '=', 324508366L, 'application/x-gdbm'],
+  [0L, 'string', '=', 'GDBM', 'application/x-gdbm'],
+  [0L, 'belong', '=', 398689L, 'application/x-db'],
+  [0L, 'belong', '=', 340322L, 'application/x-db'],
+  [0L, 'string', '=', '<list>\012<protocol bbn-m', 'application/data'],
+  [0L, 'string', '=', 'diff text/x-patch', ''],
+  [0L, 'string', '=', '*** text/x-patch', ''],
+  [0L, 'string', '=', 'Only in text/x-patch', ''],
+  [0L, 'string', '=', 'Common subdirectories: text/x-patch', ''],
+  [0L, 'string', '=', '!<arch>\012________64E', 'application/data'],
+  [0L, 'leshort', '=', 387L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 392L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 399L, 'application/x-object-file'],
+  [0L, 'string', '=', '\377\377\177', 'application/data'],
+  [0L, 'string', '=', '\377\377|', 'application/data'],
+  [0L, 'string', '=', '\377\377~', 'application/data'],
+  [0L, 'string', '=', '\033c\033', 'application/data'],
+  [0L, 'long', '=', 4553207L, 'image/x11'],
+  [0L, 'string', '=', '!<PDF>!\012', 'application/x-prof'],
+  [0L, 'short', '=', 1281L, 'application/x-locale'],
+  [24L, 'belong', '=', 60012L, 'application/x-dump'],
+  [24L, 'belong', '=', 60011L, 'application/x-dump'],
+  [24L, 'lelong', '=', 60012L, 'application/x-dump'],
+  [24L, 'lelong', '=', 60011L, 'application/x-dump'],
+  [0L, 'string', '=', '\177ELF', 'application/x-executable-file'],
+  [0L, 'short', '=', 340L, 'application/data'],
+  [0L, 'short', '=', 341L, 'application/x-executable-file'],
+  [1080L, 'leshort', '=', 61267L, 'application/x-linux-ext2fs'],
+  [0L, 'string', '=', '\366\366\366\366', 'application/x-pc-floppy'],
+  [774L, 'beshort', '=', 55998L, 'application/data'],
+  [510L, 'leshort', '=', 43605L, 'application/data'],
+  [1040L, 'leshort', '=', 4991L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 5007L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 9320L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 9336L, 'application/x-filesystem'],
+  [0L, 'string', '=', '-rom1fs-\000', 'application/x-filesystem'],
+  [395L, 'string', '=', 'OS/2', 'application/x-bootable'],
+  [0L, 'string', '=', 'FONT', 'font/x-vfont'],
+  [0L, 'short', '=', 436L, 'font/x-vfont'],
+  [0L, 'short', '=', 17001L, 'font/x-vfont'],
+  [0L, 'string', '=', '%!PS-AdobeFont-1.0', 'font/type1'],
+  [6L, 'string', '=', '%!PS-AdobeFont-1.0', 'font/type1'],
+  [0L, 'belong', '=', 4L, 'font/x-snf'],
+  [0L, 'lelong', '=', 4L, 'font/x-snf'],
+  [0L, 'string', '=', 'STARTFONT font/x-bdf', ''],
+  [0L, 'string', '=', '\001fcp', 'font/x-pcf'],
+  [0L, 'string', '=', 'D1.0\015', 'font/x-speedo'],
+  [0L, 'string', '=', 'flf', 'font/x-figlet'],
+  [0L, 'string', '=', 'flc', 'application/x-font'],
+  [0L, 'belong', '=', 335698201L, 'font/x-libgrx'],
+  [0L, 'belong', '=', 4282797902L, 'font/x-dos'],
+  [7L, 'belong', '=', 4540225L, 'font/x-dos'],
+  [7L, 'belong', '=', 5654852L, 'font/x-dos'],
+  [4098L, 'string', '=', 'DOSFONT', 'font/x-dos'],
+  [0L, 'string', '=', '<MakerFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MIFFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MakerDictionary', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MakerScreenFont', 'font/x-framemaker'],
+  [0L, 'string', '=', '<MML', 'application/x-framemaker'],
+  [0L, 'string', '=', '<BookFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<Maker', 'application/x-framemaker'],
+  [0L, 'lelong&0377777777', '=', 41400407L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400410L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400413L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400314L, 'application/x-executable-file'],
+  [7L, 'string', '=', '\357\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000', 'application/core'],
+  [0L, 'lelong', '=', 11421044151L, 'application/data'],
+  [0L, 'string', '=', 'GIMP Gradient', 'application/x-gimp-gradient'],
+  [0L, 'string', '=', 'gimp xcf', 'application/x-gimp-image'],
+  [20L, 'string', '=', 'GPAT', 'application/x-gimp-pattern'],
+  [20L, 'string', '=', 'GIMP', 'application/x-gimp-brush'],
+  [0L, 'string', '=', '\336\022\004\225', 'application/x-locale'],
+  [0L, 'string', '=', '\225\004\022\336', 'application/x-locale'],
+  [0L, 'beshort', '=', 627L, 'application/x-executable-file'],
+  [0L, 'beshort', '=', 624L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\000\001\000\000\000', 'font/ttf'],
+  [0L, 'long', '=', 1203604016L, 'application/data'],
+  [0L, 'long', '=', 1702407010L, 'application/data'],
+  [0L, 'long', '=', 1003405017L, 'application/data'],
+  [0L, 'long', '=', 1602007412L, 'application/data'],
+  [0L, 'belong', '=', 34603270L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34603271L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603272L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603275L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603278L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34603277L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34865414L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34865415L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865416L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865419L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865422L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34865421L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34275590L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34275591L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275592L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275595L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275598L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34275597L, 'application/x-library-file'],
+  [0L, 'belong', '=', 557605234L, 'application/x-ar'],
+  [0L, 'long', '=', 34078982L, 'application/x-executable-file'],
+  [0L, 'long', '=', 34078983L, 'application/x-executable-file'],
+  [0L, 'long', '=', 34078984L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341128L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341127L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341131L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341126L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34210056L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34210055L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341134L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34341133L, 'application/x-library-file'],
+  [0L, 'long', '=', 65381L, 'application/x-library-file'],
+  [0L, 'long', '=', 34275173L, 'application/x-library-file'],
+  [0L, 'long', '=', 34406245L, 'application/x-library-file'],
+  [0L, 'long', '=', 34144101L, 'application/x-library-file'],
+  [0L, 'long', '=', 22552998L, 'application/core'],
+  [0L, 'long', '=', 1302851304L, 'font/x-hp-windows'],
+  [0L, 'string', '=', 'Bitmapfile', 'image/unknown'],
+  [0L, 'string', '=', 'IMGfile', 'CIS image/unknown'],
+  [0L, 'long', '=', 34341132L, 'application/x-lisp'],
+  [0L, 'string', '=', 'msgcat01', 'application/x-locale'],
+  [0L, 'string', '=', 'HPHP48-', 'HP48 binary'],
+  [0L, 'string', '=', '%%HP:', 'HP48 text'],
+  [0L, 'beshort', '=', 200L, 'hp200 (68010) BSD'],
+  [0L, 'beshort', '=', 300L, 'hp300 (68020+68881) BSD'],
+  [0L, 'beshort', '=', 537L, '370 XA sysV executable'],
+  [0L, 'beshort', '=', 532L, '370 XA sysV pure executable'],
+  [0L, 'beshort', '=', 54001L, '370 sysV pure executable'],
+  [0L, 'beshort', '=', 55001L, '370 XA sysV pure executable'],
+  [0L, 'beshort', '=', 56401L, '370 sysV executable'],
+  [0L, 'beshort', '=', 57401L, '370 XA sysV executable'],
+  [0L, 'beshort', '=', 531L, 'SVR2 executable (Amdahl-UTS)'],
+  [0L, 'beshort', '=', 534L, 'SVR2 pure executable (Amdahl-UTS)'],
+  [0L, 'beshort', '=', 530L, 'SVR2 pure executable (USS/370)'],
+  [0L, 'beshort', '=', 535L, 'SVR2 executable (USS/370)'],
+  [0L, 'beshort', '=', 479L, 'executable (RISC System/6000 V3.1) or obj module'],
+  [0L, 'beshort', '=', 260L, 'shared library'],
+  [0L, 'beshort', '=', 261L, 'ctab data'],
+  [0L, 'beshort', '=', 65028L, 'structured file'],
+  [0L, 'string', '=', '0xabcdef', 'AIX message catalog'],
+  [0L, 'belong', '=', 505L, 'AIX compiled message catalog'],
+  [0L, 'string', '=', '<aiaff>', 'archive'],
+  [0L, 'string', '=', 'FORM', 'IFF data'],
+  [0L, 'string', '=', 'P1', 'image/x-portable-bitmap'],
+  [0L, 'string', '=', 'P2', 'image/x-portable-graymap'],
+  [0L, 'string', '=', 'P3', 'image/x-portable-pixmap'],
+  [0L, 'string', '=', 'P4', 'image/x-portable-bitmap'],
+  [0L, 'string', '=', 'P5', 'image/x-portable-graymap'],
+  [0L, 'string', '=', 'P6', 'image/x-portable-pixmap'],
+  [0L, 'string', '=', 'IIN1', 'image/tiff'],
+  [0L, 'string', '=', 'MM\000*', 'image/tiff'],
+  [0L, 'string', '=', 'II*\000', 'image/tiff'],
+  [0L, 'string', '=', '\211PNG', 'image/x-png'],
+  [1L, 'string', '=', 'PNG', 'image/x-png'],
+  [0L, 'string', '=', 'GIF8', 'image/gif'],
+  [0L, 'string', '=', '\361\000@\273', 'image/x-cmu-raster'],
+  [0L, 'string', '=', 'id=ImageMagick', 'MIFF image data'],
+  [0L, 'long', '=', 1123028772L, 'Artisan image data'],
+  [0L, 'string', '=', '#FIG', 'FIG image text'],
+  [0L, 'string', '=', 'ARF_BEGARF', 'PHIGS clear text archive'],
+  [0L, 'string', '=', '@(#)SunPHIGS', 'SunPHIGS'],
+  [0L, 'string', '=', 'GKSM', 'GKS Metafile'],
+  [0L, 'string', '=', 'BEGMF', 'clear text Computer Graphics Metafile'],
+  [0L, 'beshort&0xffe0', '=', 32L, 'binary Computer Graphics Metafile'],
+  [0L, 'beshort', '=', 12320L, 'character Computer Graphics Metafile'],
+  [0L, 'string', '=', 'yz', 'MGR bitmap, modern format, 8-bit aligned'],
+  [0L, 'string', '=', 'zz', 'MGR bitmap, old format, 1-bit deep, 16-bit aligned'],
+  [0L, 'string', '=', 'xz', 'MGR bitmap, old format, 1-bit deep, 32-bit aligned'],
+  [0L, 'string', '=', 'yx', 'MGR bitmap, modern format, squeezed'],
+  [0L, 'string', '=', '%bitmap\000', 'FBM image data'],
+  [1L, 'string', '=', 'PC Research, Inc', 'group 3 fax data'],
+  [0L, 'beshort', '=', 65496L, 'image/jpeg'],
+  [0L, 'string', '=', 'hsi1', 'image/x-jpeg-proprietary'],
+  [0L, 'string', '=', 'BM', 'image/x-bmp'],
+  [0L, 'string', '=', 'IC', 'image/x-ico'],
+  [0L, 'string', '=', 'PI', 'PC pointer image data'],
+  [0L, 'string', '=', 'CI', 'PC color icon data'],
+  [0L, 'string', '=', 'CP', 'PC color pointer image data'],
+  [0L, 'string', '=', '/* XPM */', 'X pixmap image text'],
+  [0L, 'leshort', '=', 52306L, 'RLE image data,'],
+  [0L, 'string', '=', 'Imagefile version-', 'iff image data'],
+  [0L, 'belong', '=', 1504078485L, 'x/x-image-sun-raster'],
+  [0L, 'beshort', '=', 474L, 'x/x-image-sgi'],
+  [0L, 'string', '=', 'IT01', 'FIT image data'],
+  [0L, 'string', '=', 'IT02', 'FIT image data'],
+  [2048L, 'string', '=', 'PCD_IPI', 'x/x-photo-cd-pack-file'],
+  [0L, 'string', '=', 'PCD_OPA', 'x/x-photo-cd-overfiew-file'],
+  [0L, 'string', '=', 'SIMPLE  =', 'FITS image data'],
+  [0L, 'string', '=', 'This is a BitMap file', 'Lisp Machine bit-array-file'],
+  [0L, 'string', '=', '!!', 'Bennet Yee\'s "face" format'],
+  [0L, 'beshort', '=', 4112L, 'PEX Binary Archive'],
+  [3000L, 'string', '=', 'Visio (TM) Drawing', '%s'],
+  [0L, 'leshort', '=', 502L, 'basic-16 executable'],
+  [0L, 'leshort', '=', 503L, 'basic-16 executable (TV)'],
+  [0L, 'leshort', '=', 510L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 511L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 512L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 522L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 514L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\210OPS', 'Interleaf saved data'],
+  [0L, 'string', '=', '<!OPS', 'Interleaf document text'],
+  [4L, 'string', '=', 'pgscriptver', 'IslandWrite document'],
+  [13L, 'string', '=', 'DrawFile', 'IslandDraw document'],
+  [0L, 'leshort&0xFFFC', '=', 38400L, 'little endian ispell'],
+  [0L, 'beshort&0xFFFC', '=', 38400L, 'big endian ispell'],
+  [0L, 'belong', '=', 3405691582L, 'compiled Java class data,'],
+  [0L, 'beshort', '=', 44269L, 'Java serialization data'],
+  [0L, 'string', '=', 'KarmaRHD', 'Version Karma Data Structure Version'],
+  [0L, 'string', '=', 'lect', 'DEC SRC Virtual Paper Lectern file'],
+  [53L, 'string', '=', 'yyprevious', 'C program text (from lex)'],
+  [21L, 'string', '=', 'generated by flex', 'C program text (from flex)'],
+  [0L, 'string', '=', '%{', 'lex description text'],
+  [0L, 'short', '=', 32768L, 'lif file'],
+  [0L, 'lelong', '=', 6553863L, 'Linux/i386 impure executable (OMAGIC)'],
+  [0L, 'lelong', '=', 6553864L, 'Linux/i386 pure executable (NMAGIC)'],
+  [0L, 'lelong', '=', 6553867L, 'Linux/i386 demand-paged executable (ZMAGIC)'],
+  [0L, 'lelong', '=', 6553804L, 'Linux/i386 demand-paged executable (QMAGIC)'],
+  [0L, 'string', '=', '\007\001\000', 'Linux/i386 object file'],
+  [0L, 'string', '=', '\001\003\020\004', 'Linux-8086 impure executable'],
+  [0L, 'string', '=', '\001\003 \004', 'Linux-8086 executable'],
+  [0L, 'string', '=', '\243\206\001\000', 'Linux-8086 object file'],
+  [0L, 'string', '=', '\001\003\020\020', 'Minix-386 impure executable'],
+  [0L, 'string', '=', '\001\003 \020', 'Minix-386 executable'],
+  [0L, 'string', '=', '*nazgul*', 'Linux compiled message catalog'],
+  [216L, 'lelong', '=', 421L, 'Linux/i386 core file'],
+  [2L, 'string', '=', 'LILO', 'Linux/i386 LILO boot/chain loader'],
+  [0L, 'string', '=', '0.9', ''],
+  [0L, 'leshort', '=', 1078L, 'font/linux-psf'],
+  [4086L, 'string', '=', 'SWAP-SPACE', 'Linux/i386 swap file'],
+  [0L, 'leshort', '=', 387L, 'ECOFF alpha'],
+  [514L, 'string', '=', 'HdrS', 'Linux kernel'],
+  [0L, 'belong', '=', 3099592590L, 'Linux kernel'],
+  [0L, 'string', '=', 'Begin3', 'Linux Software Map entry text'],
+  [0L, 'string', '=', ';;', 'Lisp/Scheme program text'],
+  [0L, 'string', '=', '\012(', 'byte-compiled Emacs-Lisp program data'],
+  [0L, 'string', '=', ';ELC\023\000\000\000', 'byte-compiled Emacs-Lisp program data'],
+  [0L, 'string', '=', "(SYSTEM::VERSION '", 'CLISP byte-compiled Lisp program text'],
+  [0L, 'long', '=', 1886817234L, 'CLISP memory image data'],
+  [0L, 'long', '=', 3532355184L, 'CLISP memory image data, other endian'],
+  [0L, 'long', '=', 3725722773L, 'GNU-format message catalog data'],
+  [0L, 'long', '=', 2500072158L, 'GNU-format message catalog data'],
+  [0L, 'belong', '=', 3405691582L, 'mach-o fat file'],
+  [0L, 'belong', '=', 4277009102L, 'mach-o'],
+  [11L, 'string', '=', 'must be converted with BinHex', 'BinHex binary text'],
+  [0L, 'string', '=', 'SIT!', 'StuffIt Archive (data)'],
+  [65L, 'string', '=', 'SIT!', 'StuffIt Archive (rsrc + data)'],
+  [0L, 'string', '=', 'SITD', 'StuffIt Deluxe (data)'],
+  [65L, 'string', '=', 'SITD', 'StuffIt Deluxe (rsrc + data)'],
+  [0L, 'string', '=', 'Seg', 'StuffIt Deluxe Segment (data)'],
+  [65L, 'string', '=', 'Seg', 'StuffIt Deluxe Segment (rsrc + data)'],
+  [0L, 'string', '=', 'APPL', 'Macintosh Application (data)'],
+  [65L, 'string', '=', 'APPL', 'Macintosh Application (rsrc + data)'],
+  [0L, 'string', '=', 'zsys', 'Macintosh System File (data)'],
+  [65L, 'string', '=', 'zsys', 'Macintosh System File(rsrc + data)'],
+  [0L, 'string', '=', 'FNDR', 'Macintosh Finder (data)'],
+  [65L, 'string', '=', 'FNDR', 'Macintosh Finder(rsrc + data)'],
+  [0L, 'string', '=', 'libr', 'Macintosh Library (data)'],
+  [65L, 'string', '=', 'libr', 'Macintosh Library(rsrc + data)'],
+  [0L, 'string', '=', 'shlb', 'Macintosh Shared Library (data)'],
+  [65L, 'string', '=', 'shlb', 'Macintosh Shared Library(rsrc + data)'],
+  [0L, 'string', '=', 'cdev', 'Macintosh Control Panel (data)'],
+  [65L, 'string', '=', 'cdev', 'Macintosh Control Panel(rsrc + data)'],
+  [0L, 'string', '=', 'INIT', 'Macintosh Extension (data)'],
+  [65L, 'string', '=', 'INIT', 'Macintosh Extension(rsrc + data)'],
+  [0L, 'string', '=', 'FFIL', 'font/ttf'],
+  [65L, 'string', '=', 'FFIL', 'font/ttf'],
+  [0L, 'string', '=', 'LWFN', 'font/type1'],
+  [65L, 'string', '=', 'LWFN', 'font/type1'],
+  [0L, 'string', '=', 'PACT', 'Macintosh Compact Pro Archive (data)'],
+  [65L, 'string', '=', 'PACT', 'Macintosh Compact Pro Archive(rsrc + data)'],
+  [0L, 'string', '=', 'ttro', 'Macintosh TeachText File (data)'],
+  [65L, 'string', '=', 'ttro', 'Macintosh TeachText File(rsrc + data)'],
+  [0L, 'string', '=', 'TEXT', 'Macintosh TeachText File (data)'],
+  [65L, 'string', '=', 'TEXT', 'Macintosh TeachText File(rsrc + data)'],
+  [0L, 'string', '=', 'PDF', 'Macintosh PDF File (data)'],
+  [65L, 'string', '=', 'PDF', 'Macintosh PDF File(rsrc + data)'],
+  [0L, 'string', '=', '# Magic', 'magic text file for file(1) cmd'],
+  [0L, 'string', '=', 'Relay-Version:', 'old news text'],
+  [0L, 'string', '=', '#! rnews', 'batched news text'],
+  [0L, 'string', '=', 'N#! rnews', 'mailed, batched news text'],
+  [0L, 'string', '=', 'Forward to', 'mail forwarding text'],
+  [0L, 'string', '=', 'Pipe to', 'mail piping text'],
+  [0L, 'string', '=', 'Return-Path:', 'message/rfc822'],
+  [0L, 'string', '=', 'Path:', 'message/news'],
+  [0L, 'string', '=', 'Xref:', 'message/news'],
+  [0L, 'string', '=', 'From:', 'message/rfc822'],
+  [0L, 'string', '=', 'Article', 'message/news'],
+  [0L, 'string', '=', 'BABYL', 'message/x-gnu-rmail'],
+  [0L, 'string', '=', 'Received:', 'message/rfc822'],
+  [0L, 'string', '=', 'MIME-Version:', 'MIME entity text'],
+  [0L, 'string', '=', 'Content-Type: ', ''],
+  [0L, 'string', '=', 'Content-Type:', ''],
+  [0L, 'long', '=', 31415L, 'Mirage Assembler m.out executable'],
+  [0L, 'string', '=', '\311\304', 'ID tags data'],
+  [0L, 'string', '=', '\001\001\001\001', 'MMDF mailbox'],
+  [4L, 'string', '=', 'Research,', 'Digifax-G3-File'],
+  [0L, 'short', '=', 256L, 'raw G3 data, byte-padded'],
+  [0L, 'short', '=', 5120L, 'raw G3 data'],
+  [0L, 'string', '=', 'RMD1', 'raw modem data'],
+  [0L, 'string', '=', 'PVF1\012', 'portable voice format'],
+  [0L, 'string', '=', 'PVF2\012', 'portable voice format'],
+  [0L, 'beshort', '=', 520L, 'mc68k COFF'],
+  [0L, 'beshort', '=', 521L, 'mc68k executable (shared)'],
+  [0L, 'beshort', '=', 522L, 'mc68k executable (shared demand paged)'],
+  [0L, 'beshort', '=', 554L, '68K BCS executable'],
+  [0L, 'beshort', '=', 555L, '88K BCS executable'],
+  [0L, 'string', '=', 'S0', 'Motorola S-Record; binary data in text format'],
+  [0L, 'string', '=', '@echo off', 'MS-DOS batch file text'],
+  [128L, 'string', '=', 'PE\000\000', 'MS Windows PE'],
+  [0L, 'leshort', '=', 332L, 'MS Windows COFF Intel 80386 object file'],
+  [0L, 'leshort', '=', 358L, 'MS Windows COFF MIPS R4000 object file'],
+  [0L, 'leshort', '=', 388L, 'MS Windows COFF Alpha object file'],
+  [0L, 'leshort', '=', 616L, 'MS Windows COFF Motorola 68000 object file'],
+  [0L, 'leshort', '=', 496L, 'MS Windows COFF PowerPC object file'],
+  [0L, 'leshort', '=', 656L, 'MS Windows COFF PA-RISC object file'],
+  [0L, 'string', '=', 'MZ', 'application/x-ms-dos-executable'],
+  [0L, 'string', '=', 'LZ', 'MS-DOS executable (built-in)'],
+  [0L, 'string', '=', 'regf', 'Windows NT Registry file'],
+  [2080L, 'string', '=', 'Microsoft Word 6.0 Document', 'text/vnd.ms-word'],
+  [2080L, 'string', '=', 'Documento Microsoft Word 6', 'text/vnd.ms-word'],
+  [2112L, 'string', '=', 'MSWordDoc', 'text/vnd.ms-word'],
+  [0L, 'belong', '=', 834535424L, 'text/vnd.ms-word'],
+  [0L, 'string', '=', 'PO^Q`', 'text/vnd.ms-word'],
+  [2080L, 'string', '=', 'Microsoft Excel 5.0 Worksheet', 'application/vnd.ms-excel'],
+  [2114L, 'string', '=', 'Biff5', 'application/vnd.ms-excel'],
+  [0L, 'belong', '=', 6656L, 'Lotus 1-2-3'],
+  [0L, 'belong', '=', 512L, 'Lotus 1-2-3'],
+  [1L, 'string', '=', 'WPC', 'text/vnd.wordperfect'],
+  [0L, 'beshort', '=', 610L, 'Tower/XP rel 2 object'],
+  [0L, 'beshort', '=', 615L, 'Tower/XP rel 2 object'],
+  [0L, 'beshort', '=', 620L, 'Tower/XP rel 3 object'],
+  [0L, 'beshort', '=', 625L, 'Tower/XP rel 3 object'],
+  [0L, 'beshort', '=', 630L, 'Tower32/600/400 68020 object'],
+  [0L, 'beshort', '=', 640L, 'Tower32/800 68020'],
+  [0L, 'beshort', '=', 645L, 'Tower32/800 68010'],
+  [0L, 'lelong', '=', 407L, 'NetBSD little-endian object file'],
+  [0L, 'belong', '=', 407L, 'NetBSD big-endian object file'],
+  [0L, 'belong&0377777777', '=', 41400413L, 'NetBSD/i386 demand paged'],
+  [0L, 'belong&0377777777', '=', 41400410L, 'NetBSD/i386 pure'],
+  [0L, 'belong&0377777777', '=', 41400407L, 'NetBSD/i386'],
+  [0L, 'belong&0377777777', '=', 41400507L, 'NetBSD/i386 core'],
+  [0L, 'belong&0377777777', '=', 41600413L, 'NetBSD/m68k demand paged'],
+  [0L, 'belong&0377777777', '=', 41600410L, 'NetBSD/m68k pure'],
+  [0L, 'belong&0377777777', '=', 41600407L, 'NetBSD/m68k'],
+  [0L, 'belong&0377777777', '=', 41600507L, 'NetBSD/m68k core'],
+  [0L, 'belong&0377777777', '=', 42000413L, 'NetBSD/m68k4k demand paged'],
+  [0L, 'belong&0377777777', '=', 42000410L, 'NetBSD/m68k4k pure'],
+  [0L, 'belong&0377777777', '=', 42000407L, 'NetBSD/m68k4k'],
+  [0L, 'belong&0377777777', '=', 42000507L, 'NetBSD/m68k4k core'],
+  [0L, 'belong&0377777777', '=', 42200413L, 'NetBSD/ns32532 demand paged'],
+  [0L, 'belong&0377777777', '=', 42200410L, 'NetBSD/ns32532 pure'],
+  [0L, 'belong&0377777777', '=', 42200407L, 'NetBSD/ns32532'],
+  [0L, 'belong&0377777777', '=', 42200507L, 'NetBSD/ns32532 core'],
+  [0L, 'belong&0377777777', '=', 42400413L, 'NetBSD/sparc demand paged'],
+  [0L, 'belong&0377777777', '=', 42400410L, 'NetBSD/sparc pure'],
+  [0L, 'belong&0377777777', '=', 42400407L, 'NetBSD/sparc'],
+  [0L, 'belong&0377777777', '=', 42400507L, 'NetBSD/sparc core'],
+  [0L, 'belong&0377777777', '=', 42600413L, 'NetBSD/pmax demand paged'],
+  [0L, 'belong&0377777777', '=', 42600410L, 'NetBSD/pmax pure'],
+  [0L, 'belong&0377777777', '=', 42600407L, 'NetBSD/pmax'],
+  [0L, 'belong&0377777777', '=', 42600507L, 'NetBSD/pmax core'],
+  [0L, 'belong&0377777777', '=', 43000413L, 'NetBSD/vax demand paged'],
+  [0L, 'belong&0377777777', '=', 43000410L, 'NetBSD/vax pure'],
+  [0L, 'belong&0377777777', '=', 43000407L, 'NetBSD/vax'],
+  [0L, 'belong&0377777777', '=', 43000507L, 'NetBSD/vax core'],
+  [0L, 'lelong', '=', 459141L, 'ECOFF NetBSD/alpha binary'],
+  [0L, 'belong&0377777777', '=', 43200507L, 'NetBSD/alpha core'],
+  [0L, 'belong&0377777777', '=', 43400413L, 'NetBSD/mips demand paged'],
+  [0L, 'belong&0377777777', '=', 43400410L, 'NetBSD/mips pure'],
+  [0L, 'belong&0377777777', '=', 43400407L, 'NetBSD/mips'],
+  [0L, 'belong&0377777777', '=', 43400507L, 'NetBSD/mips core'],
+  [0L, 'belong&0377777777', '=', 43600413L, 'NetBSD/arm32 demand paged'],
+  [0L, 'belong&0377777777', '=', 43600410L, 'NetBSD/arm32 pure'],
+  [0L, 'belong&0377777777', '=', 43600407L, 'NetBSD/arm32'],
+  [0L, 'belong&0377777777', '=', 43600507L, 'NetBSD/arm32 core'],
+  [0L, 'string', '=', 'StartFontMetrics', 'font/x-sunos-news'],
+  [0L, 'string', '=', 'StartFont', 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773060L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773063L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773072L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773073L, 'font/x-sunos-news'],
+  [8L, 'belong', '=', 326773573L, 'font/x-sunos-news'],
+  [8L, 'belong', '=', 326773576L, 'font/x-sunos-news'],
+  [0L, 'string', '=', 'Octave-1-L', 'Octave binary data (little endian)'],
+  [0L, 'string', '=', 'Octave-1-B', 'Octave binary data (big endian)'],
+  [0L, 'string', '=', '\177OLF', 'OLF'],
+  [0L, 'beshort', '=', 34765L, 'OS9/6809 module:'],
+  [0L, 'beshort', '=', 19196L, 'OS9/68K module:'],
+  [0L, 'long', '=', 61374L, 'OSF/Rose object'],
+  [0L, 'short', '=', 565L, 'i386 COFF object'],
+  [0L, 'short', '=', 10775L, '"compact bitmap" format (Poskanzer)'],
+  [0L, 'string', '=', '%PDF-', 'PDF document'],
+  [0L, 'lelong', '=', 101555L, 'PDP-11 single precision APL workspace'],
+  [0L, 'lelong', '=', 101554L, 'PDP-11 double precision APL workspace'],
+  [0L, 'leshort', '=', 407L, 'PDP-11 executable'],
+  [0L, 'leshort', '=', 401L, 'PDP-11 UNIX/RT ldp'],
+  [0L, 'leshort', '=', 405L, 'PDP-11 old overlay'],
+  [0L, 'leshort', '=', 410L, 'PDP-11 pure executable'],
+  [0L, 'leshort', '=', 411L, 'PDP-11 separate I&D executable'],
+  [0L, 'leshort', '=', 437L, 'PDP-11 kernel overlay'],
+  [0L, 'beshort', '=', 39168L, 'PGP key public ring'],
+  [0L, 'beshort', '=', 38145L, 'PGP key security ring'],
+  [0L, 'beshort', '=', 38144L, 'PGP key security ring'],
+  [0L, 'beshort', '=', 42496L, 'PGP encrypted data'],
+  [0L, 'string', '=', '-----BEGIN PGP', 'PGP armored data'],
+  [0L, 'string', '=', '# PaCkAgE DaTaStReAm', 'pkg Datastream (SVR4)'],
+  [0L, 'short', '=', 601L, 'mumps avl global'],
+  [0L, 'short', '=', 602L, 'mumps blt global'],
+  [0L, 'string', '=', '%!', 'application/postscript'],
+  [0L, 'string', '=', '\004%!', 'application/postscript'],
+  [0L, 'belong', '=', 3318797254L, 'DOS EPS Binary File'],
+  [0L, 'string', '=', '*PPD-Adobe:', 'PPD file'],
+  [0L, 'string', '=', '\033%-12345X at PJL', 'HP Printer Job Language data'],
+  [0L, 'string', '=', '\033%-12345X at PJL', 'HP Printer Job Language data'],
+  [0L, 'string', '=', '\033E\033', 'image/x-pcl-hp'],
+  [0L, 'string', '=', '@document(', 'Imagen printer'],
+  [0L, 'string', '=', 'Rast', 'RST-format raster font data'],
+  [0L, 'belong&0xff00ffff', '=', 1442840576L, 'ps database'],
+  [0L, 'long', '=', 1351614727L, 'Pyramid 90x family executable'],
+  [0L, 'long', '=', 1351614728L, 'Pyramid 90x family pure executable'],
+  [0L, 'long', '=', 1351614731L, 'Pyramid 90x family demand paged pure executable'],
+  [0L, 'beshort', '=', 60843L, ''],
+  [0L, 'string', '=', '{\\\\rtf', 'Rich Text Format data,'],
+  [38L, 'string', '=', 'Spreadsheet', 'sc spreadsheet file'],
+  [8L, 'string', '=', '\001s SCCS', 'archive data'],
+  [0L, 'byte', '=', 46L, 'Sendmail frozen configuration'],
+  [0L, 'short', '=', 10012L, 'Sendmail frozen configuration'],
+  [0L, 'lelong', '=', 234L, 'BALANCE NS32000 .o'],
+  [0L, 'lelong', '=', 4330L, 'BALANCE NS32000 executable (0 @ 0)'],
+  [0L, 'lelong', '=', 8426L, 'BALANCE NS32000 executable (invalid @ 0)'],
+  [0L, 'lelong', '=', 12522L, 'BALANCE NS32000 standalone executable'],
+  [0L, 'leshort', '=', 4843L, 'SYMMETRY i386 .o'],
+  [0L, 'leshort', '=', 8939L, 'SYMMETRY i386 executable (0 @ 0)'],
+  [0L, 'leshort', '=', 13035L, 'SYMMETRY i386 executable (invalid @ 0)'],
+  [0L, 'leshort', '=', 17131L, 'SYMMETRY i386 standalone executable'],
+  [0L, 'string', '=', 'kbd!map', 'kbd map file'],
+  [0L, 'belong', '=', 407L, 'old SGI 68020 executable'],
+  [0L, 'belong', '=', 410L, 'old SGI 68020 pure executable'],
+  [0L, 'beshort', '=', 34661L, 'disk quotas file'],
+  [0L, 'beshort', '=', 1286L, 'IRIS Showcase file'],
+  [0L, 'beshort', '=', 550L, 'IRIS Showcase template'],
+  [0L, 'belong', '=', 1396917837L, 'IRIS Showcase file'],
+  [0L, 'belong', '=', 1413695053L, 'IRIS Showcase template'],
+  [0L, 'belong', '=', 3735927486L, 'IRIX Parallel Arena'],
+  [0L, 'beshort', '=', 352L, 'MIPSEB COFF executable'],
+  [0L, 'beshort', '=', 354L, 'MIPSEL COFF executable'],
+  [0L, 'beshort', '=', 24577L, 'MIPSEB-LE COFF executable'],
+  [0L, 'beshort', '=', 25089L, 'MIPSEL-LE COFF executable'],
+  [0L, 'beshort', '=', 355L, 'MIPSEB MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 358L, 'MIPSEL MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 25345L, 'MIPSEB-LE MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 26113L, 'MIPSEL-LE MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 320L, 'MIPSEB MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 322L, 'MIPSEL MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 16385L, 'MIPSEB-LE MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 16897L, 'MIPSEL-LE MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 384L, 'MIPSEB Ucode'],
+  [0L, 'beshort', '=', 386L, 'MIPSEL Ucode'],
+  [0L, 'belong', '=', 3735924144L, 'IRIX core dump'],
+  [0L, 'belong', '=', 3735924032L, 'IRIX 64-bit core dump'],
+  [0L, 'belong', '=', 3133063355L, 'IRIX N32 core dump'],
+  [0L, 'string', '=', 'CrshDump', 'IRIX vmcore dump of'],
+  [0L, 'string', '=', 'SGIAUDIT', 'SGI Audit file'],
+  [0L, 'string', '=', 'WNGZWZSC', 'Wingz compiled script'],
+  [0L, 'string', '=', 'WNGZWZSS', 'Wingz spreadsheet'],
+  [0L, 'string', '=', 'WNGZWZHP', 'Wingz help file'],
+  [0L, 'string', '=', '\\#Inventor', 'V IRIS Inventor 1.0 file'],
+  [0L, 'string', '=', '\\#Inventor', 'V2 Open Inventor 2.0 file'],
+  [0L, 'string', '=', 'glfHeadMagic();', 'GLF_TEXT'],
+  [4L, 'belong', '=', 1090584576L, 'GLF_BINARY_LSB_FIRST'],
+  [4L, 'belong', '=', 321L, 'GLF_BINARY_MSB_FIRST'],
+  [0L, 'string', '=', '<!DOCTYPE HTML', 'text/html'],
+  [0L, 'string', '=', '<!doctype html', 'text/html'],
+  [0L, 'string', '=', '<HEAD', 'text/html'],
+  [0L, 'string', '=', '<head', 'text/html'],
+  [0L, 'string', '=', '<TITLE', 'text/html'],
+  [0L, 'string', '=', '<title', 'text/html'],
+  [0L, 'string', '=', '<html', 'text/html'],
+  [0L, 'string', '=', '<HTML', 'text/html'],
+  [0L, 'string', '=', '<!DOCTYPE', 'exported SGML document text'],
+  [0L, 'string', '=', '<!doctype', 'exported SGML document text'],
+  [0L, 'string', '=', '<!SUBDOC', 'exported SGML subdocument text'],
+  [0L, 'string', '=', '<!subdoc', 'exported SGML subdocument text'],
+  [0L, 'string', '=', '<!--', 'exported SGML document text'],
+  [0L, 'string', '=', 'RTSS', 'NetMon capture file'],
+  [0L, 'string', '=', 'TRSNIFF data    \032', 'Sniffer capture file'],
+  [0L, 'string', '=', 'XCP\000', 'NetXRay capture file'],
+  [0L, 'ubelong', '=', 2712847316L, 'tcpdump capture file (big-endian)'],
+  [0L, 'ulelong', '=', 2712847316L, 'tcpdump capture file (little-endian)'],
+  [0L, 'string', '=', '<!SQ DTD>', 'Compiled SGML rules file'],
+  [0L, 'string', '=', '<!SQ A/E>', 'A/E SGML Document binary'],
+  [0L, 'string', '=', '<!SQ STS>', 'A/E SGML binary styles file'],
+  [0L, 'short', '=', 49374L, 'Compiled PSI (v1) data'],
+  [0L, 'short', '=', 49370L, 'Compiled PSI (v2) data'],
+  [0L, 'short', '=', 125252L, 'SoftQuad DESC or font file binary'],
+  [0L, 'string', '=', 'SQ BITMAP1', 'SoftQuad Raster Format text'],
+  [0L, 'string', '=', 'X SoftQuad', 'troff Context intermediate'],
+  [0L, 'belong&077777777', '=', 600413L, 'sparc demand paged'],
+  [0L, 'belong&077777777', '=', 600410L, 'sparc pure'],
+  [0L, 'belong&077777777', '=', 600407L, 'sparc'],
+  [0L, 'belong&077777777', '=', 400413L, 'mc68020 demand paged'],
+  [0L, 'belong&077777777', '=', 400410L, 'mc68020 pure'],
+  [0L, 'belong&077777777', '=', 400407L, 'mc68020'],
+  [0L, 'belong&077777777', '=', 200413L, 'mc68010 demand paged'],
+  [0L, 'belong&077777777', '=', 200410L, 'mc68010 pure'],
+  [0L, 'belong&077777777', '=', 200407L, 'mc68010'],
+  [0L, 'belong', '=', 407L, 'old sun-2 executable'],
+  [0L, 'belong', '=', 410L, 'old sun-2 pure executable'],
+  [0L, 'belong', '=', 413L, 'old sun-2 demand paged executable'],
+  [0L, 'belong', '=', 525398L, 'SunOS core file'],
+  [0L, 'long', '=', 4197695630L, 'SunPC 4.0 Hard Disk'],
+  [0L, 'string', '=', '#SUNPC_CONFIG', 'SunPC 4.0 Properties Values'],
+  [0L, 'string', '=', 'snoop', 'Snoop capture file'],
+  [36L, 'string', '=', 'acsp', 'Kodak Color Management System, ICC Profile'],
+  [0L, 'string', '=', '#!teapot\012xdr', 'teapot work sheet (XDR format)'],
+  [0L, 'string', '=', '\032\001', 'Compiled terminfo entry'],
+  [0L, 'short', '=', 433L, 'Curses screen image'],
+  [0L, 'short', '=', 434L, 'Curses screen image'],
+  [0L, 'string', '=', '\367\002', 'TeX DVI file'],
+  [0L, 'string', '=', '\367\203', 'font/x-tex'],
+  [0L, 'string', '=', '\367Y', 'font/x-tex'],
+  [0L, 'string', '=', '\367\312', 'font/x-tex'],
+  [0L, 'string', '=', 'This is TeX,', 'TeX transcript text'],
+  [0L, 'string', '=', 'This is METAFONT,', 'METAFONT transcript text'],
+  [2L, 'string', '=', '\000\021', 'font/x-tex-tfm'],
+  [2L, 'string', '=', '\000\022', 'font/x-tex-tfm'],
+  [0L, 'string', '=', '\\\\input\\', 'texinfo Texinfo source text'],
+  [0L, 'string', '=', 'This is Info file', 'GNU Info text'],
+  [0L, 'string', '=', '\\\\input', 'TeX document text'],
+  [0L, 'string', '=', '\\\\section', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\setlength', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\documentstyle', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\chapter', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\documentclass', 'LaTeX 2e document text'],
+  [0L, 'string', '=', '\\\\relax', 'LaTeX auxiliary file'],
+  [0L, 'string', '=', '\\\\contentsline', 'LaTeX table of contents'],
+  [0L, 'string', '=', '\\\\indexentry', 'LaTeX raw index file'],
+  [0L, 'string', '=', '\\\\begin{theindex}', 'LaTeX sorted index'],
+  [0L, 'string', '=', '\\\\glossaryentry', 'LaTeX raw glossary'],
+  [0L, 'string', '=', '\\\\begin{theglossary}', 'LaTeX sorted glossary'],
+  [0L, 'string', '=', 'This is makeindex', 'Makeindex log file'],
+  [0L, 'string', '=', '**TI82**', 'TI-82 Graphing Calculator'],
+  [0L, 'string', '=', '**TI83**', 'TI-83 Graphing Calculator'],
+  [0L, 'string', '=', '**TI85**', 'TI-85 Graphing Calculator'],
+  [0L, 'string', '=', '**TI92**', 'TI-92 Graphing Calculator'],
+  [0L, 'string', '=', '**TI80**', 'TI-80 Graphing Calculator File.'],
+  [0L, 'string', '=', '**TI81**', 'TI-81 Graphing Calculator File.'],
+  [0L, 'string', '=', 'TZif', 'timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000', 'old timezone data'],
+  [0L, 'string', '=', '.\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\'\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\'.\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', 'x T', 'ditroff text'],
+  [0L, 'string', '=', '@\357', 'very old (C/A/T) troff output data'],
+  [0L, 'string', '=', 'Interpress/Xerox', 'Xerox InterPress data'],
+  [0L, 'short', '=', 263L, 'unknown machine executable'],
+  [0L, 'short', '=', 264L, 'unknown pure executable'],
+  [0L, 'short', '=', 265L, 'PDP-11 separate I&D'],
+  [0L, 'short', '=', 267L, 'unknown pure executable'],
+  [0L, 'long', '=', 268L, 'unknown demand paged pure executable'],
+  [0L, 'long', '=', 269L, 'unknown demand paged pure executable'],
+  [0L, 'long', '=', 270L, 'unknown readable demand paged pure executable'],
+  [0L, 'string', '=', 'begin uuencoded', 'or xxencoded text'],
+  [0L, 'string', '=', 'xbtoa Begin', "btoa'd text"],
+  [0L, 'string', '=', '$\012ship', "ship'd binary text"],
+  [0L, 'string', '=', 'Decode the following with bdeco', 'bencoded News text'],
+  [11L, 'string', '=', 'must be converted with BinHex', 'BinHex binary text'],
+  [0L, 'short', '=', 610L, 'Perkin-Elmer executable'],
+  [0L, 'beshort', '=', 572L, 'amd 29k coff noprebar executable'],
+  [0L, 'beshort', '=', 1572L, 'amd 29k coff prebar executable'],
+  [0L, 'beshort', '=', 160007L, 'amd 29k coff archive'],
+  [6L, 'beshort', '=', 407L, 'unicos (cray) executable'],
+  [596L, 'string', '=', 'X\337\377\377', 'Ultrix core file'],
+  [0L, 'string', '=', 'Joy!peffpwpc', 'header for PowerPC PEF executable'],
+  [0L, 'lelong', '=', 101557L, 'VAX single precision APL workspace'],
+  [0L, 'lelong', '=', 101556L, 'VAX double precision APL workspace'],
+  [0L, 'lelong', '=', 407L, 'VAX executable'],
+  [0L, 'lelong', '=', 410L, 'VAX pure executable'],
+  [0L, 'lelong', '=', 413L, 'VAX demand paged pure executable'],
+  [0L, 'leshort', '=', 570L, 'VAX COFF executable'],
+  [0L, 'leshort', '=', 575L, 'VAX COFF pure executable'],
+  [0L, 'string', '=', 'LBLSIZE=', 'VICAR image data'],
+  [43L, 'string', '=', 'SFDU_LABEL', 'VICAR label file'],
+  [0L, 'short', '=', 21845L, 'VISX image file'],
+  [0L, 'string', '=', '\260\0000\000', 'VMS VAX executable'],
+  [0L, 'belong', '=', 50331648L, 'VMS Alpha executable'],
+  [1L, 'string', '=', 'WPC', '(Corel/WP)'],
+  [0L, 'string', '=', 'core', 'core file (Xenix)'],
+  [0L, 'byte', '=', 128L, '8086 relocatable (Microsoft)'],
+  [0L, 'leshort', '=', 65381L, 'x.out'],
+  [0L, 'leshort', '=', 518L, 'Microsoft a.out'],
+  [0L, 'leshort', '=', 320L, 'old Microsoft 8086 x.out'],
+  [0L, 'lelong', '=', 518L, 'b.out'],
+  [0L, 'leshort', '=', 1408L, 'XENIX 8086 relocatable or 80286 small model'],
+  [0L, 'long', '=', 59399L, 'object file (z8000 a.out)'],
+  [0L, 'long', '=', 59400L, 'pure object file (z8000 a.out)'],
+  [0L, 'long', '=', 59401L, 'separate object file (z8000 a.out)'],
+  [0L, 'long', '=', 59397L, 'overlay object file (z8000 a.out)'],
+  [0L, 'string', '=', 'ZyXEL\002', 'ZyXEL voice data'],
+]
+
+magicNumbers = []
+
+def strToNum(n):
+  val = 0
+  col = long(1)
+  if n[:1] == 'x': n = '0' + n
+  if n[:2] == '0x':
+    # hex
+    n = string.lower(n[2:])
+    while len(n) > 0:
+      l = n[len(n) - 1]
+      val = val + string.hexdigits.index(l) * col
+      col = col * 16
+      n = n[:len(n)-1]
+  elif n[0] == '\\':
+    # octal
+    n = n[1:]
+    while len(n) > 0:
+      l = n[len(n) - 1]
+      if ord(l) < 48 or ord(l) > 57: break
+      val = val + int(l) * col
+      col = col * 8
+      n = n[:len(n)-1]
+  else:
+    val = string.atol(n)
+  return val
+       
+def unescape(s):
+  # replace string escape sequences
+  while 1:
+    m = re.search(r'\\', s)
+    if not m: break
+    x = m.start()+1
+    if m.end() == len(s): 
+      # escaped space at end
+      s = s[:len(s)-1] + ' '
+    elif s[x:x+2] == '0x':
+      # hex ascii value
+      c = chr(strToNum(s[x:x+4]))
+      s = s[:x-1] + c + s[x+4:]
+    elif s[m.start()+1] == 'x':
+      # hex ascii value
+      c = chr(strToNum(s[x:x+3]))
+      s = s[:x-1] + c + s[x+3:]
+    elif ord(s[x]) > 47 and ord(s[x]) < 58:
+      # octal ascii value
+      end = x
+      while (ord(s[end]) > 47 and ord(s[end]) < 58):
+        end = end + 1
+        if end > len(s) - 1: break
+      c = chr(strToNum(s[x-1:end]))
+      s = s[:x-1] + c + s[end:]
+    elif s[x] == 'n':
+      # newline
+      s = s[:x-1] + '\n' + s[x+1:]
+    else:
+      break
+  return s
+
+class magicTest:
+  def __init__(self, offset, t, op, value, msg, mask = None):
+    if t.count('&') > 0:
+      mask = strToNum(t[t.index('&')+1:])  
+      t = t[:t.index('&')]
+    if type(offset) == type('a'):
+      self.offset = strToNum(offset)
+    else:
+      self.offset = offset
+    self.type = t
+    self.msg = msg
+    self.subTests = []
+    self.op = op
+    self.mask = mask
+    self.value = value
+      
+
+  def test(self, data):
+    if self.mask:
+      data = data & self.mask
+    if self.op == '=': 
+      if self.value == data: return self.msg
+    elif self.op ==  '<':
+      pass
+    elif self.op ==  '>':
+      pass
+    elif self.op ==  '&':
+      pass
+    elif self.op ==  '^':
+      pass
+    return None
+
+  def compare(self, data):
+    #print str([self.type, self.value, self.msg])
+    try: 
+      if self.type == 'string':
+        c = ''; s = ''
+        for i in range(0, len(self.value)+1):
+          if i + self.offset > len(data) - 1: break
+          s = s + c
+          [c] = struct.unpack('c', data[self.offset + i])
+        data = s
+      elif self.type == 'short':
+        [data] = struct.unpack('h', data[self.offset : self.offset + 2])
+      elif self.type == 'leshort':
+        [data] = struct.unpack('<h', data[self.offset : self.offset + 2])
+      elif self.type == 'beshort':
+        [data] = struct.unpack('>H', data[self.offset : self.offset + 2])
+      elif self.type == 'long':
+        [data] = struct.unpack('l', data[self.offset : self.offset + 4])
+      elif self.type == 'lelong':
+        [data] = struct.unpack('<l', data[self.offset : self.offset + 4])
+      elif self.type == 'belong':
+        [data] = struct.unpack('>l', data[self.offset : self.offset + 4])
+      else:
+        #print 'UNKNOWN TYPE: ' + self.type
+        pass
+    except:
+      return None
+  
+#    print str([self.msg, self.value, data])
+    return self.test(data)
+    
+
+def load(file):
+  global magicNumbers
+  lines = open(file).readlines()
+  last = { 0: None }
+  for line in lines:
+    if re.match(r'\s*#', line):
+      # comment
+      continue
+    else:
+      # split up by space delimiters, and remove trailing space
+      line = string.rstrip(line)
+      line = re.split(r'\s*', line)
+      if len(line) < 3:
+        # bad line
+        continue
+      offset = line[0]
+      type = line[1]
+      value = line[2]
+      level = 0
+      while offset[0] == '>':
+        # count the level of the type
+        level = level + 1
+        offset = offset[1:]
+      l = magicNumbers
+      if level > 0:
+        l = last[level - 1].subTests
+      if offset[0] == '(':
+        # don't handle indirect offsets just yet
+        print 'SKIPPING ' + string.join(list(line[3:]))
+        pass
+      elif offset[0] == '&':
+        # don't handle relative offsets just yet
+        print 'SKIPPING ' + string.join(list(line[3:]))
+        pass
+      else:
+        operands = ['=', '<', '>', '&']
+        if operands.count(value[0]) > 0:
+          # a comparison operator is specified
+          op = value[0] 
+          value = value[1:]
+        else:
+          print str([value, operands])
+          if len(value) >1 and value[0] == '\\' and operands.count(value[1]) >0:
+            # literal value that collides with operands is escaped
+            value = value[1:]
+          op = '='
+
+        mask = None
+        if type == 'string':
+          while 1:
+            value = unescape(value)
+            if value[len(value)-1] == ' ' and len(line) > 3:
+              # last value was an escaped space, join
+              value = value + line[3]
+              del line[3]
+            else:
+              break
+        else:
+          if value.count('&') != 0:
+            mask = value[(value.index('&') + 1):]
+            print 'MASK: ' + mask
+            value = value[:(value.index('&')+1)]
+          try: value = strToNum(value)
+          except: continue
+          msg = string.join(list(line[3:]))
+        new = magicTest(offset, type, op, value, msg, mask)
+        last[level] = new
+        l.append(new)
+
+def whatis(data):
+  for test in magicNumbers:
+     m = test.compare(data)
+     if m: return m
+  # no matching, magic number. is it binary or text?
+  for c in data:
+    if ord(c) > 128:
+      return 'data'
+  # its ASCII, now do text tests
+  if string.find('The', data, 0, 8192) > -1:
+    return 'English text'
+  if string.find('def', data, 0, 8192) > -1:
+    return 'Python Source'
+  return 'ASCII text'
+      
+    
+def file(file):
+  try:
+    return whatis(open(file, 'r').read(8192))
+  except Exception, e:
+    if str(e) == '[Errno 21] Is a directory':
+      return 'directory'
+    else:
+      raise e
+  
+
+#### BUILD DATA ####
+#load('mime-magic')
+#f = open('out', 'w')
+#for m in magicNumbers:
+#  f.write(str([m.offset, m.type, m.op, m.value, m.msg]) + ',\n')
+#f.close
+
+import sys
+for m in magic:
+  magicNumbers.append(magicTest(m[0], m[1], m[2], m[3], m[4]))
+
+if __name__ == '__main__':
+  import sys
+  for arg in sys.argv[1:]:
+    msg = file(arg)
+    if msg:
+      print arg + ': ' + msg
+    else:
+      print arg + ': unknown'


Property changes on: haypo/hachoir/branches/hachoir-yield/libhachoir/fallback/magic.py
___________________________________________________________________
Name: svn:mime-type
   + text/script

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,4 @@
+from field import Field
+from integer import Integer, IntegerHex, Enum, Bits, Bit
+from string_field import String
+from field_set import FieldSet, ParserError

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,61 @@
+class Field(object):
+    is_field_set = False
+    
+    def __init__(self, parent, name, value, size=None, address=None, description=None):
+        assert parent == None or issubclass(parent.__class__, Field)
+        self.parent = parent
+        self._name = name 
+        self._value = value
+        if address == None:
+            if parent != None:
+                address = parent.newFieldAskAddress()
+            else:
+                address = 0
+        self.address = address
+        self._size = size 
+        self.description = description
+
+    def readRawContent(self):
+        stream = self.parent.stream
+        stream.seek(self.absolute_address)
+        return stream.getN(self.size)
+
+    def __str__(self):
+        return self.display
+
+    def _getValue(self):
+        return self._value
+    def _setValue(self, new_value):
+        self._value = new_value
+        self.parent.raiseEvent("value-changed", self)
+    value = property(_getValue, _setValue)
+
+    def _getDisplay(self):
+        raise NotImplementedError()
+    display = property(_getDisplay)
+
+    def _getName(self):
+        return self._name
+    name = property(_getName)
+
+    def _getPath(self):
+        path = "/"+self.name
+        current = self.parent
+        while current != None:
+            path = "/" + current. name + path
+            current = current.parent
+        return path
+    path = property(_getPath)
+
+    def _getAbsoluteAddress(self):
+        address = self.address
+        current = self.parent
+        while current != None:
+            address += current.address
+            current = current.parent
+        return address
+    absolute_address = property(_getAbsoluteAddress)
+
+    def _getSize(self):
+        return self._size
+    size = property(_getSize)

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,226 @@
+from event_handler import EventHandler
+from field import Field
+from indexed_dict import IndexedDict
+import config
+
+class MissingField(KeyError):
+    pass
+
+class ParserError(Exception):
+    pass
+
+class FieldSet(Field):
+    """
+    Ordered list of fields. Use operator [] to access fields using their
+    name (field names are unique in a field set, but not in the whole
+    document).
+
+    Class attributes:
+       * endian: Default endian of integer fields ("!" by default,
+         network order). Values can be "!" (network order, little endian),
+         ">" (same than "!"), or ">" (big endian)
+       * static_size: Size of FieldSet in bits (optionnal attribute).
+         This attribute is optionnal and should be used in parser when
+         the size is constant
+
+    Instance attributes/methods:
+       * fields: Ordered dictionnary of all fields, may be incomplete
+         because feeded when a field is requested
+       * stream: Input stream used to feed fields' value
+       * root: The root of all field sets
+       * __len__(): Number of fields, may need to create field set 
+       * __getitem(): Get an field by it's name or it's path
+
+    And attributes inherited from Field class:
+       * parent: Parent field (may be None if it's the root)
+       * name: Field name (unique in parent field set)
+       * value: The field set
+       * address: Field address (in bits) relative to parent
+       * description: A string describing the content (can be None)
+       * size: Size of field set in bits, may need to create field set
+
+    Event handling:
+       * connect: Connect an handler to an event
+       * raiseEvent: Raise an event 
+   
+    To implement a new field set, you need to:
+       * create a class which inherite from FieldSet
+       * write createFields() method using lines like:
+         "yield <field class>(self, <field name>, ...)"
+       * and maybe set endian/static_size class attributes
+    """
+
+    is_field_set = True
+    endian = "!"
+
+    def __init__(self, parent, name, stream, description=None, size=None):
+        if hasattr(self, "static_size"):
+            self._size = self.static_size
+        else:
+            self._size = size 
+        assert self.endian in ("!", "<", ">")
+        Field.__init__(self, parent, name, self, size=self._size, description=description)
+        self.stream = stream
+        self.fields = IndexedDict()
+        self._event_handler = None
+        self._field_generator = self.createFields()
+        self._field_array_count = {}
+        self._total_field_size = 0
+        if parent != None:
+            self.root = parent.root
+        else:
+            self.root = self
+
+    def __str__(self):
+        return "(...)" 
+
+    def _getDisplay(self):
+        return "(...)" 
+    display = property(_getDisplay)
+
+    def connect(self, event_name, handler):
+        if self._event_handler == None:
+            self._event_handler = EventHandler()
+        self._event_handler.connect(event_name, handler)
+
+    def raiseEvent(self, event_name, *args):
+        if self._event_handler == None:
+            return
+        self._event_handler.raiseEvent(event_name, *args)
+
+    def __len__(self):
+        if self._field_generator != None:
+            self._feedAll()
+        return len(self.fields)
+
+    def _getSize(self):
+        if self._size == None:
+            self._feedAll()
+        return self._size
+    size = property(_getSize)
+
+    def newFieldAskAddress(self):
+        return self._total_field_size
+
+    def _feed(self):
+        # Instanciate the field
+        stream_address = self.absolute_address + self._total_field_size
+        field = self._field_generator.next()
+
+        if config.debug:
+            addr = field.absolute_address
+            print "* Instanciate %s (addr=%s.%s, size=%s bits)" \
+                % (field.path, addr/8, addr%8, field.size)
+
+        # Compute field address and total field size
+        assert field.address == self._total_field_size
+        self._total_field_size += field.size
+
+        # Replace "name[]" with "name[<index>]"
+        if field._name[-2:] == "[]":
+            name = field._name[:-2]
+            if name in self._field_array_count:
+                self._field_array_count[name] += 1
+            else:
+                self._field_array_count[name] = 0
+            field._name = name + "[%u]" % self._field_array_count[name]
+
+        # Append field to the field list
+        self.fields.append(field._name, field)
+        return field
+
+    def getChunkByPath(self, path):
+        names = path.split("/")
+        if names[0] == '':
+            # Path "/..." => start from root
+            field = self.root
+            names = names[1:]
+        elif names[0] == '..':
+            if self.parent == None:
+                raise MissingField("Field '%s' has no parent (can't get field %s)!" \
+                    % (path, self.path))
+            field = self.parent
+            names = names[1:]
+        else:
+            field = self
+        # For path like "../" => delete last (useless) "/"
+        if 1 <= len(names) and names[-1] == '':
+            del names[-1]
+        for name in names:
+            if name=="" or not field.is_field_set:
+                raise MissingField("Field '%s' doesn't exist in %s" \
+                    % (path, self.path))
+            field = field[name]
+        return field
+
+    def __getitem__(self, name):
+        """
+        Get an item with it's name or it's path.
+        @rtype Field
+        """
+        
+        # Get item with a path? (eg. "point/x")
+        if "/" in name or name.startswith(".."):
+            return self.getChunkByPath(name)
+
+        # Field does exit?
+        if name in self.fields:
+            return self.fields[name]
+            
+        # Feed until field can be found
+        if self._field_generator != None:
+            field = self._feedUntil(name)
+            if field != None:
+                return field
+        raise MissingField("Field '%s' doesn't exist in %s" \
+            % (name, self.path))
+
+    def __contains__(self, name):
+        if "/" in name or name.startswith(".."):
+            try:
+                field = self.getChunkByPath(name)
+                return True
+            except MissingField:
+                return False
+        else:
+            if self._field_generator != None:
+                field = self._feedUntil(name)
+            return name in self.fields
+
+    def _stopFeeding(self):
+        self._field_generator = None
+        self._size = self._total_field_size
+
+    def _feedUntil(self, field_name):
+        try:
+            while True:
+                field = self._feed()
+                if field.name == field_name:
+                    return field
+        except StopIteration:
+            self._stopFeeding()
+        return None
+
+    def _feedAll(self):
+        try:
+            while True:
+                self._feed()
+        except StopIteration:
+            self._stopFeeding()
+
+    def __iter__(self):
+        # Iterate in existing fields
+        for field in self.fields:
+            yield field
+        
+        # If field set in not yet complete, continue to feed it
+        if self._field_generator != None:
+            try:
+                while True:
+                    yield self._feed()
+            except StopIteration:
+                self._stopFeeding()
+
+    def createFields(self):
+        raise NotImplementedError
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/integer.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,68 @@
+from field import Field
+from format import getFormatSize
+from text_handler import hexadecimal
+
+class Bits(Field):
+    def __init__(self, parent, name, size, description=None):
+        assert issubclass(parent.__class__, Field)
+        Field.__init__(self, parent, name, None, size, description=description)
+
+    def _getValue(self):
+        if self._value == None:
+            self._value = self.parent.stream.getBits(
+                self.absolute_address, self.size, True) 
+        return self._value
+    value = property(_getValue, Field._setValue)
+   
+    def _getDisplay(self):
+        return self.value
+    display = property(_getDisplay)
+
+class Bit(Bits):
+    def __init__(self, parent, name, description=None):
+        Bits.__init__(self, parent, name, 1, description=description)
+
+    def _getValue(self):
+        if self._value == None:
+            data = self.parent.stream.getBits(
+                self.absolute_address, self.size, True) 
+            self._value = (data == 1)
+        return self._value
+    value = property(_getValue, Field._setValue)
+   
+class Integer(Field):
+    def __init__(self, parent, name, format, description=None):
+        assert issubclass(parent.__class__, Field)
+        if format[0] not in "!<>":
+            self.format = parent.endian + format
+        else:
+            self.format = format
+        size = getFormatSize(format)*8
+        Field.__init__(self, parent, name, None, size, description=description)
+
+    def _getValue(self):
+        if self._value == None:
+            self._value = self.parent.stream.getBits(
+                self.absolute_address, self.size, self.parent.endian=="<")
+        return self._value
+    value = property(_getValue, Field._setValue)
+   
+    def _getDisplay(self):
+        return self.value
+    display = property(_getDisplay)
+
+class IntegerHex(Integer):   
+    def _getDisplay(self):
+        return hexadecimal(self)
+    display = property(_getDisplay)
+
+class Enum(Integer):   
+    def __init__(self, parent, name, format, enum, description=None):
+        self.enum = enum
+        Integer.__init__(self, parent, name, format, description)
+    
+    def _getDisplay(self):
+        value = self.value
+        return self.enum.get(value, value)
+    display = property(_getDisplay)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,37 @@
+from field import Field
+from format import getFormatSize
+from tools import convertDataToPrintableString
+
+class String(Field):
+    def __init__(self, parent, name, format, description=None):
+        assert issubclass(parent.__class__, Field)
+        self.format = format
+        size = getFormatSize(format)*8
+        Field.__init__(self, parent, name, None, size, description=description)
+        
+    def _getDisplay(self):
+        max = 20
+        if self._value == None:
+            assert (self.size % 8) == 0
+            if max < self._size/8:
+                display = self.parent.stream.getBytes( \
+                    self.absolute_address, max)
+                display += "(...)"
+            else:
+                self._value = self.parent.stream.getBytes( \
+                    self.absolute_address, self._size / 8)
+                display = self._value
+        else:
+            display = self._value[:max]
+            if max < self._size/8:
+                display += "(...)"
+        return convertDataToPrintableString(display)
+    display = property(_getDisplay)        
+    
+    def _getValue(self):
+        if self._value == None:
+            assert (self.size % 8) == 0
+            self._value = self.parent.stream.getBytes( \
+                self.absolute_address, self.size / 8)
+        return self._value
+    value = property(_getValue, Field._setValue)

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/format.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/format.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/format.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,108 @@
+import re, struct
+from cache import Cache
+
+class FormatCache(Cache):
+    # Uniq instance of the class
+    _instance = None
+
+    # Check if a format is an array or not
+    # "string[4]" is an array, "char" isn't
+    regex_array =  re.compile("^([a-z]+[0-9]*)\[([0-9]+)\]$")
+
+    # Convert Hachoir syntax to struct module syntax
+    format_type = {
+        "string": "s",
+        "char": "c",
+        "float": "f",
+        "double": "d",
+        "int8": "b",
+        "uint8": "B",
+        "int16": "h",
+        "uint16": "H",
+        "int32": "l",
+        "uint32": "L"
+    }
+
+    # Singleton design pattern
+    def __new__(cls):
+        if cls._instance == None:
+            cls._instance = object.__new__(cls)
+        return cls._instance
+    
+    def __init__(self):
+        Cache.__init__(self, "FormatCache")
+        self._dict = {}
+
+    def getCacheSize(self):
+        return len(self._dict)
+
+    def purgeCache(self):
+        self._dict = {}
+
+    def convertNewFormat(self, format):
+        old_format = format
+        if format[0] in "!<>":
+            endian = format[0]
+            str_endian = format[0]
+            format = format[1:]
+        else:
+            endian = None
+            str_endian = ""
+        m = FormatCache.regex_array.match(format)
+        if m != None:
+            format = m.group(1)
+            str_count = m.group(2)
+            count = int(str_count)
+        else:
+            str_count = "" 
+            count = 1
+        if format not in FormatCache.format_type:
+            raise Exception("Format \"%s\" is invalid!" % old_format)
+        type = FormatCache.format_type[format]
+        return (str_endian + str_count + type, endian, count, type)
+
+    def __getitem__(self, format):
+        if format not in self._dict:
+            real_format, endian, count, type = self.convertNewFormat(format)
+            size = count * struct.calcsize(type)
+            self._dict[format] = (real_format, endian, count, type, size)
+        return self._dict[format]   
+
+_format_size_cache = {}
+
+def formatIsString(format):
+    cache = FormatCache()[format]
+    return cache[3] == "s"
+
+def formatIsInteger(format):
+    cache = FormatCache()[format]
+    return cache[3] in "bBhHlL"
+
+def getFormatEndian(format):
+    cache = FormatCache()[format]
+    return cache[1]   
+
+def getFormatSize(format):
+    cache = FormatCache()[format]
+    return cache[4]   
+
+def getRealFormat(format):
+    cache = FormatCache()[format]
+    return cache[0]   
+
+def checkFormat(format):
+    # TODO: Don't use try/except, but something better
+    try:
+        cache = FormatCache()
+        conv = cache.convertNewFormat(format)
+        return True
+    except:
+        return False
+
+def splitFormat(format):
+    cache = FormatCache()[format]
+    return cache[1:4]   
+
+def formatIsArray(format):
+    cache = FormatCache()[format]
+    return (1 < cache[2]) and (cache[3] != "s")

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,26 @@
+class UniqKeyError(KeyError):
+    pass
+
+class IndexedDict:
+    def __init__(self):
+        self._dict = {}
+        self._list = []
+
+    def __getitem__(self, key):
+        return self._dict[key]
+
+    def append(self, key, value):
+        if key in self._dict:
+            raise UniqKeyError("Key '%s' already exists" % key)
+        self._dict[key] = value
+        self._list.append(value)
+
+    def __len__(self):
+        return len(self._list)
+
+    def __contains__(self, key):
+        return key in self._dict
+
+    def __iter__(self):
+        return iter(self._list)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/log.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/log.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/log.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,93 @@
+#!/usr/bin/env python
+# -*- coding: UTF-8 -*-
+
+import time
+
+class Log:
+    LOG_INFO   = 0
+    LOG_WARN   = 1
+    LOG_ERROR  = 2
+
+    def __init__(self):
+        self.__buffer = {}
+        self.__file = None
+        self.use_print = True
+        self.on_new_message = None # (level, prefix, text)
+
+    def setFilename(self, filename):
+        """
+        Use a file to store all messages. The
+        UTF-8 encoding will be used. Write an informative
+        message if the file can't be created.
+
+        @param filename: C{L{string}}
+        """
+
+        try:
+            import codecs
+            self.__file = codecs.open(filename, "w", "utf-8")
+        except IOError, errno:
+            if errno[0] == 2:
+                self.__file = None
+                self.info("Log.setFilename(%s) fails : no such file." % filename)
+                return
+            raise
+
+    def getLevelPrefix(self, level):
+        """
+        String prefix which depends on message level.
+        Eg. information returns "[info]".
+        @return: C{str}
+        """
+        if level==Log.LOG_WARN: return "[warn]"
+        if level==Log.LOG_ERROR: return "[err!]"
+        return "[info]"
+
+    def newMessage(self, level, str):
+        """
+        Write a new message : append it in the buffer,
+        display it to the screen (if needed), and write
+        it in the log file (if needed).
+
+        @param level: Message level.
+        @type level: C{int}
+        @param str: Message content.
+        @type str: C{str}
+        """
+
+        if not self.__buffer.has_key(level):
+            self.__buffer[level] = [str]
+        else:
+            self.__buffer[level].append(str)
+        prefix = self.getLevelPrefix(level)            
+        if self.use_print:
+            print "%s %s" % (prefix, str)
+        if self.__file:
+            self.__file.write(u"%s - %s %s\n" \
+                % (time.strftime("%Y-%M-%d %H:%M:%S"),
+                   prefix, str))
+        if self.on_new_message:
+            self.on_new_message (level, prefix, str)
+
+    def info(self, str):
+        """
+        New informative message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_INFO, str)
+
+    def warning(self, str):
+        """
+        New warning message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_WARN, str)
+
+    def error(self, str):
+        """
+        New error message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_ERROR, str)
+
+log = Log()        


Property changes on: haypo/hachoir/branches/hachoir-yield/libhachoir/log.py
___________________________________________________________________
Name: svn:mime-type
   + text/script

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,206 @@
+"""
+MIME type detection using libmagic library.
+
+See also:
+- ftp://ftp.astron.com/pub/file/ (libmagic)
+- http://www.demonseed.net/~jp/code/magic.py (100% Python)
+- http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
+- files in /usr/share/misc/file/* (on Unix/BSD systems)
+"""
+
+import os, sys, stat, re
+from error import warning
+
+_mime_by_ext = {
+    '.gz':  'application/x-gzip',
+    '.ico': 'image/x-ico'
+}
+
+# Regular expression used to split a list of MIME types
+_mime_splitter_regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
+
+def getGuessFunc():
+    """
+    Find a function to guess MIME type of a buffer. Try to load libmagic
+    (python module "magic"), or use internal fallback.
+    @return: Function used to guess MIME type
+    @rtype: C{func}
+    """
+    try:
+        path = os.path.dirname(__file__)
+        sys.path.append(path)
+        import magic
+        func = magic.open(magic.MAGIC_MIME)
+        func.load()
+        return func.buffer
+    except ImportError:
+        warning("Warning: The library libmagic for Python is unavailable. "
+        "Using internal fallback engine.")
+        from fallback.magic import whatis
+        return whatis
+
+guessMime = getGuessFunc()
+
+def getFileMime(realname, filename=None):
+    """ Guess MIME type of a file.
+
+    @parameter realname: Physical filename (used to open the file)
+    @type host: C{str}
+    @parameter filename: Filename used to detect MIME type using its extension
+    @type host: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+    if filename == None:
+        filename = realname
+    mode = os.stat(filename)[stat.ST_MODE]
+    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
+    
+    content = file(filename, "rb").read(4096)
+    return getBufferMime(content, filename)
+
+def getMimeByExt(ext):    
+    """ Guess MIME type of a file using its extension
+
+    @parameter ext: Filename extension (eg. ".zip")
+    @type: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+    return _mime_by_ext.get(ext, None)
+
+def getStreamMime(stream, filename):
+    """ Guess MIME type of a stream using first 4 KB
+
+    @parameter stream: Stream containing data
+    @type: C{Stream}
+    @parameter filename: Filename of the stream source, can be None
+    @type: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+
+    oldpos = stream.tell()
+    stream.seek(0)
+    size = stream.getSize()
+    if 4096 < size:
+        size = 4096
+    data = stream.getN(size)
+    stream.seek(oldpos)
+    return getBufferMime(data, filename)
+
+def getAnotherBufferMime(content):    
+    """ Another method (L{guessMime}) to guess MIME type. This
+    function is used for uncommon MIME types like Gimp picture
+    (image/x-xcf).
+
+    @parameter content: First 4 KB of file/stream content.
+    @type: C{str}
+    @return: MIME type, or None if fails
+    @rtype: C{str}
+    """
+
+    if content[:2] == "\x4d\x4d" and content[6:12] == "\x02\0\x0A\0\0\0":
+        return "image/x-3ds"
+
+    if 2 <= len(content) and ord(content[0]) == 31 and ord(content[1]) == 139:
+        return "application/x-gzip"
+
+    # Text
+    if content[0:4] == "%PDF":
+        return "application/pdf"
+
+    # Pictures
+    if content[0:14] == "gimp xcf file\0":
+        return "image/x-xcf"
+
+    if content[0:2] == "\0\0" \
+    and content[2:4] in ("\x01\0", "\x02\0") \
+    and content[9] == "\0":
+        return "image/x-ico"
+
+    if content[0] == "\x0A" \
+    and content[1] in "\x00\x02\x03\x04\x05" \
+    and content[64] == "\0":
+        return "image/x-pcx"
+
+    # File system        
+    if 4096 <= len(content) \
+    and content[1080:1082] == "\x53\xEF" \
+    and content[1116:1120] == "\x04\x00\x00\x00":
+        return "hachoir/fs-ext2"
+        
+    if 512 <= len(content) \
+    and content[0] in "\xEB\xFA" \
+    and content[510:512] == "\x55\xAA" \
+    and content[446] in "\x00\x80" \
+    and content[446+16*1] in "\x00\x80" \
+    and content[446+16*2] in "\x00\x80" \
+    and content[446+16*3] in "\x00\x80":
+        return "hachoir/master-boot-record"
+    
+    # Worms2 files
+    if content[0:4] == "IMG\x1A":
+        return "hachoir/worms2-image"
+    if content[0:4] == "SPR\x1A":
+        return "hachoir/worms2-sprite"
+    if content[0:4] == "FNT\x1A":
+        return "hachoir/worms2-font"
+    if content[0:4] == "DIR\x1A":
+        return "hachoir/worms2-directory"
+    return None        
+
+def splitMimes(mimes):
+    """ Split flat MIME type string into a list in which each entry has
+    the following format: ["type", {"key1": value1, "key2": value2, ...}]
+
+    Examples:
+    - "text/plain; encoding=latin-1" => [["text/plain", {"encoding": latin-1"}]
+    - "text/plain, text/xml" => [["text/plain", {}],["text/xml", {}]]
+    - "text/plain; charset=ISO-8859-1; format=flowed"
+      => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
+
+    @parameter mimes: Flat MIME type string
+    @type: C{str}
+    @return: MIME type in a list
+    @rtype: C{list}
+    """
+
+    mimes = _mime_splitter_regex.findall(mimes)    
+    
+    mime_list = []
+    for mime in mimes:
+        parts = mime.strip(" ,").split(";")
+        mime = parts[0]
+        parts = [ item.strip() for item in parts[1:] ]
+        values = {}
+        for part in parts:
+            if part != "":
+                split_part = part.split("=", 1)             
+                values[ split_part[0] ] = split_part[1]
+        mime_list.append([mime, values])
+    return mime_list
+
+def getBufferMime(content, filename):
+    """ Main function used to guess the MIME types. It calls L{guessMime},
+    and then L{getAnotherBufferMime} if needed.
+
+    @parameter content: First 4 KB of file/stream content.
+    @type: C{str}
+    @parameter filename: Filename of the file/stream, can be None.
+    @type: C{str}
+    @return: MIME type list (same format than L{splitMimes} result)
+    @rtype: C{str}
+    """
+
+    mimes = guessMime(content)
+    mimes = splitMimes(mimes)
+    if len(mimes) == 0 \
+    or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
+        new_mime = getAnotherBufferMime(content)
+        if new_mime == None and filename != None:
+            ext = os.path.splitext(filename)[1]
+            new_mime = getMimeByExt(ext)
+        if new_mime != None:
+            mimes = ((new_mime, {}),)
+    return mimes

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,470 @@
+"""
+EXT2 (Linux) file system parser.
+
+Sources:
+- EXT2FS source code
+  http://ext2fsd.sourceforge.net/
+- Analysis of the Ext2fs structure
+  http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
+"""
+
+from text_handler import unixTimestamp
+from field import FieldSet, Integer, Enum, String, ParserError
+from tools import humanDuration, getUnixRWX, humanFilesize
+from bits import str2hex
+
+class FieldSetWithSeek(FieldSet):
+    def seekField(self, to):
+        size = to - self._total_field_size 
+        assert 0 <= size
+        if 0 < size:
+            assert (size % 8) == 0
+            return String(self, "raw[]", "string[%u]" % (size / 8))
+        else:
+            return None
+
+class DirectoryEntry(FieldSet):
+    file_type = {
+        1: "Regular",
+        2: "Directory",
+        3: "Char. dev.",
+        4: "Block dev.",
+        5: "Fifo",
+        6: "Socket",
+        7: "Symlink",
+        8: "Max"
+    }
+    endian = "<"
+
+    # TODO: write constructor to set: self._size = self["rec_len"].value * 8 (or something like that)
+    
+    def createFields(self):
+        yield Integer(self, "inode", "uint32", "Inode")
+        yield Integer(self, "rec_len", "uint16", "Record length")
+        name_length = Integer(self, "name_len", "B", "Name length", (FormatChunk, "uint8")).value
+        yield name_length
+        yield Enum(self, "file_type", "uint8", DirectoryEntry.file_type, "File type")
+        yield String(self, "name", "string[%u]" % name_length, "File name")
+        size = self["rec_len"].value-8-name_length 
+        if size != 0:
+            yield String(self, "padding", "string[%u]" % size, "Padding")
+
+#  TODO: Re-enable that, maybe using event 'all fields are read'
+#    def updateParent(self, chunk):        
+#        name = self["name"].strip("\0")
+#        if name != "":
+#            desc = "Directory entry: %s" % name
+#        else:
+#            desc = "Directory entry (empty)"
+#        chunk.description = desc
+#        self.setDescription(desc)
+
+class Inode(FieldSet):
+    name = {
+        1: "list of bad blocks",
+        2: "Root directory",
+        3: "ACL inode",
+        4: "ACL inode",
+        5: "Boot loader",
+        6: "Undelete directory",
+        8: "EXT3 journal"
+    }
+
+    endian = "<"
+    static_size = (68 + 15*4)*8
+
+    def __init__(self, parent, name, stream, index, description=None):
+        self.index = index
+        FieldSet.__init__(self, parent, name, stream, description)
+        
+        if self.description == None:
+            desc = "Inode %s: " % self.index
+
+            if 11 <= self.index:
+                size = humanFilesize(self["size"].value)
+                desc += "file, size=%s, mode=%s" % (size, self["mode"].display)
+            else:
+                if self.index in Inode.name:
+                    desc += Inode.name[self.index]
+                    if self.index == 2:
+                        desc += " (%s)" % getUnixRWX(self["mode"].value)
+                else:
+                    desc += "special"
+                if self["size"].value == 0:
+                    desc += " (unused)"
+            self.description = desc
+
+    def createFields(self):
+        yield Integer(self, "mode", "uint16", "Mode") # {"post": self.postMode}
+        yield Integer(self, "uid", "uint16", "User ID")
+        yield Integer(self, "size", "uint32", "File size (in bytes)")
+        yield Integer(self, "atime", "uint32", "Last access time") # {"post": unixTimestamp}
+        yield Integer(self, "ctime", "uint32", "Creation time") # {"post": unixTimestamp}
+        yield Integer(self, "mtime", "uint32", "Last modification time") # {"post": unixTimestamp}
+        yield Integer(self, "dtime", "uint32", "Delete time") #  {"post": unixTimestamp}
+        yield Integer(self, "gid", "uint16", "Group ID")
+        yield Integer(self, "links_count", "uint16", "Links count")
+        yield Integer(self, "blocks", "uint32", "Number of blocks")
+        yield Integer(self, "flags", "uint32", "Flags")
+        yield Integer(self, "reserved1", "uint32", "Reserved")
+        for i in range(0,15):
+            yield Integer(self, "block[]", "uint32", "Block %i" % i)
+        yield Integer(self, "version", "uint32", "Version")
+        yield Integer(self, "file_acl", "uint32", "File ACL")
+        yield Integer(self, "dir_acl", "uint32", "Directory ACL")
+        yield Integer(self, "faddr", "uint32", "Block where the fragment of the file resides")
+        
+        os = self["/superblock/creator_os"].value
+        if os == SuperBlock.OS_LINUX:
+            yield Integer(self, "frag", "uint8", "Number of fragments in the block")
+            yield Integer(self, "fsize", "uint8", "Fragment size")
+            yield Integer(self, "padding", "uint16", "Padding")
+            yield Integer(self, "uid_high", "uint16", "High 16 bits of user ID")
+            yield Integer(self, "gid_high", "uint16", "High 16 bits of group ID")
+            yield Integer(self, "reserved", "uint32", "Reserved")
+        elif os == SuperBlock.OS_HURD:
+            yield Integer(self, "frag", "uint8", "Number of fragments in the block")
+            yield Integer(self, "fsize", "uint8", "Fragment size")
+            yield Integer(self, "mode_high", "uint16", "High 16 bits of mode")
+            yield Integer(self, "uid_high", "uint16", "High 16 bits of user ID")
+            yield Integer(self, "gid_high", "uint16", "High 16 bits of group ID")
+            yield Integer(self, "author", "uint32", "Author ID (?)")
+        else:
+            yield String(self, "raw", "string[12]", "Reserved")
+
+    def postMode(self, chunk):
+        mode = chunk.value
+        text = ""
+        if mode & 0100000 != 0:
+            text = "regular (%s)" % getUnixRWX(mode)
+        elif mode & 0040000:
+            text = "directory (%s)" % getUnixRWX(mode)
+        elif mode & 0020000:
+            text = "char. dev."
+        elif mode & 0060000:
+            text = "block dev."
+        elif mode & 0010000:
+            text = "fifo"
+        elif mode & 0120000:
+            text = "sym. link"
+        elif mode & 0140000:
+            text = "socket"
+        elif mode == 0:
+            text = "(empty)"
+        else:
+            text = "???"
+        return text
+
+class Bitmap(FieldSet):
+    def __init__(self, parent, name, stream, count, start, description=None):
+        if description != None:
+            description = "%s: %s items" % (description, count)
+        FieldSet.__init__(self, parent, name, stream, description)
+        assert (count % 8) == 0
+        self._size = count
+        self.start = start
+        self.count = count
+
+    def createFields(self):
+        yield String(self, "block_bitmap", "string[%u]" % self._size, "Bitmap")
+
+#    def showFree(self, type="Block"):
+#        data = self["block_bitmap"]
+#        cpt = self.start
+#        for octet in data:
+#            octet = ord(octet)
+#            mask = 1
+#            for i in range(0,8):
+#                if octet & mask == 0:
+#                    print "%s %s free." % (type, cpt)
+#                cpt = cpt + 1
+#                mask = mask << 1
+
+BlockBitmap = Bitmap
+InodeBitmap = Bitmap
+
+class GroupDescriptor(FieldSet):
+    endian = "<"
+    static_size = 32*8
+
+    def __init__(self, parent, name, stream, index, description="Group descriptor"):
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.index = index
+
+        # Set description
+        superblock = self["/superblock"]
+        blocks_per_group = superblock["blocks_per_group"].value
+        start = self.index * blocks_per_group
+        end = start + blocks_per_group 
+        self.description = "Group descriptor: blocks %s-%s" % (start, end)
+
+    def createFields(self):
+        yield Integer(self, "block_bitmap", "uint32", "Points to the blocks bitmap block")
+        yield Integer(self, "inode_bitmap", "uint32", "Points to the inodes bitmap block")
+        yield Integer(self, "inode_table", "uint32", "Points to the inodes table first block")
+        yield Integer(self, "free_blocks_count", "uint16", "Number of free blocks")
+        yield Integer(self, "free_inodes_count", "uint16", "Number of free inodes")
+        yield Integer(self, "used_dirs_count", "uint16", "Number of inodes allocated to directories")
+        yield Integer(self, "padding", "uint16", "Padding")
+        yield String(self, "reserved", "string[12]", "Reserved")
+   
+class SuperBlock(FieldSet):
+    error_handling = {
+        1: "Continue"
+    }
+    OS_LINUX = 0
+    OS_HURD = 1
+    os_name = {
+        0: "Linux",
+        1: "Hurd",
+        2: "Masix",
+        3: "FreeBSD",
+        4: "Lites",
+        5: "WinNT"
+    }
+    state = {
+        1: "Valid",
+        2: "Error"
+    }
+ 
+    static_size = 433*8
+    endian = "<"
+ 
+    def __init__(self, parent, name, stream, description="Super block"):
+        FieldSet.__init__(self, parent, name, stream, description)
+        if self["feature_compat"].value & 4 == 4:
+            type = "ext3"
+        else:
+            type = "ext2"
+        self.description = "Superblock: %s file system" % type
+        self._group_count = None
+
+    def createFields(self):
+        yield Integer(self, "inodes_count", "uint32", "Inodes count")
+        yield Integer(self, "blocks_count", "uint32", "Blocks count")
+        yield Integer(self, "r_blocks_count", "uint32", "Reserved blocks count")
+        yield Integer(self, "free_blocks_count", "uint32", "Free blocks count")
+        yield Integer(self, "free_inodes_count", "uint32", "Free inodes count")
+        yield Integer(self, "first_data_block", "uint32", "First data block")
+        if self["first_data_block"].value != 0:
+            raise ParserError(
+                "Stream doesn't looks like EXT2/EXT3 partition "
+                "(first data block is %s instead of 0)" %
+                self["first_data_block"].value)                
+        yield Integer(self, "log_block_size", "uint32", "Block size")
+        yield Integer(self, "log_frag_size", "uint32", "Fragment size")
+        yield Integer(self, "blocks_per_group", "uint32", "Blocks per group")
+        yield Integer(self, "frags_per_group", "uint32", "Fragments per group")
+        yield Integer(self, "inodes_per_group", "uint32", "Inodes per group")
+        yield Integer(self, "mtime", "uint32", "Mount time") #  {"post": unixTimestamp}
+        yield Integer(self, "wtime", "uint32", "Write time") #  {"post": unixTimestamp}
+        yield Integer(self, "mnt_count", "uint16", "Mount count")
+        yield Integer(self, "max_mnt_count", "int16", "Max mount count")
+        yield String(self, "magic", "string[2]", "Magic number (0x53EF)")
+        if self["magic"].value != "\x53\xEF":
+            raise ParserError(
+                "Stream doesn't looks like EXT2/EXT3 partition "
+                "(invalid magic value: %s instead of %s)" %
+                (str2hex(self["magic"].value), str2hex("\x53\xEF")))
+        yield Enum(self, "state", "uint16", SuperBlock.state, "File system state")
+        yield Enum(self, "errors", "uint16", SuperBlock.error_handling, "Behaviour when detecting errors")
+        yield Integer(self, "minor_rev_level", "uint16", "Minor revision level")
+        yield Integer(self, "last_check", "uint32", "Time of last check") #  {"post": unixTimestamp}
+        yield Integer(self, "check_interval", "uint32", "Maximum time between checks") #  {"post": self.postMaxTime}
+        yield Enum(self, "creator_os", "uint32", SuperBlock.os_name, "Creator OS")        
+        yield Integer(self, "rev_level", "uint32", "Revision level")
+        yield Integer(self, "def_resuid", "uint16", "Default uid for reserved blocks")
+        yield Integer(self, "def_resgid", "uint16", "Default guid for reserverd blocks")
+        yield Integer(self, "first_ino", "uint32", "First non-reserved inode")
+        yield Integer(self, "inode_size", "uint16", "Size of inode structure")
+        if self["inode_size"].value != (68 + 15*4):
+            raise ParserError(
+                "EXT2/EXT3 parser error: inode of size %s are not supported" \
+                % self["inode_size"].value)
+        yield Integer(self, "block_group_nr", "uint16", "Block group # of this superblock")
+        yield Integer(self, "feature_compat", "uint32", "Compatible feature set")
+        yield Integer(self, "feature_incompat", "uint32", "Incompatible feature set")
+        yield Integer(self, "feature_ro_compat", "uint32", "Read-only compatible feature set")
+        yield String(self, "uuid", "string[16]", "128-bit uuid for volume")
+        yield String(self, "volume_name", "string[16]", "Volume name")
+        yield String(self, "last_mounted", "string[64]", "Directory where last mounted")
+        yield Integer(self, "compression", "uint32", "For compression (algorithm usage bitmap)")
+        yield Integer(self, "prealloc_blocks", "uint8", "Number of blocks to try to preallocate")
+        yield Integer(self, "prealloc_dir_blocks", "uint8", "Number to preallocate for directories")
+        yield Integer(self, "padding", "uint16", "Padding")
+        yield String(self, "journal_uuid", "string[16]", "uuid of journal superblock")
+        yield Integer(self, "journal_inum", "uint32", "inode number of journal file")
+        yield Integer(self, "journal_dev", "uint32", "device number of journal file")
+        yield Integer(self, "last_orphan", "uint32", "start of list of inodes to delete")
+        yield String(self, "reserved", "string[197]", "Padding to the end of the block")
+
+    def _getGroupCount(self):
+        if self._group_count == None:
+            # Calculate number of groups
+            blocks_per_group = self["blocks_per_group"].value
+            self._group_count = (self["blocks_count"].value - self["first_data_block"].value + (blocks_per_group - 1)) / blocks_per_group
+        return self._group_count
+    group_count = property(_getGroupCount)        
+ 
+#    def postMaxTime(self, chunk):
+#        return humanDuration(chunk.value * 1000)
+
+class GroupDescriptors(FieldSet):
+    def __init__(self, parent, name, stream, start, count, description=None):
+        if description == None:
+            description = "Group descriptors: %s items" % count
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.start = start
+        self.count = count
+
+    def createFields(self):
+        for index in range(0, self.count):
+            yield GroupDescriptor(self, "group[]", self.stream, index)
+
+    def getGroup(self, index):
+        return self["group[%s]" % (self.start + index)]
+
+class InodeTable(FieldSet):
+    def __init__(self, parent, name, stream, start, count, description=None):
+        if description == None:
+            description = "Inode table: %s inodes" % count
+        FieldSet.__init__(self, parent, name, stream, description)
+        self.start = start
+        self.count = count
+        self._size = self.count * self["/superblock/inode_size"].value * 8
+
+    def createFields(self):
+        for index in range(self.start, self.start+self.count):
+            yield Inode(self, "inode[]", index, description="Inode %s" % index)
+
+    def getInode(self, index):
+        index = index - self.start - 1
+        return self.getChunk("inode[%u]" % index).getFilter()
+
+def testSuperblock(stream):
+    oldpos = stream.tell()
+    stream.seek(56*8, 1)
+    magic = stream.getN(2)    
+    stream.seek(oldpos)
+    return (magic == "\x53\xEF")
+
+class Group(FieldSetWithSeek):
+    def __init__(self, parent, name, stream, index, description=None):
+        if description == None:
+            description = "Group %u" % index
+        FieldSetWithSeek.__init__(self, parent, name, stream, description)
+        self.index = index
+
+# TODO: Re-enable that using event (event like "all fields are read)
+#    def updateParent(self, chunk):
+#        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
+#        if "superblock_copy" in self:
+#            desc += " (with superblock copy)"
+#        self.description = desc 
+
+    def createFields(self):
+        group = self["../group_desc"].getGroup(self.index)
+        superblock = self["/superblock"]
+        block_size = self["/"].block_size
+    
+        # Read block bitmap
+        self.superblock_copy = False
+        if testSuperblock(self.stream):
+            self.superblock_copy = True
+            yield SuperBlock(self, "superblock_copy", self.stream, "Superblock")
+        field = self.seekField(group["block_bitmap"].value * block_size * 8)
+        if field != None:
+            yield field
+            
+        count = superblock["blocks_per_group"].value
+        yield BlockBitmap(self, "block_bitmap[]", self.stream, count, 0, "Block bitmap")
+
+        # Read inode bitmap
+        assert (group["inode_bitmap"].value * block_size * 8) == self._total_field_size 
+        count = superblock["inodes_per_group"].value
+        yield InodeBitmap(self, "inode_bitmap[]", self.stream, count, 1, "Inode bitmap")
+        addr = self._total_field_size % 4096
+        if addr != 0:
+            addr = self._total_field_size + (4096 - addr % 4096) * 8
+            field = self.seekField(addr)
+            if field != None:
+                yield field
+             
+        count = superblock["inodes_per_group"].value
+        inode_index = 1 + self.index * count
+        yield InodeTable(self, "inode_table[]", self.stream, inode_index, count)
+
+        size = (self.index+1) * superblock["blocks_per_group"].value * block_size
+        if self.stream.getSize() < size:
+            size = self.stream.getSize()
+        assert (self._total_field_size % 8) == 0
+        size = size - self._total_field_size / 8
+        yield String(self, "data", "string[%u]" % size, "Data")
+
+class EXT2_FS(FieldSetWithSeek):
+    """
+    Parse an EXT2 or EXT3 partition.
+
+    Attributes:
+       * block_size: Size of a block (in bytes)
+
+    Fields:
+       * superblock: Most important block, store most important informations
+       * ...
+    """
+    mime_types = "hachoir/fs-ext2"
+
+    def __init__(self, parent, name, stream, description="EXT2 file system"):
+        FieldSetWithSeek.__init__(self, parent, name, stream, description)
+
+    def createFields(self):
+        # Skip something (what is stored here? MBR?) 
+        field = self.seekField(1024 * 8) 
+        if field != None:
+            yield field
+        
+        # Read superblock
+        superblock = SuperBlock(self, "superblock", self.stream)
+        yield superblock
+        self.block_size = 1024 << superblock["log_block_size"].value # in bytes
+
+        # Read groups' descriptor
+        field = self.seekField(4096 * 8) 
+        if field != None:
+            yield field
+        groups = GroupDescriptors(self, "group_desc", self.stream, 0, superblock.group_count)
+        yield groups
+
+        # Read groups
+        address = groups.getGroup(0)["block_bitmap"].value * self.block_size * 8
+        field = self.seekField(address)
+        if field != None:
+            yield field
+        for i in range(0, superblock.group_count):
+            yield Group(self, "group[]", self.stream, i)
+
+        # Padding (?)
+#        size = self.stream.getSize()*8 - self._total_field_size
+#        if size != 0:
+#            assert (size % 8) == 0
+#            yield String(self, "end", "string[%u]" % size, "End (raw)")
+
+#    def readDirectory(self, inode):
+#        stream = self.getStream()
+#        block_index = 0
+#        while True:
+#            assert block_index < 12
+#            block = inode["block[%u]" % block_index]
+#            if block == 0:
+#                return
+#            self.seek(block * self.block_size)
+#
+#            total = 0
+#            while total < self.block_size:
+#                entry = self.doRead("directory[]", "Directory entry", (DirectoryEntry,))
+#                if entry["inode"] == 0:
+#                    return
+#                total = total + entry.getSize()
+#            assert total == self.block_size
+#            block_index = block_index + 1
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,41 @@
+"""
+Microsoft Bitmap picture parser.
+- file extension: ".bmp"
+
+Author: Victor Stinner
+Creation: 16 december 2005
+"""
+
+from field import FieldSet, Integer, String, ParserError
+
+class BmpFile(FieldSet):
+    mime_types = ["image/x-ms-bmp", "image/x-bmp"]
+    endian = "<"
+    
+    def createFields(self):
+        yield String(self, "header", "string[2]", "Header (\"BM\")")
+        if self["header"].value != "BM": 
+            raise ParserError(
+                "BMP picture parser error: indentifier is uncorrect")
+        yield Integer(self, "file_size", "uint32", "File size (bytes)")
+        yield Integer(self, "notused", "uint32", "Reseved")
+        yield Integer(self, "data_start", "uint32", "Data start position")
+        yield Integer(self, "header_size", "uint32", "Header size")
+        if self["header_size"].value not in (12, 40):
+            raise ParserError(
+                "BMP picture parser error: header size is uncorrect " \
+                "(%s instead of 12 or 40)" % \
+                self["header_size"].value)
+        yield Integer(self, "width", "uint32", "Width (pixels)")
+        yield Integer(self, "height", "uint32", "Height (pixels)")
+        yield Integer(self, "nb_plan", "uint16", "Number of plan (=1)")
+        yield Integer(self, "bpp", "uint16", "Bits per pixel")
+        if self["header_size"].value == 40:
+            yield Integer(self, "compression", "uint32", "Compression method")
+            yield Integer(self, "image_size", "uint32", "Image size (bytes)")
+            yield Integer(self, "horizontal_dpi", "uint32", "Horizontal DPI")
+            yield Integer(self, "vertical_dpi", "uint32", "Vertical DPI")
+            yield Integer(self, "used_colors", "uint32", "Number of color used")
+            yield Integer(self, "important_color", "uint32", "Number of import colors")
+#        self.addPadding("data", "Image raw data")
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,39 @@
+from field import FieldSet, Integer
+
+class RGB(FieldSet):
+    color_name = {
+        0x000000: "Black",
+        0xFFFFFF: "White"
+    }
+    static_size = 3*8
+    
+    def __init__(self, parent, name, stream, description=None):
+        FieldSet.__init__(self, parent, name, stream, description)
+        if self.description == None:
+            self.description = self.getColorName()
+
+    def createFields(self):
+        yield Integer(self, "red", "uint8", "Red")
+        yield Integer(self, "green", "uint8", "Green")
+        yield Integer(self, "blue", "uint8", "Blue")
+
+    def getColorName(self):
+        value = (self["red"].value << 16) + (self["green"].value << 8) + self["blue"].value
+        if value in RGB.color_name:
+            return "RGB color: "+RGB.color_name[value]
+        else:
+            return "RGB color: #%02X%02X%02X" % \
+                (self["red"].value, self["green"].value, self["blue"].value)
+
+class Palette(FieldSet):
+    def __init__(self, parent, name, nb_colors, description=None):
+        self.nb_colors = nb_colors
+        size = self.nb_colors * RGB.static_size
+        if description == None:
+            description = "Palette of %u RGB colors" % self.nb_colors
+        FieldSet.__init__(self, parent, name, parent.stream, size=size, description=description)
+
+    def createFields(self):
+        for i in range(0, self.nb_colors):
+            yield RGB(self, "color[]", self.stream)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,42 @@
+"""
+PCX picture filter.
+"""
+
+from field import FieldSet, Integer, String
+from common import Palette
+
+class PcxFile(FieldSet):
+    endian = "<"
+    mime_types = "image/x-pcx"
+    compression_name = { 1: "RLE" }
+
+    def createFields(self):
+        yield Integer(self, "id", "uint8", "PCX identifier (10)")
+        if self["id"].value != 10:
+            raise ParserError("PCX parser: wrong identifier (%u instead of 10)" \
+                % self["id"].value)
+        yield Integer(self, "version", "uint8", "PCX version")
+        yield Integer(self, "compression", "uint8", "Compression") # (EnumChunk, , PCX_File.compression_name)
+        yield Integer(self, "bpp", "uint8", "Bits / pixel")
+        yield Integer(self, "xmin", "uint16", "Minimum X")
+        yield Integer(self, "ymin", "uint16", "Minimum Y")
+        yield Integer(self, "xmax", "uint16", "Width minus one") # value + 1
+        yield Integer(self, "ymax", "uint16", "Height minus one") # value + 1
+        yield Integer(self, "horiz_dpi", "uint16", "Horizontal DPI")
+        yield Integer(self, "vert_dpi", "uint16", "Vertical DPI")
+        yield Palette(self, "palette_4bits", 16, "Palette (4 bits)")
+        yield Integer(self, "reserved", "uint8", "Reserved")
+        yield Integer(self, "nb_color_plan", "uint8", "Number of color plans")
+        yield Integer(self, "bytes_per_line", "uint16", "Bytes per line")
+        yield Integer(self, "color_mode", "uint16", "Color mode")
+        yield String(self, "reserved2", "string[58]", "Reserved")
+
+        size = self.stream.getSize() - self.stream.tell()
+        has_palette = (self["bpp"].value == 8)
+        if has_palette:
+            size -= 256*3*8            
+        yield String(self, "data", "string[%u]" % size, "Image data")
+
+        if has_palette:
+            yield Palette(self, "palette_8bits", 256, "Palette (8 bit)")
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,98 @@
+from field import FieldSet, Integer, String, IntegerHex, Bit, Bits, ParserError
+from common import RGB
+from bits import str2hex
+
+class HeaderFlags(FieldSet):
+    def createFields(self):
+        yield Bit(self, "palette", "Palette used?")
+        yield Bit(self, "color", "Color used?")
+        yield Bit(self, "alpha", "Alpha channel used?")
+        yield Bits(self, "reserved", 5, "(reserved)")
+
+class Header(FieldSet):
+    def createFields(self):
+        yield Integer(self, "width", "uint32", "Width (pixels)")
+        yield Integer(self, "height", "uint32", "Height (pixels)")
+        yield Integer(self, "bpp", "uint8", "Bits per pixel")
+        yield HeaderFlags(self, "color_type", self.stream, "Color type")
+        yield Integer(self, "compression", "uint8", "Compression method")
+        yield Integer(self, "filter", "uint8", "Filter method")
+        yield Integer(self, "interlace", "uint8", "Interlace method")
+
+    def updateParent(self, chunk):
+        chunk.description = "Header: %ux%u pixels and %u bits/pixel" \
+            % (self["width"], self["height"], self["bpp"])
+
+class Palette(FieldSet):
+    def __init__(self, parent, name, stream, description=None):
+        size = parent["size"].value
+        if (size % 3) != 0:
+            raise ParserError("Palette have invalid size (%s), should be 3*n." % size)
+        self.nb_colors = size / 3
+        if description == None:
+            description = "Palette: %u colors" % self.nb_colors
+        FieldSet.__init__(self, parent, name, stream, description)
+
+    def createFields(self):
+        for i in range(self.nb_colors):
+            yield RGB(self, "color[]", self.stream)
+
+class Chunk(FieldSet):
+    handler = {
+#        "tIME": Time,
+#        "pHYs": Physical,
+        "IHDR": Header,
+        "PLTE": Palette,
+#        "gAMA": Gamma,
+#        "tEXt": Text
+    }
+    name_by_type = {
+        "tIME": ("time", "Time"),
+        "pHYs": ("physical", "Physical"),
+        "IHDR": ("header", "Header"),
+        "PLTE": ("palette", "Palette"),
+        "gAMA": ("gamma", "Gamma"),
+        "IDAT": ("data[]", "Image data"),
+        "IEND": ("end", "End"),
+        "tEXt": ("text", "Text")
+    }
+    
+    def __init__(self, parent, name, stream, description=None):
+        FieldSet.__init__(self, parent, name, stream, description)
+        self._size = (self["size"].value + 3*4) * 8
+
+        type = self["type"].value
+        if type in self.name_by_type:
+            name = self.name_by_type[type]
+            self._name = name[0]
+
+    def createFields(self):
+        yield Integer(self, "size", "uint32", "Size")
+        yield String(self, "type", "string[4]", "Type")
+
+        type = self["type"].value
+        if type in self.handler:
+            size = self["size"]
+#            oldpos = self._stream.tell()
+#            sub = stream.createLimited(size=size)
+            cls = self.handler[type]
+            yield cls(self, "content", self.stream)
+#            assert stream.tell() == (oldpos + size) 
+        else:
+            yield String(self, "content", "string[%u]" % self["size"].value, "Data")
+        yield IntegerHex(self, "crc32", "uint32", "CRC32")
+
+class PngFile(FieldSet):
+    mime_types = ["image/png", "image/x-png"]
+
+    def createFields(self):
+        yield String(self, "id", "string[8]", "PNG identifier") 
+        if self["id"].value != "\x89PNG\r\n\x1A\n":
+            raise ParserError("Png parser: file identifier looks wrong (%s instead of %s)" % \
+                (str2hex(self["id"].value), str2hex("\x89PNG\r\n\x1A\n")))
+        while True:
+            field = Chunk(self, "chunks[]", self.stream)
+            yield field
+            if field.name == "end":
+                break
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/plugin.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,82 @@
+import re, os
+from stat import S_ISDIR, ST_MODE
+from mime import getFileMime, getStreamMime
+from error import warning
+
+regex_plugin_filename = re.compile(r"^([a-z0-9_]+)\.py$")
+
+def loadPluginFromFile(module_path, loaded):
+    try:
+        module = __import__(module_path)
+        for get in module_path.split(".")[1:]:
+            module = getattr(module, get)
+    except Exception, msg:
+        warning("Error while loading the plugin \"%s\": %s" \
+            % (module_path, msg))
+        return
+    for attr in module.__dict__:
+        item = getattr(module, attr)
+        if hasattr(item, "mime_types"):
+            registerPlugin(item, item.mime_types)
+            loaded.append(module_path)
+
+def loadPlugins(dir, module_path="libhachoir.parser", loaded=[]):
+    """
+    Load all plugings from directory dir.
+
+    Do not set module_path or loaded, they are used internally.
+    """
+    if module_path == None:
+        module_path = os.path.basename(dir)
+    for file in os.listdir(dir):
+        fullpath = os.path.join(dir, file)
+        if S_ISDIR(os.stat(fullpath)[ST_MODE]):
+            loadPlugins(fullpath, module_path+"."+file, loaded)
+        else:
+            m = regex_plugin_filename.match(file)
+            if m != None and m.group(1) != "__init__":
+                path = module_path + "." + m.group(1)
+                loadPluginFromFile(path, loaded)
+    return loaded                    
+
+def guessPlugin(stream, filename, default=None):
+    return getPluginByStream(stream, filename, default)
+
+def getPluginByMime(mimes, default=None):
+    global hachoir_plugins
+    plugins = []
+    for mime in mimes:
+        mime = mime[0]
+        if mime in hachoir_plugins:
+            for plugin in hachoir_plugins[mime]:
+                if plugin not in plugins:
+                    plugins.append(plugin)
+    if len(plugins)==0:
+        return default
+    if 1<len(plugins):
+        plist = []
+        for plugin in plugins:
+            plist.append(plugin.__name__)
+        plist = ", ".join(plist)
+        warning("More than one plugin have same MIME:\n%s" % plist)
+    return plugins[0]
+    
+def getPluginByStream(stream, filename, default=None):
+    mime = getStreamMime(stream, filename)
+    return getPluginByMime(mime, default)
+
+def getPluginByFile(filename, realname=None, default=None):
+    mime = getFileMime(filename, realname)
+    return getPluginByMime(mime, default)
+    
+def registerPlugin(filter_class, mimes):
+    global hachoir_plugins
+    if isinstance(mimes, str):
+        mimes = [mimes]
+    for mime in mimes:
+        if mime in hachoir_plugins:
+            hachoir_plugins[mime].append(filter_class)
+        else:
+            hachoir_plugins[mime] = [filter_class]
+
+hachoir_plugins = {} 

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1 @@
+from stream import Stream

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/error.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,3 @@
+class StreamError(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/file.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1,89 @@
+import os
+from error import StreamError
+from stream import Stream
+#from config import config
+
+def getFileSize(stream):
+    """ Get file size in bits """
+    oldpos = stream.tell()
+    stream.seek(0,2)
+    size = stream.tell() * 8
+    stream.seek(oldpos)
+    return size
+
+class FileStream(Stream):
+    def __init__(self, file, size, filename=None, copy=None):
+        Stream.__init__(self, filename)
+        self._file = file 
+        if copy != None:
+            self._size = copy._size
+        else:
+            self._size = size
+            self._file.seek(0)
+            if self._size == 0:
+                raise Exception("Error: file %s is empty!" % filename)
+        
+    def _getSize(self):
+        """ Size of the stream in bits """
+        return self._size
+    size = property(_getSize)
+
+    def getBits(self, address, nbits, big_endian=False):
+        data = self._getRawBits(address, nbits)        
+        if (address % 8) != 0 or (nbits % 8) != 0:
+            mask = (1 << nbits) - 1
+            shift = address & 7 
+        else:
+            shift = 0
+            mask = None
+        value = 0
+        if not big_endian:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+                shift = nbits-shift
+            else:
+                shift = nbits-8
+                if shift < 0:
+                    shift += 8
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift -= 8
+        else:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift += 8
+        if mask != None:
+            value = value & mask
+        return value
+
+    def getBytes(self, address, nbytes):
+        if address % 8 != 0:
+            data = self._getRawBits(address, nbytes*8)
+            nbits = address % 8
+            shift1 = nbits
+            shift2 = 8 - nbits
+            mask = (1 << nbits) - 1
+            newdata = ""
+            for i in range(0, len(data)-1):
+                byte1 = ord(data[i])
+                byte2 = ord(data[i+1])
+                new = chr((byte1 >> shift1) + ((byte2 & mask) << shift2))
+                newdata += new 
+            data = newdata
+        else:
+            data = self._getRawBits(address, nbytes*8)
+        return data
+    
+    def _getRawBits(self, address, nbits):
+        nbytes = (nbits + (address & 7) + 7) / 8
+        self.seek(address / 8)
+        return self.getN(nbytes)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/stream.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -0,0 +1 @@
+

Deleted: haypo/hachoir/branches/hachoir-yield/log.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/log.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/log.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,93 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-
-import time
-
-class Log:
-    LOG_INFO   = 0
-    LOG_WARN   = 1
-    LOG_ERROR  = 2
-
-    def __init__(self):
-        self.__buffer = {}
-        self.__file = None
-        self.use_print = True
-        self.on_new_message = None # (level, prefix, text)
-
-    def setFilename(self, filename):
-        """
-        Use a file to store all messages. The
-        UTF-8 encoding will be used. Write an informative
-        message if the file can't be created.
-
-        @param filename: C{L{string}}
-        """
-
-        try:
-            import codecs
-            self.__file = codecs.open(filename, "w", "utf-8")
-        except IOError, errno:
-            if errno[0] == 2:
-                self.__file = None
-                self.info("Log.setFilename(%s) fails : no such file." % filename)
-                return
-            raise
-
-    def getLevelPrefix(self, level):
-        """
-        String prefix which depends on message level.
-        Eg. information returns "[info]".
-        @return: C{str}
-        """
-        if level==Log.LOG_WARN: return "[warn]"
-        if level==Log.LOG_ERROR: return "[err!]"
-        return "[info]"
-
-    def newMessage(self, level, str):
-        """
-        Write a new message : append it in the buffer,
-        display it to the screen (if needed), and write
-        it in the log file (if needed).
-
-        @param level: Message level.
-        @type level: C{int}
-        @param str: Message content.
-        @type str: C{str}
-        """
-
-        if not self.__buffer.has_key(level):
-            self.__buffer[level] = [str]
-        else:
-            self.__buffer[level].append(str)
-        prefix = self.getLevelPrefix(level)            
-        if self.use_print:
-            print "%s %s" % (prefix, str)
-        if self.__file:
-            self.__file.write(u"%s - %s %s\n" \
-                % (time.strftime("%Y-%M-%d %H:%M:%S"),
-                   prefix, str))
-        if self.on_new_message:
-            self.on_new_message (level, prefix, str)
-
-    def info(self, str):
-        """
-        New informative message.
-        @type str: C{str}
-        """
-        self.newMessage(Log.LOG_INFO, str)
-
-    def warning(self, str):
-        """
-        New warning message.
-        @type str: C{str}
-        """
-        self.newMessage(Log.LOG_WARN, str)
-
-    def error(self, str):
-        """
-        New error message.
-        @type str: C{str}
-        """
-        self.newMessage(Log.LOG_ERROR, str)
-
-log = Log()        

Modified: haypo/hachoir/branches/hachoir-yield/metadata.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/metadata.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,6 +1,6 @@
-from file.image.png import PngFile
-from file.image.pcx import PcxFile
-from file.image.bmp import BmpFile
+from libhachoir.parser.image.png import PngFile
+from libhachoir.parser.image.pcx import PcxFile
+from libhachoir.parser.image.bmp import BmpFile
 
 class MetaData:
     def __str__(self):

Deleted: haypo/hachoir/branches/hachoir-yield/mime.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/mime.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/mime.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,206 +0,0 @@
-"""
-MIME type detection using libmagic library.
-
-See also:
-- ftp://ftp.astron.com/pub/file/ (libmagic)
-- http://www.demonseed.net/~jp/code/magic.py (100% Python)
-- http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
-- files in /usr/share/misc/file/* (on Unix/BSD systems)
-"""
-
-import os, sys, stat, re
-from error import warning
-
-_mime_by_ext = {
-    '.gz':  'application/x-gzip',
-    '.ico': 'image/x-ico'
-}
-
-# Regular expression used to split a list of MIME types
-_mime_splitter_regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
-
-def getGuessFunc():
-    """
-    Find a function to guess MIME type of a buffer. Try to load libmagic
-    (python module "magic"), or use internal fallback.
-    @return: Function used to guess MIME type
-    @rtype: C{func}
-    """
-    try:
-        path = os.path.dirname(__file__)
-        sys.path.append(path)
-        import magic
-        func = magic.open(magic.MAGIC_MIME)
-        func.load()
-        return func.buffer
-    except ImportError:
-        warning("Warning: The library libmagic for Python is unavailable. "
-        "Using internal fallback engine.")
-        from fallback.magic import whatis
-        return whatis
-
-guessMime = getGuessFunc()
-
-def getFileMime(realname, filename=None):
-    """ Guess MIME type of a file.
-
-    @parameter realname: Physical filename (used to open the file)
-    @type host: C{str}
-    @parameter filename: Filename used to detect MIME type using its extension
-    @type host: C{str}
-    @return: MIME type, or None if fails
-    @rtype: C{str}
-    """
-    if filename == None:
-        filename = realname
-    mode = os.stat(filename)[stat.ST_MODE]
-    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
-    
-    content = file(filename, "rb").read(4096)
-    return getBufferMime(content, filename)
-
-def getMimeByExt(ext):    
-    """ Guess MIME type of a file using its extension
-
-    @parameter ext: Filename extension (eg. ".zip")
-    @type: C{str}
-    @return: MIME type, or None if fails
-    @rtype: C{str}
-    """
-    return _mime_by_ext.get(ext, None)
-
-def getStreamMime(stream, filename):
-    """ Guess MIME type of a stream using first 4 KB
-
-    @parameter stream: Stream containing data
-    @type: C{Stream}
-    @parameter filename: Filename of the stream source, can be None
-    @type: C{str}
-    @return: MIME type, or None if fails
-    @rtype: C{str}
-    """
-
-    oldpos = stream.tell()
-    stream.seek(0)
-    size = stream.getSize()
-    if 4096 < size:
-        size = 4096
-    data = stream.getN(size)
-    stream.seek(oldpos)
-    return getBufferMime(data, filename)
-
-def getAnotherBufferMime(content):    
-    """ Another method (L{guessMime}) to guess MIME type. This
-    function is used for uncommon MIME types like Gimp picture
-    (image/x-xcf).
-
-    @parameter content: First 4 KB of file/stream content.
-    @type: C{str}
-    @return: MIME type, or None if fails
-    @rtype: C{str}
-    """
-
-    if content[:2] == "\x4d\x4d" and content[6:12] == "\x02\0\x0A\0\0\0":
-        return "image/x-3ds"
-
-    if 2 <= len(content) and ord(content[0]) == 31 and ord(content[1]) == 139:
-        return "application/x-gzip"
-
-    # Text
-    if content[0:4] == "%PDF":
-        return "application/pdf"
-
-    # Pictures
-    if content[0:14] == "gimp xcf file\0":
-        return "image/x-xcf"
-
-    if content[0:2] == "\0\0" \
-    and content[2:4] in ("\x01\0", "\x02\0") \
-    and content[9] == "\0":
-        return "image/x-ico"
-
-    if content[0] == "\x0A" \
-    and content[1] in "\x00\x02\x03\x04\x05" \
-    and content[64] == "\0":
-        return "image/x-pcx"
-
-    # File system        
-    if 4096 <= len(content) \
-    and content[1080:1082] == "\x53\xEF" \
-    and content[1116:1120] == "\x04\x00\x00\x00":
-        return "hachoir/fs-ext2"
-        
-    if 512 <= len(content) \
-    and content[0] in "\xEB\xFA" \
-    and content[510:512] == "\x55\xAA" \
-    and content[446] in "\x00\x80" \
-    and content[446+16*1] in "\x00\x80" \
-    and content[446+16*2] in "\x00\x80" \
-    and content[446+16*3] in "\x00\x80":
-        return "hachoir/master-boot-record"
-    
-    # Worms2 files
-    if content[0:4] == "IMG\x1A":
-        return "hachoir/worms2-image"
-    if content[0:4] == "SPR\x1A":
-        return "hachoir/worms2-sprite"
-    if content[0:4] == "FNT\x1A":
-        return "hachoir/worms2-font"
-    if content[0:4] == "DIR\x1A":
-        return "hachoir/worms2-directory"
-    return None        
-
-def splitMimes(mimes):
-    """ Split flat MIME type string into a list in which each entry has
-    the following format: ["type", {"key1": value1, "key2": value2, ...}]
-
-    Examples:
-    - "text/plain; encoding=latin-1" => [["text/plain", {"encoding": latin-1"}]
-    - "text/plain, text/xml" => [["text/plain", {}],["text/xml", {}]]
-    - "text/plain; charset=ISO-8859-1; format=flowed"
-      => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
-
-    @parameter mimes: Flat MIME type string
-    @type: C{str}
-    @return: MIME type in a list
-    @rtype: C{list}
-    """
-
-    mimes = _mime_splitter_regex.findall(mimes)    
-    
-    mime_list = []
-    for mime in mimes:
-        parts = mime.strip(" ,").split(";")
-        mime = parts[0]
-        parts = [ item.strip() for item in parts[1:] ]
-        values = {}
-        for part in parts:
-            if part != "":
-                split_part = part.split("=", 1)             
-                values[ split_part[0] ] = split_part[1]
-        mime_list.append([mime, values])
-    return mime_list
-
-def getBufferMime(content, filename):
-    """ Main function used to guess the MIME types. It calls L{guessMime},
-    and then L{getAnotherBufferMime} if needed.
-
-    @parameter content: First 4 KB of file/stream content.
-    @type: C{str}
-    @parameter filename: Filename of the file/stream, can be None.
-    @type: C{str}
-    @return: MIME type list (same format than L{splitMimes} result)
-    @rtype: C{str}
-    """
-
-    mimes = guessMime(content)
-    mimes = splitMimes(mimes)
-    if len(mimes) == 0 \
-    or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
-        new_mime = getAnotherBufferMime(content)
-        if new_mime == None and filename != None:
-            ext = os.path.splitext(filename)[1]
-            new_mime = getMimeByExt(ext)
-        if new_mime != None:
-            mimes = ((new_mime, {}),)
-    return mimes

Deleted: haypo/hachoir/branches/hachoir-yield/plugin.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/plugin.py	2006-03-04 00:26:16 UTC (rev 428)
+++ haypo/hachoir/branches/hachoir-yield/plugin.py	2006-03-04 00:26:40 UTC (rev 429)
@@ -1,82 +0,0 @@
-import re, os
-from stat import S_ISDIR, ST_MODE
-from mime import getFileMime, getStreamMime
-from error import warning
-
-regex_plugin_filename = re.compile(r"^([a-z0-9_]+)\.py$")
-
-def loadPluginFromFile(module_path, loaded):
-    try:
-        module = __import__(module_path)
-        for get in module_path.split(".")[1:]:
-            module = getattr(module, get)
-    except Exception, msg:
-        warning("Error while loading the plugin \"%s\": %s" \
-            % (module_path, msg))
-        return
-    for attr in module.__dict__:
-        item = getattr(module, attr)
-        if hasattr(item, "mime_types"):
-            registerPlugin(item, item.mime_types)
-            loaded.append(module_path)
-
-def loadPlugins(dir, module_path=None, loaded=[]):
-    """
-    Load all plugings from directory dir.
-
-    Do not set module_path or loaded, they are used internally.
-    """
-    if module_path == None:
-        module_path = os.path.basename(dir)
-    for file in os.listdir(dir):
-        fullpath = os.path.join(dir, file)
-        if S_ISDIR(os.stat(fullpath)[ST_MODE]):
-            loadPlugins(fullpath, module_path+"."+file, loaded)
-        else:
-            m = regex_plugin_filename.match(file)
-            if m != None and m.group(1) != "__init__":
-                path = module_path + "." + m.group(1)
-                loadPluginFromFile(path, loaded)
-    return loaded                    
-
-def guessPlugin(stream, filename, default=None):
-    return getPluginByStream(stream, filename, default)
-
-def getPluginByMime(mimes, default=None):
-    global hachoir_plugins
-    plugins = []
-    for mime in mimes:
-        mime = mime[0]
-        if mime in hachoir_plugins:
-            for plugin in hachoir_plugins[mime]:
-                if plugin not in plugins:
-                    plugins.append(plugin)
-    if len(plugins)==0:
-        return default
-    if 1<len(plugins):
-        plist = []
-        for plugin in plugins:
-            plist.append(plugin.__name__)
-        plist = ", ".join(plist)
-        warning("More than one plugin have same MIME:\n%s" % plist)
-    return plugins[0]
-    
-def getPluginByStream(stream, filename, default=None):
-    mime = getStreamMime(stream, filename)
-    return getPluginByMime(mime, default)
-
-def getPluginByFile(filename, realname=None, default=None):
-    mime = getFileMime(filename, realname)
-    return getPluginByMime(mime, default)
-    
-def registerPlugin(filter_class, mimes):
-    global hachoir_plugins
-    if isinstance(mimes, str):
-        mimes = [mimes]
-    for mime in mimes:
-        if mime in hachoir_plugins:
-            hachoir_plugins[mime].append(filter_class)
-        else:
-            hachoir_plugins[mime] = [filter_class]
-
-hachoir_plugins = {} 



From haypo at berlios.de  Mon Mar  6 19:28:10 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 6 Mar 2006 19:28:10 +0100
Subject: [Happyboom-svn] r440 - haypo/hachoir/branches/hachoir-yield
Message-ID: <200603061828.k26ISAlN031752@sheep.berlios.de>

Author: haypo
Date: 2006-03-06 19:28:05 +0100 (Mon, 06 Mar 2006)
New Revision: 440

Modified:
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
Fix displayFieldSet(): automaticly detect if the size/address has bit precision


Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-04 02:51:10 UTC (rev 439)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-06 18:28:05 UTC (rev 440)
@@ -1,11 +1,11 @@
 def displayFieldSet(field_set, max_depth=2, depth=0, options={}):
     display_parent_addr = options.get("parent-addr", False)
     display_parent_size = options.get("parent-size", True)
-    display_bits = options.get("bit-addr", False)
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     text = "%s--- %s ---" % (indent, field_set.name) 
     if display_parent_addr or display_parent_size:
+        display_bits = (addr % 8) != 0 or (field_set.size % 8) != 0 
         info = []
         if display_bits:
             if display_parent_addr:
@@ -24,6 +24,7 @@
     if max_depth == None or max_depth < 0 or depth < max_depth:
         for field in field_set:
             if not field.is_field_set:
+                display_bits = (field.address % 8) != 0 or (field.size % 8) != 0 
                 text = indent
                 if display_bits:
                     text += "%u.%u" % (field.address/8, field.address%8)



From haypo at berlios.de  Wed Mar  8 21:00:00 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 8 Mar 2006 21:00:00 +0100
Subject: [Happyboom-svn] r441 - haypo/hachoir/trunk/plugins
Message-ID: <200603082000.k28K00Po014658@sheep.berlios.de>

Author: haypo
Date: 2006-03-08 20:59:42 +0100 (Wed, 08 Mar 2006)
New Revision: 441

Modified:
   haypo/hachoir/trunk/plugins/id3.py
   haypo/hachoir/trunk/plugins/tar.py
Log:
 * Fix TAR parser: fix FileEntry.isEmpty() for links
 * ID3 support AlbumWrap extension


Modified: haypo/hachoir/trunk/plugins/id3.py
===================================================================
--- haypo/hachoir/trunk/plugins/id3.py	2006-03-06 18:28:05 UTC (rev 440)
+++ haypo/hachoir/trunk/plugins/id3.py	2006-03-08 19:59:42 UTC (rev 441)
@@ -111,6 +111,10 @@
             if chunk["size"] == 0:
                 break
 
+        # Check AlbumWrap
+        if True:
+            self.readAlbumWrap(stream)
+
         # Search first byte of the MPEG file                
         size = stream.searchLength("\xFF", False)
         if size == -1:
@@ -118,3 +122,25 @@
             size = end - stream.tell()
         if 0 < size:
             self.read("padding", "Padding", (FormatChunk, "string[%u]" % size))
+
+    def readAlbumWrap(self, stream):            
+        ofst = 1325 
+        oldpos = stream.tell()
+        if ofst < ofst:
+            return
+        stream.seek(ofst)
+        count = stream.getN(12)
+        count = count.rstrip(" ")
+        stream.seek(oldpos)
+        if len(count.strip("\0")) == 0:
+            return
+        try:
+            count = int(count)
+        except ValueError:
+            return
+        size = ofst - oldpos
+        self.read("padding", "Padding", (FormatChunk, "string[%u]" % size))
+        self.read("count", "File count", (FormatChunk, "string[12]"))
+        for index in range(count):
+            self.read("filename[]", "Filename %i" % index, (FormatChunk, "string[501]"))
+

Modified: haypo/hachoir/trunk/plugins/tar.py
===================================================================
--- haypo/hachoir/trunk/plugins/tar.py	2006-03-06 18:28:05 UTC (rev 440)
+++ haypo/hachoir/trunk/plugins/tar.py	2006-03-08 19:59:42 UTC (rev 441)
@@ -49,6 +49,7 @@
         self.read("padding", "Padding (zero)", (FormatChunk, "string[167]"))
 
         self.name = self["name"].strip("\0")
+        self.link_name = self["lname"].strip("\0")
         self.size = self.octal2int(self["size"])
         if self["type"] in (0, ord("0")) and self.size != 0:
             substream = stream.createSub(stream.tell(), self.size)
@@ -87,7 +88,7 @@
         return str(datetime.fromtimestamp(value))
 
     def isEmpty(self):
-        return self.name == ""
+        return (self.name == "" and self.link_name == "")
 
     def octal2int(self, str):
         str = str.strip(" \0")



From haypo at berlios.de  Sun Mar 12 21:02:19 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:02:19 +0100
Subject: [Happyboom-svn] r442 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/stream branches/hachoir-yield/unit_test
Message-ID: <200603122002.k2CK2JYn022353@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:02:15 +0100 (Sun, 12 Mar 2006)
New Revision: 442

Added:
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py
Removed:
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/run_unit_test.py
   haypo/hachoir/branches/hachoir-yield/test_doc.py
   haypo/hachoir/branches/hachoir-yield/unit_test/__init__.py
Log:
 r56 at haypopc:  haypo | 2006-03-04 05:23:32 +0100
  * Move stream.py to stream/input.py
  * Create output streams
  * Write unit test for output stream



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:54
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:56

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py	2006-03-08 19:59:42 UTC (rev 441)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py	2006-03-12 20:02:15 UTC (rev 442)
@@ -0,0 +1,139 @@
+from cStringIO import StringIO
+
+class InputStreamError(Exception):
+    pass
+
+def FileInputStream(filename):
+    input = open(filename, 'r')
+    input.seek(0, 2)
+    size = input.tell() * 8
+    input.seek(0)
+    return InputStream(input, filename=filename, size=size)
+
+def StringInputStream(content):
+    input = StringIO(content)
+    return InputStream(input, filename=None, size=len(content)*8)
+
+class InputStream:
+    def __init__(self, input, filename=None, size=None):
+        self.filename = filename
+        if size == 0:
+            raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
+        self._size = size
+
+        # TODO: Doesn't support computation of last byte address with bit
+        # address
+        assert (self._size % 8) == 0
+        self._last_byte_address = self._size / 8 - 1
+        self._input = input 
+        
+    def _getSize(self):
+        return self._size
+    size = property(_getSize, doc="Size of the stream in bits")
+
+    def getBits(self, address, nbits, big_endian=False):
+        data = self._getRawBits(address, nbits)        
+        if (address % 8) != 0 or (nbits % 8) != 0:
+            mask = (1 << nbits) - 1
+            shift = address & 7 
+        else:
+            shift = 0
+            mask = None
+        value = 0
+        if not big_endian:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+                shift = nbits-shift
+            else:
+                shift = nbits-8
+                if shift < 0:
+                    shift += 8
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift -= 8
+        else:
+            if shift != 0:
+                byte = ord(data[0])
+                value += (byte >> shift)
+                data = data[1:]
+            for character in data:
+                byte = ord(character)
+                value += (byte << shift) 
+                shift += 8
+        if mask != None:
+            value = value & mask
+        return value
+
+    def getBytes(self, address, nbytes):
+        if address % 8 != 0:
+            data = self._getRawBits(address, nbytes*8)
+            nbits = address % 8
+            shift1 = nbits
+            shift2 = 8 - nbits
+            mask = (1 << nbits) - 1
+            newdata = ""
+            for i in range(0, len(data)-1):
+                byte1 = ord(data[i])
+                byte2 = ord(data[i+1])
+                new = chr((byte1 >> shift1) + ((byte2 & mask) << shift2))
+                newdata += new 
+            data = newdata
+        else:
+            data = self._getRawBits(address, nbytes*8)
+        return data
+    
+    def _getRawBits(self, address, nb_bits):
+        nb_bytes = (nb_bits + (address & 7) + 7) / 8
+        self._input.seek(address / 8)
+        data = self._input.read(nb_bytes)
+        if len(data) != nb_bytes:
+            raise InputStreamError(
+                "Can't read %u bytes at address %u (got %u bytes)!" % \
+                (nb_bytes, address/8, len(data)))
+        return data
+
+    def searchBytes(self, needle, start_address=0, end_address=None):
+        """
+        Search some bytes between start_address and end_address
+
+        Returns the address of the bytes if founded, None else
+        """
+
+        if end_address == None:
+            end_address = self._last_byte_address * 8
+        if end_address < start_address:
+            return None
+        
+        # TODO: Doesn't suppport bit address yet :-(
+        assert (start_address % 8) == 0
+        assert (end_address % 8) == 0
+
+        size = 2048 
+        if size <= len(needle):
+            raise InputStreamError("Search string too big.")
+        doublesize = size * 2
+
+        address = start_address 
+        max = end_address - start_address + 1
+        if max<doublesize:
+            doublesize = max/8 
+            size = 0 
+        buffer = self.getBytes(address, doublesize)
+
+        new_address = address + size
+        while len(buffer) != 0:
+            found = buffer.find(needle)
+            if found != -1:
+                return address + found*8
+            address = new_address
+            if end_address < address + size:
+                size = end_address - address
+            if size == 0:
+                break
+            buffer = buffer[size:] + self.getBytes(address, size)
+            new_address = address + size 
+        return None
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py	2006-03-08 19:59:42 UTC (rev 441)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py	2006-03-12 20:02:15 UTC (rev 442)
@@ -0,0 +1,98 @@
+from cStringIO import StringIO
+from libhachoir.bits import countBits
+
+def FileOutputStream(filename, big_endian=True):
+    output = open(filename, 'w')
+    return OutputStream(output, big_endian=big_endian, filename=filename)
+
+class OutputStream(object):
+    def __init__(self, output, big_endian=True, filename=None):
+        self._output = output
+        self._filename = filename
+        self._bit_pos = 0
+        self._byte = 0
+        self._big_endian = big_endian
+
+    def _getFilename(self):
+        return self._filename
+    filename = property(_getFilename)
+
+    def writeBit(self, state):
+        if self._bit_pos == 7:
+            self._bit_pos = 0
+            if state:
+                if self._big_endian:
+                    self._byte |= 1
+                else:
+                    self._byte |= 128
+            self._output.write(chr(self._byte))
+            self._byte = 0
+        else:
+            if state:
+                if self._big_endian:
+                    self._byte |= (1 << (7-self._bit_pos))
+                else:
+                    self._byte |= (1 << self._bit_pos)
+            self._bit_pos += 1
+
+    def writeBits(self, count, value):
+        assert countBits(value) <= count
+
+        # Feed bits to align to byte address
+        if self._bit_pos != 0:
+            n = 8 - self._bit_pos
+            if n <= count:
+                count -= n
+                if self._big_endian:
+                    self._byte |= (value >> count)
+                    value &= ((1 << count) - 1)
+                else:
+                    self._byte |= (value & ((1 << n)-1)) << self._bit_pos
+                    value >>= n
+                self._output.write(chr(self._byte))
+                self._byte = 0
+            else:
+                if self._big_endian:
+                    self._byte |= (value << (8-self._bit_pos-count))
+                else:
+                    self._byte |= (value << self._bit_pos)
+                self._bit_pos += count 
+                return
+
+        # Write byte per byte
+        while 8 <= count:
+            count -= 8
+            if self._big_endian:
+                byte = (value >> count)
+                value &= ((1 << count) - 1)
+            else:
+                byte = (value & 0xFF)
+                value >>= 8
+            self._output.write(chr(byte))
+
+        # Keep last bits
+        assert 0 <= count and count < 8
+        self._bit_pos = count
+        if 0 < count:
+            assert countBits(value) <= count
+            if self._big_endian:
+                self._byte = value << (8-count)
+            else:
+                self._byte = value
+        else:
+            assert value == 0
+            self._byte = 0
+
+    def paddingToByte(self, bit=False):
+        n = 0
+        while self._bit_pos != 0:
+            self.writeBit(bit)
+            n += 1
+        return n
+
+class StringOutputStream(OutputStream):
+    def __init__(self, big_endian=True):
+        self.string = StringIO()
+        OutputStream.__init__(self, self.string, \
+            big_endian=big_endian, filename=None)
+

Deleted: haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-08 19:59:42 UTC (rev 441)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream.py	2006-03-12 20:02:15 UTC (rev 442)
@@ -1,139 +0,0 @@
-from cStringIO import StringIO
-
-class InputStreamError(Exception):
-    pass
-
-def FileInputStream(filename):
-    input = open(filename, 'r')
-    input.seek(0, 2)
-    size = input.tell() * 8
-    input.seek(0)
-    return InputStream(input, filename=filename, size=size)
-
-def StringInputStream(content):
-    input = StringIO(content)
-    return InputStream(input, filename=None, size=len(content)*8)
-
-class InputStream:
-    def __init__(self, input, filename=None, size=None):
-        self.filename = filename
-        if size == 0:
-            raise InputStreamError("Error: input size is nul (filename='%s')!" % filename)
-        self._size = size
-
-        # TODO: Doesn't support computation of last byte address with bit
-        # address
-        assert (self._size % 8) == 0
-        self._last_byte_address = self._size / 8 - 1
-        self._input = input 
-        
-    def _getSize(self):
-        return self._size
-    size = property(_getSize, doc="Size of the stream in bits")
-
-    def getBits(self, address, nbits, big_endian=False):
-        data = self._getRawBits(address, nbits)        
-        if (address % 8) != 0 or (nbits % 8) != 0:
-            mask = (1 << nbits) - 1
-            shift = address & 7 
-        else:
-            shift = 0
-            mask = None
-        value = 0
-        if not big_endian:
-            if shift != 0:
-                byte = ord(data[0])
-                value += (byte >> shift)
-                data = data[1:]
-                shift = nbits-shift
-            else:
-                shift = nbits-8
-                if shift < 0:
-                    shift += 8
-            for character in data:
-                byte = ord(character)
-                value += (byte << shift) 
-                shift -= 8
-        else:
-            if shift != 0:
-                byte = ord(data[0])
-                value += (byte >> shift)
-                data = data[1:]
-            for character in data:
-                byte = ord(character)
-                value += (byte << shift) 
-                shift += 8
-        if mask != None:
-            value = value & mask
-        return value
-
-    def getBytes(self, address, nbytes):
-        if address % 8 != 0:
-            data = self._getRawBits(address, nbytes*8)
-            nbits = address % 8
-            shift1 = nbits
-            shift2 = 8 - nbits
-            mask = (1 << nbits) - 1
-            newdata = ""
-            for i in range(0, len(data)-1):
-                byte1 = ord(data[i])
-                byte2 = ord(data[i+1])
-                new = chr((byte1 >> shift1) + ((byte2 & mask) << shift2))
-                newdata += new 
-            data = newdata
-        else:
-            data = self._getRawBits(address, nbytes*8)
-        return data
-    
-    def _getRawBits(self, address, nb_bits):
-        nb_bytes = (nb_bits + (address & 7) + 7) / 8
-        self._input.seek(address / 8)
-        data = self._input.read(nb_bytes)
-        if len(data) != nb_bytes:
-            raise InputStreamError(
-                "Can't read %u bytes at address %u (got %u bytes)!" % \
-                (nb_bytes, address/8, len(data)))
-        return data
-
-    def searchBytes(self, needle, start_address=0, end_address=None):
-        """
-        Search some bytes between start_address and end_address
-
-        Returns the address of the bytes if founded, None else
-        """
-
-        if end_address == None:
-            end_address = self._last_byte_address * 8
-        if end_address < start_address:
-            return None
-        
-        # TODO: Doesn't suppport bit address yet :-(
-        assert (start_address % 8) == 0
-        assert (end_address % 8) == 0
-
-        size = 2048 
-        if size <= len(needle):
-            raise InputStreamError("Search string too big.")
-        doublesize = size * 2
-
-        address = start_address 
-        max = end_address - start_address + 1
-        if max<doublesize:
-            doublesize = max/8 
-            size = 0 
-        buffer = self.getBytes(address, doublesize)
-
-        new_address = address + size
-        while len(buffer) != 0:
-            found = buffer.find(needle)
-            if found != -1:
-                return address + found*8
-            address = new_address
-            if end_address < address + size:
-                size = end_address - address
-            if size == 0:
-                break
-            buffer = buffer[size:] + self.getBytes(address, size)
-            new_address = address + size 
-        return None
-

Modified: haypo/hachoir/branches/hachoir-yield/run_unit_test.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/run_unit_test.py	2006-03-08 19:59:42 UTC (rev 441)
+++ haypo/hachoir/branches/hachoir-yield/run_unit_test.py	2006-03-12 20:02:15 UTC (rev 442)
@@ -1,12 +1,12 @@
-from unit_test import create_fields
-from unit_test import field_set_get_item
-from unit_test import stream_search
+from unit_test import (create_fields, 
+    field_set_get_item, stream_search, output_stream)
 import sys, os
 
 def runAllTests():
     create_fields.runTests()
     field_set_get_item.runTests()
     stream_search.runTests()
+    output_stream.runTests()
 
 def main():
     # Load Hachoir library

Modified: haypo/hachoir/branches/hachoir-yield/test_doc.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-08 19:59:42 UTC (rev 441)
+++ haypo/hachoir/branches/hachoir-yield/test_doc.py	2006-03-12 20:02:15 UTC (rev 442)
@@ -1,6 +1,8 @@
-import doctest, sys, os
+import doctest, sys, os, re
 from stat import S_ISREG, ST_MODE
 
+regex_doc_filename = re.compile("^[a-z0-9_-]+\.txt$")
+
 def testDoc(filename, name=None):
     print "--- %s: Run tests" % filename
     doctest.testfile(filename, optionflags=doctest.ELLIPSIS, name=name)
@@ -16,7 +18,8 @@
     documents.sort()
     for doc in documents:
         filename = os.path.join(doc_dir, doc)
-        if S_ISREG(os.stat(filename)[ST_MODE]):
+        if S_ISREG(os.stat(filename)[ST_MODE]) \
+        and regex_doc_filename.match(doc) != None:
             testDoc(filename)
 
 if __name__ == "__main__":

Modified: haypo/hachoir/branches/hachoir-yield/unit_test/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/unit_test/__init__.py	2006-03-08 19:59:42 UTC (rev 441)
+++ haypo/hachoir/branches/hachoir-yield/unit_test/__init__.py	2006-03-12 20:02:15 UTC (rev 442)
@@ -1,3 +1,4 @@
 import create_fields
 import field_set_get_item
+import output_stream
 



From haypo at berlios.de  Sun Mar 12 21:02:40 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:02:40 +0100
Subject: [Happyboom-svn] r443 - in haypo/hachoir: . branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser/3d
Message-ID: <200603122002.k2CK2eFs022655@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:02:39 +0100 (Sun, 12 Mar 2006)
New Revision: 443

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py
Log:
 r57 at haypopc:  haypo | 2006-03-04 18:18:37 +0100
 Finish to port 3DS parser to new syntax



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:56
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:57

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-12 20:02:15 UTC (rev 442)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-12 20:02:39 UTC (rev 443)
@@ -1,5 +1,6 @@
 from libhachoir.field.field import Field
 from libhachoir.field.bit_field import Bits, Bit
 from libhachoir.field.integer import Integer, Enum 
+from libhachoir.field.float import Float
 from libhachoir.field.string_field import RawBytes, String
 from libhachoir.field.field_set import FieldSet, ParserError

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-12 20:02:15 UTC (rev 442)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-12 20:02:39 UTC (rev 443)
@@ -9,7 +9,7 @@
     def _getValue(self):
         if self._value == None:
             self._value = self.parent.stream.getBits(
-                self.absolute_address, self.size, self.big_endian) 
+                self.absolute_address, self._size, self.big_endian) 
         return self._value
     value = property(_getValue, Field._setValue)
    

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:02:15 UTC (rev 442)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:02:39 UTC (rev 443)
@@ -190,6 +190,7 @@
     def _stopFeeding(self):
         self._field_generator = None
         self._size = self._total_field_size
+        assert not hasattr(self, "static_size") or (self.static_size == self._size)
 
     def _feedUntil(self, field_name):
         try:

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py	2006-03-12 20:02:15 UTC (rev 442)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py	2006-03-12 20:02:39 UTC (rev 443)
@@ -3,14 +3,16 @@
 Author: Victor Stinner
 """
 
-from libhachoir.field import FieldSet, Integer, RawBytes, Enum, String
+from libhachoir.field import (FieldSet, ParserError,
+    Integer, RawBytes, Enum, String, Float)
 from libhachoir.parser.image.common import RGB
 
-#def readObject(self, stream, last_pos):
-#    yield String(self, "name", "C", "Object name")
-#    while self._total_field_size < last_pos:
-#        yield Chunk(self)
-#
+def readObject(parent):
+    yield String(parent, "name", "C", "Object name")
+    size = parent["size"].value * 8
+    while parent.newFieldAskAddress() < size:
+        yield Chunk(parent)
+
 def readTextureFilename(parent):
     yield String(parent, "filename", "C", "Texture filename")
 
@@ -20,62 +22,58 @@
 def readMaterialName(parent):
     yield String(parent, "name", "C", "Material name")
 
-#class Filter_3DS_MapUV(OnDemandFilter):
-#    def __init__(self, stream, parent):
-#        OnDemandFilter.__init__(self, "3ds_map", "3DS UV map", stream, parent, "<")
-#        self.read("u", "Map U", (FormatChunk, "float"))
-#        self.read("v", "Map V", (FormatChunk, "float"))
-#
-#    @staticmethod
-#    def getStaticSize(stream, args):
-#        return 4*2
-# 
-class Filter_3DS_Vertex(FieldSet):
-    static_size = 4*3*8
+class MapUV(FieldSet):
+    endian = "<"
+    def __init__(self, parent, name="map[]", description="Mapping UV"):
+        FieldSet.__init__(self, parent, name, parent.stream, size=64, description=description)
+        
+    def createFields(self):
+        yield Float(self, "u", "float", "Map U")
+        yield Float(self, "v", "float", "Map V")
+
+class Vertex(FieldSet):
+    static_size = 12*8
+    endian = "<"
+
     def __init__(self, parent, name="vertex[]", description="Vertex"):
         FieldSet.__init__(self, parent, name, parent.stream, description=description)
 
     def createFields(self):
-        self.read("x", "X", (FormatChunk, "float"))
-        self.read("y", "Y", (FormatChunk, "float"))
-        self.read("z", "Z", (FormatChunk, "float"))
-#
-#    @staticmethod
-#    def getStaticSize(stream, args):
-#        return 4*3
-#
-#class Filter_3DS_Polygon(OnDemandFilter):
-#    def __init__(self, stream, parent):
-#        OnDemandFilter.__init__(self, "3ds_polygon", "3DS polygon", stream, parent, "<")
-#        self.read("a", "Vertex A", (FormatChunk, "uint16"))
-#        self.read("b", "Vertex B", (FormatChunk, "uint16"))
-#        self.read("c", "Vertex C", (FormatChunk, "uint16"))
-#        self.read("flags", "Flags", (FormatChunk, "uint16"))
-#
-#    @staticmethod
-#    def getStaticSize(stream, args):
-#        return 4*2
-#    
-#def readMapList(filter, stream, last_pos):
-#    filter.read("count", "Map count", (FormatChunk, "uint16"))
-#    for i in range(0, filter["count"]):
-#        filter.read("map[]", "Map UV", (Filter_3DS_MapUV,))
-#
+        yield Float(self, "x", "float", "X")
+        yield Float(self, "y", "float", "Y")
+        yield Float(self, "z", "float", "Z")
+
+class Polygon(FieldSet):
+    static_size = 64
+    endian = "<"
+    def createFields(self):
+        yield Integer(self, "a", "uint16", "Vertex A")
+        yield Integer(self, "b", "uint16", "Vertex B")
+        yield Integer(self, "c", "uint16", "Vertex C")
+        yield Integer(self, "flags", "uint16", "Flags")
+
+def readMapList(parent):
+    yield Integer(parent, "count", "uint16", "Map count")
+    for i in range(0, parent["count"].value):
+        yield MapUV(parent)
+
 def readColor(parent):
     yield RGB(parent, "color", parent.stream)
 
 def readVertexList(parent):
+    yield Integer(parent, "count", "uint16", "Vertex count")
+    for i in range(0, parent["count"].value):
+        yield Vertex(parent)
+    
+def readPolygonList(parent):
     count = Integer(parent, "count", "uint16", "Vertex count")
+    yield count 
     for i in range(0, count.value):
-        yield Vertex(parent)
-    
-#def readPolygonList(filter, stream, last_pos):
-#    filter.read("count", "Vertex count", (FormatChunk, "uint16"))
-#    for i in range(0, filter["count"]):
-#        filter.read("polygon[]", "Polygon", (Filter_3DS_Polygon,))
-#    while stream.tell() < last_pos:
-#        filter.read("chunk[]", "Chunk", (Filter_3DS_Chunk,))
-#
+        yield Polygon(parent, "polygon[]", parent.stream)
+    size = parent["size"].value * 8
+    while parent.newFieldAskAddress() < size:
+        yield Chunk(parent)
+
 class Chunk(FieldSet):
     # List of chunk type name
     type_name = {
@@ -131,13 +129,13 @@
     # List of chunk type handlers
     handlers = {
         0xA000: readMaterialName,
-#        0x4000: readObject,
+        0x4000: readObject,
         0xA300: readTextureFilename,
         0x0011: readColor,
         0x0002: readVersion,
         0x4110: readVertexList,
-#        0x4120: readPolygonList,
-#        0x4140: readMapList
+        0x4120: readPolygonList,
+        0x4140: readMapList
     }
 
     endian = "<"
@@ -176,7 +174,10 @@
                 fields = Chunk.handlers[type] (self)
                 for field in fields:
                     yield field
-                assert self._total_field_size == (chunk_size * 8)
+                if self._total_field_size != (chunk_size * 8):
+                    raise ParserError( \
+                        "Wrong chunk content size (%u bits instead of %u, field %s)"
+                        % (self._total_field_size, chunk_size * 8, self.path))
             else:
                 yield RawBytes(self, "data", content_size)
 



From haypo at berlios.de  Sun Mar 12 21:02:57 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:02:57 +0100
Subject: [Happyboom-svn] r444 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser/file_system branches/hachoir-yield/libhachoir/parser/image branches/hachoir-yield/libhachoir/stream
Message-ID: <200603122002.k2CK2vF6022758@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:02:54 +0100 (Sun, 12 Mar 2006)
New Revision: 444

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/hachoir.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r58 at haypopc:  haypo | 2006-03-04 18:55:41 +0100
  * Field.description becomes a property
  * RGB field set create it's description on demand
  * stream argument in FieldSet constructor becomes optionnal (use parent's one
    by default)
  * Continue to fix EXT2/EXT3 parser
  * displayFieldSet() function display parent description instead of it's size
    by default



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:57
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:58

Modified: haypo/hachoir/branches/hachoir-yield/hachoir.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/hachoir.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -58,7 +58,7 @@
         elif option == "--debug":
             config.debug = True
         elif option == "--metadata":
-            options["metadata"] = value
+            options["metadata"] = True 
         elif option == "--max-depth":   
             try:
                 options["max-depth"] = int(value)

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -16,8 +16,14 @@
                 address = 0
         self.address = address
         self._size = size 
-        self.description = description
+        self._description = description
 
+    def _getDescription(self):
+        return self._description
+    def _setDescription(self, description):
+        self._description = description
+    description = property(_getDescription, _setDescription)
+
     def readRawContent(self):
         stream = self.parent.stream
         stream.seek(self.absolute_address)

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -53,14 +53,18 @@
     is_field_set = True
     endian = "!"
 
-    def __init__(self, parent, name, stream, description=None, size=None):
+    def __init__(self, parent, name, stream=None, description=None, size=None):
         if hasattr(self, "static_size"):
             self._size = self.static_size
         else:
             self._size = size 
         assert self.endian in ("!", "<", ">")
         Field.__init__(self, parent, name, self, size=self._size, description=description)
-        self.stream = stream
+        if stream == None:
+            assert parent != None
+            self.stream = parent.stream
+        else:
+            self.stream = stream
         self.fields = IndexedDict()
         self._event_handler = None
         self._field_generator = self.createFields()

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -49,18 +49,18 @@
         if size != 0:
             yield String(self, "padding", "string[%u]" % size, "Padding")
 
-#  TODO: Re-enable that, maybe using event 'all fields are read'
-#    def updateParent(self, chunk):        
-#        name = self["name"].strip("\0")
-#        if name != "":
-#            desc = "Directory entry: %s" % name
-#        else:
-#            desc = "Directory entry (empty)"
-#        chunk.description = desc
-#        self.setDescription(desc)
+    def _getDescription(self):
+        if self._description == None:
+            name = self["name"].value.strip("\0")
+            if name != "":
+                self._description = "Directory entry: %s" % name
+            else:
+                self._description = "Directory entry (empty)"
+        return self._description
+    description = property(_getDescription, FieldSet._getDescription)
 
 class Inode(FieldSet):
-    name = {
+    type_name = {
         1: "list of bad blocks",
         2: "Root directory",
         3: "ACL inode",
@@ -73,9 +73,9 @@
     endian = "<"
     static_size = (68 + 15*4)*8
 
-    def __init__(self, parent, name, stream, index, description=None):
+    def __init__(self, parent, name, index, description=None):
         self.index = index
-        FieldSet.__init__(self, parent, name, stream, description)
+        FieldSet.__init__(self, parent, name, parent.stream, description)
         
         if self.description == None:
             desc = "Inode %s: " % self.index
@@ -84,8 +84,8 @@
                 size = humanFilesize(self["size"].value)
                 desc += "file, size=%s, mode=%s" % (size, self["mode"].display)
             else:
-                if self.index in Inode.name:
-                    desc += Inode.name[self.index]
+                if self.index in Inode.type_name:
+                    desc += Inode.type_name[self.index]
                     if self.index == 2:
                         desc += " (%s)" % getUnixRWX(self["mode"].value)
                 else:
@@ -98,17 +98,17 @@
         yield Integer(self, "mode", "uint16", "Mode") # {"post": self.postMode}
         yield Integer(self, "uid", "uint16", "User ID")
         yield Integer(self, "size", "uint32", "File size (in bytes)")
-        yield Integer(self, "atime", "uint32", "Last access time") # {"post": unixTimestamp}
-        yield Integer(self, "ctime", "uint32", "Creation time") # {"post": unixTimestamp}
-        yield Integer(self, "mtime", "uint32", "Last modification time") # {"post": unixTimestamp}
-        yield Integer(self, "dtime", "uint32", "Delete time") #  {"post": unixTimestamp}
+        yield Integer(self, "atime", "uint32", "Last access time", text_handler=unixTimestamp)
+        yield Integer(self, "ctime", "uint32", "Creation time", text_handler=unixTimestamp)
+        yield Integer(self, "mtime", "uint32", "Last modification time", text_handler=unixTimestamp)
+        yield Integer(self, "dtime", "uint32", "Delete time", text_handler=unixTimestamp)
         yield Integer(self, "gid", "uint16", "Group ID")
         yield Integer(self, "links_count", "uint16", "Links count")
         yield Integer(self, "blocks", "uint32", "Number of blocks")
         yield Integer(self, "flags", "uint32", "Flags")
         yield Integer(self, "reserved1", "uint32", "Reserved")
         for i in range(0,15):
-            yield Integer(self, "block[]", "uint32", "Block %i" % i)
+            yield Integer(self, "block[]", "uint32")
         yield Integer(self, "version", "uint32", "Version")
         yield Integer(self, "file_acl", "uint32", "File ACL")
         yield Integer(self, "dir_acl", "uint32", "Directory ACL")
@@ -230,7 +230,7 @@
     static_size = 433*8
     endian = "<"
  
-    def __init__(self, parent, name, stream, description="Super block"):
+    def __init__(self, parent, name, stream=None, description="Super block"):
         FieldSet.__init__(self, parent, name, stream, description)
         if self["feature_compat"].value & 4 == 4:
             type = "ext3"
@@ -256,8 +256,8 @@
         yield Integer(self, "blocks_per_group", "uint32", "Blocks per group")
         yield Integer(self, "frags_per_group", "uint32", "Fragments per group")
         yield Integer(self, "inodes_per_group", "uint32", "Inodes per group")
-        yield Integer(self, "mtime", "uint32", "Mount time") #  {"post": unixTimestamp}
-        yield Integer(self, "wtime", "uint32", "Write time") #  {"post": unixTimestamp}
+        yield Integer(self, "mtime", "uint32", "Mount time", text_handler=unixTimestamp)
+        yield Integer(self, "wtime", "uint32", "Write time", text_handler=unixTimestamp)
         yield Integer(self, "mnt_count", "uint16", "Mount count")
         yield Integer(self, "max_mnt_count", "int16", "Max mount count")
         yield String(self, "magic", "string[2]", "Magic number (0x53EF)")
@@ -341,13 +341,6 @@
         index = index - self.start - 1
         return self.getChunk("inode[%u]" % index).getFilter()
 
-def testSuperblock(stream):
-    oldpos = stream.tell()
-    stream.seek(56*8, 1)
-    magic = stream.getN(2)    
-    stream.seek(oldpos)
-    return (magic == "\x53\xEF")
-
 class Group(FieldSetWithSeek):
     def __init__(self, parent, name, stream, index, description=None):
         if description == None:
@@ -368,9 +361,9 @@
         block_size = self["/"].block_size
     
         # Read block bitmap
-        self.superblock_copy = False
-        if testSuperblock(self.stream):
-            self.superblock_copy = True
+#        addr = self.absolute_address + 56*8
+        self.superblock_copy = False #(self.stream.getBytes(addr, 2) == "\x53\xEF")
+        if self.superblock_copy:
             yield SuperBlock(self, "superblock_copy", self.stream, "Superblock")
         field = self.seekField(group["block_bitmap"].value * block_size * 8)
         if field != None:
@@ -395,8 +388,8 @@
         yield InodeTable(self, "inode_table[]", self.stream, inode_index, count)
 
         size = (self.index+1) * superblock["blocks_per_group"].value * block_size
-        if self.stream.getSize() < size:
-            size = self.stream.getSize()
+        if self.stream.size < size:
+            size = self.stream.size
         assert (self._total_field_size % 8) == 0
         size = size - self._total_field_size / 8
         yield String(self, "data", "string[%u]" % size, "Data")

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -7,24 +7,22 @@
     }
     static_size = 3*8
     
-    def __init__(self, parent, name, stream, description=None):
-        FieldSet.__init__(self, parent, name, stream, description)
-        if self.description == None:
-            self.description = self.getColorName()
+    def _getDescription(self):
+        if self._description == None:
+            value = (self["red"].value << 16) + (self["green"].value << 8) + self["blue"].value
+            if value in RGB.color_name:
+                self._description = "RGB color: "+RGB.color_name[value]
+            else:
+                self._description = "RGB color: #%02X%02X%02X" % \
+                    (self["red"].value, self["green"].value, self["blue"].value)
+        return self._description
+    description = property(_getDescription, FieldSet._getDescription)
 
     def createFields(self):
         yield Integer(self, "red", "uint8", "Red")
         yield Integer(self, "green", "uint8", "Green")
         yield Integer(self, "blue", "uint8", "Blue")
 
-    def getColorName(self):
-        value = (self["red"].value << 16) + (self["green"].value << 8) + self["blue"].value
-        if value in RGB.color_name:
-            return "RGB color: "+RGB.color_name[value]
-        else:
-            return "RGB color: #%02X%02X%02X" % \
-                (self["red"].value, self["green"].value, self["blue"].value)
-
 class Palette(FieldSet):
     def __init__(self, parent, name, nb_colors, description=None):
         self.nb_colors = nb_colors

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/pcx.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -31,11 +31,12 @@
         yield Integer(self, "color_mode", "uint16", "Color mode")
         yield RawBytes(self, "reserved2", 58, "Reserved")
 
-        size = self.stream.getSize() - self.stream.tell()
+        size = self.stream.size - self.newFieldAskAddress()
         has_palette = (self["bpp"].value == 8)
         if has_palette:
             size -= 256*3*8            
-        yield RawBytes(self, "data", size, "Image data")
+        assert (size % 8) == 0
+        yield RawBytes(self, "data", size/8, "Image data")
 
         if has_palette:
             yield Palette(self, "palette_8bits", 256, "Palette (8 bit)")

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -20,9 +20,12 @@
         yield Integer(self, "filter", "uint8", "Filter method")
         yield Integer(self, "interlace", "uint8", "Interlace method")
 
-    def updateParent(self, chunk):
-        chunk.description = "Header: %ux%u pixels and %u bits/pixel" \
-            % (self["width"], self["height"], self["bpp"])
+    def _getDescription(self):
+        if self._description == None:
+            self._description = "Header: %ux%u pixels and %u bits/pixel" \
+                % (self["width"].value, self["height"].value, self["bpp"].value)
+        return self._description
+    description = property(_getDescription, FieldSet._getDescription)
 
 class Palette(FieldSet):
     def __init__(self, parent, name, stream, description=None):

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -67,9 +67,9 @@
             value = value & mask
         return value
 
-    def getBytes(self, address, nbytes):
+    def getBytes(self, address, nb_bytes):
         if address % 8 != 0:
-            data = self._getRawBits(address, nbytes*8)
+            data = self._getRawBits(address, nb_bytes*8)
             nbits = address % 8
             shift1 = nbits
             shift2 = 8 - nbits
@@ -82,7 +82,7 @@
                 newdata += new 
             data = newdata
         else:
-            data = self._getRawBits(address, nbytes*8)
+            data = self._getRawBits(address, nb_bytes*8)
         return data
     
     def _getRawBits(self, address, nb_bits):

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/text_handler.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -19,8 +19,8 @@
 def humanFilesize(chunk):
     return doHumanFilesize(chunk.value)
 
-def unixTimestamp(chunk):
-    timestamp = datetime.datetime.fromtimestamp(chunk.value)
+def unixTimestamp(field):
+    timestamp = datetime.datetime.fromtimestamp(field.value)
     return str(timestamp) 
 
 def binary(chunk):

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:02:39 UTC (rev 443)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:02:54 UTC (rev 444)
@@ -1,6 +1,7 @@
 def displayFieldSet(field_set, max_depth=2, depth=0, options={}):
     display_parent_addr = options.get("parent-addr", False)
-    display_parent_size = options.get("parent-size", True)
+    display_parent_size = options.get("parent-size", False)
+    display_parent_desc = options.get("parent-desc", True)
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     text = "%s--- %s ---" % (indent, field_set.name) 
@@ -20,6 +21,8 @@
             if display_parent_size:
                 info.append( "size=%s bytes" % (field_set.size/8) )
         text += " (%s)" % (", ".join(info))
+    if display_parent_desc:
+        text += " (%s)" % field_set.description
     print text
     if max_depth == None or max_depth < 0 or depth < max_depth:
         for field in field_set:
@@ -31,13 +34,15 @@
                 else:
                     assert (field.address % 8) == 0
                     text += "%u" % (field.address/8)
-                text += ") %s = %s: %s " % \
-                    (field._name, field.display, field.description)
+                text += ") %s = %s" % \
+                    (field._name, field.display)
+                if field.description != None:
+                    text += ": %s" % field.description
                 if display_bits:
-                    text += "(size=%s bits)" % field.size
+                    text += " (size=%s bits)" % field.size
                 else:
                     assert (field.size % 8) == 0
-                    text += "(size=%s bytes)" % (field.size / 8)
+                    text += " (size=%s bytes)" % (field.size / 8)
                 print text
             else:
                 displayFieldSet(field, max_depth, depth+1, options)



From haypo at berlios.de  Sun Mar 12 21:03:16 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:03:16 +0100
Subject: [Happyboom-svn] r445 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser branches/hachoir-yield/libhachoir/parser/3d branches/hachoir-yield/libhachoir/parser/archive branches/hachoir-yield/libhachoir/parser/file_system branches/hachoir-yield/libhachoir/parser/image
Message-ID: <200603122003.k2CK3GIp022876@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:03:15 +0100 (Sun, 12 Mar 2006)
New Revision: 445

Added:
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/tar.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r59 at haypopc:  haypo | 2006-03-06 01:37:33 +0100
  * New String field class constructor arguments: 'text_handler' and 'strip'
  * Replace some String with RawBytes in parsers
  * Add last Chunk content handler in PNG parser (from old Hachoir code)
  * Add TAR parser (imported from old Hachoir code)
  * displayFieldSet() automaticly detect if address/size have bit granularity



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:58
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:59

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -3,6 +3,8 @@
 class Bits(Field):
     def __init__(self, parent, name, size, description=None):
         assert issubclass(parent.__class__, Field)
+        # Arbitrary limit (stream supports bigger value)
+        assert size <= 256
         Field.__init__(self, parent, name, size=size, description=description)
         self.big_endian = True
 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -8,23 +8,24 @@
         Field.__init__(self, parent, name, size=length*8, description=description)
         
     def _getTruncated(self, address, length, max_bytes=20):
+        truncated = False
         if self._value == None:
             if max_bytes < length:
                 display = self.parent.stream.getBytes( \
                     address, max_bytes)
-                display += "(...)"
             else:
                 self._value = self.parent.stream.getBytes( \
                     address, length)
                 display = self._value
         else:
             display = self._value[:max_bytes]
-            if max_bytes < length:
-                display += "(...)"
-        return convertDataToPrintableString(display)
+        return display, max_bytes < length
     
     def _getDisplay(self):
-        return self._getTruncated(self.absolute_address, self._size/8)
+        value, truncated = self._getTruncated(self.absolute_address, self._size/8)
+        if truncated:
+            value += "(...)"
+        return convertDataToPrintableString(value)
     display = property(_getDisplay)        
     
     def _getValue(self):
@@ -36,7 +37,8 @@
     value = property(_getValue, Field._setValue)        
 
 class String(RawBytes):
-    def __init__(self, parent, name, format, description=None):
+    def __init__(self, parent, name, format, description=None, \
+            strip=None, text_handler=None):
         RawBytes.__init__(self, parent, name, 0, description)
         self._begin_offset = 0 # in bytes
         self._end_offset = 0 # in bytes
@@ -52,15 +54,31 @@
             self._size = getFormatSize(format) * 8
         self._length = (self._size / 8) - self._begin_offset - self._end_offset
         assert 0 <= self._length
+        self.strip = strip
+        self.text_handler = text_handler
 
     def _getLength(self):
         return self._length
     length = property(_getLength)
+
+    def _processData(self, text, truncated):
+        if self.strip != None:
+            if isinstance(self.strip, str):
+                text = text.strip(self.strip)
+            else:
+                text = text.strip()
+        if truncated:
+            text += "(...)"
+        if self.text_handler != None:
+            self.text_handler(self)
+        return text        
     
     def _getDisplay(self):
-        return self._getTruncated( \
+        value, truncated = self._getTruncated( \
             self.absolute_address + self._begin_offset, \
             self._length)
+        value = self._processData(value, truncated)
+        return convertDataToPrintableString(value)
     display = property(_getDisplay)        
 
     def _getValue(self):
@@ -68,6 +86,7 @@
             assert (self._size % 8) == 0
             self._value = self.parent.stream.getBytes( \
                 self.absolute_address + self._begin_offset*8, self._length)
+            self._value = self._processData(self._value, False)
         return self._value
     value = property(_getValue, Field._setValue)        
 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/3d/3ds.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -144,7 +144,7 @@
         FieldSet.__init__(self, parent, name, parent.stream)
 
         # Set description
-        self.description = "Chunk: %s" % self["type"].display
+        self._description = "Chunk: %s" % self["type"].display
 
         # Set name based on type field
         type = self["type"].value 

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/__init__.py
===================================================================

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/tar.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/tar.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/tar.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -0,0 +1,121 @@
+"""
+Tar archive parser.
+
+Author: Victor Stinner
+"""
+
+from field import FieldSet, Integer, Enum, RawBytes, String
+from error import error
+from tools import humanFilesize
+import re, datetime
+
+from bits import str2hex
+
+class FileEntry(FieldSet):
+    type_name = {
+        0: "Normal disk file (old format)",
+        # 48 is "0", 49 is "1", ...
+        48: "Normal disk file",
+        49: "Link to previously dumped file",
+        50: "Symbolic link",
+        51: "Character special file",
+        52: "Block special file",
+        53: "Directory",
+        54: "FIFO special file",
+        55: "Contiguous file"
+    }
+
+    def createFields(self):
+        yield String(self, "name", "string[100]", "Name", strip="\0")
+        yield String(self, "mode", "string[8]", "Mode", text_handler=self.convertOctal)
+        yield String(self, "uid", "string[8]", "User ID", text_handler=self.convertOctal)
+        yield String(self, "gid", "string[8]", "Group ID", text_handler=self.convertOctal)
+        yield String(self, "size", "string[12]", "Size", text_handler=self.convertOctal)
+        yield String(self, "mtime", "string[12]", "Modification time", text_handler=self.getTime)
+        yield String(self, "check_sum", "string[8]", "Check sum", text_handler=self.convertOctal)
+        yield Enum(self, "type", "uint8", FileEntry.type_name, "Type")
+        yield String(self, "lname", "string[100]", "Link name", strip=" \0")
+        yield String(self, "magic", "string[8]", "Magic", strip=" \0")
+        yield String(self, "uname", "string[32]", "User name", strip=" \0") 
+        yield String(self, "gname", "string[32]", "Group name", strip=" \0") 
+        yield String(self, "devmajor", "string[8]", "Dev major", strip=" \0")
+        yield String(self, "devminor", "string[8]", "Dev minor", strip=" \0")
+        yield RawBytes(self, "padding", 167, "Padding (zero)")
+
+        self.filesize = self.octal2int(self["size"].value)
+        if self["type"].value in (0, ord("0")) and self.filesize != 0:
+            #substream = stream.createSub(stream.tell(), self.size)
+            #plugin = guessPlugin(substream, self["name"].value)
+            #self.read("content", "Compressed file content", (DeflateFilter, substream, self.size, plugin), {"stream": substream, "size": self.size})
+            yield RawBytes(self, "content", self.filesize, "File content")
+
+        padding = 512 - (self.newFieldAskAddress()/8) % 512
+        if padding != 512:
+            yield RawBytes(self, "padding_end", padding, "Padding (512 align)")
+
+    def getMode(self, chunk):
+        mode = self.octal2int(chunk.value)
+        owner = self._getModeItem(mode >> 6 & 7)
+        group = self._getModeItem(mode >> 3 & 7)
+        other = self._getModeItem(mode & 7)
+        return "%04o (%s%s%s)" % (mode, owner, group, other)
+
+    def _getModeItem(mode):
+        if mode & 4 == 4: r="r"
+        else: r="-"
+        if mode & 2 == 2: w="w"
+        else: w="-"
+        if mode & 1 == 1: x="x"
+        else: x="-"
+        return "%c%c%c" % (r, w, x) 
+
+    def convertOctal(self, chunk):
+        return self.octal2int(chunk.value)
+
+    def getTime(self, chunk):
+        value = self.octal2int(chunk.value) 
+        return str(datetime.datetime.fromtimestamp(value))
+
+    def isEmpty(self):
+        return self["name"].value == ""
+
+    def octal2int(self, text):
+        text = text.strip(" \0")
+        if text == "":
+            return 0
+        assert re.match("^[0-7]+$", text)
+        try:
+            return int(text, 8)
+        except:
+            return 0
+
+    def _getDescription(self):
+        if self._description == None:
+            self._description = "Tar File "
+            if not self.isEmpty():
+                self._description += "(%s: %s, %s)" \
+                    % (self.filename, self["type"].display, humanFilesize(self.filesize))
+            else:
+                self._description += "(terminator, empty header)"
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
+    
+    def updateParent(self, chunk):
+        chunk.description = text
+        self.setDescription(text)
+
+class TarFile(FieldSet):
+    mime_types = ["application/x-gtar", "application/x-tar"]
+    
+    def createFields(self):
+        while self._total_field_size < self.stream.size:
+            file = FileEntry(self, "file[]", self.stream, "File")
+            yield file
+            if file.isEmpty():
+                break
+            print file["name"].value
+        padding = self.stream.size - self._total_field_size
+        if padding != 0:
+            assert (padding % 8) == 0
+            yield RawBytes(self, "padding", padding, "Padding")
+

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/file_system/ext2.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -1,6 +1,8 @@
 """
 EXT2 (Linux) file system parser.
 
+Author: Victor Stinner
+
 Sources:
 - EXT2FS source code
   http://ext2fsd.sourceforge.net/
@@ -9,7 +11,7 @@
 """
 
 from text_handler import unixTimestamp
-from field import FieldSet, Integer, Enum, String, ParserError
+from field import FieldSet, Integer, Enum, String, ParserError, RawBytes
 from tools import humanDuration, getUnixRWX, humanFilesize
 from bits import str2hex
 
@@ -19,7 +21,7 @@
         assert 0 <= size
         if 0 < size:
             assert (size % 8) == 0
-            return String(self, "raw[]", "string[%u]" % (size / 8))
+            return RawBytes(self, "raw[]", size/8)
         else:
             return None
 
@@ -47,7 +49,7 @@
         yield String(self, "name", "string[%u]" % name_length, "File name")
         size = self["rec_len"].value-8-name_length 
         if size != 0:
-            yield String(self, "padding", "string[%u]" % size, "Padding")
+            yield RawBytes(self, "padding", size, "Padding")
 
     def _getDescription(self):
         if self._description == None:
@@ -76,12 +78,13 @@
     def __init__(self, parent, name, index, description=None):
         self.index = index
         FieldSet.__init__(self, parent, name, parent.stream, description)
-        
-        if self.description == None:
-            desc = "Inode %s: " % self.index
 
+    def _getDescription(self):
+        if self._description == None:
+            desc = "Inode %s: " % self.index
+            size = self["size"].value
             if 11 <= self.index:
-                size = humanFilesize(self["size"].value)
+                size = humanFilesize(size)
                 desc += "file, size=%s, mode=%s" % (size, self["mode"].display)
             else:
                 if self.index in Inode.type_name:
@@ -90,9 +93,11 @@
                         desc += " (%s)" % getUnixRWX(self["mode"].value)
                 else:
                     desc += "special"
-                if self["size"].value == 0:
+                if size == 0:
                     desc += " (unused)"
-            self.description = desc
+            self._description = desc
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
 
     def createFields(self):
         yield Integer(self, "mode", "uint16", "Mode") # {"post": self.postMode}
@@ -130,7 +135,7 @@
             yield Integer(self, "gid_high", "uint16", "High 16 bits of group ID")
             yield Integer(self, "author", "uint32", "Author ID (?)")
         else:
-            yield String(self, "raw", "string[12]", "Reserved")
+            yield RawBytes(self, "raw", 12, "Reserved")
 
     def postMode(self, chunk):
         mode = chunk.value
@@ -157,29 +162,17 @@
 
 class Bitmap(FieldSet):
     def __init__(self, parent, name, stream, count, start, description=None):
+        assert (count % 8) == 0
         if description != None:
             description = "%s: %s items" % (description, count)
         FieldSet.__init__(self, parent, name, stream, description)
-        assert (count % 8) == 0
         self._size = count
         self.start = start
         self.count = count
 
     def createFields(self):
-        yield String(self, "block_bitmap", "string[%u]" % self._size, "Bitmap")
+        yield RawBytes(self, "block_bitmap", self._size/8, "Bitmap")
 
-#    def showFree(self, type="Block"):
-#        data = self["block_bitmap"]
-#        cpt = self.start
-#        for octet in data:
-#            octet = ord(octet)
-#            mask = 1
-#            for i in range(0,8):
-#                if octet & mask == 0:
-#                    print "%s %s free." % (type, cpt)
-#                cpt = cpt + 1
-#                mask = mask << 1
-
 BlockBitmap = Bitmap
 InodeBitmap = Bitmap
 
@@ -192,8 +185,7 @@
         self.index = index
 
         # Set description
-        superblock = self["/superblock"]
-        blocks_per_group = superblock["blocks_per_group"].value
+        blocks_per_group = self["/superblock/blocks_per_group"].value
         start = self.index * blocks_per_group
         end = start + blocks_per_group 
         self.description = "Group descriptor: blocks %s-%s" % (start, end)
@@ -206,7 +198,7 @@
         yield Integer(self, "free_inodes_count", "uint16", "Number of free inodes")
         yield Integer(self, "used_dirs_count", "uint16", "Number of inodes allocated to directories")
         yield Integer(self, "padding", "uint16", "Padding")
-        yield String(self, "reserved", "string[12]", "Reserved")
+        yield RawBytes(self, "reserved", 12, "Reserved")
    
 class SuperBlock(FieldSet):
     error_handling = {
@@ -285,9 +277,9 @@
         yield Integer(self, "feature_compat", "uint32", "Compatible feature set")
         yield Integer(self, "feature_incompat", "uint32", "Incompatible feature set")
         yield Integer(self, "feature_ro_compat", "uint32", "Read-only compatible feature set")
-        yield String(self, "uuid", "string[16]", "128-bit uuid for volume")
-        yield String(self, "volume_name", "string[16]", "Volume name")
-        yield String(self, "last_mounted", "string[64]", "Directory where last mounted")
+        yield RawBytes(self, "uuid", 16, "128-bit uuid for volume")
+        yield String(self, "volume_name", "string[16]", "Volume name", strip="\0")
+        yield String(self, "last_mounted", "string[64]", "Directory where last mounted", strip="\0")
         yield Integer(self, "compression", "uint32", "For compression (algorithm usage bitmap)")
         yield Integer(self, "prealloc_blocks", "uint8", "Number of blocks to try to preallocate")
         yield Integer(self, "prealloc_dir_blocks", "uint8", "Number to preallocate for directories")
@@ -296,7 +288,7 @@
         yield Integer(self, "journal_inum", "uint32", "inode number of journal file")
         yield Integer(self, "journal_dev", "uint32", "device number of journal file")
         yield Integer(self, "last_orphan", "uint32", "start of list of inodes to delete")
-        yield String(self, "reserved", "string[197]", "Padding to the end of the block")
+        yield RawBytes(self, "reserved", 197, "Reserved")
 
     def _getGroupCount(self):
         if self._group_count == None:
@@ -392,7 +384,7 @@
             size = self.stream.size
         assert (self._total_field_size % 8) == 0
         size = size - self._total_field_size / 8
-        yield String(self, "data", "string[%u]" % size, "Data")
+        yield RawBytes(self, "data", size, "Data")
 
 class EXT2_FS(FieldSetWithSeek):
     """
@@ -440,7 +432,7 @@
 #        size = self.stream.getSize()*8 - self._total_field_size
 #        if size != 0:
 #            assert (size % 8) == 0
-#            yield String(self, "end", "string[%u]" % size, "End (raw)")
+#            yield RawBytes(self, "end", "string[%u]" % size, "End (raw)")
 
 #    def readDirectory(self, inode):
 #        stream = self.getStream()

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/png.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -1,9 +1,18 @@
-from field import FieldSet, Integer, RawBytes, Bit, Bits, ParserError
+"""
+PNG picture file parser.
+
+Author: Victor Stinner
+"""
+
+from field import ( \
+    FieldSet, ParserError,
+    Integer, RawBytes, Bit, Bits, Enum)
 from common import RGB
 from bits import str2hex
 from text_handler import hexadecimal
+import datetime
 
-class HeaderFlags(FieldSet):
+class ColorType(FieldSet):
     def createFields(self):
         yield Bit(self, "palette", "Palette used?")
         yield Bit(self, "color", "Color used?")
@@ -15,7 +24,7 @@
         yield Integer(self, "width", "uint32", "Width (pixels)")
         yield Integer(self, "height", "uint32", "Height (pixels)")
         yield Integer(self, "bpp", "uint8", "Bits per pixel")
-        yield HeaderFlags(self, "color_type", self.stream, "Color type")
+        yield ColorType(self, "color_type", self.stream, "Color type")
         yield Integer(self, "compression", "uint8", "Compression method")
         yield Integer(self, "filter", "uint8", "Filter method")
         yield Integer(self, "interlace", "uint8", "Interlace method")
@@ -25,7 +34,7 @@
             self._description = "Header: %ux%u pixels and %u bits/pixel" \
                 % (self["width"].value, self["height"].value, self["bpp"].value)
         return self._description
-    description = property(_getDescription, FieldSet._getDescription)
+    description = property(_getDescription, FieldSet._setDescription)
 
 class Palette(FieldSet):
     def __init__(self, parent, name, stream, description=None):
@@ -41,14 +50,80 @@
         for i in range(self.nb_colors):
             yield RGB(self, "color[]", self.stream)
 
+class Gamma(FieldSet):
+    static_size = 32
+
+    def createFields(self):
+        yield Integer(self, "gamma", "uint32", "Gamma (x10,000)", \
+            text_handler=self.getGamma)
+
+    def getGamma(self, chunk):
+        return float(chunk.value) / 10000
+
+class Text(FieldSet):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "text", "Text", stream, parent)
+        kw = String(self, "keyword", "C", "Keyword")
+        yield kw
+        lg = self["../size"].value - kw.size/8
+        yield String(self, "text", "string[%u]" % lg, "Text")
+
+    def _getDescription(self):
+        if self._description == None:
+            self._description = 'Text: "%s"' % self["text"].display
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
+
+class Time(FieldSet):
+    endian = "!"
+    static_size = 7*8
+
+    def createFields(self):
+        yield Integer(self, "year", "uint16", "Year")
+        yield Integer(self, "month", "uint8", "Month")
+        yield Integer(self, "day", "uint8", "Day")
+        yield Integer(self, "hour", "uint8", "Hour")
+        yield Integer(self, "minute", "uint8", "Minute")
+        yield Integer(self, "second", "uint8", "Second")
+
+    def _getDescription(self):
+        if self._description == None:
+            time = datetime.datetime( \
+                self["year"].value, self["month"].value, self["day"].value, \
+                self["hour"].value, self["minute"].value, self["second"].value)
+            self._description = "Time: %s" % time
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
+
+class Physical(FieldSet):
+    unit_name = {
+        0: "Unknow",
+        1: "Meter"
+    }
+
+    def createFields(self):
+        yield Integer(self, "pixel_per_unit_x", "uint32", "Pixel per unit, X axis")
+        yield Integer(self, "pixel_per_unit_y", "uint32", "Pixel per unit, Y axis")
+        yield Enum(self, "unit", "uint8", Physical.unit_name, "Unit type")
+
+    def _getDescription(self):
+        if self._description == None:
+            x = self["pixel_per_unit_x"].value
+            y = self["pixel_per_unit_y"].value
+            self._description = "Physical: %ux%u pixels" % (x,y)
+            if self["unit"].value == 1:
+                self._description += " per meter"
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
+
 class Chunk(FieldSet):
     handler = {
-#        "tIME": Time,
-#        "pHYs": Physical,
+        "tIME": Time,
+        "pHYs": Physical,
         "IHDR": Header,
         "PLTE": Palette,
-#        "gAMA": Gamma,
-#        "tEXt": Text
+        "gAMA": Gamma,
+        "tEXt": Text
     }
     name_by_type = {
         "tIME": ("time", "Time"),
@@ -76,12 +151,9 @@
 
         type = self["type"].value
         if type in self.handler:
-            size = self["size"]
-#            oldpos = self._stream.tell()
-#            sub = stream.createLimited(size=size)
             cls = self.handler[type]
             yield cls(self, "content", self.stream)
-#            assert stream.tell() == (oldpos + size) 
+            assert self["content"].size == self["size"].value*8
         else:
             yield RawBytes(self, "content", self["size"].value, "Data")
         yield Integer(self, "crc32", "uint32", "CRC32", text_handler=hexadecimal)

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:02:54 UTC (rev 444)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:03:15 UTC (rev 445)
@@ -8,6 +8,7 @@
     if display_parent_addr or display_parent_size:
         display_bits = (addr % 8) != 0 or (field_set.size % 8) != 0 
         info = []
+        display_bits = (addr % 8) != 0 or (field_set.size % 8) != 0
         if display_bits:
             if display_parent_addr:
                 info.append( "addr=%u.%u" % (addr/8, addr%8) )
@@ -26,6 +27,7 @@
     print text
     if max_depth == None or max_depth < 0 or depth < max_depth:
         for field in field_set:
+            display_bits = (field.address % 8) != 0 or (field.size % 8) != 0
             if not field.is_field_set:
                 display_bits = (field.address % 8) != 0 or (field.size % 8) != 0 
                 text = indent



From haypo at berlios.de  Sun Mar 12 21:03:40 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:03:40 +0100
Subject: [Happyboom-svn] r446 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser/archive branches/hachoir-yield/libhachoir/parser/image branches/hachoir-yield/libhachoir/stream branches/hachoir-yield/unit_test
Message-ID: <200603122003.k2CK3ekB023081@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:03:26 +0100 (Sun, 12 Mar 2006)
New Revision: 446

Added:
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/bzip2.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/ico.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py
   haypo/hachoir/branches/hachoir-yield/unit_test/output_stream.py
Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/log.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r60 at haypopc:  haypo | 2006-03-07 00:51:51 +0100
  * Create field classes: Character and Float
  * Image parsers: import ICO file parser, RGBA color and PaletteRGBA
  * Log class write output to stderr instead of stdout
  * Import BZ2 and GZip file parser



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:59
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:60

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/__init__.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -1,5 +1,6 @@
 from libhachoir.field.field import Field
 from libhachoir.field.bit_field import Bits, Bit
+from libhachoir.field.character import Character
 from libhachoir.field.integer import Integer, Enum 
 from libhachoir.field.float import Float
 from libhachoir.field.string_field import RawBytes, String

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,15 @@
+from field import Field
+from bit_field import Bits
+
+class Character(Bits):
+    def __init__(self, parent, name, description=None):
+        Bits.__init__(self, parent, name, 8, description=description)
+
+    def _getValue(self):
+        if self._value == None:
+            byte = self.parent.stream.getBits(
+                self.absolute_address, 8, True) 
+            self._value = chr(byte)
+        return self._value
+    value = property(_getValue, Field._setValue)
+

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -2,6 +2,7 @@
 from libhachoir.event_handler import EventHandler
 from libhachoir.indexed_dict import IndexedDict
 import libhachoir.config as config
+from libhachoir.stream import InputStream
 
 class MissingField(KeyError):
     pass
@@ -65,6 +66,7 @@
             self.stream = parent.stream
         else:
             self.stream = stream
+        assert isinstance(stream, InputStream)
         self.fields = IndexedDict()
         self._event_handler = None
         self._field_generator = self.createFields()

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,29 @@
+from libhachoir.field.field import Field
+from libhachoir.format import getFormatSize, getRealFormat
+import struct
+
+class Float(Field):
+    def __init__(self, parent, name, format, description=None):
+        assert issubclass(parent.__class__, Field)
+        assert format.endswith("float")
+        if format[0] not in "!<>":
+            format = parent.endian + format
+        self.format = getRealFormat(format)
+        size = getFormatSize(format)*8
+        Field.__init__(self, parent, name, size=size, description=description)
+
+    def _getValue(self):
+        if self._value == None:
+            assert (self._size % 8) == 0
+            raw = self.parent.stream.getBytes(
+                self.absolute_address, self._size/8)
+            raw = struct.unpack(self.format, raw)
+            assert len(raw) == 1
+            self._value = raw[0]
+        return self._value
+    value = property(_getValue, Field._setValue)
+   
+    def _getDisplay(self):
+        return self.value
+    display = property(_getDisplay)
+

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -5,6 +5,8 @@
 class RawBytes(Field):
     def __init__(self, parent, name, length, description="Raw data"):
         assert issubclass(parent.__class__, Field)
+        # arbitrary limit
+        assert length < (1 << 64)
         Field.__init__(self, parent, name, size=length*8, description=description)
         
     def _getTruncated(self, address, length, max_bytes=20):

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/log.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/log.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/log.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: UTF-8 -*-
 
-import time
+import time, sys
 
 class Log:
     LOG_INFO   = 0
@@ -61,7 +61,7 @@
             self.__buffer[level].append(str)
         prefix = self.getLevelPrefix(level)            
         if self.use_print:
-            print "%s %s" % (prefix, str)
+            sys.stderr.write("%s %s\n" % (prefix, str))
         if self.__file:
             self.__file.write(u"%s - %s %s\n" \
                 % (time.strftime("%Y-%M-%d %H:%M:%S"),

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/bzip2.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/bzip2.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/bzip2.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,41 @@
+"""
+BZIP2 archive file
+
+Author: Victor Stinner
+"""
+
+from field import (FieldSet, ParserError, RawBytes, String, Character, Integer)
+from text_handler import hexadecimal
+
+class Bzip2_File(FieldSet):
+    mime_types = "application/x-bzip2"
+    endian = "<"
+
+    def createFields(self):
+        yield String(self, "id", "string[3]", "Identifier (BZh)")
+        assert self["id"].value == "BZh"
+        yield Character(self, "blocksize", "Block size")
+        if not("1" <= self["blocksize"].value <= "9"):
+            raise ParserError(
+                "Stream doesn't look like bzip2 archive (wrong blocksize)!")
+
+        # Size of memory needed to decompress (on classic mode, not "small" mode)
+        size = (ord(self["blocksize"].value) - ord("0")) * 100
+        self["blocksize"].description = "Block size (will need %u KB of memory)" % size
+        
+        yield Integer(self, "blockheader", "uint8", "Block header")
+        if self["blockheader"].value == 0x17:
+            yield String(self, "id2", "string[4]", "Identifier2 (re8P)")
+            yield Integer(self, "id3", "uint8", "Identifier3 (0x90)")
+        elif self["blockheader"].value == 0x31:
+            yield String(self, "id2", "string[5]", "Identifier 2 (AY&SY)")
+            assert self["id2"].value == "AY&SY"
+        else:
+            raise ParserError(
+                "Stream doesn't look like bzip2 archive (wrong blockheader)!")
+        yield Integer(self, "crc32", "uint32", "CRC32", text_handler=hexadecimal)
+
+        size = self.stream.size - self.newFieldAskAddress()
+        assert (size % 8) == 0
+        yield RawBytes(self, "content", size/8, "Compressed data content")
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,84 @@
+"""
+GZIP archive parser.
+
+Author: Victor Stinner
+"""
+
+from field import (FieldSet, 
+    Integer, Enum, 
+    Bit, Bits,
+    RawBytes,  String)
+from error import error
+from text_handler import hexadecimal, humanFilesize, unixTimestamp
+import datetime
+   
+class GzipFile(FieldSet):
+    mime_types = "application/x-gzip"
+    os_name = {
+        0: "FAT filesystem",
+        1: "Amiga",
+        2: "VMS (or OpenVMS)",
+        3: "Unix",
+        4: "VM/CMS",
+        5: "Atari TOS",
+        6: "HPFS filesystem (OS/2, NT)",
+        7: "Macintosh",
+        8: "Z-System",
+        9: "CP/M",
+        10: "TOPS-20",
+        11: "NTFS filesystem (NT)",
+        12: "QDOS",
+        13: "Acorn RISCOS"} 
+    endian = "<"
+
+    def createFields(self):
+        # Gzip header
+        yield RawBytes(self, "id", 2, "GZip identifier")
+        assert self["id"].value == "\x1f\x8b" 
+        yield Integer(self, "compression", "uint8", "Compression method", text_handler=self.getCompressionMethod)
+        
+        # Flags
+        yield Bit(self, "is_text", "File content is probably ASCII text")
+        yield Bit(self, "has_crc16", "Header CRC16")
+        yield Bit(self, "has_extra", "Extra informations (variable size)")
+        yield Bit(self, "has_filename", "Contains filename?")
+        yield Bit(self, "has_comment", "Contains comment?")
+        yield Bits(self, "unused1", 3, "(unused bits)")
+        yield Integer(self, "mtime", "uint32", "Modification time", text_handler=unixTimestamp)
+
+        # Extra flags
+        yield Bit(self, "unused2", "(unused bit)")
+        yield Bit(self, "slowest", "Compressor used maximum compression (slowest)")
+        yield Bit(self, "fastest", "Compressor used the fastest compression")
+        yield Bits(self, "unused3", 5, "(unused bits)")
+
+        yield Enum(self, "os", "uint8", GzipFile.os_name, "Operating system")
+
+        # Optionnal fields
+        if self["has_extra"].value:
+            yield Integer(self, "extra_length", "uint16", "Extra length")
+            yield RawBytes(self, "extra", self["extra_length"].value, "Extra")
+        if self["has_filename"].value:
+            yield String(self, "filename", "C", "Filename")
+        if self["has_comment"].value:
+            yield String(self, "comment", "C", "Comment")
+        if self["has_crc16"].value:
+            yield Integer(self, "hdr_crc16", "uint16", "CRC16 of the header", text_handler=hexadecimal)
+
+        # Read content           
+        size = self.stream.size - self.newFieldAskAddress() - 8*8
+        assert (size % 8) == 0
+        yield RawBytes(self, "data", size/8, "Compressed data")
+
+        # Footer
+        yield Integer(self, "crc32", "uint32", "CRC32", text_handler=hexadecimal)
+        yield Integer(self, "size", "uint32", "Uncompressed size", text_handler=humanFilesize)
+
+    def getCompressionMethod(self, chunk):
+        if chunk.value < 8:
+            return "reserved"
+        elif chunk.value == 8:
+            return "deflate"
+        else:
+            return "Unknow (%s)" % val
+

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/common.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -6,6 +6,11 @@
         0xFFFFFF: "White"
     }
     static_size = 3*8
+
+    def createFields(self):
+        yield Integer(self, "red", "uint8", "Red")
+        yield Integer(self, "green", "uint8", "Green")
+        yield Integer(self, "blue", "uint8", "Blue")
     
     def _getDescription(self):
         if self._description == None:
@@ -18,10 +23,14 @@
         return self._description
     description = property(_getDescription, FieldSet._getDescription)
 
+class RGBA(RGB):
+    static_size = 4*8
+    
     def createFields(self):
         yield Integer(self, "red", "uint8", "Red")
         yield Integer(self, "green", "uint8", "Green")
         yield Integer(self, "blue", "uint8", "Blue")
+        yield Integer(self, "alpha", "uint8", "Alpha")
 
 class Palette(FieldSet):
     def __init__(self, parent, name, nb_colors, description=None):
@@ -35,3 +44,17 @@
         for i in range(0, self.nb_colors):
             yield RGB(self, "color[]", self.stream)
 
+class PaletteRGBA(FieldSet):
+    def __init__(self, parent, name, nb_colors, description=None):
+        self.nb_colors = nb_colors
+        print self.nb_colors
+        print RGBA.static_size
+        size = self.nb_colors * RGBA.static_size
+        if description == None:
+            description = "Palette of %u RGBA colors" % self.nb_colors
+        FieldSet.__init__(self, parent, name, parent.stream, size=size, description=description)
+
+    def createFields(self):
+        for i in range(0, self.nb_colors):
+            yield RGBA(self, "color[]", self.stream)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/ico.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/ico.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/ico.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,119 @@
+"""
+ICO picture file format parser.
+
+Author: Victor Stinner
+"""
+
+from libhachoir.field import FieldSet, ParserError, Integer, Enum, RawBytes
+from libhachoir.parser.image.common import PaletteRGBA
+
+class BitmapInfoHeader(FieldSet):
+    """ Win32 BITMAPINFOHEADER structure from GDI """
+
+    static_size = 40*8
+
+    compression_name = {
+        0: "Uncompressed (RGB)",
+        1: "RLE (8 bits)",
+        2: "RLE (4 bits)",
+        3: "Bitfields",
+        4: "JPEG",
+        5: "PNG"
+    }
+    endian = "<"
+    
+    def createFields(self):
+        yield Integer(self, "hdr_size", "uint32", "Header size (in bytes) (=40)")
+        if self["hdr_size"].value != 40:
+            yield ParserError( \
+                "Bitmap information header looks uncorrect "
+                "(header size is %s instead of 40)" \
+                % self["hdr_size"].value)
+        yield Integer(self, "width", "uint32", "Width")
+        yield Integer(self, "height", "uint32", "Height")
+        yield Integer(self, "nb_planes", "uint16", "Color planes")
+        assert self["nb_planes"].value == 1
+        yield Integer(self, "bpp", "uint16", "Bits/pixel")
+        yield Enum(self, "compression", "uint32", BitmapInfoHeader.compression_name, "Compression")
+        yield Integer(self, "size", "uint32", "Image size (in bytes)")
+        yield Integer(self, "xres", "uint32", "X pixels per meter")
+        yield Integer(self, "yres", "uint32", "Y pixels per meter")
+        yield Integer(self, "color_used", "uint32", "Number of used colors")
+        yield Integer(self, "color_important", "uint32", "Number of important colors")
+
+    def _getDescription(self):
+        if self._description == None:
+            self.description = "Bitmap info header: %ux%u pixels, %u bits/pixel" % \
+                (self["width"].value, self["height"].value,
+                 self["bpp"].value)
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
+
+class IconHeader(FieldSet):
+    endian = "<"
+
+    def createFields(self):
+        yield Integer(self, "width", "uint8", "Width")
+        yield Integer(self, "height", "uint8", "Height")
+        yield Integer(self, "nb_color", "uint8", "Number of colors")
+        yield Integer(self, "reserved", "uint8", "(reserved)")
+        yield Integer(self, "planes", "uint16", "Color planes (=1)")
+        if self["planes"].value != 1:
+            raise ParserError( \
+                "Stream doesn't looks like an icon header "
+                "(wrong plan count)!")
+        yield Integer(self, "bpp", "uint16", "Bits per pixel")
+        yield Integer(self, "size", "uint32", "Content size in bytes")
+        yield Integer(self, "offset", "uint32", "Data offset")
+
+    def _getDescription(self):
+        if self._description == None:
+            self._description = "Icon: %ux%u pixels, %u bits/pixel" \
+                % (self["width"].value, self["height"].value, self["bpp"].value)
+        return self._description
+    description = property(_getDescription, FieldSet._setDescription)
+
+class IconData(FieldSet):
+    def __init__(self, parent, name, header, description="Icon data"):
+        FieldSet.__init__(self, parent, name, parent.stream, description=description)
+        self.header = header
+
+    def createFields(self):
+        yield BitmapInfoHeader(self, "header", self.stream)
+        
+        # Read palette if needed
+        nb_color = self.header["nb_color"].value
+        if self.header["bpp"].value == 8:
+            nb_color = 256
+        if nb_color != 0:            
+            yield PaletteRGBA(self, "palette", nb_color)
+
+        # Read pixels
+        size = self.header["size"].value - self.newFieldAskAddress()/8
+        yield RawBytes(self, "pixels", size, "Image pixels")
+
+class IcoFile(FieldSet):
+    mime_types = "image/x-ico"
+    type_name = {
+        1: "Icon",
+        2: "Mouse cursor"
+    }
+    endian = "<"
+
+    def createFields(self):
+        yield Integer(self, "id", "uint16", "Identifier (0x0000)")
+        if self["id"].value != 0:
+            raise ParserError(
+                "Stream doesn't look like an windows icon file "
+                "(wrong file identifier)")
+        yield Enum(self, "type", "uint16", IcoFile.type_name, "Resource type")
+        yield Integer(self, "nb_items", "uint16", "Number of items")
+        items = []
+        for i in range(0, self["nb_items"].value):
+            item = IconHeader(self, "icon_header[]", self.stream, "Icon header %u" % i)
+            yield item
+            items.append(item)
+        for header in items:
+            assert header["offset"].value*8 == self.newFieldAskAddress()
+            yield IconData(self, "icon_data[]", header)
+

Added: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/__init__.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,5 @@
+from input import (
+        InputStreamError, FileInputStream, StringInputStream, InputStream)
+from output import (
+        FileOutputStream, StringOutputStream, OutputStream)
+

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -1,5 +1,5 @@
 def displayFieldSet(field_set, max_depth=2, depth=0, options={}):
-    display_parent_addr = options.get("parent-addr", False)
+    display_parent_addr = options.get("parent-addr", True)
     display_parent_size = options.get("parent-size", False)
     display_parent_desc = options.get("parent-desc", True)
     indent = " " * (3*depth)

Added: haypo/hachoir/branches/hachoir-yield/unit_test/output_stream.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/unit_test/output_stream.py	2006-03-12 20:03:15 UTC (rev 445)
+++ haypo/hachoir/branches/hachoir-yield/unit_test/output_stream.py	2006-03-12 20:03:26 UTC (rev 446)
@@ -0,0 +1,37 @@
+from libhachoir.stream import StringOutputStream
+from libhachoir.bits import str2bin
+
+def CONTENT(output):
+    output.paddingToByte()
+    string = output.string
+    string.seek(0)
+    return string.read()
+
+def test1():
+    output = StringOutputStream()
+    output.writeBit(True)
+    assert str2bin(CONTENT(output)) == "10000000"
+
+def test2():
+    output = StringOutputStream()
+    output.writeBit(False)
+    output.writeBits(8, 0xFF)
+    assert str2bin(CONTENT(output)) == "01111111 10000000"
+
+def test3():
+    output = StringOutputStream(big_endian=False)
+    output.writeBit(True)
+    assert str2bin(CONTENT(output)) == "00000001"
+
+def test4():
+    output = StringOutputStream(big_endian=False)
+    output.writeBit(False)
+    output.writeBits(8, 0xFF)
+    assert str2bin(CONTENT(output)) == "11111110 00000001"
+
+def runTests():
+    test1()
+    test2()
+    test3()
+    test4()
+



From haypo at berlios.de  Sun Mar 12 21:04:01 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:04:01 +0100
Subject: [Happyboom-svn] r447 - in haypo/hachoir: . branches/hachoir-yield branches/hachoir-yield/doc branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser/image branches/hachoir-yield/libhachoir/stream
Message-ID: <200603122004.k2CK41Vb023226@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:03:49 +0100 (Sun, 12 Mar 2006)
New Revision: 447

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
Log:
 r61 at haypopc:  haypo | 2006-03-09 23:16:17 +0100
 It's possible to recreate a file from a field set :-)
  * In InputStream, rename get*() to read*(), and endian is no optionnal anymore
    for function readBits(). Update documentation for this changes.
  * Add Field.writeInto() method
  * OutputStream: fix writeBits() method, add copyBitsFrom() and copyBytesFrom()
  * displayFieldSet(): only display field set description ... if it has an
    description



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:60
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:61

Modified: haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt
===================================================================
--- haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/doc/1-basic.txt	2006-03-12 20:03:49 UTC (rev 447)
@@ -9,16 +9,16 @@
 ``FileInputStream`` function (needs a filename) or ``StringInputStream``
 (needs a string). Here is a small example to create a stream:
 
->>> from stream import StringInputStream
+>>> from libhachoir.stream import StringInputStream
 >>> stream = StringInputStream("\x03abc")
 
 Most interesting methods are:
 
->>> stream.size            # get size in bits
+>>> stream.size                   # get size in bits
 32
->>> stream.getBits(0, 8)   # get 8 bits at address 0
+>>> stream.readBits(0, 8, True)  # get 8 bits at address 0 in big endian
 3
->>> stream.getBytes(8, 3)  # get 3 bytes at address 8
+>>> stream.readBytes(8, 3)        # get 3 bytes at address 8
 'abc'
 
 Support your own format using FieldSet

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/bit_field.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -10,7 +10,7 @@
 
     def _getValue(self):
         if self._value == None:
-            self._value = self.parent.stream.getBits(
+            self._value = self.parent.stream.readBits(
                 self.absolute_address, self._size, self.big_endian) 
         return self._value
     value = property(_getValue, Field._setValue)
@@ -18,6 +18,9 @@
     def _getDisplay(self):
         return self.value
     display = property(_getDisplay)
+    
+    def writeInto(self, output):
+        output.copyBitsFrom(self.parent.stream, self.absolute_address, self._size, self.big_endian)
 
 class Bit(Bits):
     def __init__(self, parent, name, description=None):
@@ -25,7 +28,7 @@
 
     def _getValue(self):
         if self._value == None:
-            data = self.parent.stream.getBits(
+            data = self.parent.stream.readBits(
                 self.absolute_address, 1, True) 
             self._value = (data == 1)
         return self._value

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/character.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -7,7 +7,7 @@
 
     def _getValue(self):
         if self._value == None:
-            byte = self.parent.stream.getBits(
+            byte = self.parent.stream.readBits(
                 self.absolute_address, 8, True) 
             self._value = chr(byte)
         return self._value

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -68,3 +68,7 @@
     def _getSize(self):
         return self._size
     size = property(_getSize)
+
+    def writeInto(self, output):
+        raise NotImplementedError()
+

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -65,8 +65,9 @@
             assert parent != None
             self.stream = parent.stream
         else:
+#            assert isinstance(stream, InputStream)
+#            assert issubclass(stream.__class__, InputStream)
             self.stream = stream
-        assert isinstance(stream, InputStream)
         self.fields = IndexedDict()
         self._event_handler = None
         self._field_generator = self.createFields()
@@ -231,3 +232,7 @@
     def createFields(self):
         raise NotImplementedError
 
+    def writeInto(self, output):
+        for field in self:
+            field.writeInto(output)
+

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/float.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -15,7 +15,7 @@
     def _getValue(self):
         if self._value == None:
             assert (self._size % 8) == 0
-            raw = self.parent.stream.getBytes(
+            raw = self.parent.stream.readBytes(
                 self.absolute_address, self._size/8)
             raw = struct.unpack(self.format, raw)
             assert len(raw) == 1

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -13,10 +13,10 @@
         truncated = False
         if self._value == None:
             if max_bytes < length:
-                display = self.parent.stream.getBytes( \
+                display = self.parent.stream.readBytes( \
                     address, max_bytes)
             else:
-                self._value = self.parent.stream.getBytes( \
+                self._value = self.parent.stream.readBytes( \
                     address, length)
                 display = self._value
         else:
@@ -33,11 +33,14 @@
     def _getValue(self):
         if self._value == None:
             assert (self._size % 8) == 0
-            self._value = self.parent.stream.getBytes( \
+            self._value = self.parent.stream.readBytes( \
                 self.absolute_address, self._size / 8)
         return self._value
     value = property(_getValue, Field._setValue)        
 
+    def writeInto(self, output):
+        output.copyBytesFrom(self.parent.stream, self.absolute_address, self._size/8)
+
 class String(RawBytes):
     def __init__(self, parent, name, format, description=None, \
             strip=None, text_handler=None):
@@ -86,7 +89,7 @@
     def _getValue(self):
         if self._value == None:
             assert (self._size % 8) == 0
-            self._value = self.parent.stream.getBytes( \
+            self._value = self.parent.stream.readBytes( \
                 self.absolute_address + self._begin_offset*8, self._length)
             self._value = self._processData(self._value, False)
         return self._value

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/mime.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -81,7 +81,7 @@
     nb_bytes = stream.size/8
     if 4096 < nb_bytes:
         nb_bytes = 4096
-    data = stream.getBytes(0, nb_bytes)
+    data = stream.readBytes(0, nb_bytes)
     return getBufferMime(data, stream.filename)
 
 def getAnotherBufferMime(content):    

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/image/bmp.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -18,7 +18,7 @@
     }        
     
     def createFields(self):
-        yield RawBytes(self, "header", "string[2]", "Header (\"BM\")")
+        yield RawBytes(self, "header", 2, "Header (\"BM\")")
         if self["header"].value != "BM": 
             raise ParserError(
                 "BMP picture parser error: indentifier is uncorrect")

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/input.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -31,7 +31,7 @@
         return self._size
     size = property(_getSize, doc="Size of the stream in bits")
 
-    def getBits(self, address, nbits, big_endian=False):
+    def readBits(self, address, nbits, big_endian):
         data = self._getRawBits(address, nbits)        
         if (address % 8) != 0 or (nbits % 8) != 0:
             mask = (1 << nbits) - 1
@@ -67,7 +67,7 @@
             value = value & mask
         return value
 
-    def getBytes(self, address, nb_bytes):
+    def readBytes(self, address, nb_bytes):
         if address % 8 != 0:
             data = self._getRawBits(address, nb_bytes*8)
             nbits = address % 8
@@ -121,7 +121,7 @@
         if max<doublesize:
             doublesize = max/8 
             size = 0 
-        buffer = self.getBytes(address, doublesize)
+        buffer = self.readBytes(address, doublesize)
 
         new_address = address + size
         while len(buffer) != 0:
@@ -133,7 +133,7 @@
                 size = end_address - address
             if size == 0:
                 break
-            buffer = buffer[size:] + self.getBytes(address, size)
+            buffer = buffer[size:] + self.readBytes(address, size)
             new_address = address + size 
         return None
 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/stream/output.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -53,7 +53,7 @@
                 self._byte = 0
             else:
                 if self._big_endian:
-                    self._byte |= (value << (8-self._bit_pos-count))
+                    self._byte |= (value << (7-self._bit_pos-count))
                 else:
                     self._byte |= (value << self._bit_pos)
                 self._bit_pos += count 
@@ -83,6 +83,38 @@
             assert value == 0
             self._byte = 0
 
+    def copyBitsFrom(self, input, address, nb_bits, big_endian):
+        if (nb_bits % 8) == 0 and big_endian:
+            self.copyBytesFrom(input, address, nb_bits/8)
+        else:
+            # Arbitrary limit (because we should use a buffer, like copyBytesFrom(),
+            # but with endianess problem
+            assert nb_bits <= 128
+            buffer = input.readBits(address, nb_bits, big_endian)
+            self.writeBits(nb_bits, buffer)
+    
+    def copyBytesFrom(self, input, address, nb_bytes):
+        buffer_size = 1 << 16 # 64 KB
+        while 0 < nb_bytes:
+            # Compute buffer size
+            if nb_bytes < buffer_size:
+                buffer_size = nb_bytes
+                
+            # Read
+            buffer = input.readBytes(address, buffer_size)
+            
+            # Write
+            self.writeBytes(buffer)
+
+            # Move address
+            address += buffer_size*8
+            nb_bytes -= buffer_size
+
+    def writeBytes(self, bytes):           
+        if self._bit_pos != 0:
+            raise NotImplementedError()
+        self._output.write(bytes)
+
     def paddingToByte(self, bit=False):
         n = 0
         while self._bit_pos != 0:

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:03:26 UTC (rev 446)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-12 20:03:49 UTC (rev 447)
@@ -1,5 +1,5 @@
 def displayFieldSet(field_set, max_depth=2, depth=0, options={}):
-    display_parent_addr = options.get("parent-addr", True)
+    display_parent_addr = options.get("parent-addr", False)
     display_parent_size = options.get("parent-size", False)
     display_parent_desc = options.get("parent-desc", True)
     indent = " " * (3*depth)
@@ -22,7 +22,7 @@
             if display_parent_size:
                 info.append( "size=%s bytes" % (field_set.size/8) )
         text += " (%s)" % (", ".join(info))
-    if display_parent_desc:
+    if display_parent_desc and field_set.description != None:
         text += " (%s)" % field_set.description
     print text
     if max_depth == None or max_depth < 0 or depth < max_depth:



From haypo at berlios.de  Sun Mar 12 21:04:10 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:04:10 +0100
Subject: [Happyboom-svn] r448 - in haypo/hachoir: . branches/hachoir-yield/libhachoir/field
Message-ID: <200603122004.k2CK4AVB023552@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:04:10 +0100 (Sun, 12 Mar 2006)
New Revision: 448

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
Log:
 r62 at haypopc:  haypo | 2006-03-09 23:20:32 +0100
 Small changes about event and comment syntax ...



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:61
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:62

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:03:49 UTC (rev 447)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:04:10 UTC (rev 448)
@@ -36,7 +36,7 @@
         return self._value
     def _setValue(self, new_value):
         self._value = new_value
-        self.parent.raiseEvent("value-changed", self)
+        self.parent.raiseEvent("field-value-changed", self)
     value = property(_getValue, _setValue)
 
     def _getDisplay(self):

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:03:49 UTC (rev 447)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:04:10 UTC (rev 448)
@@ -41,14 +41,14 @@
        * size: Size of field set in bits, may need to create field set
 
     Event handling:
-       * connect: Connect an handler to an event
+       * connectEvent: Connect an handler to an event
        * raiseEvent: Raise an event 
    
     To implement a new field set, you need to:
        * create a class which inherite from FieldSet
        * write createFields() method using lines like:
          "yield <field class>(self, <field name>, ...)"
-       * and maybe set endian/static_size class attributes
+       * and maybe set endian and static_size class attributes
     """
 
     is_field_set = True
@@ -65,6 +65,7 @@
             assert parent != None
             self.stream = parent.stream
         else:
+            # Disabled because document test doesn't work !?!?
 #            assert isinstance(stream, InputStream)
 #            assert issubclass(stream.__class__, InputStream)
             self.stream = stream
@@ -85,7 +86,8 @@
         return "(...)" 
     display = property(_getDisplay)
 
-    def connect(self, event_name, handler):
+    def connectEvent(self, event_name, handler):
+        assert event_name in ("field-value-changed",)
         if self._event_handler == None:
             self._event_handler = EventHandler()
         self._event_handler.connect(event_name, handler)



From haypo at berlios.de  Sun Mar 12 21:04:32 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:04:32 +0100
Subject: [Happyboom-svn] r450 - in haypo/hachoir: . branches/hachoir-yield
Message-ID: <200603122004.k2CK4WMP023765@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:04:29 +0100 (Sun, 12 Mar 2006)
New Revision: 450

Added:
   haypo/hachoir/branches/hachoir-yield/write.py
Modified:
   haypo/hachoir/
Log:
 r64 at haypopc:  haypo | 2006-03-12 21:00:44 +0100
  * Add dumb script to test write feature



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:63
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:64

Added: haypo/hachoir/branches/hachoir-yield/write.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/write.py	2006-03-12 20:04:20 UTC (rev 449)
+++ haypo/hachoir/branches/hachoir-yield/write.py	2006-03-12 20:04:29 UTC (rev 450)
@@ -0,0 +1,26 @@
+#!/usr/bin/env python
+import sys, os, getopt
+from text_ui import displayFieldSet
+
+def main():
+    current_dir = os.path.dirname(__file__)
+    libhachoir_path = os.path.join(current_dir, "libhachoir")
+    sys.path.append(libhachoir_path)
+
+    from libhachoir.parser.archive.gzip import GzipFile
+    from libhachoir.stream import FileInputStream, FileOutputStream
+
+    input = FileInputStream("/home/haypo/exemple/gz.gz")
+    gzip = GzipFile(None, "gzip", input)
+
+#    displayFieldSet(gzip)
+    
+    print "Set has_comment=True"
+    gzip["has_comment"].value = True 
+    print "Set has_comment=True: done"
+
+    output = FileOutputStream("/home/haypo/new.gz")
+    gzip.writeInto(output)
+#    displayFieldSet(gzip)
+    
+main()


Property changes on: haypo/hachoir/branches/hachoir-yield/write.py
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + text/script



From haypo at berlios.de  Sun Mar 12 21:04:21 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 12 Mar 2006 21:04:21 +0100
Subject: [Happyboom-svn] r449 - in haypo/hachoir: . branches/hachoir-yield/libhachoir branches/hachoir-yield/libhachoir/field branches/hachoir-yield/libhachoir/parser/archive
Message-ID: <200603122004.k2CK4LkX023681@sheep.berlios.de>

Author: haypo
Date: 2006-03-12 21:04:20 +0100 (Sun, 12 Mar 2006)
New Revision: 449

Modified:
   haypo/hachoir/
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py
Log:
 r63 at haypopc:  haypo | 2006-03-12 20:48:30 +0100
  * remove useless Field.readRawContent()
  * Field.setValue() only raise event if value changed
  * fix FieldSet._feedUntil()
  * IndexedDict() supports __delitem__() and insert(), also add indexOf() method
  * write experimental insertFieldAt() and removeField() in GzipFile parser



Property changes on: haypo/hachoir
___________________________________________________________________
Name: svk:merge
   - f1182766-d90d-0410-bb94-dc577a833def:/hachoir:62
   + f1182766-d90d-0410-bb94-dc577a833def:/hachoir:63

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:04:10 UTC (rev 448)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field.py	2006-03-12 20:04:20 UTC (rev 449)
@@ -24,17 +24,14 @@
         self._description = description
     description = property(_getDescription, _setDescription)
 
-    def readRawContent(self):
-        stream = self.parent.stream
-        stream.seek(self.absolute_address)
-        return stream.getN(self.size)
-
     def __str__(self):
         return self.display
 
     def _getValue(self):
         return self._value
     def _setValue(self, new_value):
+        if self.value == new_value:
+            return
         self._value = new_value
         self.parent.raiseEvent("field-value-changed", self)
     value = property(_getValue, _setValue)

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:04:10 UTC (rev 448)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-12 20:04:20 UTC (rev 449)
@@ -194,7 +194,9 @@
         else:
             if self._field_generator != None:
                 field = self._feedUntil(name)
-            return name in self.fields
+                return (field != None)
+            else:
+                return name in self.fields
 
     def _stopFeeding(self):
         self._field_generator = None
@@ -202,6 +204,9 @@
         assert not hasattr(self, "static_size") or (self.static_size == self._size)
 
     def _feedUntil(self, field_name):
+        """
+        Return the field if it was found, None else
+        """
         try:
             while True:
                 field = self._feed()

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:04:10 UTC (rev 448)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/string_field.py	2006-03-12 20:04:20 UTC (rev 449)
@@ -3,11 +3,12 @@
 from libhachoir.tools import convertDataToPrintableString
 
 class RawBytes(Field):
-    def __init__(self, parent, name, length, description="Raw data"):
+    def __init__(self, parent, name, length, description="Raw data", value=None):
         assert issubclass(parent.__class__, Field)
         # arbitrary limit
         assert length < (1 << 64)
-        Field.__init__(self, parent, name, size=length*8, description=description)
+        Field.__init__(self, parent, name, size=length*8, \
+            description=description, value=value)
         
     def _getTruncated(self, address, length, max_bytes=20):
         truncated = False
@@ -43,8 +44,9 @@
 
 class String(RawBytes):
     def __init__(self, parent, name, format, description=None, \
-            strip=None, text_handler=None):
-        RawBytes.__init__(self, parent, name, 0, description)
+            strip=None, text_handler=None, value=None):
+        RawBytes.__init__(self, parent, name, 0, description, \
+            value=value)
         self._begin_offset = 0 # in bytes
         self._end_offset = 0 # in bytes
         if format == "C":

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-12 20:04:10 UTC (rev 448)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-12 20:04:20 UTC (rev 449)
@@ -3,24 +3,59 @@
 
 class IndexedDict:
     def __init__(self):
-        self._dict = {}
-        self._list = []
+        self._dict = {}         # key => value
+        self._value_list = []   # index => value
+        self._index = {}        # key => index
+        self._key_list = []     # index => key, needed by insert
 
+    def getByIndex(self, index):
+        return self._value_list[index]
+
     def __getitem__(self, key):
         return self._dict[key]
 
+    def __delitem__(self, index):
+        key = self._key_list[index]
+        for index_key in self._key_list[index+1:]:
+            self._index[index_key] -= 1
+        del self._dict[key]
+        del self._value_list[index]
+        del self._key_list[index]
+
+    def insert(self, index, key, value):
+        if key in self:
+            raise UniqKeyError("Insert error: key '%s' ready exists" % key)
+        if index < 0:
+            if not(-len(self._key_list) <= index):
+                raise IndexError("Insert error: index '%s' is invalid" % index)
+            index = len(self._key_list)+index
+        else:                
+            if not(0 <= index <= len(self._key_list)):
+                raise IndexError("Insert error: index '%s' is invalid" % index)
+        for index_key in self._key_list[index:]:
+            self._index[index_key] += 1         
+        self._dict[key] = value
+        self._index[key] = index 
+        self._value_list.insert(index, value)
+        self._key_list.insert(index, key)
+
+    def indexOf(self, key):
+        return self._index[key]
+
     def append(self, key, value):
         if key in self._dict:
             raise UniqKeyError("Key '%s' already exists" % key)
         self._dict[key] = value
-        self._list.append(value)
+        self._index[key] = len(self._key_list)
+        self._value_list.append(value)
+        self._key_list.append(key)
 
     def __len__(self):
-        return len(self._list)
+        return len(self._value_list)
 
     def __contains__(self, key):
         return key in self._dict
 
     def __iter__(self):
-        return iter(self._list)
+        return iter(self._value_list)
 

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py	2006-03-12 20:04:10 UTC (rev 448)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py	2006-03-12 20:04:20 UTC (rev 449)
@@ -11,6 +11,27 @@
 from error import error
 from text_handler import hexadecimal, humanFilesize, unixTimestamp
 import datetime
+
+def removeField(field_set, delete_field):
+    size = delete_field.size
+    index = field_set.fields.indexOf(delete_field.name)
+    fields = field_set.fields
+    for update_index in xrange(index+1, len(fields)):
+        field = fields.getByIndex(update_index)
+        field.address -= size
+    del field_set.fields[index]
+    
+def insertFieldAfter(field_set, after, new_field):
+    print new_field.path
+    size = new_field.size
+    index = field_set.fields.indexOf(after.name)
+    fields = field_set.fields
+    for update_index in xrange(index+1, len(fields)):
+        field = fields.getByIndex(update_index)
+        field.address += size
+    print "Insert %s after %s" % (new_field.path, after.path)
+    new_field.address = after.address + after.size
+    field_set.fields.insert(index+1, new_field.name, new_field)
    
 class GzipFile(FieldSet):
     mime_types = "application/x-gzip"
@@ -31,7 +52,26 @@
         13: "Acorn RISCOS"} 
     endian = "<"
 
+    def fieldValueChanged(self, field):
+        if field.name == "has_comment":
+            if field.value:
+                assert "comment" not in self
+                if self["has_filename"].value:
+                    after = self["filename"]
+                elif self["has_extra"].value:
+                    after = self["extra"]
+                else:
+                    after = self["os"]
+                value = "abc"
+                comment = String(self, "comment", "string[%u]" % len(value), description="Comment", value=value)
+                insertFieldAfter(self, after, comment)
+            else:
+                removeField(self, self["comment"])
+
     def createFields(self):
+        # Install handlers
+        self.connectEvent("field-value-changed", self.fieldValueChanged)
+    
         # Gzip header
         yield RawBytes(self, "id", 2, "GZip identifier")
         assert self["id"].value == "\x1f\x8b" 



From haypo at berlios.de  Tue Mar 14 23:48:16 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 14 Mar 2006 23:48:16 +0100
Subject: [Happyboom-svn] r451 - haypo/hachoir/trunk
Message-ID: <200603142248.k2EMmGb8017024@sheep.berlios.de>

Author: haypo
Date: 2006-03-14 23:48:16 +0100 (Tue, 14 Mar 2006)
New Revision: 451

Modified:
   haypo/hachoir/trunk/reverse.py
Log:
Cleanup entropy() function


Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-03-12 20:04:29 UTC (rev 450)
+++ haypo/hachoir/trunk/reverse.py	2006-03-14 22:48:16 UTC (rev 451)
@@ -31,10 +31,9 @@
         if count[i] != 0:
             p.append( float(count[i]) / length )
     h = 0
-    n = len(p)
     for p_i in p:
-        h += p_i * math.log(p_i, 2)
-    return -h
+        h -= p_i * math.log(p_i, 2)
+    return h
 
 class Pattern:
     def check(self, stream):



From haypo at berlios.de  Tue Mar 14 23:52:52 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 14 Mar 2006 23:52:52 +0100
Subject: [Happyboom-svn] r452 - haypo/hachoir/trunk
Message-ID: <200603142252.k2EMqqah017529@sheep.berlios.de>

Author: haypo
Date: 2006-03-14 23:52:51 +0100 (Tue, 14 Mar 2006)
New Revision: 452

Modified:
   haypo/hachoir/trunk/reverse.py
Log:
Merge two for in entropy() function


Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-03-14 22:48:16 UTC (rev 451)
+++ haypo/hachoir/trunk/reverse.py	2006-03-14 22:52:51 UTC (rev 452)
@@ -26,13 +26,12 @@
         for i in raw:
             count[i] = count[i] + 1
     length = stream.getSize()
+    h = 0
     for i in range(0, 256):
         i = chr(i)
         if count[i] != 0:
-            p.append( float(count[i]) / length )
-    h = 0
-    for p_i in p:
-        h -= p_i * math.log(p_i, 2)
+            p_i = float(count[i]) / length
+            h -= p_i * math.log(p_i, 2)
     return h
 
 class Pattern:



From haypo at berlios.de  Wed Mar 15 01:12:32 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 15 Mar 2006 01:12:32 +0100
Subject: [Happyboom-svn] r453 - in haypo/hachoir/branches/hachoir-yield: . libhachoir libhachoir/field libhachoir/parser/archive
Message-ID: <200603150012.k2F0CW05009486@sheep.berlios.de>

Author: haypo
Date: 2006-03-15 01:11:00 +0100 (Wed, 15 Mar 2006)
New Revision: 453

Modified:
   haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
   haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py
   haypo/hachoir/branches/hachoir-yield/text_ui.py
   haypo/hachoir/branches/hachoir-yield/write.py
Log:
 * Split IndexedDict class into OrderedDict and IndexedDict


Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-14 22:52:51 UTC (rev 452)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/field/field_set.py	2006-03-15 00:11:00 UTC (rev 453)
@@ -1,6 +1,6 @@
 from field import Field
 from libhachoir.event_handler import EventHandler
-from libhachoir.indexed_dict import IndexedDict
+from libhachoir.indexed_dict import OrderedDict
 import libhachoir.config as config
 from libhachoir.stream import InputStream
 
@@ -69,7 +69,7 @@
 #            assert isinstance(stream, InputStream)
 #            assert issubclass(stream.__class__, InputStream)
             self.stream = stream
-        self.fields = IndexedDict()
+        self.fields = OrderedDict()
         self._event_handler = None
         self._field_generator = self.createFields()
         self._field_array_count = {}

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-14 22:52:51 UTC (rev 452)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-15 00:11:00 UTC (rev 453)
@@ -1,12 +1,16 @@
 class UniqKeyError(KeyError):
     pass
 
-class IndexedDict:
+class OrderedDict:
+    """
+    This class works like classic Python dict() but has an important method:
+    __iter__() which allow to iterate into the dictionnary _values_ (and not
+    keys like Python's dict does).
+    """
     def __init__(self):
         self._dict = {}         # key => value
         self._value_list = []   # index => value
         self._index = {}        # key => index
-        self._key_list = []     # index => key, needed by insert
 
     def getByIndex(self, index):
         return self._value_list[index]
@@ -14,6 +18,39 @@
     def __getitem__(self, key):
         return self._dict[key]
 
+    def indexOf(self, key):
+        return self._index[key]
+
+    def append(self, key, value):
+        if key in self._dict:
+            raise UniqKeyError("Key '%s' already exists" % key)
+        self._dict[key] = value
+        self._index[key] = len(self._value_list)
+        self._value_list.append(value)
+
+    def __len__(self):
+        return len(self._value_list)
+
+    def __contains__(self, key):
+        return key in self._dict
+
+    def __iter__(self):
+        return iter(self._value_list)
+
+class IndexedDict(OrderedDict):
+    """
+    This class is based on OrderedDict(), but add new methods:
+     * insert(index, key, value) 
+     * __delitem__(index)
+    """
+    
+    def __init__(self):
+        self._key_list = []     # index => key, needed by insert
+
+    def append(self, key, value):
+        OrderedDict.append(key, value)
+        self._key_list.append(key)
+        
     def __delitem__(self, index):
         key = self._key_list[index]
         for index_key in self._key_list[index+1:]:
@@ -39,23 +76,3 @@
         self._value_list.insert(index, value)
         self._key_list.insert(index, key)
 
-    def indexOf(self, key):
-        return self._index[key]
-
-    def append(self, key, value):
-        if key in self._dict:
-            raise UniqKeyError("Key '%s' already exists" % key)
-        self._dict[key] = value
-        self._index[key] = len(self._key_list)
-        self._value_list.append(value)
-        self._key_list.append(key)
-
-    def __len__(self):
-        return len(self._value_list)
-
-    def __contains__(self, key):
-        return key in self._dict
-
-    def __iter__(self):
-        return iter(self._value_list)
-

Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py	2006-03-14 22:52:51 UTC (rev 452)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/parser/archive/gzip.py	2006-03-15 00:11:00 UTC (rev 453)
@@ -111,7 +111,7 @@
         yield RawBytes(self, "data", size/8, "Compressed data")
 
         # Footer
-        yield Integer(self, "crc32", "uint32", "CRC32", text_handler=hexadecimal)
+        yield Integer(self, "crc32", "uint32", "Uncompressed data content CRC32", text_handler=hexadecimal)
         yield Integer(self, "size", "uint32", "Uncompressed size", text_handler=humanFilesize)
 
     def getCompressionMethod(self, chunk):

Modified: haypo/hachoir/branches/hachoir-yield/text_ui.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-14 22:52:51 UTC (rev 452)
+++ haypo/hachoir/branches/hachoir-yield/text_ui.py	2006-03-15 00:11:00 UTC (rev 453)
@@ -2,6 +2,7 @@
     display_parent_addr = options.get("parent-addr", False)
     display_parent_size = options.get("parent-size", False)
     display_parent_desc = options.get("parent-desc", True)
+    display_field_value = options.get("field-value", False)
     indent = " " * (3*depth)
     addr = field_set.absolute_address
     text = "%s--- %s ---" % (indent, field_set.name) 
@@ -36,8 +37,9 @@
                 else:
                     assert (field.address % 8) == 0
                     text += "%u" % (field.address/8)
-                text += ") %s = %s" % \
-                    (field._name, field.display)
+                text += ") %s" % field.name
+                if display_field_value:
+                    text += "= %s" % field.display
                 if field.description != None:
                     text += ": %s" % field.description
                 if display_bits:

Modified: haypo/hachoir/branches/hachoir-yield/write.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/write.py	2006-03-14 22:52:51 UTC (rev 452)
+++ haypo/hachoir/branches/hachoir-yield/write.py	2006-03-15 00:11:00 UTC (rev 453)
@@ -20,7 +20,7 @@
     print "Set has_comment=True: done"
 
     output = FileOutputStream("/home/haypo/new.gz")
-    gzip.writeInto(output)
-#    displayFieldSet(gzip)
+#    gzip.writeInto(output)
+    displayFieldSet(gzip)
     
 main()



From haypo at berlios.de  Wed Mar 15 01:16:32 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 15 Mar 2006 01:16:32 +0100
Subject: [Happyboom-svn] r454 - haypo/hachoir/branches/hachoir-yield/libhachoir
Message-ID: <200603150016.k2F0GWOJ010446@sheep.berlios.de>

Author: haypo
Date: 2006-03-15 01:16:16 +0100 (Wed, 15 Mar 2006)
New Revision: 454

Modified:
   haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
Log:
Move _index attribute and indexOf() method from OrderedDict() to IndexedDict()


Modified: haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py
===================================================================
--- haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-15 00:11:00 UTC (rev 453)
+++ haypo/hachoir/branches/hachoir-yield/libhachoir/indexed_dict.py	2006-03-15 00:16:16 UTC (rev 454)
@@ -10,7 +10,6 @@
     def __init__(self):
         self._dict = {}         # key => value
         self._value_list = []   # index => value
-        self._index = {}        # key => index
 
     def getByIndex(self, index):
         return self._value_list[index]
@@ -18,14 +17,10 @@
     def __getitem__(self, key):
         return self._dict[key]
 
-    def indexOf(self, key):
-        return self._index[key]
-
     def append(self, key, value):
         if key in self._dict:
             raise UniqKeyError("Key '%s' already exists" % key)
         self._dict[key] = value
-        self._index[key] = len(self._value_list)
         self._value_list.append(value)
 
     def __len__(self):
@@ -40,15 +35,21 @@
 class IndexedDict(OrderedDict):
     """
     This class is based on OrderedDict(), but add new methods:
-     * insert(index, key, value) 
-     * __delitem__(index)
+      * indexOf(key)
+      * insert(index, key, value) 
+      * __delitem__(index)
     """
     
     def __init__(self):
         self._key_list = []     # index => key, needed by insert
+        self._index = {}        # key => index
 
+    def indexOf(self, key):
+        return self._index[key]
+
     def append(self, key, value):
         OrderedDict.append(key, value)
+        self._index[key] = len(self._value_list)-1
         self._key_list.append(key)
         
     def __delitem__(self, index):



