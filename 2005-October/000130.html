<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Happyboom-svn] r222 - / haypo haypo/hachoir haypo/hachoir/plugins
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/happyboom-svn/2005-October/index.html" >
   <LINK REL="made" HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r222%20-%20/%20haypo%20haypo/hachoir%20haypo/hachoir/plugins&In-Reply-To=%3C200510272230.j9RMUXbj014902%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000128.html">
   <LINK REL="Next"  HREF="000129.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Happyboom-svn] r222 - / haypo haypo/hachoir haypo/hachoir/plugins</H1>
    <B>Victor STINNER at BerliOS</B> 
    <A HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r222%20-%20/%20haypo%20haypo/hachoir%20haypo/hachoir/plugins&In-Reply-To=%3C200510272230.j9RMUXbj014902%40sheep.berlios.de%3E"
       TITLE="[Happyboom-svn] r222 - / haypo haypo/hachoir haypo/hachoir/plugins">haypo at berlios.de
       </A><BR>
    <I>Fri Oct 28 00:30:33 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000128.html">[Happyboom-svn] r221 - / haypo trouphp
</A></li>
        <LI>Next message: <A HREF="000129.html">[Happyboom-svn] r223 - haypo/hachoir/plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#130">[ date ]</a>
              <a href="thread.html#130">[ thread ]</a>
              <a href="subject.html#130">[ subject ]</a>
              <a href="author.html#130">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: haypo
Date: 2005-10-28 00:30:32 +0200 (Fri, 28 Oct 2005)
New Revision: 222

Added:
   haypo/hachoir/
   haypo/hachoir/Makefile
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/
   haypo/hachoir/plugins/exe.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/ncftp.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/stream.py
   haypo/lamer/
Removed:
   lamer/
Log:
Add hachoir project, move lamer into haypo subdir.


Added: haypo/hachoir/Makefile
===================================================================
--- haypo/hachoir/Makefile	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/Makefile	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,2 @@
+clean:
+	rm -f *.pyc plugins/*.pyc

Added: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/filter.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,119 @@
+&quot;&quot;&quot;
+Base class for all splitter filters.
+&quot;&quot;&quot;
+
+import struct
+import re
+import sys
+import types
+import string
+
+class Filter:
+    def __init__(self, stream, parent=None):
+        self._sub_struct = {}
+        self.stream = stream
+        self.parent = parent
+        if self.parent:
+            self.depth = parent.depth + 1
+        else:
+            self.depth = 1
+        self.indent = &quot; &quot; * ((self.depth-1)*2)
+        self.child_indent = &quot; &quot; * (self.depth*2)
+
+    def __replaceFieldFormat(self, match):
+        return str(getattr(self, match.group(1)))
+
+    def openChild(self):
+        self.__child_stream_pos = self.stream.tell()
+
+    def closeChild(self, text):
+        if display_filter_actions != self.depth: return
+        size = self.stream.tell() - self.__child_stream_pos
+        sys.stdout.write(&quot;%s&lt;%s (%u bytes)&gt;\n&quot; % (self.indent, text, size))
+
+    def newChild(self, text):
+        if display_filter_actions &lt; self.depth+1: return
+        sys.stdout.write(&quot;%s[ %s ]\n&quot; % (self.child_indent, text))
+
+    def __isStrPrintable(self, str):
+        &quot;&quot;&quot;
+        Can a string be printed on the screen?
+        &quot;&quot;&quot;
+        for c in str:
+            if c not in string.printable: return False
+        return True
+
+    def readField(self, id, description, delimiter):
+        lg = self.stream.searchLength(delimiter, False)
+        if lg == -1:
+            raise Exception(&quot;Delimiter \&quot;%s\&quot; not found for %s (%s)!&quot; % (delimiter, id, description))
+        self.read(id, &quot;!%us&quot; % lg, description) 
+        self.read(None, &quot;!%us&quot; % len(delimiter), &quot;Delimiter of %s&quot; % id) 
+
+    def searchEol(self, eol):
+        lg = self.stream.searchLength(eol, True)
+        if lg == -1:
+            return self.stream.getLastPos() - self.stream.tell()
+        else:
+            return lg
+
+    def readLine(self, id, description, eol=&quot;\n&quot;, fails_if_not_found=False, can_truncate=False):
+        lg = self.searchEol(eol)
+        self.read(id, &quot;!%us&quot; % lg, description, can_truncate)
+        line = getattr(self, id)
+        setattr(self, id, line[:-len(eol)])
+        
+    def read(self, id, format, description, can_truncate=True):
+        format = re.sub(r'\[([^]]+)\]', self.__replaceFieldFormat, format)
+        size = struct.calcsize(format)
+        max = 80 
+        if size&lt;max or format[-1] != &quot;s&quot; or not can_truncate:
+            rawdata = self.stream.getN(size)
+            assert len(rawdata) == size
+            data = struct.unpack(format, rawdata)
+            data = data[0]
+        else:
+            rawdata = self.stream.getN(max)
+            assert len(rawdata) == max
+            data = rawdata + &quot;(...)&quot;
+            self.stream.seek( self.stream.tell() + size - max )
+        # Display content ?
+        if self.depth &lt;= display_filter_actions and 0&lt;size:
+            # Write indentation
+            sys.stdout.write(self.indent)
+
+            # Write first 4 bytes in hexadecimal
+            i = 0
+            for byte in rawdata:
+                # If there are more than 4 bytes, write &quot;...&quot;
+                if 4 &lt;= i:
+                    sys.stdout.write(&quot;.. &quot;)
+                    i = i + 1
+                    break
+                sys.stdout.write(&quot;%02X &quot; % ord(byte))
+                i = i + 1
+
+            # Align text to 4 bytes
+            sys.stdout.write(&quot;   &quot; * (5-i))
+
+            # Write description
+            sys.stdout.write(&quot;%s (%u bytes)&quot; % (description, size))
+
+            # Write content like id=value?
+            if id != None:
+                t = type(data)
+                if t==types.IntType or t==types.LongType:
+                    # Display integers
+                    sys.stdout.write(&quot;, %s = %u&quot; % (id, data))
+                elif type(data)==types.StringType and len(data)&lt;max:
+                    # Display string (replace ASCII &lt; 32 by \xCC)
+                    display = re.sub(&quot;([\x00-\x1F])&quot;, lambda m: &quot;\\x%02X&quot; % ord(m.group(1)), data)
+                    if self.__isStrPrintable(display):
+                        sys.stdout.write(&quot;, %s=\&quot;%s\&quot;&quot; % (id, display))
+            sys.stdout.write(&quot;\n&quot;)
+
+        # Save result in the object
+        if id != None:
+            setattr(self, id, data)
+
+display_filter_actions = 1

Added: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/hachoir.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,131 @@
+#!/usr/bin/python
+&quot;&quot;&quot;
+Splitter: tool to split a binary file into human readable data.
+Because it's written in Python, it would be easy to write new plugins
+(supports new file format).
+
+Author: Victor Stinner
+&quot;&quot;&quot;
+
+PROGRAM=&quot;Hachoir&quot;
+VERSION=&quot;2005-10-27&quot;
+
+import sys, os, re, traceback
+from stream import FileStream
+import filter
+from plugin import getPlugin
+
+def usage(defval):
+    print &quot;%s version %s&quot; % (PROGRAM, VERSION)
+    print &quot;&quot;
+    print &quot;Usage: %s [options] file&quot; % (sys.argv[0])
+    print &quot;&quot;
+    print &quot;Options:&quot;
+    print &quot;\t--help            : Show this help&quot;
+    print &quot;\t--version         : Show the program version&quot;
+    print &quot;\t--verbose         : Activate verbose mode&quot;
+    print &quot;\t--depth NB        : Detail depth (default %u)&quot; % (defval[&quot;depth&quot;])
+    print &quot;\t--no-display      : Hide result&quot;
+
+def parseArgs(val):
+    import getopt
+    def_val = val.copy()
+    
+    try:
+        short = &quot;&quot;
+        long = [&quot;no-display&quot;, &quot;verbose&quot;, &quot;help&quot;, &quot;version&quot;, &quot;depth=&quot;]
+        opts, args = getopt.getopt(sys.argv[1:], short, long)
+    except getopt.GetoptError:
+        usage(def_val)
+        sys.exit(2)
+   
+    if len(args) != 1:
+        usage(def_val)
+        sys.exit(2)
+        
+    for o, a in opts:
+        if o == &quot;--help&quot;:
+            usage(def_val)
+            sys.exit()
+        if o == &quot;--version&quot;:
+            print &quot;%s version %s&quot; % (PROGRAM, VERSION)
+            sys.exit()
+        if o == &quot;--no-display&quot;:
+            val[&quot;display&quot;] = False
+        if o == &quot;--depth&quot;:
+            val[&quot;depth&quot;] = int(a)
+        if o == &quot;--verbose&quot;:
+            val[&quot;verbose&quot;] = True
+    return (val, args[0],)
+
+class Hachoir:
+    def __init__(self):
+        self.verbose = False
+        self.display = True
+        self.depth = 5
+
+    def run(self, filename):
+        # Look for a plugin
+        plugin = getPlugin(filename)
+        if plugin != None:
+            regex, plugin_name, split_func, display_func = plugin
+            if self.verbose:
+                print &quot;Split file \&quot;%s\&quot;: %s.&quot; % (filename, plugin_name)
+            
+            # Create stream
+            stream = FileStream(filename)
+
+            # Split 
+            filter.display_filter_actions = self.depth
+            if 0 &lt; self.depth:
+                print &quot;=== Split file %s ===&quot; % filename
+            split = split_func(stream)
+            if 0 &lt; self.depth:
+                print &quot;&quot;
+
+            # Display
+            if self.display:
+                print &quot;=== File %s data ===&quot; % filename
+                display_func(split)
+        else:
+            print &quot;No suitable plugin for \&quot;%s\&quot;.&quot; % (filename)
+            sys.exit(1)
+
+def main():
+    try:        
+        import imp
+        plugins_dir = os.path.join(os.path.dirname(__file__), &quot;plugins&quot;)
+        plugins_files = os.listdir(plugins_dir)
+        file_py = re.compile(&quot;^([a-z0-9_]+)\.py$&quot;)
+        modules = []
+        for file in plugins_files:
+            m = file_py.match(file)
+            if m != None:
+                module = &quot;plugins.&quot;+m.group(1)
+                __import__(module)
+                modules.append(m.group(1))
+        print &quot;Loaded: %u plugings (%s)&quot; % (len(modules), &quot;, &quot;.join(modules))
+
+        opt = {
+            &quot;depth&quot;: 2,
+            &quot;verbose&quot;: False,
+            &quot;display&quot;: True
+        }
+        if len(sys.argv) &lt; 2:
+            usage(opt)
+            sys.exit(1)
+
+        opt, filename = parseArgs(opt)
+
+        hachoir = Hachoir()
+        for key in opt:
+            setattr(hachoir, key, opt[key])
+        hachoir.run(filename)
+    except SystemExit:
+        pass
+    except Exception, err:
+        print &quot;Exception:\n%s&quot; % (err)
+        print &quot;&quot;.join(traceback.format_exception( \
+            sys.exc_type, sys.exc_value, sys.exc_traceback))
+
+if __name__==&quot;__main__&quot;: main()    


Property changes on: haypo/hachoir/hachoir.py
___________________________________________________________________
Name: svn:executable
   + *

Added: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/plugin.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,14 @@
+import re
+
+def getPlugin(filename):
+    global hachoir_plugins
+    for plugin in hachoir_plugins:
+        if plugin[0].match(filename) != None: return plugin
+    return None
+    
+def registerPlugin(regex, name, splitFunc, displayFunc):
+    global hachoir_plugins
+    regex = re.compile(regex)
+    hachoir_plugins.append( (regex, name, splitFunc, displayFunc,) )
+
+hachoir_plugins = [] 

Added: haypo/hachoir/plugins/exe.py
===================================================================
--- haypo/hachoir/plugins/exe.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/plugins/exe.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,233 @@
+&quot;&quot;&quot;
+EXE filter.
+
+Status: alpha 
+Author: Victor Stinner
+&quot;&quot;&quot;
+
+from filter import Filter
+from plugin import registerPlugin
+
+def displayPE(pe):
+    print &quot;[ PE HEADER ]&quot;
+    print &quot;Architecture: %s&quot; % pe.getCpuType()
+            
+def displayPE_Section(section):
+    print &quot;-&gt; Section %- 8s: size=%u, rva=%08X&quot; % \
+        (section.name, section.size, section.rva)
+
+def displayPE_Resource(res):
+    print &quot;Resource: id=%u&quot; % \
+        (res.id)
+        
+def displayPE_ResourceDirectory(res):
+    print &quot;Resources: nb_entries = %u + %s&quot; % \
+        (res.named_entries, res.indexed_entries)
+    for item in res.items:
+        displayPE_Resource(item)
+
+def displayExe(exe):
+    print &quot;[ MS-DOS HEADER ]&quot;
+    print &quot;Init. SS:SP: %04X:%04X&quot; % \
+        (exe.init_ss_sp &amp; 0xFFFF,
+         exe.init_ss_sp &gt;&gt; 16 &amp; 0xFFFF)
+    if exe.pe:
+#        displayPE(exe.pe)
+        for section in exe.pe_sections:
+            displayPE_Section(section)
+        for res in exe.pe_resources:
+            displayPE_ResourceDirectory(res)
+            
+class PE_ResourceData(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;Offset&quot;)
+        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
+        self.read(&quot;page_code&quot;, &quot;&lt;L&quot;, &quot;Page code (language)&quot;)
+        self.read(&quot;language&quot;, &quot;&lt;l&quot;, &quot;Page code (language)&quot;)
+        self.language = -self.language
+        self.read(None, &quot;!L&quot;, &quot;Reserverd&quot;)
+
+        oldpos = stream.tell()
+        
+        #stream.seek(XXX + self.offset - self.offset_res_section)
+        stream.seek(self.offset)
+        stream.seek(oldpos)
+
+class PE_ResourceEntry(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;id&quot;, &quot;&lt;L&quot;, &quot;ID or name&quot;)
+        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;Offset&quot;)
+        
+class PE_ResourceDirectory(Filter):
+    def __init__(self, stream, parent, offset_res_section):
+        Filter.__init__(self, stream, parent)
+        self.offset_res_section = offset_res_section
+        self.read(&quot;option&quot;, &quot;&lt;L&quot;, &quot;Options&quot;)
+        self.read(&quot;creation_date&quot;, &quot;&lt;L&quot;, &quot;Creation date&quot;)
+        self.read(&quot;maj_ver&quot;, &quot;&lt;H&quot;, &quot;Major version&quot;)
+        self.read(&quot;named_entries&quot;, &quot;&lt;H&quot;, &quot;Named entries&quot;)
+        self.read(&quot;indexed_entries&quot;, &quot;&lt;H&quot;, &quot;Indexed entries&quot;)
+        nb_entries = self.named_entries + self.indexed_entries
+        self.openChild()
+
+        stream.seek( stream.tell() + 0x10)
+        self.items = []
+        for i in range(nb_entries):
+            self.newChild(&quot;Resource&quot;)
+            self.items.append( PE_ResourceEntry(stream,self) )
+        self.closeChild(&quot;Resources&quot;)
+
+class PE_Section(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;name&quot;, &quot;8s&quot;, &quot;Name&quot;)
+        self.name = self.name.strip(&quot;\0&quot;)
+        self.read(&quot;rva&quot;, &quot;&lt;L&quot;, &quot;RVA&quot;)
+        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
+        self.read(&quot;file_size&quot;, &quot;&lt;L&quot;, &quot;File size&quot;)
+        self.read(&quot;file_offset&quot;, &quot;&lt;L&quot;, &quot;File offset&quot;)
+        self.read(&quot;reloc_ptr&quot;, &quot;&lt;L&quot;, &quot;Relocation pointer&quot;)
+        self.read(&quot;lines_ptr&quot;, &quot;&lt;L&quot;, &quot;File line numbers pointer&quot;)
+        self.read(&quot;nb_reloc&quot;, &quot;&lt;H&quot;, &quot;Number of relocations&quot;)
+        self.read(&quot;nb_lines&quot;, &quot;&lt;H&quot;, &quot;Number of file line&quot;)
+        self.read(&quot;options&quot;, &quot;&lt;L&quot;, &quot;Options&quot;)
+
+class PE_Directory(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size&quot;)
+        self.read(&quot;rva&quot;, &quot;&lt;L&quot;, &quot;RVA&quot;)
+
+class PE_OptionnalHeader(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;header&quot;, &quot;&lt;H&quot;, &quot;Header&quot;)
+        assert self.header == 0x010B
+        self.read(&quot;linker_maj_ver&quot;, &quot;B&quot;, &quot;Linker major version&quot;)
+        self.read(&quot;linker_min_ver&quot;, &quot;B&quot;, &quot;Linker minor version&quot;)
+        self.read(&quot;code_size&quot;, &quot;&lt;L&quot;, &quot;Code size (bytes)&quot;)
+        self.read(&quot;data_size&quot;, &quot;&lt;L&quot;, &quot;Data size (bytes)&quot;)
+        self.read(&quot;heap_size&quot;, &quot;&lt;L&quot;, &quot;Heap size (bytes)&quot;)
+        self.read(&quot;entry_point_rva&quot;, &quot;&lt;L&quot;, &quot;Entry point offset (RVA)&quot;)
+        self.read(&quot;code_rva&quot;, &quot;&lt;L&quot;, &quot;Code offset (RVA)&quot;)
+        self.read(&quot;data_rva&quot;, &quot;&lt;L&quot;, &quot;Data offset (RVA)&quot;)
+        self.read(&quot;base_image_rva&quot;, &quot;&lt;L&quot;, &quot;Base image offset (RVA)&quot;)
+        self.read(&quot;memory_alignment&quot;, &quot;&lt;L&quot;, &quot;Memory alignment&quot;)
+        self.read(&quot;file_alignment&quot;, &quot;&lt;L&quot;, &quot;File alignment&quot;)
+        self.read(&quot;os_maj_ver&quot;, &quot;&lt;H&quot;, &quot;OS major version&quot;)
+        self.read(&quot;os_min_ver&quot;, &quot;&lt;H&quot;, &quot;OS minor version&quot;)
+        self.read(&quot;prog_maj_ver&quot;, &quot;&lt;H&quot;, &quot;Program major version&quot;)
+        self.read(&quot;prog_min_ver&quot;, &quot;&lt;H&quot;, &quot;Program minor version&quot;)
+        self.read(&quot;api_maj_ver&quot;, &quot;&lt;H&quot;, &quot;API major version?!&quot;)
+        self.read(&quot;api_min_ver&quot;, &quot;&lt;H&quot;, &quot;API minor version?!&quot;)
+        self.read(&quot;windows_ver&quot;, &quot;&lt;L&quot;, &quot;Windows version?!&quot;)
+        self.read(&quot;image_size&quot;, &quot;&lt;L&quot;, &quot;Image size&quot;)
+        self.read(&quot;headers_size&quot;, &quot;&lt;L&quot;, &quot;Headers size&quot;)
+        self.read(&quot;checksum&quot;, &quot;&lt;L&quot;, &quot;Checkum&quot;)
+        self.read(&quot;neeed_api&quot;, &quot;&lt;H&quot;, &quot;Needed API?!&quot;)
+        self.read(&quot;dll_options&quot;, &quot;&lt;H&quot;, &quot;DLL options (only for DLL)&quot;)
+        self.read(&quot;reserved_stack_size&quot;, &quot;&lt;L&quot;, &quot;Reserved stack size&quot;)
+        self.read(&quot;common_stack_size&quot;, &quot;&lt;L&quot;, &quot;Common stack size&quot;)
+        self.read(&quot;reserved_heap_size&quot;, &quot;&lt;L&quot;, &quot;Reserved heap size&quot;)
+        self.read(&quot;common_heap_size&quot;, &quot;&lt;L&quot;, &quot;Common heap size&quot;)
+        self.read(&quot;loader_options&quot;, &quot;&lt;L&quot;, &quot;Loader options&quot;)
+        self.read(&quot;nb_directories&quot;, &quot;&lt;L&quot;, &quot;Number of directories (16)&quot;)
+        assert self.nb_directories == 16
+        self.directories = []
+        self.openChild()
+        for i in range(self.nb_directories):
+            self.newChild(&quot;PE directory&quot;)            
+            self.directories.append( PE_Directory(stream, self) )
+        self.closeChild(&quot;PE directories&quot;)            
+
+class PE_Filter(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;header&quot;, &quot;4s&quot;, &quot;File header&quot;)
+        assert self.header == &quot;PE\0\0&quot;
+        self.read(&quot;cpu_type&quot;, &quot;&lt;H&quot;, &quot;CPU type&quot;)
+        self.read(&quot;nb_sections&quot;, &quot;&lt;H&quot;, &quot;Number of sections&quot;)
+        self.read(&quot;creation_date&quot;, &quot;&lt;L&quot;, &quot;Creation date&quot;)
+        self.read(&quot;ptr_to_symbols&quot;, &quot;&lt;L&quot;, &quot;Pointer to symbol table&quot;)
+        self.read(&quot;nb_symbols&quot;, &quot;&lt;L&quot;, &quot;Number of symbols&quot;)
+        self.read(&quot;opt_header_size&quot;, &quot;&lt;H&quot;, &quot;Optionnal header size&quot;)
+        self.read(&quot;options&quot;, &quot;&lt;H&quot;, &quot;Options&quot;)
+
+    def getCpuType(self):
+        cpu_name = {
+            0x014C: &quot;Intel 80386 or greater&quot;,
+            0x014D: &quot;Intel 80486 or greater&quot;,
+            0x014E: &quot;Intel Pentium or greader&quot;, 
+            0x0160: &quot;R3000 (MIPS), big endian&quot;,
+            0x0162: &quot;R3000 (MIPS), little endian&quot;,
+            0x0166: &quot;R4000 (MIPS), little endian&quot;,
+            0x0168: &quot;R10000 (MIPS), little endian&quot;,
+            0x0184: &quot;DEC Alpha AXP&quot;,
+            0x01F0: &quot;IBM Power PC, little endian&quot;}
+        return cpu_name.get(self.cpu_type, &quot;unknow&quot;)
+
+class ExeFilter(Filter):
+    def __init__(self, stream):
+        Filter.__init__(self, stream)
+        self.read(&quot;header&quot;, &quot;2s&quot;, &quot;File header&quot;)
+        assert self.header == &quot;MZ&quot;
+        self.read(&quot;filesize_mod_512&quot;, &quot;&gt;H&quot;, &quot;Filesize mod 512&quot;)
+        self.read(&quot;filesize_div_512&quot;, &quot;&gt;H&quot;, &quot;Filesize div 512&quot;)
+        self.filesize = self.filesize_div_512 * 512 + self.filesize_mod_512
+        self.read(&quot;reloc_entries&quot;, &quot;&gt;H&quot;, &quot;Number of relocation entries&quot;)
+        self.read(&quot;code_offset&quot;, &quot;&lt;H&quot;, &quot;Offset to the code in the file (div 16)&quot;)
+        self.code_offset = self.code_offset * 16
+        self.read(&quot;needed_memory&quot;, &quot;&gt;H&quot;, &quot;Memory needed to run (div 16)&quot;)
+        self.needed_memory = self.needed_memory * 16
+        self.read(&quot;max_memory&quot;, &quot;&gt;H&quot;, &quot;Maximum memory needed to run (div 16)&quot;)
+        self.max_memory = self.max_memory * 16
+        self.read(&quot;init_ss_sp&quot;, &quot;&gt;L&quot;, &quot;Initial value of SP:SS registers.&quot;)
+        self.read(&quot;checksum&quot;, &quot;&gt;H&quot;, &quot;Checksum&quot;)
+        self.read(&quot;init_cs_ip&quot;, &quot;&gt;L&quot;, &quot;Initial value of CS:IP registers.&quot;)
+        self.read(&quot;reloc_offset&quot;, &quot;&lt;H&quot;, &quot;Offset in file to relocation table.&quot;)
+        self.read(&quot;overlay_number&quot;, &quot;&gt;H&quot;, &quot;Overlay number&quot;)
+        self.read(None, &quot;&gt;4H&quot;, &quot;Reserverd&quot;)
+        self.read(&quot;oem_id&quot;, &quot;&gt;H&quot;, &quot;OEM id&quot;)
+        self.read(&quot;oem_info&quot;, &quot;&gt;H&quot;, &quot;OEM info&quot;)
+        self.read(None, &quot;!10H&quot;, &quot;Reserved&quot;)
+        self.read(&quot;pe_offset&quot;, &quot;&lt;L&quot;, &quot;Offset to PE header&quot;)
+
+        if self.reloc_offset == 0x40:
+            self.openChild()
+            self.newChild(&quot;PE header&quot;)
+            self.stream.seek(self.pe_offset)
+            self.pe = PE_Filter(stream, self)
+            self.closeChild(&quot;PE header&quot;)
+
+            self.openChild()
+            self.newChild(&quot;PE optionnal header&quot;)            
+            self.pe_optionnal_header = PE_OptionnalHeader(stream, self)
+            self.closeChild(&quot;PE optionnal header&quot;)            
+
+            self.openChild()
+            self.pe_sections = []
+            for i in range(self.pe.nb_sections):
+                self.newChild(&quot;PE section&quot;)            
+                self.pe_sections.append( PE_Section(stream, self) )
+            self.closeChild(&quot;PE sections&quot;)     
+
+            # Look for resource section
+            self.pe_resources = []
+            offset_res_section = None
+            for section in self.pe_sections:
+                if section.name == &quot;.rsrc&quot;:
+                    offset_res_section = section.file_offset
+                    self.stream.seek( offset_res_section )
+                    break
+            if offset_res_section != None:
+                self.openChild()
+                for i in range(1): #range(self.pe.nb_sections):
+                    self.newChild(&quot;PE resource header&quot;)            
+                    self.pe_resources.append( PE_ResourceDirectory(stream, self, offset_res_section) )
+                self.closeChild(&quot;PE resources header&quot;)            
+        else:
+            self.pe = None
+
+registerPlugin(&quot;^.*\.(exe|EXE)$&quot;, &quot;MS-Dos / Windows filter&quot;, ExeFilter, displayExe)

Added: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/plugins/gif.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,132 @@
+&quot;&quot;&quot;
+GIF splitter.
+
+Status: only loads header, and is buggy ...
+Author: Victor Stinner
+&quot;&quot;&quot;
+
+from filter import Filter
+from plugin import registerPlugin
+
+def displayGif(gif):
+    print &quot;Format: %s&quot; % (gif.header)
+    print &quot;Size: %ux%u&quot; % (gif.screen.width, gif.screen.height)
+    print &quot;Colormap: %s&quot; % (gif.color_map)
+    for image in gif.images:
+        print image
+
+class GifColor(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;red&quot;, &quot;!B&quot;, &quot;Red&quot;)
+        self.read(&quot;green&quot;, &quot;!B&quot;, &quot;Green&quot;)
+        self.read(&quot;blue&quot;, &quot;!B&quot;, &quot;Blue&quot;)
+
+class GifImage(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;left&quot;, &quot;!H&quot;, &quot;Left&quot;)
+        self.read(&quot;top&quot;, &quot;!H&quot;, &quot;Top&quot;)
+        self.read(&quot;width&quot;, &quot;!H&quot;, &quot;Width&quot;)
+        self.read(&quot;height&quot;, &quot;!H&quot;, &quot;Height&quot;)
+
+        # TODO: Fix this ...
+        self.read(&quot;flags&quot;, &quot;!H&quot;, &quot;Flags&quot;)
+        self.global_map = ((self.flags &amp; 0x80) == 0x80)
+        self.interlaced = ((self.flags &amp; 0x40) == 0x40)
+        self.bits_per_pixel = 1 + (self.flags &amp; 0x07)
+        if not self.global_map:
+            self.local_map = GifColorMap(stream, 1 &lt;&lt; self.bits_per_pixel, self)
+        else:
+            self.local_map = None
+        # -- End of TODO
+
+    def __str__(self):
+        return &quot;Gif image &lt;position=(%u,%u), size=%ux%u, bits/pixel=%u&gt;&quot; % \
+            (self.left, self.top,
+             self.width, self.height,
+             self.bits_per_pixel)
+     
+class GifColorMap(Filter):
+    def __init__(self, stream, nb_colors, parent):
+        Filter.__init__(self, stream, parent)
+        self.map = []
+        self.openChild()
+        for i in range(0, nb_colors):
+            self.newChild(&quot;Color&quot;)
+            self.map.append( GifColor(stream, self) )
+        self.closeChild(&quot;Colors&quot;)
+
+    def __str__(self):
+        return &quot;Gif colormap &lt;colors=%u&gt;&quot; % (len(self.map))
+        
+class GifExtensionChunk(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;size&quot;, &quot;!B&quot;, &quot;Size (in bytes)&quot;)
+        self.read(&quot;content&quot;, &quot;![size]s&quot;, &quot;Content&quot;)
+
+class GifExtension(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;func&quot;, &quot;!B&quot;, &quot;Function&quot;)
+        self.chunks = []
+        self.openChild()
+        while True:
+            self.newChild(&quot;Extension chunk&quot;)
+            chunk = GifExtensionChunk(stream, self)
+            self.chunks.append( chunk )
+            if chunk.size == 0: break 
+        self.closeChild(&quot;Extension chunk&quot;)
+        
+class GifScreenDescriptor(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;width&quot;, &quot;!H&quot;, &quot;Width&quot;)
+        self.read(&quot;height&quot;, &quot;!H&quot;, &quot;Height&quot;)
+
+        # TODO: Fix this
+        self.read(&quot;flags&quot;, &quot;!B&quot;, &quot;Flags&quot;)
+        self.global_map = ((self.flags &amp; 0x80) == 0x80) # ok
+        self.color_res = 1 + ((self.flags &gt;&gt; 4) &amp; 0x7) # ??
+        self.bits_per_pixel = 1 + (self.flags &amp; 0x7) # ok
+        # -- End of TODO
+        
+        self.background = stream.get8()
+        zero = stream.get8()
+        
+class GifFilter(Filter):
+    def __init__(self, stream):
+        Filter.__init__(self, stream)
+        # Header
+        self.read(&quot;header&quot;, &quot;6s&quot;, &quot;File header&quot;)
+        assert (self.header == &quot;GIF87a&quot;) or (self.header == &quot;GIF89a&quot;)
+        self.newChild(&quot;Screen descriptor&quot;)
+        self.screen = GifScreenDescriptor(stream, self)
+        if self.screen.global_map:
+            self.newChild(&quot;Color map&quot;)
+            self.color_map = GifColorMap(stream, 1 &lt;&lt; self.screen.bits_per_pixel, self)
+        else:
+            self.color_map = None
+        self.images = []
+        self.extensions = []
+        while True:
+            self.read(&quot;code&quot;, &quot;c&quot;, &quot;Separator code&quot;)
+            if self.code == &quot;!&quot;:
+                self.openChild()
+                self.newChild(&quot;New extension&quot;)
+                self.extensions.append( GifExtension(stream, self) )
+                self.closeChild(&quot;Extension&quot;)
+            elif self.code == &quot;,&quot;:
+                self.openChild()
+                self.newChild(&quot;New image&quot;)
+                self.images.append( GifImage(stream, self) )
+                self.closeChild(&quot;Image&quot;)
+                return
+            elif self.code == &quot;;&quot;:
+                # GIF Terminator
+                return
+            else:
+                raise Exception(&quot;Wrong GIF image separator: ASCII %02X.&quot; % ord(self.code))
+
+registerPlugin(&quot;^.*\.(gif|GIF)$&quot;, &quot;GIF picture&quot;, GifFilter, displayGif)

Added: haypo/hachoir/plugins/ncftp.py
===================================================================
--- haypo/hachoir/plugins/ncftp.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/plugins/ncftp.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,52 @@
+&quot;&quot;&quot;
+Ncftp bookmarks filter.
+
+Status: Read most import fields.
+Author: Victor Stinner
+&quot;&quot;&quot;
+
+import re, base64
+from filter import Filter
+from plugin import registerPlugin
+from stream import LimitedFileStream
+
+def displayNcftp(data):
+    print &quot;Ncftp saved bookmarks:&quot;
+    for b in data.bookmarks:
+        print &quot;o %s (port %s): u=%s, p=\&quot;%s\&quot;&quot; % \
+            (b.server, b.port, b.username, b.password)
+
+class NcftpBookmark(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.readField(&quot;name&quot;, &quot;Bookmark name&quot;, &quot;,&quot;)
+        self.readField(&quot;server&quot;, &quot;Server name/ip&quot;, &quot;,&quot;)
+        self.readField(&quot;username&quot;, &quot;Username&quot;, &quot;,&quot;)
+        self.readField(&quot;password&quot;, &quot;Password&quot;, &quot;,&quot;)
+        self.readField(&quot;notused1&quot;, &quot;Not used (1)&quot;, &quot;,&quot;)
+        self.readField(&quot;last_dir&quot;, &quot;Last directory&quot;, &quot;,&quot;)
+        self.readField(&quot;notused3&quot;, &quot;Not used (3)&quot;, &quot;,&quot;)
+        self.readField(&quot;port&quot;, &quot;Server port&quot;, &quot;,&quot;)
+        self.readLine(&quot;eol&quot;, &quot;End of line&quot;, &quot;\n&quot;)
+        self.password = self.crackPass(self.password)
+        
+    def crackPass(self, password):
+        m = re.compile(&quot;^\*encoded\*(.*)$&quot;).match(password)
+        if m == None: return password
+        password = base64.decodestring(m.group(1))
+        return password.strip(&quot;\0&quot;)
+
+class NcftpFilter(Filter):
+    def __init__(self, stream):
+        Filter.__init__(self, stream)
+        self.readLine(&quot;header&quot;, &quot;Header (first line&quot;)
+        self.readLine(&quot;nb_bookmark&quot;, &quot;Number of bookmarks&quot;)
+
+        self.openChild()
+        self.bookmarks = []
+        while not self.stream.eof():
+            self.newChild(&quot;Bookmark&quot;)
+            self.bookmarks.append( NcftpBookmark(stream,self) )
+        self.closeChild(&quot;Bookmarks&quot;)
+        
+registerPlugin(&quot;^.*bookmarks$&quot;, &quot;NcFTP bookmarks&quot;, NcftpFilter, displayNcftp)

Added: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/plugins/png.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,136 @@
+&quot;&quot;&quot;
+PNG splitter.
+
+Status: split into chunks, can only resplit tIME chunk.
+Author: Victor Stinner
+&quot;&quot;&quot;
+
+from stream import StringStream, LimitedFileStream
+from filter import Filter
+from plugin import registerPlugin
+
+def displayPng(png):
+    for chunk in png.chunks:
+        if issubclass(chunk.data.__class__, Filter):
+            print chunk.data
+        else:
+            print &quot;(unknow chunk type \&quot;%s\&quot;)&quot; % chunk.type
+
+class PngHeader(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;width&quot;, &quot;!L&quot;, &quot;Width (pixels)&quot;)
+        self.read(&quot;height&quot;, &quot;!L&quot;, &quot;Height (pixels)&quot;)
+        self.read(&quot;bit_depth&quot;, &quot;!B&quot;, &quot;Bit depth&quot;)
+        self.read(&quot;color_type&quot;, &quot;!B&quot;, &quot;Color type&quot;)
+        self.read(&quot;compression_method&quot;, &quot;!B&quot;, &quot;Compression method&quot;)
+        self.read(&quot;filter_method&quot;, &quot;!B&quot;, &quot;Filter method&quot;)
+        self.read(&quot;interlace_method&quot;, &quot;!B&quot;, &quot;Interlace method&quot;)
+
+    def __str__(self):
+        return &quot;PNG header &lt;size=%ux%u, depth=%u bits/pixel&gt;&quot; % \
+            (self.width, self.height,
+             self.bit_depth)
+
+class PngPhysical(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;pixel_per_unit_x&quot;, &quot;!L&quot;, &quot;Pixel per unit, X axis&quot;)
+        self.read(&quot;pixel_per_unit_y&quot;, &quot;!L&quot;, &quot;Pixel per unit, Y axis&quot;)
+        self.read(&quot;unit_type&quot;, &quot;!B&quot;, &quot;Unit type&quot;)
+
+    def __str__(self):
+        if self.unit_type==&quot;0&quot;:
+            unit = &quot;unknow&quot;
+        else:
+            unit = &quot;meter&quot;
+        return &quot;PNG physical chunk &lt;pixel per unit=(%u,%u), unit=%s&gt;&quot; % \
+            (self.pixel_per_unit_x, self.pixel_per_unit_y, unit)
+
+class PngGamma(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;gamma&quot;, &quot;!L&quot;, &quot;Gamma (divided by 10,000)&quot;)
+        self.gamma = float(self.gamma)
+        self.gamma = self.gamma / 10000
+
+    def __str__(self):
+        return &quot;PNG gamma &lt;gamma=%0.2f&gt;&quot; % (self.gamma)
+
+class PngText(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        old = self.stream.tell()
+        pos = self.stream.search(&quot;\0&quot;, 14)
+        if pos == -1:
+            raise Exception(&quot;Fails to find end of text&quot;)
+        self.read(&quot;keyword&quot;, &quot;!%us&quot; % (pos-old), &quot;Keyword&quot;)
+        self.read(&quot;separator&quot;, &quot;!B&quot;, &quot;Null byte used to separe strings&quot;)
+        lg = self.stream.getEnd()-self.stream.tell()
+        self.read(&quot;text&quot;, &quot;!%us&quot; % lg, &quot;Text&quot;)
+
+    def __str__(self):
+        return &quot;PNG text &lt;keyword=\&quot;%s\&quot;, text=\&quot;%s\&quot;&gt;&quot; % \
+            (self.keyword, self.text)
+
+class PngTime(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;year&quot;, &quot;!H&quot;, &quot;Year&quot;)
+        self.read(&quot;month&quot;, &quot;!B&quot;, &quot;Month&quot;)
+        self.read(&quot;day&quot;, &quot;!B&quot;, &quot;Day&quot;)
+        self.read(&quot;hour&quot;, &quot;!B&quot;, &quot;Hour&quot;)
+        self.read(&quot;minute&quot;, &quot;!B&quot;, &quot;Minute&quot;)
+        self.read(&quot;second&quot;, &quot;!B&quot;, &quot;Second&quot;)
+
+    def __str__(self):
+        return &quot;PNG time chunk &lt;%04u-%02u-%02u %02u:%02u:%02u&gt;&quot; % \
+            (self.year, self.month, self.day,
+             self.hour, self.minute, self.second)
+
+class PngFilter(Filter):
+    &quot;&quot;&quot;
+    Split a PNG file into chunks.
+    &quot;&quot;&quot;
+
+    def __init__(self, stream):
+        Filter.__init__(self, stream)
+        self.read(&quot;header&quot;, &quot;8s&quot;, &quot;File header&quot;)
+        assert self.header == &quot;\x89\x50\x4E\x47\x0D\x0A\x1A\x0A&quot;
+        self.chunks = []
+        self.openChild()
+        while not self.stream.eof():
+            self.newChild(&quot;New chunk&quot;)
+            chunk = PngChunk(stream, parent=self)
+            self.chunks.append( chunk )
+
+        self.closeChild(&quot;Chunks&quot;)
+        
+class PngChunk(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;size&quot;, &quot;!L&quot;, &quot;Chunk size&quot;)
+        self.read(&quot;type&quot;, &quot;!4s&quot;, &quot;Chunk type&quot;)
+        self.chunk_splitter = {
+            &quot;tIME&quot;: PngTime,
+            &quot;pHYs&quot;: PngPhysical,
+            &quot;IHDR&quot;: PngHeader,
+            &quot;gAMA&quot;: PngGamma,
+            &quot;tEXt&quot;: PngText
+        }
+        if self.type in self.chunk_splitter:
+            self.openChild()
+            self.newChild(&quot;Decode chunk data (type %s)&quot; % self.type)
+            func = self.chunk_splitter[self.type]
+            new_stream = LimitedFileStream( self.stream.filename, self.stream.tell(), self.size )
+            self.data = func(new_stream, self)            
+            self.stream.seek(self.stream.tell() + self.size)
+            self.closeChild(&quot;Chunk data&quot;)
+        else:
+            self.read(&quot;data&quot;, &quot;![size]s&quot;, &quot;Chunk data&quot;)
+        self.read(&quot;crc32&quot;, &quot;!L&quot;, &quot;Chunk CRC32&quot;)
+
+    def __str__(self):
+        return &quot;PngChunk &lt;size=%u, type=%s&gt;&quot; % (self.size, self.type)
+
+registerPlugin(&quot;^.*\.(PNG|png)$&quot;, &quot;PNG picture&quot;, PngFilter, displayPng)

Added: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/plugins/zip.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,126 @@
+&quot;&quot;&quot;
+Zip splitter.
+
+Status: can read most important headers
+Author: Victor Stinner
+&quot;&quot;&quot;
+
+from filter import Filter
+from plugin import registerPlugin
+import sys
+
+def splitZip(stream):
+    return ZipFilter(stream)
+
+def displayZip(zip):    
+    print &quot;[ Zip archive ]&quot;
+    for file in zip.files:
+        sys.stdout.write (&quot;* File %s (size=%0.1f KB&quot; %
+            (file.filename, file.uncompressed_size / 1024))
+        if file.uncompressed_size != 0:
+            sys.stdout.write (&quot; - %0.1f%%&quot; % \
+                (100 - file.compressed_size * 100 / file.uncompressed_size))
+        sys.stdout.write (&quot;)\n&quot;)
+    print &quot;[ End of the zip archive ]&quot;
+
+class ZipCentralDirectory(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;version_made_by&quot;, &quot;&lt;H&quot;, &quot;Version made by&quot;)
+        self.read(&quot;version_needed&quot;, &quot;&lt;H&quot;, &quot;Version neede&quot;)
+        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;General purpose flag&quot;)
+        self.read(&quot;compression_method&quot;, &quot;&lt;H&quot;, &quot;Compression method&quot;)
+        self.read(&quot;last_mod_file_time&quot;, &quot;&lt;H&quot;, &quot;Last moditication file time&quot;)
+        self.read(&quot;last_mod_file_date&quot;, &quot;&lt;H&quot;, &quot;Last moditication file date&quot;)
+        self.read(&quot;crc32&quot;, &quot;&lt;L&quot;, &quot;CRC-32&quot;)
+        self.read(&quot;compressed_size&quot;, &quot;&lt;L&quot;, &quot;Compressed size&quot;)
+        self.read(&quot;uncompressed_size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size&quot;)
+        self.read(&quot;filename_length&quot;, &quot;&lt;H&quot;, &quot;Filename length&quot;)
+        self.read(&quot;extra_length&quot;, &quot;&lt;H&quot;, &quot;Extra fields length&quot;)
+        self.read(&quot;file_comment_length&quot;, &quot;&lt;H&quot;, &quot;File comment length&quot;)
+        self.read(&quot;disk_number_start&quot;, &quot;&lt;H&quot;, &quot;Disk number start&quot;)
+        self.read(&quot;internal_attr&quot;, &quot;&lt;H&quot;, &quot;Internal file attributes&quot;)
+        self.read(&quot;external_attr&quot;, &quot;&lt;L&quot;, &quot;External file attributes&quot;)
+        self.read(&quot;offset_header&quot;, &quot;&lt;L&quot;, &quot;Relative offset of local header&quot;)
+        self.read(&quot;filename&quot;, &quot;&lt;[filename_length]s&quot;, &quot;Filename&quot;)
+        self.read(&quot;extra&quot;, &quot;&lt;[extra_length]s&quot;, &quot;Extra fields&quot;)
+        self.read(&quot;file_comment&quot;, &quot;&lt;[file_comment_length]s&quot;, &quot;File comment&quot;)
+
+class ZipEndCentralDirectory(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;number_disk&quot;, &quot;&lt;H&quot;, &quot;Number of this disk&quot;)
+        self.read(&quot;number_disk2&quot;, &quot;&lt;H&quot;, &quot;Number of this disk2&quot;)
+        self.read(&quot;total_number_disk&quot;, &quot;&lt;H&quot;, &quot;Total number of entries&quot;)
+        self.read(&quot;total_number_disk2&quot;, &quot;&lt;H&quot;, &quot;Total number of entries2&quot;)
+        self.read(&quot;size&quot;, &quot;&lt;L&quot;, &quot;Size of the central directory&quot;)
+        self.read(&quot;offset&quot;, &quot;&lt;L&quot;, &quot;Offset of start of central directory&quot;)
+        self.read(&quot;comment_length&quot;, &quot;&lt;H&quot;, &quot;ZIP comment length&quot;)
+        self.read(&quot;comment&quot;, &quot;&lt;[comment_length]s&quot;, &quot;ZIP comment&quot;)
+
+#class ZipZip64(Filter):
+#    def __init__(self, stream, parent):
+#        Filter.__init__(self, stream, parent)
+#        self.read(&quot;size&quot;, &quot;&lt;Q&quot;, &quot;Directory size&quot;)
+#        self.read(&quot;version_made_by&quot;, &quot;&lt;H&quot;, &quot;Version made by&quot;)
+#        self.read(&quot;version_needed&quot;, &quot;&lt;H&quot;, &quot;Version neede&quot;)
+#        self.read(&quot;disk_index&quot;, &quot;&lt;L&quot;, &quot;Disk index&quot;)
+#        self.read(&quot;disk_index2&quot;, &quot;&lt;L&quot;, &quot;Disk index2&quot;)
+#        self.read(&quot;disk_number&quot;, &quot;&lt;Q&quot;, &quot;Disk number&quot;)
+#        self.read(&quot;disk_number2&quot;, &quot;&lt;Q&quot;, &quot;Disk number2&quot;)
+#        self.read(&quot;size2&quot;, &quot;&lt;Q&quot;, &quot;Directory size2&quot;)
+#        self.read(&quot;offset&quot;, &quot;&lt;Q&quot;, &quot;Offset&quot;)
+        
+class ZipFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, stream, parent)
+        self.read(&quot;version&quot;, &quot;&lt;H&quot;, &quot;Version&quot;)
+        self.read(&quot;flags&quot;, &quot;&lt;H&quot;, &quot;Flags&quot;)
+        self.read(&quot;compression_method&quot;, &quot;&lt;H&quot;, &quot;Compression method&quot;)
+        self.read(&quot;last_mod_time&quot;, &quot;&lt;H&quot;, &quot;Last modification time&quot;)
+        self.read(&quot;last_mod_date&quot;, &quot;&lt;H&quot;, &quot;Last modification date&quot;)
+        self.read(&quot;crc32&quot;, &quot;&lt;L&quot;, &quot;Checksum (CRC32)&quot;)
+        self.read(&quot;compressed_size&quot;, &quot;&lt;L&quot;, &quot;Compressed size (bytes)&quot;)
+        self.read(&quot;uncompressed_size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size (bytes)&quot;)
+        self.read(&quot;filename_length&quot;, &quot;&lt;H&quot;, &quot;Filename length&quot;)
+        self.read(&quot;extra_length&quot;, &quot;&lt;H&quot;, &quot;Extra length&quot;)
+        self.read(&quot;filename&quot;, &quot;&lt;[filename_length]s&quot;, &quot;Filename&quot;)
+        self.read(&quot;extra&quot;, &quot;&lt;[extra_length]s&quot;, &quot;Extra&quot;)
+        self.read(&quot;compressed_data&quot;, &quot;&lt;[compressed_size]s&quot;, &quot;Compressed data&quot;)
+        if (self.flags &amp; 4) == 4:
+            self.read(&quot;file_crc32&quot;, &quot;&lt;L&quot;, &quot;Checksum (CRC32)&quot;)
+            self.read(&quot;file_compressed_size&quot;, &quot;&lt;L&quot;, &quot;Compressed size (bytes)&quot;)
+            self.read(&quot;file_uncompressed_size&quot;, &quot;&lt;L&quot;, &quot;Uncompressed size (bytes)&quot;)
+        
+class ZipFilter(Filter):
+    def __init__(self, stream):
+        Filter.__init__(self, stream)
+        # File data
+        self.signature = None
+        self.central_directory = []
+        self.end_central_directory = None
+        self.files = []
+        while not stream.eof():
+            self.read(&quot;header&quot;, &quot;&lt;L&quot;, &quot;Header&quot;)
+            if self.header == 0x04034B50:
+                self.newChild(&quot;File entry&quot;)
+                self.openChild()
+                self.files.append( ZipFile(stream, self) )
+                self.closeChild(&quot;File entry&quot;)
+            elif self.header == 0x02014b50:
+                self.newChild(&quot;Central directory&quot;)
+                self.openChild()
+                self.central_directory.append( ZipCentralDirectory(stream,self) )
+                self.closeChild(&quot;Central directory&quot;)
+            elif self.header == 0x06054b50:
+                self.newChild(&quot;End of central directory&quot;)
+                self.openChild()
+                self.end_central_directory = ZipEndCentralDirectory(stream,self)
+                self.closeChild(&quot;End of central directory&quot;)
+            elif self.header == 0x05054b50:
+                self.read(&quot;signature_length&quot;, &quot;!H&quot;, &quot;Signature length&quot;)
+                self.read(&quot;signature&quot;, &quot;![signature_length]s&quot;, &quot;Signature&quot;)
+            else:
+                raise Exception(&quot;Error, unknow ZIP header (0x%08X).&quot; % self.header)
+        
+registerPlugin(&quot;^.*\.(zip|ZIP)$&quot;, &quot;ZIP (compressed archive)&quot;, splitZip, displayZip)

Added: haypo/hachoir/stream.py
===================================================================
--- haypo/hachoir/stream.py	2005-10-03 12:45:32 UTC (rev 221)
+++ haypo/hachoir/stream.py	2005-10-27 22:30:32 UTC (rev 222)
@@ -0,0 +1,173 @@
+import struct
+from StringIO import StringIO
+
+class Stream:
+    def __init__(self):
+        pass
+
+    def get16(self):
+        return None
+
+    def eof(self):
+        return self.getLastPos() &lt;= self.tell() 
+
+    def tell(self):
+        return 0
+
+    def searchLength(self, str, include_str, size_max=None):        
+        pos = self.search(str, size_max)
+        if pos == -1: return -1
+        lg = pos - self.tell()
+        if include_str: lg = lg + len(str)
+        return lg
+    
+    def search(self, str, size_max=None):
+        return -1
+
+def StringStream(data, endian=&quot;!&quot;):
+    file = StringIO(data)
+    return FileStream(file, endian)
+
+class LimitedFileStream(Stream):
+    def __init__(self, filename, start=0, size=0, endian=&quot;&lt;&quot;):
+        self.__stream = FileStream(filename)
+        if start&lt;0: start = 0
+        if self.__stream.getSize() &lt; start+size: size = self.__stream.getSize()-start
+        self.__start = start
+        self.__size = size
+        self.__end = self.__start + self.__size
+        self.__stream.seek(self.__start)
+
+    def search(self, str, size_max=None):
+        if self.__end == 0: return -1
+        if size_max == None or self.__end-self.tell() &lt; size_max:
+            size_max = self.__end-self.tell()
+        assert 0&lt;=size_max  and size_max&lt;=self.__size
+        return self.__stream.search(str, size_max)
+
+    def getN(self, size):
+        if self.__start+self.__size&lt;self.__stream.tell()+size:
+            raise Exception(&quot;Can't read outsize the stream.&quot;)
+        return self.__stream.getN(size)
+
+    def tell(self):
+        return self.__stream.tell()
+
+    def seek(self, pos, where=0):
+        return self.__stream.seek(pos, where)
+        
+    def getSize(self):
+        return self.__size
+    
+    def getLastPos(self):
+        return self.__end
+    
+class FileStream(Stream):
+    def __init__(self, filename, endian=&quot;&lt;&quot;):
+        &quot;&quot;&quot;
+        Endian: See setEndian function. 
+        &quot;&quot;&quot;
+
+        Stream.__init__(self)
+        self.__file = open(filename, 'r')
+        self.filename = filename
+        self.__file.seek(0,2) # Seek to end
+        self.__size = self.__file.tell()
+        self.__file.seek(0,0) # Seel to beginning
+        self.setEndian(endian)
+
+    def seek(self, pos, where=0):
+        &quot;&quot;&quot; Read file seek document to understand where. &quot;&quot;&quot;
+        return self.__file.seek(pos, where)
+
+    def tell(self):
+        return self.__file.tell()
+
+    def __doSearch(self, binary_string, pos_max):
+        &quot;&quot;&quot;
+        pos_max: Position of last tested byte
+        &quot;&quot;&quot;
+        # TODO: Use max ...
+        if 2048&lt;=len(binary_string):
+            raise Exception(&quot;Search string too big.&quot;)
+        size = 2048 
+        doublesize = size * 2
+        oldpos = self.tell()
+        if pos_max-oldpos+1&lt;doublesize:
+            doublesize = pos_max-oldpos
+            size = 0 
+        buffer = self.__file.read(doublesize)
+        newpos = oldpos + size
+        while len(buffer) != 0:
+            pos = buffer.find(binary_string)
+            if pos != -1: return oldpos + pos
+            oldpos = newpos
+            if pos_max &lt; oldpos + size:
+                size = pos_max - oldpos
+            if size == 0:
+                break
+            buffer = buffer[size:] + self.__file.read(size)
+            newpos = oldpos + size 
+        return -1 
+  
+    def search(self, binary_string, size_max=None):
+        if self.__size == 0: return -1
+        if size_max != None:
+            pos_max = self.tell()+size_max
+            if self.__size &lt;= pos_max:
+                pos_max = sel.__size-1
+        else:
+            pos_max = self.__size-1
+        assert 0&lt;=pos_max  and pos_max&lt;self.__size
+        oldpos = self.tell()
+        pos = self.__doSearch(binary_string, pos_max)
+        self.seek(oldpos)
+        return pos
+
+    def setEndian(self, endian):
+        &quot;&quot;&quot;
+        Endian: &quot;&lt;&quot; for little endian, &quot;&gt;&quot; for big endian, &quot;!&quot; for network endian.
+        &quot;&quot;&quot;
+
+        self.__endian = endian
+        self.__unpack8u = &quot;B&quot;
+        self.__unpack16u = &quot;%sH&quot; % self.__endian
+        self.__unpack32u = &quot;%sI&quot; % self.__endian
+
+    def get8(self):
+        data = self.__file.read(1)
+        data = struct.unpack(self.__unpack8u, data)
+        return data[0]
+
+    def get16(self):
+        data = self.__file.read(2)
+        data = struct.unpack(self.__unpack16u, data)
+        return data[0]
+
+    def get32(self):
+        data = self.__file.read(4)
+        data = struct.unpack(self.__unpack32u, data)
+        return data[0]
+
+    def getN(self, size):
+        data = self.__file.read(size)
+        # Do endian things
+        return data
+
+    def getEnd(self):
+        &quot;&quot;&quot;
+        Read everything until the end.
+        &quot;&quot;&quot;
+        
+        data = self.__file.read()
+        # Do endian things
+        return data
+
+    def destroy(self):
+        self.__file.close()
+
+    def getSize(self):
+        return self.__size
+
+    def getLastPos(self):
+        return self.__size-1

Copied: haypo/lamer (from rev 205, lamer)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000128.html">[Happyboom-svn] r221 - / haypo trouphp
</A></li>
	<LI>Next message: <A HREF="000129.html">[Happyboom-svn] r223 - haypo/hachoir/plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#130">[ date ]</a>
              <a href="thread.html#130">[ thread ]</a>
              <a href="subject.html#130">[ subject ]</a>
              <a href="author.html#130">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/happyboom-svn">More information about the Happyboom-svn
mailing list</a><br>
</body></html>
