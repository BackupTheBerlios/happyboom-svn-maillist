From haypo at berlios.de  Thu Dec  1 03:54:12 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 1 Dec 2005 03:54:12 +0100
Subject: [Happyboom-svn] r290 - in haypo/hachoir: . plugins stream ui
Message-ID: <200512010254.jB12sCqT027309@sheep.berlios.de>

Author: haypo
Date: 2005-12-01 03:53:31 +0100 (Thu, 01 Dec 2005)
New Revision: 290

Modified:
   haypo/hachoir/config.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/deb.py
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
- UI: Add "read ASCII" tab in information notebook.
- Fix DEB filter (supports space between lines)
- FileStream use it's own seed instead calling always seek()/tell()


Modified: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/config.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -1,2 +1,3 @@
 max_string_length = 30
 max_hexa_length = 4096 
+max_ascii_length = 4096 

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/filter.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -77,7 +77,7 @@
 
     def getUniqChunkId(self, id):
         if id[-2:] == "[]":
-            return self._getUniqChunkId("%s[%u]", id[:-2], 1)
+            return self._getUniqChunkId("%s[%u]", id[:-2], 0)
 
         if id in self._chunks_dict:
             m = re.compile("^(.*?)([0-9]+)$").match(id)

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/hachoir_class.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -83,7 +83,7 @@
     def _addPadding(self):
         filter_size = self._filter.getSize()
         stream_size = self._filter.getStream().getSize()
-        diff_size = filter_size - stream_size
+        diff_size = filter_size - stream_size + 1
         if diff_size < 0:
             chunks = self._filter.getChunks()
             if len(chunks) != 0:

Modified: haypo/hachoir/plugins/deb.py
===================================================================
--- haypo/hachoir/plugins/deb.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/plugins/deb.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -9,15 +9,18 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "file_entry", "File entry", stream, parent)
         self.readString("header", "UnixLine", "Header")
-#        info = re.split(" +", self.header)
         info = self["header"].split()
-        filename = info[0]
-        size = int(info[5])
-        dataio = stream.createSub(stream.tell(), size)
-        plugin = guessPlugin(dataio, filename)
-#        self.readStreamChild("data", dataio, plugin)
-#        self.read("data", "%us" % size, "Data")
-        self.readChild("data", DeflateFilter, dataio, size, plugin)
+        assert len(info) == 7
+        self.filename = info[0]
+        self.size = int(info[5])
+        dataio = stream.createSub(stream.tell(), self.size)
+        plugin = guessPlugin(dataio, self.filename)
+        self.readChild("data", DeflateFilter, dataio, self.size, plugin)
+
+    def updateParent(self, chunk):
+        desc = "File entry (%s)" % self.filename
+        chunk.description = desc
+        self.setDescription(desc)
         
 class DebianFile(Filter):
     def __init__(self, stream, parent):
@@ -25,10 +28,13 @@
         self.readString("id", "UnixLine", "Debian archive identifier")
         self.readString("header", "UnixLine", "Header")
         self.readString("version", "UnixLine", "Version")
-        self.readArray("file", DebianFileEntry, "Files", self.checkEnd)
-
-    def checkEnd(self, stream, array, last):
-#        if len(array)==1: return True
-        return stream.eof()
+        while not stream.eof():
+            while True:
+                data = stream.read(1, False)
+                if data == "\n":
+                    self.readString("empty_line[]", "UnixLine", "Empty line")
+                else:
+                    break
+            self.readChild("file[]", DebianFileEntry)
         
 registerPlugin(DebianFile, "application/x-debian-package")

Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/plugins/elf.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -152,28 +152,17 @@
             section = self.readChild("prg_header[]", ProgramHeader32)
             sections.append(section.getFilter())
 
-        i = 1
-        for section in sections:
-            print "Section %u: type %u, data in %u..%u " % (i, section["type"], section["offset"], section["offset"]+section["file_size"])
-            i = i + 1
+#        i = 1
+#        for section in sections:
+#            print "Section %u: type %u, data in %u..%u " % (i, section["type"], section["offset"], section["offset"]+section["file_size"])
+#            i = i + 1
             
-        if False:
-            sections.sort( sortSection )
-            for section in sections:
-                if section["type"] != 6 and section["offset"] != 0:
-                    print "  DO Section: %u..%u" % (section["offset"], section["offset"]+section["file_size"])
-                    seek(self, stream, section["offset"])
-                    print stream.tell(), section["offset"]
-#                    assert stream.tell() == section["offset"]
-                    self.read("section[]", "%us" % section["file_size"], "")
-            seek(self, stream, elf["shoff"])
-            assert stream.tell() == elf["shoff"]            
-        else:
-            size = elf["shoff"] - stream.tell()
-            newstream = stream.clone()
-            chunk = self.readChild("data", DeflateFilter, newstream, size, Sections, sections) 
-            chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
-            assert stream.tell() == elf["shoff"]
+        size = elf["shoff"] - stream.tell()
+        newstream = stream.clone()
+        chunk = self.readChild("data", DeflateFilter, newstream, size, Sections, sections) 
+        chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
+        assert stream.tell() == elf["shoff"]
+
         for i in range(0, elf["shnum"]):
             chunk = self.readChild("section_header[]", SectionHeader32)
             assert chunk.size == 40

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/plugins/tar.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -153,16 +153,12 @@
 class TarFile(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "tar_file", "TAR archive file", stream, parent)
-
-        self.readArray("files", TarFileEntry, "Tar Files", self.checkEndOfChunks)
+        while not stream.eof():
+            chunk = self.readChild("file[]", TarFileEntry)
+            if chunk.getFilter().isEmpty():
+                break
         
-#        padding = 4096 - stream.tell() % 4096
-#        self.read("padding", "!%ss" % padding, "Padding (4096 align)")
-#        assert stream.eof()
-
-    def checkEndOfChunks(self, stream, array, file):
-        if file != None:
-            if file.isEmpty(): return True
-        return stream.eof()
+        padding = stream.getSize() - stream.tell()
+        self.read("padding", "!%ss" % padding, "Padding (4096 align)")
         
 registerPlugin(TarFile, ["application/x-gtar", "application/x-tar"])

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/stream/file.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -3,53 +3,67 @@
 import os
 
 class FileStream(Stream):
-    def __init__(self, file, filename=None):
+    def __init__(self, file, filename=None, copy=None):
         """
         Endian: See setEndian function. 
         """
 
         Stream.__init__(self, filename)
-        self.__file = file 
-        self.__file.seek(0,2) # Seek to end
-        self.__size = self.__file.tell()
-        self.__file.seek(0,0) # Seel to beginning
+        self._file = file 
+        if copy != None:
+            self._size = copy._size
+            self._seed = copy._seed
+        else:
+            self._file.seek(0,2) # Seek to end
+            self._size = self._file.tell()
+            self._file.seek(0,0) # Seel to beginning
+            self._seed = 0
 
     def getType(self):
         return "%s (%s)" % \
             (self.__class__.__name__, self.filename)
         
     def read(self, size, seek=True):
-        data = self.__file.read(size)
-        if seek==False:
-            self.seek(-len(data), 1)
+        self._file.seek(self._seed)
+        data = self._file.read(size)
+        if seek:
+            self._seed = self._seed + len(data)
+            assert self._seed == self._file.tell()
         return data            
 
     def clone(self):
         #?TODO: Don't copy low-level file IO,
         # but only copy seed :-)
         # => use internal?seed + cache
-        file_copy = open(self.filename)
-        return FileStream(file_copy, self.filename)
+        return FileStream(self._file, self.filename, copy=self)
 
     def seek(self, pos, where=0):
         """ Read file seek document to understand where. """
-        self.__file.seek(pos, where)
-        if self.__size < self.tell():
+        #?TODO: Don't really seek
+        if where==0:
+            self._seed = pos
+        elif where==1:
+            self._seed = self._seed + pos
+        else:
+            self._seed = self._size - pos
+        if self._size < self._seed:
             raise StreamError("Error when seek to (%s,%s) in a stream." % (pos, where))
 
     def tell(self):
-        return self.__file.tell()
+        return self._seed
 
     def getN(self, size, seek=True):
-        data = self.__file.read(size)
+        self._file.seek(self._seed)
+        data = self._file.read(size)
         if len(data) != size:
             raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
-        if not seek:
-            self.__file.seek(-size, 1)
+        if seek:
+            self._seed = self._seed + size
+            assert self._seed == self._file.tell()
         return data
 
     def getSize(self):
-        return self.__size
+        return self._size
 
     def getLastPos(self):
-        return self.__size-1
+        return self._size-1

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/tools.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -102,7 +102,7 @@
         last_unit = unit
     return "%u %s" % (size, unit)
 
-def convertDataToPrintableString(data):
+def convertDataToPrintableString(data, keep_n=False):
     if len(data) == 0:
         return "(empty)"
     display = ""
@@ -114,7 +114,10 @@
                 "\t": "\\t",
                 "\0": "\\0"}
             if c in know:
-                display = display + know[c]
+                if not keep_n or c != "\n":
+                    display = display + know[c]
+                else:
+                    display = display + c
             else:
 #                display = display + "\\x%02X" % ord(c)
                 display = display + "."

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/ui/hachoir.glade	2005-12-01 02:53:31 UTC (rev 290)
@@ -1060,6 +1060,151 @@
 	      <property name="type">tab</property>
 	    </packing>
 	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox6">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox3">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label44">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Path:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">6</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="ascii_path">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="padding">6</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkScrolledWindow" id="scrolledwindow3">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		  <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		  <property name="shadow_type">GTK_SHADOW_IN</property>
+		  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		  <child>
+		    <widget class="GtkTextView" id="ascii_content">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="overwrite">False</property>
+		      <property name="accepts_tab">False</property>
+		      <property name="justification">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap_mode">GTK_WRAP_NONE</property>
+		      <property name="cursor_visible">True</property>
+		      <property name="pixels_above_lines">0</property>
+		      <property name="pixels_below_lines">0</property>
+		      <property name="pixels_inside_wrap">0</property>
+		      <property name="left_margin">0</property>
+		      <property name="right_margin">0</property>
+		      <property name="indent">0</property>
+		      <property name="text" translatable="yes"></property>
+		    </widget>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">12</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkButton" id="button4">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="label">gtk-refresh</property>
+		  <property name="use_stock">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_ascii_clicked" last_modification_time="Thu, 01 Dec 2005 02:02:30 GMT"/>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label43">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">ASCII</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
 	</widget>
 	<packing>
 	  <property name="padding">0</property>

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-11-30 05:55:11 UTC (rev 289)
+++ haypo/hachoir/ui/ui_window.py	2005-12-01 02:53:31 UTC (rev 290)
@@ -3,6 +3,7 @@
 import gtk
 import gtk.glade
 import config
+from tools import convertDataToPrintableString
 
 class InfoNotebook:
     def __init__(self, xml):
@@ -50,6 +51,8 @@
         self.toolbutton_property = xml.get_widget('toolbutton_property')
         self.toolbutton_close = xml.get_widget('toolbutton_close')
         self.toolbutton_export = xml.get_widget('toolbutton_export')
+        self.ascii_path = xml.get_widget('ascii_path')
+        self.ascii_content = xml.get_widget('ascii_content')
         self.hexa_path = xml.get_widget('hexa_path')
         self.hexa_content = xml.get_widget('hexa_content')
         self.menu_close = xml.get_widget('menu_close')
@@ -212,6 +215,34 @@
             self.ui.hachoir.saveUser(filename)
         chooser.destroy()
 
+    def on_ascii_clicked(self, widget):
+        chunk = self.getActiveChunk()
+        if chunk == None:
+            return
+        path = chunk.getParent().getPath()+"/"+chunk.id
+        self.ascii_path.set_text(path)
+        raw = chunk.getRaw(config.max_ascii_length)
+        # TODO: Remove old code
+        if False:
+            # TODO: Use better str=>ascii code ...
+            content = ""
+            wrap = 16
+            while len(raw) != 0:
+                if len(content) != 0:
+                    content = content + "\n"
+                content = content + convertDataToPrintableString(raw[:wrap])
+                raw = raw[wrap:]
+        else:
+            content = convertDataToPrintableString(raw, True)
+        if config.max_hexa_length < chunk.size:
+            if len(content) != 0:
+                content = content + "\n"
+            content = content + " (...)"
+        # TODO: Write new TextBuffer!?
+        buffer = gtk.TextBuffer()
+        buffer.set_text(content)
+        self.ascii_content.set_buffer(buffer)
+
     def on_hexadecimal_clicked(self, widget):
         chunk = self.getActiveChunk()
         if chunk == None:



From haypo at berlios.de  Thu Dec  1 04:05:28 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 1 Dec 2005 04:05:28 +0100
Subject: [Happyboom-svn] r291 - in haypo/hachoir: . plugins
Message-ID: <200512010305.jB135SXF030396@sheep.berlios.de>

Author: haypo
Date: 2005-12-01 04:05:24 +0100 (Thu, 01 Dec 2005)
New Revision: 291

Added:
   haypo/hachoir/plugins/ar.py
Removed:
   haypo/hachoir/plugins/deb.py
Modified:
   haypo/hachoir/plugin.py
Log:
Rename DebianFile to ArchiveFile, and now supports '.a' archive.


Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-12-01 02:53:31 UTC (rev 290)
+++ haypo/hachoir/plugin.py	2005-12-01 03:05:24 UTC (rev 291)
@@ -1,6 +1,7 @@
 import re
 from mime import getFileMime, getStreamMime
 from default import DefaultFilter
+from error import warning
 
 def guessPlugin(stream, filename, default=DefaultFilter):
     return getPluginByStream(stream, filename, default)

Copied: haypo/hachoir/plugins/ar.py (from rev 290, haypo/hachoir/plugins/deb.py)
===================================================================
--- haypo/hachoir/plugins/deb.py	2005-12-01 02:53:31 UTC (rev 290)
+++ haypo/hachoir/plugins/ar.py	2005-12-01 03:05:24 UTC (rev 291)
@@ -0,0 +1,39 @@
+"""
+GNU ar archive : archive file (.a) and Debian (.deb) archive.
+"""
+
+from filter import Filter, DeflateFilter
+from plugin import registerPlugin, guessPlugin
+from error import error
+   
+class ArchiveFileEntry(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "file_entry", "File entry", stream, parent)
+        self.readString("header", "UnixLine", "Header")
+        info = self["header"].split()
+        assert len(info) == 7
+        self.filename = info[0]
+        self.size = int(info[5])
+        dataio = stream.createSub(stream.tell(), self.size)
+        plugin = guessPlugin(dataio, self.filename)
+        self.readChild("data", DeflateFilter, dataio, self.size, plugin)
+
+    def updateParent(self, chunk):
+        desc = "File entry (%s)" % self.filename
+        chunk.description = desc
+        self.setDescription(desc)
+        
+class ArchiveFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "ar_file", "GNU ar file", stream, parent)
+        self.readString("id", "UnixLine", "ar archive identifier")
+        while not stream.eof():
+            while True:
+                data = stream.read(1, False)
+                if data == "\n":
+                    self.readString("empty_line[]", "UnixLine", "Empty line")
+                else:
+                    break
+            self.readChild("file[]", ArchiveFileEntry)
+        
+registerPlugin(ArchiveFile, ["application/x-debian-package", "application/x-archive"])

Deleted: haypo/hachoir/plugins/deb.py
===================================================================
--- haypo/hachoir/plugins/deb.py	2005-12-01 02:53:31 UTC (rev 290)
+++ haypo/hachoir/plugins/deb.py	2005-12-01 03:05:24 UTC (rev 291)
@@ -1,40 +0,0 @@
-"""
-Debian (.deb) archive file
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin, guessPlugin
-   
-class DebianFileEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "file_entry", "File entry", stream, parent)
-        self.readString("header", "UnixLine", "Header")
-        info = self["header"].split()
-        assert len(info) == 7
-        self.filename = info[0]
-        self.size = int(info[5])
-        dataio = stream.createSub(stream.tell(), self.size)
-        plugin = guessPlugin(dataio, self.filename)
-        self.readChild("data", DeflateFilter, dataio, self.size, plugin)
-
-    def updateParent(self, chunk):
-        desc = "File entry (%s)" % self.filename
-        chunk.description = desc
-        self.setDescription(desc)
-        
-class DebianFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "deb_file", "Debian archive file", stream, parent)
-        self.readString("id", "UnixLine", "Debian archive identifier")
-        self.readString("header", "UnixLine", "Header")
-        self.readString("version", "UnixLine", "Version")
-        while not stream.eof():
-            while True:
-                data = stream.read(1, False)
-                if data == "\n":
-                    self.readString("empty_line[]", "UnixLine", "Empty line")
-                else:
-                    break
-            self.readChild("file[]", DebianFileEntry)
-        
-registerPlugin(DebianFile, "application/x-debian-package")



From haypo at berlios.de  Thu Dec  1 05:10:23 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 1 Dec 2005 05:10:23 +0100
Subject: [Happyboom-svn] r292 - haypo/hachoir/plugins
Message-ID: <200512010410.jB14ANQi011738@sheep.berlios.de>

Author: haypo
Date: 2005-12-01 05:10:12 +0100 (Thu, 01 Dec 2005)
New Revision: 292

Modified:
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/plugins/exif.py
Log:
Exif can read entries value. Update ELF mimes (supports shared library now).


Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-12-01 03:05:24 UTC (rev 291)
+++ haypo/hachoir/plugins/elf.py	2005-12-01 04:10:12 UTC (rev 292)
@@ -167,4 +167,4 @@
             chunk = self.readChild("section_header[]", SectionHeader32)
             assert chunk.size == 40
 
-registerPlugin(ElfFile, "application/x-executable")
+registerPlugin(ElfFile, ["application/x-executable", "application/x-sharedlib"])

Modified: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-12-01 03:05:24 UTC (rev 291)
+++ haypo/hachoir/plugins/exif.py	2005-12-01 04:10:12 UTC (rev 292)
@@ -9,29 +9,103 @@
 """
 
 from filter import Filter
+import struct
 
 class ExifEntry(Filter):
+    format = {
+        1: (1, "B"),
+        2: (1, "s"),
+        3: (1, "H"),
+        4: (1, "L"),
+        5: (2, "L"),
+        7: (1, "B"),
+        9: (1, "l"),
+        10: (2, "l")
+    }
+
+    type_name = {    
+        1: "BYTE (8 bits)",
+        2: "ASCII (8 bits)",
+        3: "SHORT (16 bits)",
+        4: "LONG (32 bits)",
+        5: "RATIONAL (two LONGs)",
+        7: "UNDEFINED (8 bits)",
+        9: "SLONG (32 bits)",
+        10: "SRATIONTAL (two SLONGs)"
+    }
+
+    tag_name = {    
+        0x0100: "Image width",
+        0x0101: "Image height",
+        0x0102: "Number of bits per component",
+        0x0103: "Compression scheme",
+        0x0106: "Pixel composition",
+        0x0112: "Orientation of image",
+        0x0115: "Number of components",
+        0x011C: "Image data arrangement",
+        0x0212: "Subsampling ratio Y to C",
+        0x0213: "Y and C positioning",
+        0x011A: "Image resolution width direction",
+        0x011B: "Image resolution in height direction",
+        0x0128: "Unit of X and Y resolution",
+        
+        0x0111: "Image data location",
+        0x0116: "Number of rows per strip",
+        0x0117: "Bytes per compressed strip",
+        0x0201: "Offset to JPEG SOI",
+        0x0202: "Bytes of JPEG data",
+        
+        0x012D: "Transfer function",
+        0x013E: "White point chromaticity",
+        0x013F: "Chromaticities of primaries",
+        0x0211: "Color space transformation matrix coefficients",
+        0x0214: "Pair of blank and white reference values",
+        
+        0x0132: "File change date and time",
+        0x010e: "Image title",
+        0x010f: "Camera (Image input equipment) manufacturer",
+        0x0110: "Camera (Input input equipment) model",
+        0x0131: "Software",
+        0x013B: "File change date and time",
+        0x8298: "Copyright holder"
+
+    }
+
     def __init__(self, stream, parent, endian):
         Filter.__init__(self, "exif_entry", "Exif entry", stream, parent)
         self.endian = endian
         self.read("tag", endian+"H", "Tag", post=self.processTag)
-        self.read("whatsthis", "10s", "What's this?")
+        self.read("type", endian+"H", "Type", post=self.processType)
+        self.read("count", endian+"L", "Count")
 
+        # Create format
+        assert self["type"] in ExifEntry.format
+        format = ExifEntry.format[ self["type"] ]
+        self.format = "%s%u%s" % (self.endian, format[0]*self["count"], format[1])
+
+        # Get size
+        self.size = struct.calcsize(self.format)
+
+        # Get offset/value
+        if 4 < self.size:
+            self.read("offset", endian+"L", "Value offset")
+        else:
+            self.read("value", self.format, "Value")
+            if self.size < 4:
+                self.read("padding", "%us" % (4-self.size), "Padding")
+
     def updateParent(self, parent):
         parent.description = "Exif entry (%s)" % self.getTag() 
 
     def getTag(self):
-        know = {
-            0x010e: "Image description",
-            0x010f: "Camera constructor",
-            0x0110: "Camera model",
-            0x0131: "Software"
-        }
-        return know.get(self["tag"], "Unknown tag (0x%03X)" % self["tag"])
+        return ExifEntry.tag_name.get(self["tag"], "Unknown tag (0x%03X)" % self["tag"])
 
+    def processType(self, chunk):
+        return ExifEntry.type_name.get(chunk.value, "%u" % chunk.value) 
+
     def processTag(self, chunk):
         chunk.description = self.getTag()
-        return "(0x%04X)" % chunk.value 
+        return "0x%04X" % chunk.value 
 
 class ExifFilter(Filter):
     def __init__(self, stream, parent):
@@ -48,12 +122,22 @@
            endian = ">"
         self.read("header2", endian+"H", "Header2 (42)")
 
-        # Part 0
+        # Part #0
         self.read("nb_entry", endian+"H", "Number of entries")
         self.read("offset", endian+"L", "Reserved")
         nb_entry = self["nb_entry"]
+        entries = []
         for i in range(0,nb_entry):
-            self.readChild("entry[]", ExifEntry, endian)
+            chunk = self.readChild("entry[]", ExifEntry, endian)
+            entries.append(chunk.getFilter())
 
+        # TODO: What's this?
+        self.read("whatisthat", "16s", "What's this?")
+
+        # Read data of part #0
+        for entry in entries:
+            if 4 < entry.size:
+                self.read("entry_value[]", entry.format, "Value of %s" % entry.getId())
+
         # TODO: To be continued...
         self.read("end", "{@end@}s", "End")



From haypo at berlios.de  Thu Dec  1 07:56:38 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 1 Dec 2005 07:56:38 +0100
Subject: [Happyboom-svn] r294 - in haypo/hachoir: . plugins
Message-ID: <200512010656.jB16uc4i032676@sheep.berlios.de>

Author: haypo
Date: 2005-12-01 07:56:21 +0100 (Thu, 01 Dec 2005)
New Revision: 294

Added:
   haypo/hachoir/plugins/rpm.py
Modified:
   haypo/hachoir/export.template
Log:
Beginning of RPM filter.


Modified: haypo/hachoir/export.template
===================================================================
--- haypo/hachoir/export.template	2005-12-01 05:34:01 UTC (rev 293)
+++ haypo/hachoir/export.template	2005-12-01 06:56:21 UTC (rev 294)
@@ -6,11 +6,11 @@
 """
 
 from filter import Filter
-from plugins import registerPlugin
+from plugin import registerPlugin
 
 class MyFilter(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "{id}", "{description}", stream, parent)
 {chunks}
 
-#registerPlugin(MyFilter, "<MIME type>")
+#registerPlugin(MyFilter, "")

Added: haypo/hachoir/plugins/rpm.py
===================================================================
--- haypo/hachoir/plugins/rpm.py	2005-12-01 05:34:01 UTC (rev 293)
+++ haypo/hachoir/plugins/rpm.py	2005-12-01 06:56:21 UTC (rev 294)
@@ -0,0 +1,75 @@
+"""
+RPM archive parser.
+
+Author: Victor Stinner, 1st December 2005.
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class RpmItem(Filter):
+    type_name = {
+        0: "NULL",
+        1: "CHAR",
+        2: "INT8",
+        3: "INT16",
+        4: "INT32",
+        5: "INT64",
+        6: "STRING",
+        7: "BIN",
+        8: "STRING_ARRAY"
+    }
+    
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "rpm_item", "RPM item", stream, parent)
+        self.read("tag", "!L", "Tag")
+        self.read("type", "!L", "Type", post=self.postType)
+        self.read("offset", "!L", "Offset")
+        self.read("count", "!L", "Count")
+
+    def postType(self, chunk):
+        return self.getType(chunk.value)
+
+    def updateParent(self, chunk):
+        type = self.getType(self["type"])
+        chunk.description = "RPM item (%s)" % type
+
+    def getType(self, type):
+        return RpmItem.type_name.get(type, "Unknow type (%s)" % type)
+
+class RpmSignature(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "rpm_sig", "RPM signature", stream, parent)
+        self.read("id", "!3B", "Identifier")
+        assert self["id"] == (142, 173, 232)
+        self.read("version", "!B", "Signature version")
+        self.read("reserved", "4s", "Reserved")
+        self.read("count", "!L", "Count")
+        self.read("size", "!L", "Size")
+        for i in range(0, self["count"]):
+            self.readChild("item[]", RpmItem)
+
+class RpmFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "rpm_file", "RPM File", stream, parent)
+        self.read("id", "!4B", "Identifier")
+        assert self["id"] == (237, 171, 238, 219)
+        self.read("major_ver", "!B", "Major version")
+        self.read("minor_ver", "!B", "Minor version")
+        self.read("type", "!H", "RPM type", post=self.postType)
+        self.read("architecture", "!H", "Architecture")
+        self.read("name", "!66s", "Archive name")
+        self.read("osnum", "!H", "OS")
+        self.read("signature_type", "!H", "Type of signature")
+        self.read("reserved", "16s", "Reserved")
+        self.readChild("sig", RpmSignature)
+
+    def postType(self, chunk):
+        if chunk.value == 0:
+            return "Binary"
+        elif chunk.value == 1:
+            return "Source"
+        else:
+            return "Unknown (%s)" % chunk.value
+
+registerPlugin(RpmFile, "application/x-rpm")



From haypo at berlios.de  Fri Dec  2 00:57:44 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 2 Dec 2005 00:57:44 +0100
Subject: [Happyboom-svn] r295 - in haypo/hachoir: . ui
Message-ID: <200512012357.jB1Nvif1030829@sheep.berlios.de>

Author: haypo
Date: 2005-12-02 00:57:35 +0100 (Fri, 02 Dec 2005)
New Revision: 295

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
Reorganize buttons in UI and support "write chunk to file".


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-01 06:56:21 UTC (rev 294)
+++ haypo/hachoir/chunk.py	2005-12-01 23:57:35 UTC (rev 295)
@@ -44,7 +44,7 @@
         oldpos = self._stream.tell()
         self._stream.seek(self.addr)
         size = self.size
-        if max_size<size:
+        if max_size != None and max_size<size:
             size = max_size
         data = self._stream.getN(size)
         self._stream.seek(oldpos)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-01 06:56:21 UTC (rev 294)
+++ haypo/hachoir/filter.py	2005-12-01 23:57:35 UTC (rev 295)
@@ -55,7 +55,7 @@
 
     def deleteChunk(self, chunk):
         if len(self._chunks) < 2:
-            error("Can't not the chunk %s (there is only one chunk)." % chunk.id)
+            error("Can't not delete the chunk %s (there is only one chunk)." % chunk.id)
             return            
         chunk_size = chunk.size
         pos = self._chunks.index(chunk)

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-12-01 06:56:21 UTC (rev 294)
+++ haypo/hachoir/ui/hachoir.glade	2005-12-01 23:57:35 UTC (rev 295)
@@ -112,27 +112,11 @@
 	    <widget class="GtkToolbar" id="toolbar1">
 	      <property name="visible">True</property>
 	      <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
-	      <property name="toolbar_style">GTK_TOOLBAR_BOTH</property>
+	      <property name="toolbar_style">GTK_TOOLBAR_ICONS</property>
 	      <property name="tooltips">True</property>
 	      <property name="show_arrow">True</property>
 
 	      <child>
-		<widget class="GtkToolButton" id="toolbutton_new">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Open new file and split it</property>
-		  <property name="stock_id">gtk-new</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_new" last_modification_time="Mon, 31 Oct 2005 04:36:45 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
 		<widget class="GtkToolButton" id="toolbutton_open">
 		  <property name="visible">True</property>
 		  <property name="tooltip" translatable="yes">Open a filter and apply it to this level</property>
@@ -140,7 +124,7 @@
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
 		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_open" last_modification_time="Mon, 31 Oct 2005 04:36:36 GMT"/>
+		  <signal name="clicked" handler="on_toolbutton_new" last_modification_time="Thu, 01 Dec 2005 23:30:26 GMT"/>
 		</widget>
 		<packing>
 		  <property name="expand">False</property>
@@ -149,14 +133,13 @@
 	      </child>
 
 	      <child>
-		<widget class="GtkToolButton" id="toolbutton_save">
+		<widget class="GtkToolButton" id="toolbutton_close">
 		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Save current filter into a XML file</property>
-		  <property name="stock_id">gtk-save</property>
+		  <property name="stock_id">gtk-close</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
 		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_save" last_modification_time="Mon, 31 Oct 2005 04:32:02 GMT"/>
+		  <signal name="clicked" handler="on_toolbutton_close" last_modification_time="Tue, 29 Nov 2005 02:21:01 GMT"/>
 		</widget>
 		<packing>
 		  <property name="expand">False</property>
@@ -194,53 +177,6 @@
 		  <property name="homogeneous">True</property>
 		</packing>
 	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_property">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Set filter properties</property>
-		  <property name="stock_id">gtk-properties</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_property" last_modification_time="Mon, 31 Oct 2005 16:11:08 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_export">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Export current filter to python script</property>
-		  <property name="stock_id">gtk-convert</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_export" last_modification_time="Wed, 02 Nov 2005 00:47:19 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_close">
-		  <property name="visible">True</property>
-		  <property name="stock_id">gtk-close</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_close" last_modification_time="Tue, 29 Nov 2005 02:21:01 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
 	    </widget>
 	  </child>
 	</widget>
@@ -349,257 +285,336 @@
 	  <property name="enable_popup">False</property>
 
 	  <child>
-	    <widget class="GtkTable" id="table5">
-	      <property name="border_width">6</property>
+	    <widget class="GtkVBox" id="vbox8">
 	      <property name="visible">True</property>
-	      <property name="n_rows">3</property>
-	      <property name="n_columns">4</property>
 	      <property name="homogeneous">False</property>
-	      <property name="row_spacing">6</property>
-	      <property name="column_spacing">6</property>
+	      <property name="spacing">0</property>
 
 	      <child>
-		<widget class="GtkLabel" id="label31">
+		<widget class="GtkTable" id="table5">
+		  <property name="border_width">6</property>
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Name:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <property name="n_rows">3</property>
+		  <property name="n_columns">4</property>
+		  <property name="homogeneous">False</property>
+		  <property name="row_spacing">6</property>
+		  <property name="column_spacing">6</property>
 
-	      <child>
-		<widget class="GtkEntry" id="filter_name">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkLabel" id="label31">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Name:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkLabel" id="label32">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Decription:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkEntry" id="filter_name">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkEntry" id="filter_description">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkLabel" id="label32">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Decription:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkEntry" id="filter_type">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkEntry" id="filter_description">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkLabel" id="label39">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Type:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkEntry" id="filter_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkLabel" id="label28">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Stream:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">2</property>
-		  <property name="right_attach">3</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkLabel" id="label39">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Type:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkEntry" id="stream_size">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
+		  <child>
+		    <widget class="GtkLabel" id="label28">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Stream:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="stream_size">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label29">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Size:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="stream_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 		</widget>
 		<packing>
-		  <property name="left_attach">3</property>
-		  <property name="right_attach">4</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="y_options"></property>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="label29">
+		<widget class="GtkHButtonBox" id="hbuttonbox3">
+		  <property name="border_width">6</property>
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Size:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">2</property>
-		  <property name="right_attach">3</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <property name="layout_style">GTK_BUTTONBOX_DEFAULT_STYLE</property>
+		  <property name="spacing">0</property>
 
-	      <child>
-		<widget class="GtkEntry" id="stream_type">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
+		  <child>
+		    <widget class="GtkButton" id="info_filter_open">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-open</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_toolbutton_open" last_modification_time="Thu, 01 Dec 2005 23:27:22 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="info_filter_save">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-save</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_toolbutton_save" last_modification_time="Thu, 01 Dec 2005 23:27:31 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="info_filter_export">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-convert</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_toolbutton_export" last_modification_time="Thu, 01 Dec 2005 23:29:48 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="info_filter_property">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-properties</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_toolbutton_property" last_modification_time="Thu, 01 Dec 2005 23:22:25 GMT"/>
+		    </widget>
+		  </child>
 		</widget>
 		<packing>
-		  <property name="left_attach">3</property>
-		  <property name="right_attach">4</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="y_options"></property>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 	    </widget>
@@ -633,257 +648,309 @@
 	  </child>
 
 	  <child>
-	    <widget class="GtkTable" id="table7">
-	      <property name="border_width">6</property>
+	    <widget class="GtkVBox" id="vbox7">
 	      <property name="visible">True</property>
-	      <property name="n_rows">3</property>
-	      <property name="n_columns">4</property>
 	      <property name="homogeneous">False</property>
-	      <property name="row_spacing">6</property>
-	      <property name="column_spacing">6</property>
+	      <property name="spacing">0</property>
 
 	      <child>
-		<widget class="GtkLabel" id="label33">
+		<widget class="GtkTable" id="table7">
+		  <property name="border_width">6</property>
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Name:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <property name="n_rows">3</property>
+		  <property name="n_columns">4</property>
+		  <property name="homogeneous">False</property>
+		  <property name="row_spacing">6</property>
+		  <property name="column_spacing">6</property>
 
-	      <child>
-		<widget class="GtkEntry" id="chunk_name">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkLabel" id="label33">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Name:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkLabel" id="label41">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Address:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">2</property>
-		  <property name="right_attach">3</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkEntry" id="chunk_name">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkEntry" id="chunk_address">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">3</property>
-		  <property name="right_attach">4</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkLabel" id="label41">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Address:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkLabel" id="label34">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Size:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">2</property>
-		  <property name="right_attach">3</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkEntry" id="chunk_address">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkEntry" id="chunk_size">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">3</property>
-		  <property name="right_attach">4</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkLabel" id="label34">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Size:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkLabel" id="label35">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Type:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <child>
+		    <widget class="GtkEntry" id="chunk_size">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 
-	      <child>
-		<widget class="GtkEntry" id="chunk_type">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
+		  <child>
+		    <widget class="GtkLabel" id="label35">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Type:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label36">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Description:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_description">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 		</widget>
 		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="y_options"></property>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="label36">
+		<widget class="GtkHButtonBox" id="hbuttonbox2">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Description:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
+		  <property name="layout_style">GTK_BUTTONBOX_DEFAULT_STYLE</property>
+		  <property name="spacing">0</property>
 
-	      <child>
-		<widget class="GtkEntry" id="chunk_description">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">False</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
+		  <child>
+		    <widget class="GtkButton" id="info_chunk_save">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-save</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="onSaveChunk" last_modification_time="Thu, 01 Dec 2005 23:43:45 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="info_chunk_delete">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-delete</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="onDeleteChunk" last_modification_time="Thu, 01 Dec 2005 23:25:43 GMT"/>
+		    </widget>
+		  </child>
 		</widget>
 		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="y_options"></property>
+		  <property name="padding">0</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 	    </widget>
@@ -1226,7 +1293,7 @@
       <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image49">
+	<widget class="GtkImage" id="image55">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -1247,7 +1314,7 @@
       <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image50">
+	<widget class="GtkImage" id="image56">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -1268,7 +1335,7 @@
       <signal name="activate" handler="onAddString" last_modification_time="Wed, 02 Nov 2005 05:30:33 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image51">
+	<widget class="GtkImage" id="image57">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-add</property>
 	  <property name="icon_size">1</property>
@@ -1289,7 +1356,7 @@
       <signal name="activate" handler="onConvert" last_modification_time="Wed, 02 Nov 2005 02:32:16 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image52">
+	<widget class="GtkImage" id="image58">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-convert</property>
 	  <property name="icon_size">1</property>
@@ -1310,7 +1377,7 @@
       <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image53">
+	<widget class="GtkImage" id="image59">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-edit</property>
 	  <property name="icon_size">1</property>
@@ -1331,7 +1398,7 @@
       <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image54">
+	<widget class="GtkImage" id="image60">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-delete</property>
 	  <property name="icon_size">1</property>
@@ -1352,7 +1419,7 @@
       <signal name="activate" handler="onCopyClipboard" last_modification_time="Wed, 23 Nov 2005 22:09:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image55">
+	<widget class="GtkImage" id="image61">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-copy</property>
 	  <property name="icon_size">1</property>

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-01 06:56:21 UTC (rev 294)
+++ haypo/hachoir/ui/ui_window.py	2005-12-01 23:57:35 UTC (rev 295)
@@ -22,11 +22,15 @@
         self.chunk_type = xml.get_widget("chunk_type")
         
     def updateChunk(self, chunk):
-        self.chunk_name.set_text(chunk.id)
-        self.chunk_description.set_text(chunk.description)
-        self.chunk_address.set_text(str(chunk.addr))
-        self.chunk_size.set_text(str(chunk.size))
-        self.chunk_type.set_text(chunk.__class__.__name__)
+        if chunk != None:
+            self.chunk_name.set_text(chunk.id)
+            self.chunk_description.set_text(chunk.description)
+            self.chunk_address.set_text(str(chunk.addr))
+            self.chunk_size.set_text(str(chunk.size))
+            self.chunk_type.set_text(chunk.__class__.__name__)
+        chunk_present = (chunk != None)
+        self.info_chunk_save = chunk_present
+        self.info_chunk_delete = chunk_present
     
     def updateFilter(self, filter):        
         self.filter_name.set_text(filter.getId())
@@ -45,17 +49,17 @@
         self.window = xml.get_widget('main_window')
         self.toolbar = xml.get_widget('toolbar')
         self.toolbutton_parent = xml.get_widget('toolbutton_parent')
-        self.toolbutton_new = xml.get_widget('toolbutton_new')
         self.toolbutton_open = xml.get_widget('toolbutton_open')
-        self.toolbutton_save = xml.get_widget('toolbutton_save')
-        self.toolbutton_property = xml.get_widget('toolbutton_property')
         self.toolbutton_close = xml.get_widget('toolbutton_close')
-        self.toolbutton_export = xml.get_widget('toolbutton_export')
         self.ascii_path = xml.get_widget('ascii_path')
         self.ascii_content = xml.get_widget('ascii_content')
         self.hexa_path = xml.get_widget('hexa_path')
         self.hexa_content = xml.get_widget('hexa_content')
         self.menu_close = xml.get_widget('menu_close')
+        self.info_filter_open = xml.get_widget('info_filter_open')
+        self.info_filter_save = xml.get_widget('info_filter_save')
+        self.info_filter_export = xml.get_widget('info_filter_export')
+        self.info_filter_property = xml.get_widget('info_filter_property')
         self.info = InfoNotebook(xml)
         self.table = xml.get_widget('table')
         self.table_store = None
@@ -64,16 +68,37 @@
         self.table.connect("button_press_event", self.on_treeview_button_press_event)
 #        self.window.set_size_request(760,500)
         self.build_table()
+
+    def onSaveChunk(self, event):
+        chunk = self.getActiveChunk()
+        assert chunk != None
+
+        chooser = gtk.FileChooserDialog( \
+            title="Write chunk data to ...",
+            action=gtk.FILE_CHOOSER_ACTION_SAVE,
+            buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
+        if chooser.run() == gtk.RESPONSE_OK:
+            filename = chooser.get_filename() 
+            raw = chunk.getRaw()
+            f = open(filename, 'w')
+            f.write(raw)
+            f.close()
+        chooser.destroy()
+
+    def onDeleteChunk(self, event):
+        chunk = self.getActiveChunk()
+        chunk.getParent().deleteChunk(chunk)
         
     def updateToolbar(self):
         file_present = (self.ui.hachoir.getFilter() != None)
-        self.toolbutton_open.set_sensitive(file_present)
-        self.toolbutton_save.set_sensitive(file_present)
+        filter_present = file_present
         if not file_present:
             self.toolbutton_parent.set_sensitive(False)
-        self.toolbutton_property.set_sensitive(file_present)
-        self.toolbutton_export.set_sensitive(file_present)
         self.toolbutton_close.set_sensitive(file_present)
+        self.info_filter_open.set_sensitive(filter_present)
+        self.info_filter_save.set_sensitive(filter_present)
+        self.info_filter_export.set_sensitive(filter_present)
+        self.info_filter_property.set_sensitive(filter_present)
         self.menu_close.set_sensitive(file_present)
 
     def getTableChunk(self, col):
@@ -130,8 +155,7 @@
 
     def onTableClick(self, widget, data=None):
         chunk = self.getActiveChunk()
-        if chunk != None:
-            self.info.updateChunk(chunk)
+        self.info.updateChunk(chunk)
 
     def build_table(self):
         self.table_store = gtk.TreeStore(int, str, int, str, str, str)



From haypo at berlios.de  Fri Dec  2 03:43:57 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 2 Dec 2005 03:43:57 +0100
Subject: [Happyboom-svn] r296 - in haypo/hachoir: . plugins stream ui
Message-ID: <200512020243.jB22hviV017038@sheep.berlios.de>

Author: haypo
Date: 2005-12-02 03:43:33 +0100 (Fri, 02 Dec 2005)
New Revision: 296

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/plugins/exif.py
   haypo/hachoir/stream/bunzip.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_popup.py
   haypo/hachoir/ui/ui_window.py
Log:
Fix FileStream.getLastPos() when size=0. Truncate size to 0 for FormatChunk
with format "{@end@}s" when size<0. Fix window size to 600x560.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/chunk.py	2005-12-02 02:43:33 UTC (rev 296)
@@ -224,7 +224,7 @@
         stream = self._chunk.getStream()
         oldpos = stream.tell()
         stream.seek(self._addr)
-        if (max_size == None or self._size<max_size) or not self._chunk.isString():
+        if (max_size == None or self._size<=max_size) or not self._chunk.isString():
             data = stream.getN(self._size)
             stream.seek(oldpos)
             return data, False
@@ -289,6 +289,9 @@
         id = match.group(1)
         if id == "@end@":
             size = self._stream.getLastPos() - self.addr
+            if size < 0:
+                warning("Size < 0 for chunk %s, will use size=0!" % self.id)
+                size = 0
         else:
             size = self._parent[id]
         return str(size)

Modified: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/plugins/exif.py	2005-12-02 02:43:33 UTC (rev 296)
@@ -165,6 +165,7 @@
 
 def sortExifEntry(a,b):
     return int( a["offset"] - b["offset"] )
+
 class ExifIFD(Filter):
     def __init__(self, stream, parent, endian, offset_diff):
         Filter.__init__(self, "exif", "Exif IFD", stream, parent)
@@ -182,10 +183,14 @@
             if 4 < entry.size:
                 entries.append(entry)
         self.read("next", endian+"L", "Next IFD offset")
+#        self.read("x", "12s", "")
         entries.sort( sortExifEntry )                
         for entry in entries:
             offset = entry["offset"]+offset_diff
-            assert stream.tell() == offset
+            padding = offset - stream.tell()
+            if 0 < padding:
+                self.read("padding[]", "%us" % padding, "Padding (?)")
+            assert offset == stream.tell()
             self.read("entry_value[]", entry.format, "Value of %s" % entry.getId())
 
     def updateParent(self, chunk):

Modified: haypo/hachoir/stream/bunzip.py
===================================================================
--- haypo/hachoir/stream/bunzip.py	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/stream/bunzip.py	2005-12-02 02:43:33 UTC (rev 296)
@@ -25,11 +25,12 @@
     if filename==None:
         os.unlink(realname)
 
-    # Check data size
+    # Check data size (buggy with Python <= 2.4.2 and maybe other)
     io.seek(0,2)
     guess_size = io.tell()
     io.seek(0)
 
+    # Check data size
     io.seek(-1,2)
     real_size = io.tell() + 1
     io.seek(0)

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/stream/file.py	2005-12-02 02:43:33 UTC (rev 296)
@@ -13,11 +13,16 @@
         if copy != None:
             self._size = copy._size
             self._seed = copy._seed
+            self._end = copy._end
         else:
             self._file.seek(0,2) # Seek to end
             self._size = self._file.tell()
             self._file.seek(0,0) # Seel to beginning
             self._seed = 0
+            if self._size != 0:
+                self._end = self._size-1
+            else:
+                self._end = 0
 
     def getType(self):
         return "%s (%s)" % \
@@ -66,4 +71,4 @@
         return self._size
 
     def getLastPos(self):
-        return self._size-1
+        return self._end

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/ui/hachoir.glade	2005-12-02 02:43:33 UTC (rev 296)
@@ -260,7 +260,7 @@
 	      <property name="headers_visible">True</property>
 	      <property name="rules_hint">False</property>
 	      <property name="reorderable">False</property>
-	      <property name="enable_search">True</property>
+	      <property name="enable_search">False</property>
 	      <property name="fixed_height_mode">False</property>
 	      <property name="hover_selection">False</property>
 	      <property name="hover_expand">False</property>

Modified: haypo/hachoir/ui/ui_popup.py
===================================================================
--- haypo/hachoir/ui/ui_popup.py	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/ui/ui_popup.py	2005-12-02 02:43:33 UTC (rev 296)
@@ -4,7 +4,7 @@
 from chunk import FormatChunk, FilterChunk, StringChunk
 from ui_new_chunk import NewChunkDialog
 from ui_new_string import NewStringDialog
-from format import splitFormat # TODO: remove this line
+from format import splitFormat
 from error import error
 
 MAX_CHUNK_SIZE=1024 # When copy to clipboard

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-01 23:57:35 UTC (rev 295)
+++ haypo/hachoir/ui/ui_window.py	2005-12-02 02:43:33 UTC (rev 296)
@@ -66,7 +66,7 @@
         xml.signal_autoconnect(self)
         self.window.connect("key-press-event", self.onKeyUp)
         self.table.connect("button_press_event", self.on_treeview_button_press_event)
-#        self.window.set_size_request(760,500)
+        self.window.set_size_request(600,560)
         self.build_table()
 
     def onSaveChunk(self, event):
@@ -171,8 +171,6 @@
         self.table.set_reorderable(True)
         self.treeselection = self.table.get_selection()
         self.table.columns_autosize()
-        self.window.maximize()
-        self.window.grab_focus()
 
     def treeview_add_column(self, treeview, name, num):
         col = gtk.TreeViewColumn(name)



From haypo at berlios.de  Mon Dec  5 01:54:48 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 5 Dec 2005 01:54:48 +0100
Subject: [Happyboom-svn] r297 - haypo/greycstoration_gimp
Message-ID: <200512050054.jB50smiL006068@sheep.berlios.de>

Author: haypo
Date: 2005-12-05 01:54:31 +0100 (Mon, 05 Dec 2005)
New Revision: 297

Modified:
   haypo/greycstoration_gimp/AUTHORS
   haypo/greycstoration_gimp/ChangeLog
   haypo/greycstoration_gimp/INSTALL
Log:
Add  Thomas de Grenier de Latour to AUTHORS list.


Modified: haypo/greycstoration_gimp/AUTHORS
===================================================================
--- haypo/greycstoration_gimp/AUTHORS	2005-12-02 02:43:33 UTC (rev 296)
+++ haypo/greycstoration_gimp/AUTHORS	2005-12-05 00:54:31 UTC (rev 297)
@@ -8,3 +8,6 @@
     o nice(19) patch to limit CPU use
 Victor Stinner aka haypo <vitor.stinner AT haypocalc.com>
     o First author of the patch
+Thomas de Grenier de Latour <degrenier AT easyconnect.fr>
+    o Patch for use of autotools and getttext (based on official Gimp
+      plugin template), and also wrote first translation (in french)

Modified: haypo/greycstoration_gimp/ChangeLog
===================================================================
--- haypo/greycstoration_gimp/ChangeLog	2005-12-02 02:43:33 UTC (rev 296)
+++ haypo/greycstoration_gimp/ChangeLog	2005-12-05 00:54:31 UTC (rev 297)
@@ -1,3 +1,8 @@
+2005-11-22 Victor Stinner
+
+        * Version 0.1.3 
+        * Apply Thomas de Grenier de Latour (autotools + gettext). 
+
 2005-09-28 Victor Stinner
 
         * Apply Pedro C?rte-Real patch (nice).

Modified: haypo/greycstoration_gimp/INSTALL
===================================================================
--- haypo/greycstoration_gimp/INSTALL	2005-12-02 02:43:33 UTC (rev 296)
+++ haypo/greycstoration_gimp/INSTALL	2005-12-05 00:54:31 UTC (rev 297)
@@ -8,11 +8,10 @@
 - GTK 2.x (version 2.6 or greater?) and development headers of GTK+
   http://www.gtk.org/
 
-Instruction to compile
-======================
+Instructions to compile
+=======================
 
 ./autogen.sh
-./configure
 make
 make install
 



From haypo at berlios.de  Mon Dec  5 18:14:38 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 5 Dec 2005 18:14:38 +0100
Subject: [Happyboom-svn] r298 - in haypo/greycstoration_gimp: . po
Message-ID: <200512051714.jB5HEce2032483@sheep.berlios.de>

Author: haypo
Date: 2005-12-05 18:14:38 +0100 (Mon, 05 Dec 2005)
New Revision: 298

Added:
   haypo/greycstoration_gimp/po/ru.po
Modified:
   haypo/greycstoration_gimp/AUTHORS
   haypo/greycstoration_gimp/configure.in
Log:
Add russian translation of Alexandre Prokoudine


Modified: haypo/greycstoration_gimp/AUTHORS
===================================================================
--- haypo/greycstoration_gimp/AUTHORS	2005-12-05 00:54:31 UTC (rev 297)
+++ haypo/greycstoration_gimp/AUTHORS	2005-12-05 17:14:38 UTC (rev 298)
@@ -1,13 +1,15 @@
-David Tschumperl? <David.Tschumperle AT greyc.ensicaen.fr>
+David Tschumperl? <David.Tschumperle AT greyc.ensicaen.fr>, french
     o Author of the GREYCstoration algorithm
 David Rodr?guez Garc?a <david AT livux.com>
     o Patch to limit progress bar updates
-Michael Schumacher <schumaml AT gmx.de>
+Michael Schumacher <schumaml AT gmx.de>, german
     o Prepared Win32 binaries
 Pedro C?rte-Real <pedrocr AT gmail.com>
     o nice(19) patch to limit CPU use
-Victor Stinner aka haypo <vitor.stinner AT haypocalc.com>
+Victor Stinner aka haypo <vitor.stinner AT haypocalc.com>, french
     o First author of the patch
 Thomas de Grenier de Latour <degrenier AT easyconnect.fr>
     o Patch for use of autotools and getttext (based on official Gimp
       plugin template), and also wrote first translation (in french)
+Alexandre Prokoudine <alexandre.prokoudine AT gmail.com>, russian
+    o Russian translation

Modified: haypo/greycstoration_gimp/configure.in
===================================================================
--- haypo/greycstoration_gimp/configure.in	2005-12-05 00:54:31 UTC (rev 297)
+++ haypo/greycstoration_gimp/configure.in	2005-12-05 17:14:38 UTC (rev 298)
@@ -61,7 +61,7 @@
 AC_SUBST(GTK_LIBS)
 
 dnl i18n stuff
-ALL_LINGUAS="fr"
+ALL_LINGUAS="fr ru"
 GETTEXT_PACKAGE=gimp20-greycstoration
 AC_SUBST(GETTEXT_PACKAGE)
 AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,

Added: haypo/greycstoration_gimp/po/ru.po
===================================================================
--- haypo/greycstoration_gimp/po/ru.po	2005-12-05 00:54:31 UTC (rev 297)
+++ haypo/greycstoration_gimp/po/ru.po	2005-12-05 17:14:38 UTC (rev 298)
@@ -0,0 +1,78 @@
+# translation of ru.po to Russian
+# translation of gimp20-greycstoration.po to Russian
+# This file is distributed under the same license as the PACKAGE package.
+# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER.
+# Alexandre Prokoudine <alexandre.prokoudine at gmail.com>, 2005.
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: ru\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2005-12-05 03:43+0300\n"
+"PO-Revision-Date: 2005-12-05 03:55+0300\n"
+"Last-Translator: Alexandre Prokoudine <alexandre.prokoudine at gmail.com>\n"
+"Language-Team: Russian <ru at li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Generator: KBabel 1.10.2\n"
+"Plural-Forms:  nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
+
+#. Insert table in a new notebook page
+#: ../src/dialog.cpp:122
+msgid "Restore"
+msgstr "??????????????"
+
+#. Power1
+#: ../src/dialog.cpp:127
+msgid "_Detail factor (p1):"
+msgstr "?????. _??????????? (p1):"
+
+#: ../src/dialog.cpp:128
+msgid "_Gradient factor (p2):"
+msgstr "?????. _????????? (p2):"
+
+#: ../src/dialog.cpp:129
+msgid "_Time step (dt):"
+msgstr "_??? ?? ??????? (dt):"
+
+#: ../src/dialog.cpp:130
+msgid "_Blur (sigma):"
+msgstr "_?????????? (sigma):"
+
+#: ../src/dialog.cpp:131
+msgid "Blur _iterations (iter) :"
+msgstr "_???????? ?????????? (iter) :"
+
+#. New vbox
+#: ../src/dialog.cpp:141
+msgid "Quality"
+msgstr "????????"
+
+#. linear checkbox
+#: ../src/dialog.cpp:147
+msgid "Use linear interpolation:"
+msgstr "???????? ????????????:"
+
+#. normalize checkbox
+#: ../src/dialog.cpp:153
+msgid "Normalize picture to [0-255]:"
+msgstr "????????????? ??????????? ?? [0-255]:"
+
+#. Insert parameters into the table
+#: ../src/dialog.cpp:170
+msgid "_Angular step (da):"
+msgstr "??? _???? (da):"
+
+#: ../src/dialog.cpp:171
+msgid "_Integral step (dt):"
+msgstr "_???????????? ??? (dt):"
+
+#: ../src/dialog.cpp:172
+msgid "_Gaussian precision (gauss):"
+msgstr "???????? _???????? ????????? (gauss):"
+
+#: ../src/dialog.cpp:188
+msgid "GREYCstoration"
+msgstr "GREYCstoration"
+



From haypo at berlios.de  Mon Dec  5 18:54:33 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 5 Dec 2005 18:54:33 +0100
Subject: [Happyboom-svn] r299 - in haypo/greycstoration_gimp: . src
Message-ID: <200512051754.jB5HsX3L021556@sheep.berlios.de>

Author: haypo
Date: 2005-12-05 18:54:32 +0100 (Mon, 05 Dec 2005)
New Revision: 299

Modified:
   haypo/greycstoration_gimp/INSTALL
   haypo/greycstoration_gimp/Makefile.am
   haypo/greycstoration_gimp/configure.in
   haypo/greycstoration_gimp/src/Makefile.am
Log:
Last fixes (from Thomas) for autotoolification :-)


Modified: haypo/greycstoration_gimp/INSTALL
===================================================================
--- haypo/greycstoration_gimp/INSTALL	2005-12-05 17:14:38 UTC (rev 298)
+++ haypo/greycstoration_gimp/INSTALL	2005-12-05 17:54:32 UTC (rev 299)
@@ -8,14 +8,27 @@
 - GTK 2.x (version 2.6 or greater?) and development headers of GTK+
   http://www.gtk.org/
 
+The plugin is only tested on Linux, but Michael Schumacher
+prepared Win32 binaries.
+
 Instructions to compile
 =======================
 
-./autogen.sh
-make
-make install
+  ./configure  [see --help for options]
+  make
+  make install
 
-That's all :-)
+Last step ("make install") should be run by the root user. If you are not the
+administrator on your station, you can still install the plugin in your home 
+directory ("$HOME/.gimp-2.2/plug-ins/"):
+  gimptool --install-bin src/greycstoration
 
-The plugin is only tested on Linux, but Michael Schumacher
-prepared Win32 binaries.
+Instruction to compile SVN sources
+==================================
+
+Prior to running the above described commands, you must create the "configure"
+script by running this command:
+  ./autogen.sh
+
+This requires that you have installed some recent enough versions of GNU 
+autotools (tested with autoconf-1.9.6 and automake-2.59).

Modified: haypo/greycstoration_gimp/Makefile.am
===================================================================
--- haypo/greycstoration_gimp/Makefile.am	2005-12-05 17:14:38 UTC (rev 298)
+++ haypo/greycstoration_gimp/Makefile.am	2005-12-05 17:54:32 UTC (rev 299)
@@ -1,4 +1,4 @@
-AUTOMAKE_OPTIONS = foreign
+AUTOMAKE_OPTIONS = foreign dist-bzip2
 
 SUBDIRS = po src
 

Modified: haypo/greycstoration_gimp/configure.in
===================================================================
--- haypo/greycstoration_gimp/configure.in	2005-12-05 17:14:38 UTC (rev 298)
+++ haypo/greycstoration_gimp/configure.in	2005-12-05 17:54:32 UTC (rev 299)
@@ -4,7 +4,7 @@
 
 m4_define([plugin_major_version], [0])
 m4_define([plugin_minor_version], [1])
-m4_define([plugin_micro_version], [2])
+m4_define([plugin_micro_version], [3])
 m4_define([plugin_version],
           [plugin_major_version.plugin_minor_version.plugin_micro_version])
 

Modified: haypo/greycstoration_gimp/src/Makefile.am
===================================================================
--- haypo/greycstoration_gimp/src/Makefile.am	2005-12-05 17:14:38 UTC (rev 298)
+++ haypo/greycstoration_gimp/src/Makefile.am	2005-12-05 17:54:32 UTC (rev 299)
@@ -11,7 +11,6 @@
 	greycstoration.cpp \
 	image.h \
 	image.cpp \
-	main.h \
 	main.cpp
 
 AM_CPPFLAGS = \



From haypo at berlios.de  Tue Dec  6 01:48:10 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 01:48:10 +0100
Subject: [Happyboom-svn] r300 - in haypo: . greycstoration_gimp greycstoration_gimp/po
Message-ID: <200512060048.jB60mAU1016837@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 01:48:08 +0100 (Tue, 06 Dec 2005)
New Revision: 300

Added:
   haypo/greycstoration_gimp/po/ChangeLog
   haypo/tachatte.py
Modified:
   haypo/apache_log.py
   haypo/greycstoration_gimp/configure.in
Log:
- GREYCstoration 0.2.0 is out :-)
- Add Tachatte project
- Fix apache_log Python header


Modified: haypo/apache_log.py
===================================================================
--- haypo/apache_log.py	2005-12-05 17:54:32 UTC (rev 299)
+++ haypo/apache_log.py	2005-12-06 00:48:08 UTC (rev 300)
@@ -1,8 +1,9 @@
 #!/usr/bin/python
+# -*- coding: iso-8859-1 -*-
+#
 # Python script to parse Apache log file
-# 21 septembre 2005
+# Creation: 21 septembre 2005
 # Author: Victor Stinner
-#
 
 import re, time, sys, traceback
 

Modified: haypo/greycstoration_gimp/configure.in
===================================================================
--- haypo/greycstoration_gimp/configure.in	2005-12-05 17:54:32 UTC (rev 299)
+++ haypo/greycstoration_gimp/configure.in	2005-12-06 00:48:08 UTC (rev 300)
@@ -3,8 +3,8 @@
 m4_define([plugin_name], [greycstoration])
 
 m4_define([plugin_major_version], [0])
-m4_define([plugin_minor_version], [1])
-m4_define([plugin_micro_version], [3])
+m4_define([plugin_minor_version], [2])
+m4_define([plugin_micro_version], [0])
 m4_define([plugin_version],
           [plugin_major_version.plugin_minor_version.plugin_micro_version])
 

Added: haypo/greycstoration_gimp/po/ChangeLog
===================================================================
--- haypo/greycstoration_gimp/po/ChangeLog	2005-12-05 17:54:32 UTC (rev 299)
+++ haypo/greycstoration_gimp/po/ChangeLog	2005-12-06 00:48:08 UTC (rev 300)
@@ -0,0 +1,3 @@
+2005-12-05 Victor Stinner
+
+        * Add russian translation, thanks Alexandre Prokoudine

Added: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-05 17:54:32 UTC (rev 299)
+++ haypo/tachatte.py	2005-12-06 00:48:08 UTC (rev 300)
@@ -0,0 +1,170 @@
+#!/usr/bin/python
+# -*- coding: iso-8859-1 -*-
+#
+# Tachatte: obsursify C source code.
+# Creation: 6 decembre 2005
+# Author: Victor Stinner
+
+import sys, re, random, string
+
+class Word:
+    def __init__(self, old, new):
+        self.old = old
+        self.new = new
+
+class Tachatter:
+    def __init__(self, file):
+        # Options
+        self.encode_number = True
+        self.encode_string = True
+        self.obscure = \
+            ["tachatte", "zob", "couille", "merde",
+             "poil", "grossepute", "putain", "encule",
+             "batard", "tarace", "chameau"]
+        
+        # Attributes
+        self.word=None
+        self.thesaurus={}
+        self.exclude = ["if", "else", "return", "for", "while", "do"]
+        self.file = file
+        self.regex_c_include = re.compile("^include")
+        self.c_include = ""
+        self.start_word = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
+        if self.encode_number:
+            self.start_word = self.start_word + "0123456789"
+        self.content = []
+        self.process()
+
+    def getContent(self):
+        text = ""
+        for item in self.content:
+            if isinstance(item, Word):
+                text = text + item.new
+            else:
+                text = text + item
+        return text                
+
+    def getHeaders(self):
+        content = self.c_include
+        for word in self.thesaurus:
+            item = self.thesaurus[word]
+            content = content + "#define %s %s\n" % (item.new, item.old)
+        return content
+
+    def readComment(self):
+        while True:
+            c=self.file.read(1)
+            assert c != ""
+            if c == "*":
+                c = self.file.read(1)
+                if c == "/":
+                    return
+
+    def readString(self, quote):
+        str = quote
+        while True:
+            c=self.file.read(1)
+            str = str + c
+            assert c != ""
+            if c == quote:
+                break
+        if self.encode_string:                
+            self.unputWord(str)                
+        else:
+            self.unput(str)
+
+    def process(self, c):
+        if self.word != None:
+            self.word = self.word + c
+        else:
+            self.word = c
+
+    def generateWord(self, new_thesaurus):
+        tries = 0
+        while tries < 100:
+            tries = tries + 1
+            index = random.randint(0, len(self.obscure)-1)
+            obscure = self.obscure[index]
+            new = ""
+            for c in obscure:
+                if 70 < random.randint(0,100):
+                    # Take 30% of upper case
+                    new = new + string.upper(c)
+                else:
+                    new = new + c
+            if new not in self.thesaurus \
+            and new not in new_thesaurus:
+                return new
+        raise Exception("No more shit!")
+        
+    def unput(self, str):
+        self.content.append(str)
+
+    def unputWord(self, word):
+        if word not in self.thesaurus:
+            key = len(self.thesaurus)+1
+            self.thesaurus[word] = Word(word, None) 
+        self.content.append( self.thesaurus[word] )
+
+    def processEOL(self, c):
+        if self.word != None:
+            if self.word in self.exclude:
+                self.unput(self.word)
+            else:
+                self.unputWord(self.word)
+            self.word = None
+        if c != None:
+            self.unput(c)
+
+    def process(self):       
+        while True:
+            c = self.file.read(1)
+            if c == '':
+                break
+            elif c=="#":
+                line = self.file.readline()
+                if self.regex_c_include.match(line) != None:
+                    self.c_include = self.c_include + "#%s" % line 
+                else:
+                    self.unput('#'+line)
+            elif c in ("'", "\""):
+                self.readString(c)
+            elif c=="/":
+                c=f.read(1)
+                if c == "/":
+                    line = self.file.readline()
+                    self.unput('/'+line)
+                elif c=="*":
+                    self.readComment()
+                else:
+                    f.seek(-1,1)
+            elif c in self.start_word:
+                if self.word != None:
+                    self.word = self.word + c
+                else:
+                    self.word = c
+            else:
+                self.processEOL(c)
+        self.processEOL(None)
+        self.generateThesaurus()
+
+    def generateThesaurus(self):        
+        new_words = {}
+        for word in self.thesaurus:
+            item = self.thesaurus[word]
+            item.new = self.generateWord(new_words)
+            new_words[item.new] = item
+
+def usage():
+    print "Usage: %s file.c" % sys.argv[0]
+    sys.exit(1)
+
+if __name__=="__main__":
+    if len(sys.argv)<2:
+        usage()
+    f=open(sys.argv[1])
+    random.seed()
+    t=Tachatter(f)
+    sys.stdout.write(t.getHeaders())
+    sys.stdout.write(t.getContent())
+    f.close()



From haypo at berlios.de  Tue Dec  6 02:09:27 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 02:09:27 +0100
Subject: [Happyboom-svn] r301 - haypo
Message-ID: <200512060109.jB619RLT023036@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 02:09:22 +0100 (Tue, 06 Dec 2005)
New Revision: 301

Modified:
   haypo/tachatte.py
Log:
Add reversible mode to tachatte.


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 00:48:08 UTC (rev 300)
+++ haypo/tachatte.py	2005-12-06 01:09:22 UTC (rev 301)
@@ -6,6 +6,8 @@
 # Author: Victor Stinner
 
 import sys, re, random, string
+PROGRAM="Tachatte"
+VERSION="2005-12-06"
 
 class Word:
     def __init__(self, old, new):
@@ -13,27 +15,28 @@
         self.new = new
 
 class Tachatter:
-    def __init__(self, file):
+    def __init__(self):
         # Options
         self.encode_number = True
         self.encode_string = True
+        self.reversible = False
         self.obscure = \
             ["tachatte", "zob", "couille", "merde",
              "poil", "grossepute", "putain", "encule",
              "batard", "tarace", "chameau"]
         
         # Attributes
-        self.word=None
+        self.uniq = 1
+        self.word = None
         self.thesaurus={}
         self.exclude = ["if", "else", "return", "for", "while", "do"]
-        self.file = file
+        self.file = None
         self.regex_c_include = re.compile("^include")
         self.c_include = ""
         self.start_word = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
         if self.encode_number:
             self.start_word = self.start_word + "0123456789"
         self.content = []
-        self.process()
 
     def getContent(self):
         text = ""
@@ -46,9 +49,10 @@
 
     def getHeaders(self):
         content = self.c_include
-        for word in self.thesaurus:
-            item = self.thesaurus[word]
-            content = content + "#define %s %s\n" % (item.new, item.old)
+        if not self.reversible:
+            for word in self.thesaurus:
+                item = self.thesaurus[word]
+                content = content + "#define %s %s\n" % (item.new, item.old)
         return content
 
     def readComment(self):
@@ -73,13 +77,23 @@
         else:
             self.unput(str)
 
-    def process(self, c):
-        if self.word != None:
-            self.word = self.word + c
-        else:
-            self.word = c
+    def generateWordReversible(self, new_thesaurus):
+        self.uniq = self.uniq + 1
+        if 256 <= self.uniq:
+            raise Exception("No more shit!")
+        up="TACHATTE"
+        down="tachatte"
+        word = ""
+        index = self.uniq
+        for i in range(0,8):
+            if (index & 1 == 1):
+                word = word + up[i]
+            else:
+                word = word + down[i]
+            index = index/2
+        return word     
 
-    def generateWord(self, new_thesaurus):
+    def generateWordRandom(self, new_thesaurus):
         tries = 0
         while tries < 100:
             tries = tries + 1
@@ -116,7 +130,8 @@
         if c != None:
             self.unput(c)
 
-    def process(self):       
+    def process(self, file):
+        self.file = file
         while True:
             c = self.file.read(1)
             if c == '':
@@ -152,19 +167,61 @@
         new_words = {}
         for word in self.thesaurus:
             item = self.thesaurus[word]
-            item.new = self.generateWord(new_words)
+            if self.reversible:
+                item.new = self.generateWordReversible(new_words)
+            else:
+                item.new = self.generateWordRandom(new_words)
             new_words[item.new] = item
 
 def usage():
-    print "Usage: %s file.c" % sys.argv[0]
-    sys.exit(1)
+    print "%s version %s" % (PROGRAM, VERSION)
+    print ""
+    print "Usage: %s [options] file.c" % (sys.argv[0])
+    print
+    print "Options :"
+    print "\t--help            : Print this help"
+    print "\t--version         : Print the software version"
+    print "\t--reversible      : Use reversible mode"
+    sys.exit(2)
 
+def parseArgs(tachatte):
+    import getopt
+
+    try:
+        short = ""
+        long = ["help", "version", \
+            "reversible"]
+        opts, args = getopt.getopt(sys.argv[1:], short, long)
+    except getopt.GetoptError:
+        usage()
+        
+    for o, a in opts:
+        if o == "--help":
+            usage()
+        if o == "--version":
+            print "%s version %s" % (PROGRAM, VERSION)
+            sys.exit(0)
+        if o == "--reversible":
+            tachatte.reversible = True
+
+    if len(args) != 1:
+        usage()
+
+    return args[0]
+
 if __name__=="__main__":
     if len(sys.argv)<2:
         usage()
-    f=open(sys.argv[1])
+
+    # Prepare
+    t=Tachatter()
+    filename = parseArgs(t)
     random.seed()
-    t=Tachatter(f)
+
+    # Process file
+    file = open(filename)
+    t.process(file)
+
+    # Display result
     sys.stdout.write(t.getHeaders())
     sys.stdout.write(t.getContent())
-    f.close()



From haypo at berlios.de  Tue Dec  6 03:19:06 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 03:19:06 +0100
Subject: [Happyboom-svn] r302 - haypo
Message-ID: <200512060219.jB62J6Kd022255@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 03:18:54 +0100 (Tue, 06 Dec 2005)
New Revision: 302

Modified:
   haypo/tachatte.py
Log:
Some fixed in tachatte:
- Support macro on multilines (lines ending with "\")
- More command line options: --eat-comments, --number=enable, --string=enable
- Small fixes


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 01:09:22 UTC (rev 301)
+++ haypo/tachatte.py	2005-12-06 02:18:54 UTC (rev 302)
@@ -20,6 +20,7 @@
         self.encode_number = True
         self.encode_string = True
         self.reversible = False
+        self.eat_comments = False 
         self.obscure = \
             ["tachatte", "zob", "couille", "merde",
              "poil", "grossepute", "putain", "encule",
@@ -31,11 +32,9 @@
         self.thesaurus={}
         self.exclude = ["if", "else", "return", "for", "while", "do"]
         self.file = None
-        self.regex_c_include = re.compile("^include")
+        self.regex_c_include = re.compile("^# *include")
         self.c_include = ""
-        self.start_word = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
-        if self.encode_number:
-            self.start_word = self.start_word + "0123456789"
+        self.start_word = "_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
         self.content = []
 
     def getContent(self):
@@ -56,12 +55,17 @@
         return content
 
     def readComment(self):
+        comment = "/*"
         while True:
             c=self.file.read(1)
             assert c != ""
+            comment = comment + c
             if c == "*":
                 c = self.file.read(1)
+                comment = comment + c
                 if c == "/":
+                    if not self.eat_comments:
+                        self.unput(comment)
                     return
 
     def readString(self, quote):
@@ -120,47 +124,56 @@
             self.thesaurus[word] = Word(word, None) 
         self.content.append( self.thesaurus[word] )
 
-    def processEOL(self, c):
+    def processEOL(self):
         if self.word != None:
             if self.word in self.exclude:
                 self.unput(self.word)
             else:
                 self.unputWord(self.word)
             self.word = None
-        if c != None:
-            self.unput(c)
 
     def process(self, file):
+        if self.encode_number:
+            self.start_word = self.start_word + "0123456789"
         self.file = file
         while True:
             c = self.file.read(1)
             if c == '':
                 break
-            elif c=="#":
-                line = self.file.readline()
-                if self.regex_c_include.match(line) != None:
-                    self.c_include = self.c_include + "#%s" % line 
-                else:
-                    self.unput('#'+line)
-            elif c in ("'", "\""):
-                self.readString(c)
-            elif c=="/":
-                c=f.read(1)
-                if c == "/":
-                    line = self.file.readline()
-                    self.unput('/'+line)
-                elif c=="*":
-                    self.readComment()
-                else:
-                    f.seek(-1,1)
-            elif c in self.start_word:
+
+            if c in self.start_word:
                 if self.word != None:
                     self.word = self.word + c
                 else:
                     self.word = c
             else:
-                self.processEOL(c)
-        self.processEOL(None)
+                self.processEOL()
+                if c=="#":
+                    line = self.file.readline()
+                    macro = "#"+line
+                    while re.match(r"^.*\\ *$", line.strip()) != None:
+                        line = self.file.readline()
+                        macro = macro + line
+                    if self.regex_c_include.match(macro) != None:
+                        self.c_include = self.c_include + macro 
+                    else:
+                        self.unput(macro)
+                elif c in ("'", "\""):
+                    self.readString(c)
+                elif c=="/":
+                    d = self.file.read(1)
+                    if d == "/":
+                        line = self.file.readline()
+                        if not self.eat_comments:
+                            self.unput('//'+line)
+                    elif d=="*":
+                        self.readComment()
+                    else:
+                        self.unput(c)
+                        self.file.seek(-1, 1)
+                else:
+                    self.unput(c)
+        self.processEOL()
         self.generateThesaurus()
 
     def generateThesaurus(self):        
@@ -182,15 +195,28 @@
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
     print "\t--reversible      : Use reversible mode"
+    print "\t--eat-comments    : Eat comments (default: off)"
+    print "\t--number=ENABLE   : Encode numbers? (default: on)"
+    print "\t--string=ENABLE   : Encode numbers? (default: on)"
+    print
+    print "Values for ENABLE: 0, 1, on, off, true or false."
     sys.exit(2)
 
+def arg2bool(arg):
+    arg = arg.lower()
+    if arg in ("0", "off", "false"):
+        return False
+    if arg in ("1", "on", "true"):
+        return True
+    usage()        
+
 def parseArgs(tachatte):
     import getopt
 
     try:
         short = ""
         long = ["help", "version", \
-            "reversible"]
+            "reversible", "number=", "string="]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage()
@@ -203,6 +229,12 @@
             sys.exit(0)
         if o == "--reversible":
             tachatte.reversible = True
+        if o == "--eat-comments":
+            tachatte.eat_comments = True
+        if o == "--number":
+            tachatte.encode_number = arg2bool(a)
+        if o == "--string":
+            tachatte.encode_string = arg2bool(a)
 
     if len(args) != 1:
         usage()



From haypo at berlios.de  Tue Dec  6 03:27:53 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 03:27:53 +0100
Subject: [Happyboom-svn] r303 - haypo
Message-ID: <200512060227.jB62Rr0N025549@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 03:27:24 +0100 (Tue, 06 Dec 2005)
New Revision: 303

Modified:
   haypo/tachatte.py
Log:
Fix multiline comment parser


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 02:18:54 UTC (rev 302)
+++ haypo/tachatte.py	2005-12-06 02:27:24 UTC (rev 303)
@@ -56,17 +56,19 @@
 
     def readComment(self):
         comment = "/*"
+        end = 0
         while True:
             c=self.file.read(1)
             assert c != ""
             comment = comment + c
             if c == "*":
-                c = self.file.read(1)
-                comment = comment + c
-                if c == "/":
-                    if not self.eat_comments:
-                        self.unput(comment)
-                    return
+                end = 1
+            elif end == 1 and c == "/":
+                if not self.eat_comments:
+                    self.unput(comment)
+                return
+            else:
+                end = 0
 
     def readString(self, quote):
         str = quote
@@ -216,7 +218,8 @@
     try:
         short = ""
         long = ["help", "version", \
-            "reversible", "number=", "string="]
+            "reversible", "eat-comments",
+            "number=", "string="]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage()



From haypo at berlios.de  Tue Dec  6 04:27:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 04:27:22 +0100
Subject: [Happyboom-svn] r304 - haypo
Message-ID: <200512060327.jB63RMNM025769@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 04:27:18 +0100 (Tue, 06 Dec 2005)
New Revision: 304

Modified:
   haypo/tachatte.py
Log:
Add modes "moo" and "shit"


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 02:27:24 UTC (rev 303)
+++ haypo/tachatte.py	2005-12-06 03:27:18 UTC (rev 304)
@@ -9,6 +9,16 @@
 PROGRAM="Tachatte"
 VERSION="2005-12-06"
 
+def count_bits(n):
+    if n < 2:
+        return 1
+    length = 0
+    n = n - 1
+    while 0 < n:
+        n = n/2
+        length = length + 1
+    return length
+
 class Word:
     def __init__(self, old, new):
         self.old = old
@@ -19,7 +29,7 @@
         # Options
         self.encode_number = True
         self.encode_string = True
-        self.reversible = False
+        self.mode = "random"
         self.eat_comments = False 
         self.obscure = \
             ["tachatte", "zob", "couille", "merde",
@@ -27,7 +37,8 @@
              "batard", "tarace", "chameau"]
         
         # Attributes
-        self.uniq = 1
+        self.uniq = 0
+        self.word_generator = None
         self.word = None
         self.thesaurus={}
         self.exclude = ["if", "else", "return", "for", "while", "do"]
@@ -48,10 +59,9 @@
 
     def getHeaders(self):
         content = self.c_include
-        if not self.reversible:
-            for word in self.thesaurus:
-                item = self.thesaurus[word]
-                content = content + "#define %s %s\n" % (item.new, item.old)
+        for word in self.thesaurus:
+            item = self.thesaurus[word]
+            content = content + "#define %s %s\n" % (item.new, item.old)
         return content
 
     def readComment(self):
@@ -83,20 +93,38 @@
         else:
             self.unput(str)
 
-    def generateWordReversible(self, new_thesaurus):
+    def generateWord(self, word, new_thesaurus):
+        if self.mode in ("moo", "tachatte"):
+            return self.generateWordUniq(new_thesaurus)
+        elif self.mode == "shit":
+            return self.generateWordRepeat(new_thesaurus)
+        else:
+            return self.generateWordRandom(new_thesaurus)
+
+    def generateWordRepeat(self, new_thesaurus):
+        if 1000 <= self.uniq:
+            raise Exception("Too much shit! (more than %u words)" % 1000)
+        start_up, start_low, repeat, end = self.word_generator
+        if self.uniq & 1 == 1:
+            word = start_up + repeat * (1+self.uniq/2) + end
+        else:            
+            word = start_low + repeat * (1+self.uniq/2) + end
         self.uniq = self.uniq + 1
-        if 256 <= self.uniq:
-            raise Exception("No more shit!")
-        up="TACHATTE"
-        down="tachatte"
+        return word
+
+    def generateWordUniq(self, new_thesaurus):
+        up, down = self.word_generator
+        if (1 << len(up)) <= self.uniq:
+            raise Exception("No more shit! (more than %u words)" % (1 << len(up)))
         word = ""
         index = self.uniq
-        for i in range(0,8):
+        for i in range(0,len(up)):
             if (index & 1 == 1):
                 word = word + up[i]
             else:
                 word = word + down[i]
             index = index/2
+        self.uniq = self.uniq + 1
         return word     
 
     def generateWordRandom(self, new_thesaurus):
@@ -179,13 +207,23 @@
         self.generateThesaurus()
 
     def generateThesaurus(self):        
+        # Compute length of thesaurus in bits
+        length = count_bits( len(self.thesaurus) )
+            
+        #?Choose uniq word generator
+        if self.mode == "shit":
+            self.word_generator = ("Sh", "sh", "i", "t")
+        elif self.mode == "moo":
+            if length<3:
+                length = 3
+            self.word_generator = ("M"+"O"*(length-1), "m"+"o"*(length-1))
+        else:
+            self.word_generator = ("TACHATTE", "tachatte")
+
         new_words = {}
         for word in self.thesaurus:
             item = self.thesaurus[word]
-            if self.reversible:
-                item.new = self.generateWordReversible(new_words)
-            else:
-                item.new = self.generateWordRandom(new_words)
+            item.new = self.generateWord(item.old, new_words)
             new_words[item.new] = item
 
 def usage():
@@ -196,7 +234,7 @@
     print "Options :"
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
-    print "\t--reversible      : Use reversible mode"
+    print "\t--mode=MODE       : Mode (random, moo, tachatte or shit)"
     print "\t--eat-comments    : Eat comments (default: off)"
     print "\t--number=ENABLE   : Encode numbers? (default: on)"
     print "\t--string=ENABLE   : Encode numbers? (default: on)"
@@ -218,7 +256,7 @@
     try:
         short = ""
         long = ["help", "version", \
-            "reversible", "eat-comments",
+            "mode=", "eat-comments",
             "number=", "string="]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
@@ -227,17 +265,22 @@
     for o, a in opts:
         if o == "--help":
             usage()
-        if o == "--version":
+        elif o == "--version":
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit(0)
-        if o == "--reversible":
-            tachatte.reversible = True
-        if o == "--eat-comments":
+        elif o == "--mode":
+            if a not in ("random", "tachatte", "moo", "shit"):
+                usage()
+            tachatte.mode = a
+        elif o == "--eat-comments":
             tachatte.eat_comments = True
-        if o == "--number":
+        elif o == "--number":
             tachatte.encode_number = arg2bool(a)
-        if o == "--string":
+        elif o == "--string":
             tachatte.encode_string = arg2bool(a)
+        else:
+            # What's the hell?!
+            usage()
 
     if len(args) != 1:
         usage()



From haypo at berlios.de  Tue Dec  6 05:11:44 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 05:11:44 +0100
Subject: [Happyboom-svn] r305 - haypo
Message-ID: <200512060411.jB64BiOT012206@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 05:11:41 +0100 (Tue, 06 Dec 2005)
New Revision: 305

Modified:
   haypo/tachatte.py
Log:
Add letter mode.


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 03:27:18 UTC (rev 304)
+++ haypo/tachatte.py	2005-12-06 04:11:41 UTC (rev 305)
@@ -98,6 +98,8 @@
             return self.generateWordUniq(new_thesaurus)
         elif self.mode == "shit":
             return self.generateWordRepeat(new_thesaurus)
+        elif self.mode == "letter":
+            return self.generateWordLetter(new_thesaurus)
         else:
             return self.generateWordRandom(new_thesaurus)
 
@@ -125,8 +127,24 @@
                 word = word + down[i]
             index = index/2
         self.uniq = self.uniq + 1
-        return word     
+        return word
 
+    def generateWordLetter(self, new_thesaurus):
+        up, down = self.word_generator
+        if (1 << len(up)) <= self.uniq:
+            raise Exception("No more shit! (more than %u words)" % (1 << len(up)))
+        word = ""
+        word = chr(ord('a') + self.uniq % 26)
+        index = self.uniq / 26
+        self.uniq = self.uniq + 1
+        if index == 1:
+            return "a"+word
+        index = index - 1
+        while 0 < index:
+            word = word + chr(ord('a')+index % 26)
+            index = index / 26
+        return word[::-1] 
+
     def generateWordRandom(self, new_thesaurus):
         tries = 0
         while tries < 100:
@@ -234,7 +252,7 @@
     print "Options :"
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
-    print "\t--mode=MODE       : Mode (random, moo, tachatte or shit)"
+    print "\t--mode=MODE       : Mode (random, moo, tachatte, letter or shit)"
     print "\t--eat-comments    : Eat comments (default: off)"
     print "\t--number=ENABLE   : Encode numbers? (default: on)"
     print "\t--string=ENABLE   : Encode numbers? (default: on)"
@@ -269,7 +287,7 @@
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit(0)
         elif o == "--mode":
-            if a not in ("random", "tachatte", "moo", "shit"):
+            if a not in ("random", "tachatte", "moo", "shit", "letter"):
                 usage()
             tachatte.mode = a
         elif o == "--eat-comments":



From haypo at berlios.de  Tue Dec  6 05:47:08 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 05:47:08 +0100
Subject: [Happyboom-svn] r306 - haypo
Message-ID: <200512060447.jB64l8Jm020247@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 05:47:06 +0100 (Tue, 06 Dec 2005)
New Revision: 306

Modified:
   haypo/tachatte.py
Log:
Rename random mode to "words" mode, and sort thesaurus


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 04:11:41 UTC (rev 305)
+++ haypo/tachatte.py	2005-12-06 04:47:06 UTC (rev 306)
@@ -8,7 +8,17 @@
 import sys, re, random, string
 PROGRAM="Tachatte"
 VERSION="2005-12-06"
+        
+def sortThesaurusItem(a,b):
+    return b.count - a.count
 
+def sortThesaurus(thesaurus):
+    sorted = []
+    for item in thesaurus.values():
+        sorted.append(item)
+    sorted.sort(sortThesaurusItem)
+    return sorted 
+
 def count_bits(n):
     if n < 2:
         return 1
@@ -20,17 +30,20 @@
     return length
 
 class Word:
-    def __init__(self, old, new):
+    def __init__(self, old, new, need_define):
         self.old = old
         self.new = new
+        self.count = 1
+        self.need_define = need_define 
 
 class Tachatter:
     def __init__(self):
         # Options
         self.encode_number = True
         self.encode_string = True
-        self.mode = "random"
+        self.mode = "words"
         self.eat_comments = False 
+        self.sort_thesaurus = True  # most used names are shorter
         self.obscure = \
             ["tachatte", "zob", "couille", "merde",
              "poil", "grossepute", "putain", "encule",
@@ -61,7 +74,8 @@
         content = self.c_include
         for word in self.thesaurus:
             item = self.thesaurus[word]
-            content = content + "#define %s %s\n" % (item.new, item.old)
+            if item.need_define:
+                content = content + "#define %s %s\n" % (item.new, item.old)
         return content
 
     def readComment(self):
@@ -166,11 +180,15 @@
     def unput(self, str):
         self.content.append(str)
 
-    def unputWord(self, word):
+    def unputWord(self, word, need_define=True):
         if word not in self.thesaurus:
             key = len(self.thesaurus)+1
-            self.thesaurus[word] = Word(word, None) 
-        self.content.append( self.thesaurus[word] )
+            item = Word(word, None, need_define) 
+            self.thesaurus[word] = item
+        else:
+            item = self.thesaurus[word]
+            item.count = item.count + 1
+        self.content.append(item)
 
     def processEOL(self):
         if self.word != None:
@@ -238,9 +256,12 @@
         else:
             self.word_generator = ("TACHATTE", "tachatte")
 
+        if self.sort_thesaurus:
+            values = sortThesaurus(self.thesaurus)
+        else:
+            values = self.thesaurus.values()
         new_words = {}
-        for word in self.thesaurus:
-            item = self.thesaurus[word]
+        for item in values:
             item.new = self.generateWord(item.old, new_words)
             new_words[item.new] = item
 
@@ -252,7 +273,7 @@
     print "Options :"
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
-    print "\t--mode=MODE       : Mode (random, moo, tachatte, letter or shit)"
+    print "\t--mode=MODE       : Mode (words, moo, tachatte, letter or shit)"
     print "\t--eat-comments    : Eat comments (default: off)"
     print "\t--number=ENABLE   : Encode numbers? (default: on)"
     print "\t--string=ENABLE   : Encode numbers? (default: on)"
@@ -287,7 +308,7 @@
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit(0)
         elif o == "--mode":
-            if a not in ("random", "tachatte", "moo", "shit", "letter"):
+            if a not in ("words", "tachatte", "moo", "shit", "letter"):
                 usage()
             tachatte.mode = a
         elif o == "--eat-comments":
@@ -296,9 +317,6 @@
             tachatte.encode_number = arg2bool(a)
         elif o == "--string":
             tachatte.encode_string = arg2bool(a)
-        else:
-            # What's the hell?!
-            usage()
 
     if len(args) != 1:
         usage()



From haypo at berlios.de  Tue Dec  6 22:18:34 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 6 Dec 2005 22:18:34 +0100
Subject: [Happyboom-svn] r307 - haypo
Message-ID: <200512062118.jB6LIYO0027978@sheep.berlios.de>

Author: haypo
Date: 2005-12-06 22:18:33 +0100 (Tue, 06 Dec 2005)
New Revision: 307

Modified:
   haypo/tachatte.py
Log:
Tachatte has new features:
- "--syntax=1": encode syntax
- "--random": shuffle thesaurus
- "--eat-spaces": eat spaces

Output is wrapped to 79 characters width (if eat spaces if enabled).

Fix: generateWord checks that new word doesn't exist in thesaurus nor in
new word thesaurus.


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2005-12-06 04:47:06 UTC (rev 306)
+++ haypo/tachatte.py	2005-12-06 21:18:33 UTC (rev 307)
@@ -41,9 +41,12 @@
         # Options
         self.encode_number = True
         self.encode_string = True
+        self.encode_syntax = False 
         self.mode = "words"
         self.eat_comments = False 
-        self.sort_thesaurus = True  # most used names are shorter
+        self.eat_spaces = False 
+        self.sort_thesaurus = False # most used names are shorter
+        self.random_thesaurus = False  # most used names are shorter
         self.obscure = \
             ["tachatte", "zob", "couille", "merde",
              "poil", "grossepute", "putain", "encule",
@@ -55,25 +58,44 @@
         self.word = None
         self.thesaurus={}
         self.exclude = ["if", "else", "return", "for", "while", "do"]
+        self.exclude = []
+        self.syntax1 = re.compile(r"[][{}();,.*=&|:?+!<>-]")
+        self.syntax2 = re.compile(r"(?:[*/+-=|!]=|\+\+|--|&&|\<\<|\>\>|\|\||-\>)")
+        self.syntax3 = re.compile(r"(?:(?:\<\<|\>\>)=|\.\.\.)")
         self.file = None
         self.regex_c_include = re.compile("^# *include")
         self.c_include = ""
         self.start_word = "_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
         self.content = []
 
-    def getContent(self):
+    def getContent(self, width=79):
         text = ""
+        line = ""
+        tmp_text = ""
+        if not self.eat_spaces:
+            width = None
         for item in self.content:
             if isinstance(item, Word):
-                text = text + item.new
+                str_item = item.new
             else:
-                text = text + item
+                str_item = item
+#       TODO: Fix code to allow wrap       
+            if width != None:
+                if width <= len(line + str_item):
+                    text = text + line + "\n"
+                    line = ""
+            line = line + str_item
+        text = text + line            
+        if self.eat_spaces:
+            text = text.strip()+"\n"
         return text                
 
     def getHeaders(self):
         content = self.c_include
-        for word in self.thesaurus:
-            item = self.thesaurus[word]
+        values = self.thesaurus.values()
+        if self.random_thesaurus:
+            random.shuffle(values)
+        for item in values:
             if item.need_define:
                 content = content + "#define %s %s\n" % (item.new, item.old)
         return content
@@ -108,16 +130,27 @@
             self.unput(str)
 
     def generateWord(self, word, new_thesaurus):
-        if self.mode in ("moo", "tachatte"):
-            return self.generateWordUniq(new_thesaurus)
-        elif self.mode == "shit":
-            return self.generateWordRepeat(new_thesaurus)
-        elif self.mode == "letter":
-            return self.generateWordLetter(new_thesaurus)
-        else:
-            return self.generateWordRandom(new_thesaurus)
+        last = None
+        tries = 1
+        while tries < 100:
+            if self.mode in ("moo", "tachatte"):
+                word = self.generateWordUniq()
+            elif self.mode == "shit":
+                word = self.generateWordRepeat()
+            elif self.mode == "letter":
+                word = self.generateWordLetter()
+            else:
+                word = self.generateWordRandom()
+            if word not in self.thesaurus \
+            and word not in new_thesaurus:
+                return word
+            if word == last:
+                break
+            last = word
+            tries = tries + 1
+        raise Exception("No more shit!")
 
-    def generateWordRepeat(self, new_thesaurus):
+    def generateWordRepeat(self):
         if 1000 <= self.uniq:
             raise Exception("Too much shit! (more than %u words)" % 1000)
         start_up, start_low, repeat, end = self.word_generator
@@ -128,22 +161,21 @@
         self.uniq = self.uniq + 1
         return word
 
-    def generateWordUniq(self, new_thesaurus):
-        up, down = self.word_generator
-        if (1 << len(up)) <= self.uniq:
-            raise Exception("No more shit! (more than %u words)" % (1 << len(up)))
+    def generateWordUniq(self):
+        base = len(self.word_generator)
+        length = len(self.word_generator[0])
+        max = base ** length 
+        if max <= self.uniq:
+            raise Exception("No more shit! (more than %u words)" % max)
         word = ""
         index = self.uniq
-        for i in range(0,len(up)):
-            if (index & 1 == 1):
-                word = word + up[i]
-            else:
-                word = word + down[i]
-            index = index/2
+        for i in range(0,length):
+            word = word + self.word_generator[index % base][i]
+            index = index / base
         self.uniq = self.uniq + 1
         return word
 
-    def generateWordLetter(self, new_thesaurus):
+    def generateWordLetter(self):
         up, down = self.word_generator
         if (1 << len(up)) <= self.uniq:
             raise Exception("No more shit! (more than %u words)" % (1 << len(up)))
@@ -159,24 +191,36 @@
             index = index / 26
         return word[::-1] 
 
-    def generateWordRandom(self, new_thesaurus):
-        tries = 0
-        while tries < 100:
-            tries = tries + 1
-            index = random.randint(0, len(self.obscure)-1)
-            obscure = self.obscure[index]
-            new = ""
-            for c in obscure:
-                if 70 < random.randint(0,100):
-                    # Take 30% of upper case
-                    new = new + string.upper(c)
-                else:
-                    new = new + c
-            if new not in self.thesaurus \
-            and new not in new_thesaurus:
-                return new
-        raise Exception("No more shit!")
+    def generateWordRandom(self):
+        index = random.randint(0, len(self.obscure)-1)
+        obscure = self.obscure[index]
+        new = ""
+        for c in obscure:
+            if 70 < random.randint(0,100):
+                # Take 30% of upper case
+                new = new + string.upper(c)
+            else:
+                new = new + c
+        return new                
         
+    def last_is_new_line(self):
+        if len(self.content) == 0:
+            return None
+        last = self.content[-1]
+        if isinstance(last, Word):
+            return False
+        else:
+            return last[-1] in "\r\n"
+
+    def last_is_space(self):
+        if len(self.content) == 0:
+            return None
+        last = self.content[-1]
+        if isinstance(last, Word):
+            return False
+        else:
+            return last[-1] in string.whitespace
+
     def unput(self, str):
         self.content.append(str)
 
@@ -198,9 +242,16 @@
                 self.unputWord(self.word)
             self.word = None
 
-    def process(self, file):
+    def init(self):
+        if self.mode == "letter" and not self.random_thesaurus:
+            self.sort_thesaurus = True 
+        if self.sort_thesaurus:
+            self.random_thesaurus = False
         if self.encode_number:
             self.start_word = self.start_word + "0123456789"
+
+    def process(self, file):
+        self.init()
         self.file = file
         while True:
             c = self.file.read(1)
@@ -224,6 +275,24 @@
                         self.c_include = self.c_include + macro 
                     else:
                         self.unput(macro)
+                elif self.encode_syntax and self.syntax1.match(c) != None:
+                    d = self.file.read(1)
+                    e = self.file.read(1)
+                    cd = c+d
+                    cde = cd+e
+                    if not self.last_is_space():
+                        self.unput(" ")
+                    if len(cde) == 3 and self.syntax3.match(c+d+e) != None:
+                        self.unputWord(c+d+e)
+                        self.unput(" ")
+                    elif len(cd) == 2 and self.syntax2.match(c+d) != None:
+                        self.unputWord(c+d)
+                        self.unput(" ")
+                        self.file.seek(-len(e), 1)
+                    else:
+                        self.unputWord(c)
+                        self.unput(" ")
+                        self.file.seek(-len(d+e), 1)
                 elif c in ("'", "\""):
                     self.readString(c)
                 elif c=="/":
@@ -238,7 +307,14 @@
                         self.unput(c)
                         self.file.seek(-1, 1)
                 else:
-                    self.unput(c)
+                    if self.eat_spaces:
+                        if c in string.whitespace:
+                            if not self.last_is_space():
+                                self.unput(" ")
+                        else:
+                            self.unput(c)
+                    else:
+                        self.unput(c)
         self.processEOL()
         self.generateThesaurus()
 
@@ -258,6 +334,9 @@
 
         if self.sort_thesaurus:
             values = sortThesaurus(self.thesaurus)
+        elif self.random_thesaurus:
+            values = self.thesaurus.values()
+            random.shuffle(values)
         else:
             values = self.thesaurus.values()
         new_words = {}
@@ -274,7 +353,10 @@
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
     print "\t--mode=MODE       : Mode (words, moo, tachatte, letter or shit)"
+    print "\t--random          : Shuffle thesaurus (default: off)"
     print "\t--eat-comments    : Eat comments (default: off)"
+    print "\t--eat-spaces      : Eat white spaces (default: off)"
+    print "\t--syntax=ENABLE   : Encode syntax? (default: off)"
     print "\t--number=ENABLE   : Encode numbers? (default: on)"
     print "\t--string=ENABLE   : Encode numbers? (default: on)"
     print
@@ -295,8 +377,8 @@
     try:
         short = ""
         long = ["help", "version", \
-            "mode=", "eat-comments",
-            "number=", "string="]
+            "mode=", "eat-spaces", "eat-comments", "random",
+            "number=", "string=", "syntax="]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage()
@@ -311,10 +393,16 @@
             if a not in ("words", "tachatte", "moo", "shit", "letter"):
                 usage()
             tachatte.mode = a
+        elif o == "--eat-spaces":
+            tachatte.eat_spaces = True
         elif o == "--eat-comments":
             tachatte.eat_comments = True
         elif o == "--number":
             tachatte.encode_number = arg2bool(a)
+        elif o == "--syntax":
+            tachatte.encode_syntax = arg2bool(a)
+        elif o == "--random":
+            tachatte.random_thesaurus = True
         elif o == "--string":
             tachatte.encode_string = arg2bool(a)
 



From haypo at berlios.de  Sat Dec 10 15:42:52 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 10 Dec 2005 15:42:52 +0100
Subject: [Happyboom-svn] r308 - in haypo/hachoir: . plugins
Message-ID: <200512101442.jBAEgqbg031023@sheep.berlios.de>

Author: haypo
Date: 2005-12-10 15:42:52 +0100 (Sat, 10 Dec 2005)
New Revision: 308

Modified:
   haypo/hachoir/mime.py
   haypo/hachoir/plugins/3ds.py
Log:
Fix 3DS MIME (image/tiff => image/x-3ds)


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-06 21:18:33 UTC (rev 307)
+++ haypo/hachoir/mime.py	2005-12-10 14:42:52 UTC (rev 308)
@@ -65,6 +65,8 @@
     return getBufferMime(data, filename)
 
 def getAnotherBufferMime(buffer):    
+    if buffer[:2] == "\x4d\x4d" and buffer[6:12]=="\x02\0\x0A\0\0\0":
+        return "image/x-3ds"
     if 2<=len(buffer) and ord(buffer[0])==31 and ord(buffer[1])==139:
         return "application/x-gzip"
     if buffer[:4] == "%PDF":
@@ -110,7 +112,7 @@
         instance = GuessMime()
     mimes = instance.guess(buffer)
     mimes = splitMimes(mimes)
-    if (len(mimes) == 0 or mimes[0][0] == 'application/octet-stream') and filename != None:
+    if len(mimes) == 0 or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
         ext = os.path.splitext(filename)[1]
         new_mime = getAnotherBufferMime(buffer)
         if new_mime == None:

Modified: haypo/hachoir/plugins/3ds.py
===================================================================
--- haypo/hachoir/plugins/3ds.py	2005-12-06 21:18:33 UTC (rev 307)
+++ haypo/hachoir/plugins/3ds.py	2005-12-10 14:42:52 UTC (rev 308)
@@ -77,14 +77,14 @@
         self.read("size", "<L", "Chunk size")
         types = {
             0xA000: readMaterial,
-            0x4000: readObject,
+#            0x4000: readObject,
             0xA300: readTextureFilename,
             0x0011: readColor,
+            0x0002: readVersion,
 # TODO: Uncomment these functions, it's too slow yet            
 #            0x4110: readVertexList,
 #            0x4120: readPolygonList,
-#            0x4140: readMapList,
-            0x0002: readVersion
+#            0x4140: readMapList
         }
         size = self["size"] - 6
         type = self["type"] 
@@ -155,6 +155,4 @@
         while not stream.eof():
             self.readChild("chunk[]", Filter_3DS_Chunk)
 
-# TODO: What the is that!? => image/tiff
-# What's the right MIME type?
-registerPlugin(Filter_3DS_File, "image/tiff")
+registerPlugin(Filter_3DS_File, "image/x-3ds")



From haypo at berlios.de  Sat Dec 10 16:26:25 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 10 Dec 2005 16:26:25 +0100
Subject: [Happyboom-svn] r309 - in haypo/hachoir: . plugins
Message-ID: <200512101526.jBAFQPUt001251@sheep.berlios.de>

Author: haypo
Date: 2005-12-10 16:26:24 +0100 (Sat, 10 Dec 2005)
New Revision: 309

Modified:
   haypo/hachoir/config.py
   haypo/hachoir/plugins/3ds.py
Log:
Fix 3DS plugin


Modified: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-12-10 14:42:52 UTC (rev 308)
+++ haypo/hachoir/config.py	2005-12-10 15:26:24 UTC (rev 309)
@@ -1,3 +1,3 @@
-max_string_length = 30
+max_string_length = 14
 max_hexa_length = 4096 
 max_ascii_length = 4096 

Modified: haypo/hachoir/plugins/3ds.py
===================================================================
--- haypo/hachoir/plugins/3ds.py	2005-12-10 14:42:52 UTC (rev 308)
+++ haypo/hachoir/plugins/3ds.py	2005-12-10 15:26:24 UTC (rev 309)
@@ -9,17 +9,17 @@
 def readTextureFilename(filter, stream):
     filter.readString("filename", "C", "Texture filename")
 
-def readVersion(filter, stream):
+def readVersion(filter, stream, last_pos):
     filter.read("version", "<L", "Version")
 
-def readMaterial(filter, stream):
+def readMaterialName(filter, stream, last_pos):
     filter.readString("name", "C", "Material name")
-    while not stream.eof():
-        filter.readChild("chunk[]", Filter_3DS_Chunk)
+#    while not stream.eof():
+#        filter.readChild("chunk[]", Filter_3DS_Chunk)
 
-def readObject(filter, stream):
-    filter.readString("name", "C", "Object name")
-    while not stream.eof():
+def readObject(filter, stream, last_pos):
+    chunk = filter.readString("name", "C", "Object name")
+    while stream.tell() < last_pos:
         filter.readChild("chunk[]", Filter_3DS_Chunk)
 
 class Filter_3DS_MapUV(Filter):
@@ -43,49 +43,92 @@
         self.read("c", "<H", "Vertex C")
         self.read("flags", "<H", "Flags")
     
-def readMapList(filter, stream):
+def readMapList(filter, stream, last_pos):
     filter.read("count", "<H", "Map count")
-    while not stream.eof():
+    for i in range(0, filter["count"]):
         filter.readChild("map[]", Filter_3DS_MapUV)
 
-def readColor(filter, stream):
+def readColor(filter, stream, last_pos):
     filter.read("red", "B", "Red componant")
     filter.read("green", "B", "Green componant")
     filter.read("blue", "B", "Blue componant")
 
-def readVertexList(filter, stream):
+def readVertexList(filter, stream, last_pos):
     filter.read("count", "<H", "Vertex count")
-    while not stream.eof():
+    for i in range(0, filter["count"]):
         filter.readChild("vertex[]", Filter_3DS_Vertex)
     
-def readPolygonList(filter, stream):
+def readPolygonList(filter, stream, last_pos):
     filter.read("count", "<H", "Vertex count")
-    while not stream.eof():
+    for i in range(0, filter["count"]):
         filter.readChild("polygon[]", Filter_3DS_Polygon)
 
 class Filter_3DS_Chunk(Filter):
+    # List of chunk type name
+    type_name = {
+        0x0011: "Color",
+        0x4D4D: "Main chunk",
+        0x0002: "File version",
+        0x3D3D: "Materials and objects",
+        0x4000: "Object",
+        0x4100: "Mesh (triangular)",
+        0x4110: "Vertices list",
+        0x4120: "Polygon (faces) list",
+        0x4140: "Map UV list",
+        0x4130: "Object material",
+        0xAFFF: "New material",
+        0xA000: "Material name",
+        0xA010: "Material ambiant",
+        0xA020: "Material diffuse",
+        0xA030: "Texture specular",
+        0xA200: "Texture",
+        0xA300: "Texture filename",
+
+        # Key frames
+        0xB000: "Keyframes",
+        0xB002: "Object node tag",
+        0xB006: "Light target node tag",
+        0xB007: "Spot light node tag",
+        0xB00A: "Keyframes header",
+        0xB009: "Keyframe current time",
+        0xB030: "Node identifier",
+        0xB010: "Node header",
+        0x7001: "Viewport layout"
+    }
+
+    chunk_id_by_type = {
+        0x4d4d: "main",
+        0x0002: "version",
+        0x3d3d: "obj_mat",
+        0xb000: "keyframes",
+        0xafff: "material",
+        0x4000: "object"
+    }
+
     # List of chunks which contains other chunks
     sub_chunks = \
         (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
          0xB002, 0xB006, 0xB007,
          0xA010, 0xA030, 0xA020, 0xB000)
+
+    # List of chunk type handlers
+    handlers = {
+        0xA000: readMaterialName,
+        0x4000: readObject,
+        0xA300: readTextureFilename,
+        0x0011: readColor,
+        0x0002: readVersion,
+# TODO: Uncomment these functions, it's too slow yet            
+#         0x4110: readVertexList,
+#         0x4120: readPolygonList,
+#         0x4140: readMapList
+    }
     
     def __init__(self, stream, parent):
         Filter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
         chunk = self.read("type", "<H", "Chunk type", post=self.toHex)
         chunk.description = "Chunk type (%s)" % self.getType()
         self.read("size", "<L", "Chunk size")
-        types = {
-            0xA000: readMaterial,
-#            0x4000: readObject,
-            0xA300: readTextureFilename,
-            0x0011: readColor,
-            0x0002: readVersion,
-# TODO: Uncomment these functions, it's too slow yet            
-#            0x4110: readVertexList,
-#            0x4120: readPolygonList,
-#            0x4140: readMapList
-        }
         size = self["size"] - 6
         type = self["type"] 
         end = stream.tell() + size
@@ -94,9 +137,10 @@
                 self.readChild("chunk[]", Filter_3DS_Chunk)
             assert stream.tell() == end 
         else:
-            if type in types: 
-                substream = stream.createSub(size=size)
-                types[type] (self, substream)
+            if type in Filter_3DS_Chunk.handlers: 
+                end = stream.tell() + size
+                Filter_3DS_Chunk.handlers[type] (self, stream, end)
+                assert stream.tell() == end
             else:
                 self.read("data", "%us" % size, "Raw data")
 
@@ -107,48 +151,21 @@
         type = self.getType()
         chunk.description = "Chunk of type \"%s\"" % type
         self.setDescription("Chunk type (%s)" % type)
-        self.setId("chunk_%04x" % self["type"])
+        if self["type"] in Filter_3DS_Chunk.chunk_id_by_type:
+            id = Filter_3DS_Chunk.chunk_id_by_type[self["type"]]
+#            chunk.id = id
+            self.setId(id) 
+        else:
+            self.setId("chunk_%04x" % self["type"])
 
+
     def toHex(self, chunk):
         return "%04X" % chunk.value
         
     def getType(self):
         type = self["type"]
-        know = {
-            0x0011: "Color",
-            0x4D4D: "Main chunk",
-            0x0002: "File version",
-            0x3D3D: "Materials and objects",
-            0x4000: "Object",
-            0x4100: "Mesh (triangular)",
-            0x4110: "Vertices list",
-            0x4120: "Polygon (faces) list",
-            0x4140: "Map UV list",
-            0x4130: "Object material",
-            0xAFFF: "New material",
-            0xA000: "New material (name)",
-            0xA010: "Material ambiant",
-            0xA020: "Material diffuse",
-            0xA030: "Texture specular",
-            0xA200: "Texture",
-            0xA300: "Texture filename",
+        return Filter_3DS_Chunk.type_name.get(type, "%04X" % type)
 
-            # Key frames
-            0xB000: "Keyframes",
-            0xB002: "Object node tag",
-            0xB006: "Light target node tag",
-            0xB007: "Spot light node tag",
-            0xB00A: "Keyframes header",
-            0xB009: "Keyframe current time",
-            0xB030: "Node identifier",
-            0xB010: "Node header",
-            0x7001: "Viewport layout"
-        }
-        if type in know:
-            return know[type]
-        else:
-            return "%04X" % type 
-
 class Filter_3DS_File(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "3ds_file", "3DS file", stream, parent)



From haypo at berlios.de  Sun Dec 11 07:15:49 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 07:15:49 +0100
Subject: [Happyboom-svn] r310 - in haypo/hachoir: . plugins stream
Message-ID: <200512110615.jBB6Fncs030322@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 07:15:28 +0100 (Sun, 11 Dec 2005)
New Revision: 310

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/default.py
   haypo/hachoir/filter.py
   haypo/hachoir/format.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/3ds.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/jpeg.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/stream/file.py
Log:
Speed improvment:
- Extract regex to compile them only once
- Add filter size cache (only compute size once)
- FormatChunk.getRealFormat only call regex if "{" is present
- Add chunk counter to speed up Filter.getUniqChunkId

Filters don't use truncate/can_truncate parameter (not needed anymore).

Add load_ui attribute to hachoir class, so it's possible to no load UI
(with --no-ui command line argument).

Write file cache.

Write (buggy?) chunk clone methods.



Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/chunk.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -15,6 +15,9 @@
         self.post_process = None
         self.display = None
 
+    def clone(self):
+        raise Exception("%s doesn't implement clone() method!" % self)
+
     def postProcess(self):        
         if self.post_process != None:
             self.display = self.post_process(self)
@@ -65,14 +68,14 @@
     def _setAddr(self, addr): self._addr = addr
     def _getAddr(self): return self._addr
     def _getSize(self): return self._size
-    def __getId(self): return self.__id
-    def __setId(self, id):
+    def _getId(self): return self.__id
+    def _setId(self, id):
         if self.__id == id: return
         self._parent.updateChunkId(self, id)
         self.__id = id
     addr = property(_getAddr, _setAddr)        
     size = property(_getSize)        
-    id = property(__getId, __setId)
+    id = property(_getId, _setId)
     value = property(getValue)
     raw = property(getRaw)
     
@@ -86,6 +89,12 @@
             filter.getDescription(), filter.getStream(), filter.getAddr(), \
             filter.getSize(), parent)
     
+    def clone(self, addr=None):
+        filter_copy = self._filter.clone(addr=addr)
+        # TODO: Is it always alright? (or use parent_addr = self.parent_addr)
+        parent_addr = addr
+        return FilterChunk(self.id, filter_copy, self.getParent(), parent_addr)
+    
     def getFormat(self):
         return self._filter.getId()
 
@@ -118,6 +127,11 @@
     def getFilter(self):
         return self._filter
 
+    def _setId(self, id):
+        Chunk._setId(self, id)
+        self._filter.setId(id)
+    id = property(Chunk._getId, _setId)
+
     def _getDescription(self):
         return self._description
     def _setDescription(self, description):
@@ -126,7 +140,7 @@
     description = property(_getDescription, _setDescription)
 
 class StringChunk(Chunk):
-    cache_hit = 0
+    regex_eol_nr = re.compile("[\n\r]")
 
     def __init__(self, id, description, stream, str_type, parent):
         assert str_type in ("C", "UnixLine", "WindowsLine", "MacLine", "AutoLine")
@@ -152,7 +166,7 @@
     def _findSize(self):
         self._stream.seek(self.addr)
         if self._str_type == "AutoLine":
-            self._size = self._stream.searchLength(re.compile("[\n\r]"), True)
+            self._size = self._stream.searchLength(StringChunk.regex_eol_nr, True)
             assert self._size != -1
             self._stream.seek(self.addr + self._size-1)
             self.eol = self._stream.getN(1)
@@ -177,7 +191,6 @@
         
     def _read(self, max_size):
         if self._cache_addr==self.addr and self._cache_max_size==max_size:
-            StringChunk.cache_hit = StringChunk.cache_hit + 1
             return self._cache_value
         self._cache_addr = self.addr
         self._cache_max_size = max_size
@@ -212,6 +225,7 @@
         self._value = {}
         self._addr = None
         self._format = None
+        self._orig_format = None
         self._size = None
         self._chunk = chunk
         
@@ -237,11 +251,11 @@
                 return data, True
 
     def update(self):
-        real_format = self._chunk.getRealFormat(self._chunk.getFormat())
-        if self._addr != self._chunk.addr or self._format != real_format:
+        if self._addr != self._chunk.addr or self._orig_format != self._chunk.getFormat():
             # Invalidate the cache
             self._value = {}
-            self._format = real_format
+            self._orig_format = self._chunk.getFormat()
+            self._format = self._chunk.getRealFormat(self._orig_format)
             self._addr = self._chunk.addr
             self._size = struct.calcsize(self._format)
 
@@ -265,12 +279,19 @@
         return self._value[max_size]
 
 class FormatChunk(Chunk):
+    regex_sub_format = re.compile(r'\{([^}]+)\}')
+
     def __init__(self, id, description, stream, addr, format, parent):
         Chunk.__init__(self, id, description, stream, addr, 0, parent)
         if not checkFormat(format):
             raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
         self.__format = format
         self._cache = FormatChunkCache(self)
+        
+    def clone(self, addr=None):
+        if addr == None:
+            addr = self._addr
+        return FormatChunk(self.id, self.description, self._stream, addr, self.__format, self._parent)
 
     def getFormat(self):
         return self.__format
@@ -280,7 +301,10 @@
     size = property(_getSize)        
 
     def getRealFormat(self, format):
-        return re.sub(r'\{([^}]+)\}', self.__replaceFieldFormat, format)
+        if "{" in format:
+            return FormatChunk.regex_sub_format.sub(self.__replaceFieldFormat, format)
+        else:
+            return format
 
     def isString(self):
         return self.__format[-1] == "s"

Modified: haypo/hachoir/default.py
===================================================================
--- haypo/hachoir/default.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/default.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -7,4 +7,4 @@
 class DefaultFilter(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "default", "Default filter", stream, parent)
-        self.read("data", "!{@end@}s", "Data", truncate=True)
+        self.read("data", "!{@end@}s", "Data")

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/filter.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -11,6 +11,9 @@
 from tools import getBacktrace
 
 class Filter:
+    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
+    regex_array_chunk = re.compile(r"^([^[]+)\[\]$")
+
     def __init__(self, id, description, stream, parent):
         self._id = id
         self._description = description
@@ -24,14 +27,18 @@
         self._chunks = []
         self._chunks_dict = {}
         self._addr = self._stream.tell()
+        self._cache_valid = False
+        self._cache_size = None
 
     def __getitem__(self, chunk_id):
         return self.getChunk(chunk_id).getValue()
 
-    def clone(self):
+    def clone(self, addr=None):
         if self.__class__ == Filter:
             return None
-        self.getStream().seek(self.getAddr())
+        if addr == None:
+            addr = self.getAddr()
+        self.getStream().seek(addr)
         try:
             new = self.__class__(self.getStream(), self.getParent())
         except:
@@ -46,6 +53,7 @@
     def setDescription(self, description): self._description = description
 
     def _deleteChunk(self, pos):
+        self._cache_valid = False
         chunk = self._chunks[pos]
         if chunk.id in self._chunks_dict:
             del self._chunks_dict[chunk.id]
@@ -69,18 +77,21 @@
         return self._chunks
 
     def _getUniqChunkId(self, pattern, root, index):
-        new_id = pattern % (root, index)
-        while new_id in self._chunks_dict:
-            index = index + 1
-            new_id = pattern % (root, index)
-        return new_id 
+        if not hasattr(self, "_chunk_counter"):
+            self._chunk_counter = {}
+        
+        if root in self._chunk_counter:
+            self._chunk_counter[root] = self._chunk_counter[root]+1
+        else:
+            self._chunk_counter[root] = 0
+        return pattern % (root, self._chunk_counter[root])
 
     def getUniqChunkId(self, id):
         if id[-2:] == "[]":
             return self._getUniqChunkId("%s[%u]", id[:-2], 0)
 
         if id in self._chunks_dict:
-            m = re.compile("^(.*?)([0-9]+)$").match(id)
+            m = Filter.regex_chunk_uniq_id.match(id)
             if m != None:
                 return self._getUniqChunkId("%s%u", m.group(1), int(m.group(2))+1)
             else:
@@ -108,7 +119,7 @@
             addr = self.getAddr()
             chunk_pos = len(self._chunks)
         chunk = FormatChunk(id, description, self.getStream(), addr, "!%ss" % size, self)
-        self._appendChunk(chunk, can_truncate=True, position=chunk_pos)
+        self.appendChunk(chunk, position=chunk_pos)
 
     def rescan(self, from_chunk, diff_size, new_id=None, new_description=None, truncate=False):
         if from_chunk != None:
@@ -158,6 +169,7 @@
             self.addRawChunk(prev_chunk, id, size, description)
 
     def _rescanUpdateChunks(self, start, prev_chunk):
+        self._cache_valid = False
         pos = start
         try:
             for chunk in self._chunks[start:]:
@@ -179,6 +191,7 @@
 
     def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate=False):
         assert 0<=start and start <= len(self._chunks)
+        self._cache_valid = False
         if 0<start:
             prev_chunk = self._chunks[start-1]
         else:
@@ -209,10 +222,13 @@
         return last_chunk.addr + last_chunk.size
 
     def getSize(self):
-        size = 0
-        for chunk in self._chunks:
-            size = size + chunk.size
-        return size
+        if not self._cache_valid:
+            self._cache_valid = True
+            size = 0
+            for chunk in self._chunks:
+                size = size + chunk.size
+            self._cache_size = size
+        return self._cache_size
 
     def addString(self, str_type, before_chunk):
         if before_chunk != None:
@@ -225,7 +241,7 @@
         stream.seek(addr)
         id = self.getUniqChunkId("str")
         str_chunk = StringChunk(id, "String", stream, str_type, self)
-        self._appendChunk(str_chunk, can_truncate=True, position=pos)
+        self.appendChunk(str_chunk, position=pos)
         str_chunk.postProcess()
         before_chunk.addr = before_chunk.addr + str_chunk.size
         before_chunk.convertToStringSize(before_chunk.size - str_chunk.size)
@@ -296,31 +312,17 @@
 
     def updateFormatChunk(self, chunk):
         if chunk.id == None: return
+        self._cache_valid = False
         data = chunk.getValue(config.max_string_length)
         setattr(self, chunk.id, data)       
 
-    def _appendChunk(self, chunk, can_truncate=False, position=None):
+    def appendChunk(self, chunk, position=None):
+        self._cache_valid = False
         if position != None:
             self._chunks.insert(position, chunk)
         else:
             self._chunks.append(chunk)
-        id = chunk.id
-        assert id != None
-        m = re.compile(r"^([^[]+)\[\]$").match(id)
-        if m != None:
-            id = m.group(1)
-            if hasattr(self, id):
-                array = getattr(self, id)
-            else:
-                array = []
-                setattr(self, id, array)
-            assert type(array) == types.ListType
-            chunk.id = "%s[%u]" % (id, len(array))
-            array.append(chunk)
-            if id not in self._chunks_dict:
-                self._chunks_dict[id] = array 
-        else:
-            self._chunks_dict[id] = chunk
+        self._chunks_dict[chunk.id] = chunk
 
     def readLimitedChild(self, id, size, filter_class, *args):
         start = self._stream.tell()
@@ -344,9 +346,8 @@
     
     def addFilter(self, id, filter, addr): 
         chunk = FilterChunk(id, filter, self, addr)
-        self._appendChunk(chunk)
+        self.appendChunk(chunk)
         filter.updateParent(chunk)
-#        self._stream.seek(chunk.addr + chunk.size)
         return chunk
 
     def readArray(self, id, entry_class, description, end_func): 
@@ -362,16 +363,16 @@
     def readString(self, id, format, description, post=None):
         """ Returns chunk """
         chunk = StringChunk(id, description, self._stream, format, self)
-        self._appendChunk(chunk)
+        self.appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)
         chunk.post_process = post
         chunk.postProcess()
         return chunk
     
-    def read(self, id, format, description, post=None, truncate=False):
+    def read(self, id, format, description, post=None):
         """ Returns chunk """
         chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
-        self._appendChunk(chunk, can_truncate=truncate)
+        self.appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)
         chunk.post_process = post
         chunk.postProcess()
@@ -411,7 +412,7 @@
         stream.seek(chunk.addr)
         filter = Filter(chunk.id, chunk.description, stream, self)
         chunk.setParent(filter)
-        filter._appendChunk(chunk, can_truncate=True)
+        filter.appendChunk(chunk)
         
         # Create new chunk and add it into self 
         new_chunk = FilterChunk(chunk.id, filter, self, chunk.addr)
@@ -446,7 +447,7 @@
             nb = nb + 1
             chunk = FilterChunk(chunk_id, filter, self, addr)
             self._array.append( chunk )
-            self._appendChunk(chunk)
+            self.appendChunk(chunk)
             last_filter = filter
 
         for chunk in self._array:
@@ -465,6 +466,7 @@
             del self._array[pos]
 
     def update(self):
+        self._cache_valid = False
         prev_chunk = None
         pos = 0
         try:
@@ -492,8 +494,10 @@
     def __getitem__(self, index):
         return self._array[index]
 
-    def clone(self):
-        self.getStream().seek(self.getAddr())
+    def clone(self, addr=None):
+        if addr == None:
+            addr = self.getAddr()
+        self.getStream().seek(addr)
         new = ArrayFilter( self.getId(), self.getDescription(), \
             self.getStream(), self.getParent(), self._entry_class, self._end_func)
         new.filter_chunk = self.filter_chunk

Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/format.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -1,11 +1,14 @@
 import re
 
+_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLscfd]$")
+_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLscfd])$")
+
 def checkFormat(format):
-    m = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLscfd]$").match(format)
+    m = _regex_format1.match(format)
     return m != None
 
 def splitFormat(format):
-    m = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLscfd])$").match(format)
+    m = _regex_format2.match(format)
     if m == None: return None
     endian = m.group(1)
     if endian=="": endian="!"

Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/hachoir.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -21,6 +21,7 @@
     print ""
     print "Options:"
     print "\t--script file.py  : Load python script"
+    print "\t--no-ui           : Don't load user interface"
     print "\t--version         : Show the program version"
     print "\t--verbose         : Activate verbose mode"
     print "\t--help            : Show this help"
@@ -31,7 +32,7 @@
     
     try:
         short = ""
-        long = ["verbose", "help", "version", "script="]
+        long = ["verbose", "help", "version", "script=", "no-ui"]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage(def_val)
@@ -52,6 +53,8 @@
         if o == "--version":
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit()
+        if o == "--no-ui":
+            val["load_ui"] = False
         if o == "--script":
             val["script"] = a
         if o == "--verbose":
@@ -78,17 +81,19 @@
 
         opt = {
             "verbose": False,
-            "script": None
+            "script": None,
+            "load_ui": True            
         }
         opt, filename = parseArgs(opt)
-
+        global hachoir 
         hachoir = Hachoir()
         for key in opt:
             setattr(hachoir, key, opt[key])
-        try:
-            ui.loadInterface(hachoir)
-        except ImportError, err:
-            error("""Error: a Python module is missing:
+        if hachoir.load_ui:
+            try:
+                ui.loadInterface(hachoir)
+            except ImportError, err:
+                error("""Error: a Python module is missing:
 %s
 
 You can find PyGTK at: http://www.pygtk.org/
@@ -97,9 +102,16 @@
 Gentoo: emerge pytgtk
 Debian: apt-get install python2.4-gtk python2.4-magic
 Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
-            sys.exit(1)
-        hachoir.run(filename)
+                sys.exit(1)
+        if True:
+            import profile, pstats
+            profile.run('global hachoir; hachoir.run("%s")' % filename, 'hachoir.loadStream')
+            #pstats.Stats('hachoir.loadStream').sort_stats('time').print_stats()
+            pstats.Stats('hachoir.loadStream').sort_stats('cumulative').print_stats()
+        else:
+            hachoir.run(filename)
 
+
     except SystemExit:
         pass
     except Exception, err:

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/hachoir_class.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -19,6 +19,7 @@
         self._main_filter = None
         self._filter = None
         self.script = None
+        self.load_ui = True
 
     def getFilter(self):
         return self._filter
@@ -28,11 +29,14 @@
         self._filter = filter
         if filter != None:
             self._addPadding()
-            self._filter.display()
-            self.ui.window.info.updateFilter(filter)
+            if self.load_ui:
+                self._filter.display()
+                self.ui.window.info.updateFilter(filter)
         else:
-            self.ui.window.clear_table()
-        self.ui.window.updateToolbar()
+            if self.load_ui:
+                self.ui.window.clear_table()
+        if self.load_ui:
+            self.ui.window.updateToolbar()
 
     def onGoParent(self):
         if self._filter.getParent() == None: return
@@ -69,7 +73,8 @@
             chunk.setFilter(self._filter)
             diff_size = self._filter.getSize() - old_size
             chunk.getParent().rescan(chunk, diff_size)
-        self._filter.display()
+        if self.load_ui:
+            self._filter.display()
         self.ui.window.updateToolbar()
     
     def saveUser(self, filename):
@@ -136,4 +141,5 @@
             self.loadScript(self.script)
         elif filename != None:
             self.loadFile(filename)
-        self.ui.run()      
+        if self.load_ui:
+            self.ui.run()      

Modified: haypo/hachoir/plugins/3ds.py
===================================================================

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/plugins/gzip.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -68,7 +68,7 @@
         except Exception, msg:
             error("Error while processing file in gzip: %s\ns%s" % (msg, getBacktrace()))
             stream.seek(oldpos)
-            self.read("data", "!%us" % size, "Compressed data", truncate=True)
+            self.read("data", "!%us" % size, "Compressed data")
         
         self.read("crc32", "<L", "CRC32")
         self.read("size", "<L", "Uncompressed size")

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/plugins/jpeg.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -26,7 +26,7 @@
         self.read("thumb_h", "B", "Thumbnail height")
         thumb = self["thumb_w"] * self["thumb_h"]
         if thumb != 0:
-            self.read("thumb_data", "%us" % size, "Thumbnail data", truncate=True)
+            self.read("thumb_data", "%us" % size, "Thumbnail data")
 
 class JpegChunk(Filter):
     def __init__(self, stream, parent):

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/plugins/tar.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -79,7 +79,7 @@
 
     def __init__(self, stream, parent):
         Filter.__init__(self, "tar_file_entry","Tar file entry", stream, parent)
-        self.read("name", "!100s", "Name", truncate=False, post=self.stripNul)
+        self.read("name", "!100s", "Name", post=self.stripNul)
         self.name = self["name"].strip("\0")
         self.read("mode", "!8s", "Mode", post=self.convertOctal)
         self.read("uid", "!8s", "User ID", post=self.convertOctal)
@@ -89,7 +89,7 @@
         self.read("mtime", "!12s", "Modification time", self.getTime)
         self.read("check_sum", "!8s", "Check sum")
         self.read("type", "!c", "Type")
-        self.read("lname", "!100s", "Link name", post=self.stripNul, truncate=False)
+        self.read("lname", "!100s", "Link name", post=self.stripNul)
         self.read("magic", "!8s", "Magic", post=self.stripNul)
         self.read("uname", "!32s", "User name", post=self.stripNul)
         self.read("gname", "!32s", "Group name", post=self.stripNul)
@@ -109,11 +109,11 @@
                 stream.seek(oldpos)
                 chunk = self.readChild("filedata", EmptyFilter)
                 filter = chunk.getFilter()
-                filter.read("filedata", "!%us" % self.size, "File data", truncate=True)
+                filter.read("filedata", "!%us" % self.size, "File data")
 
         if stream.tell() % 512 != 0:
             padding = 512 - stream.tell() % 512
-            self.read("padding", "!%ss" % padding, "Padding (512 align)", truncate=True)
+            self.read("padding", "!%ss" % padding, "Padding (512 align)")
 
     def isEmpty(self):
         return self.name == ""

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/plugins/zip.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -73,7 +73,7 @@
         self.read("extra_length", "<H", "Extra length")
         self.read("filename", "<{filename_length}s", "Filename")
         self.read("extra", "<{extra_length}s", "Extra")
-        self.read("compressed_data", "<{compressed_size}s", "Compressed data", truncate=True)
+        self.read("compressed_data", "<{compressed_size}s", "Compressed data")
         if (self["flags"] & 4) == 4:
             self.read("file_crc32", "<L", "Checksum (CRC32)")
             self.read("file_compressed_size", "<L", "Compressed size (bytes)")

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-12-10 15:26:24 UTC (rev 309)
+++ haypo/hachoir/stream/file.py	2005-12-11 06:15:28 UTC (rev 310)
@@ -2,6 +2,50 @@
 from stream import Stream
 import os
 
+class FileCacheEntry:
+    def __init__(self, index, data):
+        self.index = index
+        self.data = data
+
+class FileCache:
+    def __init__(self, file, file_size):
+        self.file = file
+        self.file_size = file_size
+        self.block_size = 4096
+        self.max_block = 100
+        self.blocks = {}
+
+    def read(self, position, length):
+        block_position = position % self.block_size
+        block_index = position / self.block_size
+        length_copy = length
+        assert position+length <= self.file_size
+        
+        # TODO: Be able to read two or more blocks
+        data = ""
+        while 0 < length:
+            if block_index not in self.blocks:
+                if self.max_block <= len(self.blocks):
+                    # TODO: Remove oldest block
+                    pass
+                self.file.seek(block_index * self.block_size)
+                block_data = self.file.read(self.block_size)
+                assert (len(block_data) == self.block_size) or self.file.tell() == self.file_size
+                self.blocks[block_index] = block_data
+            else:
+                block_data = self.blocks[block_index]
+            if block_position != 0 or length != self.block_size:
+                end = block_position+length
+                if self.block_size < end:
+                    end = self.block_size
+                block_data = block_data[block_position:end]
+            data = data + block_data
+            block_position = 0
+            block_index = block_index + 1
+            length = length - len(block_data)
+        assert len(data) == length_copy
+        return data
+
 class FileStream(Stream):
     def __init__(self, file, filename=None, copy=None):
         """
@@ -14,6 +58,7 @@
             self._size = copy._size
             self._seed = copy._seed
             self._end = copy._end
+            self._cache = copy._cache
         else:
             self._file.seek(0,2) # Seek to end
             self._size = self._file.tell()
@@ -23,23 +68,21 @@
                 self._end = self._size-1
             else:
                 self._end = 0
+            self._cache = FileCache(self._file, self._size)
 
     def getType(self):
         return "%s (%s)" % \
             (self.__class__.__name__, self.filename)
         
     def read(self, size, seek=True):
-        self._file.seek(self._seed)
-        data = self._file.read(size)
+        data = self._cache.read(self._seed, size)
+#        self._file.seek(self._seed) ; data = self._file.read(size)
         if seek:
             self._seed = self._seed + len(data)
-            assert self._seed == self._file.tell()
+#            assert self._seed == self._file.tell()
         return data            
 
     def clone(self):
-        #?TODO: Don't copy low-level file IO,
-        # but only copy seed :-)
-        # => use internal?seed + cache
         return FileStream(self._file, self.filename, copy=self)
 
     def seek(self, pos, where=0):
@@ -58,13 +101,13 @@
         return self._seed
 
     def getN(self, size, seek=True):
-        self._file.seek(self._seed)
-        data = self._file.read(size)
-        if len(data) != size:
-            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
+        data = self._cache.read(self._seed, size)
+#        self._file.seek(self._seed) ; data = self._file.read(size)
+#        if len(data) != size:
+#            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
         if seek:
             self._seed = self._seed + size
-            assert self._seed == self._file.tell()
+#            assert self._seed == self._file.tell()
         return data
 
     def getSize(self):



From haypo at berlios.de  Sun Dec 11 07:25:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 07:25:22 +0100
Subject: [Happyboom-svn] r311 - haypo/hachoir
Message-ID: <200512110625.jBB6PMIJ000537@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 07:24:40 +0100 (Sun, 11 Dec 2005)
New Revision: 311

Modified:
   haypo/hachoir/hachoir.py
Log:
Disable profiler by default.


Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-12-11 06:15:28 UTC (rev 310)
+++ haypo/hachoir/hachoir.py	2005-12-11 06:24:40 UTC (rev 311)
@@ -103,7 +103,7 @@
 Debian: apt-get install python2.4-gtk python2.4-magic
 Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
                 sys.exit(1)
-        if True:
+        if False:
             import profile, pstats
             profile.run('global hachoir; hachoir.run("%s")' % filename, 'hachoir.loadStream')
             #pstats.Stats('hachoir.loadStream').sort_stats('time').print_stats()



From haypo at berlios.de  Sun Dec 11 08:08:03 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 08:08:03 +0100
Subject: [Happyboom-svn] r312 - in haypo/hachoir: . plugins stream
Message-ID: <200512110708.jBB7835k017136@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 08:07:44 +0100 (Sun, 11 Dec 2005)
New Revision: 312

Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/exif.py
   haypo/hachoir/stream/stream.py
Log:
Exif filter can read JPEG.


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-11 06:24:40 UTC (rev 311)
+++ haypo/hachoir/filter.py	2005-12-11 07:07:44 UTC (rev 312)
@@ -371,6 +371,7 @@
     
     def read(self, id, format, description, post=None):
         """ Returns chunk """
+        id = self.getUniqChunkId(id)
         chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
         self.appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)

Modified: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-12-11 06:24:40 UTC (rev 311)
+++ haypo/hachoir/plugins/exif.py	2005-12-11 07:07:44 UTC (rev 312)
@@ -174,7 +174,7 @@
         entries = []
         while True:
             next = stream.getFormat("!L", False)[0]
-            if next == 0:
+            if next in (0, 0xF0000000):
                 break
             chunk = self.readChild("entry[]", ExifEntry, endian)
             entry = chunk.getFilter()
@@ -184,7 +184,7 @@
                 entries.append(entry)
         self.read("next", endian+"L", "Next IFD offset")
 #        self.read("x", "12s", "")
-        entries.sort( sortExifEntry )                
+        entries.sort( sortExifEntry )
         for entry in entries:
             offset = entry["offset"]+offset_diff
             padding = offset - stream.tell()
@@ -240,8 +240,16 @@
             self.read("whatsthis?", endian+"H", "What's this ??")
             while True:
                 tag = stream.getN(2, False)
+                if tag == "\xFF\xD8":
+                    size = stream.getSize() - stream.tell()
+                    sub = stream.createLimited(size=size)
+                    from jpeg import JpegFile
+                    self.readStreamChild("thumbnail", sub, JpegFile)
+                    break
                 if tag == "\xFF\xFF":
                     break
                 self.readChild("ifd[]", ExifIFD, endian, 6)
         size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "End")
+        if size != 0:                
+            self.read("end", "%us" % size, "End")
+        assert self.getSize() == stream.getSize()

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-12-11 06:24:40 UTC (rev 311)
+++ haypo/hachoir/stream/stream.py	2005-12-11 07:07:44 UTC (rev 312)
@@ -47,7 +47,11 @@
             size = self.getSize()-start
         return SubStream(self, start, size, self.filename)
 
-    def createLimited(self, start, size):
+    def createLimited(self, start=None, size=None):
+        if start==None:
+            start = self.tell()
+        if size == None:
+            size = self.getSize()-start
         return LimitedStream(self, start, size, self.filename)
 
     def getFormat(self, format, seek=True):



From haypo at berlios.de  Sun Dec 11 08:28:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 08:28:22 +0100
Subject: [Happyboom-svn] r313 - haypo/hachoir/plugins
Message-ID: <200512110728.jBB7SM9Y024696@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 08:28:16 +0100 (Sun, 11 Dec 2005)
New Revision: 313

Modified:
   haypo/hachoir/plugins/exif.py
Log:
Fixes in Exif filter (read padding if needed).


Modified: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-12-11 07:07:44 UTC (rev 312)
+++ haypo/hachoir/plugins/exif.py	2005-12-11 07:28:16 UTC (rev 313)
@@ -154,7 +154,7 @@
         parent.description = "Exif entry (%s)" % self.getTag() 
 
     def getTag(self):
-        return ExifEntry.tag_name.get(self["tag"], "Unknown tag (0x%03X)" % self["tag"])
+        return ExifEntry.tag_name.get(self["tag"], "Unknown tag (0x%04X)" % self["tag"])
 
     def processType(self, chunk):
         return ExifEntry.type_name.get(chunk.value, "%u" % chunk.value) 
@@ -172,18 +172,19 @@
         self.endian = endian
         self.read("id", endian+"H", "IFD identifier")
         entries = []
+        next_chunk_offset = None
         while True:
             next = stream.getFormat("!L", False)[0]
             if next in (0, 0xF0000000):
                 break
             chunk = self.readChild("entry[]", ExifEntry, endian)
             entry = chunk.getFilter()
-            if entry["tag"] == 0x8769:
+            if entry["tag"] in (0x8769, 0x0201):
+                next_chunk_offset = entry["value"]+offset_diff
                 break
             if 4 < entry.size:
                 entries.append(entry)
         self.read("next", endian+"L", "Next IFD offset")
-#        self.read("x", "12s", "")
         entries.sort( sortExifEntry )
         for entry in entries:
             offset = entry["offset"]+offset_diff
@@ -192,6 +193,10 @@
                 self.read("padding[]", "%us" % padding, "Padding (?)")
             assert offset == stream.tell()
             self.read("entry_value[]", entry.format, "Value of %s" % entry.getId())
+        if next_chunk_offset != None:
+            padding = next_chunk_offset - stream.tell()
+            if 0 < padding:
+                self.read("padding[]", "%us" % padding, "Padding (?)")
 
     def updateParent(self, chunk):
         desc = "Exif IFD (id %s)" % self["id"]
@@ -213,42 +218,19 @@
            endian = ">"
         self.read("header2", endian+"H", "Header2 (42)")
 
-        if False:
-            # Part #0
-            self.read("nb_entry", endian+"H", "Number of entries")
-            self.read("offset", endian+"L", "Offset")
-            nb_entry = self["nb_entry"]+1
-            entries = []
-            for i in range(0,nb_entry):
-                chunk = self.readChild("entry[]", ExifEntry, endian)
-                entry = chunk.getFilter()
-                if entry["tag"] != 0x8769:
-                    entries.append(entry)
-
-            # TODO: What's this?
-            self.read("next", endian+"L", "Next IFD offset")
-
-            # Read data of part #0
-            for entry in entries:
-                if 4 < entry.size:
-                    self.read("entry_value[]", entry.format, "Value of %s" % entry.getId())
-
-            # Read IFD
-            self.readChild("ifd", ExifIFD, endian)
-        else:
-            self.read("nb_entry", endian+"H", "Number of entries")
-            self.read("whatsthis?", endian+"H", "What's this ??")
-            while True:
-                tag = stream.getN(2, False)
-                if tag == "\xFF\xD8":
-                    size = stream.getSize() - stream.tell()
-                    sub = stream.createLimited(size=size)
-                    from jpeg import JpegFile
-                    self.readStreamChild("thumbnail", sub, JpegFile)
-                    break
-                if tag == "\xFF\xFF":
-                    break
-                self.readChild("ifd[]", ExifIFD, endian, 6)
+        self.read("nb_entry", endian+"H", "Number of entries")
+        self.read("whatsthis?", endian+"H", "What's this ??")
+        while True:
+            tag = stream.getN(2, False)
+            if tag == "\xFF\xD8":
+                size = stream.getSize() - stream.tell()
+                sub = stream.createLimited(size=size)
+                from jpeg import JpegFile
+                self.readStreamChild("thumbnail", sub, JpegFile)
+                break
+            if tag == "\xFF\xFF":
+                break
+            self.readChild("ifd[]", ExifIFD, endian, 6)
         size = stream.getSize() - stream.tell()
         if size != 0:                
             self.read("end", "%us" % size, "End")



From haypo at berlios.de  Sun Dec 11 08:49:02 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 08:49:02 +0100
Subject: [Happyboom-svn] r314 - haypo/hachoir
Message-ID: <200512110749.jBB7n26x001951@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 08:48:58 +0100 (Sun, 11 Dec 2005)
New Revision: 314

Added:
   haypo/hachoir/COPYING
   haypo/hachoir/ChangeLog
   haypo/hachoir/INSTALL
Removed:
   haypo/hachoir/broken_plugins/
Modified:
   haypo/hachoir/program.py
Log:
Commit version 2005-12-11.


Added: haypo/hachoir/COPYING
===================================================================
--- haypo/hachoir/COPYING	2005-12-11 07:28:16 UTC (rev 313)
+++ haypo/hachoir/COPYING	2005-12-11 07:48:58 UTC (rev 314)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: haypo/hachoir/ChangeLog
===================================================================
--- haypo/hachoir/ChangeLog	2005-12-11 07:28:16 UTC (rev 313)
+++ haypo/hachoir/ChangeLog	2005-12-11 07:48:58 UTC (rev 314)
@@ -0,0 +1,2 @@
+2005-10-20
+	- Creation of the project

Added: haypo/hachoir/INSTALL
===================================================================
--- haypo/hachoir/INSTALL	2005-12-11 07:28:16 UTC (rev 313)
+++ haypo/hachoir/INSTALL	2005-12-11 07:48:58 UTC (rev 314)
@@ -0,0 +1,12 @@
+To use Hachoir, you will need:
+- Python 2.2 (maybe 2.3 ?) 
+  http://www.python.org/
+- pyGTK 2.0 with Glade support
+  http://www.pygtk.org/
+- Python module "magic" (*)
+  (part of libmagic)
+- Python XML DOM extension ("xml.dom.ext")
+
+(*) If you don't have python module magic, download:
+      http://www.haypocalc.com/perso/prog/hachoir/magic.so.bz2
+    Decompress it and move it to Hachoir directory.

Modified: haypo/hachoir/program.py
===================================================================
--- haypo/hachoir/program.py	2005-12-11 07:28:16 UTC (rev 313)
+++ haypo/hachoir/program.py	2005-12-11 07:48:58 UTC (rev 314)
@@ -1,3 +1,3 @@
 PROGRAM="Hachoir"
-VERSION="2005-10-27"
+VERSION="2005-12-11"
 WEBSITE="http://www.haypocalc.com/wiki/Hachoir"



From haypo at berlios.de  Sun Dec 11 09:49:11 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 09:49:11 +0100
Subject: [Happyboom-svn] r315 - in haypo/hachoir: plugins ui
Message-ID: <200512110849.jBB8nBAx027624@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 09:48:30 +0100 (Sun, 11 Dec 2005)
New Revision: 315

Modified:
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/jpeg.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
Replace some readArray() with classic Python while structure.
Add "copy to clipboard" button to copy chunk text.


Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-12-11 07:48:58 UTC (rev 314)
+++ haypo/hachoir/plugins/gif.py	2005-12-11 08:48:30 UTC (rev 315)
@@ -45,7 +45,10 @@
             assert issubclass(parent.__class__, GifFile)
             screen = parent.getChunk("screen").getFilter()
             self._nb_colors = (1 << screen.bits_per_pixel)
-        self.readArray("color", GifColor, "Color map", self.checkEndOfMap)
+        n = 0
+        while n<self._nb_colors:
+            self.readChild("color[]", GifColor)
+            n = n + 1
 
     def checkEndOfMap(self, stream, array, color):
         return len(array) == self._nb_colors 
@@ -60,11 +63,10 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "gif_ext", "GIF extension", stream, parent)
         self.read("func", "<B", "Function")
-        self.readArray("chunks", GifExtensionChunk, "Extension chunks", self.checkEnd)
-
-    def checkEnd(self, stream, array, chunk):
-        if chunk == None: return False
-        return chunk["size"] == 0 
+        while True:
+            chunk = self.readChild("chunk[]", GifExtensionChunk)
+            if chunk.getFilter()["size"] == 0:
+                break
         
 class GifScreenDescriptor(Filter):
     def __init__(self, stream, parent):

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-12-11 07:48:58 UTC (rev 314)
+++ haypo/hachoir/plugins/jpeg.py	2005-12-11 08:48:30 UTC (rev 315)
@@ -29,6 +29,20 @@
             self.read("thumb_data", "%us" % size, "Thumbnail data")
 
 class JpegChunk(Filter):
+    type_name = {
+        0xC0: "Start Of Frame 0 (SOF0)",
+        0xC3: "Define Huffman Table (DHT)",
+        0xD8: "Start of image (SOI)",
+        0xD9: "End of image (EOI)",
+        0xDA: "Start Of Scan (SOS)",
+        0xDB: "Define Quantization Table (DQT)",
+        0xDC: "Define number of Lines (DNL)",
+        0xDD: "Define Restart Interval (DRI)",
+        0xE1: "EXIF",
+        0xE0: "APP0",
+        0xFE: "Comment"
+    }
+
     def __init__(self, stream, parent):
         Filter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
         chunk = self.read("header", "B", "Header")
@@ -50,37 +64,20 @@
             self.read("data", "!%us" % size, "Data")
 
     def getChunkType(self, chunk):
-        types = {
-            0xC0: "Start Of Frame 0 (SOF0)",
-            0xC3: "Define Huffman Table (DHT)",
-            0xD8: "Start of image (SOI)",
-            0xD9: "End of image (EOI)",
-            0xDA: "Start Of Scan (SOS)",
-            0xDB: "Define Quantization Table (DQT)",
-            0xDC: "Define number of Lines (DNL)",
-            0xDD: "Define Restart Interval (DRI)",
-            0xE1: "EXIF",
-            0xE0: "APP0",
-            0xFE: "Comment"
-        }
         type = chunk.value
-        if type in types:
-            type = types[type]
-        else:
-            type = "Unknow type (%02X)" % type
+        type = JpegChunk.type_name.get(type, "Unknow type (%02X)" % type)
         self.setDescription("JPEG chunk \"%s\"" % type)
         return type
 
 class JpegFile(Filter):
-    def checkEndOfChunks(self, stream, array, chunk):
-        if chunk != None and chunk["type"] == 0xDA: return True
-        return stream.eof()
-
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "jpeg_file", "JPEG file", stream, parent)
         self.read("header", "!2B", "Header \"start of image\" (0xFF, 0xD8)")
         assert self["header"] == (0xFF, 0xD8)
-        self.readArray("chunk", JpegChunk, "Chunks", self.checkEndOfChunks)
+        while not stream.eof():
+            chunk = self.readChild("chunk[]", JpegChunk)
+            if chunk.getFilter()["type"] == 0xDA:
+                break
         self.read("data", "!{@end@}s", "JPEG data")
         
 registerPlugin(JpegFile, "image/jpeg")

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-12-11 07:48:58 UTC (rev 314)
+++ haypo/hachoir/plugins/png.py	2005-12-11 08:48:30 UTC (rev 315)
@@ -75,20 +75,6 @@
         return "PNG time chunk <%04u-%02u-%02u %02u:%02u:%02u>" % \
             (self["year"], self["month"], self["day"],
              self["hour"], self["minute"], self["second"])
-
-class PngFile(Filter):
-    """
-    Split a PNG file into chunks.
-    """
-
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "png_file", "PNG file", stream, parent)
-        self.read("header", "!8s", "File header")
-        assert self["header"] == "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"
-        self.readArray("chunks", PngChunk, "Png chunks", self.checkEndOfChunks)
-
-    def checkEndOfChunks(self, stream, array, png_chunk):
-        return stream.eof()
         
 class PngChunk(Filter):
     def __init__(self, stream, parent):
@@ -119,4 +105,16 @@
     def __str__(self):
         return "PngChunk <size=%u, type=%s>" % (self["size"], self["type"])
 
+class PngFile(Filter):
+    """
+    Split a PNG file into chunks.
+    """
+
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "png_file", "PNG file", stream, parent)
+        self.read("header", "!8s", "File header")
+        assert self["header"] == "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"
+        while not stream.eof():
+            self.readChild("chunks[]", PngChunk)
+
 registerPlugin(PngFile, ["image/png", "image/x-png"])

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-12-11 07:48:58 UTC (rev 314)
+++ haypo/hachoir/ui/hachoir.glade	2005-12-11 08:48:30 UTC (rev 315)
@@ -935,6 +935,19 @@
 		  </child>
 
 		  <child>
+		    <widget class="GtkButton" id="on_chunk_copy">
+		      <property name="visible">True</property>
+		      <property name="can_default">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-copy</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="onChunkCopy" last_modification_time="Sun, 11 Dec 2005 08:45:53 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
 		    <widget class="GtkButton" id="info_chunk_delete">
 		      <property name="visible">True</property>
 		      <property name="can_default">True</property>

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-11 07:48:58 UTC (rev 314)
+++ haypo/hachoir/ui/ui_window.py	2005-12-11 08:48:30 UTC (rev 315)
@@ -68,6 +68,13 @@
         self.table.connect("button_press_event", self.on_treeview_button_press_event)
         self.window.set_size_request(600,560)
         self.build_table()
+        
+    def onChunkCopy(self, event):
+        chunk = self.getActiveChunk()
+        print "Copy %s" % chunk
+        assert chunk != None
+        text = chunk.getStringValue()
+        self.ui.getClipboard().set_text(text)
 
     def onSaveChunk(self, event):
         chunk = self.getActiveChunk()



From haypo at berlios.de  Sun Dec 11 10:02:21 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 11 Dec 2005 10:02:21 +0100
Subject: [Happyboom-svn] r316 - in haypo/hachoir: . ui
Message-ID: <200512110902.jBB92LH1000339@sheep.berlios.de>

Author: haypo
Date: 2005-12-11 10:02:16 +0100 (Sun, 11 Dec 2005)
New Revision: 316

Modified:
   haypo/hachoir/error.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui.py
   haypo/hachoir/ui/ui_window.py
Log:
Fix error/warning (display message box if UI is loaded), add border in UI,
and close ask confirmation.


Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-12-11 08:48:30 UTC (rev 315)
+++ haypo/hachoir/error.py	2005-12-11 09:02:16 UTC (rev 316)
@@ -1,10 +1,11 @@
 import os
 from log import log
-from ui.ui import ui as ui
+import ui.ui
 
 def warning(message):
     log.warning(message)   
-    if ui != None:
+    if ui.ui.ui != None:
+        import gtk
         dlg = gtk.MessageDialog( \
             type=gtk.MESSAGE_WARNING,
             buttons=gtk.BUTTONS_OK,
@@ -14,7 +15,9 @@
 
 def error(message):
     log.error(message)
-    if ui != None:
+    print ui.ui
+    if ui.ui.ui != None:
+        import gtk
         dlg = gtk.MessageDialog( \
             type=gtk.MESSAGE_ERROR,
             buttons=gtk.BUTTONS_OK,

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-12-11 08:48:30 UTC (rev 315)
+++ haypo/hachoir/ui/hachoir.glade	2005-12-11 09:02:16 UTC (rev 316)
@@ -917,6 +917,7 @@
 
 	      <child>
 		<widget class="GtkHButtonBox" id="hbuttonbox2">
+		  <property name="border_width">6</property>
 		  <property name="visible">True</property>
 		  <property name="layout_style">GTK_BUTTONBOX_DEFAULT_STYLE</property>
 		  <property name="spacing">0</property>
@@ -998,6 +999,7 @@
 
 	  <child>
 	    <widget class="GtkVBox" id="vbox5">
+	      <property name="border_width">6</property>
 	      <property name="visible">True</property>
 	      <property name="homogeneous">False</property>
 	      <property name="spacing">0</property>
@@ -1143,6 +1145,7 @@
 
 	  <child>
 	    <widget class="GtkVBox" id="vbox6">
+	      <property name="border_width">6</property>
 	      <property name="visible">True</property>
 	      <property name="homogeneous">False</property>
 	      <property name="spacing">0</property>

Modified: haypo/hachoir/ui/ui.py
===================================================================
--- haypo/hachoir/ui/ui.py	2005-12-11 08:48:30 UTC (rev 315)
+++ haypo/hachoir/ui/ui.py	2005-12-11 09:02:16 UTC (rev 316)
@@ -6,7 +6,7 @@
     try:
         pygtk.require ('2.0') # 2.2 for Clipboard
     except:
-	raise Exception("Sorry, you need pyGTK version 2.0")	
+        raise Exception("Sorry, you need pyGTK version 2.0")	
     from ui_glade import GladeInterface    
     glade = os.path.join(os.path.dirname(__file__), 'hachoir.glade')
     ui = GladeInterface(glade, hachoir)
@@ -16,4 +16,4 @@
     hachoir.ui.on_go_parent = hachoir.onGoParent
 
 ui = None
-window = None
\ No newline at end of file
+window = None

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-11 08:48:30 UTC (rev 315)
+++ haypo/hachoir/ui/ui_window.py	2005-12-11 09:02:16 UTC (rev 316)
@@ -195,7 +195,14 @@
         self.on_open_activate(widget)
 
     def on_toolbutton_close(self, widget):
-        self.ui.hachoir.setFilter(None)
+        dlg = gtk.MessageDialog( \
+            type=gtk.MESSAGE_QUESTION,
+            buttons=gtk.BUTTONS_YES_NO,
+            message_format="Are you sure that you want to close the file?")
+        dlg.set_default_response(gtk.RESPONSE_NO)            
+        if dlg.run() == gtk.RESPONSE_YES:
+            self.ui.hachoir.setFilter(None)
+        dlg.destroy()
 
     def on_toolbutton_property(self, widget):
         filter = self.ui.hachoir.getFilter()



From haypo at berlios.de  Mon Dec 12 01:06:00 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 12 Dec 2005 01:06:00 +0100
Subject: [Happyboom-svn] r317 - in haypo/hachoir: . plugins stream
Message-ID: <200512120006.jBC060lj027561@sheep.berlios.de>

Author: haypo
Date: 2005-12-12 01:05:56 +0100 (Mon, 12 Dec 2005)
New Revision: 317

Added:
   haypo/hachoir/plugins/avi.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/error.py
   haypo/hachoir/stream/stream.py
Log:
Add AVI plugin.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-11 09:02:16 UTC (rev 316)
+++ haypo/hachoir/chunk.py	2005-12-12 00:05:56 UTC (rev 317)
@@ -312,11 +312,12 @@
     def __replaceFieldFormat(self, match):
         id = match.group(1)
         if id == "@end@":
-            size = self._stream.getLastPos() - self.addr
+            size = self._stream.getLastPos() - self.addr + 1
             if size < 0:
                 warning("Size < 0 for chunk %s, will use size=0!" % self.id)
                 size = 0
         else:
+            assert id != self.id
             size = self._parent[id]
         return str(size)
     

Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-12-11 09:02:16 UTC (rev 316)
+++ haypo/hachoir/error.py	2005-12-12 00:05:56 UTC (rev 317)
@@ -15,7 +15,6 @@
 
 def error(message):
     log.error(message)
-    print ui.ui
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \

Added: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-11 09:02:16 UTC (rev 316)
+++ haypo/hachoir/plugins/avi.py	2005-12-12 00:05:56 UTC (rev 317)
@@ -0,0 +1,73 @@
+"""
+AVI splitter.
+
+Creation: 12 decembre 2005
+Status: alpha
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class AVI_ChunkList(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
+        tag = self.read("tag", "4s", "Tag").value
+        size = stream.getSize()-4
+        end = stream.tell() + size
+        if tag in ("hdrl", "INFO"):
+            while 8 <= end - stream.tell():
+                chunk = self.readChild("chunk[]", AVI_Chunk)            
+            size = end - stream.tell()
+            if size != 0:
+                self.read("padding", "%us" % size, "Padding")
+        elif tag == "strl":
+            while not stream.eof():
+                self.read("stag[]", "4s", "String tag")
+                size = self.read("ssize[]", "<L", "String size").value
+                self.read("svalue[]", "%us" % size, "String value")
+        else:
+            self.read("raw", "%us" % size, "Raw data")
+        assert stream.tell() == end
+
+class AVI_ChunkString(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
+
+class AVI_Chunk(Filter):
+    handler = {
+        "LIST": AVI_ChunkList
+    }
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
+        tag = self.read("tag", "4s", "Tag").value
+        size = self.read("size", "<L", "Size").value
+        if tag in AVI_Chunk.handler:
+            end = stream.tell() + size
+            sub = stream.createSub(size=size)
+            self.readStreamChild("data", sub, AVI_Chunk.handler[tag])
+            assert stream.tell() == end
+        else:
+            self.read("raw", "%us" % size, "Raw data")
+
+    def updateParent(self, parent):
+        type = self["tag"]
+        if type == "LIST":
+            tag2 = self["data"]["tag"]
+            type = type + " (%s)" % tag2      
+        desc = "Chunk %s" % type
+        self.setDescription(desc)
+        parent.description = desc
+
+class AVI_File(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "avi_file", "AVI file", stream, parent)
+        self.read("header", "4s", "AVI header (RIFF)")
+        assert self["header"] == "RIFF"
+        self.read("filesize", "<L", "File size")
+        self.read("avi", "4s", "\"AVI \" string")
+        assert self["avi"] == "AVI "
+        while not stream.eof():
+            self.readChild("chunk[]", AVI_Chunk)
+
+registerPlugin(AVI_File, "video/x-msvideo")

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-12-11 09:02:16 UTC (rev 316)
+++ haypo/hachoir/stream/stream.py	2005-12-12 00:05:56 UTC (rev 317)
@@ -134,8 +134,8 @@
         self._stream = stream.clone()
         if start<0:
             start = 0
-        if self._stream.getLastPos() < start+size:
-            size = self._stream.getLastPos()-start
+        if self._stream.getLastPos()+1 < start+size:
+            size = self._stream.getLastPos()-start+1
         self._start = start
         self._size = size
         self._end = self._start + self._size



From haypo at berlios.de  Mon Dec 12 01:29:08 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 12 Dec 2005 01:29:08 +0100
Subject: [Happyboom-svn] r318 - in haypo/hachoir: . plugins
Message-ID: <200512120029.jBC0T8ku005085@sheep.berlios.de>

Author: haypo
Date: 2005-12-12 01:29:05 +0100 (Mon, 12 Dec 2005)
New Revision: 318

Added:
   haypo/hachoir/README
Modified:
   haypo/hachoir/plugins/avi.py
Log:
Add README and AVI can read video and audio headers.


Added: haypo/hachoir/README
===================================================================
--- haypo/hachoir/README	2005-12-12 00:05:56 UTC (rev 317)
+++ haypo/hachoir/README	2005-12-12 00:29:05 UTC (rev 318)
@@ -0,0 +1,10 @@
+Hachoir
+=======
+
+Hachoir is a Python program which parse binary streams. It uses plugins
+to support new (file) formats using MIME type detection to choose right
+plugin. It can do uncompress bz2, gzip and deflate streams.
+
+If you had problems to install it, read INSTALL file.
+
+Website: http://www.haypocalc.com/wiki/Hachoir

Modified: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-12 00:05:56 UTC (rev 317)
+++ haypo/hachoir/plugins/avi.py	2005-12-12 00:29:05 UTC (rev 318)
@@ -18,16 +18,45 @@
         if tag in ("hdrl", "INFO"):
             while 8 <= end - stream.tell():
                 chunk = self.readChild("chunk[]", AVI_Chunk)            
-            size = end - stream.tell()
-            if size != 0:
-                self.read("padding", "%us" % size, "Padding")
         elif tag == "strl":
-            while not stream.eof():
-                self.read("stag[]", "4s", "String tag")
+            while 8 <= end - stream.tell():
+                stag = self.read("stag[]", "4s", "String tag").value
                 size = self.read("ssize[]", "<L", "String size").value
-                self.read("svalue[]", "%us" % size, "String value")
+                if stag == "strf" and size == 40:
+                    # Video header
+                    self.read("v_size", "<L", "Video format: Size")                    
+                    self.read("v_width", "<L", "Video format: Width")                    
+                    self.read("v_height", "<L", "Video format: Height")                    
+                    self.read("v_panes", "<H", "Video format: Panes")                    
+                    self.read("v_depth", "<H", "Video format: Depth")                    
+                    self.read("v_tag1", "<L", "Video format: Tag1")                    
+                    self.read("v_img_size", "<L", "Video format: Image size")                    
+                    self.read("v_xpels_meter", "<L", "Video format: XPelsPerMeter")
+                    self.read("v_ypels_meter", "<L", "Video format: YPelsPerMeter")
+                    self.read("v_clr_used", "<L", "Video format: ClrUsed")
+                    self.read("v_clr_importand", "<L", "Video format: ClrImportant")
+                elif stag == "strf" and size == 30:
+                    # Audio (wav) header
+                    aend = stream.tell() + size
+                    self.read("a_id", "<H", "Audio format: ID")                    
+                    self.read("a_channel", "<H", "Audio format: Channels")                    
+                    self.read("a_sample_rate", "<L", "Audio format: Sample rate")                    
+                    self.read("a_bit_rate", "<L", "Audio format: Bit rate")
+                    self.read("a_block_align", "<H", "Audio format: Block align")
+                    #?if size == 14: bits_per_sample = 8
+                    self.read("a_bits_per_sample", "<H", "Audio format: Bits per sample")
+                    self.read("a_codec_id", "<H", "Audio format: Codec id")
+                    diff = aend-stream.tell()
+                    if 0 < diff:
+                        self.read("a_extra", "%us" % diff, "Audio format: Extra")
+                    assert stream.tell() == aend
+                else:
+                    self.read("svalue[]", "%us" % size, "String value")
         else:
             self.read("raw", "%us" % size, "Raw data")
+        padding = end - stream.tell()
+        if padding != 0:
+            self.read("padding", "%us" % padding, "Padding")
         assert stream.tell() == end
 
 class AVI_ChunkString(Filter):



From haypo at berlios.de  Mon Dec 12 17:05:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 12 Dec 2005 17:05:22 +0100
Subject: [Happyboom-svn] r319 - haypo/hachoir/plugins
Message-ID: <200512121605.jBCG5MZD029390@sheep.berlios.de>

Author: haypo
Date: 2005-12-12 17:05:21 +0100 (Mon, 12 Dec 2005)
New Revision: 319

Modified:
   haypo/hachoir/plugins/png.py
Log:
Fix dummy bug in PNG.


Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-12-12 00:29:05 UTC (rev 318)
+++ haypo/hachoir/plugins/png.py	2005-12-12 16:05:21 UTC (rev 319)
@@ -54,7 +54,7 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "png_text", "PNG text", stream, parent)
         chunk = self.readString("keyword", "C", "Keyword")
-        lg = self._parent.size - chunk.size
+        lg = stream.getSize() - chunk.size
         self.read("text", "!%us" % lg, "Text")
 
     def __str__(self):
@@ -77,23 +77,24 @@
              self["hour"], self["minute"], self["second"])
         
 class PngChunk(Filter):
+    handler = {
+        "tIME": PngTime,
+        "pHYs": PngPhysical,
+        "IHDR": PngHeader,
+        "gAMA": PngGamma,
+        "tEXt": PngText
+    }
     def __init__(self, stream, parent):
         Filter.__init__(self, "png_chunk", "PNG chunk", stream, parent)
         self.read("size", "!L", "Chunk size")
         self.read("type", "!4s", "Chunk type")
-        self.chunk_splitter = {
-            "tIME": PngTime,
-            "pHYs": PngPhysical,
-            "IHDR": PngHeader,
-            "gAMA": PngGamma,
-            "tEXt": PngText
-        }
-        if self["type"] in self.chunk_splitter:
+        type = self["type"]
+        if type in PngChunk.handler:
+            size = self["size"]
             oldpos = self._stream.tell()
-            child_filter = self.chunk_splitter[self["type"]]
-            sub = stream.createSub(stream.tell(), self["size"])
-            self.readStreamChild("chunk_data", sub, child_filter)
-            stream.seek(oldpos + self["size"])
+            sub = stream.createSub(size=size)
+            self.readStreamChild("chunk_data", sub, PngChunk.handler[type])
+            assert stream.tell() == (oldpos + size) 
         else:
             self.read("data", "!{size}s", "Chunk data")
         self.read("crc32", "!L", "Chunk CRC32")



From haypo at berlios.de  Mon Dec 12 18:19:18 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 12 Dec 2005 18:19:18 +0100
Subject: [Happyboom-svn] r320 - haypo/hachoir/plugins
Message-ID: <200512121719.jBCHJI7b006996@sheep.berlios.de>

Author: haypo
Date: 2005-12-12 18:19:17 +0100 (Mon, 12 Dec 2005)
New Revision: 320

Modified:
   haypo/hachoir/plugins/xcf.py
Log:
Fix XCF chunk handlers: use Filter instead of readXXX functions.


Modified: haypo/hachoir/plugins/xcf.py
===================================================================
--- haypo/hachoir/plugins/xcf.py	2005-12-12 16:05:21 UTC (rev 319)
+++ haypo/hachoir/plugins/xcf.py	2005-12-12 17:19:17 UTC (rev 320)
@@ -11,32 +11,41 @@
 from filter import Filter
 from plugin import registerPlugin
 
-def readCompression(filter, stream):
+class XcfCompression(Filter):
     name = {
         0: "None",
         1: "RLE",
         2: "Zlib",
         3: "Fractal"
     }
-    chunk = filter.read("compression", "B", "")
-    type = name.get(chunk.value, "Unknow (%s)" % chunk.value)
-    chunk.description = "Compress type (%s)" % type
 
-def readResolution(filter, stream):
-    filter.read("xres", "f", "X resolution")
-    filter.read("yres", "f", "Y resolution")
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "compression", "Compression", stream, parent)
+        chunk = self.read("compression", "B", "")
+        type = XcfCompression.name.get(chunk.value, "Unknow (%s)" % chunk.value)
+        chunk.description = "Compress type (%s)" % type
 
-def readTattoo(filter, stream):
-    filter.read("tattoo", "!L", "Tattoo")
+class XcfResolution(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "resolution", "Resolution", stream, parent)
+        self.read("xres", "f", "X resolution")
+        self.read("yres", "f", "Y resolution")
 
-def readUnit(filter, stream):
-    filter.read("unit", "!L", "Unit")
+class XcfTattoo(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "tattoo", "Tattoo", stream, parent)
+        self.read("tattoo", "!L", "Tattoo")
 
+class XcfUnit(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "unit", "Unit", stream, parent)
+        self.read("unit", "!L", "Unit")
+
 def readString(filter, stream, name, description):
     chunk = filter.read(name+"_size", "!L", description+" length")
     filter.read(name, "%us" % chunk.value, description)
 
-class XcfParasite(Filter):
+class XcfParasiteEntry(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "xcf_para", "XCF parasite", stream, parent)
         readString(self, stream, "name", "Name")
@@ -92,7 +101,6 @@
         self.read("height", "!L", "Channel height")
         readString(self, stream, "name", "Channel name")
         readProperties(self, stream)
-        return
         self.read("hierarchie_ofs", "!L", "Hierarchie offset")
         self.readChild("hierarchie", XcfHierarchie)
 
@@ -111,9 +119,11 @@
         self.readChild("hierarchie", XcfHierarchie)
         # TODO: Read layer mask if needed: self["mask_ofs"] != 0
 
-def readParasites(filter, stream):
-    while not stream.eof():
-        filter.readChild("parasite[]", XcfParasite)
+class XcfParasites(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "parasites", "Parasites", stream, parent)
+        while not stream.eof():
+            self.readChild("parasite[]", XcfParasiteEntry)
 
 class XcfProperty(Filter):
     known_types = {
@@ -146,11 +156,11 @@
         26: "Text layer flags"
     }
     handler = {
-        17: readCompression,
-        19: readResolution,
-        20: readTattoo,
-        21: readParasites,
-        22: readUnit
+        17: XcfCompression,
+        19: XcfResolution,
+        20: XcfTattoo,
+        21: XcfParasites,
+        22: XcfUnit
     }
 
     def __init__(self, stream, parent):
@@ -162,7 +172,7 @@
         if type in XcfProperty.handler:
             end = stream.tell() + self["size"]
             substream = stream.createSub(size=self["size"])
-            XcfProperty.handler[type] (self, substream)
+            self.readStreamChild("data", substream, XcfProperty.handler[type])
             assert stream.tell() == end
         elif 0 < self["size"]:
             self.read("data", "%us" % self["size"], "Data")



From haypo at berlios.de  Mon Dec 12 18:44:25 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 12 Dec 2005 18:44:25 +0100
Subject: [Happyboom-svn] r321 - in haypo/hachoir: . plugins
Message-ID: <200512121744.jBCHiPX4022596@sheep.berlios.de>

Author: haypo
Date: 2005-12-12 18:44:22 +0100 (Mon, 12 Dec 2005)
New Revision: 321

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/xcf.py
Log:
Improve StringChunk: add "Pascal32" string type, and also "strip" argument.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-12 17:19:17 UTC (rev 320)
+++ haypo/hachoir/chunk.py	2005-12-12 17:44:22 UTC (rev 321)
@@ -141,9 +141,21 @@
 
 class StringChunk(Chunk):
     regex_eol_nr = re.compile("[\n\r]")
+    names = {
+        "C": "c-string",
+        "MacLine": "mac line",
+        "UnixLine": "unix line",
+        "AutoLine": "line",
+        "Pascal32": "pascal32",
+        "WindowsLine": "windows line"
+    }
 
-    def __init__(self, id, description, stream, str_type, parent):
-        assert str_type in ("C", "UnixLine", "WindowsLine", "MacLine", "AutoLine")
+    def __init__(self, id, description, stream, str_type, parent, strip=None):
+        """
+        Strip: if strip=None, call read text.strip()
+               if strip is a string, call read text.strip(self.strip)
+        """
+        assert str_type in StringChunk.names
         Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
         self._str_type = str_type
         self.eol = None
@@ -151,20 +163,20 @@
         self._cache_addr = None
         self._cache_max_size = None
         self._cache_value = None
+        self.strip = strip
 
     def getFormat(self):
-        names = {
-            "C": "c-string",
-            "MacLine": "mac line",
-            "UnixLine": "unix line",
-            "AutoLine": "line",
-            "WindowsLine": "windows line"
-        }
-        assert self._str_type in names
-        return names[self._str_type]
+        assert self._str_type in StringChunk.names
+        return StringChunk.names[self._str_type]
 
     def _findSize(self):
         self._stream.seek(self.addr)
+        if self._str_type == "Pascal32":
+            self.length = self._stream.getFormat("!L")[0]
+            self._size = 4 + self.length
+            self.eol = ""
+            return
+            
         if self._str_type == "AutoLine":
             self._size = self._stream.searchLength(StringChunk.regex_eol_nr, True)
             assert self._size != -1
@@ -196,12 +208,21 @@
         self._cache_max_size = max_size
 
         self._stream.seek(self.addr)
-        size = self._size - len(self.eol)
+        if self._str_type == "Pascal32":
+            self._stream.seek(4,1)
+            size = self.length
+        else:
+            size = self._size - len(self.eol)
         if max_size != None and max_size<size:
             text = self._stream.getN(max_size)+"(...)"
         else:
             text = self._stream.getN(size)
         self._stream.seek(self.addr + self._size)
+        if self.strip != None:
+            if self.strip == True:
+                text = text.strip()
+            else:
+                text = text.strip(self.strip)
         self._cache_value = text
         return text
 

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-12 17:19:17 UTC (rev 320)
+++ haypo/hachoir/filter.py	2005-12-12 17:44:22 UTC (rev 321)
@@ -360,9 +360,9 @@
         chunk.postProcess()
         return chunk
     
-    def readString(self, id, format, description, post=None):
+    def readString(self, id, format, description, post=None, strip=None):
         """ Returns chunk """
-        chunk = StringChunk(id, description, self._stream, format, self)
+        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
         self.appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)
         chunk.post_process = post

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-12-12 17:19:17 UTC (rev 320)
+++ haypo/hachoir/plugins/pdf.py	2005-12-12 17:44:22 UTC (rev 321)
@@ -9,14 +9,11 @@
 def isEnd(stream, array, last):
     return stream.eof()
 
-def stripLine(chunk):
-    return convertDataToPrintableString(chunk.value.strip())
-
 class PdfObject(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "pdf_obj", "PDF object", stream, parent)
         self.metadata = {}
-        chunk = self.readString("header", "AutoLine", "Object header", post=stripLine)
+        chunk = self.readString("header", "AutoLine", "Object header", strip=True)
         header = chunk.value 
         assert header != ""
         if header == "xref":
@@ -51,7 +48,7 @@
         deflate = False
         while text not in ("endobj", "stream"):
             self.processLine(text)
-            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+            chunk = self.readString("line[]", "AutoLine", "", strip=True)
             text = chunk.value
             if re.match(r".*/Filter /FlateDecode.*", chunk.value) != None:
                 deflate = True
@@ -89,22 +86,22 @@
             assert self.getStream().tell() == (start+size)
             
             self.readString("data_end[]", "AutoLine", "Data end")
-            self.readString("endobj", "AutoLine", "Object end", post=stripLine)
+            self.readString("endobj", "AutoLine", "Object end", strip=True)
         ver = self.getParent().version
         eol = self.getStream().read(1, seek=False)
         if eol in ("\n", "\r"):
             self.readString("emptyline", "AutoLine", "")
 
     def readXref(self):
-        chunk = self.readString("xref_header", "AutoLine", "XRef header", post=stripLine)
+        chunk = self.readString("xref_header", "AutoLine", "XRef header", strip=True)
         m = re.match(r"^[0-9]+ ([0-9]+)$", chunk.value)
         assert m != None
         nb_ref = int(m.group(1)) - 1
         n = 0
         while n<nb_ref:
-            chunk = self.readString("ref[]", "AutoLine", "Reference", post=stripLine)
+            chunk = self.readString("ref[]", "AutoLine", "Reference", strip=True)
             n = n + 1
-        self.readString("endobj", "AutoLine", "Object end", post=stripLine)
+        self.readString("endobj", "AutoLine", "Object end", strip=True)
 
     def processLine(self, line):
         tests = {

Modified: haypo/hachoir/plugins/xcf.py
===================================================================
--- haypo/hachoir/plugins/xcf.py	2005-12-12 17:19:17 UTC (rev 320)
+++ haypo/hachoir/plugins/xcf.py	2005-12-12 17:44:22 UTC (rev 321)
@@ -42,6 +42,9 @@
         self.read("unit", "!L", "Unit")
 
 def readString(filter, stream, name, description):
+    filter.readString(name, "Pascal32", description, strip="\0")
+    return
+    
     chunk = filter.read(name+"_size", "!L", description+" length")
     filter.read(name, "%us" % chunk.value, description)
 
@@ -119,6 +122,11 @@
         self.readChild("hierarchie", XcfHierarchie)
         # TODO: Read layer mask if needed: self["mask_ofs"] != 0
 
+    def updateParent(self, chunk):
+        desc = "Layer \"%s\"" % self["name"]
+        chunk.description = desc
+        self.setDescription(desc)
+
 class XcfParasites(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "parasites", "Parasites", stream, parent)



From haypo at berlios.de  Tue Dec 13 01:16:26 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 13 Dec 2005 01:16:26 +0100
Subject: [Happyboom-svn] r322 - in haypo/hachoir: . plugins
Message-ID: <200512130016.jBD0GQlF031831@sheep.berlios.de>

Author: haypo
Date: 2005-12-13 01:16:05 +0100 (Tue, 13 Dec 2005)
New Revision: 322

Added:
   haypo/hachoir/plugins/id3.py
   haypo/hachoir/plugins/mp3.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/config.py
   haypo/hachoir/tools.py
Log:
Add MP3 filter and ID3 filter. Write humanDuration function, and fix
FormatChunk max display length.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-12 17:44:22 UTC (rev 321)
+++ haypo/hachoir/chunk.py	2005-12-13 00:16:05 UTC (rev 322)
@@ -393,7 +393,7 @@
     def getDisplayData(self):
         if self.display != None:
             return self.display
-        data = self.getValue(20)
+        data = self.getValue(config.max_string_length)
         if type(data)==types.StringType:
             return convertDataToPrintableString(data)
         else:

Modified: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-12-12 17:44:22 UTC (rev 321)
+++ haypo/hachoir/config.py	2005-12-13 00:16:05 UTC (rev 322)
@@ -1,3 +1,3 @@
-max_string_length = 14
+max_string_length = 10
 max_hexa_length = 4096 
 max_ascii_length = 4096 

Added: haypo/hachoir/plugins/id3.py
===================================================================
--- haypo/hachoir/plugins/id3.py	2005-12-12 17:44:22 UTC (rev 321)
+++ haypo/hachoir/plugins/id3.py	2005-12-13 00:16:05 UTC (rev 322)
@@ -0,0 +1,119 @@
+"""
+AVI splitter.
+
+Creation: 12 decembre 2005
+Status: alpha
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from tools import humanDuration
+
+class ID3_String(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "id3_string", "ID3 string", stream, parent)
+        self.read("zero", "B", "Zero")
+        assert self["zero"] == 0
+        size = stream.getSize()-1
+        self.read("content", "%us" % size, "Content")
+
+class ID3_Private(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "id3_priv", "ID3 private", stream, parent)
+        size = stream.getSize()
+        if stream.read(9, False) == "PeakValue":
+            self.read("text", "%us" % 9, "Text")
+            size = size - 9
+            self.read("content", "%us" % size, "Content")
+        else:
+            self.read("content", "%us" % size, "Content")
+
+class ID3_TrackLength(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "id3_tlen", "ID3 track length", stream, parent)
+        self.read("zero", "B", "Zero")
+        assert self["zero"] == 0
+        size = stream.getSize()-1
+        self.read("length", "%us" % size, "Length in ms", post=self.computeLength)
+
+    def computeLength(self, chunk):
+        try:
+            ms = int(chunk.value)
+            return humanDuration(ms)
+        except:
+            return chunk.value
+        
+
+class ID3_Chunk(Filter):
+    name = {
+        "COMM": "Comment",
+        "PRIV": "Private",
+        "TPE1": "Artist",
+        "TCOP": "Copyright",
+        "TALB": "Album",
+        "TENC": "Encoder",
+        "TYER": "Year",
+        "TSSE": "Encoder settings",
+        "TCOM": "Composer",
+        "TRCK": "Track number",
+        "PCNT": "Play counter",
+        "TCON": "Content type",
+        "TLEN": "Track length",
+        "TIT2": "Track title"
+    }
+    handler = {
+        "TYER": ID3_String,
+        "TALB": ID3_String,
+        "TCON": ID3_String,
+        "TPE1": ID3_String,
+        "TCOP": ID3_String,
+        "TRCK": ID3_String,
+        "TIT2": ID3_String,
+        "TSSE": ID3_String,
+        "PRIV": ID3_Private,
+        "TLEN": ID3_TrackLength
+    }
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "id3_chunk", "ID3 Chunk", stream, parent)
+        tag = self.read("tag", "!4s", "Tag").value
+        self.read("size", ">L", "Size")
+        self.read("flags", ">H", "Flags")
+        size = self["size"]
+        if tag in ID3_Chunk.handler:
+            end = stream.tell() + size
+            substream = stream.createLimited(size=size)
+            self.readStreamChild("content", substream, ID3_Chunk.handler[tag])
+            assert stream.tell() == end
+        else:
+            self.read("data", "%us" % size, "Raw data")
+
+    def updateParent(self, chunk):
+        type = self["tag"].strip("\0")
+        if type != "":
+            type = ID3_Chunk.name.get(type, "Unknow (\"%s\")" % type)
+            desc = "ID3 Chunk: %s" % type
+        else:
+            desc = "(empty ID3 chunk)"
+        chunk.description = desc
+        self.setDescription(desc)
+
+class ID3_Parser(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "id3", "ID3", stream, parent)
+        header = self.read("header", "!3s", "Header (ID3)").value
+        assert header == "ID3"
+        ver_major = self.read("ver_major", "!1B", "Version (major)").value
+        assert ver_major in (3,4)
+        ver_minor = self.read("ver_minor", "!B", "Version (minor)").value
+#        assert ver_minor == 0
+        self.read("flags", "!B", "Flags")
+        self.read("size", "!L", "Size")
+        end = stream.tell() + self["size"]
+        while stream.tell() < end:
+            chunk = self.readChild("chunk[]", ID3_Chunk)
+            if chunk.getFilter()["size"] == 0:
+                break
+        padding = end - stream.tell()
+        if 0 < padding:
+            self.read("padding", "%us" % padding, "Padding")
+#        assert stream.tell() == end

Added: haypo/hachoir/plugins/mp3.py
===================================================================
--- haypo/hachoir/plugins/mp3.py	2005-12-12 17:44:22 UTC (rev 321)
+++ haypo/hachoir/plugins/mp3.py	2005-12-13 00:16:05 UTC (rev 322)
@@ -0,0 +1,244 @@
+"""
+AVI splitter.
+
+Creation: 12 decembre 2005
+Status: alpha
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+from id3 import ID3_Parser
+
+class MP3_File(Filter):
+    version = {
+        0: "2.5",
+        2: "2",
+        3: "1"
+    }
+    layer = {
+        0: "(reserved)",
+        1: "III",
+        2: "II",
+        3: "I"
+    }
+    bit_rate = {
+        # MPEG1
+        1: {
+            # MPEG1, layer I
+            3: {
+                1: 32,
+                2: 64,
+                3: 96,
+                4: 128,
+                5: 160,
+                6: 192,
+                7: 224,
+                8: 256,
+                9: 288,
+                10: 320,
+                11: 352,
+                12: 384,
+                13: 416,
+                14: 448
+            },
+
+            # MPEG1, layer II
+            2: {
+                1: 32,
+                2: 48,
+                3: 56,
+                4: 64,
+                5: 80,
+                6: 96,
+                7: 112,
+                8: 128,
+                9: 160,
+                10: 192,
+                11: 224,
+                12: 256,
+                13: 320,
+                14: 384
+            },
+
+            # MPEG1, layer III
+            1: {
+                1: 32,
+                2: 40,
+                3: 48,
+                4: 56,
+                5: 64,
+                6: 80,
+                7: 96,
+                8: 112,
+                9: 128,
+                10: 160,
+                11: 192,
+                12: 224,
+                13: 256,
+                14: 320
+            }
+        },
+        
+        # MPEG2 / MPEG2.5
+        2: {
+            # MPEG2 / MPEG2.5, layer I
+            3: {
+                1: 32,
+                2: 64,
+                3: 96,
+                4: 128,
+                5: 160,
+                6: 192,
+                7: 224,
+                8: 256,
+                9: 288,
+                10: 320,
+                11: 352,
+                12: 384,
+                13: 416,
+                14: 448},
+
+            # MPEG2 / MPEG2.5, layer II
+            2: {
+                1: 32,
+                2: 48,
+                3: 56,
+                4: 64,
+                5: 80,
+                6: 96,
+                7: 112,
+                8: 128,
+                9: 160,
+                10: 192,
+                11: 224,
+                12: 256,
+                13: 320,
+                14: 384},
+
+            # MPEG2 / MPEG2.5, layer III
+            1: {
+                1: 8,  #?8
+                2: 16, # 16
+                3: 24, # 24
+                4: 32, # 32
+                5: 64, # 40
+                6: 80, # 48
+                7: 56, # 56
+                8: 64, # 64
+                9: 128, # 80
+                10: 160, # 96
+                11: 112, # 112
+                12: 128, # 128
+                13: 256, # 144 
+                14: 320} #?160
+        }
+    }
+    sampling_rate = {
+        # MPEG1
+        3: {
+            0: 44100,
+            1: 48000,
+            2: 32000},
+        # MPEG2
+        2: {
+            0: 22050,
+            1: 24000,
+            2: 16000},
+        # MPEG2.5
+        1: {
+            0: 11025,
+            1: 12000,
+            2: 8000}
+    }
+    emphasis = {
+        0: "none",
+        1: "50/15 ms",
+        3: "CCIT J.17"
+    }
+    channel_mode = {
+        0: "Stereo",
+        1: "Joint stereo",
+        2: "Dual channel",
+        3: "Single channel"
+    }
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "mp3", "MP3 file", stream, parent)
+        if stream.getN(3, False)=="ID3":
+            self.readChild("id3", ID3_Parser)
+        self.read("header", "!H", "Header", post=self.postHeader)
+        self.read("rate", "B", "Rates and padding", post=self.postRate)
+        self.read("various", "B", "Channel mode, mode extension, copyright, original", post=self.postVarious)
+
+        print (self.sampling_rate, self.bit_rate, self.padding)
+        frame_size = (144 * self.sampling_rate) / self.bit_rate + self.padding
+        print "Frame size=%s" % frame_size
+        
+    def postVarious(self, chunk):
+        # Get channel mode
+        channel_mode = chunk.value >> 6 & 3
+        text = MP3_File.channel_mode[channel_mode]
+
+#        mode_extension = chunk.value >> 4 & 3
+
+        # Get copyright bit
+        copyright = chunk.value >> 3 & 1
+        if copyright == 1:
+            text = text + ", copyrighted"
+
+        # Get original bit
+        original = chunk.value >> 2 & 1
+        if original == 1:
+            text = text + ", is original"
+        else:
+            text = text + ", copied"
+
+        # Get emphasis
+        emphasis = chunk.value & 3
+        assert emphasis in MP3_File.emphasis
+        emphasis = MP3_File.emphasis[emphasis]
+        if emphasis != "none":
+            text = text + ", emphasis=%s" % emphasis
+        return text 
+
+    def postHeader(self, chunk):
+        header = chunk.value
+        sync = header >> 5
+        assert sync == 2047
+        self.version = header >> 3 & 3
+        assert self.version in MP3_File.version
+        self.layer = header >> 1 & 3
+        protection = header & 1
+        text = "MPEG%s, layer %s" % (\
+            MP3_File.version[self.version],
+            MP3_File.layer[self.layer])
+        if protection==1:
+            text = "%s, protected" % text
+        return text
+
+    def postRate(self, chunk):
+        # Get bit rates
+        bit_rate = chunk.value >> 4
+        if self.version == 3: # MPEG1
+            rates = MP3_File.bit_rate[1] # MPEG1
+        else:
+            rates = MP3_File.bit_rate[2] # MPEG2 / MPEG2.5
+        assert self.layer in rates
+        rates = rates[self.layer]
+        assert bit_rate in rates
+        self.bit_rate = rates[bit_rate]
+        
+        # Get sampling rate
+        sampling_rate = chunk.value >> 2 & 3
+        rates = MP3_File.sampling_rate[self.version]
+        assert sampling_rate in rates
+        self.sampling_rate = rates[sampling_rate]
+        text = "%u bps, %s Hz" % (self.bit_rate, self.sampling_rate)
+        
+        # Get Padding
+        self.padding = chunk.value >> 1 & 1
+        if self.padding==1:
+            text = text + ", padded"
+        return text
+
+registerPlugin(MP3_File, "audio/mpeg")

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-12-12 17:44:22 UTC (rev 321)
+++ haypo/hachoir/tools.py	2005-12-13 00:16:05 UTC (rev 322)
@@ -88,6 +88,18 @@
         raise "Can't parse regular expression: %s" % pattern 
     return size 
 
+def humanDuration(ms):
+    if ms < 1000:
+        return "%u ms" % ms
+    sec = ms/1000
+    ms = ms%1000
+    if sec < 60:
+        return  "%u sec" % sec
+    min = sec/60
+    sec = sec%60
+    text = "%u min %u sec" % (min, sec)
+    return text
+
 def humanFilesize(size):
     if size < 1000:
         return "%u bytes" % size



From haypo at berlios.de  Tue Dec 13 01:25:59 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 13 Dec 2005 01:25:59 +0100
Subject: [Happyboom-svn] r323 - haypo/hachoir
Message-ID: <200512130025.jBD0Pxcb005015@sheep.berlios.de>

Author: haypo
Date: 2005-12-13 01:25:38 +0100 (Tue, 13 Dec 2005)
New Revision: 323

Removed:
   haypo/hachoir/id3.xml
   haypo/hachoir/id3_chunk.xml
Log:
Don't need ID3 xml anymore


Deleted: haypo/hachoir/id3.xml
===================================================================
--- haypo/hachoir/id3.xml	2005-12-13 00:16:05 UTC (rev 322)
+++ haypo/hachoir/id3.xml	2005-12-13 00:25:38 UTC (rev 323)
@@ -1,9 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<user_filter hachoir_version='2005-10-27' id="id3_tag" description="MP3 ID3 tag">
-  <chunk format='!3s' id='header' description='Header (ID3)'/>
-  <chunk format='!1B' id='ver_major' description='Version (major)'/>
-  <chunk format='!B' id='ver_minor' description='Version (minor)'/>
-  <chunk format='!B' id='flags' description='Flags'/>
-  <chunk format='!L' id='size' description='Size'/>
-  <chunk format='!{@end@}s' id='data' description='Data'/>
-</user_filter>

Deleted: haypo/hachoir/id3_chunk.xml
===================================================================
--- haypo/hachoir/id3_chunk.xml	2005-12-13 00:16:05 UTC (rev 322)
+++ haypo/hachoir/id3_chunk.xml	2005-12-13 00:25:38 UTC (rev 323)
@@ -1,7 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<user_filter hachoir_version='2005-10-27' id='raw' description='raw'>
-  <chunk format='!4s' id='header' description='Header'/>
-  <chunk format='>L' id='size' description='Size'/>
-  <chunk format='>H' id='flags' description='Flags'/>
-  <chunk format='!{size}s' id='data' description='Data'/>
-</user_filter>



From haypo at berlios.de  Tue Dec 13 01:54:24 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 13 Dec 2005 01:54:24 +0100
Subject: [Happyboom-svn] r324 - haypo/hachoir/plugins
Message-ID: <200512130054.jBD0sOPE018113@sheep.berlios.de>

Author: haypo
Date: 2005-12-13 01:54:19 +0100 (Tue, 13 Dec 2005)
New Revision: 324

Modified:
   haypo/hachoir/plugins/exif.py
   haypo/hachoir/plugins/jpeg.py
   haypo/hachoir/plugins/zip.py
Log:
Small bugfix in JPEG and EXIF. ZIP filter now update parent chunks.


Modified: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-12-13 00:25:38 UTC (rev 323)
+++ haypo/hachoir/plugins/exif.py	2005-12-13 00:54:19 UTC (rev 324)
@@ -232,6 +232,6 @@
                 break
             self.readChild("ifd[]", ExifIFD, endian, 6)
         size = stream.getSize() - stream.tell()
-        if size != 0:                
+        if 0 < size:
             self.read("end", "%us" % size, "End")
         assert self.getSize() == stream.getSize()

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-12-13 00:25:38 UTC (rev 323)
+++ haypo/hachoir/plugins/jpeg.py	2005-12-13 00:54:19 UTC (rev 324)
@@ -78,6 +78,7 @@
             chunk = self.readChild("chunk[]", JpegChunk)
             if chunk.getFilter()["type"] == 0xDA:
                 break
-        self.read("data", "!{@end@}s", "JPEG data")
+        size = stream.getSize() - self.getSize()
+        self.read("data", "%us" % size, "JPEG data")
         
 registerPlugin(JpegFile, "image/jpeg")

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-12-13 00:25:38 UTC (rev 323)
+++ haypo/hachoir/plugins/zip.py	2005-12-13 00:54:19 UTC (rev 324)
@@ -33,6 +33,11 @@
         self.read("extra", "<{extra_length}s", "Extra fields")
         self.read("file_comment", "<{file_comment_length}s", "File comment")
 
+    def updateParent(self, chunk):
+        desc = "Central directory: %s" % self["filename"]
+        chunk.description = desc
+        self.setDescription(desc)
+
 class ZipEndCentralDirectory(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "zip_end_dir", "ZIP end central directory", stream, parent)
@@ -78,6 +83,11 @@
             self.read("file_crc32", "<L", "Checksum (CRC32)")
             self.read("file_compressed_size", "<L", "Compressed size (bytes)")
             self.read("file_uncompressed_size", "<L", "Uncompressed size (bytes)")
+
+    def updateParent(self, chunk):
+        desc = "File entry: %s" % self["filename"]
+        chunk.description = desc
+        self.setDescription(desc)
         
 class ZipFile(Filter):
     def __init__(self, stream, parent):



From haypo at berlios.de  Tue Dec 13 18:20:59 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 13 Dec 2005 18:20:59 +0100
Subject: [Happyboom-svn] r325 - haypo/hachoir/plugins
Message-ID: <200512131720.jBDHKxG5008080@sheep.berlios.de>

Author: haypo
Date: 2005-12-13 18:20:58 +0100 (Tue, 13 Dec 2005)
New Revision: 325

Modified:
   haypo/hachoir/plugins/mp3.py
Log:
Fucking &nbsp; !


Modified: haypo/hachoir/plugins/mp3.py
===================================================================
--- haypo/hachoir/plugins/mp3.py	2005-12-13 00:54:19 UTC (rev 324)
+++ haypo/hachoir/plugins/mp3.py	2005-12-13 17:20:58 UTC (rev 325)
@@ -118,7 +118,7 @@
 
             # MPEG2 / MPEG2.5, layer III
             1: {
-                1: 8,  #?8
+                1: 8, # 8
                 2: 16, # 16
                 3: 24, # 24
                 4: 32, # 32
@@ -131,7 +131,7 @@
                 11: 112, # 112
                 12: 128, # 128
                 13: 256, # 144 
-                14: 320} #?160
+                14: 320} # 160
         }
     }
     sampling_rate = {



From haypo at berlios.de  Tue Dec 13 21:59:32 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 13 Dec 2005 21:59:32 +0100
Subject: [Happyboom-svn] r326 - in haypo/hachoir: . plugins
Message-ID: <200512132059.jBDKxWeg030583@sheep.berlios.de>

Author: haypo
Date: 2005-12-13 21:59:32 +0100 (Tue, 13 Dec 2005)
New Revision: 326

Added:
   haypo/hachoir/plugins/mbr.py
Modified:
   haypo/hachoir/mime.py
Log:
Add MBR plugin.


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-13 17:20:58 UTC (rev 325)
+++ haypo/hachoir/mime.py	2005-12-13 20:59:32 UTC (rev 326)
@@ -73,6 +73,14 @@
         return "application/pdf"
     if buffer[:14] == "gimp xcf file\0":
         return "image/x-xcf"
+    if 512<=len(buffer) \
+    and buffer[0]=="\xEB" \
+    and buffer[510:512] == "\x55\xAA" \
+    and buffer[446] in "\x00\x80" \
+    and buffer[446+16*1] in "\x00\x80" \
+    and buffer[446+16*2] in "\x00\x80" \
+    and buffer[446+16*3] in "\x00\x80":
+        return "hachoir/master-boot-record"
     return None        
 
 def splitMimes(mimes):
@@ -86,9 +94,6 @@
     - "application/x-archive application/x-debian-package"
     """
 
-
-    #mimes = map(string.strip, mimes.split(","))
-    
     regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
     mimes = regex.findall(mimes)    
     

Added: haypo/hachoir/plugins/mbr.py
===================================================================
--- haypo/hachoir/plugins/mbr.py	2005-12-13 17:20:58 UTC (rev 325)
+++ haypo/hachoir/plugins/mbr.py	2005-12-13 20:59:32 UTC (rev 326)
@@ -0,0 +1,63 @@
+"""
+Master Boot Record.
+
+
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class PartitionEntry(Filter):
+    system_name = {
+        0x00: "Unused",
+        0x05: "Extended",
+        0x06: "FAT16",
+        0x0E: "FAT16",
+        0x0B: "FAT32",
+        0x0C: "FAT32",
+        0x82: "Linux swap",
+        0x83: "Linux"
+    }
+    
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "default", "Default filter", stream, parent)
+        bootable = self.read("bootable", "B", "Bootable flag (true if equals to 0x80)").value
+        assert bootable in (0x00, 0x80)
+        self.read("start_head", "B", "Starting head number of the partition")
+        self.read("start_sector", "B", "Starting sector number of the partition")
+        self.read("start_low_cylinder", "B", "Lower 8 bits of starting cylinder number of the partition")
+        self.read("system", "B", "System indicator", post=self.postSystem)
+        self.read("end_head", "B", "Ending head number of the partition")
+        self.read("end_sector", "B", "Ending sector number of the partition")
+        self.read("end_low_cylinder", "B", "Lower 8 bits of ending cylinder number of the partition")
+        self.read("sector_before", "<L", "Number of sectors before this partition")
+        self.read("sector_after", "<L", "Number of sectors in this partition")
+        assert self.getSize() == 16
+
+    def updateParent(self, parent):
+        desc = "Partition entry (%s)" % self.type
+        parent.description = desc
+        self.setDescription(desc)        
+
+    def postSystem(self, chunk):
+        type = chunk.value
+        self.type = PartitionEntry.system_name.get(type, "Unknow (%02X)" % type)
+        return self.type      
+
+class MasterBootRecordFilter(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "default", "Default filter", stream, parent)
+        assert 512<=stream.getSize()
+        jmp = self.read("jmp", "!1B", "Long jump (x86 assembler: EA)").value
+        assert jmp == 0xEB
+        self.read("to", "<H", "(Jump to) address")
+        size = 446 - stream.tell()
+        self.read("data", "%us" % size, "Raw data")
+        self.readChild("partition[]", PartitionEntry)
+        self.readChild("partition[]", PartitionEntry)
+        self.readChild("partition[]", PartitionEntry)
+        self.readChild("partition[]", PartitionEntry)
+        id = self.read("id", "<H", "Identifier (0xAA55)").value
+        assert id == 0xAA55
+
+registerPlugin(MasterBootRecordFilter, "hachoir/master-boot-record")



From haypo at berlios.de  Tue Dec 13 22:39:46 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 13 Dec 2005 22:39:46 +0100
Subject: [Happyboom-svn] r327 - in haypo/hachoir: . plugins
Message-ID: <200512132139.jBDLdkRH002230@sheep.berlios.de>

Author: haypo
Date: 2005-12-13 22:39:45 +0100 (Tue, 13 Dec 2005)
New Revision: 327

Modified:
   haypo/hachoir/mime.py
   haypo/hachoir/plugins/mbr.py
Log:
Fix MBR recognition, and PartitionEntry can read it's size in MB.


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-13 20:59:32 UTC (rev 326)
+++ haypo/hachoir/mime.py	2005-12-13 21:39:45 UTC (rev 327)
@@ -74,7 +74,7 @@
     if buffer[:14] == "gimp xcf file\0":
         return "image/x-xcf"
     if 512<=len(buffer) \
-    and buffer[0]=="\xEB" \
+    and buffer[0] in "\xEB\xFA" \
     and buffer[510:512] == "\x55\xAA" \
     and buffer[446] in "\x00\x80" \
     and buffer[446+16*1] in "\x00\x80" \

Modified: haypo/hachoir/plugins/mbr.py
===================================================================
--- haypo/hachoir/plugins/mbr.py	2005-12-13 20:59:32 UTC (rev 326)
+++ haypo/hachoir/plugins/mbr.py	2005-12-13 21:39:45 UTC (rev 327)
@@ -30,12 +30,14 @@
         self.read("end_head", "B", "Ending head number of the partition")
         self.read("end_sector", "B", "Ending sector number of the partition")
         self.read("end_low_cylinder", "B", "Lower 8 bits of ending cylinder number of the partition")
-        self.read("sector_before", "<L", "Number of sectors before this partition")
-        self.read("sector_after", "<L", "Number of sectors in this partition")
-        assert self.getSize() == 16
+        self.read("LBA", "<L", "LBA (number of sectors before this partition)")
+        self.read("size", "<L", "Size")
 
     def updateParent(self, parent):
-        desc = "Partition entry (%s)" % self.type
+        block_size = self.getParent().block_size
+        size_mb = self["size"] / ((1 << 20) / block_size)
+
+        desc = "Partition entry (type %s, %u MB)" % (self.type, size_mb)
         parent.description = desc
         self.setDescription(desc)        
 
@@ -47,10 +49,11 @@
 class MasterBootRecordFilter(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "default", "Default filter", stream, parent)
+        # TODO: Get right block size!
+        self.block_size = 512
         assert 512<=stream.getSize()
-        jmp = self.read("jmp", "!1B", "Long jump (x86 assembler: EA)").value
-        assert jmp == 0xEB
-        self.read("to", "<H", "(Jump to) address")
+        jmp = self.read("jmp", "B", "Jump instruction").value
+        assert jmp in (0xEB, 0xFA)
         size = 446 - stream.tell()
         self.read("data", "%us" % size, "Raw data")
         self.readChild("partition[]", PartitionEntry)



From haypo at berlios.de  Thu Dec 15 02:08:48 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 15 Dec 2005 02:08:48 +0100
Subject: [Happyboom-svn] r328 - in haypo/hachoir: . plugins
Message-ID: <200512150108.jBF18mhN004990@sheep.berlios.de>

Author: haypo
Date: 2005-12-15 02:08:03 +0100 (Thu, 15 Dec 2005)
New Revision: 328

Added:
   haypo/hachoir/plugins/ext2.py
Modified:
   haypo/hachoir/format.py
   haypo/hachoir/mime.py
   haypo/hachoir/tools.py
Log:
Add EXT2 parser. Supports FormatChunk of type 'signed 16 bits'. humanDuration
can returns number of hours and days too.


Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-13 21:39:45 UTC (rev 327)
+++ haypo/hachoir/format.py	2005-12-15 01:08:03 UTC (rev 328)
@@ -1,7 +1,7 @@
 import re
 
-_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLscfd]$")
-_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLscfd])$")
+_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLhscfd]$")
+_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLhscfd])$")
 
 def checkFormat(format):
     m = _regex_format1.match(format)

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-13 21:39:45 UTC (rev 327)
+++ haypo/hachoir/mime.py	2005-12-15 01:08:03 UTC (rev 328)
@@ -73,6 +73,10 @@
         return "application/pdf"
     if buffer[:14] == "gimp xcf file\0":
         return "image/x-xcf"
+    if 4096<=len(buffer) \
+    and buffer[1080:1082]=="\x53\xEF" \
+    and buffer[1116:1120]=="\x04\x00\x00\x00":
+        return "hachoir/fs-ext2"
     if 512<=len(buffer) \
     and buffer[0] in "\xEB\xFA" \
     and buffer[510:512] == "\x55\xAA" \

Added: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-13 21:39:45 UTC (rev 327)
+++ haypo/hachoir/plugins/ext2.py	2005-12-15 01:08:03 UTC (rev 328)
@@ -0,0 +1,114 @@
+"""
+EXT2 (Linux) file system parser.
+
+Sources:
+- EXT2FS source code -> http://ext2fsd.sourceforge.net/
+"""
+
+from datetime import datetime
+from filter import Filter
+from plugin import registerPlugin
+from tools import humanDuration
+
+class EXT2_SuperBlock(Filter):
+    error_handling = {
+        1: "Continue"
+    }
+    os_name = {
+        0: "Linux",
+        1: "Hurd",
+        2: "Masix",
+        3: "FreeBSD",
+        4: "Lites",
+        5: "WinNT"
+    }
+    
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "ext2", "EXT2 file system", stream, parent)
+        self.read("inodes_count", "<L", "Inodes count")
+        self.read("blocks_count", "<L", "Blocks count")
+        self.read("r_blocks_count", "<L", "Reserved blocks count")
+        self.read("free_blocks_count", "<L", "Free blocks count")
+        self.read("free_inodes_count", "<L", "Free inodes count")
+        self.read("first_data_block", "<L", "First data block")
+        self.read("log_block_size", "<L", "Block size")
+        self.read("log_frag_size", "<L", "Fragment size")
+        self.read("blocks_per_group", "<L", "Blocks per group")
+        self.read("frags_per_group", "<L", "Fragments per group")
+        self.read("inodes_per_group", "<L", "Inodes per group")
+        self.read("mtime", "<L", "Mount time", post=self.getTime)
+        self.read("wtime", "<L", "Write time", post=self.getTime)
+        self.read("mnt_count", "<H", "Mount count")
+        self.read("max_mnt_count", "<h", "Max mount count")
+        id = self.read("magic", ">H", "Magic number (0x53EF)").value
+        assert id == 0x53EF
+
+        self.read("state", "<H", "File system state")
+
+        # Read error handling
+        chunk = self.read("errors", "<H", "")
+        desc = "Behaviour when detecting errors"
+        if chunk.value in EXT2_SuperBlock.error_handling:
+            desc = "%s: %s" % (desc, EXT2_SuperBlock.error_handling[chunk.value])
+        chunk.description = desc
+        
+        self.read("minor_rev_level", "<H", "Minor revision level")
+        self.read("last_check", "<L", "Time of last check", post=self.getTime)
+        self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
+        
+        chunk = self.read("creator_os", "<L", "")
+        desc = "Creator OS"
+        if chunk.value in EXT2_SuperBlock.os_name:
+            desc = "%s: %s" % (desc, EXT2_SuperBlock.os_name[chunk.value])
+        chunk.description = desc
+        
+        self.read("rev_level", "<L", "Revision level")
+        self.read("def_resuid", "<H", "Default uid for reserved blocks")
+        self.read("def_resgid", "<H", "Default guid for reserverd blocks")
+
+        # ---------
+
+        self.read("first_ino", "<L", "First non-reserved inode")
+        self.read("inode_size", "<H", "Size of inode structure")
+        self.read("block_group_nr", "<H", "Block group # of this superblock")
+        self.read("feature_compat", "<L", "Compatible feature set")
+        self.read("feature_incompat", "<L", "Incompatible feature set")
+        self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
+        self.read("uuid", "16s", "128-bit uuid for volume")
+        self.read("volume_name", "16s", "Volume name")
+        self.read("last_mounted", "64s", "Directory where last mounted")
+        self.read("compression", "<L", "For compression (algorithm usage bitmap)")
+        
+        self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
+        self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
+        self.read("padding", "H", "Padding")
+        
+        self.read("journal_uuid", "16s", "uuid of journal superblock")
+        self.read("journal_inum", "<L", "inode number of journal file")
+        self.read("journal_dev", "<L", "device number of journal file")
+        self.read("last_orphan", "<L", "start of list of inodes to delete")
+        
+        self.read("reserved", "197s", "Padding to the end of the block")
+
+    def updateParent(self, chunk):
+        if self["feature_compat"] & 4 == 4:
+            type = "ext3"
+        else:
+            type = "ext2"
+        desc = "EXT2 Superblock: %s file system" % type
+        self.setDescription(desc)
+        chunk.description = desc
+
+    def postMaxTime(self, chunk):
+        return humanDuration(chunk.value * 1000)
+
+    def getTime(self, chunk):
+        return datetime.fromtimestamp(chunk.value)
+
+class EXT2_FS(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "ext2", "EXT2 file system", stream, parent)
+        self.read("raw[]", "1024s", "Raw data")
+        self.readChild("superblock", EXT2_SuperBlock)
+
+registerPlugin(EXT2_FS, "hachoir/fs-ext2")

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-12-13 21:39:45 UTC (rev 327)
+++ haypo/hachoir/tools.py	2005-12-15 01:08:03 UTC (rev 328)
@@ -89,15 +89,35 @@
     return size 
 
 def humanDuration(ms):
+    # Milliseconds
     if ms < 1000:
         return "%u ms" % ms
+        
+    # Seconds
     sec = ms/1000
     ms = ms%1000
     if sec < 60:
         return  "%u sec" % sec
+
+    #?Minutes
     min = sec/60
     sec = sec%60
-    text = "%u min %u sec" % (min, sec)
+    if min<60:
+        text = "%u min %u sec" % (min, sec)
+
+    # Hours
+    hour = min/60
+    min = min/60
+    if hour < 24:
+        text = "%u hour(s) %u min" % (hour, min)
+
+    # Days
+    day = hour/24
+    hour = hour%24
+    if hour != 0:
+        text = "%u day(s) %u hour(s)" % (day, hour)    
+    else:
+        text = "%u day(s)" % (day)
     return text
 
 def humanFilesize(size):



From haypo at berlios.de  Thu Dec 15 16:06:05 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 15 Dec 2005 16:06:05 +0100
Subject: [Happyboom-svn] r329 - haypo/hachoir/stream
Message-ID: <200512151506.jBFF65YR002361@sheep.berlios.de>

Author: haypo
Date: 2005-12-15 16:06:05 +0100 (Thu, 15 Dec 2005)
New Revision: 329

Modified:
   haypo/hachoir/stream/file.py
Log:
Fix file cache.


Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-12-15 01:08:03 UTC (rev 328)
+++ haypo/hachoir/stream/file.py	2005-12-15 15:06:05 UTC (rev 329)
@@ -6,34 +6,41 @@
     def __init__(self, index, data):
         self.index = index
         self.data = data
+        self.used = 0
 
+    def __cmp__(self, to):
+        return cmp(self.used, to.used)
+
 class FileCache:
-    def __init__(self, file, file_size):
+    def __init__(self, file, file_size, block_size=4096, block_count=100):
         self.file = file
         self.file_size = file_size
-        self.block_size = 4096
-        self.max_block = 100
+        self.block_size = block_size
+        self.max_block = block_count
         self.blocks = {}
 
+    def removeOldestBlock(self):
+        entry = min(self.blocks.values())
+        del self.blocks[entry.index]
+
     def read(self, position, length):
         block_position = position % self.block_size
         block_index = position / self.block_size
         length_copy = length
         assert position+length <= self.file_size
         
-        # TODO: Be able to read two or more blocks
         data = ""
         while 0 < length:
             if block_index not in self.blocks:
                 if self.max_block <= len(self.blocks):
-                    # TODO: Remove oldest block
-                    pass
+                    self.removeOldestBlock()
                 self.file.seek(block_index * self.block_size)
                 block_data = self.file.read(self.block_size)
                 assert (len(block_data) == self.block_size) or self.file.tell() == self.file_size
-                self.blocks[block_index] = block_data
+                self.blocks[block_index] = FileCacheEntry(block_index, block_data)
             else:
-                block_data = self.blocks[block_index]
+                block_data = self.blocks[block_index].data
+            self.blocks[block_index].used = self.blocks[block_index].used + 1
             if block_position != 0 or length != self.block_size:
                 end = block_position+length
                 if self.block_size < end:
@@ -47,7 +54,7 @@
         return data
 
 class FileStream(Stream):
-    def __init__(self, file, filename=None, copy=None):
+    def __init__(self, file, filename=None, copy=None, use_cache=True):
         """
         Endian: See setEndian function. 
         """
@@ -68,18 +75,22 @@
                 self._end = self._size-1
             else:
                 self._end = 0
-            self._cache = FileCache(self._file, self._size)
+            if use_cache:
+                self._cache = FileCache(self._file, self._size, 4096, 10)
+            else:
+                self._cache = None
 
     def getType(self):
         return "%s (%s)" % \
             (self.__class__.__name__, self.filename)
         
     def read(self, size, seek=True):
-        data = self._cache.read(self._seed, size)
-#        self._file.seek(self._seed) ; data = self._file.read(size)
+        if self._cache != None:
+            data = self._cache.read(self._seed, size)
+        else:
+            self._file.seek(self._seed) ; data = self._file.read(size)
         if seek:
             self._seed = self._seed + len(data)
-#            assert self._seed == self._file.tell()
         return data            
 
     def clone(self):
@@ -87,27 +98,28 @@
 
     def seek(self, pos, where=0):
         """ Read file seek document to understand where. """
-        #?TODO: Don't really seek
         if where==0:
             self._seed = pos
         elif where==1:
             self._seed = self._seed + pos
         else:
             self._seed = self._size - pos
-        if self._size < self._seed:
+        if self._seed < 0 or self._size < self._seed:
             raise StreamError("Error when seek to (%s,%s) in a stream." % (pos, where))
 
     def tell(self):
         return self._seed
 
     def getN(self, size, seek=True):
-        data = self._cache.read(self._seed, size)
-#        self._file.seek(self._seed) ; data = self._file.read(size)
-#        if len(data) != size:
-#            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
+        if self._cache != None:
+            data = self._cache.read(self._seed, size)
+        else:
+            self._file.seek(self._seed)
+            data = self._file.read(size)
+        if len(data) != size:
+            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
         if seek:
             self._seed = self._seed + size
-#            assert self._seed == self._file.tell()
         return data
 
     def getSize(self):



From haypo at berlios.de  Thu Dec 15 17:15:14 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 15 Dec 2005 17:15:14 +0100
Subject: [Happyboom-svn] r330 - in haypo/hachoir: . plugins
Message-ID: <200512151615.jBFGFETY010222@sheep.berlios.de>

Author: haypo
Date: 2005-12-15 17:15:13 +0100 (Thu, 15 Dec 2005)
New Revision: 330

Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/ext2.py
Log:
EXT2 can read groups.


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-15 15:06:05 UTC (rev 329)
+++ haypo/hachoir/filter.py	2005-12-15 16:15:13 UTC (rev 330)
@@ -83,7 +83,7 @@
         if root in self._chunk_counter:
             self._chunk_counter[root] = self._chunk_counter[root]+1
         else:
-            self._chunk_counter[root] = 0
+            self._chunk_counter[root] = index
         return pattern % (root, self._chunk_counter[root])
 
     def getUniqChunkId(self, id):

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-15 15:06:05 UTC (rev 329)
+++ haypo/hachoir/plugins/ext2.py	2005-12-15 16:15:13 UTC (rev 330)
@@ -10,6 +10,18 @@
 from plugin import registerPlugin
 from tools import humanDuration
 
+class EXT2_Group(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "group", "EXT2 group", stream, parent)
+        self.read("block_bitmap", "<L", "Points to the blocks bitmap block")
+        self.read("inode_bitmap", "<L", "Points to the inodes bitmap block")
+        self.read("inode_table", "<L", "Points to the inodes table first block")
+        self.read("free_blocks_count", "<H", "Number of free blocks")
+        self.read("free_inodes_count", "<H", "Number of free inodes")
+        self.read("used_dirs_count", "<H", "Number of inodes allocated to directories")
+        self.read("padding", "<H", "Padding")
+        self.read("reserved", "12s", "Reserved")
+
 class EXT2_SuperBlock(Filter):
     error_handling = {
         1: "Continue"
@@ -22,9 +34,13 @@
         4: "Lites",
         5: "WinNT"
     }
+    state = {
+        1: "Valid",
+        2: "Error"
+    }
     
     def __init__(self, stream, parent):
-        Filter.__init__(self, "ext2", "EXT2 file system", stream, parent)
+        Filter.__init__(self, "super_block", "EXT2 super block", stream, parent)
         self.read("inodes_count", "<L", "Inodes count")
         self.read("blocks_count", "<L", "Blocks count")
         self.read("r_blocks_count", "<L", "Reserved blocks count")
@@ -43,7 +59,10 @@
         id = self.read("magic", ">H", "Magic number (0x53EF)").value
         assert id == 0x53EF
 
-        self.read("state", "<H", "File system state")
+        # Read state
+        chunk = self.read("state", "<H", "File system state")
+        chunk.description = "Behaviour when detecting errors: %s" % \
+            EXT2_SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
 
         # Read error handling
         chunk = self.read("errors", "<H", "")
@@ -110,5 +129,9 @@
         Filter.__init__(self, "ext2", "EXT2 file system", stream, parent)
         self.read("raw[]", "1024s", "Raw data")
         self.readChild("superblock", EXT2_SuperBlock)
+        size = 4096 - stream.tell()
+        self.read("raw[]", "%us" % size, "Raw data")
+        for i in range(0,71):
+            self.readChild("group[]", EXT2_Group)
 
 registerPlugin(EXT2_FS, "hachoir/fs-ext2")



From haypo at berlios.de  Thu Dec 15 22:41:40 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 15 Dec 2005 22:41:40 +0100
Subject: [Happyboom-svn] r331 - in haypo/hachoir: . plugins ui
Message-ID: <200512152141.jBFLfeDA027990@sheep.berlios.de>

Author: haypo
Date: 2005-12-15 22:41:39 +0100 (Thu, 15 Dec 2005)
New Revision: 331

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/plugins/ext2.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui/ui_window.py
Log:
Remove chunk size limit, and EXT2 plugin is able to read root directory ;-)

- EXT2 can read Bitmap and DirectoryEntry.
- Add getUnixRWX function in tools module (Unix access rigths).
- Fix in FormatChunk to support long size (don't use calcsize directly).
- UI can display long addresses and sizes.
- UI display address in hexadecimal content.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-15 16:15:13 UTC (rev 330)
+++ haypo/hachoir/chunk.py	2005-12-15 21:41:39 UTC (rev 331)
@@ -278,7 +278,12 @@
             self._orig_format = self._chunk.getFormat()
             self._format = self._chunk.getRealFormat(self._orig_format)
             self._addr = self._chunk.addr
-            self._size = struct.calcsize(self._format)
+            endian, count, type = splitFormat(self._format)
+            if count != "":
+                count = int(count)
+            else:
+                count = 1
+            self._size = count * struct.calcsize(type)
 
     def getSize(self):
         self.update()

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-15 16:15:13 UTC (rev 330)
+++ haypo/hachoir/plugins/ext2.py	2005-12-15 21:41:39 UTC (rev 331)
@@ -2,14 +2,169 @@
 EXT2 (Linux) file system parser.
 
 Sources:
-- EXT2FS source code -> http://ext2fsd.sourceforge.net/
+- EXT2FS source code
+  http://ext2fsd.sourceforge.net/
+- Analysis of the Ext2fs structure
+  http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
 """
 
 from datetime import datetime
 from filter import Filter
 from plugin import registerPlugin
-from tools import humanDuration
+from tools import humanDuration, getUnixRWX 
 
+class DirectoryEntry(Filter):
+    file_type = {
+        1: "Regular",
+        2: "Directory",
+        3: "Char. dev.",
+        4: "Block dev.",
+        5: "Fifo",
+        6: "Socket",
+        7: "Symlink",
+        8: "Max"
+    }
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "dir", "EXT2 directory", stream, parent)
+        self.read("inode", "<L", "Inode")
+        self.read("rec_len", "<H", "Record length")
+        name_length = self.read("name_len", "B", "Name length").value
+        self.read("file_type", "B", "File type", post=self.postFileType)
+        self.read("name", "%us" % name_length, "Name")
+        size = self["rec_len"]-8-name_length
+        if size != 0:
+            self.read("padding", "%us" % size, "Padding")
+
+    def updateParent(self, chunk):        
+        name = self["name"].strip("\0")
+        if name != "":
+            desc = "Directory entry: %s" % name
+        else:
+            desc = "Directory entry (empty)"
+        chunk.description = desc
+        self.setDescription(desc)
+
+    def postFileType(self, chunk):
+        type = chunk.value
+        return DirectoryEntry.file_type.get(type, "Unknow (%02X)" % type)
+
+class Inode(Filter):
+    name = {
+        1: "list of bad blocks",
+        2: "Root directory",
+        3: "ACL inode",
+        4: "ACL inode",
+        5: "Boot loader",
+        6: "Undelete directory",
+        8: "EXT3 journal"
+    }
+    
+    def __init__(self, stream, parent, index):
+        Filter.__init__(self, "inode", "EXT2 inode", stream, parent)
+        self.index = index
+        self.read("mode", "<H", "Mode", post=self.postMode)
+        self.read("uid", "<H", "User ID")
+        self.read("size", "<L", "File size")
+        self.read("atime", "<L", "Last access time", post=self.getTime)
+        self.read("ctime", "<L", "Creation time", post=self.getTime)
+        self.read("mtime", "<L", "Last modification time", post=self.getTime)
+        self.read("dtime", "<L", "Delete time", post=self.getTime)
+        self.read("gid", "<H", "Group ID")
+        self.read("links_count", "<H", "Links count")
+        self.read("blocks", "<L", "Number of blocks")
+        self.read("flags", "<L", "Flags")
+        self.read("reserved1", "<L", "Reserved")
+        for i in range(0,15):
+            self.read("block[]", "<L", "Block %i" % i)
+        self.read("version", "<L", "Version")
+        self.read("file_acl", "<L", "File ACL")
+        self.read("dir_acl", "<L", "Directory ACL")
+        self.read("faddr", "<L", "Block where the fragment of the file resides")
+        os = parent.superblock["creator_os"]
+        if os == SuperBlock.OS_LINUX:
+            self.read("frag", "B", "Number of fragments in the block")
+            self.read("fsize", "B", "Fragment size")
+            self.read("padding", "<H", "Padding")
+            self.read("uid_high", "<H", "High 16 bits of user ID")
+            self.read("gid_high", "<H", "High 16 bits of group ID")
+            self.read("reserved", "<L", "Reserved")
+        elif os == SuperBlock.OS_HURD:
+            self.read("frag", "B", "Number of fragments in the block")
+            self.read("fsize", "B", "Fragment size")
+            self.read("mode_high", "<H", "High 16 bits of mode")
+            self.read("uid_high", "<H", "High 16 bits of user ID")
+            self.read("gid_high", "<H", "High 16 bits of group ID")
+            self.read("author", "<L", "Author ID (?)")
+        else:
+            self.read("raw", "12s", "Reserved")
+
+    def updateParent(self, chunk):
+        desc = "Inode %s: " % self.index
+        size = self["size"]
+        if 11 <= self.index:
+            desc = desc + "file, size=%s, mode=%s" % (size, self.getChunk("mode").display)
+        else:
+            if self.index in Inode.name:
+                desc = desc + Inode.name[self.index]
+                if self.index == 2:
+                    desc = desc + " (%s)" % getUnixRWX(self["mode"])
+            else:
+                desc = desc + "special"
+            if size == 0:
+                desc = desc + " (unused)"
+        chunk.description = desc
+        self.setDescription(desc)
+
+    def postMode(self, chunk):
+        mode = chunk.value
+        text = ""
+        if mode & 0100000 != 0:
+            text = "regular (%s)" % getUnixRWX(mode)
+        elif mode & 0040000:
+            text = "directory (%s)" % getUnixRWX(mode)
+        elif mode & 0020000:
+            text = "char. dev."
+        elif mode & 0060000:
+            text = "block dev."
+        elif mode & 0010000:
+            text = "fifo"
+        elif mode & 0120000:
+            text = "sym. link"
+        elif mode & 0140000:
+            text = "socket"
+        elif mode == 0:
+            text = "(empty)"
+        else:
+            text = "???"
+        return text
+
+    def getTime(self, chunk):
+        if chunk.value != 0:
+            return datetime.fromtimestamp(chunk.value)
+        else:
+            return "(empty)"
+
+class Bitmap(Filter):
+    def __init__(self, stream, parent, size, start):
+        Filter.__init__(self, "group", "EXT2 group", stream, parent)
+        self.start = start
+        self.read("block_bitmap", "%us" % size, "Bitmap")
+
+    def showFree(self, type="Block"):
+        data = self["block_bitmap"]
+        cpt = self.start
+        for octet in data:
+            octet = ord(octet)
+            mask = 1
+            for i in range(0,8):
+                if octet & mask == 0:
+                    print "%s %s free." % (type, cpt)
+                cpt = cpt + 1
+                mask = mask << 1
+
+BlockBitmap = Bitmap
+InodeBitmap = Bitmap
+
 class EXT2_Group(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "group", "EXT2 group", stream, parent)
@@ -22,10 +177,12 @@
         self.read("padding", "<H", "Padding")
         self.read("reserved", "12s", "Reserved")
 
-class EXT2_SuperBlock(Filter):
+class SuperBlock(Filter):
     error_handling = {
         1: "Continue"
     }
+    OS_LINUX = 0
+    OS_HURD = 1
     os_name = {
         0: "Linux",
         1: "Hurd",
@@ -46,75 +203,85 @@
         self.read("r_blocks_count", "<L", "Reserved blocks count")
         self.read("free_blocks_count", "<L", "Free blocks count")
         self.read("free_inodes_count", "<L", "Free inodes count")
-        self.read("first_data_block", "<L", "First data block")
-        self.read("log_block_size", "<L", "Block size")
-        self.read("log_frag_size", "<L", "Fragment size")
-        self.read("blocks_per_group", "<L", "Blocks per group")
-        self.read("frags_per_group", "<L", "Fragments per group")
-        self.read("inodes_per_group", "<L", "Inodes per group")
-        self.read("mtime", "<L", "Mount time", post=self.getTime)
-        self.read("wtime", "<L", "Write time", post=self.getTime)
-        self.read("mnt_count", "<H", "Mount count")
-        self.read("max_mnt_count", "<h", "Max mount count")
-        id = self.read("magic", ">H", "Magic number (0x53EF)").value
-        assert id == 0x53EF
+        first = self.read("first_data_block", "<L", "First data block").value
+        self.is_superblock = (first == 0)
+        if self.is_superblock:
+            self.read("log_block_size", "<L", "Block size")
+            self.read("log_frag_size", "<L", "Fragment size")
+            self.read("blocks_per_group", "<L", "Blocks per group")
+            self.read("frags_per_group", "<L", "Fragments per group")
+            self.read("inodes_per_group", "<L", "Inodes per group")
+            self.read("mtime", "<L", "Mount time", post=self.getTime)
+            self.read("wtime", "<L", "Write time", post=self.getTime)
+            self.read("mnt_count", "<H", "Mount count")
+            self.read("max_mnt_count", "<h", "Max mount count")
+            id = self.read("magic", ">H", "Magic number (0x53EF)").value
+            assert id == 0x53EF
 
-        # Read state
-        chunk = self.read("state", "<H", "File system state")
-        chunk.description = "Behaviour when detecting errors: %s" % \
-            EXT2_SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
+            # Read state
+            chunk = self.read("state", "<H", "File system state")
+            chunk.description = "Behaviour when detecting errors: %s" % \
+                SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
 
-        # Read error handling
-        chunk = self.read("errors", "<H", "")
-        desc = "Behaviour when detecting errors"
-        if chunk.value in EXT2_SuperBlock.error_handling:
-            desc = "%s: %s" % (desc, EXT2_SuperBlock.error_handling[chunk.value])
-        chunk.description = desc
-        
-        self.read("minor_rev_level", "<H", "Minor revision level")
-        self.read("last_check", "<L", "Time of last check", post=self.getTime)
-        self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
-        
-        chunk = self.read("creator_os", "<L", "")
-        desc = "Creator OS"
-        if chunk.value in EXT2_SuperBlock.os_name:
-            desc = "%s: %s" % (desc, EXT2_SuperBlock.os_name[chunk.value])
-        chunk.description = desc
-        
-        self.read("rev_level", "<L", "Revision level")
-        self.read("def_resuid", "<H", "Default uid for reserved blocks")
-        self.read("def_resgid", "<H", "Default guid for reserverd blocks")
+            # Read error handling
+            chunk = self.read("errors", "<H", "")
+            desc = "Behaviour when detecting errors"
+            if chunk.value in SuperBlock.error_handling:
+                desc = "%s: %s" % (desc, SuperBlock.error_handling[chunk.value])
+            chunk.description = desc
+            
+            self.read("minor_rev_level", "<H", "Minor revision level")
+            self.read("last_check", "<L", "Time of last check", post=self.getTime)
+            self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
+            
+            chunk = self.read("creator_os", "<L", "")
+            desc = "Creator OS"
+            if chunk.value in SuperBlock.os_name:
+                desc = "%s: %s" % (desc, SuperBlock.os_name[chunk.value])
+            chunk.description = desc
+            
+            self.read("rev_level", "<L", "Revision level")
+            self.read("def_resuid", "<H", "Default uid for reserved blocks")
+            self.read("def_resgid", "<H", "Default guid for reserverd blocks")
 
-        # ---------
+            # ---------
 
-        self.read("first_ino", "<L", "First non-reserved inode")
-        self.read("inode_size", "<H", "Size of inode structure")
-        self.read("block_group_nr", "<H", "Block group # of this superblock")
-        self.read("feature_compat", "<L", "Compatible feature set")
-        self.read("feature_incompat", "<L", "Incompatible feature set")
-        self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
-        self.read("uuid", "16s", "128-bit uuid for volume")
-        self.read("volume_name", "16s", "Volume name")
-        self.read("last_mounted", "64s", "Directory where last mounted")
-        self.read("compression", "<L", "For compression (algorithm usage bitmap)")
-        
-        self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
-        self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
-        self.read("padding", "H", "Padding")
-        
-        self.read("journal_uuid", "16s", "uuid of journal superblock")
-        self.read("journal_inum", "<L", "inode number of journal file")
-        self.read("journal_dev", "<L", "device number of journal file")
-        self.read("last_orphan", "<L", "start of list of inodes to delete")
-        
-        self.read("reserved", "197s", "Padding to the end of the block")
+            self.read("first_ino", "<L", "First non-reserved inode")
+            inode_size = self.read("inode_size", "<H", "Size of inode structure").value
+            assert inode_size == (68 + 15*4)
+            self.read("block_group_nr", "<H", "Block group # of this superblock")
+            self.read("feature_compat", "<L", "Compatible feature set")
+            self.read("feature_incompat", "<L", "Incompatible feature set")
+            self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
+            self.read("uuid", "16s", "128-bit uuid for volume")
+            self.read("volume_name", "16s", "Volume name")
+            self.read("last_mounted", "64s", "Directory where last mounted")
+            self.read("compression", "<L", "For compression (algorithm usage bitmap)")
+            
+            self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
+            self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
+            self.read("padding", "H", "Padding")
+            
+            self.read("journal_uuid", "16s", "uuid of journal superblock")
+            self.read("journal_inum", "<L", "inode number of journal file")
+            self.read("journal_dev", "<L", "device number of journal file")
+            self.read("last_orphan", "<L", "start of list of inodes to delete")
+            
+            self.read("reserved", "197s", "Padding to the end of the block")
+        else:        
+            self.read("padding", "197s", "Padding to the end of the block")
 
     def updateParent(self, chunk):
-        if self["feature_compat"] & 4 == 4:
-            type = "ext3"
+        if self.is_superblock:
+            blocks_per_group = self["blocks_per_group"]
+            self.group_count = (self["blocks_count"] - self["first_data_block"] + blocks_per_group - 1) / blocks_per_group
+            if self["feature_compat"] & 4 == 4:
+                type = "ext3"
+            else:
+                type = "ext2"
+            desc = "EXT2 Superblock: %s file system" % type
         else:
-            type = "ext2"
-        desc = "EXT2 Superblock: %s file system" % type
+            desc = "EXT2 block #%s" % self["first_data_block"]
         self.setDescription(desc)
         chunk.description = desc
 
@@ -127,11 +294,68 @@
 class EXT2_FS(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "ext2", "EXT2 file system", stream, parent)
-        self.read("raw[]", "1024s", "Raw data")
-        self.readChild("superblock", EXT2_SuperBlock)
-        size = 4096 - stream.tell()
-        self.read("raw[]", "%us" % size, "Raw data")
-        for i in range(0,71):
-            self.readChild("group[]", EXT2_Group)
+        
+        # Read superblock
+        self.seek(1024) 
+        self.superblock = self.readChild("superblock", SuperBlock).getFilter()
+        self.block_size = 1024 << self.superblock["log_block_size"]
 
+        # Read groups
+        self.seek(4096) 
+        groups = []
+        for i in range(0,self.superblock.group_count):
+            group = self.readChild("group[]", EXT2_Group).getFilter()
+            groups.append(group)
+        group = groups[0]
+        
+        # Read block bitmap
+        self.seek(group["block_bitmap"] * self.block_size)
+        count = 32768
+        self.readChild("block_bitmap[]", BlockBitmap, count / 8, 0)
+
+        # Read inode bitmap
+        assert (group["inode_bitmap"] * self.block_size) == stream.tell()
+        count = 32768
+        self.readChild("inode_bitmap[]", InodeBitmap, count / 8, 1)
+
+        root_inode = 2
+        for index in range(1,20):
+            inode = self.readChild("inode[]", Inode, index).getFilter()
+            if index == root_inode:
+                root = inode
+
+        self.readDirectory(root)
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        print "Seek to %s => %s" % (to, size)
+        assert 0 <= size
+        if 0 < size:
+            self.read("raw[]", "%us" % size, "Raw")
+
+    def readDirectory(self, inode):
+        stream = self.getStream()
+        block_index = 0
+        print "Read Dir."
+        while True:
+            assert block_index < 12
+            block = inode["block[%u]" % block_index]
+            if block == 0:
+                return
+            print "Seek to block %s" % block_index
+            self.seek(block * self.block_size)
+
+            total = 0
+            for i in range(0, 100):
+                entry = self.readChild("directory[]", DirectoryEntry).getFilter()
+                if entry["inode"] == 0:
+                    print "End."            
+                    return
+                total = total + entry.getSize()
+                if self.block_size <= total:
+                    assert total == self.block_size
+                    print "End of block"
+                    break
+            block_index = block_index + 1
+
 registerPlugin(EXT2_FS, "hachoir/fs-ext2")

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-12-15 16:15:13 UTC (rev 330)
+++ haypo/hachoir/tools.py	2005-12-15 21:41:39 UTC (rev 331)
@@ -99,7 +99,7 @@
     if sec < 60:
         return  "%u sec" % sec
 
-    #?Minutes
+    # Minutes
     min = sec/60
     sec = sec%60
     if min<60:
@@ -166,3 +166,16 @@
         return "".join(bt)
     except:
         return "Error while trying to get backtrace"
+
+def getUnixRWX(mode):
+#-- TODO --
+#EXT2_S_ISUID  0x0800  SUID
+#EXT2_S_ISGID  0x0400  SGID
+#EXT2_S_ISVTX  0x0200  sticky bit
+    rwx = ("---", "rwx")
+    text = ""
+    for i in range(0,3):
+        for j in range(0,3):
+            mask = 1 << (3*(2-i)) << (2-j)
+            text = text + rwx[int(mode & mask == mask)][j]
+    return text

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-15 16:15:13 UTC (rev 330)
+++ haypo/hachoir/ui/ui_window.py	2005-12-15 21:41:39 UTC (rev 331)
@@ -141,6 +141,8 @@
         return self.table_store.append(parent, (addr, format, size, None, id, description, None,))
        
     def add_table(self, parent, addr, size, format, id, description, value):
+        addr = str(addr)
+        size = str(size)
         self.table_store.append(parent, (addr, format, size, id, value, description, ))
 
     def onKeyUp(self, widget, key, data=None):
@@ -165,7 +167,7 @@
         self.info.updateChunk(chunk)
 
     def build_table(self):
-        self.table_store = gtk.TreeStore(int, str, int, str, str, str)
+        self.table_store = gtk.TreeStore(str, str, str, str, str, str)
         self.table.set_model(self.table_store)
         self.table.connect("button_release_event", self.onTableClick)
         self.table.connect("row-activated", self.onTableRowActivate)
@@ -289,10 +291,12 @@
         # TODO: Use better str=>hexa function ...
         content = ""
         wrap = 16
+        addr = 0
         while len(raw) != 0:
             if len(content) != 0:
                 content = content + "\n"
-            content = content + " ".join([ "%02X" % ord(i) for i in raw[:wrap] ])
+            content = content + "% 4s: " % addr + " ".join([ "%02X" % ord(i) for i in raw[:wrap] ])
+            addr = addr + wrap
             raw = raw[wrap:]
         if config.max_hexa_length < chunk.size:
             if len(content) != 0:



From haypo at berlios.de  Thu Dec 15 22:51:50 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 15 Dec 2005 22:51:50 +0100
Subject: [Happyboom-svn] r332 - haypo/hachoir/plugins
Message-ID: <200512152151.jBFLpo8f029704@sheep.berlios.de>

Author: haypo
Date: 2005-12-15 22:51:50 +0100 (Thu, 15 Dec 2005)
New Revision: 332

Modified:
   haypo/hachoir/plugins/ext2.py
Log:
Clean EXT2 plugin code.


Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-15 21:41:39 UTC (rev 331)
+++ haypo/hachoir/plugins/ext2.py	2005-12-15 21:51:50 UTC (rev 332)
@@ -25,7 +25,7 @@
         8: "Max"
     }
     def __init__(self, stream, parent):
-        Filter.__init__(self, "dir", "EXT2 directory", stream, parent)
+        Filter.__init__(self, "dir", "EXT2 directory entry", stream, parent)
         self.read("inode", "<L", "Inode")
         self.read("rec_len", "<H", "Record length")
         name_length = self.read("name_len", "B", "Name length").value
@@ -80,7 +80,7 @@
         self.read("file_acl", "<L", "File ACL")
         self.read("dir_acl", "<L", "Directory ACL")
         self.read("faddr", "<L", "Block where the fragment of the file resides")
-        os = parent.superblock["creator_os"]
+        os = parent.getParent().superblock["creator_os"]
         if os == SuperBlock.OS_LINUX:
             self.read("frag", "B", "Number of fragments in the block")
             self.read("fsize", "B", "Fragment size")
@@ -291,6 +291,33 @@
     def getTime(self, chunk):
         return datetime.fromtimestamp(chunk.value)
 
+class Groups(Filter):
+    def __init__(self, stream, parent, count):
+        Filter.__init__(self, "groups", "EXT2 groups", stream, parent)
+        self.items = []
+        for i in range(0, count):
+            group = self.readChild("group[]", EXT2_Group).getFilter()
+            self.items.append(group)
+
+    def __getitem__(self, index):
+        return self.items[index]
+
+class InodeTable(Filter):
+    def __init__(self, stream, parent, start, count):
+        Filter.__init__(self, "ino_table", "EXT2 inode table", stream, parent)
+        self.inodes = {}
+        for index in range(start,start+count):
+            inode = self.readChild("inode[]", Inode, index).getFilter()
+            self.inodes[index] = inode
+
+    def __getitem__(self, index):
+        return self.inodes[index]
+
+#class Directory(Filter):
+#    def __init__(self, stream, parent):
+#        Filter.__init__(self, "dir", "EXT2 directory", stream, parent)
+#        self.read("inode", "<L", "Inode")
+
 class EXT2_FS(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "ext2", "EXT2 file system", stream, parent)
@@ -302,10 +329,7 @@
 
         # Read groups
         self.seek(4096) 
-        groups = []
-        for i in range(0,self.superblock.group_count):
-            group = self.readChild("group[]", EXT2_Group).getFilter()
-            groups.append(group)
+        groups = self.readChild("groups", Groups, self.superblock.group_count).getFilter()
         group = groups[0]
         
         # Read block bitmap
@@ -318,17 +342,14 @@
         count = 32768
         self.readChild("inode_bitmap[]", InodeBitmap, count / 8, 1)
 
-        root_inode = 2
-        for index in range(1,20):
-            inode = self.readChild("inode[]", Inode, index).getFilter()
-            if index == root_inode:
-                root = inode
+        inode_table0 = self.readChild("inode_table[]", InodeTable, 1, 20).getFilter()
 
+        root = inode_table0[2]
+
         self.readDirectory(root)
 
     def seek(self, to):
         size = to - self.getStream().tell()
-        print "Seek to %s => %s" % (to, size)
         assert 0 <= size
         if 0 < size:
             self.read("raw[]", "%us" % size, "Raw")
@@ -336,26 +357,20 @@
     def readDirectory(self, inode):
         stream = self.getStream()
         block_index = 0
-        print "Read Dir."
         while True:
             assert block_index < 12
             block = inode["block[%u]" % block_index]
             if block == 0:
                 return
-            print "Seek to block %s" % block_index
             self.seek(block * self.block_size)
 
             total = 0
-            for i in range(0, 100):
+            while total < self.block_size:
                 entry = self.readChild("directory[]", DirectoryEntry).getFilter()
                 if entry["inode"] == 0:
-                    print "End."            
                     return
                 total = total + entry.getSize()
-                if self.block_size <= total:
-                    assert total == self.block_size
-                    print "End of block"
-                    break
+            assert total == self.block_size
             block_index = block_index + 1
 
 registerPlugin(EXT2_FS, "hachoir/fs-ext2")



From haypo at berlios.de  Fri Dec 16 02:10:52 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 02:10:52 +0100
Subject: [Happyboom-svn] r333 - in haypo/hachoir: . plugins
Message-ID: <200512160110.jBG1Aq8J024728@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 02:10:45 +0100 (Fri, 16 Dec 2005)
New Revision: 333

Added:
   haypo/hachoir/plugins/pcx.py
Modified:
   haypo/hachoir/format.py
   haypo/hachoir/mime.py
   haypo/hachoir/plugins/gzip.py
Log:
Add PCX parser. FormatChunk supports signed 8 bit type ("b"). Clean GZIP plugin code.


Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-15 21:51:50 UTC (rev 332)
+++ haypo/hachoir/format.py	2005-12-16 01:10:45 UTC (rev 333)
@@ -1,7 +1,7 @@
 import re
 
-_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLhscfd]$")
-_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLhscfd])$")
+_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLbhscfd]$")
+_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLbhscfd])$")
 
 def checkFormat(format):
     m = _regex_format1.match(format)

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-15 21:51:50 UTC (rev 332)
+++ haypo/hachoir/mime.py	2005-12-16 01:10:45 UTC (rev 333)
@@ -73,10 +73,17 @@
         return "application/pdf"
     if buffer[:14] == "gimp xcf file\0":
         return "image/x-xcf"
+
+    if buffer[0] == "\x0A" \
+    and buffer[1] in "\x00\x02\x03\x04\x05" \
+    and buffer[64] == "\0":
+        return "image/x-pcx"
+        
     if 4096<=len(buffer) \
     and buffer[1080:1082]=="\x53\xEF" \
     and buffer[1116:1120]=="\x04\x00\x00\x00":
         return "hachoir/fs-ext2"
+        
     if 512<=len(buffer) \
     and buffer[0] in "\xEB\xFA" \
     and buffer[510:512] == "\x55\xAA" \

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-12-15 21:51:50 UTC (rev 332)
+++ haypo/hachoir/plugins/gzip.py	2005-12-16 01:10:45 UTC (rev 333)
@@ -14,26 +14,6 @@
 from default import DefaultFilter
 from tools import getBacktrace
    
-class GunzipFilter(Filter):
-    def __init__(self, stream, parent, start, size, filter_class):
-        # Read data
-        self._parent_stream = stream
-        
-        # Create a new stream
-        stream = GunzipStream(self._parent_stream)
-        self._compressed_size = size 
-        self._decompressed_size = stream.getSize()
-
-        # Create filter
-        self._parent_stream.seek(start)
-        Filter.__init__(self, "deflate", "Deflate", stream, parent)
-        self._addr = self._parent_stream.tell()
-
-        self.readChild("data", filter_class)
-
-    def getSize(self):
-        return self._compressed_size
-
 class GzipFile(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "gzip_file", "GZIP archive file", stream, parent)

Added: haypo/hachoir/plugins/pcx.py
===================================================================
--- haypo/hachoir/plugins/pcx.py	2005-12-15 21:51:50 UTC (rev 332)
+++ haypo/hachoir/plugins/pcx.py	2005-12-16 01:10:45 UTC (rev 333)
@@ -0,0 +1,91 @@
+"""
+PCX picture filter.
+"""
+
+from filter import Filter, DeflateFilter
+from plugin import registerPlugin
+from stream.file import FileStream
+from cStringIO import StringIO
+
+class RGB(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
+        self.read("red", "B", "Red")
+        self.read("green", "B", "Green")
+        self.read("blue", "B", "Blue")
+
+class Palette(Filter):
+    def __init__(self, stream, parent, count):
+        Filter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
+        for i in range(0, count):
+            self.readChild("color[]", RGB)
+
+def StreamDeflateRLE(filter, stream, size):
+    start = stream.tell()
+    end = start + size - 1
+    data = ""
+    width = filter.width
+    for y in range(0, filter.height):
+        line = ""
+        while len(line) < width:
+            character = stream.getN(1)
+            byte = ord(character)
+            if byte & 192 == 192:
+                repeat = byte & 63
+                character = stream.getN(1)
+                line = line + character * repeat                
+            else:
+                line = line + character
+        assert len(line) == width
+        data = data + line
+    assert stream.tell() == end
+    stream.seek(start)
+    return FileStream(StringIO(data),None)
+
+class PCX_Content(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "pcx_content", "PCX content", stream, parent)
+        pcx = parent.getParent()
+        bytes_per_line = pcx["bytes_per_line"]
+        height = pcx["bytes_per_line"]
+        for y in range(0, height):
+            self.read("line[]", "%us" % bytes_per_line, "Line")
+
+class PCX_File(Filter):
+    compression_name = {
+        1: "RLE"
+    }
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "pcx_file", "PCX picture", stream, parent)
+        id = self.read("id", "B", "PCX identifier (10)").value
+        assert id == 10
+        self.read("version", "B", "PCX version")
+        self.read("compression", "B", "Compression", post=self.postCompression)
+        self.bpp = self.read("bpp", "B", "Bits / pixel").value
+        # TODO: Support 4 and 24 bits/pxiel
+        assert self.bpp == 8
+        self.read("xmin", "<H", "Minimum X")
+        self.read("ymin", "<H", "Minimum Y")
+        self.width = self.read("width", "<H", "Width minus one").value+1
+        self.height = self.read("height", "<H", "Height minus one").value+1
+        self.read("horiz_dpi", "<H", "Horizontal DPI")
+        self.read("vert_dpi", "<H", "Vertical DPI")
+        self.readChild("palette_4bits", Palette, 16)
+        self.read("reserved", "B", "Reserved")
+        self.read("nb_color_plan", "B", "Number of color plans")
+        self.read("bytes_per_line", "<H", "Bytes per line")
+        self.read("color_mode", "<H", "Color mode")
+        self.read("reserved2", "58s", "Reserved")
+
+        size = stream.getSize() - stream.tell()
+        if self.bpp == 8:
+            size = size - 256*3
+        deflate = StreamDeflateRLE(self, stream, size)
+        self.readChild("data", DeflateFilter, deflate, size, PCX_Content)
+        if self.bpp == 8:
+            self.readChild("palette_8bits", Palette, 256)
+
+    def postCompression(self, chunk):
+        mode = chunk.value
+        return PCX_File.compression_name.get(mode, "Unknow (%s)" % mode)
+registerPlugin(PCX_File, "image/x-pcx")



From haypo at berlios.de  Fri Dec 16 04:27:36 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 04:27:36 +0100
Subject: [Happyboom-svn] r334 - in haypo/hachoir: . plugins stream
Message-ID: <200512160327.jBG3Rab2018827@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 04:27:21 +0100 (Fri, 16 Dec 2005)
New Revision: 334

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/default.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/plugins/ext2.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/pcx.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/stream/deflate.py
Log:
FormatChunk format size isn't dynamic anymore (syntax was like
"{name_length}s").

- Add --use-profiler command line argument
- Remove syntax like "{name_length}s" and "@end@" joker in FormatChunk
- Remove DeflateFilter in stream/deflate.py (duplicate with the one
  in filter.py)
- readString() check that id is uniq


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/chunk.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -146,6 +146,7 @@
         "MacLine": "mac line",
         "UnixLine": "unix line",
         "AutoLine": "line",
+        "Pascal16": "pascal16",
         "Pascal32": "pascal32",
         "WindowsLine": "windows line"
     }
@@ -171,6 +172,11 @@
 
     def _findSize(self):
         self._stream.seek(self.addr)
+        if self._str_type == "Pascal16":
+            self.length = self._stream.getFormat("!H")[0]
+            self._size = 2 + self.length
+            self.eol = ""
+            return
         if self._str_type == "Pascal32":
             self.length = self._stream.getFormat("!L")[0]
             self._size = 4 + self.length
@@ -211,6 +217,9 @@
         if self._str_type == "Pascal32":
             self._stream.seek(4,1)
             size = self.length
+        elif self._str_type == "Pascal16":
+            self._stream.seek(2,1)
+            size = self.length
         else:
             size = self._size - len(self.eol)
         if max_size != None and max_size<size:
@@ -243,12 +252,12 @@
         
 class FormatChunkCache:
     def __init__(self, chunk):
+        self._chunk = chunk
         self._value = {}
         self._addr = None
         self._format = None
-        self._orig_format = None
         self._size = None
-        self._chunk = chunk
+        self.update()
         
     def _isArray(self, format):
         if self._chunk.isString(): return False
@@ -271,19 +280,23 @@
             else:
                 return data, True
 
+    def _calcsize(self):
+        endian, count, type = splitFormat(self._format)
+        if count != "":
+            count = int(count)
+        else:
+            count = 1
+        self._size = count * struct.calcsize(type)
+
     def update(self):
-        if self._addr != self._chunk.addr or self._orig_format != self._chunk.getFormat():
+        format_changed = (self._format != self._chunk.getFormat())
+        if self._addr != self._chunk.addr or format_changed:
             # Invalidate the cache
             self._value = {}
-            self._orig_format = self._chunk.getFormat()
-            self._format = self._chunk.getRealFormat(self._orig_format)
+            self._format = self._chunk.getFormat()
             self._addr = self._chunk.addr
-            endian, count, type = splitFormat(self._format)
-            if count != "":
-                count = int(count)
-            else:
-                count = 1
-            self._size = count * struct.calcsize(type)
+        if format_changed:
+            self._calcsize()
 
     def getSize(self):
         self.update()
@@ -326,27 +339,9 @@
         return self._cache.getSize()
     size = property(_getSize)        
 
-    def getRealFormat(self, format):
-        if "{" in format:
-            return FormatChunk.regex_sub_format.sub(self.__replaceFieldFormat, format)
-        else:
-            return format
-
     def isString(self):
         return self.__format[-1] == "s"
 
-    def __replaceFieldFormat(self, match):
-        id = match.group(1)
-        if id == "@end@":
-            size = self._stream.getLastPos() - self.addr + 1
-            if size < 0:
-                warning("Size < 0 for chunk %s, will use size=0!" % self.id)
-                size = 0
-        else:
-            assert id != self.id
-            size = self._parent[id]
-        return str(size)
-    
     def convertToStringSize(self, size):
         self.__format = "!%ss" % size
 
@@ -360,7 +355,7 @@
             raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
         
         # Check new size
-        size = struct.calcsize(self.getRealFormat(format))
+        size = struct.calcsize(format)
         if self._stream.getLastPos() < (self.addr + size - 1):
             raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
 

Modified: haypo/hachoir/default.py
===================================================================
--- haypo/hachoir/default.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/default.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -7,4 +7,4 @@
 class DefaultFilter(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "default", "Default filter", stream, parent)
-        self.read("data", "!{@end@}s", "Data")
+        self.read("data", "%us" % stream.getSize(), "Data")

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/filter.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -141,12 +141,9 @@
         if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
             # If last chunk is a FormatChunk, update it's size
             format = splitFormat(prev_chunk.getFormat())
-            if self.getParent() == None:
-                if format[1] != "{@end@}":
-                    prev_chunk.convertToStringSize("{@end@}")
-            else:
-                size = prev_chunk.size - diff_size
-                prev_chunk.convertToStringSize(size)
+            size = prev_chunk.size - diff_size
+            prev_chunk.convertToStringSize(size)
+            self._cache_valid = False
         else:
             # Get id
             if new_id != None:
@@ -163,7 +160,7 @@
 
             # Get size
             if self.getParent() == None:
-                size = "{@end@}"
+                size = self._stream.getSize() - self.getSize() 
             else:
                 size = -diff_size
             self.addRawChunk(prev_chunk, id, size, description)
@@ -362,6 +359,7 @@
     
     def readString(self, id, format, description, post=None, strip=None):
         """ Returns chunk """
+        id = self.getUniqChunkId(id)
         chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
         self.appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)

Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/hachoir.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -22,6 +22,7 @@
     print "Options:"
     print "\t--script file.py  : Load python script"
     print "\t--no-ui           : Don't load user interface"
+    print "\t--use-profiler    : Use profiler"
     print "\t--version         : Show the program version"
     print "\t--verbose         : Activate verbose mode"
     print "\t--help            : Show this help"
@@ -32,7 +33,7 @@
     
     try:
         short = ""
-        long = ["verbose", "help", "version", "script=", "no-ui"]
+        long = ["verbose", "help", "version", "script=", "no-ui", "use-profiler"]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage(def_val)
@@ -50,15 +51,17 @@
         if o == "--help":
             usage(def_val)
             sys.exit()
-        if o == "--version":
+        elif o == "--version":
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit()
-        if o == "--no-ui":
+        elif o == "--no-ui":
             val["load_ui"] = False
-        if o == "--script":
+        elif o == "--script":
             val["script"] = a
-        if o == "--verbose":
+        elif o == "--verbose":
             val["verbose"] = True
+        elif o == "--use-profiler":
+            val["use_profiler"] = True
     return (val, filename,)
 
 def main():
@@ -82,7 +85,8 @@
         opt = {
             "verbose": False,
             "script": None,
-            "load_ui": True            
+            "load_ui": True,
+            "use_profiler": False
         }
         opt, filename = parseArgs(opt)
         global hachoir 
@@ -103,11 +107,17 @@
 Debian: apt-get install python2.4-gtk python2.4-magic
 Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
                 sys.exit(1)
-        if False:
+        if opt["use_profiler"]:
             import profile, pstats
-            profile.run('global hachoir; hachoir.run("%s")' % filename, 'hachoir.loadStream')
-            #pstats.Stats('hachoir.loadStream').sort_stats('time').print_stats()
-            pstats.Stats('hachoir.loadStream').sort_stats('cumulative').print_stats()
+            stat_filename = 'hachoir.pystat'
+            if filename != None:
+                str_filename = "\"%s\"" % filename
+            else:
+                str_filename = "None"
+            profile.run('global hachoir; hachoir.run(%s)' % str_filename, stat_filename)
+            # .sort_stats('time')
+            pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
+            os.unlink(stat_filename)
         else:
             hachoir.run(filename)
 

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/hachoir_class.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -88,14 +88,14 @@
     def _addPadding(self):
         filter_size = self._filter.getSize()
         stream_size = self._filter.getStream().getSize()
-        diff_size = filter_size - stream_size + 1
+        diff_size = filter_size - stream_size
         if diff_size < 0:
             chunks = self._filter.getChunks()
             if len(chunks) != 0:
                 last_chunk = chunks[-1]
             else:
                 last_chunk = None
-            self._filter.addRawChunk(last_chunk, "end", "{@end@}", "")
+            self._filter.addRawChunk(last_chunk, "end", "%u" % (-diff_size), "")
 
     def loadFile(self, filename):
         try:

Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/elf.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -129,7 +129,8 @@
 class Section(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "elf_section", "Elf section", stream, parent)
-        self.read("raw", "{@end@}s", "Raw data")
+        # TODO ...
+        self.read("raw", "%us" % stream.getSize(), "Raw data")
         
 class Sections(Filter):
     def __init__(self, stream, parent, sections):

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/ext2.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -342,12 +342,15 @@
         count = 32768
         self.readChild("inode_bitmap[]", InodeBitmap, count / 8, 1)
 
-        inode_table0 = self.readChild("inode_table[]", InodeTable, 1, 20).getFilter()
+        inode_table0 = self.readChild("inode_table[]", InodeTable, 1, 200).getFilter()
 
         root = inode_table0[2]
 
         self.readDirectory(root)
 
+        size = stream.getSize() - stream.tell()
+        self.read("end", "%us" % size, "End (raw)")
+
     def seek(self, to):
         size = to - self.getStream().tell()
         assert 0 <= size

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/gif.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -56,8 +56,8 @@
 class GifExtensionChunk(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "gif_ext_data", "GIF extension data", stream, parent)
-        self.read("size", "<B", "Size (in bytes)")
-        self.read("content", "<{size}s", "Content")
+        self.read("size", "B", "Size (in bytes)")
+        self.read("content", "%us" % self["size"], "Content")
 
 class GifExtension(Filter):
     def __init__(self, stream, parent):
@@ -114,9 +114,8 @@
                 self.readChild("extensions[]", GifExtension)
             elif code == ",":
                 self.readChild("images[]", GifImage)
-                # TODO: Write GifImage code :-)
-                self.readImage(stream)
-                warning("GIF FILTER CAN NOT READ IMAGE CONTENT YET, SO ABORT READING!")
+                # TODO: Write Huffman parser code :-)
+#                self.readImage(stream)
                 return
             elif code == ";":
                 # GIF Terminator

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/gzip.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -27,7 +27,7 @@
 
         if self["extra"] & 4 == 4:
             self.read("extra_length", "<2H", "Extra length")
-            self.read("extra", "!{extra_length}s", "Extra")
+            self.read("extra", "%us" % self["extra_length"], "Extra")
         if self["flags"] & 8 == 8:
             self.readString("filename", "C", "Filename")
         if self["flags"] & 16 == 16:

Modified: haypo/hachoir/plugins/pcx.py
===================================================================
--- haypo/hachoir/plugins/pcx.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/pcx.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -88,4 +88,5 @@
     def postCompression(self, chunk):
         mode = chunk.value
         return PCX_File.compression_name.get(mode, "Unknow (%s)" % mode)
+
 registerPlugin(PCX_File, "image/x-pcx")

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/pdf.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -1,10 +1,11 @@
-from filter import Filter
+from filter import Filter, DeflateFilter
 from plugin import registerPlugin
 import re
 from stream.error import StreamError
+from stream.deflate import DeflateStream
 from tools import convertDataToPrintableString, getBacktrace
-from stream.deflate import DeflateFilter
 from error import warning
+from default import DefaultFilter
 
 def isEnd(stream, array, last):
     return stream.eof()
@@ -76,7 +77,8 @@
             if what=="deflate":
                 try:
                     old = self.getStream().tell()
-                    self.readChild("deflate", DeflateFilter, start, size)
+                    new_stream = DeflateStream( self.getStream().getN(size,False) )
+                    self.readChild("deflate", DeflateFilter, new_stream, size, DefaultFilter)
                 except:
                     warning("Error while decompressing data of an objet.")
                     self.getStream().seek(start)

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/png.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -96,7 +96,7 @@
             self.readStreamChild("chunk_data", sub, PngChunk.handler[type])
             assert stream.tell() == (oldpos + size) 
         else:
-            self.read("data", "!{size}s", "Chunk data")
+            self.read("data", "%us" % self["size"], "Chunk data")
         self.read("crc32", "!L", "Chunk CRC32")
 
     def updateParent(self, chunk):

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/plugins/zip.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -29,9 +29,9 @@
         self.read("internal_attr", "<H", "Internal file attributes")
         self.read("external_attr", "<L", "External file attributes")
         self.read("offset_header", "<L", "Relative offset of local header")
-        self.read("filename", "<{filename_length}s", "Filename")
-        self.read("extra", "<{extra_length}s", "Extra fields")
-        self.read("file_comment", "<{file_comment_length}s", "File comment")
+        self.read("filename", "%us" % self["filename_length"], "Filename")
+        self.read("extra", "%us" % self["extra_length"], "Extra fields")
+        self.read("file_comment", "%us" % self["file_comment_length"], "File comment")
 
     def updateParent(self, chunk):
         desc = "Central directory: %s" % self["filename"]
@@ -47,8 +47,7 @@
         self.read("total_number_disk2", "<H", "Total number of entries2")
         self.read("size", "<L", "Size of the central directory")
         self.read("offset", "<L", "Offset of start of central directory")
-        self.read("comment_length", "<H", "ZIP comment length")
-        self.read("comment", "<{comment_length}s", "ZIP comment")
+        self.readString("comment", "Pascal16", "ZIP comment")
 
 #class ZipZip64(Filter):
 #    def __init__(self, stream, parent):
@@ -76,9 +75,9 @@
         self.read("uncompressed_size", "<L", "Uncompressed size (bytes)")
         self.read("filename_length", "<H", "Filename length")
         self.read("extra_length", "<H", "Extra length")
-        self.read("filename", "<{filename_length}s", "Filename")
-        self.read("extra", "<{extra_length}s", "Extra")
-        self.read("compressed_data", "<{compressed_size}s", "Compressed data")
+        self.read("filename", "%us" % self["filename_length"], "Filename")
+        self.read("extra", "%us" % self["extra_length"], "Extra")
+        self.read("compressed_data", "%us" % self["compressed_size"], "Compressed data")
         if (self["flags"] & 4) == 4:
             self.read("file_crc32", "<L", "Checksum (CRC32)")
             self.read("file_compressed_size", "<L", "Compressed size (bytes)")
@@ -106,10 +105,10 @@
             elif header == 0x06054b50:
                 self.readChild("end_central_directory", ZipEndCentralDirectory)
             elif header == 0x05054b50:
-                self.read("signature_length", "!H", "Signature length")
-                self.read("signature", "!{signature_length}s", "Signature")
+                self.readString("signature", "Pascal16", "Signature")
             else:
                 error("Error, unknow ZIP header (0x%08X)." % header)
-                self.read("raw", "{@end@}s", "Raw")
+                size = stream.getSize() - stream.tell()
+                self.read("raw", "%us" % size, "Raw")
         
 registerPlugin(ZipFile, "application/x-zip")

Modified: haypo/hachoir/stream/deflate.py
===================================================================
--- haypo/hachoir/stream/deflate.py	2005-12-16 01:10:45 UTC (rev 333)
+++ haypo/hachoir/stream/deflate.py	2005-12-16 03:27:21 UTC (rev 334)
@@ -3,28 +3,6 @@
 from filter import Filter
 from file import FileStream
 
-class DeflateFilter(Filter):
-    def __init__(self, stream, parent, start, size):
-        # Read data
-        self._parent_stream = stream
-        self._parent_stream.seek(start)
-        data = stream.getN(size)
-        
-        # Create a new stream
-        stream = DeflateStream(data)
-        self._compressed_size = size 
-        self._decompressed_size = stream.getSize()
-
-        # Create filter
-        self._parent_stream.seek(start)
-        Filter.__init__(self, "deflate", "Deflate", stream, parent)
-        self._addr = self._parent_stream.tell()
-
-        self.read("raw", "!{@end@}s", "")
-
-    def getSize(self):
-        return self._compressed_size
-
 def DeflateStream(data):
     data = zlib.decompress(data)
     io = StringIO(data)



From haypo at berlios.de  Fri Dec 16 04:47:25 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 04:47:25 +0100
Subject: [Happyboom-svn] r335 - in haypo/hachoir: . plugins stream
Message-ID: <200512160347.jBG3lPTn031478@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 04:47:20 +0100 (Fri, 16 Dec 2005)
New Revision: 335

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/format.py
   haypo/hachoir/plugins/exif.py
   haypo/hachoir/stream/stream.py
Log:
Speed up around FormatChunk size, most interresting trick:
use cache for struct.calcsize (in format.py)


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-16 03:27:21 UTC (rev 334)
+++ haypo/hachoir/chunk.py	2005-12-16 03:47:20 UTC (rev 335)
@@ -1,6 +1,6 @@
 import struct, re, types
 import config
-from format import checkFormat, splitFormat
+from format import checkFormat, splitFormat, getFormatSize 
 from error import warning, error
 from tools import convertDataToPrintableString
 
@@ -269,24 +269,21 @@
         oldpos = stream.tell()
         stream.seek(self._addr)
         if (max_size == None or self._size<=max_size) or not self._chunk.isString():
-            data = stream.getN(self._size)
+            data = stream.getN(self._size, False)
             stream.seek(oldpos)
             return data, False
         else:
-            data = stream.getN(max_size)
+            data = stream.getN(max_size, False)
             stream.seek(oldpos)
             if add_comment:
                 return data+"(...)", True
             else:
                 return data, True
 
-    def _calcsize(self):
-        endian, count, type = splitFormat(self._format)
-        if count != "":
-            count = int(count)
-        else:
-            count = 1
-        self._size = count * struct.calcsize(type)
+    def setFormat(self, format):
+        self._value = {}
+        self._format = format
+        self._size = getFormatSize(self._format)
 
     def update(self):
         format_changed = (self._format != self._chunk.getFormat())
@@ -296,10 +293,10 @@
             self._format = self._chunk.getFormat()
             self._addr = self._chunk.addr
         if format_changed:
-            self._calcsize()
+            self._size = getFormatSize(self._format)
 
     def getSize(self):
-        self.update()
+#        self.update()
         return self._size
 
     def getRaw(self, max_size=None):
@@ -322,8 +319,6 @@
 
     def __init__(self, id, description, stream, addr, format, parent):
         Chunk.__init__(self, id, description, stream, addr, 0, parent)
-        if not checkFormat(format):
-            raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
         self.__format = format
         self._cache = FormatChunkCache(self)
         
@@ -355,9 +350,10 @@
             raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
         
         # Check new size
-        size = struct.calcsize(format)
+        size = getFormatSize(format)
         if self._stream.getLastPos() < (self.addr + size - 1):
             raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
+        self._cache.setFormat(format)
 
         # Update format
         old_size = self.size

Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-16 03:27:21 UTC (rev 334)
+++ haypo/hachoir/format.py	2005-12-16 03:47:20 UTC (rev 335)
@@ -1,8 +1,21 @@
-import re
+import re, struct
 
 _regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLbhscfd]$")
 _regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLbhscfd])$")
+_format_size_cache = {}
 
+def getFormatSize(format):
+    global _format_size_cache
+    if format not in _format_size_cache:
+        assert checkFormat(format)
+        endian, count, type = splitFormat(format)
+        if count != "":
+            count = int(count)
+        else:
+            count = 1
+        _format_size_cache[format] = count * struct.calcsize(type)
+    return _format_size_cache[format]   
+
 def checkFormat(format):
     m = _regex_format1.match(format)
     return m != None

Modified: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-12-16 03:27:21 UTC (rev 334)
+++ haypo/hachoir/plugins/exif.py	2005-12-16 03:47:20 UTC (rev 335)
@@ -9,6 +9,7 @@
 """
 
 from filter import Filter
+from format import getFormatSize
 import struct
 
 class ExifEntry(Filter):
@@ -140,7 +141,7 @@
         self.format = "%s%u%s" % (self.endian, format[0]*self["count"], format[1])
 
         # Get size
-        self.size = struct.calcsize(self.format)
+        self.size = getFormatSize(self.format)
 
         # Get offset/value
         if 4 < self.size:

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-12-16 03:27:21 UTC (rev 334)
+++ haypo/hachoir/stream/stream.py	2005-12-16 03:47:20 UTC (rev 335)
@@ -1,6 +1,7 @@
 import struct
 from error import StreamError
 from tools import regexMaxLength
+from format import getFormatSize
 
 class Stream:
     def __init__(self, filename):
@@ -58,7 +59,7 @@
         """
         Read data using struct format. Eg. getFormat("BB") returns (10, 14).
         """
-        size = struct.calcsize(format)
+        size = getFormatSize(format)
         data = self.getN(size, seek)
         return struct.unpack(format, data)
 



From haypo at berlios.de  Fri Dec 16 06:16:51 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 06:16:51 +0100
Subject: [Happyboom-svn] r336 - in haypo/hachoir: . plugins ui
Message-ID: <200512160516.jBG5Gp2e000497@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 06:16:50 +0100 (Fri, 16 Dec 2005)
New Revision: 336

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/format.py
   haypo/hachoir/plugins/ext2.py
   haypo/hachoir/ui/ui_new_chunk.py
   haypo/hachoir/ui/ui_property.py
Log:
- Create OnlyFormatFilter which doesn't create chunk, or just on demand
- Also use cache for splitFormat function.
- Merge FormatChunkCache and FormatChunk to limit function call


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-16 03:47:20 UTC (rev 335)
+++ haypo/hachoir/chunk.py	2005-12-16 05:16:50 UTC (rev 336)
@@ -31,7 +31,7 @@
 
     def __str__(self):
         return "Chunk(%s) <addr=%s, size=%s, id=%s, description=%s>" % \
-            (self.__class__, self._addr, self.size, self.id, self.description)
+            (self.__class__, self._addr, self._size, self.id, self.description)
         
     def getStream(self):
         return self._stream
@@ -46,7 +46,7 @@
     def getRaw(self, max_size=None):
         oldpos = self._stream.tell()
         self._stream.seek(self.addr)
-        size = self.size
+        size = self._size
         if max_size != None and max_size<size:
             size = max_size
         data = self._stream.getN(size)
@@ -250,95 +250,45 @@
             text = self._read(config.max_string_length)
             return convertDataToPrintableString(text)
         
-class FormatChunkCache:
-    def __init__(self, chunk):
-        self._chunk = chunk
-        self._value = {}
-        self._addr = None
-        self._format = None
-        self._size = None
-        self.update()
-        
-    def _isArray(self, format):
-        if self._chunk.isString(): return False
-        endian, size, type = splitFormat(format)
-        return (size != "1" and size != "")
-
-    def _getRawData(self, max_size=None, add_comment=True):
-        stream = self._chunk.getStream()
-        oldpos = stream.tell()
-        stream.seek(self._addr)
-        if (max_size == None or self._size<=max_size) or not self._chunk.isString():
-            data = stream.getN(self._size, False)
-            stream.seek(oldpos)
-            return data, False
-        else:
-            data = stream.getN(max_size, False)
-            stream.seek(oldpos)
-            if add_comment:
-                return data+"(...)", True
-            else:
-                return data, True
-
-    def setFormat(self, format):
-        self._value = {}
-        self._format = format
-        self._size = getFormatSize(self._format)
-
-    def update(self):
-        format_changed = (self._format != self._chunk.getFormat())
-        if self._addr != self._chunk.addr or format_changed:
-            # Invalidate the cache
-            self._value = {}
-            self._format = self._chunk.getFormat()
-            self._addr = self._chunk.addr
-        if format_changed:
-            self._size = getFormatSize(self._format)
-
-    def getSize(self):
-#        self.update()
-        return self._size
-
-    def getRaw(self, max_size=None):
-        self.update()
-        return self._getRawData(max_size, False)[0]
-
-    def getValue(self, max_size=None):
-        self.update()
-        if max_size not in self._value:
-            data, truncated = self._getRawData(max_size)
-            if not truncated:
-                data = struct.unpack(self._format, data)
-                if not self._isArray(self._format):
-                    data = data[0]
-            self._value[max_size] = data               
-        return self._value[max_size]
-
 class FormatChunk(Chunk):
     regex_sub_format = re.compile(r'\{([^}]+)\}')
 
     def __init__(self, id, description, stream, addr, format, parent):
-        Chunk.__init__(self, id, description, stream, addr, 0, parent)
-        self.__format = format
-        self._cache = FormatChunkCache(self)
-        
+        Chunk.__init__(self, id, description, stream, addr, None, parent)
+        self._format = None
+        self._doSetFormat(format)
+
+    def _doSetFormat(self, format):
+        if format == self._format:
+            return
+        self._format = format
+        self._is_string = self.isString()
+        if not self._is_string:
+            count = splitFormat(self._format)[1]
+            self._is_array = (count != 1)
+        else:
+            self._is_array = False
+        self._size = getFormatSize(self._format)
+        self._value = {}
+       
     def clone(self, addr=None):
         if addr == None:
             addr = self._addr
-        return FormatChunk(self.id, self.description, self._stream, addr, self.__format, self._parent)
+        return FormatChunk(self.id, self.description, self._stream, addr, self._format, self._parent)
 
+    def _setAddr(self, addr):
+        self._addr = addr
+        self._value = {}
+    addr = property(Chunk._getAddr, _setAddr)
+
     def getFormat(self):
-        return self.__format
+        return self._format
 
-    def _getSize(self):
-        return self._cache.getSize()
-    size = property(_getSize)        
-
     def isString(self):
-        return self.__format[-1] == "s"
+        return self._format[-1] == "s"
 
     def convertToStringSize(self, size):
-        self.__format = "!%ss" % size
+        self._doSetFormat("%us" % size)
 
     def setFormat(self, format, method, new_id=None, new_description=None):
         """ Method:
@@ -356,9 +306,9 @@
         self._cache.setFormat(format)
 
         # Update format
-        old_size = self.size
-        self.__format = format
-        new_size = self.size
+        old_size = self._size
+        self._doSetFormat(format)
+        new_size = self._size
         diff_size = new_size - old_size
 
         # Update id and description
@@ -377,13 +327,34 @@
             else:
                 self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description, truncate=True)
         self._parent.updateFormatChunk(self)
-   
+
+    def _getRawData(self, max_size=None):
+        oldpos = self._stream.tell()
+        self._stream.seek(self._addr)
+        if (max_size == None or self._size<=max_size) or not self._is_string:
+            data = self._stream.getN(self._size, False)
+            self._stream.seek(oldpos)
+            return data, False
+        else:
+            data = self._stream.getN(max_size, False)
+            self._stream.seek(oldpos)
+            return data, True
+
     def getRaw(self, max_size=None):
-        return self._cache.getRaw(max_size)
+        return self._getRawData(max_size)[0]
     raw = property(getRaw)
    
     def getValue(self, max_size=None):
-        return self._cache.getValue(max_size)
+        if max_size not in self._value:
+            data, truncated = self._getRawData(max_size)
+            if not truncated:
+                data = struct.unpack(self._format, data)
+                if not self._is_array:
+                    data = data[0]
+            else:
+                data = data + "(...)"
+            self._value[max_size] = data
+        return self._value[max_size]
     value = property(getValue)
 
     def getDisplayData(self):

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-16 03:47:20 UTC (rev 335)
+++ haypo/hachoir/filter.py	2005-12-16 05:16:50 UTC (rev 336)
@@ -6,29 +6,108 @@
 import config
 import ui.ui as ui
 from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
-from format import splitFormat    
 from error import error
 from tools import getBacktrace
+from format import getFormatSize
 
-class Filter:
-    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
-    regex_array_chunk = re.compile(r"^([^[]+)\[\]$")
-
-    def __init__(self, id, description, stream, parent):
+class BasicFilter:
+    def __init__(self, id, description, stream, parent, addr):
         self._id = id
         self._description = description
         self._stream = stream
         self._parent = parent
-        if self._parent:
-            self.depth = self._parent.depth + 1
-        else:
-            self.depth = 1
+        self._addr = addr 
+
+
+    def getId(self): return self._id
+    def setId(self, id): self._id = id
+    def getDescription(self): return self._description
+    def setDescription(self, description): self._description = description
+    def getAddr(self): return self._addr
+    def setAddr(self, addr): self._addr = addr
+    def getParent(self): return self._parent
+    def getStream(self): return self._stream
+
+    def getPath(self):
+        """
+        Get path to the filter.
+        Example: "grandparent > parent > item"
+        """
+        text = ""
+        current = self
+        while current != None:
+            if text != "": text = "/" + text
+            text = current.getId() + text
+            current = current.getParent()
+        return "/"+text
+
+    # --- Pure virtual methods -----------
+    def getSize(self): assert False
+    def __getitem__(self, chunk_id): assert False
+    def getChunk(self, chunk_id): assert False
+    def display(self): assert False
+
+class OnlyFormatFilter(BasicFilter):
+    def __init__(self, id, description, stream, parent):
+        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
+        self._chunks = []
+        self._chunks_counter = {}
+        self._size = 0
+
+    def read(self, id, format, description, post=None):
+        if id[-2:] == "[]":
+            root = id[:-2]
+            if root in self._chunks_counter:
+                self._chunks_counter[root] += 1
+            else:
+                self._chunks_counter[root] = 0
+            id = root+"["+str(self._chunks_counter[root])+"]"
+        size = getFormatSize(format)
+        self._chunks.append( (id, description, self._stream.tell(), format, size, post) )
+        self._stream.seek(size, 1)
+        self._size = self._size + size
+
+    def display(self):
+        ui.window.enableParentButton(self.getParent() != None)
+        ui.window.clear_table()
+        for chunk in self._chunks:
+            data = FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
+            post = chunk[5]
+            if post != None:
+                display = post(data)
+            else:
+                display = data.value 
+            ui.window.add_table(None, chunk[2], chunk[4], chunk[3], chunk[0], chunk[1], display)
+ 
+    def getSize(self): return self._size
+
+    def getChunk(self, chunk_id):
+        print "getChunk: %s" % chunk_id
+        for chunk in self._chunks:
+            if chunk[0] == chunk_id:
+                return FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
+        return None                
+        assert False
+
+    def __getitem__(self, chunk_id):
+        for chunk in self._chunks:
+            if chunk[0] == chunk_id:
+                self._stream.seek(chunk[2])
+                return self._stream.getFormat(chunk[3])[0]
+                return FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
+        assert False
+
+class Filter(BasicFilter):
+    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
+
+    def __init__(self, id, description, stream, parent):
+        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
         self.filter_chunk = None 
         self._chunks = []
         self._chunks_dict = {}
-        self._addr = self._stream.tell()
         self._cache_valid = False
         self._cache_size = None
+        self._chunk_counter = {}
 
     def __getitem__(self, chunk_id):
         return self.getChunk(chunk_id).getValue()
@@ -47,11 +126,6 @@
         new.filter_chunk = self.filter_chunk
         return new
 
-    def getId(self): return self._id
-    def setId(self, id): self._id = id
-    def getDescription(self): return self._description
-    def setDescription(self, description): self._description = description
-
     def _deleteChunk(self, pos):
         self._cache_valid = False
         chunk = self._chunks[pos]
@@ -76,29 +150,34 @@
     def getChunks(self):
         return self._chunks
 
-    def _getUniqChunkId(self, pattern, root, index):
-        if not hasattr(self, "_chunk_counter"):
-            self._chunk_counter = {}
-        
+    def _getUniqChunkId(self, root, index):
         if root in self._chunk_counter:
-            self._chunk_counter[root] = self._chunk_counter[root]+1
+            self._chunk_counter[root] = self._chunk_counter[root] + 1
         else:
             self._chunk_counter[root] = index
-        return pattern % (root, self._chunk_counter[root])
+        return self._chunk_counter[root]
 
     def getUniqChunkId(self, id):
+        # Pattern like "block[]"
         if id[-2:] == "[]":
-            return self._getUniqChunkId("%s[%u]", id[:-2], 0)
+            root = id[:-2]
+            index = self._getUniqChunkId(root, 0)
+            return root+"["+str(index)+"]" 
 
-        if id in self._chunks_dict:
-            m = Filter.regex_chunk_uniq_id.match(id)
-            if m != None:
-                return self._getUniqChunkId("%s%u", m.group(1), int(m.group(2))+1)
-            else:
-                return self._getUniqChunkId("%s%u", id, 2)
-        else:
+        # No collision
+        if id not in self._chunks_dict:
             return id
 
+        # Manage id collision
+        m = Filter.regex_chunk_uniq_id.match(id)
+        if m != None:
+            root = m.group(1)
+            index = self._getUniqChunkId(root, int(m.group(2))+1)
+        else:
+            root = id
+            index = self._getUniqChunkId(root, 2)
+        return root+str(index)
+
     def updateChunkId(self, chunk, new_id):
         if chunk.id == new_id: return
         if new_id in self._chunks_dict or hasattr(self, new_id):
@@ -140,7 +219,6 @@
         
         if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
             # If last chunk is a FormatChunk, update it's size
-            format = splitFormat(prev_chunk.getFormat())
             size = prev_chunk.size - diff_size
             prev_chunk.convertToStringSize(size)
             self._cache_valid = False
@@ -207,12 +285,6 @@
         if self.getParent() != None:
             self.getParent().rescan(self.filter_chunk, diff_size)
 
-    def getAddr(self):
-        return self._addr
-
-    def setAddr(self, addr):
-        self._addr = addr
-
     def getLastPos(self):
         if len(self._array) == 0: return self.getAddr()
         last_chunk = self._array[-1]
@@ -266,19 +338,6 @@
     def redisplay(self):  
         self.display()
     
-    def getPath(self):
-        """
-        Get path to the filter.
-        Example: "grandparent > parent > item"
-        """
-        text = ""
-        current = self
-        while current != None:
-            if text != "": text = "/" + text
-            text = current.getId() + text
-            current = current.getParent()
-        return "/"+text
-
     def display(self):  
         ui.window.enableParentButton(self.getParent() != None)
             
@@ -315,10 +374,10 @@
 
     def appendChunk(self, chunk, position=None):
         self._cache_valid = False
-        if position != None:
+        if position == None:
+            self._chunks.append(chunk)
+        else:
             self._chunks.insert(position, chunk)
-        else:
-            self._chunks.append(chunk)
         self._chunks_dict[chunk.id] = chunk
 
     def readLimitedChild(self, id, size, filter_class, *args):
@@ -382,7 +441,7 @@
             (self.__class__, self.getId(), self.getDescription())
 
     def addNewFilter(self, chunk, id, size, desc):
-        chunk.setFormat("!%ss" % size, "split", id, desc)
+        chunk.setFormat("%us" % size, "split", id, desc)
         self.convertChunkToFilter(chunk)
 
     def convertFilterToChunk(self, chunk):
@@ -421,12 +480,6 @@
         self.redisplay()
         return filter
 
-    def getParent(self):
-        return self._parent
-
-    def getStream(self):
-        return self._stream
-
 class ArrayFilter(Filter):
     def __init__(self, id, description, stream, parent, entry_class, end_func):
         Filter.__init__(self, id, description, stream, parent)

Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-16 03:47:20 UTC (rev 335)
+++ haypo/hachoir/format.py	2005-12-16 05:16:50 UTC (rev 336)
@@ -4,27 +4,37 @@
 _regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLbhscfd])$")
 _format_size_cache = {}
 
-def getFormatSize(format):
+def _getFormatCache(format):
     global _format_size_cache
     if format not in _format_size_cache:
         assert checkFormat(format)
-        endian, count, type = splitFormat(format)
-        if count != "":
-            count = int(count)
-        else:
-            count = 1
-        _format_size_cache[format] = count * struct.calcsize(type)
+        endian, count, type = _doSplitFormat(format)
+        size = count * struct.calcsize(type)
+        _format_size_cache[format] = (endian, count, type, size)
     return _format_size_cache[format]   
 
+def getFormatSize(format):
+    cache = _getFormatCache(format)
+    return cache[3]   
+
 def checkFormat(format):
     m = _regex_format1.match(format)
     return m != None
 
 def splitFormat(format):
+    cache = _getFormatCache(format)
+    return cache[:3]   
+
+def _doSplitFormat(format):
     m = _regex_format2.match(format)
-    if m == None: return None
+    assert m != None
     endian = m.group(1)
-    if endian=="": endian="!"
-    size = m.group(2)
+    count = m.group(2)
     type = m.group(3)
-    return (endian, size, type,)
+    if endian == "":
+        endian = "!"
+    if count != "":
+        count = long(count)
+    else:
+        count = 1
+    return (endian, count, type,)

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-16 03:47:20 UTC (rev 335)
+++ haypo/hachoir/plugins/ext2.py	2005-12-16 05:16:50 UTC (rev 336)
@@ -9,7 +9,7 @@
 """
 
 from datetime import datetime
-from filter import Filter
+from filter import Filter, OnlyFormatFilter
 from plugin import registerPlugin
 from tools import humanDuration, getUnixRWX 
 
@@ -48,7 +48,7 @@
         type = chunk.value
         return DirectoryEntry.file_type.get(type, "Unknow (%02X)" % type)
 
-class Inode(Filter):
+class Inode(OnlyFormatFilter):
     name = {
         1: "list of bad blocks",
         2: "Root directory",
@@ -60,7 +60,7 @@
     }
     
     def __init__(self, stream, parent, index):
-        Filter.__init__(self, "inode", "EXT2 inode", stream, parent)
+        OnlyFormatFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
         self.index = index
         self.read("mode", "<H", "Mode", post=self.postMode)
         self.read("uid", "<H", "User ID")
@@ -204,84 +204,79 @@
         self.read("free_blocks_count", "<L", "Free blocks count")
         self.read("free_inodes_count", "<L", "Free inodes count")
         first = self.read("first_data_block", "<L", "First data block").value
-        self.is_superblock = (first == 0)
-        if self.is_superblock:
-            self.read("log_block_size", "<L", "Block size")
-            self.read("log_frag_size", "<L", "Fragment size")
-            self.read("blocks_per_group", "<L", "Blocks per group")
-            self.read("frags_per_group", "<L", "Fragments per group")
-            self.read("inodes_per_group", "<L", "Inodes per group")
-            self.read("mtime", "<L", "Mount time", post=self.getTime)
-            self.read("wtime", "<L", "Write time", post=self.getTime)
-            self.read("mnt_count", "<H", "Mount count")
-            self.read("max_mnt_count", "<h", "Max mount count")
-            id = self.read("magic", ">H", "Magic number (0x53EF)").value
-            assert id == 0x53EF
+        assert (first == 0)
+        self.read("log_block_size", "<L", "Block size")
+        self.read("log_frag_size", "<L", "Fragment size")
+        self.read("blocks_per_group", "<L", "Blocks per group")
+        self.read("frags_per_group", "<L", "Fragments per group")
+        self.read("inodes_per_group", "<L", "Inodes per group")
+        self.read("mtime", "<L", "Mount time", post=self.getTime)
+        self.read("wtime", "<L", "Write time", post=self.getTime)
+        self.read("mnt_count", "<H", "Mount count")
+        self.read("max_mnt_count", "<h", "Max mount count")
+        id = self.read("magic", ">H", "Magic number (0x53EF)").value
+        assert id == 0x53EF
 
-            # Read state
-            chunk = self.read("state", "<H", "File system state")
-            chunk.description = "Behaviour when detecting errors: %s" % \
-                SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
+        # Read state
+        chunk = self.read("state", "<H", "File system state")
+        chunk.description = "Behaviour when detecting errors: %s" % \
+            SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
 
-            # Read error handling
-            chunk = self.read("errors", "<H", "")
-            desc = "Behaviour when detecting errors"
-            if chunk.value in SuperBlock.error_handling:
-                desc = "%s: %s" % (desc, SuperBlock.error_handling[chunk.value])
-            chunk.description = desc
-            
-            self.read("minor_rev_level", "<H", "Minor revision level")
-            self.read("last_check", "<L", "Time of last check", post=self.getTime)
-            self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
-            
-            chunk = self.read("creator_os", "<L", "")
-            desc = "Creator OS"
-            if chunk.value in SuperBlock.os_name:
-                desc = "%s: %s" % (desc, SuperBlock.os_name[chunk.value])
-            chunk.description = desc
-            
-            self.read("rev_level", "<L", "Revision level")
-            self.read("def_resuid", "<H", "Default uid for reserved blocks")
-            self.read("def_resgid", "<H", "Default guid for reserverd blocks")
+        # Read error handling
+        chunk = self.read("errors", "<H", "")
+        desc = "Behaviour when detecting errors"
+        if chunk.value in SuperBlock.error_handling:
+            desc = "%s: %s" % (desc, SuperBlock.error_handling[chunk.value])
+        chunk.description = desc
+        
+        self.read("minor_rev_level", "<H", "Minor revision level")
+        self.read("last_check", "<L", "Time of last check", post=self.getTime)
+        self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
+        
+        chunk = self.read("creator_os", "<L", "")
+        desc = "Creator OS"
+        if chunk.value in SuperBlock.os_name:
+            desc = "%s: %s" % (desc, SuperBlock.os_name[chunk.value])
+        chunk.description = desc
+        
+        self.read("rev_level", "<L", "Revision level")
+        self.read("def_resuid", "<H", "Default uid for reserved blocks")
+        self.read("def_resgid", "<H", "Default guid for reserverd blocks")
 
-            # ---------
+        # ---------
 
-            self.read("first_ino", "<L", "First non-reserved inode")
-            inode_size = self.read("inode_size", "<H", "Size of inode structure").value
-            assert inode_size == (68 + 15*4)
-            self.read("block_group_nr", "<H", "Block group # of this superblock")
-            self.read("feature_compat", "<L", "Compatible feature set")
-            self.read("feature_incompat", "<L", "Incompatible feature set")
-            self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
-            self.read("uuid", "16s", "128-bit uuid for volume")
-            self.read("volume_name", "16s", "Volume name")
-            self.read("last_mounted", "64s", "Directory where last mounted")
-            self.read("compression", "<L", "For compression (algorithm usage bitmap)")
-            
-            self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
-            self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
-            self.read("padding", "H", "Padding")
-            
-            self.read("journal_uuid", "16s", "uuid of journal superblock")
-            self.read("journal_inum", "<L", "inode number of journal file")
-            self.read("journal_dev", "<L", "device number of journal file")
-            self.read("last_orphan", "<L", "start of list of inodes to delete")
-            
-            self.read("reserved", "197s", "Padding to the end of the block")
-        else:        
-            self.read("padding", "197s", "Padding to the end of the block")
+        self.read("first_ino", "<L", "First non-reserved inode")
+        inode_size = self.read("inode_size", "<H", "Size of inode structure").value
+        assert inode_size == (68 + 15*4)
+        self.read("block_group_nr", "<H", "Block group # of this superblock")
+        self.read("feature_compat", "<L", "Compatible feature set")
+        self.read("feature_incompat", "<L", "Incompatible feature set")
+        self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
+        self.read("uuid", "16s", "128-bit uuid for volume")
+        self.read("volume_name", "16s", "Volume name")
+        self.read("last_mounted", "64s", "Directory where last mounted")
+        self.read("compression", "<L", "For compression (algorithm usage bitmap)")
+        
+        self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
+        self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
+        self.read("padding", "H", "Padding")
+        
+        self.read("journal_uuid", "16s", "uuid of journal superblock")
+        self.read("journal_inum", "<L", "inode number of journal file")
+        self.read("journal_dev", "<L", "device number of journal file")
+        self.read("last_orphan", "<L", "start of list of inodes to delete")
+        
+        self.read("reserved", "197s", "Padding to the end of the block")
 
+        blocks_per_group = self["blocks_per_group"]
+        self.group_count = (self["blocks_count"] - self["first_data_block"] + blocks_per_group - 1) / blocks_per_group
+
     def updateParent(self, chunk):
-        if self.is_superblock:
-            blocks_per_group = self["blocks_per_group"]
-            self.group_count = (self["blocks_count"] - self["first_data_block"] + blocks_per_group - 1) / blocks_per_group
-            if self["feature_compat"] & 4 == 4:
-                type = "ext3"
-            else:
-                type = "ext2"
-            desc = "EXT2 Superblock: %s file system" % type
+        if self["feature_compat"] & 4 == 4:
+            type = "ext3"
         else:
-            desc = "EXT2 block #%s" % self["first_data_block"]
+            type = "ext2"
+        desc = "EXT2 Superblock: %s file system" % type
         self.setDescription(desc)
         chunk.description = desc
 
@@ -342,7 +337,7 @@
         count = 32768
         self.readChild("inode_bitmap[]", InodeBitmap, count / 8, 1)
 
-        inode_table0 = self.readChild("inode_table[]", InodeTable, 1, 200).getFilter()
+        inode_table0 = self.readChild("inode_table[]", InodeTable, 1, 1000).getFilter()
 
         root = inode_table0[2]
 

Modified: haypo/hachoir/ui/ui_new_chunk.py
===================================================================
--- haypo/hachoir/ui/ui_new_chunk.py	2005-12-16 03:47:20 UTC (rev 335)
+++ haypo/hachoir/ui/ui_new_chunk.py	2005-12-16 05:16:50 UTC (rev 336)
@@ -48,7 +48,7 @@
         format = chunk.getFormat()
         split = splitFormat(format)
         if split != None:
-            self.size_widget.set_text(split[1])
+            self.size_widget.set_text("%u" % split[1])
             self.endian_widget.child.set_text(split[0])
             self.format_widget.child.set_text(split[2])
         self.id_widget.set_text(chunk.id)

Modified: haypo/hachoir/ui/ui_property.py
===================================================================
--- haypo/hachoir/ui/ui_property.py	2005-12-16 03:47:20 UTC (rev 335)
+++ haypo/hachoir/ui/ui_property.py	2005-12-16 05:16:50 UTC (rev 336)
@@ -1,7 +1,6 @@
 import pygtk
 import gtk
 import gtk.glade
-from format import splitFormat
 
 class PropertyDialog:
     def __init__(self, ui):



From haypo at berlios.de  Fri Dec 16 06:44:28 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 06:44:28 +0100
Subject: [Happyboom-svn] r337 - in haypo/hachoir: . plugins
Message-ID: <200512160544.jBG5iSFZ013746@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 06:44:25 +0100 (Fri, 16 Dec 2005)
New Revision: 337

Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/ext2.py
Log:
Add chunk cache in OnlyFormatFilter.


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-16 05:16:50 UTC (rev 336)
+++ haypo/hachoir/filter.py	2005-12-16 05:44:25 UTC (rev 337)
@@ -17,8 +17,9 @@
         self._stream = stream
         self._parent = parent
         self._addr = addr 
+        self._chunks_counter = {}
+        self._chunks_dict = {}
 
-
     def getId(self): return self._id
     def setId(self, id): self._id = id
     def getDescription(self): return self._description
@@ -41,6 +42,34 @@
             current = current.getParent()
         return "/"+text
 
+    def _getUniqChunkId(self, root, index):
+        if root in self._chunks_counter:
+            self._chunks_counter[root] = self._chunks_counter[root] + 1
+        else:
+            self._chunks_counter[root] = index
+        return self._chunks_counter[root]
+
+    def getUniqChunkId(self, id):
+        # Pattern like "block[]"
+        if id[-2:] == "[]":
+            root = id[:-2]
+            index = self._getUniqChunkId(root, 0)
+            return root+"["+str(index)+"]" 
+
+        # No collision
+        if id not in self._chunks_dict:
+            return id
+
+        # Manage id collision
+        m = Filter.regex_chunk_uniq_id.match(id)
+        if m != None:
+            root = m.group(1)
+            index = self._getUniqChunkId(root, int(m.group(2))+1)
+        else:
+            root = id
+            index = self._getUniqChunkId(root, 2)
+        return root+str(index)
+
     # --- Pure virtual methods -----------
     def getSize(self): assert False
     def __getitem__(self, chunk_id): assert False
@@ -51,19 +80,19 @@
     def __init__(self, id, description, stream, parent):
         BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
         self._chunks = []
-        self._chunks_counter = {}
+        self._chunks_dict = {}
+        self._chunks_cache = {}
         self._size = 0
 
+    def purgeCache(self):
+        self._chunks_cache = {}
+
     def read(self, id, format, description, post=None):
-        if id[-2:] == "[]":
-            root = id[:-2]
-            if root in self._chunks_counter:
-                self._chunks_counter[root] += 1
-            else:
-                self._chunks_counter[root] = 0
-            id = root+"["+str(self._chunks_counter[root])+"]"
+        id = self.getUniqChunkId(id)
         size = getFormatSize(format)
-        self._chunks.append( (id, description, self._stream.tell(), format, size, post) )
+        chunk_info = (id, description, self._stream.tell(), format, size, post)
+        self._chunks_dict[id] = chunk_info
+        self._chunks.append( chunk_info )
         self._stream.seek(size, 1)
         self._size = self._size + size
 
@@ -81,21 +110,17 @@
  
     def getSize(self): return self._size
 
-    def getChunk(self, chunk_id):
-        print "getChunk: %s" % chunk_id
-        for chunk in self._chunks:
-            if chunk[0] == chunk_id:
-                return FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
-        return None                
-        assert False
+    def getChunk(self, id):
+        if id not in self._chunks_dict:
+            return None
+        if id not in self._chunks_cache:
+            chunk = self._chunks_dict[id]
+            self._chunks_cache[id] = FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
+        return self._chunks_cache[id]
 
-    def __getitem__(self, chunk_id):
-        for chunk in self._chunks:
-            if chunk[0] == chunk_id:
-                self._stream.seek(chunk[2])
-                return self._stream.getFormat(chunk[3])[0]
-                return FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
-        assert False
+    def __getitem__(self, id):
+        assert id in self._chunks_dict
+        return self.getChunk(id).value
 
 class Filter(BasicFilter):
     regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
@@ -107,7 +132,6 @@
         self._chunks_dict = {}
         self._cache_valid = False
         self._cache_size = None
-        self._chunk_counter = {}
 
     def __getitem__(self, chunk_id):
         return self.getChunk(chunk_id).getValue()
@@ -150,34 +174,6 @@
     def getChunks(self):
         return self._chunks
 
-    def _getUniqChunkId(self, root, index):
-        if root in self._chunk_counter:
-            self._chunk_counter[root] = self._chunk_counter[root] + 1
-        else:
-            self._chunk_counter[root] = index
-        return self._chunk_counter[root]
-
-    def getUniqChunkId(self, id):
-        # Pattern like "block[]"
-        if id[-2:] == "[]":
-            root = id[:-2]
-            index = self._getUniqChunkId(root, 0)
-            return root+"["+str(index)+"]" 
-
-        # No collision
-        if id not in self._chunks_dict:
-            return id
-
-        # Manage id collision
-        m = Filter.regex_chunk_uniq_id.match(id)
-        if m != None:
-            root = m.group(1)
-            index = self._getUniqChunkId(root, int(m.group(2))+1)
-        else:
-            root = id
-            index = self._getUniqChunkId(root, 2)
-        return root+str(index)
-
     def updateChunkId(self, chunk, new_id):
         if chunk.id == new_id: return
         if new_id in self._chunks_dict or hasattr(self, new_id):

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-16 05:16:50 UTC (rev 336)
+++ haypo/hachoir/plugins/ext2.py	2005-12-16 05:44:25 UTC (rev 337)
@@ -304,6 +304,7 @@
         for index in range(start,start+count):
             inode = self.readChild("inode[]", Inode, index).getFilter()
             self.inodes[index] = inode
+            inode.purgeCache()
 
     def __getitem__(self, index):
         return self.inodes[index]



From haypo at berlios.de  Fri Dec 16 07:30:23 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 07:30:23 +0100
Subject: [Happyboom-svn] r338 - in haypo/hachoir: . plugins ui
Message-ID: <200512160630.jBG6UNYU032519@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 07:29:25 +0100 (Fri, 16 Dec 2005)
New Revision: 338

Modified:
   haypo/hachoir/error.py
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/ext2.py
   haypo/hachoir/ui/ui_window.py
Log:
- Create OnlyFiltersFilter which read filter on demand.
- Add missing parent argument to gtk MessageDialog


Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-12-16 05:44:25 UTC (rev 337)
+++ haypo/hachoir/error.py	2005-12-16 06:29:25 UTC (rev 338)
@@ -7,6 +7,7 @@
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \
+            parent=ui.ui.ui.window,
             type=gtk.MESSAGE_WARNING,
             buttons=gtk.BUTTONS_OK,
             message_format=message)
@@ -18,6 +19,7 @@
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \
+            parent=ui.ui.ui.window,
             type=gtk.MESSAGE_ERROR,
             buttons=gtk.BUTTONS_OK,
             message_format=message)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-16 05:44:25 UTC (rev 337)
+++ haypo/hachoir/filter.py	2005-12-16 06:29:25 UTC (rev 338)
@@ -20,6 +20,7 @@
         self._chunks_counter = {}
         self._chunks_dict = {}
 
+    def updateParent(self, chunk): pass
     def getId(self): return self._id
     def setId(self, id): self._id = id
     def getDescription(self): return self._description
@@ -28,6 +29,9 @@
     def setAddr(self, addr): self._addr = addr
     def getParent(self): return self._parent
     def getStream(self): return self._stream
+    def setChunkCounter(self, root, start):
+        assert root not in self._chunks_counter
+        self._chunks_counter[root] = start
 
     def getPath(self):
         """
@@ -76,7 +80,7 @@
     def getChunk(self, chunk_id): assert False
     def display(self): assert False
 
-class OnlyFormatFilter(BasicFilter):
+class OnlyFormatChunksFilter(BasicFilter):
     def __init__(self, id, description, stream, parent):
         BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
         self._chunks = []
@@ -122,6 +126,57 @@
         assert id in self._chunks_dict
         return self.getChunk(id).value
 
+class OnlyFiltersFilter(BasicFilter):
+    def __init__(self, id, description, stream, parent):
+        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
+        self._chunks = []
+        self._chunks_dict = {}
+        self._chunks_cache = {}
+        self._size = 0
+
+    def purgeCache(self):
+        self._chunks_cache = {}
+
+    def readSizedChild(self, id, size, filter_class, *args): 
+        id = self.getUniqChunkId(id)
+        filter_info = (id, size, self._stream.tell(), filter_class, args)
+        self._chunks_dict[id] = filter_info
+        self._chunks.append( filter_info )
+        self._stream.seek(size, 1)
+        self._size = self._size + size
+
+    def display(self):
+        ui.window.enableParentButton(self.getParent() != None)
+        ui.window.clear_table()
+        for chunk in self._chunks:
+            format = chunk[3].__name__
+            desc = "xxx"
+            ui.window.add_table(None, chunk[2], chunk[1], format, chunk[0], desc, "(...)")
+ 
+    def getSize(self): return self._size
+
+    def getChunk(self, id):
+        if id not in self._chunks_dict:
+            return None
+        if id not in self._chunks_cache:
+            info = self._chunks_dict[id]
+
+            addr = info[2]
+            self._stream.seek(addr)
+            filter = info[3] (self._stream, self, *info[4])
+            filter.setId(info[0])
+            chunk = FilterChunk(info[0], filter, self, addr)
+#            filter.updateParent(chunk)
+#            chunk.postProcess()
+            self._stream.seek(addr + info[1])
+            
+            self._chunks_cache[id] = chunk 
+        return self._chunks_cache[id]
+
+    def __getitem__(self, id):
+        assert id in self._chunks_dict
+        return self.getChunk(id).value
+
 class Filter(BasicFilter):
     regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
 

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-16 05:44:25 UTC (rev 337)
+++ haypo/hachoir/plugins/ext2.py	2005-12-16 06:29:25 UTC (rev 338)
@@ -9,7 +9,7 @@
 """
 
 from datetime import datetime
-from filter import Filter, OnlyFormatFilter
+from filter import Filter, OnlyFormatChunksFilter, OnlyFiltersFilter
 from plugin import registerPlugin
 from tools import humanDuration, getUnixRWX 
 
@@ -48,7 +48,7 @@
         type = chunk.value
         return DirectoryEntry.file_type.get(type, "Unknow (%02X)" % type)
 
-class Inode(OnlyFormatFilter):
+class Inode(OnlyFormatChunksFilter):
     name = {
         1: "list of bad blocks",
         2: "Root directory",
@@ -60,7 +60,7 @@
     }
     
     def __init__(self, stream, parent, index):
-        OnlyFormatFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
+        OnlyFormatChunksFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
         self.index = index
         self.read("mode", "<H", "Mode", post=self.postMode)
         self.read("uid", "<H", "User ID")
@@ -297,17 +297,20 @@
     def __getitem__(self, index):
         return self.items[index]
 
-class InodeTable(Filter):
+class InodeTable(OnlyFiltersFilter):
     def __init__(self, stream, parent, start, count):
-        Filter.__init__(self, "ino_table", "EXT2 inode table", stream, parent)
+        OnlyFiltersFilter.__init__(self, "ino_table", "EXT2 inode table", stream, parent)
         self.inodes = {}
-        for index in range(start,start+count):
-            inode = self.readChild("inode[]", Inode, index).getFilter()
-            self.inodes[index] = inode
-            inode.purgeCache()
+        self.start = start
+        chunk_size = parent.superblock["inode_size"]
+        for index in range(0,count):
+            self.readSizedChild("inode[]", chunk_size, Inode, index)
 
     def __getitem__(self, index):
-        return self.inodes[index]
+        print "Read inode %s" % index
+        index = index - self.start - 1
+        print ">Read inode %s" % index
+        return self.getChunk("inode[%u]" % index).getFilter()
 
 #class Directory(Filter):
 #    def __init__(self, stream, parent):
@@ -338,7 +341,7 @@
         count = 32768
         self.readChild("inode_bitmap[]", InodeBitmap, count / 8, 1)
 
-        inode_table0 = self.readChild("inode_table[]", InodeTable, 1, 1000).getFilter()
+        inode_table0 = self.readChild("inode_table[]", InodeTable, 0, 1000).getFilter()
 
         root = inode_table0[2]
 
@@ -354,6 +357,7 @@
             self.read("raw[]", "%us" % size, "Raw")
 
     def readDirectory(self, inode):
+        print "Read."
         stream = self.getStream()
         block_index = 0
         while True:

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-16 05:44:25 UTC (rev 337)
+++ haypo/hachoir/ui/ui_window.py	2005-12-16 06:29:25 UTC (rev 338)
@@ -82,6 +82,7 @@
 
         chooser = gtk.FileChooserDialog( \
             title="Write chunk data to ...",
+            parent=self.window,
             action=gtk.FILE_CHOOSER_ACTION_SAVE,
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:
@@ -199,6 +200,7 @@
     def on_toolbutton_close(self, widget):
         dlg = gtk.MessageDialog( \
             type=gtk.MESSAGE_QUESTION,
+            parent=self.window,
             buttons=gtk.BUTTONS_YES_NO,
             message_format="Are you sure that you want to close the file?")
         dlg.set_default_response(gtk.RESPONSE_NO)            
@@ -216,6 +218,7 @@
     def on_open_activate(self, widget):
         chooser = gtk.FileChooserDialog( \
             title="Choose file to split",
+            parent=self.window,
             action=gtk.FILE_CHOOSER_ACTION_OPEN,
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:
@@ -226,6 +229,7 @@
     def on_toolbutton_open(self, widget):
         chooser = gtk.FileChooserDialog( \
             title="Choose filter",
+            parent=self.window,
             action=gtk.FILE_CHOOSER_ACTION_OPEN,
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:
@@ -236,6 +240,7 @@
     def on_toolbutton_export(self, widget):
         chooser = gtk.FileChooserDialog( \
             title="Export current filter to python script ...",
+            parent=self.window,
             action=gtk.FILE_CHOOSER_ACTION_SAVE,
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:
@@ -246,6 +251,7 @@
     def on_toolbutton_save(self, widget):
         chooser = gtk.FileChooserDialog( \
             title="Save XML filter into ...",
+            parent=self.window,
             action=gtk.FILE_CHOOSER_ACTION_SAVE,
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:



From haypo at berlios.de  Fri Dec 16 07:41:00 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 16 Dec 2005 07:41:00 +0100
Subject: [Happyboom-svn] r339 - in haypo/hachoir: . plugins
Message-ID: <200512160641.jBG6f0OL005432@sheep.berlios.de>

Author: haypo
Date: 2005-12-16 07:40:33 +0100 (Fri, 16 Dec 2005)
New Revision: 339

Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/ext2.py
Log:
Update description when a filter is loaded from OnlyFiltersFilter


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-16 06:29:25 UTC (rev 338)
+++ haypo/hachoir/filter.py	2005-12-16 06:40:33 UTC (rev 339)
@@ -29,9 +29,6 @@
     def setAddr(self, addr): self._addr = addr
     def getParent(self): return self._parent
     def getStream(self): return self._stream
-    def setChunkCounter(self, root, start):
-        assert root not in self._chunks_counter
-        self._chunks_counter[root] = start
 
     def getPath(self):
         """
@@ -118,8 +115,9 @@
         if id not in self._chunks_dict:
             return None
         if id not in self._chunks_cache:
-            chunk = self._chunks_dict[id]
-            self._chunks_cache[id] = FormatChunk(chunk[0], chunk[1], self._stream, chunk[2], chunk[3], self)
+            info = self._chunks_dict[id]
+            chunk = FormatChunk(info[0], info[1], self._stream, info[2], info[3], self)
+            self._chunks_cache[id] = chunk 
         return self._chunks_cache[id]
 
     def __getitem__(self, id):
@@ -137,9 +135,9 @@
     def purgeCache(self):
         self._chunks_cache = {}
 
-    def readSizedChild(self, id, size, filter_class, *args): 
+    def readSizedChild(self, id, size, description, filter_class, *args): 
         id = self.getUniqChunkId(id)
-        filter_info = (id, size, self._stream.tell(), filter_class, args)
+        filter_info = (id, size, self._stream.tell(), description, filter_class, args)
         self._chunks_dict[id] = filter_info
         self._chunks.append( filter_info )
         self._stream.seek(size, 1)
@@ -148,10 +146,14 @@
     def display(self):
         ui.window.enableParentButton(self.getParent() != None)
         ui.window.clear_table()
-        for chunk in self._chunks:
-            format = chunk[3].__name__
-            desc = "xxx"
-            ui.window.add_table(None, chunk[2], chunk[1], format, chunk[0], desc, "(...)")
+        for info in self._chunks:
+            format = info[4].__name__
+            if info[0] in self._chunks_cache:
+                c = self._chunks_cache[info[0]]
+                desc = c.description
+            else:
+                desc = info[3] 
+            ui.window.add_table(None, info[2], info[1], format, info[0], desc, "(...)")
  
     def getSize(self): return self._size
 
@@ -163,11 +165,10 @@
 
             addr = info[2]
             self._stream.seek(addr)
-            filter = info[3] (self._stream, self, *info[4])
+            filter = info[4] (self._stream, self, *info[5])
             filter.setId(info[0])
             chunk = FilterChunk(info[0], filter, self, addr)
-#            filter.updateParent(chunk)
-#            chunk.postProcess()
+            filter.updateParent(chunk)
             self._stream.seek(addr + info[1])
             
             self._chunks_cache[id] = chunk 

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-16 06:29:25 UTC (rev 338)
+++ haypo/hachoir/plugins/ext2.py	2005-12-16 06:40:33 UTC (rev 339)
@@ -303,13 +303,11 @@
         self.inodes = {}
         self.start = start
         chunk_size = parent.superblock["inode_size"]
-        for index in range(0,count):
-            self.readSizedChild("inode[]", chunk_size, Inode, index)
+        for index in range(self.start+1, self.start+1+count):
+            self.readSizedChild("inode[]", chunk_size, "Inode %s" % index, Inode, index)
 
     def __getitem__(self, index):
-        print "Read inode %s" % index
         index = index - self.start - 1
-        print ">Read inode %s" % index
         return self.getChunk("inode[%u]" % index).getFilter()
 
 #class Directory(Filter):
@@ -357,7 +355,6 @@
             self.read("raw[]", "%us" % size, "Raw")
 
     def readDirectory(self, inode):
-        print "Read."
         stream = self.getStream()
         block_index = 0
         while True:



From haypo at berlios.de  Tue Dec 20 14:45:54 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 20 Dec 2005 14:45:54 +0100
Subject: [Happyboom-svn] r341 - in haypo/hachoir: . fallback plugins ui
Message-ID: <200512201345.jBKDjsAk024855@sheep.berlios.de>

Author: haypo
Date: 2005-12-20 14:45:51 +0100 (Tue, 20 Dec 2005)
New Revision: 341

Added:
   haypo/hachoir/AUTHORS
Modified:
   haypo/hachoir/fallback/magic.py
   haypo/hachoir/plugins/avi.py
   haypo/hachoir/ui/hachoir.glade
Log:
Commit patch of Aur?\195?\169lien Jacobs and add him in AUTHORS list (create AUTHORS
file and update About dialog). Patch:
- Fix fallback/magic.py MIME type of AVI file
- Improve AVI plugin: can read more audio/video headers


Added: haypo/hachoir/AUTHORS
===================================================================
--- haypo/hachoir/AUTHORS	2005-12-19 15:15:41 UTC (rev 340)
+++ haypo/hachoir/AUTHORS	2005-12-20 13:45:51 UTC (rev 341)
@@ -0,0 +1,2 @@
+Aur?lien Jacobs - <aurel AT gnuage.org>
+Victor Stinner - <victor.stinner AT haypocalc.com>

Modified: haypo/hachoir/fallback/magic.py
===================================================================
--- haypo/hachoir/fallback/magic.py	2005-12-19 15:15:41 UTC (rev 340)
+++ haypo/hachoir/fallback/magic.py	2005-12-20 13:45:51 UTC (rev 341)
@@ -115,6 +115,7 @@
   [0L, 'string', '=', 'SBI', 'audio/x-sbi'],
   [0L, 'string', '=', 'Creative Voice File', 'audio/x-voc'],
   [0L, 'belong', '=', 1314148939L, 'audio/x-multitrack'],
+  [8L, 'string', '=', 'AVI ', 'video/x-msvideo'],
   [0L, 'string', '=', 'RIFF', 'audio/x-wav'],
   [0L, 'string', '=', 'EMOD', 'audio/x-emod'],
   [0L, 'belong', '=', 779248125L, 'audio/x-pn-realaudio'],

Modified: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-19 15:15:41 UTC (rev 340)
+++ haypo/hachoir/plugins/avi.py	2005-12-20 13:45:51 UTC (rev 341)
@@ -19,10 +19,35 @@
             while 8 <= end - stream.tell():
                 chunk = self.readChild("chunk[]", AVI_Chunk)            
         elif tag == "strl":
+            stype = None
             while 8 <= end - stream.tell():
                 stag = self.read("stag[]", "4s", "String tag").value
                 size = self.read("ssize[]", "<L", "String size").value
-                if stag == "strf" and size == 40:
+                if stag == "strh" and size >= 56:
+                    # Stream header
+                    hend = stream.tell() + size
+                    stype = self.read("type_fourcc", "4s", "Stream type four character code").value
+                    self.read("fourcc", "4s", "Stream four character code")
+                    self.read("flags", "<L", "Stream flags")
+                    self.read("priority", "<H", "Stream priority")
+                    self.read("langage", "2s", "Stream language")
+                    self.read("init_frames", "<L", "InitialFrames")
+                    self.read("scale", "<L", "Time scale")
+                    self.read("rate", "<L", "Divide by scale to give frame rate")
+                    self.read("start", "<L", "Stream start time (unit: rate/scale)")
+                    self.read("length", "<L", "Stream length (unit: rate/scale)")
+                    self.read("buf_size", "<L", "Suggested buffer size")
+                    self.read("quality", "<L", "Stream quality")
+                    self.read("sample_size", "<L", "Size of samples")
+                    self.read("left", "<H", "Destination rectangle (left)")
+                    self.read("top", "<H", "Destination rectangle (top)")
+                    self.read("right", "<H", "Destination rectangle (right)")
+                    self.read("bottom", "<H", "Destination rectangle (bottom)")
+                    diff = hend-stream.tell()
+                    if 0 < diff:
+                        self.read("h_extra", "%us" % diff, "Extra junk")
+                    assert stream.tell() == hend
+                elif stag == "strf" and stype == "vids" and size == 40:
                     # Video header
                     self.read("v_size", "<L", "Video format: Size")                    
                     self.read("v_width", "<L", "Video format: Width")                    
@@ -35,21 +60,29 @@
                     self.read("v_ypels_meter", "<L", "Video format: YPelsPerMeter")
                     self.read("v_clr_used", "<L", "Video format: ClrUsed")
                     self.read("v_clr_importand", "<L", "Video format: ClrImportant")
-                elif stag == "strf" and size == 30:
+                elif stag == "strf" and stype == "auds":
                     # Audio (wav) header
                     aend = stream.tell() + size
-                    self.read("a_id", "<H", "Audio format: ID")                    
-                    self.read("a_channel", "<H", "Audio format: Channels")                    
+                    self.read("a_id", "<H", "Audio format: Codec id")                    
+                    a_chan = self.read("a_channel", "<H", "Audio format: Channels").value
                     self.read("a_sample_rate", "<L", "Audio format: Sample rate")                    
                     self.read("a_bit_rate", "<L", "Audio format: Bit rate")
                     self.read("a_block_align", "<H", "Audio format: Block align")
-                    #?if size == 14: bits_per_sample = 8
-                    self.read("a_bits_per_sample", "<H", "Audio format: Bits per sample")
-                    self.read("a_codec_id", "<H", "Audio format: Codec id")
+                    if size >= 16:
+                        self.read("a_bits_per_sample", "<H", "Audio format: Bits per sample")
+                    if size >= 18:
+                        self.read("ext_size", "<H", "Audio format: Size of extra information")
+                    if a_chan > 2 and size >= 28:
+                        self.read("reserved", "<H", "Audio format: ")
+                        self.read("channel_mask", "<L", "Audio format: channels placement bitmask")
+                        self.read("subformat", "<L", "Audio format: Subformat id")
                     diff = aend-stream.tell()
                     if 0 < diff:
                         self.read("a_extra", "%us" % diff, "Audio format: Extra")
                     assert stream.tell() == aend
+                elif stag == "strn":
+                    # Stream description
+                    self.read("desc", "%us" % size, "Stream description")
                 else:
                     self.read("svalue[]", "%us" % size, "String value")
         else:

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-12-19 15:15:41 UTC (rev 340)
+++ haypo/hachoir/ui/hachoir.glade	2005-12-20 13:45:51 UTC (rev 341)
@@ -1459,7 +1459,8 @@
   <property name="wrap_license">False</property>
   <property name="website">http://www.haypocalc.com/wiki/Hachoir</property>
   <property name="website_label" translatable="yes">Website</property>
-  <property name="authors">Victor Stinner &lt;victor.stinner AT haypocalc.com&gt;</property>
+  <property name="authors">Aur?lien Jacobs - &lt;aurel AT gnuage.org&gt;
+Victor Stinner &lt;victor.stinner AT haypocalc.com&gt;</property>
   <property name="translator_credits" translatable="yes" comments="TRANSLATORS: Replace this string with your names, one name per line.">translator-credits</property>
 </widget>
 



From haypo at berlios.de  Tue Dec 20 14:48:59 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 20 Dec 2005 14:48:59 +0100
Subject: [Happyboom-svn] r342 - haypo/hachoir/plugins
Message-ID: <200512201348.jBKDmxcV026258@sheep.berlios.de>

Author: haypo
Date: 2005-12-20 14:48:54 +0100 (Tue, 20 Dec 2005)
New Revision: 342

Added:
   haypo/hachoir/plugins/bmp.py
   haypo/hachoir/plugins/worms2.py
Modified:
   haypo/hachoir/plugins/id3.py
   haypo/hachoir/plugins/pcx.py
   haypo/hachoir/plugins/rpm.py
Log:
- Create plugins BMP and WORMS2.
- Small bugfixes in plugins PCX and RPM.
- RPM plugin can now read full signature and header data
- RPM plugin can read file content using GZIP plugin


Added: haypo/hachoir/plugins/bmp.py
===================================================================
--- haypo/hachoir/plugins/bmp.py	2005-12-20 13:45:51 UTC (rev 341)
+++ haypo/hachoir/plugins/bmp.py	2005-12-20 13:48:54 UTC (rev 342)
@@ -0,0 +1,32 @@
+"""
+Microsoft Bitmap picture parseer.
+
+Author: Victor Stinner
+Creation: 16 december 2005
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class BitmapFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "bmp_file", "Bitmap picture file (BMP)", stream, parent)
+        self.read("header", "!2s", "Header (\"BM\")")
+        self.read("file_size", "<L", "File size (bytes)")
+        self.read("notused", "<L", "Reseved")
+        self.read("data_start", "<L", "Data start position")
+        header_size = self.read("header_size", "<L", "Header size").value
+        assert header_size in (12, 40)
+        self.read("width", "<L", "Width (pixels)")
+        self.read("height", "<L", "Height (pixels)")
+        self.read("nb_plan", "<H", "Number of plan (=1)")
+        self.read("bits_pixel", "<H", "Bits per pixel")
+        if header_size == 40:
+            self.read("compression", "<L", "Compression method")
+            self.read("image_size", "<L", "Image size (bytes)")
+            self.read("horizontal_dpi", "<L", "Horizontal DPI")
+            self.read("vertical_dpi", "<L", "Vertical DPI")
+            self.read("used_colors", "<L", "Number of color used")
+            self.read("important_color", "<L", "Number of import colors")
+
+registerPlugin(BitmapFile, "image/x-ms-bmp")

Modified: haypo/hachoir/plugins/id3.py
===================================================================
--- haypo/hachoir/plugins/id3.py	2005-12-20 13:45:51 UTC (rev 341)
+++ haypo/hachoir/plugins/id3.py	2005-12-20 13:48:54 UTC (rev 342)
@@ -81,8 +81,9 @@
         size = self["size"]
         if tag in ID3_Chunk.handler:
             end = stream.tell() + size
-            substream = stream.createLimited(size=size)
-            self.readStreamChild("content", substream, ID3_Chunk.handler[tag])
+            if size != 0:
+                substream = stream.createLimited(size=size)
+                self.readStreamChild("content", substream, ID3_Chunk.handler[tag])
             assert stream.tell() == end
         else:
             self.read("data", "%us" % size, "Raw data")

Modified: haypo/hachoir/plugins/pcx.py
===================================================================
--- haypo/hachoir/plugins/pcx.py	2005-12-20 13:45:51 UTC (rev 341)
+++ haypo/hachoir/plugins/pcx.py	2005-12-20 13:48:54 UTC (rev 342)
@@ -9,10 +9,12 @@
 
 class RGB(Filter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
+        Filter.__init__(self, "rgb_color", "RGB color", stream, parent)
         self.read("red", "B", "Red")
         self.read("green", "B", "Green")
         self.read("blue", "B", "Blue")
+    def updateParent(self, chunk):
+        chunk.description = "RGB color: #%02X%02X%02X" % (self["red"], self["green"], self["blue"])
 
 class Palette(Filter):
     def __init__(self, stream, parent, count):

Modified: haypo/hachoir/plugins/rpm.py
===================================================================
--- haypo/hachoir/plugins/rpm.py	2005-12-20 13:45:51 UTC (rev 341)
+++ haypo/hachoir/plugins/rpm.py	2005-12-20 13:48:54 UTC (rev 342)
@@ -6,8 +6,23 @@
 
 from filter import Filter
 from plugin import registerPlugin
+from format import getFormatSize
+from gzip import GzipFile
 
 class RpmItem(Filter):
+    format = {
+        #  (use FormatChunk? else use StringChunk, chunk format, count)
+        0: (True, "B", 1),
+        1: (True, "c", 1),
+        2: (True, "B", 1),
+        3: (True, "H", 1),
+        4: (True, "L", 1),
+        5: (True, "L", 2),
+        6: (False, "C", 1),
+        7: (True, "s", 1),
+        8: (True, "s", 1),
+        9: (False, "C", 1)
+    }
     type_name = {
         0: "NULL",
         1: "CHAR",
@@ -17,8 +32,24 @@
         5: "INT64",
         6: "STRING",
         7: "BIN",
-        8: "STRING_ARRAY"
+        8: "STRING_ARRAY",
+        9: "STRING?"
     }
+    tag_name = {
+        1000: "File size",
+        1001: "(Broken) MD5 signature",
+        1002: "PGP 2.6.3 signature",
+        1003: "(Broken) MD5 signature",
+        1004: "MD5 signature",
+        1005: "GnuPG signature",
+        1006: "PGP5 signature",
+        1007: "Uncompressed payload size (bytes)",
+        256+8: "Broken SHA1 header digest",
+        256+9: "Broken SHA1 header digest",
+        256+13: "Broken SHA1 header digest",
+        256+11: "DSA header signature",
+        256+12: "RSA header signature"
+    }
     
     def __init__(self, stream, parent):
         Filter.__init__(self, "rpm_item", "RPM item", stream, parent)
@@ -32,11 +63,148 @@
 
     def updateParent(self, chunk):
         type = self.getType(self["type"])
-        chunk.description = "RPM item (%s)" % type
+        tag = self.getTagName()
+        chunk.description = "RPM item: %s (%s)" % (tag, type)
+        
+    def getTagName(self):
+        tag = self["tag"]
+        return RpmItem.tag_name.get(tag, "Unknow tag (%s)" % tag)
 
+    def doRead(self, filter):
+        type = self["type"]
+        desc = "Value of item %s, %s" % (self.getId(), self.getDescription())
+        if type != 8:
+            format = RpmItem.format[type]
+            if format[0]:
+                if 2 < self["count"] and format[1] != "s":
+                    format = "!" + str(format[2] * self["count"] * getFormatSize(format[1])) + "s"
+                else:
+                    format = "!" + str(format[2] * self["count"]) + format[1]
+                filter.read("data[]", format, desc)
+            else:     
+                format = format[1]
+                filter.readString("data[]", format, desc)
+        else:
+            id = filter.getUniqChunkId("data[]")
+            for i in range(0, self["count"]):
+                filter.readString(id+"[]", "C", desc)
+    
     def getType(self, type):
         return RpmItem.type_name.get(type, "Unknow type (%s)" % type)
 
+class RpmHeaderItem(RpmItem):
+    tag_name = {
+        61: "Current image",
+        62: "Signatures",
+        63: "Immutable",
+        64: "Regions",
+        100: "I18N string locales",
+        1000: "Name",
+        1001: "Version",
+        1002: "Release",
+        1003: "Epoch",
+        1004: "Summary",
+        1005: "Description",
+        1006: "Build time",
+        1007: "Build host",
+        1008: "Install time",
+        1009: "Size",
+        1010: "Distribution",
+        1011: "Vendor",
+        1012: "Gif",
+        1013: "Xpm",
+        1014: "Licence",
+        1015: "Packager",
+        1016: "Group",
+        1017: "Changelog",
+        1018: "Source",
+        1019: "Patch",
+        1020: "Url",
+        1021: "OS",
+        1022: "Arch",
+        1023: "Prein",
+        1024: "Postin",
+        1025: "Preun",
+        1026: "Postun",
+        1027: "Old filenames",
+        1028: "File sizes",
+        1029: "File states",
+        1030: "File modes",
+        1031: "File uids",
+        1032: "File gids",
+        1033: "File rdevs",
+        1034: "File mtimes",
+        1035: "File MD5s",
+        1036: "File link to's",
+        1037: "File flags",
+        1038: "Root",
+        1039: "File username",
+        1040: "File groupname",
+        1043: "Icon",
+        1044: "Source rpm",
+        1045: "File verify flags",
+        1046: "Archive size",
+        1047: "Provide name",
+        1048: "Require flags",
+        1049: "Require name",
+        1050: "Require version",
+        1051: "No source",
+        1052: "No patch",
+        1053: "Conflict flags",
+        1054: "Conflict name",
+        1055: "Conflict version",
+        1056: "Default prefix",
+        1057: "Build root",
+        1058: "Install prefix",
+        1059: "Exclude arch",
+        1060: "Exclude OS",
+        1061: "Exclusive arch",
+        1062: "Exclusive OS",
+        1064: "RPM version",
+        1065: "Trigger scripts",
+        1066: "Trigger name",
+        1067: "Trigger version",
+        1068: "Trigger flags",
+        1069: "Trigger index",
+        1079: "Verify script",
+        #TODO: Finish the list (id 1070..1162 using rpm library source code)
+    }
+        
+    def getTagName(self):
+        tag = self["tag"]
+        return RpmHeaderItem.tag_name.get(tag, "Unknow tag (%s)" % tag)
+            
+def sortRpmItem(a,b):
+    return int( a["offset"] - b["offset"] )
+
+class Header(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "header", "Header", stream, parent)
+        id = self.read("id", "4s", "Identifier").value
+        assert id == "\x8E\xAD\xE8\x01"
+        self.read("padding", "4s", "Padding")
+        self.read("count", "!L", "Count")
+        self.read("size", "!L", "Store size")
+        items = []
+        for i in range(0, self["count"]):
+            item = self.readChild("item[]", RpmHeaderItem).getFilter()
+            items.append(item)
+        items.sort( sortRpmItem )
+
+        start = stream.tell()
+        end = stream.tell() + self["size"]
+        for item in items:
+            offset = item["offset"]
+            diff = offset - (stream.tell() - start)
+            if 0 < diff:
+                self.read("padding[]", "%us" % diff, "Padding")
+
+            print "Read %s" % item.getId()                
+            item.doRead(self)
+        size = end - stream.tell()
+        if 0 < size:    
+            self.read("padding[]", "%us" % size, "Padding")
+
 class RpmSignature(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "rpm_sig", "RPM signature", stream, parent)
@@ -46,9 +214,24 @@
         self.read("reserved", "4s", "Reserved")
         self.read("count", "!L", "Count")
         self.read("size", "!L", "Size")
+        items = []
         for i in range(0, self["count"]):
-            self.readChild("item[]", RpmItem)
+            item = self.readChild("item[]", RpmItem).getFilter()
+            items.append(item)
+        items.sort( sortRpmItem )
 
+        start = stream.tell()
+        end = stream.tell() + self["size"]
+        for item in items:
+            offset = item["offset"]
+            diff = offset - (stream.tell() - start)
+            if 0 < diff:
+                self.read("padding[]", "%us" % diff, "Padding")
+            item.doRead(self)
+        size = end - stream.tell()
+        if 0 < size:    
+            self.read("padding[]", "%us" % size, "Padding")
+
 class RpmFile(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "rpm_file", "RPM File", stream, parent)
@@ -62,7 +245,10 @@
         self.read("osnum", "!H", "OS")
         self.read("signature_type", "!H", "Type of signature")
         self.read("reserved", "16s", "Reserved")
-        self.readChild("sig", RpmSignature)
+        self.readChild("signature", RpmSignature)
+        self.readChild("header", Header)
+        sub = stream.createSub()
+        self.readStreamChild("gz_content", sub, GzipFile)
 
     def postType(self, chunk):
         if chunk.value == 0:

Added: haypo/hachoir/plugins/worms2.py
===================================================================
--- haypo/hachoir/plugins/worms2.py	2005-12-20 13:45:51 UTC (rev 341)
+++ haypo/hachoir/plugins/worms2.py	2005-12-20 13:48:54 UTC (rev 342)
@@ -0,0 +1,83 @@
+"""
+Worms2 DIR file.
+"""
+
+from plugin import registerPlugin 
+from filter import Filter
+from plugin import registerPlugin
+from tools import humanFilesize
+
+class Worms2_Image(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "worms2_image", "Worms2 image", stream, parent)
+        nb_color = 244/3
+        self.read("palette", "%us" % (nb_color*3), "Palette (%u colors)" % nb_color)
+        self.read("padding", "B", "Padding")
+        self.read("width", "<H", "Width")
+        self.read("height", "<H", "Height")
+        size = self["width"] * self["height"]
+        self.read("img_data", "%us" % size, "Data")
+        size = stream.getSize() - stream.tell()
+        self.read("end", "%us" % size, "Raw end")
+
+class Worms2_Sprite(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
+        # TODO ...
+        size = stream.getSize() - stream.tell()
+        self.read("end", "%us" % size, "Raw end")
+
+class Worms2_Font(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
+        self.read("palette", "%us" % (244+33), "Palette (?)")
+        self.read("charset", "%us" % (32), "Charset")
+        self.read("data", "%us" % (32+30+4+136), "Data")
+        # TODO ...
+        size = stream.getSize() - stream.tell()
+        self.read("end", "%us" % size, "Raw end")
+
+class Worms2_Resource(Filter):
+    handler = {
+        "IMG": Worms2_Image,
+        "SPR": Worms2_Sprite,
+        "FNT": Worms2_Font
+    }
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "worms2_res", "Worms2 resource", stream, parent)
+        pos = stream.tell()
+        self.tag = self.read("tag", "3s", "Type").value.strip("\0\n")
+        self.valid = self.tag.strip("\0\n") != ""
+        self.read("tag_end", "1s", "Type end")
+        size = self.read("size", "<L", "Size").value
+        if not self.valid:
+            return
+        self.readString("name", "C", "Name")
+        size = pos + size + 1 - stream.tell()
+        if self.tag in Worms2_Resource.handler:
+            sub = stream.createSub(size=size)
+            self.readStreamChild("data", sub, Worms2_Resource.handler[self.tag])
+        else:
+            self.read("data", "%us" % size, "Data")
+
+    def updateParent(self, chunk):            
+        size = humanFilesize(self["size"])
+        tag = self.tag
+        if tag != "":
+            name = self["name"]
+        else:
+            tag = "(invalid)"
+            name = "(invalid)"
+        chunk.description = "Resource \"%s\" (type=%s, size=%s)" % (name, tag, size)
+
+class Worms2_Dir_File(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent)
+        self.read("id", "3s", "Identifier (DIR)")
+        self.read("raw", "%us" % (12-stream.tell()), "Raw data")
+        while stream.tell() < 3432805:
+            file = self.readChild("file[]", Worms2_Resource).getFilter()
+            if not file.valid:
+                break
+         
+registerPlugin(Worms2_Dir_File, "hachoir/worms2")



From haypo at berlios.de  Tue Dec 20 14:51:06 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 20 Dec 2005 14:51:06 +0100
Subject: [Happyboom-svn] r343 - haypo/hachoir
Message-ID: <200512201351.jBKDp6IQ027462@sheep.berlios.de>

Author: haypo
Date: 2005-12-20 14:51:03 +0100 (Tue, 20 Dec 2005)
New Revision: 343

Modified:
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
Log:
Small fixes in Hachoir class: add padding (again) if needed after parsing a
file. Add some print to display launching progression.


Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-12-20 13:48:54 UTC (rev 342)
+++ haypo/hachoir/hachoir.py	2005-12-20 13:51:03 UTC (rev 343)
@@ -99,6 +99,7 @@
             setattr(hachoir, key, opt[key])
         if hachoir.load_ui:
             try:
+                print "Load user interface"
                 ui.loadInterface(hachoir)
             except ImportError, err:
                 error("""Error: a Python module is missing:
@@ -119,13 +120,12 @@
             else:
                 str_filename = "None"
             profile.run('global hachoir; hachoir.run(%s)' % str_filename, stat_filename)
-            # .sort_stats('time')
-            pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
+            #pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
+            pstats.Stats(stat_filename).sort_stats('time').print_stats()
             os.unlink(stat_filename)
         else:
             hachoir.run(filename)
 
-
     except SystemExit:
         pass
     except Exception, err:

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-12-20 13:48:54 UTC (rev 342)
+++ haypo/hachoir/hachoir_class.py	2005-12-20 13:51:03 UTC (rev 343)
@@ -28,7 +28,6 @@
         self._main_filter = filter
         self._filter = filter
         if filter != None:
-#            self._addPadding()
             if self.load_ui:
                 self._filter.display()
                 self.ui.window.info.updateFilter(filter)
@@ -85,19 +84,15 @@
         my.exportPython(filename)
         
     def _addPadding(self):
-        filter_size = self._filter.getSize()
-        stream_size = self._filter.getStream().getSize()
+        filter_size = self._main_filter.getSize()
+        stream_size = self._main_filter.getStream().getSize()
         diff_size = filter_size - stream_size
         if diff_size < 0:
-            chunks = self._filter.getChunks()
-            if len(chunks) != 0:
-                last_chunk = chunks[-1]
-            else:
-                last_chunk = None
-            self._filter.addRawChunk(last_chunk, "end", "%u" % (-diff_size), "")
+            self._main_filter.read("end", "%us" % (-diff_size), "Raw data")
 
     def loadFile(self, filename):
         try:
+            print "Load file %s" % filename
             file = open(filename, 'r')
             stream = FileStream(file, filename)
         except IOError, err:
@@ -122,6 +117,8 @@
                 % (filename, msg))
             stream.seek(0)
             filter = DefaultFilter(stream)
+        self._main_filter = filter
+        self._addPadding()
         self.setFilter(filter)
 
     def loadScript(self, filename):
@@ -141,4 +138,5 @@
         elif filename != None:
             self.loadFile(filename)
         if self.load_ui:
+            print "Run user interface ..."
             self.ui.run()      



From haypo at berlios.de  Tue Dec 20 15:04:41 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 20 Dec 2005 15:04:41 +0100
Subject: [Happyboom-svn] r344 - in haypo/hachoir: . plugins stream ui
Message-ID: <200512201404.jBKE4f5O001986@sheep.berlios.de>

Author: haypo
Date: 2005-12-20 15:04:36 +0100 (Tue, 20 Dec 2005)
New Revision: 344

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/mime.py
   haypo/hachoir/plugins/3ds.py
   haypo/hachoir/plugins/ext2.py
   haypo/hachoir/stream/stream.py
   haypo/hachoir/ui/ui_popup.py
   haypo/hachoir/ui/ui_window.py
Log:
- OnlyFormatChunksFilter can now also read strings.
- OnlyFormatChunksFilter can add keywords to chunks
- Fix 3DS filter: can read map uv, polygon list and vertex list (using
  new fast OnlyFormatChunksFilter filter class). Fix also readPolygonList
  which was buggy (didn't read sub-chunks).
- Only use OnlyFormatChunksFilter in EXT2 plugin
- EXT2 plugin can read groups (and rename Group class to GroupDescriptor)
- EXT2 plugin can read superblock copies (in groups).
- Small bugfix in LimitedStream: smallest size is 1 and not 2 ;-)
- Chunk.getFormat() now returns full chunk format (class + parameters) and
  Chunk.getSmallFormat() is used in display (just parameters).
- Replace event button_release_event with cursor-changed in window ui, so
  changing active cell in table also update informations about active chunk.
- Add Worms2 dir file MIME tester
- Small bugfix in MIME (only test filename extension if filename is
  defined...)


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/chunk.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -23,8 +23,11 @@
             self.display = self.post_process(self)
 
     def getFormat(self):
-        return self.__class__
+        return self.__class__.__name__
 
+    def getSmallFormat(self):
+        return self.__class__.__name__
+
     def update(self):
         self.display = None
         self.postProcess()
@@ -94,8 +97,11 @@
         return FilterChunk(self.id, filter_copy, self.getParent(), parent_addr)
     
     def getFormat(self):
-        return self._filter.getId()
+        return self.__class__.__name__ + " (%s)" % self._filter.__class__.__name__
 
+    def getSmallFormat(self):
+        return self._filter.__class__.__name__
+
     def update(self):
         new = self._filter.clone()
         if new != None:
@@ -167,9 +173,11 @@
         self.strip = strip
 
     def getFormat(self):
-        assert self._str_type in StringChunk.names
         return StringChunk.names[self._str_type]
 
+    def getSmallFormat(self):
+        return StringChunk.names[self._str_type]
+
     def _findSize(self):
         self._stream.seek(self.addr)
         if self._str_type == "Pascal16":
@@ -282,6 +290,9 @@
     addr = property(Chunk._getAddr, _setAddr)
 
     def getFormat(self):
+        return self.__class__.__name__ + " (%s)" % self._format
+
+    def getSmallFormat(self):
         return self._format
 
     def isString(self):
@@ -303,7 +314,6 @@
         size = getFormatSize(format)
         if self._stream.getLastPos() < (self.addr + size - 1):
             raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
-        self._cache.setFormat(format)
 
         # Update format
         old_size = self._size

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/filter.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -31,6 +31,7 @@
     def getStream(self): return self._stream
     def purgeCache(self): pass
     def updateChunkDescription(self, id, desc): pass
+    def __len__(self): return len(self._chunks_dict)
 
     def getPath(self):
         """
@@ -53,25 +54,30 @@
         return self._chunks_counter[root]
 
     def getUniqChunkId(self, id):
+        # No collision
+        if id not in self._chunks_dict and id[-2:] != "[]":
+            return id
+
         # Pattern like "block[]"
         if id[-2:] == "[]":
             root = id[:-2]
-            index = self._getUniqChunkId(root, 0)
-            return root+"["+str(index)+"]" 
-
-        # No collision
-        if id not in self._chunks_dict:
-            return id
-
-        # Manage id collision
-        m = Filter.regex_chunk_uniq_id.match(id)
-        if m != None:
-            root = m.group(1)
-            index = self._getUniqChunkId(root, int(m.group(2))+1)
+            start = 0
+            pattern = "%s[%u]"
         else:
-            root = id
-            index = self._getUniqChunkId(root, 2)
-        return root+str(index)
+            # Manage id collision
+            m = Filter.regex_chunk_uniq_id.match(id)
+            if m != None:
+                root = m.group(1)
+                start = int(m.group(2)) + 1
+            else:
+                root = id
+                start = 2
+            pattern = "%s%u"
+        if root in self._chunks_counter:
+            self._chunks_counter[root] = self._chunks_counter[root] + 1
+        else:
+            self._chunks_counter[root] = start 
+        return pattern % (root, self._chunks_counter[root])
 
     # --- Pure virtual methods -----------
     def getSize(self): assert False
@@ -92,18 +98,8 @@
         assert pos != -1
         self._chunks_dict[id][1] = desc
 
-        info = self._chunks_dict[id]
-        chunk_class = info[4][0]
-        if issubclass(chunk_class, BasicFilter):
-            display = "(...)"
-            format = chunk_class.__name__ 
-        else:
-            chunk = self.getChunk(id)
-            display = chunk.getDisplayData()
-            format = chunk.getFormat()
-        addr = info[2]
-        size = info[3]
-        ui.window.update_table(self, pos, None, addr, size, format, info[0], info[1], display)
+        info = self.displayChunkInfo(id)
+        ui.window.update_table(self, pos, *info)
 
     def purgeCache(self):
         if len(self._chunks_cache) != 0:
@@ -130,6 +126,8 @@
         
         if size == None:
             filter = filter_class(filter_stream, self, *args)
+            description = filter.getDescription()
+            filter.setId(id)
             chunk = FilterChunk(id, filter, self, addr)
             size = filter.getSize()
             if config.verbose:
@@ -138,13 +136,12 @@
             chunk = None
 
         chunk_info = [id, description, addr, size, \
-                (filter_class, filter_stream, filter_addr, args), None]
+                (filter_class, filter_stream, filter_addr, args), None, {}]
         self._chunks_dict[id] = chunk_info
         self._chunks.append(id)
         if chunk != None:
             filter.updateParent(chunk)
             self._chunks_cache[id] = chunk
-
         self._size = self._size + size
         self._stream.seek(addr + size)
         return id
@@ -158,29 +155,49 @@
         size = getFormatSize(format)
         addr = self._stream.tell()
         chunk_info = [id, description, addr, size, \
-                (FormatChunk, id, description, self._stream, addr, format, self,), post]
+                (FormatChunk, id, description, self._stream, addr, format, self,), post, {}]
         self._chunks_dict[id] = chunk_info
         self._chunks.append(id)
         self._stream.seek(size, 1)
         self._size = self._size + size
         return id
 
+    def readString(self, id, format, description, post=None, strip=None):
+        id = self.getUniqChunkId(id)
+        addr = self._stream.tell()
+
+        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
+        size = chunk.size
+
+        chunk_info = [id, description, addr, size, \
+                (StringChunk, id, description, self._stream, format, self,), post, {"strip": strip}]
+        self._chunks_dict[id] = chunk_info
+        self._chunks.append(id)
+        self._chunks_cache[id] = chunk
+#        self._stream.seek(size, 1)
+        self._size = self._size + size
+        return id
+
+    def displayChunkInfo(self, id):
+        info = self._chunks_dict[id]
+        chunk_class = info[4][0]
+        if issubclass(chunk_class, BasicFilter):
+            display = "(...)"
+            format = chunk_class.__name__
+        else:
+            chunk = self.getChunk(id)
+            display = chunk.getDisplayData()
+            format = chunk.getSmallFormat()
+        addr = info[2]
+        size = info[3]
+        return (None, addr, size, format, info[0], info[1], display)
+
     def display(self):
         ui.window.enableParentButton(self.getParent() != None)
         ui.window.clear_table()
         for id in self._chunks:
-            info = self._chunks_dict[id]
-            chunk_class = info[4][0]
-            if issubclass(chunk_class, BasicFilter):
-                display = "(...)"
-                format = chunk_class.__name__ 
-            else:
-                chunk = self.getChunk(id)
-                display = chunk.getDisplayData()
-                format = chunk.getFormat()
-            addr = info[2]
-            size = info[3]
-            ui.window.add_table(None, addr, size, format, info[0], info[1], display)
+            info = self.displayChunkInfo(id)
+            ui.window.add_table(*info)
  
     def getSize(self): return self._size
 
@@ -188,6 +205,7 @@
         addr = self._chunks_dict[id][2]
         desc = self._chunks_dict[id][4]
         post = self._chunks_dict[id][5]
+        chunks_kw = self._chunks_dict[id][6]
         oldpos = self._stream.tell()
         self._stream.seek(addr)
         if config.verbose:
@@ -195,7 +213,7 @@
         if not issubclass(desc[0], BasicFilter):
             chunk_class = desc[0]
             chunk_args = desc[1:]
-            chunk = chunk_class(*chunk_args)
+            chunk = chunk_class(*chunk_args, **chunks_kw)
             if post != None:
                 chunk.display = post(chunk)
         else:
@@ -203,7 +221,10 @@
             if filter_stream != self._stream:
                 filter_stream.seek(desc[2])
             filter = desc[0] (filter_stream, self, *desc[3])
+            filter.setId(id)
             chunk = FilterChunk(id, filter, self, addr)
+            if filter.getDescription() != desc[1]:
+                self.updateChunkDescription(id, filter.getDescription())
             filter.updateParent(chunk)
         self._stream.seek(oldpos)
         return chunk
@@ -479,7 +500,7 @@
         return chunk
 
     def displayChunk(self, chunk):
-        type = chunk.getFormat()
+        type = chunk.getSmallFormat()
         if isinstance(chunk, FilterChunk):
             addr = chunk.parent_addr
         else:

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/mime.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -84,6 +84,9 @@
     and buffer[1116:1120]=="\x04\x00\x00\x00":
         return "hachoir/fs-ext2"
         
+    if buffer[0:3] == "DIR":
+        return "hachoir/worms2"
+        
     if 512<=len(buffer) \
     and buffer[0] in "\xEB\xFA" \
     and buffer[510:512] == "\x55\xAA" \
@@ -129,9 +132,9 @@
     mimes = instance.guess(buffer)
     mimes = splitMimes(mimes)
     if len(mimes) == 0 or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
-        ext = os.path.splitext(filename)[1]
         new_mime = getAnotherBufferMime(buffer)
-        if new_mime == None:
+        if new_mime == None and filename != None:
+            ext = os.path.splitext(filename)[1]
             new_mime = getMimeByExt(ext)
         if new_mime != None:
             mimes = ((new_mime,),)

Modified: haypo/hachoir/plugins/3ds.py
===================================================================
--- haypo/hachoir/plugins/3ds.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/plugins/3ds.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -3,10 +3,10 @@
 Author: Victor Stinner
 """
 
-from filter import Filter
+from filter import Filter, OnlyFormatChunksFilter
 from plugin import registerPlugin
 
-def readTextureFilename(filter, stream):
+def readTextureFilename(filter, stream, last_pos):
     filter.readString("filename", "C", "Texture filename")
 
 def readVersion(filter, stream, last_pos):
@@ -14,13 +14,11 @@
 
 def readMaterialName(filter, stream, last_pos):
     filter.readString("name", "C", "Material name")
-#    while not stream.eof():
-#        filter.readChild("chunk[]", Filter_3DS_Chunk)
 
 def readObject(filter, stream, last_pos):
     chunk = filter.readString("name", "C", "Object name")
     while stream.tell() < last_pos:
-        filter.readChild("chunk[]", Filter_3DS_Chunk)
+        filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
 
 class Filter_3DS_MapUV(Filter):
     def __init__(self, stream, parent):
@@ -46,7 +44,7 @@
 def readMapList(filter, stream, last_pos):
     filter.read("count", "<H", "Map count")
     for i in range(0, filter["count"]):
-        filter.readChild("map[]", Filter_3DS_MapUV)
+        filter.readSizedChild("map[]", "Map UV", 2*4, Filter_3DS_MapUV)
 
 def readColor(filter, stream, last_pos):
     filter.read("red", "B", "Red componant")
@@ -56,14 +54,16 @@
 def readVertexList(filter, stream, last_pos):
     filter.read("count", "<H", "Vertex count")
     for i in range(0, filter["count"]):
-        filter.readChild("vertex[]", Filter_3DS_Vertex)
+        filter.readSizedChild("vertex[]", "Vertex", 3*4, Filter_3DS_Vertex)
     
 def readPolygonList(filter, stream, last_pos):
     filter.read("count", "<H", "Vertex count")
     for i in range(0, filter["count"]):
-        filter.readChild("polygon[]", Filter_3DS_Polygon)
+        filter.readSizedChild("polygon[]", "Polygon", 4*2, Filter_3DS_Polygon)
+    while stream.tell() < last_pos:
+        filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
 
-class Filter_3DS_Chunk(Filter):
+class Filter_3DS_Chunk(OnlyFormatChunksFilter):
     # List of chunk type name
     type_name = {
         0x0011: "Color",
@@ -119,14 +119,14 @@
         0x0011: readColor,
         0x0002: readVersion,
 # TODO: Uncomment these functions, it's too slow yet            
-#         0x4110: readVertexList,
-#         0x4120: readPolygonList,
-#         0x4140: readMapList
+         0x4110: readVertexList,
+         0x4120: readPolygonList,
+         0x4140: readMapList
     }
     
     def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
-        chunk = self.read("type", "<H", "Chunk type", post=self.toHex)
+        OnlyFormatChunksFilter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
+        chunk = self.doRead("type", "<H", "Chunk type", post=self.toHex)
         chunk.description = "Chunk type (%s)" % self.getType()
         self.read("size", "<L", "Chunk size")
         size = self["size"] - 6
@@ -134,7 +134,7 @@
         end = stream.tell() + size
         if type in Filter_3DS_Chunk.sub_chunks:
             while stream.tell() < end:
-                self.readChild("chunk[]", Filter_3DS_Chunk)
+                self.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
             assert stream.tell() == end 
         else:
             if type in Filter_3DS_Chunk.handlers: 
@@ -153,12 +153,12 @@
         self.setDescription("Chunk type (%s)" % type)
         if self["type"] in Filter_3DS_Chunk.chunk_id_by_type:
             id = Filter_3DS_Chunk.chunk_id_by_type[self["type"]]
+# TODO: Re-enable that            
 #            chunk.id = id
             self.setId(id) 
         else:
             self.setId("chunk_%04x" % self["type"])
 
-
     def toHex(self, chunk):
         return "%04X" % chunk.value
         

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/plugins/ext2.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -11,7 +11,7 @@
 from datetime import datetime
 from filter import Filter, OnlyFormatChunksFilter, OnlyFiltersFilter
 from plugin import registerPlugin
-from tools import humanDuration, getUnixRWX 
+from tools import humanDuration, getUnixRWX, humanFilesize
 
 class DirectoryEntry(OnlyFormatChunksFilter):
     file_type = {
@@ -80,7 +80,7 @@
         self.read("file_acl", "<L", "File ACL")
         self.read("dir_acl", "<L", "Directory ACL")
         self.read("faddr", "<L", "Block where the fragment of the file resides")
-        os = parent.getParent().superblock["creator_os"]
+        os = parent.getParent().getParent().superblock["creator_os"]
         if os == SuperBlock.OS_LINUX:
             self.read("frag", "B", "Number of fragments in the block")
             self.read("fsize", "B", "Fragment size")
@@ -100,7 +100,7 @@
 
     def updateParent(self, chunk):
         desc = "Inode %s: " % self.index
-        size = self["size"]
+        size = humanFilesize(self["size"])
         if 11 <= self.index:
             desc = desc + "file, size=%s, mode=%s" % (size, self.getChunk("mode").display)
         else:
@@ -145,9 +145,10 @@
             return "(empty)"
 
 class Bitmap(OnlyFormatChunksFilter):
-    def __init__(self, stream, parent, size, start):
-        OnlyFormatChunksFilter.__init__(self, "group", "EXT2 group", stream, parent)
+    def __init__(self, stream, parent, description, count, start):
+        OnlyFormatChunksFilter.__init__(self, "bitmap", "%s: %s items" % (description, count), stream, parent)
         self.start = start
+        size = count / 8
         self.read("block_bitmap", "%us" % size, "Bitmap")
 
     def showFree(self, type="Block"):
@@ -165,9 +166,10 @@
 BlockBitmap = Bitmap
 InodeBitmap = Bitmap
 
-class EXT2_Group(OnlyFormatChunksFilter):
-    def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "group", "EXT2 group", stream, parent)
+class GroupDescriptor(OnlyFormatChunksFilter):
+    def __init__(self, stream, parent, index):
+        OnlyFormatChunksFilter.__init__(self, "group", "Group descriptor", stream, parent)
+        self.index = index
         self.read("block_bitmap", "<L", "Points to the blocks bitmap block")
         self.read("inode_bitmap", "<L", "Points to the inodes bitmap block")
         self.read("inode_table", "<L", "Points to the inodes table first block")
@@ -177,6 +179,14 @@
         self.read("padding", "<H", "Padding")
         self.read("reserved", "12s", "Reserved")
 
+    def updateParent(self, chunk):
+        superblock = self.getParent().getParent().superblock
+        blocks_per_group = superblock["blocks_per_group"]
+        start = self.index * blocks_per_group
+        end = start + blocks_per_group 
+        chunk.description = "Group descriptor: blocks %s-%s" % (start, end)
+    
+
 class SuperBlock(OnlyFormatChunksFilter):
     error_handling = {
         1: "Continue"
@@ -197,7 +207,7 @@
     }
     
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "super_block", "EXT2 super block", stream, parent)
+        OnlyFormatChunksFilter.__init__(self, "super_block", "Super block", stream, parent)
         self.read("inodes_count", "<L", "Inodes count")
         self.read("blocks_count", "<L", "Blocks count")
         self.read("r_blocks_count", "<L", "Reserved blocks count")
@@ -276,7 +286,7 @@
             type = "ext3"
         else:
             type = "ext2"
-        desc = "EXT2 Superblock: %s file system" % type
+        desc = "Superblock: %s file system" % type
         self.setDescription(desc)
         chunk.description = desc
 
@@ -286,23 +296,21 @@
     def getTime(self, chunk):
         return datetime.fromtimestamp(chunk.value)
 
-class Groups(OnlyFormatChunksFilter):
-    def __init__(self, stream, parent, count):
-        OnlyFormatChunksFilter.__init__(self, "groups", "EXT2 groups", stream, parent)
-        self.items = []
+class GroupDescriptors(OnlyFormatChunksFilter):
+    def __init__(self, stream, parent, count, start):
+        OnlyFormatChunksFilter.__init__(self, "groups", "Group descriptors: %s items" % count, stream, parent)
+        self.start = start
         for i in range(0, count):
-            group = self.doReadChild("group[]", "Group", EXT2_Group).getFilter()
-            self.items.append(group)
+            self.readSizedChild("group[]", "Group", 32, GroupDescriptor, i)
 
-    def __getitem__(self, index):
-        return self.items[index]
+    def getGroup(self, index):
+        return self["group[%s]" % (self.start + index)]
 
 class InodeTable(OnlyFormatChunksFilter):
     def __init__(self, stream, parent, start, count):
-        OnlyFormatChunksFilter.__init__(self, "ino_table", "EXT2 inode table", stream, parent)
-        self.inodes = {}
+        OnlyFormatChunksFilter.__init__(self, "ino_table", "Inode table: %s inodes" % count, stream, parent)
         self.start = start
-        chunk_size = parent.superblock["inode_size"]
+        chunk_size = parent.getParent().superblock["inode_size"]
         for index in range(self.start, self.start+count):
             self.readSizedChild("inode[]", "Inode %s" % index, chunk_size, Inode, index)
 
@@ -310,11 +318,64 @@
         index = index - self.start - 1
         return self.getChunk("inode[%u]" % index).getFilter()
 
-#class Directory(Filter):
-#    def __init__(self, stream, parent):
-#        Filter.__init__(self, "dir", "EXT2 directory", stream, parent)
-#        self.read("inode", "<L", "Inode")
+def testSuperblock(stream):
+    oldpos = stream.tell()
+    stream.seek(80-24, 1)
+    is_super = stream.getN(2) == "\x53\xEF"    
+    stream.seek(oldpos)
+    return is_super
 
+class Group(OnlyFormatChunksFilter):
+    def __init__(self, stream, parent, index):
+        OnlyFormatChunksFilter.__init__(self, "group", "Group %u" % index, stream, parent)
+        self.index = index
+        group = parent["group_desc"].getGroup(index)
+        superblock = parent.superblock
+        block_size = parent.block_size
+    
+        # Read block bitmap
+        self.superblock_copy = False
+        if testSuperblock(stream):
+            self.readChild("superblock_copy", "Superblock", SuperBlock)
+            self.superblock_copy = True
+        self.seek(group["block_bitmap"] * block_size)
+            
+        count = superblock["blocks_per_group"]
+        self.readSizedChild("block_bitmap[]", "Block bitmap", count / 8, BlockBitmap, "Block bitmap", count, 0)
+
+        # Read inode bitmap
+        assert (group["inode_bitmap"] * block_size) == stream.tell()
+        count = superblock["inodes_per_group"]
+        self.readSizedChild("inode_bitmap[]", "Inode bitmap", count / 8, InodeBitmap, "Inode bitmap", count, 1)
+        addr = stream.tell() % 4096
+        if addr != 0:
+            addr = stream.tell() + (4096 - addr % 4096)
+            self.seek(addr)
+             
+        count = superblock["inodes_per_group"]
+        size = superblock["inode_size"] * count
+        inode_index = 1 + index * count
+        self.readSizedChild("inode_table[]", "Inode table", size, InodeTable, inode_index, count)
+
+        size = (index+1) * superblock["blocks_per_group"] * block_size
+        if stream.getSize() < size:
+            size = stream.getSize()
+        size = size - stream.tell() 
+        self.read("data", "%us" % size, "Data")
+
+    def updateParent(self, chunk):
+        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
+        if self.superblock_copy:
+            desc = desc + " (with superblock copy)"
+        chunk.description = desc 
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        assert 0 <= size
+        if 0 < size:
+            self.read("raw[]", "%us" % size, "Raw")
+
+
 class EXT2_FS(OnlyFormatChunksFilter):
     def __init__(self, stream, parent):
         OnlyFormatChunksFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)
@@ -326,35 +387,14 @@
 
         # Read groups
         self.seek(4096) 
-        groups = self.doReadChild("groups", "Groups", Groups, self.superblock.group_count).getFilter()
-        inode_index = 1
-        for i in range(0,2):
-            group = groups[i]
-        
-            # Read block bitmap
-            self.seek(group["block_bitmap"] * self.block_size)
-            count = self.superblock["blocks_per_group"]
-            self.readSizedChild("block_bitmap[]", "Block bitmap", count / 8, BlockBitmap, count / 8, 0)
+        groups = self.doReadChild("group_desc", "Group descriptors", GroupDescriptors, self.superblock.group_count, 0).getFilter()
+        self.seek(groups.getGroup(0)["block_bitmap"] * self.block_size)
+        for i in range(0,self.superblock.group_count):
+            self.readChild("group[]", "Group", Group, i)
 
-            # Read inode bitmap
-            assert (group["inode_bitmap"] * self.block_size) == stream.tell()
-            count = self.superblock["inodes_per_group"]
-            self.readSizedChild("inode_bitmap[]", "Inode bitmap", count / 8, InodeBitmap, count / 8, 1)
-            addr = stream.tell() % 4096
-            if addr != 0:
-                addr = stream.tell() + (4096 - addr % 4096)
-                self.seek(addr)
-                 
-            count = self.superblock["inodes_per_group"]
-            inode_table = self.readChild("inode_table[]", "Inode table", InodeTable, inode_index, count)
-            inode_index += count
-            return
-            if i == 0:
-                root = self[inode_table][2]
-                self.readDirectory(root)
-
         size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "End (raw)")
+        if size != 0:
+            self.read("end", "%us" % size, "End (raw)")
 
     def seek(self, to):
         size = to - self.getStream().tell()

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/stream/stream.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -132,7 +132,7 @@
 class LimitedStream(Stream):
     def __init__(self, stream, start=0, size=0, filename=None):
         Stream.__init__(self, filename)
-        assert 1<size            
+        assert 1 <= size            
         assert 0 <= start
         assert not(stream.getLastPos()+1 < start+size)
         self._stream = stream.clone()

Modified: haypo/hachoir/ui/ui_popup.py
===================================================================
--- haypo/hachoir/ui/ui_popup.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/ui/ui_popup.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -44,11 +44,13 @@
         self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
         self.set_format.set_sensitive(is_format_chunk)
 
-        chunks = self.chunk.getParent().getChunks()
+        chunk_parent = self.chunk.getParent()
         if self.chunk.getParent().getParent() != None:
-            can_delete = (1 < len(chunks)) or not is_format_chunk
+            can_delete = (1 < len(chunk_parent)) or not is_format_chunk
         else:
-            can_delete = chunks.index(self.chunk) < (len(chunks)-1) or not is_format_chunk
+            # TODO: Re-enable this
+            #can_delete = chunks.index(self.chunk) < (len(chunk_parent)-1) or not is_format_chunk
+            can_delete = not is_format_chunk
 
         self.delete_chunk.set_sensitive(can_delete)
         can_copy = (self.chunk.size < MAX_CHUNK_SIZE) and not is_filter_chunk

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-20 13:51:03 UTC (rev 343)
+++ haypo/hachoir/ui/ui_window.py	2005-12-20 14:04:36 UTC (rev 344)
@@ -27,7 +27,7 @@
             self.chunk_description.set_text(chunk.description)
             self.chunk_address.set_text(str(chunk.addr))
             self.chunk_size.set_text(str(chunk.size))
-            self.chunk_type.set_text(chunk.__class__.__name__)
+            self.chunk_type.set_text(chunk.getFormat())
         chunk_present = (chunk != None)
         self.info_chunk_save = chunk_present
         self.info_chunk_delete = chunk_present
@@ -177,7 +177,7 @@
     def build_table(self):
         self.table_store = gtk.TreeStore(str, str, str, str, str, str)
         self.table.set_model(self.table_store)
-        self.table.connect("button_release_event", self.onTableClick)
+        self.table.connect("cursor-changed", self.onTableClick)
         self.table.connect("row-activated", self.onTableRowActivate)
         self.treeview_add_column(self.table, "Address", 0)
         self.treeview_add_column(self.table, "Format", 1)



From haypo at berlios.de  Wed Dec 21 03:11:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 21 Dec 2005 03:11:22 +0100
Subject: [Happyboom-svn] r345 - haypo/hachoir/plugins
Message-ID: <200512210211.jBL2BMuP026068@sheep.berlios.de>

Author: haypo
Date: 2005-12-21 03:11:10 +0100 (Wed, 21 Dec 2005)
New Revision: 345

Modified:
   haypo/hachoir/plugins/avi.py
Log:
Fix align bug in AVI plugin (all offset looks to be like 2*k).



Modified: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-20 14:04:36 UTC (rev 344)
+++ haypo/hachoir/plugins/avi.py	2005-12-21 02:11:10 UTC (rev 345)
@@ -16,8 +16,11 @@
         size = stream.getSize()-4
         end = stream.tell() + size
         if tag in ("hdrl", "INFO"):
-            while 8 <= end - stream.tell():
+            while 8 < end - stream.tell():
                 chunk = self.readChild("chunk[]", AVI_Chunk)            
+                padding = chunk.size % 2
+                if padding != 0:
+                    self.read("padding[]", "%us" % padding, "Padding")
         elif tag == "strl":
             stype = None
             while 8 <= end - stream.tell():
@@ -89,7 +92,7 @@
             self.read("raw", "%us" % size, "Raw data")
         padding = end - stream.tell()
         if padding != 0:
-            self.read("padding", "%us" % padding, "Padding")
+            self.read("padding[]", "%us" % padding, "Padding")
         assert stream.tell() == end
 
 class AVI_ChunkString(Filter):
@@ -110,7 +113,7 @@
             self.readStreamChild("data", sub, AVI_Chunk.handler[tag])
             assert stream.tell() == end
         else:
-            self.read("raw", "%us" % size, "Raw data")
+            self.read("content", "%us" % size, "Raw data content")
 
     def updateParent(self, parent):
         type = self["tag"]



From haypo at berlios.de  Thu Dec 22 04:01:49 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 22 Dec 2005 04:01:49 +0100
Subject: [Happyboom-svn] r346 - in haypo/hachoir: plugins ui
Message-ID: <200512220301.jBM31nWQ008869@sheep.berlios.de>

Author: haypo
Date: 2005-12-22 04:00:58 +0100 (Thu, 22 Dec 2005)
New Revision: 346

Modified:
   haypo/hachoir/plugins/avi.py
   haypo/hachoir/ui/ui_window.py
Log:
- AVI can parse video/audio stream data
- Fix UI table sorting for size/address columns, and clear_table resets
  sort column (whereas Python crash, don't know why).


Modified: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-21 02:11:10 UTC (rev 345)
+++ haypo/hachoir/plugins/avi.py	2005-12-22 03:00:58 UTC (rev 346)
@@ -9,13 +9,68 @@
 from filter import Filter
 from plugin import registerPlugin
 
+class AVI_ChunkFrame(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "avi_chunk", "Video frame", stream, parent)
+        size = stream.getSize()
+        self.read("raw", "%us" % size, "Video frame")
+
+class AVI_ChunkAudio(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "avi_chunk", "Audio data", stream, parent)
+        size = stream.getSize()
+        self.read("raw", "%us" % size, "Audio data")
+
+class AVI_ChunkPalette(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "avi_chunk", "Palette change", stream, parent)
+        size = stream.getSize()
+        self.read("raw", "%us" % size, "Palette change")
+
+class AVI_ChunkMovi(Filter):
+    handler = {
+        "db": AVI_ChunkFrame, # Uncompressed
+        "dc": AVI_ChunkFrame, # Compressed
+        "wb": AVI_ChunkAudio,
+        "pc": AVI_ChunkPalette,
+    }
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "avi_chunk", "AVI movi chunk", stream, parent)
+        size = stream.getSize()
+        end = stream.tell() + size
+
+        while 8 <= end - stream.tell():
+            tag = self.read("fourcc[]", "4s", "Stream chunk four character code").value
+            size = self.read("ssize[]", "<L", "String size").value
+            if size == 0:
+                continue
+            twocc = tag[2:4]
+            if tag == "JUNK":
+                self.read("data[]", "%us" % size, "Junk data")
+            elif twocc in AVI_ChunkMovi.handler:
+                sub = stream.createSub(size=size)
+                self.readStreamChild("data[]", sub, AVI_ChunkMovi.handler[twocc])
+            else:
+                self.read("data[]", "%us" % size, "data")
+            if size & 1:
+                self.read("padding[]", "%us" % 1, "Padding")
+        size = end - stream.tell()
+        if size > 0:
+            self.read("raw", "%us" % size, "Raw data")
+
 class AVI_ChunkList(Filter):
+    handler = {
+        "movi": AVI_ChunkMovi,
+    }
     def __init__(self, stream, parent):
         Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
         tag = self.read("tag", "4s", "Tag").value
         size = stream.getSize()-4
         end = stream.tell() + size
-        if tag in ("hdrl", "INFO"):
+        if tag in AVI_ChunkList.handler:
+            sub = stream.createSub(size=size)
+            self.readStreamChild("data", sub, AVI_ChunkList.handler[tag])
+        elif tag in ("hdrl", "INFO"):
             while 8 < end - stream.tell():
                 chunk = self.readChild("chunk[]", AVI_Chunk)            
                 padding = chunk.size % 2

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-12-21 02:11:10 UTC (rev 345)
+++ haypo/hachoir/ui/ui_window.py	2005-12-22 03:00:58 UTC (rev 346)
@@ -132,6 +132,7 @@
 
     def clear_table(self):
         self.table_store.clear()
+        self.table_store.set_sort_column_id(-1, gtk.SORT_ASCENDING)
         self.table.columns_autosize()
 
     def set_table_value(self, iter, column, value):
@@ -180,15 +181,27 @@
         self.table.connect("cursor-changed", self.onTableClick)
         self.table.connect("row-activated", self.onTableRowActivate)
         self.treeview_add_column(self.table, "Address", 0)
+        self.table_store.set_sort_func(0, self.cmpColumnsLong, 0)
         self.treeview_add_column(self.table, "Format", 1)
         self.treeview_add_column(self.table, "Size", 2)
+        self.table_store.set_sort_func(2, self.cmpColumnsLong, 2)
         self.treeview_add_column(self.table, "Name", 3)
         self.treeview_add_column(self.table, "Value", 4)
         self.treeview_add_column(self.table, "Description", 5)
-        self.table.set_reorderable(True)
-        self.treeselection = self.table.get_selection()
+        self.table_store.set_default_sort_func(self.cmpDefault)
         self.table.columns_autosize()
 
+    def cmpDefault(self, model, a, b):
+        return 0
+
+    def cmpColumnsLong(self, model, a, b, row_id):
+        a = model[a][row_id]
+        b = model[b][row_id]
+        if a != None and b != None:
+            return cmp( long(a) , long(b) )
+        else:
+            return 0
+
     def treeview_add_column(self, treeview, name, num):
         col = gtk.TreeViewColumn(name)
         treeview.append_column(col)



From haypo at berlios.de  Thu Dec 22 05:10:51 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 22 Dec 2005 05:10:51 +0100
Subject: [Happyboom-svn] r347 - in haypo/hachoir: . plugins
Message-ID: <200512220410.jBM4Ap2T024364@sheep.berlios.de>

Author: haypo
Date: 2005-12-22 05:10:35 +0100 (Thu, 22 Dec 2005)
New Revision: 347

Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/3ds.py
   haypo/hachoir/plugins/avi.py
   haypo/hachoir/plugins/ext2.py
   haypo/hachoir/plugins/jpeg.py
Log:
- Rename class OnlyFormatsChunkFilter to OnDemandFilter ... better name,
  I think :-)
- AVI plugin use OnDemandFilter
- AVI plugin use better chunk name and chunk description
- Remove useless filters AVI_ChunkAudio, AVI_ChunkPalette, etc. in AVI plugin
  and use better chunk description (type + smart size)


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-22 03:00:58 UTC (rev 346)
+++ haypo/hachoir/filter.py	2005-12-22 04:10:35 UTC (rev 347)
@@ -78,6 +78,9 @@
         else:
             self._chunks_counter[root] = start 
         return pattern % (root, self._chunks_counter[root])
+        
+    def hasChunk(self, id):
+        return id in self._chunks_dict
 
     # --- Pure virtual methods -----------
     def getSize(self): assert False
@@ -85,12 +88,11 @@
     def getChunk(self, chunk_id): assert False
     def display(self): assert False
 
-class OnlyFormatChunksFilter(BasicFilter):
+class OnDemandFilter(BasicFilter):
     def __init__(self, id, description, stream, parent):
         BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
         self._size = 0
         self._chunks = []
-        self._chunks_dict = {}
         self._chunks_cache = {}
     
     def updateChunkDescription(self, id, desc):
@@ -119,6 +121,9 @@
     def readStreamChild(self, id, description, filter_stream, filter_class, *args): 
         return self._readStreamChild(id, description, filter_stream, None, filter_class, *args)
 
+    def readSizedStreamChild(self, id, description, size, filter_stream, filter_class, *args): 
+        return self._readStreamChild(id, description, filter_stream, size, filter_class, *args)
+
     def _readStreamChild(self, id, description, filter_stream, size, filter_class, *args): 
         id = self.getUniqChunkId(id)
         addr = self._stream.tell()
@@ -244,60 +249,6 @@
         else:
             return chunk.value
 
-class OnlyFiltersFilter(BasicFilter):
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self._chunks = []
-        self._chunks_dict = {}
-        self._chunks_cache = {}
-        self._size = 0
-
-    def purgeCache(self):
-        self._chunks_cache = {}
-
-    def readSizedChild(self, id, size, description, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        filter_info = (id, size, self._stream.tell(), description, filter_class, args)
-        self._chunks_dict[id] = filter_info
-        self._chunks.append( filter_info )
-        self._stream.seek(size, 1)
-        self._size = self._size + size
-
-    def display(self):
-        ui.window.enableParentButton(self.getParent() != None)
-        ui.window.clear_table()
-        for info in self._chunks:
-            format = info[4].__name__
-            if info[0] in self._chunks_cache:
-                chunk = self._chunks_cache[info[0]]
-                desc = chunk.description
-            else:
-                desc = info[3] 
-            ui.window.add_table(None, info[2], info[1], format, info[0], desc, "(...)")
- 
-    def getSize(self): return self._size
-
-    def getChunk(self, id):
-        if id not in self._chunks_dict:
-            return None
-        if id not in self._chunks_cache:
-            info = self._chunks_dict[id]
-
-            addr = info[2]
-            self._stream.seek(addr)
-            filter = info[4] (self._stream, self, *info[5])
-            filter.setId(info[0])
-            chunk = FilterChunk(info[0], filter, self, addr)
-            filter.updateParent(chunk)
-            self._stream.seek(addr + info[1])
-            
-            self._chunks_cache[id] = chunk 
-        return self._chunks_cache[id]
-
-    def __getitem__(self, id):
-        assert id in self._chunks_dict
-        return self.getChunk(id).value
-
 class Filter(BasicFilter):
     regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
 

Modified: haypo/hachoir/plugins/3ds.py
===================================================================
--- haypo/hachoir/plugins/3ds.py	2005-12-22 03:00:58 UTC (rev 346)
+++ haypo/hachoir/plugins/3ds.py	2005-12-22 04:10:35 UTC (rev 347)
@@ -3,7 +3,7 @@
 Author: Victor Stinner
 """
 
-from filter import Filter, OnlyFormatChunksFilter
+from filter import Filter, OnDemandFilter
 from plugin import registerPlugin
 
 def readTextureFilename(filter, stream, last_pos):
@@ -63,7 +63,7 @@
     while stream.tell() < last_pos:
         filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
 
-class Filter_3DS_Chunk(OnlyFormatChunksFilter):
+class Filter_3DS_Chunk(OnDemandFilter):
     # List of chunk type name
     type_name = {
         0x0011: "Color",
@@ -125,7 +125,7 @@
     }
     
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
+        OnDemandFilter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
         chunk = self.doRead("type", "<H", "Chunk type", post=self.toHex)
         chunk.description = "Chunk type (%s)" % self.getType()
         self.read("size", "<L", "Chunk size")

Modified: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-22 03:00:58 UTC (rev 346)
+++ haypo/hachoir/plugins/avi.py	2005-12-22 04:10:35 UTC (rev 347)
@@ -6,176 +6,229 @@
 Author: Victor Stinner
 """
 
-from filter import Filter
+from filter import Filter, OnDemandFilter
 from plugin import registerPlugin
+from tools import humanFilesize
 
-class AVI_ChunkFrame(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "avi_chunk", "Video frame", stream, parent)
-        size = stream.getSize()
-        self.read("raw", "%us" % size, "Video frame")
+class MovieChunk(OnDemandFilter):
+    twocc_description = {
+        "db": "Uncompressed video frame",
+        "dc": "Compressed video frame",
+        "wb": "Audio data",
+        "pc": "Palette change"
+    }
 
-class AVI_ChunkAudio(Filter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "avi_chunk", "Audio data", stream, parent)
-        size = stream.getSize()
-        self.read("raw", "%us" % size, "Audio data")
+        OnDemandFilter.__init__(self, "movie_chunk", "Movie chunk", stream, parent)
+        self.read("fourcc", "4s", "Stream chunk four character code")
+        size = self.doRead("size", "<L", "Size").value
+        if size == 0:
+            self.type = "(empty)"
+            return
+        fourcc = self["fourcc"]
+        twocc = fourcc[2:4]
+        if twocc in MovieChunk.twocc_description:
+            desc = MovieChunk.twocc_description[twocc]
+        elif fourcc == "JUNK":
+            desc = "Junk"
+        else:
+            desc = "Raw data"
+        self.read("data", "%us" % size, desc)
+        self.type = desc
+        if size & 1:
+            self.read("padding", "%us" % 1, "Padding")
 
-class AVI_ChunkPalette(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "avi_chunk", "Palette change", stream, parent)
-        size = stream.getSize()
-        self.read("raw", "%us" % size, "Palette change")
+    def updateParent(self, chunk):
+        desc = "Movie chunk: %s" % self.type
+        size = self["size"]
+        if size != 0:
+            desc = desc + " (%s)" % humanFilesize(size)
+        chunk.description = desc 
 
-class AVI_ChunkMovi(Filter):
-    handler = {
-        "db": AVI_ChunkFrame, # Uncompressed
-        "dc": AVI_ChunkFrame, # Compressed
-        "wb": AVI_ChunkAudio,
-        "pc": AVI_ChunkPalette,
-    }
+class MovieStream(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "avi_chunk", "AVI movi chunk", stream, parent)
+        OnDemandFilter.__init__(self, "movie_str", "Movie stream", stream, parent)
+        print " ********* PARSE STREAM ************"
         size = stream.getSize()
         end = stream.tell() + size
 
+        self.chunk_count = 0
+        start = stream.tell()
         while 8 <= end - stream.tell():
-            tag = self.read("fourcc[]", "4s", "Stream chunk four character code").value
-            size = self.read("ssize[]", "<L", "String size").value
-            if size == 0:
-                continue
-            twocc = tag[2:4]
-            if tag == "JUNK":
-                self.read("data[]", "%us" % size, "Junk data")
-            elif twocc in AVI_ChunkMovi.handler:
-                sub = stream.createSub(size=size)
-                self.readStreamChild("data[]", sub, AVI_ChunkMovi.handler[twocc])
-            else:
-                self.read("data[]", "%us" % size, "data")
-            if size & 1:
-                self.read("padding[]", "%us" % 1, "Padding")
+            #?Little hack to read chunk size
+            stream.seek(4, 1)
+            chunk_size = stream.getFormat("<L", False)[0]
+            stream.seek(-4, 1)
+            chunk_size = 8 + chunk_size + chunk_size % 2
+            # End of little hack :-)
+            self.readSizedChild("chunk[]", "Movie chunk", chunk_size, MovieChunk)
+            self.chunk_count += 1
+            if self.chunk_count % 1000 == 0:
+                print "Parse stream: %u %%" % ((stream.tell() - start) * 100 / size)
         size = end - stream.tell()
         if size > 0:
-            self.read("raw", "%us" % size, "Raw data")
+            self.read("end", "%us" % size, "Raw data")
 
-class AVI_ChunkList(Filter):
+    def updateParent(self, chunk):
+        chunk.description = "Movie stream: %u chunks" % self.chunk_count
+
+class Header(Filter):
+    def __init__(self, stream, parent, stream_type):
+        Filter.__init__(self, "header", "Header", stream, parent)
+        tag = self.read("tag", "4s", "Tag").value
+        size = self.read("size", "<L", "Size").value
+        self.type = "Unknow"
+        if tag == "strh" and size >= 56:
+            # Stream header
+            self.type = "Stream header"
+            hend = stream.tell() + size
+            self.read("type_fourcc", "4s", "Stream type four character code")
+            self.read("fourcc", "4s", "Stream four character code")
+            self.read("flags", "<L", "Stream flags")
+            self.read("priority", "<H", "Stream priority")
+            self.read("langage", "2s", "Stream language")
+            self.read("init_frames", "<L", "InitialFrames")
+            self.read("scale", "<L", "Time scale")
+            self.read("rate", "<L", "Divide by scale to give frame rate")
+            self.read("start", "<L", "Stream start time (unit: rate/scale)")
+            self.read("length", "<L", "Stream length (unit: rate/scale)")
+            self.read("buf_size", "<L", "Suggested buffer size")
+            self.read("quality", "<L", "Stream quality")
+            self.read("sample_size", "<L", "Size of samples")
+            self.read("left", "<H", "Destination rectangle (left)")
+            self.read("top", "<H", "Destination rectangle (top)")
+            self.read("right", "<H", "Destination rectangle (right)")
+            self.read("bottom", "<H", "Destination rectangle (bottom)")
+            diff = hend-stream.tell()
+            if 0 < diff:
+                self.read("h_extra", "%us" % diff, "Extra junk")
+            assert stream.tell() == hend
+        elif tag == "strf" and stream_type == "vids" and size == 40:
+            # Video header
+            self.type = "Video header"
+            self.read("v_size", "<L", "Video format: Size")                    
+            self.read("v_width", "<L", "Video format: Width")                    
+            self.read("v_height", "<L", "Video format: Height")                    
+            self.read("v_panes", "<H", "Video format: Panes")                    
+            self.read("v_depth", "<H", "Video format: Depth")                    
+            self.read("v_tag1", "<L", "Video format: Tag1")                    
+            self.read("v_img_size", "<L", "Video format: Image size")                    
+            self.read("v_xpels_meter", "<L", "Video format: XPelsPerMeter")
+            self.read("v_ypels_meter", "<L", "Video format: YPelsPerMeter")
+            self.read("v_clr_used", "<L", "Video format: ClrUsed")
+            self.read("v_clr_importand", "<L", "Video format: ClrImportant")
+        elif tag == "strf" and stream_type == "auds":
+            # Audio (wav) header
+            self.type = "Audio header"
+            aend = stream.tell() + size
+            self.read("a_id", "<H", "Audio format: Codec id")                    
+            a_chan = self.read("a_channel", "<H", "Audio format: Channels").value
+            self.read("a_sample_rate", "<L", "Audio format: Sample rate")                    
+            self.read("a_bit_rate", "<L", "Audio format: Bit rate")
+            self.read("a_block_align", "<H", "Audio format: Block align")
+            if size >= 16:
+                self.read("a_bits_per_sample", "<H", "Audio format: Bits per sample")
+            if size >= 18:
+                self.read("ext_size", "<H", "Audio format: Size of extra information")
+            if a_chan > 2 and size >= 28:
+                self.read("reserved", "<H", "Audio format: ")
+                self.read("channel_mask", "<L", "Audio format: channels placement bitmask")
+                self.read("subformat", "<L", "Audio format: Subformat id")
+            diff = aend-stream.tell()
+            if 0 < diff:
+                self.read("a_extra", "%us" % diff, "Audio format: Extra")
+            assert stream.tell() == aend
+        elif tag == "strn":
+            # Stream description
+            self.read("desc", "%us" % size, "Stream description")
+        else:
+            if tag == "JUNK":
+                self.type = "Junk"
+            self.read("svalue[]", "%us" % size, "String value")
+
+    def updateParent(self, chunk):
+        chunk.description = "Header: %s" % self.type
+
+class ChunkList(OnDemandFilter):
     handler = {
-        "movi": AVI_ChunkMovi,
+        "movi": MovieStream 
     }
     def __init__(self, stream, parent):
-        Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
-        tag = self.read("tag", "4s", "Tag").value
+        OnDemandFilter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
+        self.type = "Unknow"
+        tag = self.doRead("tag", "4s", "Tag").value
         size = stream.getSize()-4
         end = stream.tell() + size
-        if tag in AVI_ChunkList.handler:
+        if tag in ChunkList.handler:
+            # Handler
             sub = stream.createSub(size=size)
-            self.readStreamChild("data", sub, AVI_ChunkList.handler[tag])
+            self.readSizedStreamChild("data", "Chunk data", size, sub, ChunkList.handler[tag])
         elif tag in ("hdrl", "INFO"):
+            #?(Headers) Chunks
+            self.type = "List of chunks"
             while 8 < end - stream.tell():
-                chunk = self.readChild("chunk[]", AVI_Chunk)            
-                padding = chunk.size % 2
+                size = self.doReadChild("chunk[]", "Chunk", Chunk).size
+                padding = size % 2
                 if padding != 0:
                     self.read("padding[]", "%us" % padding, "Padding")
         elif tag == "strl":
-            stype = None
+            # Headers
+            self.type = "Headers"
+            stream_type = None
             while 8 <= end - stream.tell():
-                stag = self.read("stag[]", "4s", "String tag").value
-                size = self.read("ssize[]", "<L", "String size").value
-                if stag == "strh" and size >= 56:
-                    # Stream header
-                    hend = stream.tell() + size
-                    stype = self.read("type_fourcc", "4s", "Stream type four character code").value
-                    self.read("fourcc", "4s", "Stream four character code")
-                    self.read("flags", "<L", "Stream flags")
-                    self.read("priority", "<H", "Stream priority")
-                    self.read("langage", "2s", "Stream language")
-                    self.read("init_frames", "<L", "InitialFrames")
-                    self.read("scale", "<L", "Time scale")
-                    self.read("rate", "<L", "Divide by scale to give frame rate")
-                    self.read("start", "<L", "Stream start time (unit: rate/scale)")
-                    self.read("length", "<L", "Stream length (unit: rate/scale)")
-                    self.read("buf_size", "<L", "Suggested buffer size")
-                    self.read("quality", "<L", "Stream quality")
-                    self.read("sample_size", "<L", "Size of samples")
-                    self.read("left", "<H", "Destination rectangle (left)")
-                    self.read("top", "<H", "Destination rectangle (top)")
-                    self.read("right", "<H", "Destination rectangle (right)")
-                    self.read("bottom", "<H", "Destination rectangle (bottom)")
-                    diff = hend-stream.tell()
-                    if 0 < diff:
-                        self.read("h_extra", "%us" % diff, "Extra junk")
-                    assert stream.tell() == hend
-                elif stag == "strf" and stype == "vids" and size == 40:
-                    # Video header
-                    self.read("v_size", "<L", "Video format: Size")                    
-                    self.read("v_width", "<L", "Video format: Width")                    
-                    self.read("v_height", "<L", "Video format: Height")                    
-                    self.read("v_panes", "<H", "Video format: Panes")                    
-                    self.read("v_depth", "<H", "Video format: Depth")                    
-                    self.read("v_tag1", "<L", "Video format: Tag1")                    
-                    self.read("v_img_size", "<L", "Video format: Image size")                    
-                    self.read("v_xpels_meter", "<L", "Video format: XPelsPerMeter")
-                    self.read("v_ypels_meter", "<L", "Video format: YPelsPerMeter")
-                    self.read("v_clr_used", "<L", "Video format: ClrUsed")
-                    self.read("v_clr_importand", "<L", "Video format: ClrImportant")
-                elif stag == "strf" and stype == "auds":
-                    # Audio (wav) header
-                    aend = stream.tell() + size
-                    self.read("a_id", "<H", "Audio format: Codec id")                    
-                    a_chan = self.read("a_channel", "<H", "Audio format: Channels").value
-                    self.read("a_sample_rate", "<L", "Audio format: Sample rate")                    
-                    self.read("a_bit_rate", "<L", "Audio format: Bit rate")
-                    self.read("a_block_align", "<H", "Audio format: Block align")
-                    if size >= 16:
-                        self.read("a_bits_per_sample", "<H", "Audio format: Bits per sample")
-                    if size >= 18:
-                        self.read("ext_size", "<H", "Audio format: Size of extra information")
-                    if a_chan > 2 and size >= 28:
-                        self.read("reserved", "<H", "Audio format: ")
-                        self.read("channel_mask", "<L", "Audio format: channels placement bitmask")
-                        self.read("subformat", "<L", "Audio format: Subformat id")
-                    diff = aend-stream.tell()
-                    if 0 < diff:
-                        self.read("a_extra", "%us" % diff, "Audio format: Extra")
-                    assert stream.tell() == aend
-                elif stag == "strn":
-                    # Stream description
-                    self.read("desc", "%us" % size, "Stream description")
-                else:
-                    self.read("svalue[]", "%us" % size, "String value")
+                header = self.doReadChild("header[]", "Header", Header, stream_type).getFilter()
+                if header.hasChunk("type_fourcc"):
+                    stream_type = header["type_fourcc"]
         else:
+            #?Raw data
             self.read("raw", "%us" % size, "Raw data")
         padding = end - stream.tell()
         if padding != 0:
             self.read("padding[]", "%us" % padding, "Padding")
         assert stream.tell() == end
 
-class AVI_ChunkString(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
+    def updateParent(self, chunk):
+        chunk.description = "Chunk list: %s" % self.type
 
-class AVI_Chunk(Filter):
+class Chunk(OnDemandFilter):
     handler = {
-        "LIST": AVI_ChunkList
+        "LIST": ChunkList
     }
+
+    tag_name = {
+        "hdrl": "headers",
+        "movi": "movie",
+        "idx1": "index"
+    }
+
+    tag_description = {
+        "hdrl": "Headers",
+        "movi": "Movie stream",
+        "idx1": "Stream index"
+    }
+
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
-        tag = self.read("tag", "4s", "Tag").value
-        size = self.read("size", "<L", "Size").value
-        if tag in AVI_Chunk.handler:
+        OnDemandFilter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
+        tag = self.doRead("tag", "4s", "Tag").value
+        size = self.doRead("size", "<L", "Size").value
+        if tag in Chunk.handler:
             end = stream.tell() + size
             sub = stream.createSub(size=size)
-            self.readStreamChild("data", sub, AVI_Chunk.handler[tag])
+            self.readSizedStreamChild("data", "Data", size, sub, Chunk.handler[tag])
             assert stream.tell() == end
         else:
             self.read("content", "%us" % size, "Raw data content")
 
     def updateParent(self, parent):
-        type = self["tag"]
-        if type == "LIST":
-            tag2 = self["data"]["tag"]
-            type = type + " (%s)" % tag2      
-        desc = "Chunk %s" % type
+        tag = self["tag"]
+        if tag == "LIST":
+            tag = self["data"]["tag"]
+            type = "LIST (%s)" % Chunk.tag_description.get(tag, tag)
+        else:
+            type = Chunk.tag_description.get(tag, tag)
+        if tag in Chunk.tag_name:
+            parent.id = Chunk.tag_name[tag]
+        desc = "Chunk: %s" % type
         self.setDescription(desc)
         parent.description = desc
 
@@ -188,6 +241,6 @@
         self.read("avi", "4s", "\"AVI \" string")
         assert self["avi"] == "AVI "
         while not stream.eof():
-            self.readChild("chunk[]", AVI_Chunk)
+            self.readChild("chunk[]", Chunk)
 
 registerPlugin(AVI_File, "video/x-msvideo")

Modified: haypo/hachoir/plugins/ext2.py
===================================================================
--- haypo/hachoir/plugins/ext2.py	2005-12-22 03:00:58 UTC (rev 346)
+++ haypo/hachoir/plugins/ext2.py	2005-12-22 04:10:35 UTC (rev 347)
@@ -9,11 +9,11 @@
 """
 
 from datetime import datetime
-from filter import Filter, OnlyFormatChunksFilter, OnlyFiltersFilter
+from filter import Filter, OnDemandFilter
 from plugin import registerPlugin
 from tools import humanDuration, getUnixRWX, humanFilesize
 
-class DirectoryEntry(OnlyFormatChunksFilter):
+class DirectoryEntry(OnDemandFilter):
     file_type = {
         1: "Regular",
         2: "Directory",
@@ -25,7 +25,7 @@
         8: "Max"
     }
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "dir", "EXT2 directory entry", stream, parent)
+        OnDemandFilter.__init__(self, "dir", "EXT2 directory entry", stream, parent)
         self.read("inode", "<L", "Inode")
         self.read("rec_len", "<H", "Record length")
         name_length = self.doRead("name_len", "B", "Name length").value
@@ -48,7 +48,7 @@
         type = chunk.value
         return DirectoryEntry.file_type.get(type, "Unknow (%02X)" % type)
 
-class Inode(OnlyFormatChunksFilter):
+class Inode(OnDemandFilter):
     name = {
         1: "list of bad blocks",
         2: "Root directory",
@@ -60,7 +60,7 @@
     }
     
     def __init__(self, stream, parent, index):
-        OnlyFormatChunksFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
+        OnDemandFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
         self.index = index
         self.read("mode", "<H", "Mode", post=self.postMode)
         self.read("uid", "<H", "User ID")
@@ -144,9 +144,9 @@
         else:
             return "(empty)"
 
-class Bitmap(OnlyFormatChunksFilter):
+class Bitmap(OnDemandFilter):
     def __init__(self, stream, parent, description, count, start):
-        OnlyFormatChunksFilter.__init__(self, "bitmap", "%s: %s items" % (description, count), stream, parent)
+        OnDemandFilter.__init__(self, "bitmap", "%s: %s items" % (description, count), stream, parent)
         self.start = start
         size = count / 8
         self.read("block_bitmap", "%us" % size, "Bitmap")
@@ -166,9 +166,9 @@
 BlockBitmap = Bitmap
 InodeBitmap = Bitmap
 
-class GroupDescriptor(OnlyFormatChunksFilter):
+class GroupDescriptor(OnDemandFilter):
     def __init__(self, stream, parent, index):
-        OnlyFormatChunksFilter.__init__(self, "group", "Group descriptor", stream, parent)
+        OnDemandFilter.__init__(self, "group", "Group descriptor", stream, parent)
         self.index = index
         self.read("block_bitmap", "<L", "Points to the blocks bitmap block")
         self.read("inode_bitmap", "<L", "Points to the inodes bitmap block")
@@ -187,7 +187,7 @@
         chunk.description = "Group descriptor: blocks %s-%s" % (start, end)
     
 
-class SuperBlock(OnlyFormatChunksFilter):
+class SuperBlock(OnDemandFilter):
     error_handling = {
         1: "Continue"
     }
@@ -207,7 +207,7 @@
     }
     
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "super_block", "Super block", stream, parent)
+        OnDemandFilter.__init__(self, "super_block", "Super block", stream, parent)
         self.read("inodes_count", "<L", "Inodes count")
         self.read("blocks_count", "<L", "Blocks count")
         self.read("r_blocks_count", "<L", "Reserved blocks count")
@@ -296,9 +296,9 @@
     def getTime(self, chunk):
         return datetime.fromtimestamp(chunk.value)
 
-class GroupDescriptors(OnlyFormatChunksFilter):
+class GroupDescriptors(OnDemandFilter):
     def __init__(self, stream, parent, count, start):
-        OnlyFormatChunksFilter.__init__(self, "groups", "Group descriptors: %s items" % count, stream, parent)
+        OnDemandFilter.__init__(self, "groups", "Group descriptors: %s items" % count, stream, parent)
         self.start = start
         for i in range(0, count):
             self.readSizedChild("group[]", "Group", 32, GroupDescriptor, i)
@@ -306,9 +306,9 @@
     def getGroup(self, index):
         return self["group[%s]" % (self.start + index)]
 
-class InodeTable(OnlyFormatChunksFilter):
+class InodeTable(OnDemandFilter):
     def __init__(self, stream, parent, start, count):
-        OnlyFormatChunksFilter.__init__(self, "ino_table", "Inode table: %s inodes" % count, stream, parent)
+        OnDemandFilter.__init__(self, "ino_table", "Inode table: %s inodes" % count, stream, parent)
         self.start = start
         chunk_size = parent.getParent().superblock["inode_size"]
         for index in range(self.start, self.start+count):
@@ -325,9 +325,9 @@
     stream.seek(oldpos)
     return is_super
 
-class Group(OnlyFormatChunksFilter):
+class Group(OnDemandFilter):
     def __init__(self, stream, parent, index):
-        OnlyFormatChunksFilter.__init__(self, "group", "Group %u" % index, stream, parent)
+        OnDemandFilter.__init__(self, "group", "Group %u" % index, stream, parent)
         self.index = index
         group = parent["group_desc"].getGroup(index)
         superblock = parent.superblock
@@ -376,9 +376,9 @@
             self.read("raw[]", "%us" % size, "Raw")
 
 
-class EXT2_FS(OnlyFormatChunksFilter):
+class EXT2_FS(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)
+        OnDemandFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)
         
         # Read superblock
         self.seek(1024) 

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-12-22 03:00:58 UTC (rev 346)
+++ haypo/hachoir/plugins/jpeg.py	2005-12-22 04:10:35 UTC (rev 347)
@@ -5,13 +5,13 @@
 Default filter
 """
 
-from filter import Filter, OnlyFormatChunksFilter
+from filter import Filter, OnDemandFilter
 from plugin import registerPlugin
 from exif import ExifFilter
 
-class JpegChunkApp0(OnlyFormatChunksFilter):
+class JpegChunkApp0(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "jpeg_chunk", "JPEG chunk App0", stream, parent)
+        OnDemandFilter.__init__(self, "jpeg_chunk", "JPEG chunk App0", stream, parent)
         self.read("jfif", "5s", "JFIF string")
         self.read("ver_maj", "B", "Major version")
         self.read("ver_min", "B", "Minor version")
@@ -28,7 +28,7 @@
         if thumb != 0:
             self.read("thumb_data", "%us" % size, "Thumbnail data")
 
-class JpegChunk(OnlyFormatChunksFilter):
+class JpegChunk(OnDemandFilter):
     type_name = {
         0xC0: "Start Of Frame 0 (SOF0)",
         0xC3: "Define Huffman Table (DHT)",
@@ -48,7 +48,7 @@
     }
 
     def __init__(self, stream, parent):
-        OnlyFormatChunksFilter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
+        OnDemandFilter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
         self.read("header", "B", "Header")
         assert self["header"] == 0xFF
         self.read("type", "B", "Type", post=self.postType)
@@ -72,9 +72,9 @@
         type = chunk.value
         return JpegChunk.type_name.get(type, "Unknow type (%02X)" % type)
 
-class JpegFile(OnlyFormatChunksFilter):
+class JpegFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        OnlyFormatChunksFilter.__init__(self, "jpeg_file", "JPEG file", stream, parent)
+        OnDemandFilter.__init__(self, "jpeg_file", "JPEG file", stream, parent)
         self.read("header", "2s", "Header \"start of image\" (0xFF xD8)")
         assert self["header"] == "\xFF\xD8"
         while not stream.eof():



From haypo at berlios.de  Sat Dec 24 02:47:21 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 24 Dec 2005 02:47:21 +0100
Subject: [Happyboom-svn] r348 - in haypo/hachoir: . plugins stream
Message-ID: <200512240147.jBO1lLiT018351@sheep.berlios.de>

Author: haypo
Date: 2005-12-24 02:47:07 +0100 (Sat, 24 Dec 2005)
New Revision: 348

Added:
   haypo/hachoir/text_handler.py
Modified:
   haypo/hachoir/plugins/avi.py
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/stream/bunzip.py
Log:
Create text_handler.py and small bug fixes


Modified: haypo/hachoir/plugins/avi.py
===================================================================
--- haypo/hachoir/plugins/avi.py	2005-12-22 04:10:35 UTC (rev 347)
+++ haypo/hachoir/plugins/avi.py	2005-12-24 01:47:07 UTC (rev 348)
@@ -68,6 +68,7 @@
         size = end - stream.tell()
         if size > 0:
             self.read("end", "%us" % size, "Raw data")
+        print " ********* END OF STREAM PARSING ************"
 
     def updateParent(self, chunk):
         chunk.description = "Movie stream: %u chunks" % self.chunk_count

Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-12-22 04:10:35 UTC (rev 347)
+++ haypo/hachoir/plugins/elf.py	2005-12-24 01:47:07 UTC (rev 348)
@@ -168,4 +168,4 @@
             chunk = self.readChild("section_header[]", SectionHeader32)
             assert chunk.size == 40
 
-registerPlugin(ElfFile, ["application/x-executable", "application/x-sharedlib"])
+registerPlugin(ElfFile, ["application/x-executable", "application/x-object", "application/x-sharedlib"])

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-12-22 04:10:35 UTC (rev 347)
+++ haypo/hachoir/plugins/tar.py	2005-12-24 01:47:07 UTC (rev 348)
@@ -96,7 +96,7 @@
         self.read("devmajor", "!8s", "Dev major")
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
-        if self["type"] in ("\0", "0"):
+        if self["type"] in ("\0", "0") and self.size != 0:
             substream = stream.createSub(stream.tell(), self.size)
             plugin = guessPlugin(substream, self.name)
 

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-12-22 04:10:35 UTC (rev 347)
+++ haypo/hachoir/plugins/zip.py	2005-12-24 01:47:07 UTC (rev 348)
@@ -9,6 +9,7 @@
 from filter import Filter
 from plugin import registerPlugin
 from error import error
+from text_handler import humanFilesize, hexadecimal
 
 class ZipCentralDirectory(Filter):
     def __init__(self, stream, parent):
@@ -71,8 +72,8 @@
         self.read("last_mod_time", "<H", "Last modification time")
         self.read("last_mod_date", "<H", "Last modification date")
         self.read("crc32", "<L", "Checksum (CRC32)")
-        self.read("compressed_size", "<L", "Compressed size (bytes)")
-        self.read("uncompressed_size", "<L", "Uncompressed size (bytes)")
+        self.read("compressed_size", "<L", "Compressed size (bytes)", post=humanFilesize)
+        self.read("uncompressed_size", "<L", "Uncompressed size (bytes)", post=humanFilesize)
         self.read("filename_length", "<H", "Filename length")
         self.read("extra_length", "<H", "Extra length")
         self.read("filename", "%us" % self["filename_length"], "Filename")
@@ -84,7 +85,8 @@
             self.read("file_uncompressed_size", "<L", "Uncompressed size (bytes)")
 
     def updateParent(self, chunk):
-        desc = "File entry: %s" % self["filename"]
+        size = self.getChunk("compressed_size").display
+        desc = "File entry: %s (%s)" % (self["filename"], size)
         chunk.description = desc
         self.setDescription(desc)
         
@@ -96,8 +98,7 @@
         self.central_directory = []
         self.files = []
         while not stream.eof():
-            header = self.read("header[]", "<L", "Header")
-            header = header.getValue()
+            header = self.read("header[]", "<L", "Header", post=hexadecimal).value
             if header == 0x04034B50:
                 self.readChild("files[]", ZipFileEntry)
             elif header == 0x02014b50:

Modified: haypo/hachoir/stream/bunzip.py
===================================================================
--- haypo/hachoir/stream/bunzip.py	2005-12-22 04:10:35 UTC (rev 347)
+++ haypo/hachoir/stream/bunzip.py	2005-12-24 01:47:07 UTC (rev 348)
@@ -4,39 +4,58 @@
 import os
 
 def BunzipStream(stream):
-    if True: #not isinstance(stream, FileStream):
-        filename = None
-        realname = os.tmpnam()
-        file = open(realname, 'w')
-        oldpos = stream.tell()
-        stream.seek(0)
-        file.write(stream.getN(stream.getSize()))
-        stream.seek(oldpos)
-        file.close()
-    else:
-        print "Ok."
-        filename = stream.filename
-        realname = filename
-       
-    # TODO: Is it the best value !?
-    buffersize = 4096 
-    io = bz2.BZ2File(realname, "r", buffersize)
+    size = stream.getSize()
+    filename = stream.filename
 
-    if filename==None:
-        os.unlink(realname)
+    #?TODO: If you reach this limit that mean that a new
+    #?code have to be written :-) (using BZ2File or BZ2Decompressor)
+    assert size < 10000000
+    oldpos = stream.tell()
+    stream.seek(0)
+    content = stream.getN(size)
+    stream.seek(oldpos)
+    
+    content = bz2.decompress(content)
+    io = StringIO(content)
+    return FileStream(io, filename)
 
-    # Check data size (buggy with Python <= 2.4.2 and maybe other)
-    io.seek(0,2)
-    guess_size = io.tell()
-    io.seek(0)
-
-    # Check data size
-    io.seek(-1,2)
-    real_size = io.tell() + 1
-    io.seek(0)
-   
-    # Workaroud Python bug :-(
-    if real_size != guess_size:
-        io = StringIO(io.read())
-
-    return FileStream(io, filename)
+#def DONTUSETHISBunzipStream(stream):
+#    # DON'T USE THIS FUNCTION
+#    # because it uses security buggy function: os.tmpnam()
+#
+#    if True: #not isinstance(stream, FileStream):
+#        filename = None
+#        realname = os.tmpnam()
+#        file = open(realname, 'w')
+#        oldpos = stream.tell()
+#        stream.seek(0)
+#        file.write(stream.getN(stream.getSize()))
+#        stream.seek(oldpos)
+#        file.close()
+#    else:
+#        print "Ok."
+#        filename = stream.filename
+#        realname = filename
+#       
+#    # TODO: Is it the best value !?
+#    buffersize = 4096 
+#    io = bz2.BZ2File(realname, "r", buffersize)
+#
+#    if filename==None:
+#        os.unlink(realname)
+#
+#    # Check data size (buggy with Python <= 2.4.2 and maybe other)
+#    io.seek(0,2)
+#    guess_size = io.tell()
+#    io.seek(0)
+#
+#    # Check data size
+#    io.seek(-1,2)
+#    real_size = io.tell() + 1
+#    io.seek(0)
+#   
+#    # Workaroud Python bug :-(
+#    if real_size != guess_size:
+#        io = StringIO(io.read())
+#
+#    return FileStream(io, filename)

Added: haypo/hachoir/text_handler.py
===================================================================
--- haypo/hachoir/text_handler.py	2005-12-22 04:10:35 UTC (rev 347)
+++ haypo/hachoir/text_handler.py	2005-12-24 01:47:07 UTC (rev 348)
@@ -0,0 +1,10 @@
+from tools import humanFilesize as doHumanFilesize
+
+def humanFilesize(chunk):
+    return doHumanFilesize(chunk.value)
+
+def hexadecimal(chunk):
+    size = chunk.size
+    assert size in (2, 4, 8)
+    pattern = "%0" + str(2*size) + "X"
+    return pattern % chunk.value



From haypo at berlios.de  Mon Dec 26 04:33:53 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 26 Dec 2005 04:33:53 +0100
Subject: [Happyboom-svn] r350 - haypo/hachoir/tags
Message-ID: <200512260333.jBQ3Xrlx014022@sheep.berlios.de>

Author: haypo
Date: 2005-12-26 04:33:53 +0100 (Mon, 26 Dec 2005)
New Revision: 350

Added:
   haypo/hachoir/tags/2005-12-26/
Log:
Create tag 2005-12-26 (old version with syntax: read, readChild, readString,
readStreamChild, ...).


Copied: haypo/hachoir/tags/2005-12-26 (from rev 349, haypo/hachoir/trunk)



From haypo at berlios.de  Mon Dec 26 05:40:55 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 26 Dec 2005 05:40:55 +0100
Subject: [Happyboom-svn] r352 - haypo/hachoir/trunk
Message-ID: <200512260440.jBQ4etGh019021@sheep.berlios.de>

Author: haypo
Date: 2005-12-26 05:40:55 +0100 (Mon, 26 Dec 2005)
New Revision: 352

Added:
   haypo/hachoir/trunk/NEWS
Log:
Add NEWS file.


Added: haypo/hachoir/trunk/NEWS
===================================================================
--- haypo/hachoir/trunk/NEWS	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/NEWS	2005-12-26 04:40:55 UTC (rev 352)
@@ -0,0 +1,31 @@
+News in version 2005-12-26
+    o Some speed up:
+      - use more caches (eg. for format operations like getting format size)
+      - merge FormatChunkCache and FormatChunk to limit function calls
+    o New command line options: "--use-profiler" and "--debug"
+    o Hide backtrace by default (need "--debug" command line option)
+    o Delete ArrayFilter class, replace it with classical while Python
+      structure.
+    o Add "copy to clipboard" in user interface
+    o Add AVI (written with a new author, Aur?lien Jacobs), MP3, ID3, MBR,
+      EXT2, PCX, BMP, WORMS2 plugins. RPM plugin can now read all headers
+      and also file content.
+    o Kill arbitrary limits (address/size) ;-) (in Chunk/Filter classes and in UI)
+    o Don't support FormatChunk dynamic format (like "{size}s"),
+      nor "@end@" keyword anymore
+    o Start work on "on demand filter": create OnlyFormatsChunkFilter class
+      which only instanciate objects when needed. It's only used
+      in EXT2 plugin yet.
+
+News in version 2005-12-11 (svn commit 314)
+    o First public release
+    o Use GTK+ interface with Glade XML files (dynamically loaded) 
+    o Available plugins : jpeg, ar, email, bzip2, exif, elf, exe, gif,
+      pdf, png, rpm, tar, xcf, zip, gzip, asn1, 3ds
+    o Support three types of chunks: FormatChunk, FilterChunk, StringChunk.
+      String format can be: C, UnixLine, WindowsLine, MacLine, AutoLine.
+    o Use cache for FormatChunk value and FileStream access.
+    o Use MIME type detection to choose the best filter.
+    o Development features:
+      - it's possible to edit chunks list: create, edit, remove chunk
+      - it's possible to store and load a filter into/from XML file



From haypo at berlios.de  Mon Dec 26 05:43:19 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 26 Dec 2005 05:43:19 +0100
Subject: [Happyboom-svn] r353 - haypo/hachoir/trunk
Message-ID: <200512260443.jBQ4hJWO019259@sheep.berlios.de>

Author: haypo
Date: 2005-12-26 05:43:19 +0100 (Mon, 26 Dec 2005)
New Revision: 353

Added:
   haypo/hachoir/trunk/TODO
Modified:
   haypo/hachoir/trunk/BUGS
Log:
Add TODO and update BUGS


Modified: haypo/hachoir/trunk/BUGS
===================================================================
--- haypo/hachoir/trunk/BUGS	2005-12-26 04:40:55 UTC (rev 352)
+++ haypo/hachoir/trunk/BUGS	2005-12-26 04:43:19 UTC (rev 353)
@@ -1,2 +1 @@
-- Set format to last chunk in a sub-filter doesn't work
-  (last chunk always converted to "!%ss" % padding)
+Too much bugs, not enough time ..

Added: haypo/hachoir/trunk/TODO
===================================================================
--- haypo/hachoir/trunk/TODO	2005-12-26 04:40:55 UTC (rev 352)
+++ haypo/hachoir/trunk/TODO	2005-12-26 04:43:19 UTC (rev 353)
@@ -0,0 +1,2 @@
+List of TODO can be found which following command:
+  grep TODO -A3 $(find -name "*.py")



From haypo at berlios.de  Mon Dec 26 06:24:27 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 26 Dec 2005 06:24:27 +0100
Subject: [Happyboom-svn] r354 - haypo/hachoir/tags/2005-12-26
Message-ID: <200512260524.jBQ5OR8V021381@sheep.berlios.de>

Author: haypo
Date: 2005-12-26 06:24:27 +0100 (Mon, 26 Dec 2005)
New Revision: 354

Modified:
   haypo/hachoir/tags/2005-12-26/release.sh
Log:
Fix release date


Modified: haypo/hachoir/tags/2005-12-26/release.sh
===================================================================
--- haypo/hachoir/tags/2005-12-26/release.sh	2005-12-26 04:43:19 UTC (rev 353)
+++ haypo/hachoir/tags/2005-12-26/release.sh	2005-12-26 05:24:27 UTC (rev 354)
@@ -1,5 +1,5 @@
 PACKAGE=hachoir
-VERSION=20051115
+VERSION=2005-12-26
 ARCHIVE=$PACKAGE-$VERSION.tar.bz2
 TMP_DIR=/tmp
 DIR=$PWD



From haypo at berlios.de  Tue Dec 27 00:44:18 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 00:44:18 +0100
Subject: [Happyboom-svn] r355 - in haypo/hachoir/trunk: . broken_plugins plugins stream ui
Message-ID: <200512262344.jBQNiI0a021299@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 00:44:13 +0100 (Tue, 27 Dec 2005)
New Revision: 355

Added:
   haypo/hachoir/trunk/cache.py
   haypo/hachoir/trunk/plugins/ext2.py
   haypo/hachoir/trunk/todo.py
Removed:
   haypo/hachoir/trunk/broken_plugins/ext2.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/config.py
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/format.py
   haypo/hachoir/trunk/plugins/png.py
   haypo/hachoir/trunk/stream/file.py
   haypo/hachoir/trunk/stream/stream.py
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/hachoir.glade
   haypo/hachoir/trunk/ui/ui_window.py
Log:
- humanDuration can display years
- fix stream/stream.py for new FormatChunk syntax
- cache:
  o write a class Cache with getCacheSize() and purgeCache() virtual methods
  o write CacheList to list all caches which have method purgeCaches()
- Chunk can not be moved anymore: you should delete them and recreate others.
  So the chunk don't have to check if it has moved to read it's value.
- Remove Chunk.update() method: have to be rewritten from scratch
- Remove Chunk.clone(): not needed anymore
- Create a class for format cache: FormatCache (original name, isn't it?)
- Fix ext2 plugin for new syntax
- Filter and Chunk can have "static size": so it's not needed to instanciate
  the object to get it's size


Deleted: haypo/hachoir/trunk/broken_plugins/ext2.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/ext2.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/broken_plugins/ext2.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -1,424 +0,0 @@
-"""
-EXT2 (Linux) file system parser.
-
-Sources:
-- EXT2FS source code
-  http://ext2fsd.sourceforge.net/
-- Analysis of the Ext2fs structure
-  http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
-"""
-
-from datetime import datetime
-from filter import Filter, OnDemandFilter
-from plugin import registerPlugin
-from tools import humanDuration, getUnixRWX, humanFilesize
-
-class DirectoryEntry(OnDemandFilter):
-    file_type = {
-        1: "Regular",
-        2: "Directory",
-        3: "Char. dev.",
-        4: "Block dev.",
-        5: "Fifo",
-        6: "Socket",
-        7: "Symlink",
-        8: "Max"
-    }
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "dir", "EXT2 directory entry", stream, parent)
-        self.read("inode", "<L", "Inode")
-        self.read("rec_len", "<H", "Record length")
-        name_length = self.doRead("name_len", "B", "Name length").value
-        self.read("file_type", "B", "File type", post=self.postFileType)
-        self.read("name", "%us" % name_length, "Name")
-        size = self["rec_len"]-8-name_length 
-        if size != 0:
-            self.read("padding", "%us" % size, "Padding")
-
-    def updateParent(self, chunk):        
-        name = self["name"].strip("\0")
-        if name != "":
-            desc = "Directory entry: %s" % name
-        else:
-            desc = "Directory entry (empty)"
-        chunk.description = desc
-        self.setDescription(desc)
-
-    def postFileType(self, chunk):
-        type = chunk.value
-        return DirectoryEntry.file_type.get(type, "Unknow (%02X)" % type)
-
-class Inode(OnDemandFilter):
-    name = {
-        1: "list of bad blocks",
-        2: "Root directory",
-        3: "ACL inode",
-        4: "ACL inode",
-        5: "Boot loader",
-        6: "Undelete directory",
-        8: "EXT3 journal"
-    }
-    
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
-        self.index = index
-        self.read("mode", "<H", "Mode", post=self.postMode)
-        self.read("uid", "<H", "User ID")
-        self.read("size", "<L", "File size")
-        self.read("atime", "<L", "Last access time", post=self.getTime)
-        self.read("ctime", "<L", "Creation time", post=self.getTime)
-        self.read("mtime", "<L", "Last modification time", post=self.getTime)
-        self.read("dtime", "<L", "Delete time", post=self.getTime)
-        self.read("gid", "<H", "Group ID")
-        self.read("links_count", "<H", "Links count")
-        self.read("blocks", "<L", "Number of blocks")
-        self.read("flags", "<L", "Flags")
-        self.read("reserved1", "<L", "Reserved")
-        for i in range(0,15):
-            self.read("block[]", "<L", "Block %i" % i)
-        self.read("version", "<L", "Version")
-        self.read("file_acl", "<L", "File ACL")
-        self.read("dir_acl", "<L", "Directory ACL")
-        self.read("faddr", "<L", "Block where the fragment of the file resides")
-        os = parent.getParent().getParent().superblock["creator_os"]
-        if os == SuperBlock.OS_LINUX:
-            self.read("frag", "B", "Number of fragments in the block")
-            self.read("fsize", "B", "Fragment size")
-            self.read("padding", "<H", "Padding")
-            self.read("uid_high", "<H", "High 16 bits of user ID")
-            self.read("gid_high", "<H", "High 16 bits of group ID")
-            self.read("reserved", "<L", "Reserved")
-        elif os == SuperBlock.OS_HURD:
-            self.read("frag", "B", "Number of fragments in the block")
-            self.read("fsize", "B", "Fragment size")
-            self.read("mode_high", "<H", "High 16 bits of mode")
-            self.read("uid_high", "<H", "High 16 bits of user ID")
-            self.read("gid_high", "<H", "High 16 bits of group ID")
-            self.read("author", "<L", "Author ID (?)")
-        else:
-            self.read("raw", "12s", "Reserved")
-
-    def updateParent(self, chunk):
-        desc = "Inode %s: " % self.index
-        size = humanFilesize(self["size"])
-        if 11 <= self.index:
-            desc = desc + "file, size=%s, mode=%s" % (size, self.getChunk("mode").display)
-        else:
-            if self.index in Inode.name:
-                desc = desc + Inode.name[self.index]
-                if self.index == 2:
-                    desc = desc + " (%s)" % getUnixRWX(self["mode"])
-            else:
-                desc = desc + "special"
-            if size == 0:
-                desc = desc + " (unused)"
-        chunk.description = desc
-        self.setDescription(desc)
-
-    def postMode(self, chunk):
-        mode = chunk.value
-        text = ""
-        if mode & 0100000 != 0:
-            text = "regular (%s)" % getUnixRWX(mode)
-        elif mode & 0040000:
-            text = "directory (%s)" % getUnixRWX(mode)
-        elif mode & 0020000:
-            text = "char. dev."
-        elif mode & 0060000:
-            text = "block dev."
-        elif mode & 0010000:
-            text = "fifo"
-        elif mode & 0120000:
-            text = "sym. link"
-        elif mode & 0140000:
-            text = "socket"
-        elif mode == 0:
-            text = "(empty)"
-        else:
-            text = "???"
-        return text
-
-    def getTime(self, chunk):
-        if chunk.value != 0:
-            return datetime.fromtimestamp(chunk.value)
-        else:
-            return "(empty)"
-
-class Bitmap(OnDemandFilter):
-    def __init__(self, stream, parent, description, count, start):
-        OnDemandFilter.__init__(self, "bitmap", "%s: %s items" % (description, count), stream, parent)
-        self.start = start
-        size = count / 8
-        self.read("block_bitmap", "%us" % size, "Bitmap")
-
-    def showFree(self, type="Block"):
-        data = self["block_bitmap"]
-        cpt = self.start
-        for octet in data:
-            octet = ord(octet)
-            mask = 1
-            for i in range(0,8):
-                if octet & mask == 0:
-                    print "%s %s free." % (type, cpt)
-                cpt = cpt + 1
-                mask = mask << 1
-
-BlockBitmap = Bitmap
-InodeBitmap = Bitmap
-
-class GroupDescriptor(OnDemandFilter):
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, "group", "Group descriptor", stream, parent)
-        self.index = index
-        self.read("block_bitmap", "<L", "Points to the blocks bitmap block")
-        self.read("inode_bitmap", "<L", "Points to the inodes bitmap block")
-        self.read("inode_table", "<L", "Points to the inodes table first block")
-        self.read("free_blocks_count", "<H", "Number of free blocks")
-        self.read("free_inodes_count", "<H", "Number of free inodes")
-        self.read("used_dirs_count", "<H", "Number of inodes allocated to directories")
-        self.read("padding", "<H", "Padding")
-        self.read("reserved", "12s", "Reserved")
-
-    def updateParent(self, chunk):
-        superblock = self.getParent().getParent().superblock
-        blocks_per_group = superblock["blocks_per_group"]
-        start = self.index * blocks_per_group
-        end = start + blocks_per_group 
-        chunk.description = "Group descriptor: blocks %s-%s" % (start, end)
-    
-
-class SuperBlock(OnDemandFilter):
-    error_handling = {
-        1: "Continue"
-    }
-    OS_LINUX = 0
-    OS_HURD = 1
-    os_name = {
-        0: "Linux",
-        1: "Hurd",
-        2: "Masix",
-        3: "FreeBSD",
-        4: "Lites",
-        5: "WinNT"
-    }
-    state = {
-        1: "Valid",
-        2: "Error"
-    }
-    
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "super_block", "Super block", stream, parent)
-        self.read("inodes_count", "<L", "Inodes count")
-        self.read("blocks_count", "<L", "Blocks count")
-        self.read("r_blocks_count", "<L", "Reserved blocks count")
-        self.read("free_blocks_count", "<L", "Free blocks count")
-        self.read("free_inodes_count", "<L", "Free inodes count")
-        first = self.doRead("first_data_block", "<L", "First data block").value
-        assert (first == 0)
-        self.read("log_block_size", "<L", "Block size")
-        self.read("log_frag_size", "<L", "Fragment size")
-        self.read("blocks_per_group", "<L", "Blocks per group")
-        self.read("frags_per_group", "<L", "Fragments per group")
-        self.read("inodes_per_group", "<L", "Inodes per group")
-        self.read("mtime", "<L", "Mount time", post=self.getTime)
-        self.read("wtime", "<L", "Write time", post=self.getTime)
-        self.read("mnt_count", "<H", "Mount count")
-        self.read("max_mnt_count", "<h", "Max mount count")
-        id = self.doRead("magic", ">H", "Magic number (0x53EF)").value
-        assert id == 0x53EF
-
-        # Read state
-        chunk = self.doRead("state", "<H", "File system state")
-        chunk.description = "Behaviour when detecting errors: %s" % \
-            SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
-
-        # Read error handling
-        chunk = self.doRead("errors", "<H", "")
-        desc = "Behaviour when detecting errors"
-        if chunk.value in SuperBlock.error_handling:
-            desc = "%s: %s" % (desc, SuperBlock.error_handling[chunk.value])
-        chunk.description = desc
-        
-        self.read("minor_rev_level", "<H", "Minor revision level")
-        self.read("last_check", "<L", "Time of last check", post=self.getTime)
-        self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
-        
-        chunk = self.doRead("creator_os", "<L", "")
-        desc = "Creator OS"
-        if chunk.value in SuperBlock.os_name:
-            desc = "%s: %s" % (desc, SuperBlock.os_name[chunk.value])
-        chunk.description = desc
-        
-        self.read("rev_level", "<L", "Revision level")
-        self.read("def_resuid", "<H", "Default uid for reserved blocks")
-        self.read("def_resgid", "<H", "Default guid for reserverd blocks")
-
-        # ---------
-
-        self.read("first_ino", "<L", "First non-reserved inode")
-        inode_size = self.doRead("inode_size", "<H", "Size of inode structure").value
-        assert inode_size == (68 + 15*4)
-        self.read("block_group_nr", "<H", "Block group # of this superblock")
-        self.read("feature_compat", "<L", "Compatible feature set")
-        self.read("feature_incompat", "<L", "Incompatible feature set")
-        self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
-        self.read("uuid", "16s", "128-bit uuid for volume")
-        self.read("volume_name", "16s", "Volume name")
-        self.read("last_mounted", "64s", "Directory where last mounted")
-        self.read("compression", "<L", "For compression (algorithm usage bitmap)")
-        
-        self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
-        self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
-        self.read("padding", "H", "Padding")
-        
-        self.read("journal_uuid", "16s", "uuid of journal superblock")
-        self.read("journal_inum", "<L", "inode number of journal file")
-        self.read("journal_dev", "<L", "device number of journal file")
-        self.read("last_orphan", "<L", "start of list of inodes to delete")
-        
-        self.read("reserved", "197s", "Padding to the end of the block")
-
-        blocks_per_group = self["blocks_per_group"]
-        self.group_count = (self["blocks_count"] - self["first_data_block"] + blocks_per_group - 1) / blocks_per_group
-
-    def updateParent(self, chunk):
-        if self["feature_compat"] & 4 == 4:
-            type = "ext3"
-        else:
-            type = "ext2"
-        desc = "Superblock: %s file system" % type
-        self.setDescription(desc)
-        chunk.description = desc
-
-    def postMaxTime(self, chunk):
-        return humanDuration(chunk.value * 1000)
-
-    def getTime(self, chunk):
-        return datetime.fromtimestamp(chunk.value)
-
-class GroupDescriptors(OnDemandFilter):
-    def __init__(self, stream, parent, count, start):
-        OnDemandFilter.__init__(self, "groups", "Group descriptors: %s items" % count, stream, parent)
-        self.start = start
-        for i in range(0, count):
-            self.readSizedChild("group[]", "Group", 32, GroupDescriptor, i)
-
-    def getGroup(self, index):
-        return self["group[%s]" % (self.start + index)]
-
-class InodeTable(OnDemandFilter):
-    def __init__(self, stream, parent, start, count):
-        OnDemandFilter.__init__(self, "ino_table", "Inode table: %s inodes" % count, stream, parent)
-        self.start = start
-        chunk_size = parent.getParent().superblock["inode_size"]
-        for index in range(self.start, self.start+count):
-            self.readSizedChild("inode[]", "Inode %s" % index, chunk_size, Inode, index)
-
-    def __getitem__(self, index):
-        index = index - self.start - 1
-        return self.getChunk("inode[%u]" % index).getFilter()
-
-def testSuperblock(stream):
-    oldpos = stream.tell()
-    stream.seek(80-24, 1)
-    is_super = stream.getN(2) == "\x53\xEF"    
-    stream.seek(oldpos)
-    return is_super
-
-class Group(OnDemandFilter):
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, "group", "Group %u" % index, stream, parent)
-        self.index = index
-        group = parent["group_desc"].getGroup(index)
-        superblock = parent.superblock
-        block_size = parent.block_size
-    
-        # Read block bitmap
-        self.superblock_copy = False
-        if testSuperblock(stream):
-            self.readChild("superblock_copy", "Superblock", SuperBlock)
-            self.superblock_copy = True
-        self.seek(group["block_bitmap"] * block_size)
-            
-        count = superblock["blocks_per_group"]
-        self.readSizedChild("block_bitmap[]", "Block bitmap", count / 8, BlockBitmap, "Block bitmap", count, 0)
-
-        # Read inode bitmap
-        assert (group["inode_bitmap"] * block_size) == stream.tell()
-        count = superblock["inodes_per_group"]
-        self.readSizedChild("inode_bitmap[]", "Inode bitmap", count / 8, InodeBitmap, "Inode bitmap", count, 1)
-        addr = stream.tell() % 4096
-        if addr != 0:
-            addr = stream.tell() + (4096 - addr % 4096)
-            self.seek(addr)
-             
-        count = superblock["inodes_per_group"]
-        size = superblock["inode_size"] * count
-        inode_index = 1 + index * count
-        self.readSizedChild("inode_table[]", "Inode table", size, InodeTable, inode_index, count)
-
-        size = (index+1) * superblock["blocks_per_group"] * block_size
-        if stream.getSize() < size:
-            size = stream.getSize()
-        size = size - stream.tell() 
-        self.read("data", "%us" % size, "Data")
-
-    def updateParent(self, chunk):
-        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
-        if self.superblock_copy:
-            desc = desc + " (with superblock copy)"
-        chunk.description = desc 
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 <= size
-        if 0 < size:
-            self.read("raw[]", "%us" % size, "Raw")
-
-
-class EXT2_FS(OnDemandFilter):
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)
-        
-        # Read superblock
-        self.seek(1024) 
-        self.superblock = self.doReadChild("superblock", "Super block", SuperBlock).getFilter()
-        self.block_size = 1024 << self.superblock["log_block_size"]
-
-        # Read groups
-        self.seek(4096) 
-        groups = self.doReadChild("group_desc", "Group descriptors", GroupDescriptors, self.superblock.group_count, 0).getFilter()
-        self.seek(groups.getGroup(0)["block_bitmap"] * self.block_size)
-        for i in range(0,self.superblock.group_count):
-            self.readChild("group[]", "Group", Group, i)
-
-        size = stream.getSize() - stream.tell()
-        if size != 0:
-            self.read("end", "%us" % size, "End (raw)")
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 <= size
-        if 0 < size:
-            self.read("raw[]", "%us" % size, "Raw")
-
-    def readDirectory(self, inode):
-        stream = self.getStream()
-        block_index = 0
-        while True:
-            assert block_index < 12
-            block = inode["block[%u]" % block_index]
-            if block == 0:
-                return
-            self.seek(block * self.block_size)
-
-            total = 0
-            while total < self.block_size:
-                entry = self.doReadChild("directory[]", "Directory entry", DirectoryEntry).getFilter()
-                if entry["inode"] == 0:
-                    return
-                total = total + entry.getSize()
-            assert total == self.block_size
-            block_index = block_index + 1
-
-registerPlugin(EXT2_FS, "hachoir/fs-ext2")

Added: haypo/hachoir/trunk/cache.py
===================================================================
--- haypo/hachoir/trunk/cache.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/cache.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -0,0 +1,50 @@
+import gc
+from todo import todoWriteMethod
+
+class CacheList:
+    _instance = None
+
+    def __init__(self):
+        assert CacheList._instance == None
+        self._list = []
+
+    def purgeCaches(self):
+        size = self.getSize()
+        for value in self._list:
+            item, name = value
+            item.purgeCache()
+        gc.collect()            
+        print "Purge caches: clear %s item(s)" % size
+
+    def output(self):
+        size = 0
+        nb_obj = 0
+        print "--- Caches"
+        for value in self._list:
+            item, name = value
+            size = item.getCacheSize()
+            nb_obj += size
+            if size != 0:
+                print "o %s: %s item(s)" % (name, size)
+        print "--- Total = %s item(s)" % (nb_obj)
+
+    def getSize(self):
+        size = 0
+        for value in self._list:
+            size += value[0].getCacheSize()
+        return size           
+
+    def register(self, item, name):
+        self._list.append( (item,name) )
+
+    def getInstance():
+        if CacheList._instance == None:
+            CacheList._instance = CacheList()
+        return CacheList._instance
+    getInstance = staticmethod(getInstance)
+
+class Cache:
+    def __init__(self, name):
+        CacheList.getInstance().register(self, name)
+    def getCacheSize(self): todoWriteMethod(self, "getCacheSize")
+    def purgeCache(self): todoWriteMethod(self, "purgeCache")

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/chunk.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -5,6 +5,9 @@
 from tools import convertDataToPrintableString
 
 class Chunk(object):
+    """
+    A chunk address is fixed. If you want to move the chunk, delete it :-P
+    """
     def __init__(self, id, description, stream, addr, size, parent):
         self._id = id
         self.description = description
@@ -15,6 +18,10 @@
         self.post_process = None
         self.display = None
 
+    def getStaticSize(stream, args):
+        return None
+    getStaticSize = staticmethod(getStaticSize)
+
     def clone(self):
         raise Exception("%s doesn't implement clone() method!" % self)
 
@@ -28,10 +35,6 @@
     def getSmallFormat(self):
         return self.__class__.__name__
 
-    def update(self):
-        self.display = None
-        self.postProcess()
-
     def getStream(self):
         return self._stream
 
@@ -64,7 +67,6 @@
     def setParent(self, parent):
         self._parent = parent
     def getParent(self): return self._parent
-    def _setAddr(self, addr): self._addr = addr
     def _getAddr(self): return self._addr
     def _getSize(self): return self._size
     def _getId(self):
@@ -75,7 +77,7 @@
             return
         self._id = new_id
         self._parent.updateChunkId(old_id, new_id)
-    addr = property(_getAddr, _setAddr)        
+    addr = property(_getAddr)
     size = property(_getSize)        
     id = property(_getId, _setId)
     value = property(getValue)
@@ -93,33 +95,16 @@
             filter.getSize(), parent)
         self._description = filter.getDescription()
     
-    def clone(self, addr=None):
-        filter_copy = self._filter.clone(addr=addr)
-        # TODO: Is it always alright? (or use parent_addr = self.parent_addr)
-        parent_addr = addr
-        return FilterChunk(self.id, filter_copy, self.getParent(), parent_addr)
-    
     def getFormat(self):
         return self.__class__.__name__ + " (%s)" % self._filter.__class__.__name__
 
     def getSmallFormat(self):
         return self._filter.__class__.__name__
 
-    def update(self):
-        new = self._filter.clone()
-        if new != None:
-            self.setFilter(new)
-        Chunk.update(self)
-
     def setFilter(self, filter):
         self._filter = filter
         self._filter.updateParent(self)
     
-    def _setAddr(self, addr):
-        self._addr = addr
-        self._filter.setAddr(addr)
-    addr = property(Chunk._getAddr, _setAddr)        
-        
     def _getSize(self):
         return self._filter.getSize()
     size = property(_getSize)        
@@ -172,9 +157,6 @@
         self._str_type = str_type
         self.eol = None
         self._findSize()
-        self._cache_addr = None
-        self._cache_max_size = None
-        self._cache_value = None
         self.strip = strip
 
     def getFormat(self):
@@ -221,11 +203,6 @@
         self._stream.seek(self.addr + self._size)
         
     def _read(self, max_size):
-        if self._cache_addr==self.addr and self._cache_max_size==max_size:
-            return self._cache_value
-        self._cache_addr = self.addr
-        self._cache_max_size = max_size
-
         self._stream.seek(self.addr)
         if self._str_type == "Pascal32":
             self._stream.seek(4,1)
@@ -245,13 +222,8 @@
                 text = text.strip()
             else:
                 text = text.strip(self.strip)
-        self._cache_value = text
         return text
 
-    def update(self):
-        Chunk.update(self)
-        self._findSize()
-
     def getValue(self, max_size=None):
         return self._read(None)
     value = property(getValue)
@@ -268,7 +240,12 @@
         Chunk.__init__(self, id, description, stream, stream.tell(), None, parent)
         self._format = None
         self._doSetFormat(format)
+        stream.seek(self.size, 1)
 
+    def getStaticSize(stream, args):
+        return getFormatSize(args[0])
+    getStaticSize = staticmethod(getStaticSize)
+
     def _doSetFormat(self, format):
         if format == self._format:
             return
@@ -295,11 +272,6 @@
             addr = self._addr
         return FormatChunk(self.id, self.description, self._stream, addr, self._format, self._parent)
 
-    def _setAddr(self, addr):
-        self._addr = addr
-        self._value = {}
-    addr = property(Chunk._getAddr, _setAddr)
-
     def getFormat(self):
         return self.__class__.__name__ + " (%s)" % self._format
 

Modified: haypo/hachoir/trunk/config.py
===================================================================
--- haypo/hachoir/trunk/config.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/config.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -1,5 +1,12 @@
-max_string_length = 10
-max_hexa_length = 4096 
-max_ascii_length = 4096 
+# UI: display options
+max_string_length = 10    # Max. length of displayed string
+max_hexa_length = 4096    # Max. length of raw data displayed in hex
+max_ascii_length = 4096   # Max. length of raw data displayed in ASCII
+
+# Global options
 debug = False
 verbose = False
+
+# Size of file cache (for each opened file)
+file_cache_block_size = 4096
+file_cache_block_count = 10

Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/filter.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -8,6 +8,7 @@
 from chunk import Chunk, FormatChunk, FilterChunk, StringChunk, BitsChunk
 from error import error
 from format import getFormatSize, splitFormat
+from cache import Cache
 
 class BasicFilter(object):
     regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
@@ -23,6 +24,10 @@
         self._endian = endian
         self.filter_chunk = None
 
+    def getStaticSize(stream, args):
+        return None
+    getStaticSize = staticmethod(getStaticSize)
+
     def updateParent(self, chunk): pass
     def getId(self): return self._id
     def setId(self, id):
@@ -34,7 +39,6 @@
     def getDescription(self): return self._description
     def setDescription(self, description): self._description = description
     def getAddr(self): return self._addr
-    def setAddr(self, addr): self._addr = addr
     def getParent(self): return self._parent
     def getStream(self): return self._stream
     def updateChunkId(self, old_id, new_id): pass
@@ -90,22 +94,26 @@
     def hasChunk(self, id):
         return id in self._chunks_dict
 
-    # --- Pure virtual methods -----------
-    def getSize(self): assert False
-    def __getitem__(self, chunk_id): assert False
-    def getChunk(self, chunk_id): assert False
-    def display(self): assert False
-
     def _getEndian(self): return self._endian
     endian = property(_getEndian)
 
-class OnDemandFilter(BasicFilter):
+    # --- Pure virtual methods -----------
+    def getSize(self): todoWriteMethod(self, "getSize") 
+    def __getitem__(self, chunk_id): todoWriteMethod(self, "__getitem__") 
+    def getChunk(self, chunk_id): todoWriteMethod(self, "getChunk")
+    def display(self): todoWriteMethod(self, "display")
+
+class OnDemandFilter(BasicFilter, Cache):
     def __init__(self, id, description, stream, parent, endian=None):
         BasicFilter.__init__(self, id, description, stream, parent, stream.tell(), endian)
+        Cache.__init__(self, "Filter %s" % id)
         self._size = 0
         self._chunks = []
         self._chunks_cache = {}
-    
+   
+    def getCacheSize(self):
+        return len(self._chunks_cache)
+
     def updateChunkId(self, old_id, new_id):
         # Update self._chunks
         pos = self._chunks.index(old_id)
@@ -137,7 +145,7 @@
         ui.window.update_table(self, pos, *info)
 
     def purgeCache(self):
-        if len(self._chunks_cache) != 0:
+        if len(self._chunks_cache) != 0 and config.verbose:
             print "Purge cache: destroy %s chunks" % len(self._chunks_cache)
         self._chunks_cache = {}
         
@@ -150,8 +158,11 @@
             size = optionnal.get("size", None)
             filter_addr = filter_stream.tell()
             args = info[1:]
-
             if size == None:
+                size = chunk_class.getStaticSize(self._stream, info[1:])
+#                if size != None:
+#                    optionnal["size"] = size
+            if size == None:
                 filter = chunk_class(filter_stream, self, *args)
                 description = filter.getDescription()
                 filter.setId(id)
@@ -182,11 +193,12 @@
             else:
                 args = [ i for i in info[1:] ]
             instance_info = [info[0], id, description, self._stream]+args+[self]
-            # TODO: Use static method to get chunk fixed size (if existing)
-            if chunk_class == FormatChunk:
-                size = getFormatSize(info[1])
+
+            size = chunk_class.getStaticSize(self._stream, info[1:])
+            if size != None:
                 self._stream.seek(size, 1)
             else:
+                # Instanciate the chunk
                 seek = False
                 chunk = info[0] (*instance_info[1:], **optionnal)
                 size = chunk.size

Modified: haypo/hachoir/trunk/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/format.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -1,74 +1,101 @@
 import re, struct
+from cache import Cache
 
-_regex_array =  re.compile("^([a-z]+[0-9]*)\[([0-9]+)\]$")
-_format_size_cache = {}
-_format_type = {
-    "string": "s",
-    "char": "c",
-    "float": "f",
-    "double": "d",
-    "int8": "b",
-    "uint8": "B",
-    "int16": "h",
-    "uint16": "H",
-    "int32": "l",
-    "uint32": "L"
-}
+class FormatCache(Cache):
+    # Uniq instance of the class
+    _instance = None
 
-def _convertNewFormat(format):
-    old_format = format
-    if format[0] in "!<>":
-        endian = format[0]
-        str_endian = format[0]
-        format = format[1:]
-    else:
-        endian = None
-        str_endian = ""
-    m = _regex_array.match(format)
-    if m != None:
-        format = m.group(1)
-        str_count = m.group(2)
-        count = int(str_count)
-    else:
-        str_count = "" 
-        count = 1
-    if format not in _format_type:
-        raise Exception("Format \"%s\" is invalid!" % old_format)
-    type = _format_type[format]
-    return (str_endian + str_count + type, endian, count, type)
+    # Check if a format is an array or not
+    # "string[4]" is an array, "char" isn't
+    regex_array =  re.compile("^([a-z]+[0-9]*)\[([0-9]+)\]$")
 
-def _getFormatCache(format):
-    global _format_size_cache
-    if format not in _format_size_cache:
-        real_format, endian, count, type = _convertNewFormat(format)
-        size = count * struct.calcsize(type)
-        _format_size_cache[format] = (real_format, endian, count, type, size)
-    return _format_size_cache[format]   
+    # Convert Hachoir syntax to struct module syntax
+    format_type = {
+        "string": "s",
+        "char": "c",
+        "float": "f",
+        "double": "d",
+        "int8": "b",
+        "uint8": "B",
+        "int16": "h",
+        "uint16": "H",
+        "int32": "l",
+        "uint32": "L"
+    }
+    
+    def __init__(self):
+        assert FormatCache._instance == None
+        Cache.__init__(self, "FormatCache")
+        self._dict = {}
 
+    def getCacheSize(self):
+        return len(self._dict)
+
+    def purgeCache(self):
+        self._dict = {}
+
+    def convertNewFormat(self, format):
+        old_format = format
+        if format[0] in "!<>":
+            endian = format[0]
+            str_endian = format[0]
+            format = format[1:]
+        else:
+            endian = None
+            str_endian = ""
+        m = FormatCache.regex_array.match(format)
+        if m != None:
+            format = m.group(1)
+            str_count = m.group(2)
+            count = int(str_count)
+        else:
+            str_count = "" 
+            count = 1
+        if format not in FormatCache.format_type:
+            raise Exception("Format \"%s\" is invalid!" % old_format)
+        type = FormatCache.format_type[format]
+        return (str_endian + str_count + type, endian, count, type)
+
+    def __getitem__(self, format):
+        if format not in self._dict:
+            real_format, endian, count, type = self.convertNewFormat(format)
+            size = count * struct.calcsize(type)
+            self._dict[format] = (real_format, endian, count, type, size)
+        return self._dict[format]   
+
+    def getInstance():
+        if FormatCache._instance == None:
+            FormatCache._instance = FormatCache()
+        return FormatCache._instance
+    getInstance = staticmethod(getInstance)        
+
+_format_size_cache = {}
+
 def formatIsString(format):
-    cache = _getFormatCache(format)
+    cache = FormatCache.getInstance()[format]
     return cache[3] == "s"
 
 def formatIsInteger(format):
-    cache = _getFormatCache(format)
+    cache = FormatCache.getInstance()[format]
     return cache[3] in "bBhHlL"
 
 def getFormatSize(format):
-    cache = _getFormatCache(format)
+    cache = FormatCache.getInstance()[format]
     return cache[4]   
 
 def getRealFormat(format):
-    cache = _getFormatCache(format)
+    cache = FormatCache.getInstance()[format]
     return cache[0]   
 
 def checkFormat(format):
     # TODO: Don't use try/except, but something better
     try:
-        conv = _convertNewFormat(format)
+        cache = FormatCache.getInstance()
+        conv = cache.convertNewFormat(format)
         return True
     except:
         return False
 
 def splitFormat(format):
-    cache = _getFormatCache(format)
+    cache = FormatCache.getInstance()[format]
     return cache[1:4]   

Copied: haypo/hachoir/trunk/plugins/ext2.py (from rev 351, haypo/hachoir/trunk/broken_plugins/ext2.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/ext2.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/ext2.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -0,0 +1,401 @@
+"""
+EXT2 (Linux) file system parser.
+
+Sources:
+- EXT2FS source code
+  http://ext2fsd.sourceforge.net/
+- Analysis of the Ext2fs structure
+  http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
+"""
+
+from text_handler import unixTimestamp
+from chunk import EnumChunk, FormatChunk
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from tools import humanDuration, getUnixRWX, humanFilesize
+
+class DirectoryEntry(OnDemandFilter):
+    file_type = {
+        1: "Regular",
+        2: "Directory",
+        3: "Char. dev.",
+        4: "Block dev.",
+        5: "Fifo",
+        6: "Socket",
+        7: "Symlink",
+        8: "Max"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "dir", "EXT2 directory entry", stream, parent, "<")
+        self.read("inode", "Inode", (FormatChunk, "uint32"))
+        self.read("rec_len", "Record length", (FormatChunk, "uint16"))
+        name_length = self.doRead("name_len", "B", "Name length", (FormatChunk, "uint8")).value
+        self.read("file_type", "File type", (EnumChunk, "uint8", DirectoryEntry.file_type))
+        self.read("name", "File name", (FormatChunk, "string[%u]" % name_length))
+        size = self["rec_len"]-8-name_length 
+        if size != 0:
+            self.read("padding", "Padding", (FormatChunk, "string[%u]" % size))
+
+    def updateParent(self, chunk):        
+        name = self["name"].strip("\0")
+        if name != "":
+            desc = "Directory entry: %s" % name
+        else:
+            desc = "Directory entry (empty)"
+        chunk.description = desc
+        self.setDescription(desc)
+
+class Inode(OnDemandFilter):
+    name = {
+        1: "list of bad blocks",
+        2: "Root directory",
+        3: "ACL inode",
+        4: "ACL inode",
+        5: "Boot loader",
+        6: "Undelete directory",
+        8: "EXT3 journal"
+    }
+    
+    def __init__(self, stream, parent, index):
+        OnDemandFilter.__init__(self, "inode", "EXT2 inode", stream, parent, "<")
+        self.index = index
+        self.read("mode", "Mode", (FormatChunk, "uint16"), {"post": self.postMode})
+        self.read("uid", "User ID", (FormatChunk, "uint16"))
+        self.read("size", "File size", (FormatChunk, "uint32"))
+        self.read("atime", "Last access time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("ctime", "Creation time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("mtime", "Last modification time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("dtime", "Delete time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("gid", "Group ID", (FormatChunk, "uint16"))
+        self.read("links_count", "Links count", (FormatChunk, "uint16"))
+        self.read("blocks", "Number of blocks", (FormatChunk, "uint32"))
+        self.read("flags", "Flags", (FormatChunk, "uint32"))
+        self.read("reserved1", "Reserved", (FormatChunk, "uint32"))
+        for i in range(0,15):
+            self.read("block[]", "Block %i" % i, (FormatChunk, "uint32"))
+        self.read("version", "Version", (FormatChunk, "uint32"))
+        self.read("file_acl", "File ACL", (FormatChunk, "uint32"))
+        self.read("dir_acl", "Directory ACL", (FormatChunk, "uint32"))
+        self.read("faddr", "Block where the fragment of the file resides", (FormatChunk, "uint32"))
+        os = parent.getParent().getParent().superblock["creator_os"]
+        if os == SuperBlock.OS_LINUX:
+            self.read("frag", "Number of fragments in the block", (FormatChunk, "uint8"))
+            self.read("fsize", "Fragment size", (FormatChunk, "uint8"))
+            self.read("padding", "Padding", (FormatChunk, "uint16"))
+            self.read("uid_high", "High 16 bits of user ID", (FormatChunk, "uint16"))
+            self.read("gid_high", "High 16 bits of group ID", (FormatChunk, "uint16"))
+            self.read("reserved", "Reserved", (FormatChunk, "uint32"))
+        elif os == SuperBlock.OS_HURD:
+            self.read("frag", "Number of fragments in the block", (FormatChunk, "uint8"))
+            self.read("fsize", "Fragment size", (FormatChunk, "uint8"))
+            self.read("mode_high", "High 16 bits of mode", (FormatChunk, "uint16"))
+            self.read("uid_high", "High 16 bits of user ID", (FormatChunk, "uint16"))
+            self.read("gid_high", "High 16 bits of group ID", (FormatChunk, "uint16"))
+            self.read("author", "Author ID (?)", (FormatChunk, "uint32"))
+        else:
+            self.read("raw", "Reserved", (FormatChunk, "string[12]"))
+
+    def getStaticSize(stream, args):
+        return 68 + 15*4
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        desc = "Inode %s: " % self.index
+        size = humanFilesize(self["size"])
+        if 11 <= self.index:
+            desc = desc + "file, size=%s, mode=%s" % (size, self.getChunk("mode").display)
+        else:
+            if self.index in Inode.name:
+                desc = desc + Inode.name[self.index]
+                if self.index == 2:
+                    desc = desc + " (%s)" % getUnixRWX(self["mode"])
+            else:
+                desc = desc + "special"
+            if size == 0:
+                desc = desc + " (unused)"
+        chunk.description = desc
+        self.setDescription(desc)
+
+    def postMode(self, chunk):
+        mode = chunk.value
+        text = ""
+        if mode & 0100000 != 0:
+            text = "regular (%s)" % getUnixRWX(mode)
+        elif mode & 0040000:
+            text = "directory (%s)" % getUnixRWX(mode)
+        elif mode & 0020000:
+            text = "char. dev."
+        elif mode & 0060000:
+            text = "block dev."
+        elif mode & 0010000:
+            text = "fifo"
+        elif mode & 0120000:
+            text = "sym. link"
+        elif mode & 0140000:
+            text = "socket"
+        elif mode == 0:
+            text = "(empty)"
+        else:
+            text = "???"
+        return text
+
+class Bitmap(OnDemandFilter):
+    def __init__(self, stream, parent, description, count, start):
+        OnDemandFilter.__init__(self, "bitmap", "%s: %s items" % (description, count), stream, parent)
+        self.start = start
+        size = count / 8
+        self.read("block_bitmap", "Bitmap", (FormatChunk, "string[%u]" % size))
+
+    def showFree(self, type="Block"):
+        data = self["block_bitmap"]
+        cpt = self.start
+        for octet in data:
+            octet = ord(octet)
+            mask = 1
+            for i in range(0,8):
+                if octet & mask == 0:
+                    print "%s %s free." % (type, cpt)
+                cpt = cpt + 1
+                mask = mask << 1
+
+BlockBitmap = Bitmap
+InodeBitmap = Bitmap
+
+class GroupDescriptor(OnDemandFilter):
+    def __init__(self, stream, parent, index):
+        OnDemandFilter.__init__(self, "group", "Group descriptor", stream, parent, "<")
+        self.index = index
+        self.read("block_bitmap", "Points to the blocks bitmap block", (FormatChunk, "uint32"))
+        self.read("inode_bitmap", "Points to the inodes bitmap block", (FormatChunk, "uint32"))
+        self.read("inode_table", "Points to the inodes table first block", (FormatChunk, "uint32"))
+        self.read("free_blocks_count", "Number of free blocks", (FormatChunk, "uint16"))
+        self.read("free_inodes_count", "Number of free inodes", (FormatChunk, "uint16"))
+        self.read("used_dirs_count", "Number of inodes allocated to directories", (FormatChunk, "uint16"))
+        self.read("padding", "Padding", (FormatChunk, "uint16"))
+        self.read("reserved", "Reserved", (FormatChunk, "string[12]"))
+
+    def getStaticSize(stream, args):
+        return 32
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        superblock = self.getParent().getParent().superblock
+        blocks_per_group = superblock["blocks_per_group"]
+        start = self.index * blocks_per_group
+        end = start + blocks_per_group 
+        chunk.description = "Group descriptor: blocks %s-%s" % (start, end)
+    
+
+class SuperBlock(OnDemandFilter):
+    error_handling = {
+        1: "Continue"
+    }
+    OS_LINUX = 0
+    OS_HURD = 1
+    os_name = {
+        0: "Linux",
+        1: "Hurd",
+        2: "Masix",
+        3: "FreeBSD",
+        4: "Lites",
+        5: "WinNT"
+    }
+    state = {
+        1: "Valid",
+        2: "Error"
+    }
+   
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "super_block", "Super block", stream, parent, "<")
+        self.read("inodes_count", "Inodes count", (FormatChunk, "uint32"))
+        self.read("blocks_count", "Blocks count", (FormatChunk, "uint32"))
+        self.read("r_blocks_count", "Reserved blocks count", (FormatChunk, "uint32"))
+        self.read("free_blocks_count", "Free blocks count", (FormatChunk, "uint32"))
+        self.read("free_inodes_count", "Free inodes count", (FormatChunk, "uint32"))
+        self.read("first_data_block", "First data block", (FormatChunk, "uint32"))
+        assert self["first_data_block"] == 0
+        self.read("log_block_size", "Block size", (FormatChunk, "uint32"))
+        self.read("log_frag_size", "Fragment size", (FormatChunk, "uint32"))
+        self.read("blocks_per_group", "Blocks per group", (FormatChunk, "uint32"))
+        self.read("frags_per_group", "Fragments per group", (FormatChunk, "uint32"))
+        self.read("inodes_per_group", "Inodes per group", (FormatChunk, "uint32"))
+        self.read("mtime", "Mount time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("wtime", "Write time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("mnt_count", "Mount count", (FormatChunk, "uint16"))
+        self.read("max_mnt_count", "Max mount count", (FormatChunk, "int16"))
+        self.read("magic", "Magic number (0x53EF)", (FormatChunk, "string[2]"))
+        assert self["magic"] == "\x53\xEF"
+        self.read("state", "File system state", (EnumChunk, "uint16", SuperBlock.state))
+        self.read("errors", "Behaviour when detecting errors", (EnumChunk, "uint16", SuperBlock.error_handling))
+        self.read("minor_rev_level", "Minor revision level", (FormatChunk, "uint16"))
+        self.read("last_check", "Time of last check", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("check_interval", "Maximum time between checks", (FormatChunk, "uint32"), {"post": self.postMaxTime})        
+        self.read("creator_os", "Creator OS", (EnumChunk, "uint32", SuperBlock.os_name))        
+        self.read("rev_level", "Revision level", (FormatChunk, "uint32"))
+        self.read("def_resuid", "Default uid for reserved blocks", (FormatChunk, "uint16"))
+        self.read("def_resgid", "Default guid for reserverd blocks", (FormatChunk, "uint16"))
+        self.read("first_ino", "First non-reserved inode", (FormatChunk, "uint32"))
+        self.read("inode_size", "Size of inode structure", (FormatChunk, "uint16"))
+        assert self["inode_size"] == (68 + 15*4)
+        self.read("block_group_nr", "Block group # of this superblock", (FormatChunk, "uint16"))
+        self.read("feature_compat", "Compatible feature set", (FormatChunk, "uint32"))
+        self.read("feature_incompat", "Incompatible feature set", (FormatChunk, "uint32"))
+        self.read("feature_ro_compat", "Read-only compatible feature set", (FormatChunk, "uint32"))
+        self.read("uuid", "128-bit uuid for volume", (FormatChunk, "string[16]"))
+        self.read("volume_name", "Volume name", (FormatChunk, "string[16]"))
+        self.read("last_mounted", "Directory where last mounted", (FormatChunk, "string[64]"))
+        self.read("compression", "For compression (algorithm usage bitmap)", (FormatChunk, "uint32"))
+        self.read("prealloc_blocks", "Number of blocks to try to preallocate", (FormatChunk, "uint8"))
+        self.read("prealloc_dir_blocks", "Number to preallocate for directories", (FormatChunk, "uint8"))
+        self.read("padding", "Padding", (FormatChunk, "uint16"))
+        self.read("journal_uuid", "uuid of journal superblock", (FormatChunk, "string[16]"))
+        self.read("journal_inum", "inode number of journal file", (FormatChunk, "uint32"))
+        self.read("journal_dev", "device number of journal file", (FormatChunk, "uint32"))
+        self.read("last_orphan", "start of list of inodes to delete", (FormatChunk, "uint32"))
+        self.read("reserved", "Padding to the end of the block", (FormatChunk, "string[197]"))
+
+        # Calculate number of groups
+        blocks_per_group = self["blocks_per_group"]
+        self.group_count = (self["blocks_count"] - self["first_data_block"] + (blocks_per_group - 1)) / blocks_per_group
+
+    def getStaticSize(stream, args):
+        return 433
+    getStaticSize = staticmethod(getStaticSize)
+ 
+    def updateParent(self, chunk):
+        if self["feature_compat"] & 4 == 4:
+            type = "ext3"
+        else:
+            type = "ext2"
+        desc = "Superblock: %s file system" % type
+        self.setDescription(desc)
+        chunk.description = desc
+
+    def postMaxTime(self, chunk):
+        return humanDuration(chunk.value * 1000)
+
+class GroupDescriptors(OnDemandFilter):
+    def __init__(self, stream, parent, count, start):
+        OnDemandFilter.__init__(self, "groups", "Group descriptors: %s items" % count, stream, parent)
+        self.start = start
+        for i in range(0, count):
+            self.read("group[]", "Group", (GroupDescriptor, i))
+
+    def getGroup(self, index):
+        return self["group[%s]" % (self.start + index)]
+
+class InodeTable(OnDemandFilter):
+    def __init__(self, stream, parent, start, count):
+        OnDemandFilter.__init__(self, "ino_table", "Inode table: %s inodes" % count, stream, parent)
+        self.start = start
+        for index in range(self.start, self.start+count):
+            self.read("inode[]", "Inode %s" % index, (Inode, index))
+
+    def __getitem__(self, index):
+        index = index - self.start - 1
+        return self.getChunk("inode[%u]" % index).getFilter()
+
+def testSuperblock(stream):
+    oldpos = stream.tell()
+    stream.seek(56, 1)
+    magic = stream.getN(2)    
+    stream.seek(oldpos)
+    return (magic == "\x53\xEF")
+
+class Group(OnDemandFilter):
+    def __init__(self, stream, parent, index):
+        OnDemandFilter.__init__(self, "group", "Group %u" % index, stream, parent)
+        self.index = index
+        group = parent["group_desc"].getGroup(index)
+        superblock = parent.superblock
+        block_size = parent.block_size
+    
+        # Read block bitmap
+        self.superblock_copy = False
+        if testSuperblock(stream):
+            self.read("superblock_copy", "Superblock", (SuperBlock,))
+            self.superblock_copy = True
+        self.seek(group["block_bitmap"] * block_size)
+            
+        count = superblock["blocks_per_group"]
+        self.read("block_bitmap[]", "Block bitmap", (BlockBitmap, "Block bitmap", count, 0), {"size": count / 8})
+
+        # Read inode bitmap
+        assert (group["inode_bitmap"] * block_size) == stream.tell()
+        count = superblock["inodes_per_group"]
+        self.read("inode_bitmap[]", "Inode bitmap", (InodeBitmap, "Inode bitmap", count, 1), {"size": count / 8})
+        addr = stream.tell() % 4096
+        if addr != 0:
+            addr = stream.tell() + (4096 - addr % 4096)
+            self.seek(addr)
+             
+        count = superblock["inodes_per_group"]
+        size = superblock["inode_size"] * count
+        inode_index = 1 + index * count
+        self.read("inode_table[]", "Inode table", (InodeTable, inode_index, count), {"size": size})
+
+        size = (index+1) * superblock["blocks_per_group"] * block_size
+        if stream.getSize() < size:
+            size = stream.getSize()
+        size = size - stream.tell() 
+        self.read("data", "Data", (FormatChunk, "string[%u]" % size))
+
+    def updateParent(self, chunk):
+        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
+        if self.superblock_copy:
+            desc = desc + " (with superblock copy)"
+        chunk.description = desc 
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        assert 0 <= size
+        if 0 < size:
+            self.read("raw[]", "Raw", (FormatChunk, "string[%u]" % size))
+
+
+class EXT2_FS(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)
+        
+        # Read superblock
+        self.seek(1024) 
+        self.superblock = self.doRead("superblock", "Super block", (SuperBlock,))
+        self.block_size = 1024 << self.superblock["log_block_size"]
+
+        # Read groups
+        self.seek(4096) 
+        groups = self.doRead("group_desc", "Group descriptors", (GroupDescriptors, self.superblock.group_count, 0))
+        self.seek(groups.getGroup(0)["block_bitmap"] * self.block_size)
+        for i in range(0,self.superblock.group_count):
+            self.read("group[]", "Group", (Group, i))
+
+        size = stream.getSize() - stream.tell()
+        if size != 0:
+            self.read("end", "End (raw)", (FormatChunk, "string[%u]" % size))
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        assert 0 <= size
+        if 0 < size:
+            self.read("raw[]", "Raw", (FormatChunk, "string[%u]" % size))
+
+    def readDirectory(self, inode):
+        stream = self.getStream()
+        block_index = 0
+        while True:
+            assert block_index < 12
+            block = inode["block[%u]" % block_index]
+            if block == 0:
+                return
+            self.seek(block * self.block_size)
+
+            total = 0
+            while total < self.block_size:
+                entry = self.doRead("directory[]", "Directory entry", (DirectoryEntry,))
+                if entry["inode"] == 0:
+                    return
+                total = total + entry.getSize()
+            assert total == self.block_size
+            block_index = block_index + 1
+
+registerPlugin(EXT2_FS, "hachoir/fs-ext2")

Modified: haypo/hachoir/trunk/plugins/png.py
===================================================================
--- haypo/hachoir/trunk/plugins/png.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/plugins/png.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -93,9 +93,8 @@
         type = self["type"]
         if type in Chunk.handler:
             size = self["size"]
-            print "%s.SIZE=%s" % (self.getId(), size)
             oldpos = self._stream.tell()
-            sub = stream.createSub(size=size)
+            sub = stream.createLimited(size=size)
             handler = Chunk.handler[type]
             self.read("data", "Data", (handler,), {"stream": sub, "size": size})
             assert stream.tell() == (oldpos + size) 

Modified: haypo/hachoir/trunk/stream/file.py
===================================================================
--- haypo/hachoir/trunk/stream/file.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/stream/file.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -1,6 +1,8 @@
+import os
 from error import StreamError
 from stream import Stream
-import os
+from cache import Cache
+import config
 
 class FileCacheEntry:
     def __init__(self, index, data):
@@ -11,14 +13,21 @@
     def __cmp__(self, to):
         return cmp(self.used, to.used)
 
-class FileCache:
+class FileCache(Cache):
     def __init__(self, file, file_size, block_size=4096, block_count=100):
+        Cache.__init__(self, "FileCache")
         self.file = file
         self.file_size = file_size
         self.block_size = block_size
         self.max_block = block_count
         self.blocks = {}
 
+    def getCacheSize(self):
+        return len(self.blocks)
+
+    def purgeCache(self):
+        self.blocks = {}
+
     def removeOldestBlock(self):
         entry = min(self.blocks.values())
         del self.blocks[entry.index]
@@ -76,7 +85,8 @@
             else:
                 self._end = 0
             if use_cache:
-                self._cache = FileCache(self._file, self._size, 4096, 10)
+                self._cache = FileCache(self._file, self._size, \
+                    config.file_cache_block_size, config.file_cache_block_count)
             else:
                 self._cache = None
 

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/stream/stream.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -1,7 +1,7 @@
 import struct
 from error import StreamError
 from tools import regexMaxLength
-from format import getFormatSize
+from format import getRealFormat, getFormatSize
 
 class Stream:
     def __init__(self, filename):
@@ -60,8 +60,9 @@
         Read data using struct format. Eg. getFormat("BB") returns (10, 14).
         """
         size = getFormatSize(format)
+        real = getRealFormat(format)
         data = self.getN(size, seek)
-        return struct.unpack(format, data)
+        return struct.unpack(real, data)[0]
 
     def searchLength(self, needle, include_str, size_max=None):        
         pos = self.search(needle, size_max)

Added: haypo/hachoir/trunk/todo.py
===================================================================
--- haypo/hachoir/trunk/todo.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/todo.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -0,0 +1,2 @@
+def todoWriteMethod(obj, method):
+    raise Exception("Class %s doesn't implement method %s!" % (obj.__class__.__name__, method))

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/tools.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -103,21 +103,28 @@
     min = sec/60
     sec = sec%60
     if min<60:
-        text = "%u min %u sec" % (min, sec)
+        return "%u min %u sec" % (min, sec)
 
     # Hours
     hour = min/60
     min = min/60
     if hour < 24:
-        text = "%u hour(s) %u min" % (hour, min)
+        return "%u hour(s) %u min" % (hour, min)
 
     # Days
     day = hour/24
     hour = hour%24
+    if day < 365:
+        return "%u day(s) %u hour(s)" % (day, hour)    
+
+    # Years
+    # TODO: Better estimation !?
+    year = day / 365
+    day = day % 365
     if hour != 0:
-        text = "%u day(s) %u hour(s)" % (day, hour)    
+        text = "%u year(s) %u day(s)" % (year, day)    
     else:
-        text = "%u day(s)" % (day)
+        text = "%u year(s)" % (year)
     return text
 
 def humanFilesize(size):

Modified: haypo/hachoir/trunk/ui/hachoir.glade
===================================================================
--- haypo/hachoir/trunk/ui/hachoir.glade	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/ui/hachoir.glade	2005-12-26 23:44:13 UTC (rev 355)
@@ -177,6 +177,23 @@
 		  <property name="homogeneous">True</property>
 		</packing>
 	      </child>
+
+	      <child>
+		<widget class="GtkToolButton" id="toolbutton_purge_cache">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Purge cache</property>
+		  <property name="use_underline">True</property>
+		  <property name="stock_id">gtk-clear</property>
+		  <property name="visible_horizontal">True</property>
+		  <property name="visible_vertical">True</property>
+		  <property name="is_important">False</property>
+		  <signal name="clicked" handler="on_toolbutton_purge_cache" last_modification_time="Mon, 26 Dec 2005 07:42:41 GMT"/>
+		</widget>
+		<packing>
+		  <property name="expand">False</property>
+		  <property name="homogeneous">True</property>
+		</packing>
+	      </child>
 	    </widget>
 	  </child>
 	</widget>

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2005-12-26 05:24:27 UTC (rev 354)
+++ haypo/hachoir/trunk/ui/ui_window.py	2005-12-26 23:44:13 UTC (rev 355)
@@ -210,6 +210,10 @@
         col.add_attribute(cell, 'text', num)
         treeview.set_search_column(num)
         col.set_sort_column_id(num)
+
+    def on_toolbutton_purge_cache(self, widget, data=None):
+        from cache import CacheList
+        CacheList.getInstance().purgeCaches()
  
     def on_toolbutton_parent(self, widget, data=None):
         self.ui.on_go_parent()



From haypo at berlios.de  Tue Dec 27 00:51:29 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 00:51:29 +0100
Subject: [Happyboom-svn] r356 - haypo/hachoir/trunk
Message-ID: <200512262351.jBQNpTOm027450@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 00:51:28 +0100 (Tue, 27 Dec 2005)
New Revision: 356

Modified:
   haypo/hachoir/trunk/chunk.py
Log:
Fix syntax in StringChunk for stream.getFormat()


Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-26 23:44:13 UTC (rev 355)
+++ haypo/hachoir/trunk/chunk.py	2005-12-26 23:51:28 UTC (rev 356)
@@ -168,12 +168,12 @@
     def _findSize(self):
         self._stream.seek(self.addr)
         if self._str_type == "Pascal16":
-            self.length = self._stream.getFormat("!H")[0]
+            self.length = self._stream.getFormat("!uint16")
             self._size = 2 + self.length
             self.eol = ""
             return
         if self._str_type == "Pascal32":
-            self.length = self._stream.getFormat("!L")[0]
+            self.length = self._stream.getFormat("!uint32")
             self._size = 4 + self.length
             self.eol = ""
             return



From haypo at berlios.de  Tue Dec 27 02:02:07 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 02:02:07 +0100
Subject: [Happyboom-svn] r357 - in haypo/hachoir/trunk: . broken_plugins plugins stream
Message-ID: <200512270102.jBR127qJ013269@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 02:01:54 +0100 (Tue, 27 Dec 2005)
New Revision: 357

Added:
   haypo/hachoir/trunk/plugins/exif.py
   haypo/hachoir/trunk/plugins/pdf.py
Removed:
   haypo/hachoir/trunk/broken_plugins/exif.py
   haypo/hachoir/trunk/broken_plugins/pdf.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/plugins/jpeg.py
   haypo/hachoir/trunk/stream/deflate.py
   haypo/hachoir/trunk/tools.py
Log:
- convertDataToPrintableString now returns Unicode (and accept str or unicode
  for input)
- StringChunk accept charset optionnal argument (default: "ascii")
- Upgrade PDF and EXIF plugins to new syntax


Deleted: haypo/hachoir/trunk/broken_plugins/exif.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/exif.py	2005-12-26 23:51:28 UTC (rev 356)
+++ haypo/hachoir/trunk/broken_plugins/exif.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -1,238 +0,0 @@
-"""
-Exif filter.
-
-Informations about Exif at:
-- http://www.exif.org/
-- http://libexif.sourceforge.net/
-
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from format import getFormatSize
-import struct
-
-class ExifEntry(Filter):
-    format = {
-        1: (1, "B"),
-        2: (1, "s"),
-        3: (1, "H"),
-        4: (1, "L"),
-        5: (2, "L"),
-        7: (1, "s"),
-#        9: (1, "l"),
-#        10: (2, "l")
-        9: (1, "L"),
-        10: (2, "L")
-    }
-
-    type_name = {    
-        1: "BYTE (8 bits)",
-        2: "ASCII (8 bits)",
-        3: "SHORT (16 bits)",
-        4: "LONG (32 bits)",
-        5: "RATIONAL (two LONGs)",
-        7: "UNDEFINED (8 bits)",
-        9: "SLONG (32 bits)",
-        10: "SRATIONTAL (two SLONGs)"
-    }
-
-    tag_name = {    
-        0x0100: "Image width",
-        0x0101: "Image height",
-        0x0102: "Number of bits per component",
-        0x0103: "Compression scheme",
-        0x0106: "Pixel composition",
-        0x0112: "Orientation of image",
-        0x0115: "Number of components",
-        0x011C: "Image data arrangement",
-        0x0212: "Subsampling ratio Y to C",
-        0x0213: "Y and C positioning",
-        0x011A: "Image resolution width direction",
-        0x011B: "Image resolution in height direction",
-        0x0128: "Unit of X and Y resolution",
-        
-        0x0111: "Image data location",
-        0x0116: "Number of rows per strip",
-        0x0117: "Bytes per compressed strip",
-        0x0201: "Offset to JPEG SOI",
-        0x0202: "Bytes of JPEG data",
-        
-        0x012D: "Transfer function",
-        0x013E: "White point chromaticity",
-        0x013F: "Chromaticities of primaries",
-        0x0211: "Color space transformation matrix coefficients",
-        0x0214: "Pair of blank and white reference values",
-        
-        0x0132: "File change date and time",
-        0x010e: "Image title",
-        0x010f: "Camera (Image input equipment) manufacturer",
-        0x0110: "Camera (Input input equipment) model",
-        0x0131: "Software",
-        0x013B: "File change date and time",
-        0x8298: "Copyright holder",
-        0x8769: "Exif IFD Pointer",
-
-        0x829A: "Exposure time",
-        0x829D: "F number",
-        0x8822: "Exposure program",
-        0x8824: "Spectral sensitivity",
-        0x8827: "ISO speed rating",
-        0x8828: "Optoelectric conversion factor OECF",
-        0x9201: "Shutter speed",
-        0x9202: "Aperture",
-        0x9203: "Brightness",
-        0x9204: "Exposure bias",
-        0x9205: "Maximum lens aperture",
-        0x9206: "Subject distance",
-        0x9207: "Metering mode",
-        0x9208: "Light source",
-        0x9209: "Flash",
-        0x920A: "Lens focal length",
-        0x9214: "Subject area",
-        0xA20B: "Flash energy",
-        0xA20C: "Spatial frequency response",
-        0xA20E: "Focal plane X resolution",
-        0xA20F: "Focal plane Y resolution",
-        0xA210: "Focal plane resolution unit",
-        0xA214: "Subject location",
-        0xA215: "Exposure index",
-        0xA217: "Sensing method",
-        0xA300: "File source",
-        0xA301: "Scene type",
-        0xA302: "CFA pattern",
-        0xA401: "Custom image processing",
-        0xA402: "Exposure mode",
-        0xA403: "White balance",
-        0xA404: "Digital zoom ratio",
-        0xA405: "Focal length in 35 mm film",
-        0xA406: "Scene capture type",
-        0xA407: "Gain control",
-        0xA408: "Contrast",
-
-        0x9000: "Exif version",
-        0xA000: "Supported Flashpix version",
-        0xA001: "Color space information",
-        0x9101: "Meaning of each component",
-        0x9102: "Image compression mode",
-        0xA002: "Valid image width",
-        0xA003: "Valid image height",
-        0x927C: "Manufacturer notes",
-        0x9286: "User comments",
-        0xA004: "Related audio file",
-        0x9003: "Date and time of original data generation",
-        0x9004: "Date and time of digital data generation",
-        0x9290: "DateTime subseconds",
-        0x9291: "DateTimeOriginal subseconds",
-        0x9292: "DateTimeDigitized subseconds",
-        0xA420: "Unique image ID",
-        0xA005: "Interoperability IFD Pointer"
-    }
-
-    def __init__(self, stream, parent, endian):
-        Filter.__init__(self, "exif_entry", "Exif entry", stream, parent)
-        self.endian = endian
-        self.read("tag", endian+"H", "Tag", post=self.processTag)
-        self.read("type", endian+"H", "Type", post=self.processType)
-        self.read("count", endian+"L", "Count")
-
-        # Create format
-        format = ExifEntry.format.get(self["type"], (1, "B"))
-        self.format = "%s%u%s" % (self.endian, format[0]*self["count"], format[1])
-
-        # Get size
-        self.size = getFormatSize(self.format)
-
-        # Get offset/value
-        if 4 < self.size:
-            self.read("offset", endian+"L", "Value offset")
-        else:
-            self.read("value", self.format, "Value")
-            if self.size < 4:
-                self.read("padding", "%us" % (4-self.size), "Padding")
-
-    def updateParent(self, parent):
-        parent.description = "Exif entry (%s)" % self.getTag() 
-
-    def getTag(self):
-        return ExifEntry.tag_name.get(self["tag"], "Unknown tag (0x%04X)" % self["tag"])
-
-    def processType(self, chunk):
-        return ExifEntry.type_name.get(chunk.value, "%u" % chunk.value) 
-
-    def processTag(self, chunk):
-        chunk.description = self.getTag()
-        return "0x%04X" % chunk.value 
-
-def sortExifEntry(a,b):
-    return int( a["offset"] - b["offset"] )
-
-class ExifIFD(Filter):
-    def __init__(self, stream, parent, endian, offset_diff):
-        Filter.__init__(self, "exif", "Exif IFD", stream, parent)
-        self.endian = endian
-        self.read("id", endian+"H", "IFD identifier")
-        entries = []
-        next_chunk_offset = None
-        while True:
-            next = stream.getFormat("!L", False)[0]
-            if next in (0, 0xF0000000):
-                break
-            chunk = self.readChild("entry[]", ExifEntry, endian)
-            entry = chunk.getFilter()
-            if entry["tag"] in (0x8769, 0x0201):
-                next_chunk_offset = entry["value"]+offset_diff
-                break
-            if 4 < entry.size:
-                entries.append(entry)
-        self.read("next", endian+"L", "Next IFD offset")
-        entries.sort( sortExifEntry )
-        for entry in entries:
-            offset = entry["offset"]+offset_diff
-            padding = offset - stream.tell()
-            if 0 < padding:
-                self.read("padding[]", "%us" % padding, "Padding (?)")
-            assert offset == stream.tell()
-            self.read("entry_value[]", entry.format, "Value of %s" % entry.getId())
-        if next_chunk_offset != None:
-            padding = next_chunk_offset - stream.tell()
-            if 0 < padding:
-                self.read("padding[]", "%us" % padding, "Padding (?)")
-
-    def updateParent(self, chunk):
-        desc = "Exif IFD (id %s)" % self["id"]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ExifFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "exif", "Exif", stream, parent)
-
-        # Headers
-        self.read("header", "6s", "Header (Exif\\0\\0)")
-        assert self["header"] == "Exif\0\0"
-        self.read("byte_order", "2s", "Byte order")
-        assert self["byte_order"] in ("II", "MM")
-        if self["byte_order"] == "II":
-           endian = "<"
-        else:
-           endian = ">"
-        self.read("header2", endian+"H", "Header2 (42)")
-
-        self.read("nb_entry", endian+"H", "Number of entries")
-        self.read("whatsthis?", endian+"H", "What's this ??")
-        while True:
-            tag = stream.getN(2, False)
-            if tag == "\xFF\xD8":
-                size = stream.getSize() - stream.tell()
-                sub = stream.createLimited(size=size)
-                from jpeg import JpegFile
-                self.readStreamChild("thumbnail", sub, JpegFile)
-                break
-            if tag == "\xFF\xFF":
-                break
-            self.readChild("ifd[]", ExifIFD, endian, 6)
-        size = stream.getSize() - stream.tell()
-        if 0 < size:
-            self.read("end", "%us" % size, "End")
-        assert self.getSize() == stream.getSize()

Deleted: haypo/hachoir/trunk/broken_plugins/pdf.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/pdf.py	2005-12-26 23:51:28 UTC (rev 356)
+++ haypo/hachoir/trunk/broken_plugins/pdf.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -1,140 +0,0 @@
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-import re
-from stream.error import StreamError
-from stream.deflate import DeflateStream
-from tools import convertDataToPrintableString, getBacktrace
-from error import warning
-from default import DefaultFilter
-
-def isEnd(stream, array, last):
-    return stream.eof()
-
-class PdfObject(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pdf_obj", "PDF object", stream, parent)
-        self.metadata = {}
-        chunk = self.readString("header", "AutoLine", "Object header", strip=True)
-        header = chunk.value 
-        assert header != ""
-        if header == "xref":
-            self.type = "xref"
-            self.readXref()
-        else: 
-            self.type = "obj"
-            m = re.match(r"([0-9]+) [0-9]+ obj", header)
-            if m != None:
-                id = int(m.group(1))
-                self.metadata["id"] = id
-                self.setDescription("Object (id %s)" % id)
-            else:
-                self.metadata["id"] = header
-                self.setDescription("Object (%s)" % header)
-            self.readObj()                
-        self.updateDescription()
-
-    def updateDescription(self):
-        if self.type == "obj":
-            info = "id %s" % self.metadata["id"]
-            if "type" in self.metadata:
-                info = info + ", %s" % self.metadata["type"]
-                if "fontname" in self.metadata:
-                    info = info + ", name: %s" % self.metadata["fontname"]
-        else:
-            info = "XREF"
-        self.setDescription("Object (%s)" % info)
-
-    def readContent(self):
-        text = "" 
-        deflate = False
-        while text not in ("endobj", "stream"):
-            self.processLine(text)
-            chunk = self.readString("line[]", "AutoLine", "", strip=True)
-            text = chunk.value
-            if re.match(r".*/Filter /FlateDecode.*", chunk.value) != None:
-                deflate = True
-            if self.getStream().eof():
-                return "eof"
-        if chunk.value == "endobj":
-            chunk.id = "endobj"
-            chunk.description = "Object end"
-            return "end"
-        elif deflate:
-            return "deflate"
-        else:
-            return "stream"
-    
-    def readObj(self):
-        what = self.readContent()
-        if what == "eof":
-            return
-        if what in ("stream","deflate"):
-            start = self.getStream().tell()
-            size = self._stream.searchLength("endstream", False)
-            if size == -1:
-                raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
-
-            if what=="deflate":
-                try:
-                    old = self.getStream().tell()
-                    new_stream = DeflateStream( self.getStream().getN(size,False) )
-                    self.readChild("deflate", DeflateFilter, new_stream, size, DefaultFilter)
-                except:
-                    warning("Error while decompressing data of an objet.")
-                    self.getStream().seek(start)
-                    self.read("data", "!%us" % size, "Data (compressed with deflate)")
-            else:
-                self.read("data", "!%us" % size, "Data")
-            assert self.getStream().tell() == (start+size)
-            
-            self.readString("data_end[]", "AutoLine", "Data end")
-            self.readString("endobj", "AutoLine", "Object end", strip=True)
-        ver = self.getParent().version
-        eol = self.getStream().read(1, seek=False)
-        if eol in ("\n", "\r"):
-            self.readString("emptyline", "AutoLine", "")
-
-    def readXref(self):
-        chunk = self.readString("xref_header", "AutoLine", "XRef header", strip=True)
-        m = re.match(r"^[0-9]+ ([0-9]+)$", chunk.value)
-        assert m != None
-        nb_ref = int(m.group(1)) - 1
-        n = 0
-        while n<nb_ref:
-            chunk = self.readString("ref[]", "AutoLine", "Reference", strip=True)
-            n = n + 1
-        self.readString("endobj", "AutoLine", "Object end", strip=True)
-
-    def processLine(self, line):
-        tests = {
-            "type":  r"^.*Type /([A-Za-z]+)$",
-            "fontname":  r"^.*(?:BaseFont|FontName) /(?:[A-Z]A+\+)?([A-Za-z-]+)$"
-        }
-        for field in tests:
-            m = re.match(tests[field], line)
-            if m != None:
-                self.metadata[field] = m.group(1)
-                break 
-
-class PdfFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "id", "", stream, parent)
-        self.readString("pdf_version", "AutoLine", "PDF version")
-        m = re.match("^%PDF-([0-9]+)\.([0-9]+)$", self["pdf_version"])
-        assert m != None
-        self.version = ( int(m.group(1)), int(m.group(2)) )
-        if self.version[0] == 1 and self.version[1] > 0:
-            # PDF > 1.0
-            self.readString("header", "AutoLine", "PDF header")
-        self.nb_ref = None
-        while not stream.eof():
-            try:
-                self.readChild("obj[]", PdfObject)
-            except StreamError, err:
-                return
-            except Exception, err:
-                print "Exception in PDF: %s" % err
-                print getBacktrace()
-                return
-
-registerPlugin(PdfFile, "application/pdf")

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-26 23:51:28 UTC (rev 356)
+++ haypo/hachoir/trunk/chunk.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -137,6 +137,7 @@
 
 class StringChunk(Chunk):
     regex_eol_nr = re.compile("[\n\r]")
+    regex_not_ascii = re.compile("[^\x00-\x7F]")
     names = {
         "C": "c-string",
         "MacLine": "mac line",
@@ -147,7 +148,7 @@
         "WindowsLine": "windows line"
     }
 
-    def __init__(self, id, description, stream, str_type, parent, strip=None):
+    def __init__(self, id, description, stream, str_type, parent, strip=None, charset="ascii"):
         """
         Strip: if strip=None, call read text.strip()
                if strip is a string, call read text.strip(self.strip)
@@ -158,13 +159,14 @@
         self.eol = None
         self._findSize()
         self.strip = strip
+        self.charset = charset
 
     def getFormat(self):
-        return StringChunk.names[self._str_type]
+        return "%s (%s)" % (\
+            StringChunk.names[self._str_type],
+            self.charset)
+    getSmallFormat = getFormat
 
-    def getSmallFormat(self):
-        return StringChunk.names[self._str_type]
-
     def _findSize(self):
         self._stream.seek(self.addr)
         if self._str_type == "Pascal16":
@@ -222,6 +224,12 @@
                 text = text.strip()
             else:
                 text = text.strip(self.strip)
+        try:                
+            text = unicode(text, self.charset)
+        except:
+            self.charset = "ascii"
+            text = StringChunk.regex_not_ascii.sub(".", text)
+            text = unicode(text, "ascii")
         return text
 
     def getValue(self, max_size=None):

Copied: haypo/hachoir/trunk/plugins/exif.py (from rev 351, haypo/hachoir/trunk/broken_plugins/exif.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/exif.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/exif.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -0,0 +1,225 @@
+"""
+Exif filter.
+
+Informations about Exif at:
+- http://www.exif.org/
+- http://libexif.sourceforge.net/
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from format import getFormatSize
+from chunk import FormatChunk, EnumChunk
+import struct
+
+class ExifEntry(OnDemandFilter):
+    format = {
+        1: (1, "uint8"),
+        2: (1, "string"),
+        3: (1, "uint16"),
+        4: (1, "uint32"),
+        5: (2, "uint32"),
+        7: (1, "string"),
+        9: (1, "int32"),
+        10: (2, "int32")
+    }
+
+    type_name = {    
+        1: "BYTE (8 bits)",
+        2: "ASCII (8 bits)",
+        3: "SHORT (16 bits)",
+        4: "LONG (32 bits)",
+        5: "RATIONAL (two LONGs)",
+        7: "UNDEFINED (8 bits)",
+        9: "SLONG (32 bits)",
+        10: "SRATIONTAL (two SLONGs)"
+    }
+
+    tag_name = {    
+        0x0100: "Image width",
+        0x0101: "Image height",
+        0x0102: "Number of bits per component",
+        0x0103: "Compression scheme",
+        0x0106: "Pixel composition",
+        0x0112: "Orientation of image",
+        0x0115: "Number of components",
+        0x011C: "Image data arrangement",
+        0x0212: "Subsampling ratio Y to C",
+        0x0213: "Y and C positioning",
+        0x011A: "Image resolution width direction",
+        0x011B: "Image resolution in height direction",
+        0x0128: "Unit of X and Y resolution",
+        
+        0x0111: "Image data location",
+        0x0116: "Number of rows per strip",
+        0x0117: "Bytes per compressed strip",
+        0x0201: "Offset to JPEG SOI",
+        0x0202: "Bytes of JPEG data",
+        
+        0x012D: "Transfer function",
+        0x013E: "White point chromaticity",
+        0x013F: "Chromaticities of primaries",
+        0x0211: "Color space transformation matrix coefficients",
+        0x0214: "Pair of blank and white reference values",
+        
+        0x0132: "File change date and time",
+        0x010e: "Image title",
+        0x010f: "Camera (Image input equipment) manufacturer",
+        0x0110: "Camera (Input input equipment) model",
+        0x0131: "Software",
+        0x013B: "File change date and time",
+        0x8298: "Copyright holder",
+        0x8769: "Exif IFD Pointer",
+
+        0x829A: "Exposure time",
+        0x829D: "F number",
+        0x8822: "Exposure program",
+        0x8824: "Spectral sensitivity",
+        0x8827: "ISO speed rating",
+        0x8828: "Optoelectric conversion factor OECF",
+        0x9201: "Shutter speed",
+        0x9202: "Aperture",
+        0x9203: "Brightness",
+        0x9204: "Exposure bias",
+        0x9205: "Maximum lens aperture",
+        0x9206: "Subject distance",
+        0x9207: "Metering mode",
+        0x9208: "Light source",
+        0x9209: "Flash",
+        0x920A: "Lens focal length",
+        0x9214: "Subject area",
+        0xA20B: "Flash energy",
+        0xA20C: "Spatial frequency response",
+        0xA20E: "Focal plane X resolution",
+        0xA20F: "Focal plane Y resolution",
+        0xA210: "Focal plane resolution unit",
+        0xA214: "Subject location",
+        0xA215: "Exposure index",
+        0xA217: "Sensing method",
+        0xA300: "File source",
+        0xA301: "Scene type",
+        0xA302: "CFA pattern",
+        0xA401: "Custom image processing",
+        0xA402: "Exposure mode",
+        0xA403: "White balance",
+        0xA404: "Digital zoom ratio",
+        0xA405: "Focal length in 35 mm film",
+        0xA406: "Scene capture type",
+        0xA407: "Gain control",
+        0xA408: "Contrast",
+
+        0x9000: "Exif version",
+        0xA000: "Supported Flashpix version",
+        0xA001: "Color space information",
+        0x9101: "Meaning of each component",
+        0x9102: "Image compression mode",
+        0xA002: "Valid image width",
+        0xA003: "Valid image height",
+        0x927C: "Manufacturer notes",
+        0x9286: "User comments",
+        0xA004: "Related audio file",
+        0x9003: "Date and time of original data generation",
+        0x9004: "Date and time of digital data generation",
+        0x9290: "DateTime subseconds",
+        0x9291: "DateTimeOriginal subseconds",
+        0x9292: "DateTimeDigitized subseconds",
+        0xA420: "Unique image ID",
+        0xA005: "Interoperability IFD Pointer"
+    }
+
+    def __init__(self, stream, parent, endian):
+        OnDemandFilter.__init__(self, "exif_entry", "Exif entry", stream, parent, endian)
+        self.read("tag", "Tag", (EnumChunk, "uint16", ExifEntry.tag_name))
+        self.read("type", "Type", (FormatChunk, "uint16"), {"post": self.processType})
+        self.read("count", "Count", (FormatChunk, "uint32"))
+
+        # Create format
+        format = ExifEntry.format.get(self["type"], (1, "uint8"))
+        self.format = "%s[%u]" % (format[1], format[0]*self["count"])
+
+        # Get size
+        self.size = getFormatSize(self.format)
+
+        # Get offset/value
+        if 4 < self.size:
+            self.read("offset", "Value offset", (FormatChunk, "uint32"))
+        else:
+            self.read("value", "Value", (FormatChunk, self.format))
+            if self.size < 4:
+                self.read("padding", "Padding", (FormatChunk, "string[%u]" % (4-self.size)))
+
+    def updateParent(self, parent):
+        parent.description = "Exif entry: %s" % self.getChunk("tag").getDisplayData()
+
+    def processType(self, chunk):
+        return ExifEntry.type_name.get(chunk.value, "%u" % chunk.value) 
+
+def sortExifEntry(a,b):
+    return int( a["offset"] - b["offset"] )
+
+class ExifIFD(OnDemandFilter):
+    def __init__(self, stream, parent, endian, offset_diff):
+        OnDemandFilter.__init__(self, "exif", "Exif IFD", stream, parent, endian)
+        self.read("id", "IFD identifier", (FormatChunk, "uint16"))
+        entries = []
+        next_chunk_offset = None
+        while True:
+            # TODO: "!uint32" or self._endian+"uint32" ?
+            next = stream.getFormat("!uint32", False)
+            if next in (0, 0xF0000000):
+                break
+            entry = self.doRead("entry[]", "Entry", (ExifEntry, self._endian))
+            if entry["tag"] in (0x8769, 0x0201):
+                next_chunk_offset = entry["value"]+offset_diff
+                break
+            if 4 < entry.size:
+                entries.append(entry)
+        self.read("next", "Next IFD offset", (FormatChunk, "uint32"))
+        entries.sort( sortExifEntry )
+        for entry in entries:
+            offset = entry["offset"]+offset_diff
+            padding = offset - stream.tell()
+            if 0 < padding:
+                self.read("padding[]", "Padding (?)", (FormatChunk, "string[%u]" % padding))
+            assert offset == stream.tell()
+            self.read("entry_value[]", "Value of %s" % entry.getId(), (FormatChunk, entry.format))
+        if next_chunk_offset != None:
+            padding = next_chunk_offset - stream.tell()
+            if 0 < padding:
+                self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % padding))
+
+    def updateParent(self, chunk):
+        chunk.description = "Exif IFD (id %s)" % self["id"]
+
+class ExifFilter(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "exif", "Exif", stream, parent, None)
+
+        # Headers
+        self.read("header", "Header (Exif\\0\\0)", (FormatChunk, "string[6]"))
+        assert self["header"] == "Exif\0\0"
+        self.read("byte_order", "Byte order", (FormatChunk, "string[2]"))
+        assert self["byte_order"] in ("II", "MM")
+        if self["byte_order"] == "II":
+           self._endian = "<"
+        else:
+           self._endian = ">"
+        self.read("header2", "Header2 (42)", (FormatChunk, "uint16"))
+        self.read("nb_entry", "Number of entries", (FormatChunk, "uint16"))
+        self.read("whatsthis?", "What's this ??", (FormatChunk, "uint16"))
+        while not stream.eof():
+            tag = stream.getFormat("!uint16", False)
+            if tag == 0xFFD8:
+                size = stream.getSize() - stream.tell()
+                sub = stream.createSub(size=size)
+                from jpeg import JpegFile
+                self.read("thumbnail", "JPEG thumbnail", (JpegFile,), {"stream": sub})
+                break
+            elif tag == 0xFFFF:
+                break
+            id = self.read("ifd[]", "IFD", (ExifIFD, self._endian, 6))
+        size = stream.getSize() - stream.tell()
+        if 0 < size:
+            self.read("end", "End", (FormatChunk, "string[%u]" % size))
+        assert self.getSize() == stream.getSize()

Modified: haypo/hachoir/trunk/plugins/jpeg.py
===================================================================
--- haypo/hachoir/trunk/plugins/jpeg.py	2005-12-26 23:51:28 UTC (rev 356)
+++ haypo/hachoir/trunk/plugins/jpeg.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -7,7 +7,7 @@
 from filter import OnDemandFilter
 from plugin import registerPlugin
 from chunk import FormatChunk
-#from exif import ExifFilter
+from exif import ExifFilter
 
 class JpegChunkApp0(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -44,7 +44,7 @@
     }
     handler = {
         0xE0: JpegChunkApp0,
-#        0xE1: ExifFilter
+        0xE1: ExifFilter
     }
 
     def __init__(self, stream, parent):

Copied: haypo/hachoir/trunk/plugins/pdf.py (from rev 351, haypo/hachoir/trunk/broken_plugins/pdf.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/pdf.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/pdf.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -0,0 +1,144 @@
+from filter import OnDemandFilter, DeflateFilter
+from plugin import registerPlugin
+from chunk import StringChunk, FormatChunk
+import re
+from stream.error import StreamError
+from stream.deflate import DeflateStream
+from tools import convertDataToPrintableString, getBacktrace
+from error import warning
+from default import DefaultFilter
+
+def isEnd(stream, array, last):
+    return stream.eof()
+
+class PdfObject(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "obj", "object", stream, parent)
+        self.metadata = {}
+        header = self.doRead("header", "Object header", (StringChunk, "AutoLine"), {"strip": True}).value
+        assert header != ""
+        self.content = False
+        if header == "xref":
+            self.type = "xref"
+            self.readXref()
+        else: 
+            self.type = "obj"
+            m = re.match(r"([0-9]+) [0-9]+ obj", header)
+            if m != None:
+                id = int(m.group(1))
+                self.metadata["id"] = id
+                self.setDescription("Object: id %s" % id)
+            else:
+                self.metadata["id"] = header
+                self.setDescription("Object: %s" % header)
+            self.readObj()                
+        self.updateDescription()
+
+    def updateDescription(self):
+        if self.type == "obj":
+            info = "id %s" % self.metadata["id"]
+            if "type" in self.metadata:
+                info = info + ", %s" % self.metadata["type"]
+                if "fontname" in self.metadata:
+                    info = info + ", name: %s" % self.metadata["fontname"]
+        else:
+            info = "XREF"
+        if self.content:
+            info += " (content: %s)" % self.content
+        self.setDescription("Object: %s" % info)
+
+    def readContent(self):
+        text = "" 
+        deflate = False
+        while text not in ("endobj", "stream"):
+            self.processLine(text)
+            chunk = self.doRead("line[]", "Line", (StringChunk, "AutoLine"), {"strip": True})
+            text = chunk.value
+            if re.match(r".*/Filter /FlateDecode.*", text) != None:
+                deflate = True
+            if self.getStream().eof():
+                return "eof"
+        if text == "endobj":
+            chunk.id = "endobj"
+            chunk.description = "Object end"
+            return "end"
+        elif deflate:
+            return "deflate"
+        else:
+            return "stream"
+    
+    def readObj(self):
+        what = self.readContent()
+        if what == "eof":
+            return
+        if what in ("stream","deflate"):
+            self.content = what
+            start = self.getStream().tell()
+            size = self._stream.searchLength("endstream", False)
+            if size == -1:
+                raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
+
+            if what=="deflate":
+                try:
+                    old = self.getStream().tell()
+                    new_stream = DeflateStream( self.getStream().getN(size,False) )
+                    self.read("content", "Deflate content", (DeflateFilter, new_stream, size, DefaultFilter))
+                except:
+                    warning("Error while decompressing data of an objet.")
+                    self.getStream().seek(start)
+                    self.read("data", "Data (compressed with deflate)", (FormatChunk, "string[%u]" % size))
+            else:
+                self.read("data", "Data", (FormatChunk, "string[%u]" % size))
+            assert self.getStream().tell() == (start+size)
+            
+            self.read("data_end[]", "Data end", (StringChunk, "AutoLine"))
+            self.read("endobj", "Object end", (StringChunk, "AutoLine"), {"strip": True})
+        ver = self.getParent().version
+        eol = self.getStream().read(1, seek=False)
+        if eol in ("\n", "\r"):
+            self.read("emptyline", "Empty line", (StringChunk, "AutoLine"))
+
+    def readXref(self):
+        text = self.doRead("xref_header", "XRef header", (StringChunk, "AutoLine"), {"strip": True}).value
+        m = re.match(r"^[0-9]+ ([0-9]+)$", text)
+        assert m != None
+        nb_ref = int(m.group(1)) - 1
+        n = 0
+        while n<nb_ref:
+            self.read("ref[]", "Reference", (StringChunk, "AutoLine"), {"strip": True})
+            n = n + 1
+        self.read("endobj", "Object end", (StringChunk, "AutoLine"), {"strip": True})
+
+    def processLine(self, line):
+        tests = {
+            "type":  r"^.*Type /([A-Za-z]+)$",
+            "fontname":  r"^.*(?:BaseFont|FontName) /(?:[A-Z]A+\+)?([A-Za-z-]+)$"
+        }
+        for field in tests:
+            m = re.match(tests[field], line)
+            if m != None:
+                self.metadata[field] = m.group(1)
+                break 
+
+class PdfFile(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "id", "", stream, parent)
+        self.read("pdf_version", "PDF version", (StringChunk, "AutoLine"))
+        m = re.match("^%PDF-([0-9]+)\.([0-9]+)$", self["pdf_version"])
+        assert m != None
+        self.version = ( int(m.group(1)), int(m.group(2)) )
+        if self.version[0] == 1 and self.version[1] > 0:
+            # PDF > 1.0 (?)
+            self.read("header", "PDF header", (StringChunk, "AutoLine"), {"charset": "utf-8"})
+        self.nb_ref = None
+        while not stream.eof():
+            try:
+                self.read("obj[]", "Object", (PdfObject,))
+            except StreamError, err:
+                return
+            except Exception, err:
+                print "Exception in PDF: %s" % err
+                print getBacktrace()
+                return
+
+registerPlugin(PdfFile, "application/pdf")

Modified: haypo/hachoir/trunk/stream/deflate.py
===================================================================
--- haypo/hachoir/trunk/stream/deflate.py	2005-12-26 23:51:28 UTC (rev 356)
+++ haypo/hachoir/trunk/stream/deflate.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -1,6 +1,5 @@
 import zlib
 from cStringIO import StringIO
-from filter import Filter
 from file import FileStream
 
 def DeflateStream(data):

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-26 23:51:28 UTC (rev 356)
+++ haypo/hachoir/trunk/tools.py	2005-12-27 01:01:54 UTC (rev 357)
@@ -141,6 +141,9 @@
 def convertDataToPrintableString(data, keep_n=False):
     if len(data) == 0:
         return "(empty)"
+    if not isinstance(data, unicode):
+        data = re.sub("[^\x00-\x7F]", ".", data)
+        data = unicode(data, "ascii")
     display = ""
     for c in data:
         if ord(c)<32:
@@ -155,13 +158,20 @@
                 else:
                     display = display + c
             else:
-#                display = display + "\\x%02X" % ord(c)
                 display = display + "."
-        elif c in string.printable:
+        else:
             display = display + c
-        else:
-            display = display + "."
-    return "\"%s\"" % display
+#            if is_8bit:
+#                if ord(c) != 0xFF:
+#                    display = display + c
+#                else:
+#                    display = display + "."
+#            else:                    
+#                if c in string.printable:
+#                    display = display + c
+#                else:
+#                    display = display + "."
+    return u"\"%s\"" % display
 
 def getBacktrace():
     try:



From haypo at berlios.de  Tue Dec 27 03:11:27 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 03:11:27 +0100
Subject: [Happyboom-svn] r358 - in haypo/hachoir/trunk: . broken_plugins plugins
Message-ID: <200512270211.jBR2BRA8002329@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 03:11:18 +0100 (Tue, 27 Dec 2005)
New Revision: 358

Added:
   haypo/hachoir/trunk/plugins/xcf.py
Removed:
   haypo/hachoir/trunk/broken_plugins/xcf.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/plugins/exif.py
Log:
- Fix StringChunk._findSize (always seek in stream)
- Upgrade XCF plugin to new syntax
- XCF plugin can now read channels
- Use UTF-8 charset in XCF strings ;-)


Deleted: haypo/hachoir/trunk/broken_plugins/xcf.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/xcf.py	2005-12-27 01:01:54 UTC (rev 357)
+++ haypo/hachoir/trunk/broken_plugins/xcf.py	2005-12-27 02:11:18 UTC (rev 358)
@@ -1,226 +0,0 @@
-"""
-Exif filter.
-
-Informations about Exif at:
-- http://www.exif.org/
-- http://libexif.sourceforge.net/
-
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class XcfCompression(Filter):
-    name = {
-        0: "None",
-        1: "RLE",
-        2: "Zlib",
-        3: "Fractal"
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "compression", "Compression", stream, parent)
-        chunk = self.read("compression", "B", "")
-        type = XcfCompression.name.get(chunk.value, "Unknow (%s)" % chunk.value)
-        chunk.description = "Compress type (%s)" % type
-
-class XcfResolution(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "resolution", "Resolution", stream, parent)
-        self.read("xres", "f", "X resolution")
-        self.read("yres", "f", "Y resolution")
-
-class XcfTattoo(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "tattoo", "Tattoo", stream, parent)
-        self.read("tattoo", "!L", "Tattoo")
-
-class XcfUnit(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "unit", "Unit", stream, parent)
-        self.read("unit", "!L", "Unit")
-
-def readString(filter, stream, name, description):
-    filter.readString(name, "Pascal32", description, strip="\0")
-    return
-    
-    chunk = filter.read(name+"_size", "!L", description+" length")
-    filter.read(name, "%us" % chunk.value, description)
-
-class XcfParasiteEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_para", "XCF parasite", stream, parent)
-        readString(self, stream, "name", "Name")
-        self.read("flags", "!L", "Flags")
-        self.read("size", "!L", "Size")
-        if 0 < self["size"]:
-            self.read("data", "%us" % self["size"], "Data")
-
-class XcfLevel(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_level", "XCF level", stream, parent)
-        self.read("width", "!L", "Width")
-        self.read("height", "!L", "Height")
-        self.read("offset", "!L", "Offset")
-        offset = self["offset"]
-        if offset == 0:
-            return
-        data_offsets = []
-        while stream.tell() < offset:
-            chunk = self.read("data_offset[]", "!L", "Data offset")
-            if chunk.value == 0:
-                break
-            data_offsets.append(chunk.value)
-        assert stream.tell() == offset
-        previous = offset
-        for data_offset in data_offsets:
-            size = data_offset - previous
-            self.read("data[]", "%us" % size, "Data")
-            previous = data_offset
-
-class XcfHierarchie(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_hier", "XCF hierarchie", stream, parent)
-        self.read("width", "!L", "Width")
-        self.read("height", "!L", "Height")
-        self.read("bpp", "!L", "Bits/pixel")
-            
-        offsets = []
-        while True:
-            chunk = self.read("offset[]", "!L", "Level offset")
-            if chunk.value == 0:
-                break
-            offsets.append(chunk.value)
-        for offset in offsets:
-            seek(self, stream, offset)
-            self.readChild("level[]", XcfLevel)
-#        self.readChild("channel[]", XcfChannel)
-
-class XcfChannel(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_channel", "XCF channel", stream, parent)
-        self.read("width", "!L", "Channel width")
-        self.read("height", "!L", "Channel height")
-        readString(self, stream, "name", "Channel name")
-        readProperties(self, stream)
-        self.read("hierarchie_ofs", "!L", "Hierarchie offset")
-        self.readChild("hierarchie", XcfHierarchie)
-
-class XcfLayer(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_layer", "XCF layer", stream, parent)
-        self.read("width", "!L", "Layer width")
-        self.read("height", "!L", "Layer height")
-        self.read("type", "!L", "Layer type")
-        readString(self, stream, "name", "Layer name")
-        readProperties(self, stream)
-        # TODO: Hack for Gimp 1.2 files
-        self.read("hierarchie_ofs", "!L", "Hierarchie offset")
-        self.read("mask_ofs", "!L", "Layer mask offset")
-        seek(self, stream, self["hierarchie_ofs"])
-        self.readChild("hierarchie", XcfHierarchie)
-        # TODO: Read layer mask if needed: self["mask_ofs"] != 0
-
-    def updateParent(self, chunk):
-        desc = "Layer \"%s\"" % self["name"]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class XcfParasites(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "parasites", "Parasites", stream, parent)
-        while not stream.eof():
-            self.readChild("parasite[]", XcfParasiteEntry)
-
-class XcfProperty(Filter):
-    known_types = {
-        0: "End",
-        1: "Colormap",
-        2: "Active layer",
-        3: "Active channel",
-        4: "Selection",
-        5: "Floating selection",
-        6: "Opacity",
-        7: "Mode",
-        8: "Visible",
-        9: "Linked",
-        10: "Lock alpha",
-        11: "Apply mask",
-        12: "Edit mask",
-        13: "Show mask",
-        14: "Show masked",
-        15: "Offsets",
-        16: "Color",
-        17: "Compression",
-        18: "Guides",
-        19: "Resolution",
-        20: "Tattoo",
-        21: "Parasites",
-        22: "Unit",
-        23: "Paths",
-        24: "User unit",
-        25: "Vectors",
-        26: "Text layer flags"
-    }
-    handler = {
-        17: XcfCompression,
-        19: XcfResolution,
-        20: XcfTattoo,
-        21: XcfParasites,
-        22: XcfUnit
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_prop", "XCF property", stream, parent)
-        chunk = self.read("type", "!L", "")
-        chunk.description = "Property type (%s)" % self.getType()
-        self.read("size", "!L", "Property size")
-        type = self["type"]
-        if type in XcfProperty.handler:
-            end = stream.tell() + self["size"]
-            substream = stream.createSub(size=self["size"])
-            self.readStreamChild("data", substream, XcfProperty.handler[type])
-            assert stream.tell() == end
-        elif 0 < self["size"]:
-            self.read("data", "%us" % self["size"], "Data")
-
-    def updateParent(self, parent):
-        parent.description = "XCF property (%s)" % self.getType()
-
-    def getType(self):
-        return XcfProperty.known_types.get(self["type"], "Unknow type (%u)" % self["type"])
-
-def readProperties(filter, stream):        
-    while True:
-        chunk = filter.readChild("property[]", XcfProperty)
-        type = chunk.getFilter()["type"]
-        if type == 0:
-            break
-
-def seek(filter, stream, offset):
-    current = stream.tell()
-    if current != offset:
-        filter.read("padding[]", "%us" % (offset-current), "Padding")
-
-class XcfFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf", "XCF file", stream, parent)
-        self.readString("header", "C", "Header")
-        assert self["header"] == "gimp xcf file"
-        self.read("width", "!L", "Image width")
-        self.read("height", "!L", "Image height")
-        self.read("type", "!L", "Image type")
-        readProperties(self, stream)
-
-        offsets = []
-        while True:
-            chunk = self.read("layer_offset[]", "!L", "Layer offset")
-            if chunk.value == 0:
-                break
-            offsets.append(chunk.value)
-        for offset in offsets:
-            seek(self, stream, offset)
-            self.readChild("layer[]", XcfLayer)
-
-registerPlugin(XcfFile, "image/x-xcf")

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-27 01:01:54 UTC (rev 357)
+++ haypo/hachoir/trunk/chunk.py	2005-12-27 02:11:18 UTC (rev 358)
@@ -173,14 +173,11 @@
             self.length = self._stream.getFormat("!uint16")
             self._size = 2 + self.length
             self.eol = ""
-            return
-        if self._str_type == "Pascal32":
+        elif self._str_type == "Pascal32":
             self.length = self._stream.getFormat("!uint32")
             self._size = 4 + self.length
             self.eol = ""
-            return
-            
-        if self._str_type == "AutoLine":
+        elif self._str_type == "AutoLine":
             self._size = self._stream.searchLength(StringChunk.regex_eol_nr, True)
             assert self._size != -1
             self._stream.seek(self.addr + self._size-1)
@@ -189,19 +186,18 @@
                 self.eol = "\r\n"
                 self._size = self._size + 1
             self.length = self._size - len(self.eol)
-            return
-
-        if self._str_type == "UnixLine":
-            self.eol = "\n"
-        elif self._str_type == "WindowsLine":
-            self.eol = "\r\n"
-        elif self._str_type == "MacLine":
-            self.eol = "\r"
-        else: 
-            self.eol = "\0"
-        self._size = self._stream.searchLength(self.eol, True)
-        assert self._size != -1
-        self.length = self._size - len(self.eol)
+        else:            
+            if self._str_type == "UnixLine":
+                self.eol = "\n"
+            elif self._str_type == "WindowsLine":
+                self.eol = "\r\n"
+            elif self._str_type == "MacLine":
+                self.eol = "\r"
+            else: 
+                self.eol = "\0"
+            self._size = self._stream.searchLength(self.eol, True)
+            assert self._size != -1
+            self.length = self._size - len(self.eol)
         self._stream.seek(self.addr + self._size)
         
     def _read(self, max_size):
@@ -369,6 +365,8 @@
         assert formatIsInteger(format)
         FormatChunk.__init__(self, id, description, stream, format, parent)
         self._dict = dict
+#        value = self.getValue()
+#        self.description = self.description + ": " + self._dict.get(value, "Unknow (%s)" % value)
 
     def getDisplayData(self):
         value = self.getValue()

Modified: haypo/hachoir/trunk/plugins/exif.py
===================================================================
--- haypo/hachoir/trunk/plugins/exif.py	2005-12-27 01:01:54 UTC (rev 357)
+++ haypo/hachoir/trunk/plugins/exif.py	2005-12-27 02:11:18 UTC (rev 358)
@@ -131,7 +131,7 @@
     def __init__(self, stream, parent, endian):
         OnDemandFilter.__init__(self, "exif_entry", "Exif entry", stream, parent, endian)
         self.read("tag", "Tag", (EnumChunk, "uint16", ExifEntry.tag_name))
-        self.read("type", "Type", (FormatChunk, "uint16"), {"post": self.processType})
+        self.read("type", "Type", (EnumChunk, "uint16", ExifEntry.type_name))
         self.read("count", "Count", (FormatChunk, "uint32"))
 
         # Create format
@@ -152,9 +152,6 @@
     def updateParent(self, parent):
         parent.description = "Exif entry: %s" % self.getChunk("tag").getDisplayData()
 
-    def processType(self, chunk):
-        return ExifEntry.type_name.get(chunk.value, "%u" % chunk.value) 
-
 def sortExifEntry(a,b):
     return int( a["offset"] - b["offset"] )
 

Copied: haypo/hachoir/trunk/plugins/xcf.py (from rev 351, haypo/hachoir/trunk/broken_plugins/xcf.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/xcf.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/xcf.py	2005-12-27 02:11:18 UTC (rev 358)
@@ -0,0 +1,228 @@
+"""
+Gimp image parser (XCF file, ".xcf" extension).
+
+You can find informations about XCF file in Gimp source code. URL to read
+CVS online:
+  http://cvs.gnome.org/viewcvs/gimp/app/xcf/
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from chunk import FormatChunk, StringChunk, EnumChunk
+from plugin import registerPlugin
+
+class XcfCompression(OnDemandFilter):
+    name = {
+        0: "None",
+        1: "RLE",
+        2: "Zlib",
+        3: "Fractal"
+    }
+
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "compression", "Compression", stream, parent)
+        self.read("compression", "Compression method", (EnumChunk, "uint8", XcfCompression.name))
+
+class XcfResolution(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "resolution", "Resolution", stream, parent, "!")
+        self.read("xres", "X resolution", (FormatChunk, "float"))
+        self.read("yres", "Y resolution", (FormatChunk, "float"))
+
+class XcfTattoo(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "tattoo", "Tattoo", stream, parent, "!")
+        self.read("tattoo", "Tattoo", (FormatChunk, "uint32"))
+
+class XcfUnit(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "unit", "Unit", stream, parent, "!")
+        self.read("unit", "Unit", (FormatChunk, "uint32"))
+
+class XcfParasiteEntry(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf_para", "XCF parasite", stream, parent, "!")
+        self.read("name", "Name", (StringChunk, "Pascal32"), {"strip": "\0", "charset": "utf-8"})
+        self.read("flags", "Flags", (FormatChunk, "uint32"))
+        self.read("size", "Size", (FormatChunk, "uint32"))
+        if 0 < self["size"]:
+            self.read("data", "Data", (FormatChunk, "string[%u]" % self["size"]))
+
+class XcfLevel(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf_level", "XCF level", stream, parent, "!")
+        self.read("width", "Width", (FormatChunk, "uint32"))
+        self.read("height", "Height", (FormatChunk, "uint32"))
+        self.read("offset", "Offset", (FormatChunk, "uint32"))
+        offset = self["offset"]
+        if offset == 0:
+            return
+        data_offsets = []
+        while stream.tell() < offset:
+            chunk = self.doRead("data_offset[]", "Data offset", (FormatChunk, "uint32"))
+            if chunk.value == 0:
+                break
+            data_offsets.append(chunk)
+        assert stream.tell() == offset
+        previous = offset
+        for chunk in data_offsets:
+            data_offset = chunk.value
+            size = data_offset - previous
+            self.read("data[]", "Data content of %s" % chunk.id, (FormatChunk, "string[%u]" % size))
+            previous = data_offset
+
+class XcfHierarchie(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf_hier", "XCF hierarchie", stream, parent, "!")
+        self.read("width", "Width", (FormatChunk, "uint32"))
+        self.read("height", "Height", (FormatChunk, "uint32"))
+        self.read("bpp", "Bits/pixel", (FormatChunk, "uint32"))
+            
+        offsets = []
+        while True:
+            chunk = self.doRead("offset[]", "Level offset", (FormatChunk, "uint32"))
+            if chunk.value == 0:
+                break
+            offsets.append(chunk.value)
+        for offset in offsets:
+            seek(self, stream, offset)
+            self.read("level[]", "Level", (XcfLevel,))
+#        self.read("channel[]", "Channel", (XcfChannel,))
+
+class XcfChannel(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf_channel", "XCF channel", stream, parent, "!")
+        self.read("width", "Channel width", (FormatChunk, "uint32"))
+        self.read("height", "Channel height", (FormatChunk, "uint32"))
+        self.read("name", "Channel name", (StringChunk, "Pascal32"), {"strip": "\0", "charset": "utf-8"})
+        readProperties(self, stream)
+        self.read("hierarchie_ofs", "Hierarchie offset", (FormatChunk, "uint32"))
+        self.read("hierarchie", "Hierarchie", (XcfHierarchie,))
+
+    def updateParent(self, chunk):
+        desc = "Channel \"%s\"" % self["name"]
+        chunk.description = desc
+        self.setDescription(desc)
+
+class XcfLayer(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf_layer", "XCF layer", stream, parent, "!")
+        self.read("width", "Layer width", (FormatChunk, "uint32"))
+        self.read("height", "Layer height", (FormatChunk, "uint32"))
+        self.read("type", "Layer type", (FormatChunk, "uint32"))
+        self.read("name", "Layer name", (StringChunk, "Pascal32"), {"strip": "\0", "charset": "utf-8"})
+        readProperties(self, stream)
+        # TODO: Hack for Gimp 1.2 files
+        self.read("hierarchie_ofs", "Hierarchie offset", (FormatChunk, "uint32"))
+        self.read("mask_ofs", "Layer mask offset", (FormatChunk, "uint32"))
+        seek(self, stream, self["hierarchie_ofs"])
+        self.read("hierarchie", "Hierarchie", (XcfHierarchie,))
+        # TODO: Read layer mask if needed: self["mask_ofs"] != 0
+
+    def updateParent(self, chunk):
+        desc = "Layer \"%s\"" % self["name"]
+        chunk.description = desc
+        self.setDescription(desc)
+
+class XcfParasites(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "parasites", "Parasites", stream, parent)
+        while not stream.eof():
+            self.read("parasite[]", "Parasite", (XcfParasiteEntry,))
+
+class XcfProperty(OnDemandFilter):
+    type_name = {
+        0: "End",
+        1: "Colormap",
+        2: "Active layer",
+        3: "Active channel",
+        4: "Selection",
+        5: "Floating selection",
+        6: "Opacity",
+        7: "Mode",
+        8: "Visible",
+        9: "Linked",
+        10: "Lock alpha",
+        11: "Apply mask",
+        12: "Edit mask",
+        13: "Show mask",
+        14: "Show masked",
+        15: "Offsets",
+        16: "Color",
+        17: "Compression",
+        18: "Guides",
+        19: "Resolution",
+        20: "Tattoo",
+        21: "Parasites",
+        22: "Unit",
+        23: "Paths",
+        24: "User unit",
+        25: "Vectors",
+        26: "Text layer flags"
+    }
+    handler = {
+        17: XcfCompression,
+        19: XcfResolution,
+        20: XcfTattoo,
+        21: XcfParasites,
+        22: XcfUnit
+    }
+
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf_prop", "XCF property", stream, parent, "!")
+        self.read("type", "Property type", (EnumChunk, "uint32", XcfProperty.type_name))
+        self.read("size", "Property size", (FormatChunk, "uint32"))
+        type = self["type"]
+        if type in XcfProperty.handler:
+            end = stream.tell() + self["size"]
+            substream = stream.createSub(size=self["size"])
+            self.read("data", "Data", (XcfProperty.handler[type],), {"stream": substream})
+            assert stream.tell() == end
+        elif 0 < self["size"]:
+            self.read("data", "Data", (FormatChunk, "string[%u]" % self["size"]))
+
+    def updateParent(self, parent):
+        parent.description = "Property: %s" % self.getChunk("type").getDisplayData()
+
+def readProperties(filter, stream):        
+    while True:
+        property = filter.doRead("property[]", "Property", (XcfProperty,))
+        if property["type"] == 0:
+            break
+
+def seek(filter, stream, offset):
+    current = stream.tell()
+    if current != offset:
+        filter.read("padding[]", "Padding", (FormatChunk, "string[%u]" % (offset-current)))
+
+class XcfFile(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "xcf", "XCF file", stream, parent, "!")
+        self.read("header", "Header", (StringChunk, "C"))
+        assert self["header"] == "gimp xcf file"
+        self.read("width", "Image width", (FormatChunk, "uint32"))
+        self.read("height", "Image height", (FormatChunk, "uint32"))
+        self.read("type", "Image type", (FormatChunk, "uint32"))
+        readProperties(self, stream)
+
+        layer_offsets = []
+        while True:
+            chunk = self.doRead("layer_offset[]", "Layer offset", (FormatChunk, "uint32"))
+            if chunk.value == 0:
+                break
+            layer_offsets.append(chunk.value)
+        channel_offsets = []
+        while True:
+            chunk = self.doRead("channel_offset[]", "Channel offset", (FormatChunk, "uint32"))
+            if chunk.value == 0:
+                break
+            channel_offsets.append(chunk.value)
+        for offset in layer_offsets:
+            seek(self, stream, offset)
+            self.read("layer[]", "Layer", (XcfLayer,))
+        for offset in channel_offsets:
+            seek(self, stream, offset)
+            self.read("channel[]", "Channel", (XcfChannel,))
+
+registerPlugin(XcfFile, "image/x-xcf")



From haypo at berlios.de  Tue Dec 27 04:39:43 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 04:39:43 +0100
Subject: [Happyboom-svn] r359 - in haypo/hachoir/trunk: . broken_plugins generic plugins
Message-ID: <200512270339.jBR3dhKU023546@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 04:39:41 +0100 (Tue, 27 Dec 2005)
New Revision: 359

Added:
   haypo/hachoir/trunk/plugins/bmp.py
   haypo/hachoir/trunk/plugins/pcx.py
   haypo/hachoir/trunk/plugins/zip.py
Removed:
   haypo/hachoir/trunk/bmp_filter.xml
   haypo/hachoir/trunk/broken_plugins/bmp.py
   haypo/hachoir/trunk/broken_plugins/pcx.py
   haypo/hachoir/trunk/broken_plugins/zip.py
Modified:
   haypo/hachoir/trunk/generic/image.py
   haypo/hachoir/trunk/text_handler.py
Log:
- Upgrade PCX, ZIP and BMP plugins to new syntax
- ZIP plugin: parse flags, display datetime (is msdos timestamp), display
  compression method name
- Remove bmp_filter.xml file (replace by BMP plugin)
- Fix RGB filter (problem of Python syntax)
- Set RGB filter static size


Deleted: haypo/hachoir/trunk/bmp_filter.xml
===================================================================
--- haypo/hachoir/trunk/bmp_filter.xml	2005-12-27 02:11:18 UTC (rev 358)
+++ haypo/hachoir/trunk/bmp_filter.xml	2005-12-27 03:39:41 UTC (rev 359)
@@ -1,18 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<user_filter hachoir_version='2005-10-27' id='bmp_file' description='Bitmap picture file (BMP)'>
-  <chunk format='!2s' id='header' description='Header ("BM")'/>
-  <chunk format='&lt;L' id='file_size' description='File size (bytes)'/>
-  <chunk format='&lt;L' id='notused' description='Reseved'/>
-  <chunk format='&lt;L' id='data_start' description='Data start position'/>
-  <chunk format='&lt;L' id='header_size' description='Header size'/>
-  <chunk format='&lt;L' id='width' description='Width (pixels)'/>
-  <chunk format='&lt;L' id='height' description='Height (pixels)'/>
-  <chunk format='&lt;H' id='nb_plan' description='Number of plan (=1)'/>
-  <chunk format='&lt;H' id='bits_pixel' description='Bits per pixel'/>
-  <chunk format='&lt;L' id='compression' description='Compression method'/>
-  <chunk format='&lt;L' id='image_size' description='Image size (bytes)'/>
-  <chunk format='&lt;L' id='horizontal_dpi' description='Horizontal DPI'/>
-  <chunk format='&lt;L' id='vertical_dpi' description='Vertical DPI'/>
-  <chunk format='&lt;L' id='used_colors' description='Number of color used'/>
-  <chunk format='&lt;L' id='important_color' description='Number of import colors'/>
-</user_filter>

Deleted: haypo/hachoir/trunk/broken_plugins/bmp.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/bmp.py	2005-12-27 02:11:18 UTC (rev 358)
+++ haypo/hachoir/trunk/broken_plugins/bmp.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -1,32 +0,0 @@
-"""
-Microsoft Bitmap picture parseer.
-
-Author: Victor Stinner
-Creation: 16 december 2005
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class BitmapFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "bmp_file", "Bitmap picture file (BMP)", stream, parent)
-        self.read("header", "!2s", "Header (\"BM\")")
-        self.read("file_size", "<L", "File size (bytes)")
-        self.read("notused", "<L", "Reseved")
-        self.read("data_start", "<L", "Data start position")
-        header_size = self.read("header_size", "<L", "Header size").value
-        assert header_size in (12, 40)
-        self.read("width", "<L", "Width (pixels)")
-        self.read("height", "<L", "Height (pixels)")
-        self.read("nb_plan", "<H", "Number of plan (=1)")
-        self.read("bits_pixel", "<H", "Bits per pixel")
-        if header_size == 40:
-            self.read("compression", "<L", "Compression method")
-            self.read("image_size", "<L", "Image size (bytes)")
-            self.read("horizontal_dpi", "<L", "Horizontal DPI")
-            self.read("vertical_dpi", "<L", "Vertical DPI")
-            self.read("used_colors", "<L", "Number of color used")
-            self.read("important_color", "<L", "Number of import colors")
-
-registerPlugin(BitmapFile, "image/x-ms-bmp")

Deleted: haypo/hachoir/trunk/broken_plugins/pcx.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/pcx.py	2005-12-27 02:11:18 UTC (rev 358)
+++ haypo/hachoir/trunk/broken_plugins/pcx.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -1,94 +0,0 @@
-"""
-PCX picture filter.
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-from stream.file import FileStream
-from cStringIO import StringIO
-
-class RGB(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rgb_color", "RGB color", stream, parent)
-        self.read("red", "B", "Red")
-        self.read("green", "B", "Green")
-        self.read("blue", "B", "Blue")
-    def updateParent(self, chunk):
-        chunk.description = "RGB color: #%02X%02X%02X" % (self["red"], self["green"], self["blue"])
-
-class Palette(Filter):
-    def __init__(self, stream, parent, count):
-        Filter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
-        for i in range(0, count):
-            self.readChild("color[]", RGB)
-
-def StreamDeflateRLE(filter, stream, size):
-    start = stream.tell()
-    end = start + size - 1
-    data = ""
-    width = filter.width
-    for y in range(0, filter.height):
-        line = ""
-        while len(line) < width:
-            character = stream.getN(1)
-            byte = ord(character)
-            if byte & 192 == 192:
-                repeat = byte & 63
-                character = stream.getN(1)
-                line = line + character * repeat                
-            else:
-                line = line + character
-        assert len(line) == width
-        data = data + line
-    assert stream.tell() == end
-    stream.seek(start)
-    return FileStream(StringIO(data),None)
-
-class PCX_Content(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pcx_content", "PCX content", stream, parent)
-        pcx = parent.getParent()
-        bytes_per_line = pcx["bytes_per_line"]
-        height = pcx["bytes_per_line"]
-        for y in range(0, height):
-            self.read("line[]", "%us" % bytes_per_line, "Line")
-
-class PCX_File(Filter):
-    compression_name = {
-        1: "RLE"
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pcx_file", "PCX picture", stream, parent)
-        id = self.read("id", "B", "PCX identifier (10)").value
-        assert id == 10
-        self.read("version", "B", "PCX version")
-        self.read("compression", "B", "Compression", post=self.postCompression)
-        self.bpp = self.read("bpp", "B", "Bits / pixel").value
-        # TODO: Support 4 and 24 bits/pxiel
-        assert self.bpp == 8
-        self.read("xmin", "<H", "Minimum X")
-        self.read("ymin", "<H", "Minimum Y")
-        self.width = self.read("width", "<H", "Width minus one").value+1
-        self.height = self.read("height", "<H", "Height minus one").value+1
-        self.read("horiz_dpi", "<H", "Horizontal DPI")
-        self.read("vert_dpi", "<H", "Vertical DPI")
-        self.readChild("palette_4bits", Palette, 16)
-        self.read("reserved", "B", "Reserved")
-        self.read("nb_color_plan", "B", "Number of color plans")
-        self.read("bytes_per_line", "<H", "Bytes per line")
-        self.read("color_mode", "<H", "Color mode")
-        self.read("reserved2", "58s", "Reserved")
-
-        size = stream.getSize() - stream.tell()
-        if self.bpp == 8:
-            size = size - 256*3
-        deflate = StreamDeflateRLE(self, stream, size)
-        self.readChild("data", DeflateFilter, deflate, size, PCX_Content)
-        if self.bpp == 8:
-            self.readChild("palette_8bits", Palette, 256)
-
-    def postCompression(self, chunk):
-        mode = chunk.value
-        return PCX_File.compression_name.get(mode, "Unknow (%s)" % mode)
-
-registerPlugin(PCX_File, "image/x-pcx")

Deleted: haypo/hachoir/trunk/broken_plugins/zip.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/zip.py	2005-12-27 02:11:18 UTC (rev 358)
+++ haypo/hachoir/trunk/broken_plugins/zip.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -1,115 +0,0 @@
-"""
-Zip splitter.
-
-Status: can read most important headers
-Author: Victor Stinner
-"""
-
-import sys
-from filter import Filter
-from plugin import registerPlugin
-from error import error
-from text_handler import humanFilesize, hexadecimal
-
-class ZipCentralDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_central_dir", "ZIP central directory", stream, parent)
-        self.read("version_made_by", "<H", "Version made by")
-        self.read("version_needed", "<H", "Version neede")
-        self.read("flags", "<H", "General purpose flag")
-        self.read("compression_method", "<H", "Compression method")
-        self.read("last_mod_file_time", "<H", "Last moditication file time")
-        self.read("last_mod_file_date", "<H", "Last moditication file date")
-        self.read("crc32", "<L", "CRC-32")
-        self.read("compressed_size", "<L", "Compressed size")
-        self.read("uncompressed_size", "<L", "Uncompressed size")
-        self.read("filename_length", "<H", "Filename length")
-        self.read("extra_length", "<H", "Extra fields length")
-        self.read("file_comment_length", "<H", "File comment length")
-        self.read("disk_number_start", "<H", "Disk number start")
-        self.read("internal_attr", "<H", "Internal file attributes")
-        self.read("external_attr", "<L", "External file attributes")
-        self.read("offset_header", "<L", "Relative offset of local header")
-        self.read("filename", "%us" % self["filename_length"], "Filename")
-        self.read("extra", "%us" % self["extra_length"], "Extra fields")
-        self.read("file_comment", "%us" % self["file_comment_length"], "File comment")
-
-    def updateParent(self, chunk):
-        desc = "Central directory: %s" % self["filename"]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ZipEndCentralDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_end_dir", "ZIP end central directory", stream, parent)
-        self.read("number_disk", "<H", "Number of this disk")
-        self.read("number_disk2", "<H", "Number of this disk2")
-        self.read("total_number_disk", "<H", "Total number of entries")
-        self.read("total_number_disk2", "<H", "Total number of entries2")
-        self.read("size", "<L", "Size of the central directory")
-        self.read("offset", "<L", "Offset of start of central directory")
-        self.readString("comment", "Pascal16", "ZIP comment")
-
-#class ZipZip64(Filter):
-#    def __init__(self, stream, parent):
-#        Filter.__init__(self, "zip_zip64, "ZIP ZIP64", stream, parent)
-#        self.read("size", "<Q", "Directory size")
-#        self.read("version_made_by", "<H", "Version made by")
-#        self.read("version_needed", "<H", "Version neede")
-#        self.read("disk_index", "<L", "Disk index")
-#        self.read("disk_index2", "<L", "Disk index2")
-#        self.read("disk_number", "<Q", "Disk number")
-#        self.read("disk_number2", "<Q", "Disk number2")
-#        self.read("size2", "<Q", "Directory size2")
-#        self.read("offset", "<Q", "Offset")
-        
-class ZipFileEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_file_entry", "ZIP file entry", stream, parent)
-        self.read("version", "<H", "Version")
-        self.read("flags", "<H", "Flags")
-        self.read("compression_method", "<H", "Compression method")
-        self.read("last_mod_time", "<H", "Last modification time")
-        self.read("last_mod_date", "<H", "Last modification date")
-        self.read("crc32", "<L", "Checksum (CRC32)")
-        self.read("compressed_size", "<L", "Compressed size (bytes)", post=humanFilesize)
-        self.read("uncompressed_size", "<L", "Uncompressed size (bytes)", post=humanFilesize)
-        self.read("filename_length", "<H", "Filename length")
-        self.read("extra_length", "<H", "Extra length")
-        self.read("filename", "%us" % self["filename_length"], "Filename")
-        self.read("extra", "%us" % self["extra_length"], "Extra")
-        self.read("compressed_data", "%us" % self["compressed_size"], "Compressed data")
-        if (self["flags"] & 4) == 4:
-            self.read("file_crc32", "<L", "Checksum (CRC32)")
-            self.read("file_compressed_size", "<L", "Compressed size (bytes)")
-            self.read("file_uncompressed_size", "<L", "Uncompressed size (bytes)")
-
-    def updateParent(self, chunk):
-        size = self.getChunk("compressed_size").display
-        desc = "File entry: %s (%s)" % (self["filename"], size)
-        chunk.description = desc
-        self.setDescription(desc)
-        
-class ZipFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_file", "ZIP archive file", stream, parent)
-        # File data
-        self.signature = None
-        self.central_directory = []
-        self.files = []
-        while not stream.eof():
-            header = self.read("header[]", "<L", "Header", post=hexadecimal).value
-            if header == 0x04034B50:
-                self.readChild("files[]", ZipFileEntry)
-            elif header == 0x02014b50:
-                self.readChild("central_directory[]", ZipCentralDirectory)
-            elif header == 0x06054b50:
-                self.readChild("end_central_directory", ZipEndCentralDirectory)
-            elif header == 0x05054b50:
-                self.readString("signature", "Pascal16", "Signature")
-            else:
-                error("Error, unknow ZIP header (0x%08X)." % header)
-                size = stream.getSize() - stream.tell()
-                self.read("raw", "%us" % size, "Raw")
-        
-registerPlugin(ZipFile, "application/x-zip")

Modified: haypo/hachoir/trunk/generic/image.py
===================================================================
--- haypo/hachoir/trunk/generic/image.py	2005-12-27 02:11:18 UTC (rev 358)
+++ haypo/hachoir/trunk/generic/image.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -12,8 +12,12 @@
         self.read("green", "Green", (FormatChunk, "uint8"))
         self.read("blue", "Blue", (FormatChunk, "uint8"))
 
+    def getStaticSize(stream, args):
+        return 3 
+    getStaticSize = staticmethod(getStaticSize)
+
     def updateParent(self, chunk):
-        value = self["red"] << 16 + self["green"] << 8 + self["blue"]
+        value = (self["red"] << 16) + (self["green"] << 8) + self["blue"]
         if value in RGB.name:
             chunk.description = "RGB color: "+RGB.name[value]
         else:

Copied: haypo/hachoir/trunk/plugins/bmp.py (from rev 351, haypo/hachoir/trunk/broken_plugins/bmp.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/bmp.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/bmp.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -0,0 +1,36 @@
+"""
+Microsoft Bitmap picture parser.
+- file extension: ".bmp"
+
+Author: Victor Stinner
+Creation: 16 december 2005
+"""
+
+from filter import OnDemandFilter
+from chunk import FormatChunk
+from plugin import registerPlugin
+
+class BitmapFile(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "bmp_file", "Bitmap picture file (BMP)", stream, parent, "<")
+        self.read("header", "Header (\"BM\")", (FormatChunk, "string[2]"))
+        self.read("file_size", "File size (bytes)", (FormatChunk, "uint32"))
+        self.read("notused", "Reseved", (FormatChunk, "uint32"))
+        self.read("data_start", "Data start position", (FormatChunk, "uint32"))
+        header_size = self.doRead("header_size", "Header size", (FormatChunk, "uint32")).value
+        assert self["header_size"] in (12, 40)
+        self.read("width", "Width (pixels)", (FormatChunk, "uint32"))
+        self.read("height", "Height (pixels)", (FormatChunk, "uint32"))
+        self.read("nb_plan", "Number of plan (=1)", (FormatChunk, "uint16"))
+        self.read("bits_pixel", "Bits per pixel", (FormatChunk, "uint16"))
+        if header_size == 40:
+            self.read("compression", "Compression method", (FormatChunk, "uint32"))
+            self.read("image_size", "Image size (bytes)", (FormatChunk, "uint32"))
+            self.read("horizontal_dpi", "Horizontal DPI", (FormatChunk, "uint32"))
+            self.read("vertical_dpi", "Vertical DPI", (FormatChunk, "uint32"))
+            self.read("used_colors", "Number of color used", (FormatChunk, "uint32"))
+            self.read("important_color", "Number of import colors", (FormatChunk, "uint32"))
+        size = stream.getSize() - stream.tell()            
+        self.read("data", "Image raw data", (FormatChunk, "string[%u]" % size))
+
+registerPlugin(BitmapFile, "image/x-ms-bmp")

Copied: haypo/hachoir/trunk/plugins/pcx.py (from rev 351, haypo/hachoir/trunk/broken_plugins/pcx.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/pcx.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/pcx.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -0,0 +1,83 @@
+"""
+PCX picture filter.
+"""
+
+from filter import OnDemandFilter, DeflateFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk
+from stream.file import FileStream
+from cStringIO import StringIO
+from generic.image import RGB
+
+class Palette(OnDemandFilter):
+    def __init__(self, stream, parent, count):
+        OnDemandFilter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
+        for i in range(0, count):
+            self.read("color[]", "Color", (RGB,))
+
+def StreamDeflateRLE(filter, stream, size):
+    start = stream.tell()
+    end = start + size - 1
+    data = ""
+    width = filter.width
+    for y in range(0, filter.height):
+        line = ""
+        while len(line) < width:
+            character = stream.getN(1)
+            byte = ord(character)
+            if byte & 192 == 192:
+                repeat = byte & 63
+                character = stream.getN(1)
+                line = line + character * repeat                
+            else:
+                line = line + character
+        assert len(line) == width
+        data = data + line
+    assert stream.tell() == end
+    stream.seek(start)
+    return FileStream(StringIO(data),None)
+
+class PCX_Content(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pcx_content", "PCX content", stream, parent)
+        pcx = parent.getParent()
+        bytes_per_line = pcx["bytes_per_line"]
+        height = pcx["bytes_per_line"]
+        for y in range(0, height):
+            self.read("line[]", "Line", (FormatChunk, "string[%u]" % bytes_per_line))
+
+class PCX_File(OnDemandFilter):
+    compression_name = {
+        1: "RLE"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pcx_file", "PCX picture", stream, parent, "<")
+        self.read("id", "PCX identifier (10)", (FormatChunk, "uint8"))
+        assert self["id"] == 10
+        self.read("version", "PCX version", (FormatChunk, "uint8"))
+        self.read("compression", "Compression", (EnumChunk, "uint8", PCX_File.compression_name))
+        self.bpp = self.doRead("bpp", "Bits / pixel", (FormatChunk, "uint8")).value
+        # TODO: Support 4 and 24 bits/pxiel
+        assert self.bpp == 8
+        self.read("xmin", "Minimum X", (FormatChunk, "uint16"))
+        self.read("ymin", "Minimum Y", (FormatChunk, "uint16"))
+        self.width = self.doRead("width", "Width minus one", (FormatChunk, "uint16")).value + 1
+        self.height = self.doRead("height", "Height minus one", (FormatChunk, "uint16")).value + 1
+        self.read("horiz_dpi", "Horizontal DPI", (FormatChunk, "uint16"))
+        self.read("vert_dpi", "Vertical DPI", (FormatChunk, "uint16"))
+        self.read("palette_4bits", "Palette (4 bits)", (Palette, 16))
+        self.read("reserved", "Reserved", (FormatChunk, "uint8"))
+        self.read("nb_color_plan", "Number of color plans", (FormatChunk, "uint8"))
+        self.read("bytes_per_line", "Bytes per line", (FormatChunk, "uint16"))
+        self.read("color_mode", "Color mode", (FormatChunk, "uint16"))
+        self.read("reserved2", "Reserved", (FormatChunk, "string[58]"))
+
+        size = stream.getSize() - stream.tell()
+        if self.bpp == 8:
+            size = size - 256*3
+        deflate = StreamDeflateRLE(self, stream, size)
+        self.read("data", "Data", (DeflateFilter, deflate, size, PCX_Content))
+        if self.bpp == 8:
+            self.read("palette_8bits", "Palette (8 bit)", (Palette, 256)) 
+
+registerPlugin(PCX_File, "image/x-pcx")

Copied: haypo/hachoir/trunk/plugins/zip.py (from rev 351, haypo/hachoir/trunk/broken_plugins/zip.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/zip.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/zip.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -0,0 +1,125 @@
+"""
+Zip splitter.
+
+Status: can read most important headers
+Author: Victor Stinner
+"""
+
+import sys
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, StringChunk, BitsChunk, BitsStruct, EnumChunk
+from error import error
+from text_handler import humanFilesize, hexadecimal, msdosDatetime
+
+class ZipCentralDirectory(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "zip_central_dir", "ZIP central directory", stream, parent, "<")
+        self.read("version_made_by", "Version made by", (FormatChunk, "uint16"))
+        self.read("version_needed", "Version needed", (FormatChunk, "uint16"))
+        self.read("flags", "General purpose flag", (FormatChunk, "uint16"))
+        self.read("compression", "Compression method", (EnumChunk, "uint16", FileEntry.compression_name))
+        self.read("last_mod", "Last moditication file time", (FormatChunk, "uint32"), {"post": msdosDatetime})
+        self.read("crc32", "CRC-32", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("compressed_size", "Compressed size", (FormatChunk, "uint32"))
+        self.read("uncompressed_size", "Uncompressed size", (FormatChunk, "uint32"))
+        self.read("filename_length", "Filename length", (FormatChunk, "uint16"))
+        self.read("extra_length", "Extra fields length", (FormatChunk, "uint16"))
+        self.read("comment_length", "File comment length", (FormatChunk, "uint16"))
+        self.read("disk_number_start", "Disk number start", (FormatChunk, "uint16"))
+        self.read("internal_attr", "Internal file attributes", (FormatChunk, "uint16"))
+        self.read("external_attr", "External file attributes", (FormatChunk, "uint32"))
+        self.read("offset_header", "Relative offset of local header", (FormatChunk, "uint32"))
+        self.read("filename", "Filename", (FormatChunk, "string[%u]" % self["filename_length"]))
+        self.read("extra", "Extra fields", (FormatChunk, "string[%u]" % self["extra_length"]))
+        self.read("comment", "Comment", (FormatChunk, "string[%u]" % self["comment_length"]))
+
+    def updateParent(self, chunk):
+        desc = "Central directory: %s" % self["filename"]
+        chunk.description = desc
+        self.setDescription(desc)
+
+class ZipEndCentralDirectory(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "zip_end_dir", "ZIP end central directory", stream, parent, "<")
+        self.read("number_disk", "Number of this disk", (FormatChunk, "uint16"))
+        self.read("number_disk2", "Number of this disk2", (FormatChunk, "uint16"))
+        self.read("total_number_disk", "Total number of entries", (FormatChunk, "uint16"))
+        self.read("total_number_disk2", "Total number of entries2", (FormatChunk, "uint16"))
+        self.read("size", "Size of the central directory", (FormatChunk, "uint32"))
+        self.read("offset", "Offset of start of central directory", (FormatChunk, "uint32"))
+        self.read("comment", "ZIP comment", (StringChunk, "Pascal16"))
+       
+class FileEntry(OnDemandFilter):
+    compression_name = {
+        0: "no compression",
+        1: "Shrunk",
+        2: "Reduced (factor 1)",
+        3: "Reduced (factor 2)",
+        4: "Reduced (factor 3)",
+        5: "Reduced (factor 4)",
+        6: "Imploded",
+        7: "Tokenizing",
+        8: "Deflate",
+        9: "Deflate64",
+        10: "PKWARE Imploding"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "zip_file_entry", "ZIP file entry", stream, parent, "<")
+        self.read("version", "Version", (FormatChunk, "uint16"))
+        bits = (
+            (1, "encryption", "File is encrypted?"),
+            (1, "8k_sliding", "Use 8K sliding dictionnary (instead of 4K)"),
+            (1, "3shannon", "Use a 3 Shannon-Fano tree (instead of 2 Shannon-Fano)"),
+            (1, "use_data_desc", "Use data descriptor?"),
+            (1, "reserved", "Reserved"),
+            (1, "patched", "File is compressed with patched data?"),
+            (6, "unused", "Unused bits"),
+            (4, "pkware", "Reserved by PKWARE"))
+        flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+#        self.read("flags", "Flags", (FormatChunk, "uint16"))
+        self.read("compression", "Compression method", (EnumChunk, "uint16", FileEntry.compression_name))
+        self.read("last_mod_time", "Last modification time", (FormatChunk, "uint16"))
+        self.read("last_mod_date", "Last modification date", (FormatChunk, "uint16"))
+        self.read("crc32", "Checksum (CRC32)", (FormatChunk, "uint32"))
+        self.read("compressed_size", "Compressed size (bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
+        self.read("uncompressed_size", "Uncompressed size (bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
+        self.read("filename_length", "Filename length", (FormatChunk, "uint16"))
+        self.read("extra_length", "Extra length", (FormatChunk, "uint16"))
+        self.read("filename", "Filename", (FormatChunk, "string[%u]" % self["filename_length"]))
+        self.read("extra", "Extra", (FormatChunk, "string[%u]" % self["extra_length"]))
+        self.read("compressed_data", "Compressed data", (FormatChunk, "string[%u]" % self["compressed_size"]))
+        if flags["use_data_desc"]:
+            self.read("file_crc32", "Checksum (CRC32)", (FormatChunk, "uint32"))
+            self.read("file_compressed_size", "Compressed size (bytes)", (FormatChunk, "uint32"))
+            self.read("file_uncompressed_size", "Uncompressed size (bytes)", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        size = self.getChunk("compressed_size").display
+        desc = "File entry: %s (%s)" % (self["filename"], size)
+        chunk.description = desc
+        self.setDescription(desc)
+        
+class ZipFile(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "zip_file", "ZIP archive file", stream, parent, "<")
+        # File data
+        self.signature = None
+        self.central_directory = []
+        self.files = []
+        while not stream.eof():
+            header = self.doRead("header[]", "Header", (FormatChunk, "uint32"), {"post": hexadecimal}).value
+            if header == 0x04034B50:
+                self.read("file[]", "File", (FileEntry,))
+            elif header == 0x02014b50:
+                self.read("central_directory[]", "Central directory", (ZipCentralDirectory,))
+            elif header == 0x06054b50:
+                self.read("end_central_directory", "End of central directory", (ZipEndCentralDirectory,))
+            elif header == 0x05054b50:
+                self.read("signature", "Signature", (StringChunk, "Pascal16"))
+            else:
+                error("Error, unknow ZIP header (0x%08X)." % header)
+                size = stream.getSize() - stream.tell()
+                self.read("raw", "Raw", (FormatChunk, "string[%u]" % size))
+        
+registerPlugin(ZipFile, "application/x-zip")

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-27 02:11:18 UTC (rev 358)
+++ haypo/hachoir/trunk/text_handler.py	2005-12-27 03:39:41 UTC (rev 359)
@@ -1,3 +1,15 @@
+def msdosDatetime(chunk):
+    import datetime
+    assert chunk.size == 4
+    val = chunk.value
+    sec = 2 * (val & 31)              #?5 bits: second
+    min = (val >> 5) & 63             # 6 bits: minute
+    hour = (val >> 11) & 31           #?5 bits: hour
+    day = (val >> 16) & 31            # 5 bits: day
+    month = (val >> 21) & 15          # 4 bits: month
+    year = 1980 + ((val >> 25) & 127) # 7 bits: year
+    return str(datetime.datetime(year, month, day, hour, min, sec))
+    
 def humanFilesize(chunk):
     from tools import humanFilesize as doHumanFilesize
     return doHumanFilesize(chunk.value)
@@ -10,5 +22,5 @@
 def hexadecimal(chunk):
     size = chunk.size
     assert size in (2, 4, 8)
-    pattern = "%0" + str(2*size) + "X"
+    pattern = "0x%0" + str(2*size) + "X"
     return pattern % chunk.value



From haypo at berlios.de  Tue Dec 27 07:00:21 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 07:00:21 +0100
Subject: [Happyboom-svn] r361 - in haypo/hachoir/trunk: broken_plugins plugins
Message-ID: <200512270600.jBR60LQO020935@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 06:59:59 +0100 (Tue, 27 Dec 2005)
New Revision: 361

Added:
   haypo/hachoir/trunk/plugins/mbr.py
Removed:
   haypo/hachoir/trunk/broken_plugins/mbr.py
Log:
- Upgrade MBR to new syntax
- MBR display partition size with humanFilesize function
- Fix partition type name (be more precise)


Deleted: haypo/hachoir/trunk/broken_plugins/mbr.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/mbr.py	2005-12-27 05:36:12 UTC (rev 360)
+++ haypo/hachoir/trunk/broken_plugins/mbr.py	2005-12-27 05:59:59 UTC (rev 361)
@@ -1,66 +0,0 @@
-"""
-Master Boot Record.
-
-
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class PartitionEntry(Filter):
-    system_name = {
-        0x00: "Unused",
-        0x05: "Extended",
-        0x06: "FAT16",
-        0x0E: "FAT16",
-        0x0B: "FAT32",
-        0x0C: "FAT32",
-        0x82: "Linux swap",
-        0x83: "Linux"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "default", "Default filter", stream, parent)
-        bootable = self.read("bootable", "B", "Bootable flag (true if equals to 0x80)").value
-        assert bootable in (0x00, 0x80)
-        self.read("start_head", "B", "Starting head number of the partition")
-        self.read("start_sector", "B", "Starting sector number of the partition")
-        self.read("start_low_cylinder", "B", "Lower 8 bits of starting cylinder number of the partition")
-        self.read("system", "B", "System indicator", post=self.postSystem)
-        self.read("end_head", "B", "Ending head number of the partition")
-        self.read("end_sector", "B", "Ending sector number of the partition")
-        self.read("end_low_cylinder", "B", "Lower 8 bits of ending cylinder number of the partition")
-        self.read("LBA", "<L", "LBA (number of sectors before this partition)")
-        self.read("size", "<L", "Size")
-
-    def updateParent(self, parent):
-        block_size = self.getParent().block_size
-        size_mb = self["size"] / ((1 << 20) / block_size)
-
-        desc = "Partition entry (type %s, %u MB)" % (self.type, size_mb)
-        parent.description = desc
-        self.setDescription(desc)        
-
-    def postSystem(self, chunk):
-        type = chunk.value
-        self.type = PartitionEntry.system_name.get(type, "Unknow (%02X)" % type)
-        return self.type      
-
-class MasterBootRecordFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "default", "Default filter", stream, parent)
-        # TODO: Get right block size!
-        self.block_size = 512
-        assert 512<=stream.getSize()
-        jmp = self.read("jmp", "B", "Jump instruction").value
-        assert jmp in (0xEB, 0xFA)
-        size = 446 - stream.tell()
-        self.read("data", "%us" % size, "Raw data")
-        self.readChild("partition[]", PartitionEntry)
-        self.readChild("partition[]", PartitionEntry)
-        self.readChild("partition[]", PartitionEntry)
-        self.readChild("partition[]", PartitionEntry)
-        id = self.read("id", "<H", "Identifier (0xAA55)").value
-        assert id == 0xAA55
-
-registerPlugin(MasterBootRecordFilter, "hachoir/master-boot-record")

Copied: haypo/hachoir/trunk/plugins/mbr.py (from rev 351, haypo/hachoir/trunk/broken_plugins/mbr.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/mbr.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/mbr.py	2005-12-27 05:59:59 UTC (rev 361)
@@ -0,0 +1,65 @@
+"""
+Master Boot Record.
+
+
+"""
+
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import EnumChunk, FormatChunk
+from tools import humanFilesize
+
+class PartitionEntry(OnDemandFilter):
+    system_name = {
+        0x00: "Unused",
+        0x05: "Extended",
+        0x06: "FAT16",
+        0x0B: "FAT32",
+        0x0C: "FAT32 (LBA)",
+        0x0E: "FAT16 (LBA)",
+        0x82: "Linux swap",
+        0x83: "Linux (ext2/ext3)"
+    }
+    
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "default", "Default filter", stream, parent, "<")
+        self.read("bootable", "Bootable flag (true if equals to 0x80)", (FormatChunk, "uint8"))
+        assert self["bootable"] in (0x00, 0x80)
+        self.read("start_head", "Starting head number of the partition", (FormatChunk, "uint8"))
+        self.read("start_sector", "Starting sector number of the partition", (FormatChunk, "uint8"))
+        self.read("start_low_cylinder", "Lower 8 bits of starting cylinder number of the partition", (FormatChunk, "uint8"))
+        self.read("system", "System indicator", (EnumChunk, "uint8", PartitionEntry.system_name))
+        self.read("end_head", "Ending head number of the partition", (FormatChunk, "uint8"))
+        self.read("end_sector", "Ending sector number of the partition", (FormatChunk, "uint8"))
+        self.read("end_low_cylinder", "Lower 8 bits of ending cylinder number of the partition", (FormatChunk, "uint8"))
+        self.read("LBA", "LBA (number of sectors before this partition)", (FormatChunk, "uint32"))
+        self.read("size", "Size (block count)", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        desc = "Partition entry: "
+        system = self.getChunk("system")
+        if system.value != 0:
+            type = self.getChunk("system").getDisplayData()
+            block_size = self.getParent().block_size
+            size = self["size"] * block_size
+            desc += "%s, %s" % (type, humanFilesize(size))
+        else:
+            desc += "(unused)"
+        chunk.description = desc
+
+class MasterBootRecord(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "default", "Default filter", stream, parent, "<")
+        # TODO: Get right block size!
+        self.block_size = 512
+        assert 512<=stream.getSize()
+        self.read("jmp", "Jump instruction", (FormatChunk, "uint8"))
+        assert self["jmp"] in (0xEB, 0xFA)
+        size = 446 - stream.tell()
+        self.read("data", "Raw data", (FormatChunk, "string[%u]" % size))
+        for i in range(0,4):
+            self.read("partition[]", "Partition entry", (PartitionEntry,))
+        self.read("id", "Identifier (0xAA55)", (FormatChunk, "uint16"))
+        assert self["id"] == 0xAA55
+
+registerPlugin(MasterBootRecord, "hachoir/master-boot-record")



From haypo at berlios.de  Tue Dec 27 18:57:42 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 18:57:42 +0100
Subject: [Happyboom-svn] r362 - in haypo/hachoir/trunk: . broken_plugins plugins
Message-ID: <200512271757.jBRHvgbU017301@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 18:57:40 +0100 (Tue, 27 Dec 2005)
New Revision: 362

Added:
   haypo/hachoir/trunk/plugins/3ds.py
Removed:
   haypo/hachoir/trunk/broken_plugins/3ds.py
Modified:
   haypo/hachoir/trunk/text_handler.py
Log:
Upgrade 3DS plugin to new syntax


Deleted: haypo/hachoir/trunk/broken_plugins/3ds.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/3ds.py	2005-12-27 05:59:59 UTC (rev 361)
+++ haypo/hachoir/trunk/broken_plugins/3ds.py	2005-12-27 17:57:40 UTC (rev 362)
@@ -1,175 +0,0 @@
-"""
-3D Studio Max file (.3ds) parser.
-Author: Victor Stinner
-"""
-
-from filter import Filter, OnDemandFilter
-from plugin import registerPlugin
-
-def readTextureFilename(filter, stream, last_pos):
-    filter.readString("filename", "C", "Texture filename")
-
-def readVersion(filter, stream, last_pos):
-    filter.read("version", "<L", "Version")
-
-def readMaterialName(filter, stream, last_pos):
-    filter.readString("name", "C", "Material name")
-
-def readObject(filter, stream, last_pos):
-    chunk = filter.readString("name", "C", "Object name")
-    while stream.tell() < last_pos:
-        filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
-
-class Filter_3DS_MapUV(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_map", "3DS UV map", stream, parent)
-        self.read("u", "f", "Map U")
-        self.read("v", "f", "Map V")
-
-class Filter_3DS_Vertex(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_vertex", "3DS vertex", stream, parent)
-        self.read("x", "f", "X")
-        self.read("y", "f", "Y")
-        self.read("z", "f", "Z")
-
-class Filter_3DS_Polygon(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_polygon", "3DS polygon", stream, parent)
-        self.read("a", "<H", "Vertex A")
-        self.read("b", "<H", "Vertex B")
-        self.read("c", "<H", "Vertex C")
-        self.read("flags", "<H", "Flags")
-    
-def readMapList(filter, stream, last_pos):
-    filter.read("count", "<H", "Map count")
-    for i in range(0, filter["count"]):
-        filter.readSizedChild("map[]", "Map UV", 2*4, Filter_3DS_MapUV)
-
-def readColor(filter, stream, last_pos):
-    filter.read("red", "B", "Red componant")
-    filter.read("green", "B", "Green componant")
-    filter.read("blue", "B", "Blue componant")
-
-def readVertexList(filter, stream, last_pos):
-    filter.read("count", "<H", "Vertex count")
-    for i in range(0, filter["count"]):
-        filter.readSizedChild("vertex[]", "Vertex", 3*4, Filter_3DS_Vertex)
-    
-def readPolygonList(filter, stream, last_pos):
-    filter.read("count", "<H", "Vertex count")
-    for i in range(0, filter["count"]):
-        filter.readSizedChild("polygon[]", "Polygon", 4*2, Filter_3DS_Polygon)
-    while stream.tell() < last_pos:
-        filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
-
-class Filter_3DS_Chunk(OnDemandFilter):
-    # List of chunk type name
-    type_name = {
-        0x0011: "Color",
-        0x4D4D: "Main chunk",
-        0x0002: "File version",
-        0x3D3D: "Materials and objects",
-        0x4000: "Object",
-        0x4100: "Mesh (triangular)",
-        0x4110: "Vertices list",
-        0x4120: "Polygon (faces) list",
-        0x4140: "Map UV list",
-        0x4130: "Object material",
-        0xAFFF: "New material",
-        0xA000: "Material name",
-        0xA010: "Material ambiant",
-        0xA020: "Material diffuse",
-        0xA030: "Texture specular",
-        0xA200: "Texture",
-        0xA300: "Texture filename",
-
-        # Key frames
-        0xB000: "Keyframes",
-        0xB002: "Object node tag",
-        0xB006: "Light target node tag",
-        0xB007: "Spot light node tag",
-        0xB00A: "Keyframes header",
-        0xB009: "Keyframe current time",
-        0xB030: "Node identifier",
-        0xB010: "Node header",
-        0x7001: "Viewport layout"
-    }
-
-    chunk_id_by_type = {
-        0x4d4d: "main",
-        0x0002: "version",
-        0x3d3d: "obj_mat",
-        0xb000: "keyframes",
-        0xafff: "material",
-        0x4000: "object"
-    }
-
-    # List of chunks which contains other chunks
-    sub_chunks = \
-        (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
-         0xB002, 0xB006, 0xB007,
-         0xA010, 0xA030, 0xA020, 0xB000)
-
-    # List of chunk type handlers
-    handlers = {
-        0xA000: readMaterialName,
-        0x4000: readObject,
-        0xA300: readTextureFilename,
-        0x0011: readColor,
-        0x0002: readVersion,
-# TODO: Uncomment these functions, it's too slow yet            
-         0x4110: readVertexList,
-         0x4120: readPolygonList,
-         0x4140: readMapList
-    }
-    
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
-        chunk = self.doRead("type", "<H", "Chunk type", post=self.toHex)
-        chunk.description = "Chunk type (%s)" % self.getType()
-        self.read("size", "<L", "Chunk size")
-        size = self["size"] - 6
-        type = self["type"] 
-        end = stream.tell() + size
-        if type in Filter_3DS_Chunk.sub_chunks:
-            while stream.tell() < end:
-                self.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
-            assert stream.tell() == end 
-        else:
-            if type in Filter_3DS_Chunk.handlers: 
-                end = stream.tell() + size
-                Filter_3DS_Chunk.handlers[type] (self, stream, end)
-                assert stream.tell() == end
-            else:
-                self.read("data", "%us" % size, "Raw data")
-
-    def checkEnd(self, stream, array, last):
-        return stream.eof()
-
-    def updateParent(self, chunk):
-        type = self.getType()
-        chunk.description = "Chunk of type \"%s\"" % type
-        self.setDescription("Chunk type (%s)" % type)
-        if self["type"] in Filter_3DS_Chunk.chunk_id_by_type:
-            id = Filter_3DS_Chunk.chunk_id_by_type[self["type"]]
-# TODO: Re-enable that            
-#            chunk.id = id
-            self.setId(id) 
-        else:
-            self.setId("chunk_%04x" % self["type"])
-
-    def toHex(self, chunk):
-        return "%04X" % chunk.value
-        
-    def getType(self):
-        type = self["type"]
-        return Filter_3DS_Chunk.type_name.get(type, "%04X" % type)
-
-class Filter_3DS_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_file", "3DS file", stream, parent)
-        while not stream.eof():
-            self.readChild("chunk[]", Filter_3DS_Chunk)
-
-registerPlugin(Filter_3DS_File, "image/x-3ds")

Copied: haypo/hachoir/trunk/plugins/3ds.py (from rev 351, haypo/hachoir/trunk/broken_plugins/3ds.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/3ds.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/3ds.py	2005-12-27 17:57:40 UTC (rev 362)
@@ -0,0 +1,188 @@
+"""
+3D Studio Max file (.3ds) parser.
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter, OnDemandFilter
+from chunk import FormatChunk, StringChunk
+from plugin import registerPlugin
+
+def readTextureFilename(filter, stream, last_pos):
+    filter.read("filename", "Texture filename", (StringChunk, "C"))
+
+def readVersion(filter, stream, last_pos):
+    filter.read("version", "Version", (FormatChunk, "uint32"))
+
+def readMaterialName(filter, stream, last_pos):
+    filter.read("name", "Material name", (StringChunk, "C"))
+
+def readObject(filter, stream, last_pos):
+    chunk = filter.read("name", "Object name", (StringChunk, "C"))
+    while stream.tell() < last_pos:
+        filter.read("chunk[]", "Chunk", (Filter_3DS_Chunk,))
+
+class Filter_3DS_MapUV(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "3ds_map", "3DS UV map", stream, parent, "<")
+        self.read("u", "Map U", (FormatChunk, "float"))
+        self.read("v", "Map V", (FormatChunk, "float"))
+
+    def getStaticSize(stream, args):
+        return 4*2
+    getStaticSize = staticmethod(getStaticSize)
+ 
+class Filter_3DS_Vertex(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "3ds_vertex", "3DS vertex", stream, parent, "<")
+        self.read("x", "X", (FormatChunk, "float"))
+        self.read("y", "Y", (FormatChunk, "float"))
+        self.read("z", "Z", (FormatChunk, "float"))
+
+    def getStaticSize(stream, args):
+        return 4*3
+    getStaticSize = staticmethod(getStaticSize)
+
+class Filter_3DS_Polygon(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "3ds_polygon", "3DS polygon", stream, parent, "<")
+        self.read("a", "Vertex A", (FormatChunk, "uint16"))
+        self.read("b", "Vertex B", (FormatChunk, "uint16"))
+        self.read("c", "Vertex C", (FormatChunk, "uint16"))
+        self.read("flags", "Flags", (FormatChunk, "uint16"))
+
+    def getStaticSize(stream, args):
+        return 4*2
+    getStaticSize = staticmethod(getStaticSize)
+    
+def readMapList(filter, stream, last_pos):
+    filter.read("count", "Map count", (FormatChunk, "uint16"))
+    for i in range(0, filter["count"]):
+        filter.read("map[]", "Map UV", (Filter_3DS_MapUV,))
+
+def readColor(filter, stream, last_pos):
+    filter.read("red", "Red componant", (FormatChunk, "uint8"))
+    filter.read("green", "Green componant", (FormatChunk, "uint8"))
+    filter.read("blue", "Blue componant", (FormatChunk, "uint8"))
+
+def readVertexList(filter, stream, last_pos):
+    filter.read("count", "Vertex count", (FormatChunk, "uint16"))
+    for i in range(0, filter["count"]):
+        filter.read("vertex[]", "Vertex", (Filter_3DS_Vertex,))
+    
+def readPolygonList(filter, stream, last_pos):
+    filter.read("count", "Vertex count", (FormatChunk, "uint16"))
+    for i in range(0, filter["count"]):
+        filter.read("polygon[]", "Polygon", (Filter_3DS_Polygon,))
+    while stream.tell() < last_pos:
+        filter.read("chunk[]", "Chunk", (Filter_3DS_Chunk,))
+
+class Filter_3DS_Chunk(OnDemandFilter):
+    # List of chunk type name
+    type_name = {
+        0x0011: "Color",
+        0x4D4D: "Main chunk",
+        0x0002: "File version",
+        0x3D3D: "Materials and objects",
+        0x4000: "Object",
+        0x4100: "Mesh (triangular)",
+        0x4110: "Vertices list",
+        0x4120: "Polygon (faces) list",
+        0x4140: "Map UV list",
+        0x4130: "Object material",
+        0xAFFF: "New material",
+        0xA000: "Material name",
+        0xA010: "Material ambiant",
+        0xA020: "Material diffuse",
+        0xA030: "Texture specular",
+        0xA200: "Texture",
+        0xA300: "Texture filename",
+
+        # Key frames
+        0xB000: "Keyframes",
+        0xB002: "Object node tag",
+        0xB006: "Light target node tag",
+        0xB007: "Spot light node tag",
+        0xB00A: "Keyframes header",
+        0xB009: "Keyframe current time",
+        0xB030: "Node identifier",
+        0xB010: "Node header",
+        0x7001: "Viewport layout"
+    }
+
+    chunk_id_by_type = {
+        0x4d4d: "main",
+        0x0002: "version",
+        0x3d3d: "obj_mat",
+        0xb000: "keyframes",
+        0xafff: "material",
+        0x4000: "object",
+        0x4110: "vertices_list",
+        0x4120: "polygon_list",
+        0x4140: "mapuv_list",
+        0x4100: "mesh"
+    }
+
+    # List of chunks which contains other chunks
+    sub_chunks = \
+        (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
+         0xB002, 0xB006, 0xB007,
+         0xA010, 0xA030, 0xA020, 0xB000)
+
+    # List of chunk type handlers
+    handlers = {
+        0xA000: readMaterialName,
+        0x4000: readObject,
+        0xA300: readTextureFilename,
+        0x0011: readColor,
+        0x0002: readVersion,
+        0x4110: readVertexList,
+        0x4120: readPolygonList,
+        0x4140: readMapList
+    }
+    
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent, "<")
+        chunk = self.doRead("type", "Chunk type", (FormatChunk, "uint16"), {"post": self.toHex})
+        chunk.description = "Chunk type (%s)" % self.getType()
+        self.read("size", "Chunk size", (FormatChunk, "uint32"))
+        size = self["size"] - 6
+        type = self["type"] 
+        end = stream.tell() + size
+        if type in Filter_3DS_Chunk.sub_chunks:
+            while stream.tell() < end:
+                self.read("chunk[]", "Chunk", (Filter_3DS_Chunk,))
+            assert stream.tell() == end 
+        else:
+            if type in Filter_3DS_Chunk.handlers: 
+                end = stream.tell() + size
+                Filter_3DS_Chunk.handlers[type] (self, stream, end)
+                assert stream.tell() == end
+            else:
+                self.read("data", "Raw data", (FormatChunk, "string[%u]" % size))
+
+    def checkEnd(self, stream, array, last):
+        return stream.eof()
+
+    def updateParent(self, chunk):
+        type = self.getType()
+        chunk.description = "Chunk: %s" % type
+        if self["type"] in Filter_3DS_Chunk.chunk_id_by_type:
+            id = Filter_3DS_Chunk.chunk_id_by_type[self["type"]]
+            chunk.id = id
+        else:
+            chunk.id = "chunk_%04x" % self["type"]
+
+    def toHex(self, chunk):
+        return "%04X" % chunk.value
+        
+    def getType(self):
+        type = self["type"]
+        return Filter_3DS_Chunk.type_name.get(type, "%04X" % type)
+
+class Filter_3DS_File(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "3ds_file", "3DS file", stream, parent)
+        while not stream.eof():
+            self.read("chunk[]", "Chunk", (Filter_3DS_Chunk,))
+
+registerPlugin(Filter_3DS_File, "image/x-3ds")

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-27 05:59:59 UTC (rev 361)
+++ haypo/hachoir/trunk/text_handler.py	2005-12-27 17:57:40 UTC (rev 362)
@@ -1,21 +1,21 @@
+import datetime
+from tools import humanFilesize as doHumanFilesize
+
 def msdosDatetime(chunk):
-    import datetime
     assert chunk.size == 4
     val = chunk.value
-    sec = 2 * (val & 31)              #?5 bits: second
+    sec = 2 * (val & 31)              # 5 bits: second
     min = (val >> 5) & 63             # 6 bits: minute
-    hour = (val >> 11) & 31           #?5 bits: hour
+    hour = (val >> 11) & 31           # 5 bits: hour
     day = (val >> 16) & 31            # 5 bits: day
     month = (val >> 21) & 15          # 4 bits: month
     year = 1980 + ((val >> 25) & 127) # 7 bits: year
     return str(datetime.datetime(year, month, day, hour, min, sec))
     
 def humanFilesize(chunk):
-    from tools import humanFilesize as doHumanFilesize
     return doHumanFilesize(chunk.value)
 
 def unixTimestamp(chunk):
-    import datetime
     timestamp = datetime.datetime.fromtimestamp(chunk.value)
     return str(timestamp) 
 



From haypo at berlios.de  Tue Dec 27 20:18:07 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 20:18:07 +0100
Subject: [Happyboom-svn] r363 - in haypo/hachoir/trunk: . broken_plugins plugins
Message-ID: <200512271918.jBRJI7pT031140@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 20:18:05 +0100 (Tue, 27 Dec 2005)
New Revision: 363

Added:
   haypo/hachoir/trunk/plugins/gif.py
Removed:
   haypo/hachoir/trunk/broken_plugins/gif.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/format.py
Log:
- Upgrade GIF plugin to new syntax
- Fix GIF flags parser (thanks to new BitsChunk class)


Deleted: haypo/hachoir/trunk/broken_plugins/gif.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/gif.py	2005-12-27 17:57:40 UTC (rev 362)
+++ haypo/hachoir/trunk/broken_plugins/gif.py	2005-12-27 19:18:05 UTC (rev 363)
@@ -1,130 +0,0 @@
-"""
-GIF splitter.
-
-Status: loads header, don't load image data (stop filter), and is buggy ...
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-from error import warning
-
-class GifColor(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_color", "GIF color (RGB)", stream, parent)
-        self.read("red", "<B", "Red")
-        self.read("green", "<B", "Green")
-        self.read("blue", "<B", "Blue")
-
-class GifImage(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_image", "GIF image data", stream, parent)
-        self.read("left", "<H", "Left")
-        self.read("top", "<H", "Top")
-        self.read("width", "<H", "Width")
-        self.read("height", "<H", "Height")
-
-        # TODO: Fix this ...
-        self.read("flags", "<H", "Flags")
-        self.global_map = ((self["flags"] & 0x80) == 0x80)
-        self.interlaced = ((self["flags"] & 0x40) == 0x40)
-        self.bits_per_pixel = 1 + (self["flags"] & 0x07)
-        if not self.global_map:
-            self.readChild("local_map", GifColorMap)
-            self.local_map = self["local_map"]
-        else:
-            self.local_map = None
-        # -- End of TODO
-
-class GifColorMap(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_colormap", "GIF color map", stream, parent)
-        if issubclass(parent.__class__, GifImage):
-            self._nb_colors = (1 << parent.bits_per_pixel)
-        else:
-            assert issubclass(parent.__class__, GifFile)
-            screen = parent.getChunk("screen").getFilter()
-            self._nb_colors = (1 << screen.bits_per_pixel)
-        n = 0
-        while n<self._nb_colors:
-            self.readChild("color[]", GifColor)
-            n = n + 1
-
-    def checkEndOfMap(self, stream, array, color):
-        return len(array) == self._nb_colors 
-
-class GifExtensionChunk(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_ext_data", "GIF extension data", stream, parent)
-        self.read("size", "B", "Size (in bytes)")
-        self.read("content", "%us" % self["size"], "Content")
-
-class GifExtension(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_ext", "GIF extension", stream, parent)
-        self.read("func", "<B", "Function")
-        while True:
-            chunk = self.readChild("chunk[]", GifExtensionChunk)
-            if chunk.getFilter()["size"] == 0:
-                break
-        
-class GifScreenDescriptor(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_screen_desc", "GIF screen descriptor", stream, parent)
-        self.read("width", "<H", "Width")
-        self.read("height", "<H", "Height")
-
-        # TODO: Fix this
-        self.read("flags", "<B", "Flags", post=self.processFlags)
-        # -- End of TODO
-        
-        self.read("background", "<B", "Background color")
-        self.read("notused", "<B", "Not used (zero)")
-
-    def processFlags(self, chunk):
-        flags = chunk.value
-        self.global_map = ((flags & 0x80) == 0x80) # ok
-        self.color_res = 1 + ((flags >> 4) & 0x7) # ??
-        self.bits_per_pixel = 1 + (flags & 0x7) # ok
-        if self.global_map:
-            text = "global map, "
-        else:
-            text = ""
-        return text + "color res=%u, bits/pixel=%u" % (self.color_res, self.bits_per_pixel)
-        
-class GifFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "gif_file", "GIF picture file", stream, parent)
-        # Header
-        self.read("header", "6s", "File header")
-        assert (self["header"] == "GIF87a") or (self["header"] == "GIF89a")
-        
-        self.readChild("screen", GifScreenDescriptor)
-        if self["screen"].global_map:
-            self.readChild("color_map", GifColorMap)
-            self.color_map = self["color_map"]
-        else:
-            self.color_map = None
-            
-        self.images = []
-        while True:
-            code = self.read("separator[]", "c", "Separator code")
-            code = code.getValue()
-            if code == "!":
-                self.readChild("extensions[]", GifExtension)
-            elif code == ",":
-                self.readChild("images[]", GifImage)
-                # TODO: Write Huffman parser code :-)
-#                self.readImage(stream)
-                return
-            elif code == ";":
-                # GIF Terminator
-                return
-            else:
-                raise Exception("Wrong GIF image separator: ASCII %02X." % ord(code))
-
-    def readImage(self, stream):              
-        size = stream.getSize() - stream.tell()
-        self.read("data", "%us" % size, "Image data")
-
-registerPlugin(GifFile, "image/gif")

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-27 17:57:40 UTC (rev 362)
+++ haypo/hachoir/trunk/chunk.py	2005-12-27 19:18:05 UTC (rev 363)
@@ -1,6 +1,6 @@
 import struct, re, types
 import config
-from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsInteger
+from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsArray, formatIsInteger
 from error import warning, error
 from tools import convertDataToPrintableString
 
@@ -362,7 +362,7 @@
 
 class EnumChunk(FormatChunk):
     def __init__(self, id, description, stream, format, dict, parent):
-        assert formatIsString(format) or formatIsInteger(format)
+        assert not formatIsArray(format)
         FormatChunk.__init__(self, id, description, stream, format, parent)
         self._dict = dict
 #        value = self.getValue()

Modified: haypo/hachoir/trunk/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2005-12-27 17:57:40 UTC (rev 362)
+++ haypo/hachoir/trunk/format.py	2005-12-27 19:18:05 UTC (rev 363)
@@ -99,3 +99,7 @@
 def splitFormat(format):
     cache = FormatCache.getInstance()[format]
     return cache[1:4]   
+
+def formatIsArray(format):
+    cache = FormatCache.getInstance()[format]
+    return 1 < cache[2]   

Copied: haypo/hachoir/trunk/plugins/gif.py (from rev 351, haypo/hachoir/trunk/broken_plugins/gif.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/gif.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/gif.py	2005-12-27 19:18:05 UTC (rev 363)
@@ -0,0 +1,120 @@
+"""
+GIF picture parser.
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk, BitsChunk, BitsStruct
+from error import warning
+from generic.image import RGB
+
+class Image(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "gif_image", "Image", stream, parent, "<")
+        self.read("left", "Left", (FormatChunk, "uint16"))
+        self.read("top", "Top", (FormatChunk, "uint16"))
+        self.read("width", "Width", (FormatChunk, "uint16"))
+        self.read("height", "Height", (FormatChunk, "uint16"))
+
+        bits = (
+            (1, "local_color", "Local color table"),
+            (1, "interlace", "Interlaced?"),
+            (1, "sort", "Sort"),
+            (2, "reserved", "Reserved"),
+            (3, "size_local", "Size of local color"))
+        self.flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+
+        return
+        if not self.flags["local_color"]:
+            self.read("local_map", "Local color map", (ColorMap, 1 << self.flags["size_local"]))
+            self.local_map = self["local_map"]
+        else:
+            self.local_map = None
+
+    def updateParent(self, chunk):
+        chunk.description = "Image: %ux%u pixels at (%u,%u)" \
+            % (self["width"], self["height"], self["left"], self["top"])
+
+class ColorMap(OnDemandFilter):
+    def __init__(self, stream, parent, nb_colors):
+        OnDemandFilter.__init__(self, "gif_colormap", "Color map: %u colors" % nb_colors, stream, parent)
+        for i in range(0, nb_colors):
+            self.read("color[]", "Color", (RGB,))
+
+class ExtensionChunk(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "gif_ext_data", "GIF extension data", stream, parent)
+        self.read("size", "Size (in bytes)", (FormatChunk, "uint8"))
+        self.read("content", "Content", (FormatChunk, "string[%u]" % self["size"]))
+
+class Extension(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "gif_ext", "GIF extension", stream, parent)
+        self.read("func", "Function", (FormatChunk, "uint8"))
+        while True:
+            chunk = self.doRead("chunk[]", "Chunk", (ExtensionChunk,))
+            if chunk["size"] == 0:
+                break
+        
+class ScreenDescriptor(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "gif_screen_desc", "GIF screen descriptor", stream, parent, "<")
+        self.read("width", "Width", (FormatChunk, "uint16"))
+        self.read("height", "Height", (FormatChunk, "uint16"))
+
+        bits = (
+            (1, "global_map", "Has global map?"),
+            (3, "bpp", "Bits per pixel minus one"),
+            (3, "color_res", "Color resolution minus one"),
+            (1, "xxx", "???"))
+        self.flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+        self.bits_per_pixel = 1 + self.flags["bpp"]
+
+
+#        self.read("flags", "Flags", (FormatChunk, "uint8"), {"post": self.processFlags})
+        
+        self.read("background", "Background color", (FormatChunk, "uint8"))
+        self.read("notused", "Not used (zero)", (FormatChunk, "uint8"))
+
+    def updateParent(self, chunk):
+        chunk.description = "Screen descriptor: %ux%u, %u colors" \
+            % (self["width"], self["height"], 1 << self.bits_per_pixel)
+
+class GifFile(OnDemandFilter):
+    separator_name = {
+        "!": "Extension",
+        ",": "Image",
+        ";": "Terminator"
+    }
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "gif_file", "GIF picture file", stream, parent)
+        # Header
+        self.read("header", "File header", (FormatChunk, "string[6]"))
+        assert self["header"] in ("GIF87a", "GIF89a")
+        
+        screen = self.doRead("screen", "Screen descriptor", (ScreenDescriptor,))
+        if screen.flags["global_map"]:
+            self.read("color_map", "Color map", (ColorMap, 1 << screen.bits_per_pixel))
+            self.color_map = self["color_map"]
+        else:
+            self.color_map = None
+            
+        self.images = []
+        while True:
+            code = self.doRead("separator[]", "Separator code", (EnumChunk, "char", GifFile.separator_name)).value
+            if code == "!":
+                self.read("extensions[]", "Extension", (Extension,))
+            elif code == ",":
+                self.read("image[]", "Image", (Image,))
+                # TODO: Write Huffman parser code :-)
+                return
+            elif code == ";":
+                # GIF Terminator
+                return
+            else:
+                raise Exception("Wrong GIF image separator: ASCII %02X." % ord(code))
+                
+
+registerPlugin(GifFile, "image/gif")



From haypo at berlios.de  Tue Dec 27 20:40:23 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 20:40:23 +0100
Subject: [Happyboom-svn] r364 - in haypo/hachoir/trunk: broken_plugins plugins
Message-ID: <200512271940.jBRJeNHK000458@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 20:40:23 +0100 (Tue, 27 Dec 2005)
New Revision: 364

Added:
   haypo/hachoir/trunk/plugins/rpm.py
Removed:
   haypo/hachoir/trunk/broken_plugins/rpm.py
Log:
Upgrade RPM plugin to new syntax


Deleted: haypo/hachoir/trunk/broken_plugins/rpm.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/rpm.py	2005-12-27 19:18:05 UTC (rev 363)
+++ haypo/hachoir/trunk/broken_plugins/rpm.py	2005-12-27 19:40:23 UTC (rev 364)
@@ -1,261 +0,0 @@
-"""
-RPM archive parser.
-
-Author: Victor Stinner, 1st December 2005.
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-from format import getFormatSize
-from gzip import GzipFile
-
-class RpmItem(Filter):
-    format = {
-        #  (use FormatChunk? else use StringChunk, chunk format, count)
-        0: (True, "B", 1),
-        1: (True, "c", 1),
-        2: (True, "B", 1),
-        3: (True, "H", 1),
-        4: (True, "L", 1),
-        5: (True, "L", 2),
-        6: (False, "C", 1),
-        7: (True, "s", 1),
-        8: (True, "s", 1),
-        9: (False, "C", 1)
-    }
-    type_name = {
-        0: "NULL",
-        1: "CHAR",
-        2: "INT8",
-        3: "INT16",
-        4: "INT32",
-        5: "INT64",
-        6: "STRING",
-        7: "BIN",
-        8: "STRING_ARRAY",
-        9: "STRING?"
-    }
-    tag_name = {
-        1000: "File size",
-        1001: "(Broken) MD5 signature",
-        1002: "PGP 2.6.3 signature",
-        1003: "(Broken) MD5 signature",
-        1004: "MD5 signature",
-        1005: "GnuPG signature",
-        1006: "PGP5 signature",
-        1007: "Uncompressed payload size (bytes)",
-        256+8: "Broken SHA1 header digest",
-        256+9: "Broken SHA1 header digest",
-        256+13: "Broken SHA1 header digest",
-        256+11: "DSA header signature",
-        256+12: "RSA header signature"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rpm_item", "RPM item", stream, parent)
-        self.read("tag", "!L", "Tag")
-        self.read("type", "!L", "Type", post=self.postType)
-        self.read("offset", "!L", "Offset")
-        self.read("count", "!L", "Count")
-
-    def postType(self, chunk):
-        return self.getType(chunk.value)
-
-    def updateParent(self, chunk):
-        type = self.getType(self["type"])
-        tag = self.getTagName()
-        chunk.description = "RPM item: %s (%s)" % (tag, type)
-        
-    def getTagName(self):
-        tag = self["tag"]
-        return RpmItem.tag_name.get(tag, "Unknow tag (%s)" % tag)
-
-    def doRead(self, filter):
-        type = self["type"]
-        desc = "Value of item %s, %s" % (self.getId(), self.getDescription())
-        if type != 8:
-            format = RpmItem.format[type]
-            if format[0]:
-                if 2 < self["count"] and format[1] != "s":
-                    format = "!" + str(format[2] * self["count"] * getFormatSize(format[1])) + "s"
-                else:
-                    format = "!" + str(format[2] * self["count"]) + format[1]
-                filter.read("data[]", format, desc)
-            else:     
-                format = format[1]
-                filter.readString("data[]", format, desc)
-        else:
-            id = filter.getUniqChunkId("data[]")
-            for i in range(0, self["count"]):
-                filter.readString(id+"[]", "C", desc)
-    
-    def getType(self, type):
-        return RpmItem.type_name.get(type, "Unknow type (%s)" % type)
-
-class RpmHeaderItem(RpmItem):
-    tag_name = {
-        61: "Current image",
-        62: "Signatures",
-        63: "Immutable",
-        64: "Regions",
-        100: "I18N string locales",
-        1000: "Name",
-        1001: "Version",
-        1002: "Release",
-        1003: "Epoch",
-        1004: "Summary",
-        1005: "Description",
-        1006: "Build time",
-        1007: "Build host",
-        1008: "Install time",
-        1009: "Size",
-        1010: "Distribution",
-        1011: "Vendor",
-        1012: "Gif",
-        1013: "Xpm",
-        1014: "Licence",
-        1015: "Packager",
-        1016: "Group",
-        1017: "Changelog",
-        1018: "Source",
-        1019: "Patch",
-        1020: "Url",
-        1021: "OS",
-        1022: "Arch",
-        1023: "Prein",
-        1024: "Postin",
-        1025: "Preun",
-        1026: "Postun",
-        1027: "Old filenames",
-        1028: "File sizes",
-        1029: "File states",
-        1030: "File modes",
-        1031: "File uids",
-        1032: "File gids",
-        1033: "File rdevs",
-        1034: "File mtimes",
-        1035: "File MD5s",
-        1036: "File link to's",
-        1037: "File flags",
-        1038: "Root",
-        1039: "File username",
-        1040: "File groupname",
-        1043: "Icon",
-        1044: "Source rpm",
-        1045: "File verify flags",
-        1046: "Archive size",
-        1047: "Provide name",
-        1048: "Require flags",
-        1049: "Require name",
-        1050: "Require version",
-        1051: "No source",
-        1052: "No patch",
-        1053: "Conflict flags",
-        1054: "Conflict name",
-        1055: "Conflict version",
-        1056: "Default prefix",
-        1057: "Build root",
-        1058: "Install prefix",
-        1059: "Exclude arch",
-        1060: "Exclude OS",
-        1061: "Exclusive arch",
-        1062: "Exclusive OS",
-        1064: "RPM version",
-        1065: "Trigger scripts",
-        1066: "Trigger name",
-        1067: "Trigger version",
-        1068: "Trigger flags",
-        1069: "Trigger index",
-        1079: "Verify script",
-        #TODO: Finish the list (id 1070..1162 using rpm library source code)
-    }
-        
-    def getTagName(self):
-        tag = self["tag"]
-        return RpmHeaderItem.tag_name.get(tag, "Unknow tag (%s)" % tag)
-            
-def sortRpmItem(a,b):
-    return int( a["offset"] - b["offset"] )
-
-class Header(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "header", "Header", stream, parent)
-        id = self.read("id", "4s", "Identifier").value
-        assert id == "\x8E\xAD\xE8\x01"
-        self.read("padding", "4s", "Padding")
-        self.read("count", "!L", "Count")
-        self.read("size", "!L", "Store size")
-        items = []
-        for i in range(0, self["count"]):
-            item = self.readChild("item[]", RpmHeaderItem).getFilter()
-            items.append(item)
-        items.sort( sortRpmItem )
-
-        start = stream.tell()
-        end = stream.tell() + self["size"]
-        for item in items:
-            offset = item["offset"]
-            diff = offset - (stream.tell() - start)
-            if 0 < diff:
-                self.read("padding[]", "%us" % diff, "Padding")
-
-            print "Read %s" % item.getId()                
-            item.doRead(self)
-        size = end - stream.tell()
-        if 0 < size:    
-            self.read("padding[]", "%us" % size, "Padding")
-
-class RpmSignature(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rpm_sig", "RPM signature", stream, parent)
-        self.read("id", "!3B", "Identifier")
-        assert self["id"] == (142, 173, 232)
-        self.read("version", "!B", "Signature version")
-        self.read("reserved", "4s", "Reserved")
-        self.read("count", "!L", "Count")
-        self.read("size", "!L", "Size")
-        items = []
-        for i in range(0, self["count"]):
-            item = self.readChild("item[]", RpmItem).getFilter()
-            items.append(item)
-        items.sort( sortRpmItem )
-
-        start = stream.tell()
-        end = stream.tell() + self["size"]
-        for item in items:
-            offset = item["offset"]
-            diff = offset - (stream.tell() - start)
-            if 0 < diff:
-                self.read("padding[]", "%us" % diff, "Padding")
-            item.doRead(self)
-        size = end - stream.tell()
-        if 0 < size:    
-            self.read("padding[]", "%us" % size, "Padding")
-
-class RpmFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rpm_file", "RPM File", stream, parent)
-        self.read("id", "!4B", "Identifier")
-        assert self["id"] == (237, 171, 238, 219)
-        self.read("major_ver", "!B", "Major version")
-        self.read("minor_ver", "!B", "Minor version")
-        self.read("type", "!H", "RPM type", post=self.postType)
-        self.read("architecture", "!H", "Architecture")
-        self.read("name", "!66s", "Archive name")
-        self.read("osnum", "!H", "OS")
-        self.read("signature_type", "!H", "Type of signature")
-        self.read("reserved", "16s", "Reserved")
-        self.readChild("signature", RpmSignature)
-        self.readChild("header", Header)
-        sub = stream.createSub()
-        self.readStreamChild("gz_content", sub, GzipFile)
-
-    def postType(self, chunk):
-        if chunk.value == 0:
-            return "Binary"
-        elif chunk.value == 1:
-            return "Source"
-        else:
-            return "Unknown (%s)" % chunk.value
-
-registerPlugin(RpmFile, "application/x-rpm")

Copied: haypo/hachoir/trunk/plugins/rpm.py (from rev 351, haypo/hachoir/trunk/broken_plugins/rpm.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/rpm.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/rpm.py	2005-12-27 19:40:23 UTC (rev 364)
@@ -0,0 +1,252 @@
+"""
+RPM archive parser.
+
+Author: Victor Stinner, 1st December 2005.
+"""
+
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk, StringChunk
+from format import getFormatSize
+from gzip import GzipFile
+
+class Item(OnDemandFilter):
+    format = {
+        #  (use FormatChunk? else use StringChunk, chunk format, count)
+        0: (True, "uint8", 1),
+        1: (True, "char", 1),
+        2: (True, "uint8", 1),
+        3: (True, "uint16", 1),
+        4: (True, "uint32", 1),
+        5: (True, "uint32", 2),
+        6: (False, "C", 1),
+        7: (True, "string", 1),
+        8: (True, "strin", 1),
+        9: (False, "C", 1)
+    }
+    type_name = {
+        0: "NULL",
+        1: "CHAR",
+        2: "INT8",
+        3: "INT16",
+        4: "INT32",
+        5: "INT64",
+        6: "STRING",
+        7: "BIN",
+        8: "STRING_ARRAY",
+        9: "STRING?"
+    }
+    tag_name = {
+        1000: "File size",
+        1001: "(Broken) MD5 signature",
+        1002: "PGP 2.6.3 signature",
+        1003: "(Broken) MD5 signature",
+        1004: "MD5 signature",
+        1005: "GnuPG signature",
+        1006: "PGP5 signature",
+        1007: "Uncompressed payload size (bytes)",
+        256+8: "Broken SHA1 header digest",
+        256+9: "Broken SHA1 header digest",
+        256+13: "Broken SHA1 header digest",
+        256+11: "DSA header signature",
+        256+12: "RSA header signature"
+    }
+    
+    def __init__(self, stream, parent, tag_name_dict=None):
+        OnDemandFilter.__init__(self, "rpm_item", "RPM item", stream, parent, "!")
+        if tag_name_dict == None:
+            self.tag_name_dict = Item.tag_name
+        else:
+            self.tag_name_dict = tag_name_dict 
+        self.read("tag", "Tag", (EnumChunk, "uint32", self.tag_name_dict))
+        self.read("type", "Type", (EnumChunk, "uint32", Item.type_name))
+        self.read("offset", "Offset", (FormatChunk, "uint32"))
+        self.read("count", "Count", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        type = self.getChunk("type").getDisplayData()
+        tag = self.getChunk("tag").getDisplayData()
+        chunk.description = "Item: %s (%s)" % (tag, type)
+        
+    def doRead(self, filter):
+        type = self["type"]
+        if type != 8:
+            desc = "Value of %s: %s" % (self.getId(), self.getDescription())
+            format = Item.format[type]
+            if format[0]:
+                if 2 < self["count"] and format[1] != "string":
+                    format = "string[%u]" % (format[2] * self["count"] * getFormatSize(format[1]))
+                else:
+                    format = "%s[%u]" % (format[1], format[2] * self["count"])
+                filter.read("data[]", desc, (FormatChunk, format))
+            else:     
+                format = format[1]
+                filter.read("data[]", desc, (StringChunk, format))
+        else:
+            id = filter.getUniqChunkId("data[]")
+            for i in range(0, self["count"]):
+                desc = "Value %u of %s: %s" % (i, self.getId(), self.getDescription())
+                filter.read(id+"[]", desc, (StringChunk, "C"))
+
+class ItemHeader(Item):
+    tag_name = {
+        61: "Current image",
+        62: "Signatures",
+        63: "Immutable",
+        64: "Regions",
+        100: "I18N string locales",
+        1000: "Name",
+        1001: "Version",
+        1002: "Release",
+        1003: "Epoch",
+        1004: "Summary",
+        1005: "Description",
+        1006: "Build time",
+        1007: "Build host",
+        1008: "Install time",
+        1009: "Size",
+        1010: "Distribution",
+        1011: "Vendor",
+        1012: "Gif",
+        1013: "Xpm",
+        1014: "Licence",
+        1015: "Packager",
+        1016: "Group",
+        1017: "Changelog",
+        1018: "Source",
+        1019: "Patch",
+        1020: "Url",
+        1021: "OS",
+        1022: "Arch",
+        1023: "Prein",
+        1024: "Postin",
+        1025: "Preun",
+        1026: "Postun",
+        1027: "Old filenames",
+        1028: "File sizes",
+        1029: "File states",
+        1030: "File modes",
+        1031: "File uids",
+        1032: "File gids",
+        1033: "File rdevs",
+        1034: "File mtimes",
+        1035: "File MD5s",
+        1036: "File link to's",
+        1037: "File flags",
+        1038: "Root",
+        1039: "File username",
+        1040: "File groupname",
+        1043: "Icon",
+        1044: "Source rpm",
+        1045: "File verify flags",
+        1046: "Archive size",
+        1047: "Provide name",
+        1048: "Require flags",
+        1049: "Require name",
+        1050: "Require version",
+        1051: "No source",
+        1052: "No patch",
+        1053: "Conflict flags",
+        1054: "Conflict name",
+        1055: "Conflict version",
+        1056: "Default prefix",
+        1057: "Build root",
+        1058: "Install prefix",
+        1059: "Exclude arch",
+        1060: "Exclude OS",
+        1061: "Exclusive arch",
+        1062: "Exclusive OS",
+        1064: "RPM version",
+        1065: "Trigger scripts",
+        1066: "Trigger name",
+        1067: "Trigger version",
+        1068: "Trigger flags",
+        1069: "Trigger index",
+        1079: "Verify script",
+        #TODO: Finish the list (id 1070..1162 using rpm library source code)
+    }
+
+    def __init__(self, stream, parent):
+        Item.__init__(self, stream, parent, ItemHeader.tag_name)
+            
+def sortRpmItem(a,b):
+    return int( a["offset"] - b["offset"] )
+
+class Header(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "header", "Header", stream, parent, "!")
+        self.read("id", "Identifier", (FormatChunk, "string[4]"))
+        assert self["id"] == "\x8E\xAD\xE8\x01"
+        self.read("padding", "Padding", (FormatChunk, "string[4]"))
+        self.read("count", "Count", (FormatChunk, "uint32"))
+        self.read("size", "Store size", (FormatChunk, "uint32"))
+        items = []
+        for i in range(0, self["count"]):
+            item = self.doRead("item[]", "Item", (ItemHeader,))
+            items.append(item)
+        items.sort( sortRpmItem )
+
+        start = stream.tell()
+        end = stream.tell() + self["size"]
+        for item in items:
+            offset = item["offset"]
+            diff = offset - (stream.tell() - start)
+            if 0 < diff:
+                self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % diff))
+
+            print "Read %s" % item.getId()                
+            item.doRead(self)
+        size = end - stream.tell()
+        if 0 < size:    
+            self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % size))
+
+class Signature(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "rpm_sig", "Signature", stream, parent, "!")
+        self.read("id", "Identifier", (FormatChunk, "uint8[3]"))
+        assert self["id"] == (142, 173, 232)
+        self.read("version", "Signature version", (FormatChunk, "uint8"))
+        self.read("reserved", "Reserved", (FormatChunk, "string[4]"))
+        self.read("count", "Count", (FormatChunk, "uint32"))
+        self.read("size", "Size", (FormatChunk, "uint32"))
+        items = []
+        for i in range(0, self["count"]):
+            item = self.doRead("item[]", "Item", (Item,))
+            items.append(item)
+        items.sort( sortRpmItem )
+
+        start = stream.tell()
+        end = stream.tell() + self["size"]
+        for item in items:
+            offset = item["offset"]
+            diff = offset - (stream.tell() - start)
+            if 0 < diff:
+                self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % diff))
+            item.doRead(self)
+        size = end - stream.tell()
+        if 0 < size:    
+            self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % size))
+
+class RpmFile(OnDemandFilter):
+    rpm_type_name = {
+        0: "Binary",
+        1: "Source"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "rpm_file", "RPM File", stream, parent, "!")
+        self.read("id", "Identifier", (FormatChunk, "uint8[4]"))
+        assert self["id"] == (237, 171, 238, 219)
+        self.read("major_ver", "Major version", (FormatChunk, "uint8"))
+        self.read("minor_ver", "Minor version", (FormatChunk, "uint8"))
+        self.read("type", "RPM type", (EnumChunk, "uint16", RpmFile.rpm_type_name))
+        self.read("architecture", "Architecture", (FormatChunk, "uint16"))
+        self.read("name", "Archive name", (FormatChunk, "string[66]"))
+        self.read("osnum", "OS", (FormatChunk, "uint16"))
+        self.read("signature_type", "Type of signature", (FormatChunk, "uint16"))
+        self.read("reserved", "Reserved", (FormatChunk, "string[16]"))
+        self.read("signature", "Signature", (Signature,))
+        self.read("header", "Header", (Header,))
+        sub = stream.createSub()
+        self.read("gz_content", "Gziped content", (GzipFile,), {"stream": sub})
+
+registerPlugin(RpmFile, "application/x-rpm")



From haypo at berlios.de  Tue Dec 27 21:15:51 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 21:15:51 +0100
Subject: [Happyboom-svn] r365 - in haypo/hachoir/trunk: . broken_plugins plugins
Message-ID: <200512272015.jBRKFpDB005188@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 21:15:51 +0100 (Tue, 27 Dec 2005)
New Revision: 365

Added:
   haypo/hachoir/trunk/plugins/worms2.py
Removed:
   haypo/hachoir/trunk/broken_plugins/worms2.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/format.py
Log:
Upgrade Worms2 plugin to new syntax


Deleted: haypo/hachoir/trunk/broken_plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/worms2.py	2005-12-27 19:40:23 UTC (rev 364)
+++ haypo/hachoir/trunk/broken_plugins/worms2.py	2005-12-27 20:15:51 UTC (rev 365)
@@ -1,83 +0,0 @@
-"""
-Worms2 DIR file.
-"""
-
-from plugin import registerPlugin 
-from filter import Filter
-from plugin import registerPlugin
-from tools import humanFilesize
-
-class Worms2_Image(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_image", "Worms2 image", stream, parent)
-        nb_color = 244/3
-        self.read("palette", "%us" % (nb_color*3), "Palette (%u colors)" % nb_color)
-        self.read("padding", "B", "Padding")
-        self.read("width", "<H", "Width")
-        self.read("height", "<H", "Height")
-        size = self["width"] * self["height"]
-        self.read("img_data", "%us" % size, "Data")
-        size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "Raw end")
-
-class Worms2_Sprite(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
-        # TODO ...
-        size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "Raw end")
-
-class Worms2_Font(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
-        self.read("palette", "%us" % (244+33), "Palette (?)")
-        self.read("charset", "%us" % (32), "Charset")
-        self.read("data", "%us" % (32+30+4+136), "Data")
-        # TODO ...
-        size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "Raw end")
-
-class Worms2_Resource(Filter):
-    handler = {
-        "IMG": Worms2_Image,
-        "SPR": Worms2_Sprite,
-        "FNT": Worms2_Font
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_res", "Worms2 resource", stream, parent)
-        pos = stream.tell()
-        self.tag = self.read("tag", "3s", "Type").value.strip("\0\n")
-        self.valid = self.tag.strip("\0\n") != ""
-        self.read("tag_end", "1s", "Type end")
-        size = self.read("size", "<L", "Size").value
-        if not self.valid:
-            return
-        self.readString("name", "C", "Name")
-        size = pos + size + 1 - stream.tell()
-        if self.tag in Worms2_Resource.handler:
-            sub = stream.createSub(size=size)
-            self.readStreamChild("data", sub, Worms2_Resource.handler[self.tag])
-        else:
-            self.read("data", "%us" % size, "Data")
-
-    def updateParent(self, chunk):            
-        size = humanFilesize(self["size"])
-        tag = self.tag
-        if tag != "":
-            name = self["name"]
-        else:
-            tag = "(invalid)"
-            name = "(invalid)"
-        chunk.description = "Resource \"%s\" (type=%s, size=%s)" % (name, tag, size)
-
-class Worms2_Dir_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent)
-        self.read("id", "3s", "Identifier (DIR)")
-        self.read("raw", "%us" % (12-stream.tell()), "Raw data")
-        while stream.tell() < 3432805:
-            file = self.readChild("file[]", Worms2_Resource).getFilter()
-            if not file.valid:
-                break
-         
-registerPlugin(Worms2_Dir_File, "hachoir/worms2")

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-27 19:40:23 UTC (rev 364)
+++ haypo/hachoir/trunk/chunk.py	2005-12-27 20:15:51 UTC (rev 365)
@@ -1,6 +1,6 @@
 import struct, re, types
 import config
-from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsArray, formatIsInteger
+from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsArray, formatIsInteger, formatIsArray
 from error import warning, error
 from tools import convertDataToPrintableString
 
@@ -264,10 +264,7 @@
         self._format = format
         self._real_format = getRealFormat(format)
         self._is_string = formatIsString(self._format)
-        if not self._is_string:
-            self._is_array = (1 < splited[1])
-        else:
-            self._is_array = False 
+        self._is_array = formatIsArray(format)
         self._size = getFormatSize(self._format)
         self._value = {}
        

Modified: haypo/hachoir/trunk/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2005-12-27 19:40:23 UTC (rev 364)
+++ haypo/hachoir/trunk/format.py	2005-12-27 20:15:51 UTC (rev 365)
@@ -102,4 +102,4 @@
 
 def formatIsArray(format):
     cache = FormatCache.getInstance()[format]
-    return 1 < cache[2]   
+    return (1 < cache[2]) and (cache[3] != "s")

Copied: haypo/hachoir/trunk/plugins/worms2.py (from rev 351, haypo/hachoir/trunk/broken_plugins/worms2.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/worms2.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-27 20:15:51 UTC (rev 365)
@@ -0,0 +1,97 @@
+"""
+Worms2 DIR file parser.
+Parser based on Laurent DEFERT SIMONNEAU work.
+
+Author: Victor Stinner
+"""
+
+from plugin import registerPlugin 
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from tools import humanFilesize
+from chunk import FormatChunk, StringChunk, EnumChunk
+
+class Worms2_Image(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "worms2_image", "Worms2 image", stream, parent, "<")
+        nb_color = 244/3
+        self.read("palette", "Palette (%u colors)" % nb_color, (FormatChunk, "string[%u]" % (nb_color*3)))
+        self.read("padding", "Padding", (FormatChunk, "uint8"))
+        self.read("width", "Width", (FormatChunk, "uint16"))
+        self.read("height", "Height", (FormatChunk, "uint16"))
+        size = self["width"] * self["height"]
+        self.read("img_data", "Data", (FormatChunk, "string[%u]" % size))
+        size = stream.getSize() - stream.tell()
+        self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+
+class Worms2_Sprite(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
+        # TODO ...
+        size = stream.getSize() - stream.tell()
+        self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+
+class Worms2_Font(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
+        self.read("palette", "Palette (?)", (FormatChunk, "string[%u]" % (244+33)))
+        self.read("charset", "Charset", (FormatChunk, "string[%u]" % (32)))
+        self.read("data", "Data", (FormatChunk, "string[%u]" % (32+30+4+136)))
+        # TODO ...
+        size = stream.getSize() - stream.tell()
+        self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+
+class Resource(OnDemandFilter):
+    name = {
+        "IMG": "Image",
+        "SPR": "Sprite",
+        "FNT": "Font",
+        "DIR": "Directory"
+    }
+
+    handler = {
+        "IMG": Worms2_Image,
+        "SPR": Worms2_Sprite,
+        "FNT": Worms2_Font
+    }
+
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "worms2_res", "Worms2 resource", stream, parent, "<")
+        pos = stream.tell()
+        self.tag = self.doRead("tag", "Type", (EnumChunk, "string[3]", Resource.name)).value
+        self.read("tag_end", "Type end", (FormatChunk, "string[1]"))
+        size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
+        if self.tag != "DIR":
+            self.name = self.doRead("name", "Name", (StringChunk, "C")).value
+            
+            size = pos + size + 1 - stream.tell()
+            if self.tag in Resource.handler:
+                sub = stream.createSub(size=size)
+                self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})
+            else:
+                self.read("data", "Data", (FormatChunk, "string[%u]" % size))
+        else:
+            self.name = "(directory)"
+            end = self.doRead("last_pos", "Last position", (FormatChunk, "uint32")).value
+            while stream.tell() < end:
+                self.read("res[]", "Resource", (Resource,))
+
+#    def getStaticSize(stream, args):
+#        oldpos = stream.tell()
+#        stream.seek(4, 1)
+#        size = 1 + stream.getFormat("<uint32")
+#        stream.seek(oldpos)
+#        return size
+#    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):            
+        size = humanFilesize(self["size"])
+        tag = self.getChunk("tag").getDisplayData()
+        chunk.description = tag+": %s (size=%s)" % (self.name, size)
+
+class Worms2_Dir_File(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent, "<")
+        self.read("res[]", "Resource", (Resource,))
+         
+registerPlugin(Worms2_Dir_File, "hachoir/worms2")



From haypo at berlios.de  Tue Dec 27 23:17:37 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 27 Dec 2005 23:17:37 +0100
Subject: [Happyboom-svn] r366 - in haypo/hachoir/trunk: . plugins
Message-ID: <200512272217.jBRMHbwC019273@sheep.berlios.de>

Author: haypo
Date: 2005-12-27 23:17:37 +0100 (Tue, 27 Dec 2005)
New Revision: 366

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Fix static size of Worms2 resource item.


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2005-12-27 20:15:51 UTC (rev 365)
+++ haypo/hachoir/trunk/filter.py	2005-12-27 22:17:37 UTC (rev 366)
@@ -160,8 +160,6 @@
             args = info[1:]
             if size == None:
                 size = chunk_class.getStaticSize(self._stream, info[1:])
-#                if size != None:
-#                    optionnal["size"] = size
             if size == None:
                 filter = chunk_class(filter_stream, self, *args)
                 description = filter.getDescription()

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-27 20:15:51 UTC (rev 365)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-27 22:17:37 UTC (rev 366)
@@ -76,13 +76,17 @@
             while stream.tell() < end:
                 self.read("res[]", "Resource", (Resource,))
 
-#    def getStaticSize(stream, args):
-#        oldpos = stream.tell()
-#        stream.seek(4, 1)
-#        size = 1 + stream.getFormat("<uint32")
-#        stream.seek(oldpos)
-#        return size
-#    getStaticSize = staticmethod(getStaticSize)
+    def getStaticSize(stream, args):
+        oldpos = stream.tell()
+        if stream.getFormat("string[3]", False) != "DIR":
+            stream.seek(4, 1)
+            size = 1 + stream.getFormat("<uint32")
+        else:
+            stream.seek(8, 1)
+            size = stream.getFormat("<uint32")
+        stream.seek(oldpos)
+        return size
+    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):            
         size = humanFilesize(self["size"])
@@ -92,6 +96,6 @@
 class Worms2_Dir_File(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent, "<")
-        self.read("res[]", "Resource", (Resource,))
+        self.read("resources", "Directory of resources", (Resource,))
          
 registerPlugin(Worms2_Dir_File, "hachoir/worms2")



From haypo at berlios.de  Wed Dec 28 00:14:01 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 00:14:01 +0100
Subject: [Happyboom-svn] r367 - in haypo/hachoir/trunk: . generic plugins
Message-ID: <200512272314.jBRNE1bM026396@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 00:14:00 +0100 (Wed, 28 Dec 2005)
New Revision: 367

Modified:
   haypo/hachoir/trunk/generic/image.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/plugins/gif.py
   haypo/hachoir/trunk/plugins/pcx.py
   haypo/hachoir/trunk/plugins/worms2.py
Log:
- Write font parser for Worms2 plugin
- Use common RGB Palette parser for Worms2, PCX and GIF plugins


Modified: haypo/hachoir/trunk/generic/image.py
===================================================================
--- haypo/hachoir/trunk/generic/image.py	2005-12-27 22:17:37 UTC (rev 366)
+++ haypo/hachoir/trunk/generic/image.py	2005-12-27 23:14:00 UTC (rev 367)
@@ -22,3 +22,9 @@
             chunk.description = "RGB color: "+RGB.name[value]
         else:
             chunk.description = "RGB color: #%02X%02X%02X" % (self["red"], self["green"], self["blue"])
+
+class Palette(OnDemandFilter):
+    def __init__(self, stream, parent, count):
+        OnDemandFilter.__init__(self, "palette", "Palette of %u RGB colors" % count, stream, parent)
+        for i in range(0, count):
+            self.read("color[]", "Color", (RGB,))

Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2005-12-27 22:17:37 UTC (rev 366)
+++ haypo/hachoir/trunk/hachoir.py	2005-12-27 23:14:00 UTC (rev 367)
@@ -110,7 +110,8 @@
 
 Gentoo: emerge pytgtk
 Debian: apt-get install python2.4-gtk python2.4-magic
-Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
+Ubuntu: apt-get install python-gtk2 python-glade2
+Mandriva: urpmi pygtk2.0-libglade-2.6.2-1mdk (or pygtk2.0-libglade?)""" % (err))
                 sys.exit(1)
         if opt["use_profiler"]:
             import profile, pstats

Modified: haypo/hachoir/trunk/plugins/gif.py
===================================================================
--- haypo/hachoir/trunk/plugins/gif.py	2005-12-27 22:17:37 UTC (rev 366)
+++ haypo/hachoir/trunk/plugins/gif.py	2005-12-27 23:14:00 UTC (rev 367)
@@ -8,7 +8,7 @@
 from plugin import registerPlugin
 from chunk import FormatChunk, EnumChunk, BitsChunk, BitsStruct
 from error import warning
-from generic.image import RGB
+from generic.image import Palette
 
 class Image(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -28,7 +28,7 @@
 
         return
         if not self.flags["local_color"]:
-            self.read("local_map", "Local color map", (ColorMap, 1 << self.flags["size_local"]))
+            self.read("local_map", "Local color map", (Palette, 1 << self.flags["size_local"]))
             self.local_map = self["local_map"]
         else:
             self.local_map = None
@@ -37,12 +37,6 @@
         chunk.description = "Image: %ux%u pixels at (%u,%u)" \
             % (self["width"], self["height"], self["left"], self["top"])
 
-class ColorMap(OnDemandFilter):
-    def __init__(self, stream, parent, nb_colors):
-        OnDemandFilter.__init__(self, "gif_colormap", "Color map: %u colors" % nb_colors, stream, parent)
-        for i in range(0, nb_colors):
-            self.read("color[]", "Color", (RGB,))
-
 class ExtensionChunk(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "gif_ext_data", "GIF extension data", stream, parent)
@@ -96,7 +90,7 @@
         
         screen = self.doRead("screen", "Screen descriptor", (ScreenDescriptor,))
         if screen.flags["global_map"]:
-            self.read("color_map", "Color map", (ColorMap, 1 << screen.bits_per_pixel))
+            self.read("color_map", "Color map", (Palette, 1 << screen.bits_per_pixel))
             self.color_map = self["color_map"]
         else:
             self.color_map = None

Modified: haypo/hachoir/trunk/plugins/pcx.py
===================================================================
--- haypo/hachoir/trunk/plugins/pcx.py	2005-12-27 22:17:37 UTC (rev 366)
+++ haypo/hachoir/trunk/plugins/pcx.py	2005-12-27 23:14:00 UTC (rev 367)
@@ -7,14 +7,8 @@
 from chunk import FormatChunk, EnumChunk
 from stream.file import FileStream
 from cStringIO import StringIO
-from generic.image import RGB
+from generic.image import RGB, Palette
 
-class Palette(OnDemandFilter):
-    def __init__(self, stream, parent, count):
-        OnDemandFilter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
-        for i in range(0, count):
-            self.read("color[]", "Color", (RGB,))
-
 def StreamDeflateRLE(filter, stream, size):
     start = stream.tell()
     end = start + size - 1

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-27 22:17:37 UTC (rev 366)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-27 23:14:00 UTC (rev 367)
@@ -10,12 +10,12 @@
 from plugin import registerPlugin
 from tools import humanFilesize
 from chunk import FormatChunk, StringChunk, EnumChunk
+from generic.image import Palette
 
-class Worms2_Image(OnDemandFilter):
+class Image(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "worms2_image", "Worms2 image", stream, parent, "<")
-        nb_color = 244/3
-        self.read("palette", "Palette (%u colors)" % nb_color, (FormatChunk, "string[%u]" % (nb_color*3)))
+        self.read("palette", "Palette", (Palette, 81))
         self.read("padding", "Padding", (FormatChunk, "uint8"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
@@ -24,20 +24,28 @@
         size = stream.getSize() - stream.tell()
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
-class Worms2_Sprite(OnDemandFilter):
+class Sprite(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
+        self.read("palette", "Palette", (Palette, 81))
         # TODO ...
         size = stream.getSize() - stream.tell()
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
-class Worms2_Font(OnDemandFilter):
+class Font(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
-        self.read("palette", "Palette (?)", (FormatChunk, "string[%u]" % (244+33)))
-        self.read("charset", "Charset", (FormatChunk, "string[%u]" % (32)))
-        self.read("data", "Data", (FormatChunk, "string[%u]" % (32+30+4+136)))
-        # TODO ...
+        OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent, "<")
+        self.read("palette", "Palette", (Palette, 81))
+        self.read("header", "Header !?", (FormatChunk, "string[%u]" % 0x105))
+
+#        while not stream.eof():
+        while 2*4 < (stream.getSize() - stream.tell()):
+            ofst_x = self.doRead("offset[]", "Offset X", (FormatChunk, "uint16")).value
+            ofst_y = self.doRead("offset[]", "Offset Y", (FormatChunk, "uint16")).value
+            width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
+            height = self.doRead("size[]", "Height", (FormatChunk, "uint16")).value
+            size = (width-ofst_x) * (height-ofst_y)
+            self.read("data[]", "Font content", (FormatChunk, "string[%u]" % size))
         size = stream.getSize() - stream.tell()
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
@@ -50,9 +58,9 @@
     }
 
     handler = {
-        "IMG": Worms2_Image,
-        "SPR": Worms2_Sprite,
-        "FNT": Worms2_Font
+        "IMG": Image,
+        "SPR": Sprite,
+        "FNT": Font
     }
 
     def __init__(self, stream, parent):



From haypo at berlios.de  Wed Dec 28 02:51:52 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 02:51:52 +0100
Subject: [Happyboom-svn] r368 - in haypo/hachoir/trunk: . plugins
Message-ID: <200512280151.jBS1pqDf026024@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 02:51:31 +0100 (Wed, 28 Dec 2005)
New Revision: 368

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/text_handler.py
   haypo/hachoir/trunk/tools.py
Log:
Some fix in Worms2 plugin ...


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-27 23:14:00 UTC (rev 367)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-28 01:51:31 UTC (rev 368)
@@ -9,46 +9,133 @@
 from filter import OnDemandFilter
 from plugin import registerPlugin
 from tools import humanFilesize
-from chunk import FormatChunk, StringChunk, EnumChunk
+from chunk import FormatChunk, StringChunk, EnumChunk, BitsChunk, BitsStruct
 from generic.image import Palette
 
+# Only for debug purpose
+from text_handler import binary, str2hex, str2bin
+
+class ImageData(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "image_data", "Image data (uncompressed)", stream, parent, "<")
+        self.x = self.doRead("x", "Offset X", (FormatChunk, "uint16")).value
+        self.y = self.doRead("y", "Offset Y", (FormatChunk, "uint16")).value
+        self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
+        self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
+        size = (self.width-self.x) * (self.height-self.y)
+        self.read("data", "Font content", (FormatChunk, "string[%u]" % size))
+
+    def updateParent(self, chunk):
+        chunk.description = "Image data: %ux%u pixels at (%u,%u)" \
+            % (self.width, self.height, self.x, self.y)
+
 class Image(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "worms2_image", "Worms2 image", stream, parent, "<")
+        OnDemandFilter.__init__(self, "image", "Image", stream, parent, "<")
         self.read("palette", "Palette", (Palette, 81))
         self.read("padding", "Padding", (FormatChunk, "uint8"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
         size = self["width"] * self["height"]
         self.read("img_data", "Data", (FormatChunk, "string[%u]" % size))
-        size = stream.getSize() - stream.tell()
+        size = stream.getLastPos() - stream.tell()
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
+    def updateParent(self, chunk):            
+        chunk.description = "Image: %ux%u pixels" % \
+            (self["width"], self["height"])
+
 class Sprite(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
+        OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
+        name = parent.name
         self.read("palette", "Palette", (Palette, 81))
-        # TODO ...
-        size = stream.getSize() - stream.tell()
+        if True:
+            self.read("header116", "Header 116", (FormatChunk, "uint8"))
+            assert self["header116"] == 116 
+            self.read("a", "???", (FormatChunk, "uint8"))
+            self.read("zero", "Zeros", (FormatChunk, "string[9]"))
+            assert self["zero"] == ("\0" * 9)
+            if False:
+                bits = (
+                    (1, "info1", ""),
+                    (1, "various1", ""),
+                    (1, "info2", ""),
+                    (3, "various2", ""),
+                    (3, "zero", ""),
+                    (3, "various3", ""),
+                    (1, "info3", ""),
+                    (1, "one", ""),
+                    (2, "various4", "")
+                )
+                flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+                assert flags["zero"] == 0
+                assert flags["one"] == True
+            else:
+                self.read("flags", "???", (FormatChunk, "uint16"), {"post": binary})
+            self.read("zero2", "Zero2", (FormatChunk, "uint16"))
+            assert self["zero2"] == 0
+            import re
+            if re.match("^Tv", name) != None:
+                size = 2
+            elif re.match("^Holy", name) != None:
+                size = 26
+            elif re.match("^Banana", name) != None:
+                size = 29-15+2
+            elif re.match("^Homing", name) != None:
+                size = 29-15+3+8-1+2
+            elif re.match("^Marker", name) != None:
+                size = 29+2-15 
+            else:
+                size = 29-15
+            self.read("end_of_header", "End of mysterious header", (FormatChunk, "string[%u]" % size))
+            self.x = self.doRead("offset_x[]", "Offset X", (FormatChunk, "uint16")).value
+            self.y = self.doRead("offset_y[]", "Offset Y", (FormatChunk, "uint16")).value
+            self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
+            self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
+
+            #print "Sprite % 20s: x=%s, header=% 2s, header=%s | %s" \
+            #    % (name, x, size, str2bin(self["end_of_header"][:2]), str2hex(self["end_of_header"]))
+            #print "Sprite % 20s: a=%s, header=% 2s, header=%s" \
+            #    % (name, self["a"], size, str2hex(self["end_of_header"]))
+
+#            print "Sprite % 20s, a=%s, header=% 2s, flags=%s (%s), size=%ux%u at (%u,%u)" \
+#                % (name, self["a"], size, str2bin(self.getChunk("flags").getRaw()), self["flags"], width, height, x, y)
+
+        else:                
+            self.read("data", "Data", (FormatChunk, "string[40]"))
+            print "Sprite % 20s: %s" \
+                % (name, str2hex(self["data"]))
+            
+        size = stream.getLastPos() - stream.tell()
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
+    def updateParent(self, chunk):            
+        chunk.description = "Sprite: %ux%u pixels" % \
+            (self.width, self.height)
+
 class Font(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent, "<")
+        OnDemandFilter.__init__(self, "font", "Font", stream, parent, "<")
         self.read("palette", "Palette", (Palette, 81))
         self.read("header", "Header !?", (FormatChunk, "string[%u]" % 0x105))
 
 #        while not stream.eof():
-        while 2*4 < (stream.getSize() - stream.tell()):
-            ofst_x = self.doRead("offset[]", "Offset X", (FormatChunk, "uint16")).value
-            ofst_y = self.doRead("offset[]", "Offset Y", (FormatChunk, "uint16")).value
-            width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
-            height = self.doRead("size[]", "Height", (FormatChunk, "uint16")).value
-            size = (width-ofst_x) * (height-ofst_y)
-            self.read("data[]", "Font content", (FormatChunk, "string[%u]" % size))
-        size = stream.getSize() - stream.tell()
+        self.nb_characters = 0
+        while 2*4 < (stream.getLastPos() - stream.tell()):
+            id = self.read("image[]", "Image", (ImageData,))
+            if self.nb_characters == 0:
+                image = self[id]
+                self.width = image.width
+                self.height = image.height
+            self.nb_characters += 1
+        size = stream.getLastPos() - stream.tell()
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
+    def updateParent(self, chunk):
+        chunk.description = "Font: %ux%u pixels, %u characters" \
+            % (self.width, self.height, self.nb_characters)
+
 class Resource(OnDemandFilter):
     name = {
         "IMG": "Image",
@@ -74,7 +161,7 @@
             
             size = pos + size + 1 - stream.tell()
             if self.tag in Resource.handler:
-                sub = stream.createSub(size=size)
+                sub = stream.createLimited(size=size)
                 self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})
             else:
                 self.read("data", "Data", (FormatChunk, "string[%u]" % size))
@@ -97,9 +184,12 @@
     getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):            
-        size = humanFilesize(self["size"])
-        tag = self.getChunk("tag").getDisplayData()
-        chunk.description = tag+": %s (size=%s)" % (self.name, size)
+        if self["tag"] != "DIR":
+            chunk.description = "[%s] %s" % (self.name, self["data"].getDescription())
+        else:
+            tag = self.getChunk("tag").getDisplayData()
+            size = humanFilesize(self["size"])
+            chunk.description = tag+": %s (size=%s)" % (self.name, size)
 
 class Worms2_Dir_File(OnDemandFilter):
     def __init__(self, stream, parent):

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-27 23:14:00 UTC (rev 367)
+++ haypo/hachoir/trunk/text_handler.py	2005-12-28 01:51:31 UTC (rev 368)
@@ -1,5 +1,5 @@
 import datetime
-from tools import humanFilesize as doHumanFilesize
+from tools import humanFilesize as doHumanFilesize, str2bin
 
 def msdosDatetime(chunk):
     assert chunk.size == 4
@@ -19,6 +19,9 @@
     timestamp = datetime.datetime.fromtimestamp(chunk.value)
     return str(timestamp) 
 
+def binary(chunk):
+    return str2bin(chunk.getRaw()) + " (%s)" % chunk.value
+
 def hexadecimal(chunk):
     size = chunk.size
     assert size in (2, 4, 8)

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-27 23:14:00 UTC (rev 367)
+++ haypo/hachoir/trunk/tools.py	2005-12-28 01:51:31 UTC (rev 368)
@@ -1,5 +1,31 @@
 import traceback, sys, string, re
 
+def byte2bin(x):
+    text = ""
+    for i in range(0,8):
+        mask = 1 << (7-i)
+        if (x & mask) == mask:
+            text += "1"
+        else:
+            text += "0"
+    return text            
+
+def str2bin(value):
+    text = ""
+    for character in value:
+        if text != "":
+            text += " "
+        text += byte2bin(ord(character))
+    return text
+
+def str2hex(value):
+    text = "(hex) "
+    for character in value:
+        if text != "":
+            text += " "
+        text += "%02X" % ord(character)
+    return text
+
 def _regexMaxLength(pattern, in_parenthesis=False):
     """
     Don't use this function directly, use regexMagLength!



From haypo at berlios.de  Wed Dec 28 02:58:30 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 02:58:30 +0100
Subject: [Happyboom-svn] r369 - haypo/hachoir/trunk/plugins
Message-ID: <200512280158.jBS1wUZf028460@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 02:57:51 +0100 (Wed, 28 Dec 2005)
New Revision: 369

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Damned! Fix last commit.


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-28 01:51:31 UTC (rev 368)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-28 01:57:51 UTC (rev 369)
@@ -13,7 +13,8 @@
 from generic.image import Palette
 
 # Only for debug purpose
-from text_handler import binary, str2hex, str2bin
+from text_handler import binary
+from tools import str2hex, str2bin
 
 class ImageData(OnDemandFilter):
     def __init__(self, stream, parent):



From haypo at berlios.de  Wed Dec 28 05:12:29 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 05:12:29 +0100
Subject: [Happyboom-svn] r370 - in haypo/hachoir/trunk: . broken_plugins plugins stream
Message-ID: <200512280412.jBS4CT3A019546@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 05:12:28 +0100 (Wed, 28 Dec 2005)
New Revision: 370

Added:
   haypo/hachoir/trunk/plugins/email.py
Removed:
   haypo/hachoir/trunk/broken_plugins/email.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/stream/stream.py
Log:
- StringChunk only use Unicode when charset != "ascii"
- Some changes in Worms2 plugin
- Upgrade email plugin to new syntax


Deleted: haypo/hachoir/trunk/broken_plugins/email.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/email.py	2005-12-28 01:57:51 UTC (rev 369)
+++ haypo/hachoir/trunk/broken_plugins/email.py	2005-12-28 04:12:28 UTC (rev 370)
@@ -1,223 +0,0 @@
-"""
-Email parser
-
-Author: Victor Stinner
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin, guessPlugin, getPluginByMime
-from default import DefaultFilter
-from mime import splitMimes
-from error import warning, error
-from stream.base_64 import Base64Stream
-import re
-
-class EmailHeader(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email_hdr", "Email header", stream, parent)
-        self._dict = {}
-        regex_new = re.compile("^([A-Za-z][A-Za-z0-9-]*): (.*)$")
-        regex_continue = re.compile("^[\t ]+(.*)$")
-        linenb = 1
-        last_key = None
-        last_index = None
-        while True:
-            id = "header[%u]" % linenb
-            chunk = self.readString(id, "AutoLine", "Header line")
-            if chunk.length == 0: return
-            line = chunk.value
-
-            m = regex_new.match(line)
-            if m != None:
-                last_key = m.group(1)
-                last_index = self._newHeader(last_key, m.group(2))
-            else:
-                m = regex_continue.match(line)
-                if m != None:
-                    assert last_key != None
-                    self._appendHeader(last_key, last_index, m.group(1))
-                else:
-                    warning("Can't parse email header: %s" % line)
-
-            linenb = linenb + 1
-
-    def __contains__(self, key):
-        key = key.lower()
-        return key in self._dict
-
-    def _appendHeader(self, key, index, value):
-        key = key.lower()
-        self._dict[key][index] = self._dict[key][index] + " " + value
-        
-    def _newHeader(self, key, value):
-        key = key.lower()
-        if key in self._dict:
-            index = len(self._dict[key])
-            self._dict[key].append(value)
-        else:
-            index = 0
-            self._dict[key] = [value]
-        return index
-
-    def __getitem__(self, index):
-        index = index.lower()
-        return self._dict[index]
-
-class EmailPart(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email_part", "Email part", stream, parent)
-        self.readChild("header", EmailHeader)
-        readEmailContent(self, stream.createSub())
-
-class EmailBody(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email_body", "Email body", stream, parent)
-        linenb = 1 
-        while not stream.eof():
-            guess = stream.read(5, False)
-            if guess=="From ":
-                break
-            id = "body[%u]" % linenb
-            chunk = self.readString(id, "AutoLine", "Body text")
-            linenb = linenb + 1
-
-def readEmailContent(self, stream):
-    mime = getEmailMime(self)
-    if mime != None and re.match("^multipart/", mime[0]) != None:
-        readMultipartEmail(self, stream, mime[1]["boundary"])
-    else:
-        if mime == None:
-            warning("Can't get MIME type for email %s" % self)
-        readBody(self, stream, mime)
-
-def readBody(self, stream, mime):
-    # Read encoding
-    header = self["header"]
-    if "Content-Transfer-Encoding" in header:
-        encoding = header["Content-Transfer-Encoding"][0]
-    else:
-        encoding = None
-
-    # Get filename
-    if mime != None:
-        filename = mime[1].get("name", None)
-    else:
-        raise Exception("No MIME in readBody()")
-        filename = None
-    if filename == None:
-        if "Content-Disposition" in header:
-            disp = header["Content-Disposition"][0].split(";")
-            regex = re.compile("filename=\"([^\"]+)\"")
-            for item in disp:
-                m = regex.match(item.strip())
-                if m != None:
-                    filename = m.group(1)
-                    break
-    elif filename[0] == '"':
-        filename = filename[1:-1]
-
-    # Handler base64 encodocing
-    if encoding == "base64":
-        size = stream.getSize() - stream.tell()
-        data = stream.getN(size, False)
-        substream = Base64Stream(data)
-        deflate = True
-    else:
-#        regex_new_mail = re.compile("[\r\n]From ")
-#        pos = stream.search(regex_new_mail)
-#        if pos != -1:
-#            substream = stream.createSub(size=pos)
-#        else:
-#            substream = stream
-        substream = stream.createSub()
-        deflate = False
-
-    # Guess plugin
-    if mime != None:
-        plugin = getPluginByMime((mime,), None)
-    else:
-        plugin = None
-    if plugin == None:
-        plugin = guessPlugin(substream, filename, None)
-    if plugin == None or plugin == EmailFilter:
-        plugin = EmailBody
-
-    # Finally read data
-    try:
-        if deflate:
-            self.readChild("body", DeflateFilter, substream, size, plugin) 
-        else:
-            self.readStreamChild("body", substream, plugin)
-    except Exception, msg:
-        error("Error while parsing email body: %s" % msg)
-        substream.seek(0)
-        self.readStreamChild("body", substream, DefaultFilter)
-
-def readMultipartEmail(self, stream, boundary):
-    assert boundary[0] == '"' and boundary[-1] == '"'
-    boundary = "--" + boundary[1:-1]
-    end_boundary = boundary + "--"
-    count = 1
-    while True:
-        id = "multipart_space[%u]" % count
-        chunk = self.readString(id, "AutoLine", "Space before first email parts")
-        value = chunk.value
-        if value == boundary:
-            break
-        count = count + 1
-
-    part = 1
-    boundary_index = 1
-    while True:
-        start = stream.tell()
-        size = stream.searchLength(boundary, False)
-        sub = stream.createSub(start, size)
-        self.readStreamChild("part[%u]" % part, sub, EmailPart)
-        stream.seek(start+size)
-        chunk = self.readString("boundary[%u]" % boundary_index, "AutoLine", "Boundary")
-        part = part + 1
-        boundary_index = boundary_index + 1
-        if chunk.value == boundary+"--":
-            break
-
-def getEmailMime(self):
-    header = self["header"]
-    if not("Content-Type" in header):
-        raise Exception("No mime")
-        return None
-    content_type = header["Content-Type"]
-    assert len(content_type) == 1
-    mimes = splitMimes(content_type[0])
-    assert len(mimes) == 1
-    return mimes[0]
-
-class Email(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "email", "Email", stream, parent)
-        self.readString("id", "AutoLine", "Email identifier")
-        self.readChild("header", EmailHeader)
-        readEmailContent(self, stream.createSub())
-
-    def __str__(self):
-        header = self["header"]
-        text = "Email"
-        if "From" in header:
-            text = text + " from %s" % header["From"]
-        if "Date" in header:
-            text = text + " (date %s)" % header["Date"]
-        return text
-
-class EmailFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email", "Email maildir parser", stream, parent)
-        while not stream.eof():
-            chunk = self.readChild("email[]", Email)
-            if stream.eof():
-                break
-            while not stream.eof():
-                guess = stream.read(5, False)
-                if guess == "From ":
-                    break
-                self.readString("space[]", "AutoLine", "Space")
-
-registerPlugin(EmailFilter, ["message/rfc822", "text/x-mail"])

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-28 01:57:51 UTC (rev 369)
+++ haypo/hachoir/trunk/chunk.py	2005-12-28 04:12:28 UTC (rev 370)
@@ -220,12 +220,13 @@
                 text = text.strip()
             else:
                 text = text.strip(self.strip)
-        try:                
-            text = unicode(text, self.charset)
-        except:
-            self.charset = "ascii"
-            text = StringChunk.regex_not_ascii.sub(".", text)
-            text = unicode(text, "ascii")
+        if self.charset != "ascii":
+            try:                
+                text = unicode(text, self.charset)
+            except:
+                self.charset = "ascii"
+                text = StringChunk.regex_not_ascii.sub(".", text)
+                text = unicode(text, "ascii")
         return text
 
     def getValue(self, max_size=None):

Copied: haypo/hachoir/trunk/plugins/email.py (from rev 351, haypo/hachoir/trunk/broken_plugins/email.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/email.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/email.py	2005-12-28 04:12:28 UTC (rev 370)
@@ -0,0 +1,225 @@
+"""
+Email parser
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter, DeflateFilter
+from plugin import registerPlugin, guessPlugin, getPluginByMime
+from chunk import StringChunk
+from default import DefaultFilter
+from mime import splitMimes
+from error import warning, error
+from stream.base_64 import Base64Stream
+import re
+
+class EmailHeader(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "email_hdr", "Email header", stream, parent)
+        self._dict = {}
+        regex_new = re.compile("^([A-Za-z][A-Za-z0-9-]*): (.*)$")
+        regex_continue = re.compile("^[\t ]+(.*)$")
+        linenb = 1
+        last_key = None
+        last_index = None
+        while True:
+            id = "header[%u]" % linenb
+            chunk = self.doRead(id, "Header line", (StringChunk, "AutoLine"))
+            if chunk.length == 0: return
+            line = chunk.value
+
+            m = regex_new.match(line)
+            if m != None:
+                last_key = m.group(1)
+                last_index = self._newHeader(last_key, m.group(2))
+            else:
+                m = regex_continue.match(line)
+                if m != None:
+                    assert last_key != None
+                    self._appendHeader(last_key, last_index, m.group(1))
+                else:
+                    warning("Can't parse email header: %s" % line)
+
+            linenb = linenb + 1
+
+    def __contains__(self, key):
+        key = key.lower()
+        return key in self._dict
+
+    def _appendHeader(self, key, index, value):
+        key = key.lower()
+        self._dict[key][index] = self._dict[key][index] + " " + value
+        
+    def _newHeader(self, key, value):
+        key = key.lower()
+        if key in self._dict:
+            index = len(self._dict[key])
+            self._dict[key].append(value)
+        else:
+            index = 0
+            self._dict[key] = [value]
+        return index
+
+    def __getitem__(self, index):
+        index = index.lower()
+        return self._dict[index]
+
+class EmailPart(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "email_part", "Email part", stream, parent)
+        self.read("header", "Header", (EmailHeader,))
+        readEmailContent(self, stream.createSub())
+
+class EmailBody(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "email_body", "Email body", stream, parent)
+        linenb = 1 
+        while not stream.eof():
+            guess = stream.read(5, False)
+            if guess=="From ":
+                break
+            id = "body[%u]" % linenb
+            self.read(id, "Body text", (StringChunk, "AutoLine"))
+            linenb = linenb + 1
+
+def readEmailContent(self, stream):
+    mime = getEmailMime(self)
+    if mime != None and re.match("^multipart/", mime[0]) != None:
+        readMultipartEmail(self, stream, mime[1]["boundary"])
+    else:
+        if mime == None:
+            warning("Can't get MIME type for email %s" % self)
+        readBody(self, stream, mime)
+
+def readBody(self, stream, mime):
+    # Read encoding
+    header = self["header"]
+    if "Content-Transfer-Encoding" in header:
+        encoding = header["Content-Transfer-Encoding"][0]
+    else:
+        encoding = None
+
+    # Get filename
+    if mime != None:
+        filename = mime[1].get("name", None)
+    else:
+        raise Exception("No MIME in readBody()")
+        filename = None
+    if filename == None:
+        if "Content-Disposition" in header:
+            disp = header["Content-Disposition"][0].split(";")
+            regex = re.compile("filename=\"([^\"]+)\"")
+            for item in disp:
+                m = regex.match(item.strip())
+                if m != None:
+                    filename = m.group(1)
+                    break
+    elif filename[0] == '"':
+        filename = filename[1:-1]
+
+    # Handler base64 encodocing
+    if encoding == "base64":
+        size = stream.getSize() - stream.tell()
+        data = stream.getN(size, False)
+        substream = Base64Stream(data)
+        deflate = True
+    else:
+#        regex_new_mail = re.compile("[\r\n]From ")
+#        pos = stream.search(regex_new_mail)
+#        if pos != -1:
+#            substream = stream.createSub(size=pos)
+#        else:
+#            substream = stream
+        substream = stream.createSub()
+        deflate = False
+
+    # Guess plugin
+    if mime != None:
+        plugin = getPluginByMime((mime,), None)
+    else:
+        plugin = None
+    if plugin == None:
+        plugin = guessPlugin(substream, filename, None)
+    if plugin == None or plugin == EmailFilter:
+        plugin = EmailBody
+
+    # Finally read data
+    try:
+        if deflate:
+            self.read("body", "Body", (DeflateFilter, substream, size, plugin))
+        else:
+            self.read("body", "Body", (plugin,), {"stream": substream})
+    except Exception, msg:
+        error("Error while parsing email body: %s" % msg)
+        substream.seek(0)
+        self.read("body", "Body", (DefaultFilter,), {"stream": substream})
+
+def readMultipartEmail(self, stream, boundary):
+    assert boundary[0] == '"' and boundary[-1] == '"'
+    boundary = "--" + boundary[1:-1]
+    end_boundary = boundary + "--"
+    count = 1
+    while True:
+        id = "multipart_space[%u]" % count
+        line = self.doRead(id, "Space before first email parts", (StringChunk, "AutoLine")).value
+        if line == boundary:
+            break
+        count = count + 1
+
+    part = 1
+    boundary_index = 1
+    while True:
+        start = stream.tell()
+        size = stream.searchLength(boundary, False)
+        sub = stream.createSub(start, size)
+        self.read("part[%u]" % part, "Email part %u" % part, (EmailPart,), {"stream": sub})
+        stream.seek(start+size)
+        line = self.doRead("boundary[%u]" % boundary_index, "Boundary", (StringChunk, "AutoLine")).value
+        part = part + 1
+        boundary_index = boundary_index + 1
+        if line == boundary+"--":
+            break
+
+def getEmailMime(self):
+    header = self["header"]
+    if not("Content-Type" in header):
+        raise Exception("No mime")
+        return None
+    content_type = header["Content-Type"]
+    assert len(content_type) == 1
+    mimes = splitMimes(content_type[0])
+    assert len(mimes) == 1
+    return mimes[0]
+
+class Email(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "email", "Email", stream, parent)
+        self.read("id", "Email identifier", (StringChunk, "AutoLine"))
+        self.read("header", "Header", (EmailHeader,))
+        #readEmailContent(self, stream.createSub())
+        readEmailContent(self, stream)
+
+    def __str__(self):
+        header = self["header"]
+        text = "Email"
+        if "From" in header:
+            text = text + " from %s" % header["From"]
+        if "Date" in header:
+            text = text + " (date %s)" % header["Date"]
+        return text
+
+class EmailFilter(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "email", "Email maildir parser", stream, parent)
+        while not stream.eof():
+            id = self.read("email[]", "Email", (Email,))
+            if id == "email[2]": break
+
+            # Search next email (line which starts with "From ")                
+            while not stream.eof():
+                guess = stream.read(5, False)
+                if guess == "From ":
+                    break
+                self.read("space[]", "Space", (StringChunk, "AutoLine"))
+
+registerPlugin(EmailFilter, ["message/rfc822", "text/x-mail"])

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-28 01:57:51 UTC (rev 369)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-28 04:12:28 UTC (rev 370)
@@ -24,7 +24,7 @@
         self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
         self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
         size = (self.width-self.x) * (self.height-self.y)
-        self.read("data", "Font content", (FormatChunk, "string[%u]" % size))
+        self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):
         chunk.description = "Image data: %ux%u pixels at (%u,%u)" \
@@ -40,7 +40,8 @@
         size = self["width"] * self["height"]
         self.read("img_data", "Data", (FormatChunk, "string[%u]" % size))
         size = stream.getLastPos() - stream.tell()
-        self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+        if size != 0:
+            self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):            
         chunk.description = "Image: %ux%u pixels" % \
@@ -54,7 +55,7 @@
         if True:
             self.read("header116", "Header 116", (FormatChunk, "uint8"))
             assert self["header116"] == 116 
-            self.read("a", "???", (FormatChunk, "uint8"))
+            self.read("type", "Type?", (FormatChunk, "uint8"))
             self.read("zero", "Zeros", (FormatChunk, "string[9]"))
             assert self["zero"] == ("\0" * 9)
             if False:
@@ -90,10 +91,18 @@
             else:
                 size = 29-15
             self.read("end_of_header", "End of mysterious header", (FormatChunk, "string[%u]" % size))
-            self.x = self.doRead("offset_x[]", "Offset X", (FormatChunk, "uint16")).value
-            self.y = self.doRead("offset_y[]", "Offset Y", (FormatChunk, "uint16")).value
-            self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
-            self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
+            if True: 
+                self.x = self.doRead("offset_x[]", "Offset X", (FormatChunk, "uint16")).value
+                self.y = self.doRead("offset_y[]", "Offset Y", (FormatChunk, "uint16")).value
+                self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
+                self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
+                size = (self.width - self.x) * (self.height - self.y)
+                if size <= (stream.getLastPos() - stream.tell()+1-1):
+                    self.read("image_data[]", "Data", (FormatChunk, "string[%u]" % size))
+            else:
+                image = self.doRead("image[]", "Image", (ImageData,))
+                self.width = image.width
+                self.height = image.height
 
             #print "Sprite % 20s: x=%s, header=% 2s, header=%s | %s" \
             #    % (name, x, size, str2bin(self["end_of_header"][:2]), str2hex(self["end_of_header"]))
@@ -108,7 +117,7 @@
             print "Sprite % 20s: %s" \
                 % (name, str2hex(self["data"]))
             
-        size = stream.getLastPos() - stream.tell()
+        size = stream.getLastPos() - stream.tell() + 1
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):            
@@ -119,18 +128,21 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "font", "Font", stream, parent, "<")
         self.read("palette", "Palette", (Palette, 81))
-        self.read("header", "Header !?", (FormatChunk, "string[%u]" % 0x105))
 
-#        while not stream.eof():
+        size = 261 
+        # TODO: Decode header
+        self.read("header", "Header !?", (FormatChunk, "string[%u]" % size))
+
         self.nb_characters = 0
-        while 2*4 < (stream.getLastPos() - stream.tell()):
+#        while 2*4 < (stream.getLastPos() - stream.tell() + 1):
+        for i in range(0, 160):
             id = self.read("image[]", "Image", (ImageData,))
             if self.nb_characters == 0:
                 image = self[id]
                 self.width = image.width
                 self.height = image.height
             self.nb_characters += 1
-        size = stream.getLastPos() - stream.tell()
+        size = stream.getLastPos() - stream.tell() + 1
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2005-12-28 01:57:51 UTC (rev 369)
+++ haypo/hachoir/trunk/stream/stream.py	2005-12-28 04:12:28 UTC (rev 370)
@@ -42,7 +42,7 @@
         return self.getLastPos() <= self.tell() 
 
     def createSub(self, start=None, size=None):
-        if start==None:
+        if start == None:
             start = self.tell()
         if size == None:
             size = self.getSize()-start
@@ -68,6 +68,8 @@
         pos = self.search(needle, size_max)
         if pos == -1: return -1
         lg = pos - self.tell()
+        # TODO: Support Unicode?
+        assert not isinstance(needle, unicode)
         if include_str:
             if isinstance(needle, str):
                 lg = lg + len(needle)
@@ -95,7 +97,7 @@
         Search a string between current position and pos_max (which will be
         also tested). Returns -1 if fails.
         """
-        is_regex =  not isinstance(needle, str)
+        is_regex = not isinstance(needle, str)
         if is_regex:
             len_needle = regexMaxLength(needle.pattern)
         else:



From haypo at berlios.de  Wed Dec 28 06:35:06 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 06:35:06 +0100
Subject: [Happyboom-svn] r371 - in haypo/hachoir/trunk: . broken_plugins plugins
Message-ID: <200512280535.jBS5Z6JV000146@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 06:35:04 +0100 (Wed, 28 Dec 2005)
New Revision: 371

Added:
   haypo/hachoir/trunk/plugins/elf.py
   haypo/hachoir/trunk/plugins/exe.py
Removed:
   haypo/hachoir/trunk/broken_plugins/elf.py
   haypo/hachoir/trunk/broken_plugins/exe.py
Modified:
   haypo/hachoir/trunk/text_handler.py
Log:
- Upgrade ELF and EXE plugin to new syntax
- Improve EXE filters description (using updateParent())
- EXE plugin can read timestamp, header flags, and display machine type


Deleted: haypo/hachoir/trunk/broken_plugins/elf.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/elf.py	2005-12-28 04:12:28 UTC (rev 370)
+++ haypo/hachoir/trunk/broken_plugins/elf.py	2005-12-28 05:35:04 UTC (rev 371)
@@ -1,171 +0,0 @@
-"""
-ELF filter.
-Author: Victor Stinner
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-
-def processAddr(chunk):
-    return "%08X" % chunk.value
-
-class ElfHeader(Filter):
-    machine = {
-        0: "No machine",
-        1: "AT&T WE 32100",
-        2: "SPARC",
-        3: "Intel 80386",
-        4: "Motorolla 68000",
-        5: "Motorolla 88000",
-        7: "Intel 80860",
-        8: "MIPS RS3000"
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "elf_header", "ELF header", stream, parent)
-        self.read("id", "4s", "Identifier")
-        assert self["id"] == (chr(127) + "ELF")
-        self.read("class", "B", "Class")
-        self.read("encoding", "B", "Encoding")
-        self.read("file_version", "B", "File version")
-        self.read("pad", "8s", "Pad")
-        self.read("nident", "B", "Size of ident[]")
-        self.read("type", "<H", "File type", post=self.getType)
-        self.read("machine", "<H", "Machine type", post=self.getMachine)
-        self.read("version", "<L", "ELF format version")
-        self.read("entry", "<L", "Number of entries")
-        self.read("phoff", "<L", "Program header offset")
-        self.read("shoff", "<L", "Section header offset")
-        self.read("flags", "<L", "Flags")
-        self.read("ehsize", "<H", "Elf header size (this header)")
-        self.read("phentsize", "<H", "Program header entry size")
-        self.read("phnum", "<H", "Program header entry count")
-        self.read("shentsize", "<H", "Section header entry size")
-        self.read("shnum", "<H", "Section header entre count")
-        self.read("shstrndx", "<H", "Section header strtab index")
-
-    def getType(self, chunk):
-        type = chunk.value
-        types = {
-            0: "No file type",
-            1: "Relocable file",
-            2: "Executable file",
-            3: "Shared object file",
-            4: "Core file",
-            0xFF00: "Processor-specific (0xFF00)",
-            0xFFFF: "Processor-specific (0xFFFF)"
-        }
-        return types.get(type, "Unknow type (%u)" % type)
-
-    def getMachine(self, chunk):
-        type = chunk.value
-        return ElfHeader.machine.get(type, "Unknow machine (%u)" % type)
-
-class SectionHeader32(Filter):
-    types = {
-        8: "BSS"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "section_header", "Section header", stream, parent)
-        self.read("name", "<L", "")
-        self.read("type", "<L", "")
-        self.read("flags", "<L", "")
-        self.read("VMA", "<L", "Virtual memory address")#, post=processAddr)
-        self.read("LMA", "<L", "Logical memory address (in file)")#, post=processAddr)
-        self.read("size", "<L", "", post=processAddr)
-        self.read("link", "<L", "")
-        self.read("info", "<L", "")
-        self.read("addralign", "<L", "")
-        self.read("entsize", "<L", "")
-
-    def getType(self):
-        type = self["type"]
-        return SectionHeader32.types.get(type, "unknow type=%u" % type)
-
-    def getName(self):
-        #?TODO: Look in symbol name
-        return self["name"]
-
-    def updateParent(self, chunk):
-        desc = "Section header (name: %s, type: %s)" % (self.getName(), self.getType())
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ProgramHeader32(Filter):
-    type = {
-        3: "Dynamic library"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "prg_header", "Program header", stream, parent)
-        self.read("type", "<H", "")
-        self.read("flags", "<H", "")
-        self.read("offset", "<L", "")
-        self.read("vaddr", "<L", "", post=processAddr)
-        self.read("paddr", "<L", "", post=processAddr)
-        self.read("file_size", "<L", "")
-        self.read("mem_size", "<L", "")
-        self.read("align", "<L", "")
-        self.read("padding", "<L", "(padding?)")
-
-    def getType(self):
-        type = self["type"]
-        return ProgramHeader32.type.get(type, "unknow, %u" % type)
-
-    def updateParent(self, chunk):
-        desc = "Program Header (%s)" % self.getType() 
-        self.setDescription(desc)
-        chunk.description = desc 
-
-def seek(filter, stream, offset):
-    current = stream.tell()
-    if current != offset:
-        filter.read("padding[]", "%us" % (offset-current), "Padding")
-
-def sortSection(a, b):
-    return int(a["offset"] - b["offset"])
-
-class Section(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "elf_section", "Elf section", stream, parent)
-        # TODO ...
-        self.read("raw", "%us" % stream.getSize(), "Raw data")
-        
-class Sections(Filter):
-    def __init__(self, stream, parent, sections):
-        Filter.__init__(self, "elf_sections", "ELF sections", stream, parent)
-        for section in sections:
-            ofs = section["offset"]
-            size = section["file_size"]
-            sub = stream.createSub(ofs, size)
-            #self.readChild("section[]", DeflateFilter, sub, size, Section) 
-            chunk = self.readStreamChild("section[]", sub, Section) 
-            chunk.description = "ELF section (in file: %s..%s)" % (ofs, ofs+size)
-
-class ElfFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "elf_file", "ELF file", stream, parent)
-        self.readChild("elf_header", ElfHeader)
-        elf = self["elf_header"]
-        sections = []
-        for i in range(0, elf["phnum"]):
-            section = self.readChild("prg_header[]", ProgramHeader32)
-            sections.append(section.getFilter())
-
-#        i = 1
-#        for section in sections:
-#            print "Section %u: type %u, data in %u..%u " % (i, section["type"], section["offset"], section["offset"]+section["file_size"])
-#            i = i + 1
-            
-        size = elf["shoff"] - stream.tell()
-        newstream = stream.clone()
-        chunk = self.readChild("data", DeflateFilter, newstream, size, Sections, sections) 
-        chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
-        assert stream.tell() == elf["shoff"]
-
-        for i in range(0, elf["shnum"]):
-            chunk = self.readChild("section_header[]", SectionHeader32)
-            assert chunk.size == 40
-
-registerPlugin(ElfFile, ["application/x-executable", "application/x-object", "application/x-sharedlib"])

Deleted: haypo/hachoir/trunk/broken_plugins/exe.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/exe.py	2005-12-28 04:12:28 UTC (rev 370)
+++ haypo/hachoir/trunk/broken_plugins/exe.py	2005-12-28 05:35:04 UTC (rev 371)
@@ -1,196 +0,0 @@
-"""
-EXE filter.
-
-Status: read ms-dos and pe headers
-Todo: support resources ... and disassembler ? :-)
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class PE_ResourceData(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_rsrc_data", "PE resource data", stream, parent)
-        self.read("offset", "<L", "Offset")
-        self.read("size", "<L", "Size")
-        self.read("page_code", "<L", "Page code (language)")
-        self.read("language", "<l", "Page code (language)")
-#        self.language = -self["language"]
-        self.read("reserved", "!L", "Reserverd")
-
-        oldpos = stream.tell()
-        
-        #stream.seek(XXX + self.offset - self.offset_res_section)
-        stream.seek(self["offset"])
-        stream.seek(oldpos)
-
-class PE_ResourceEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_rsrc_entry", "PE resource entry", stream, parent)
-        self.read("id", "<L", "ID or name")
-        self.read("offset", "<L", "Offset")
-        
-class PE_ResourceDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_rsrc_dir", "PE resource directory", stream, parent)
-        self.offset_res_section = stream.tell()
-        self.read("option", "<L", "Options")
-        self.read("creation_date", "<L", "Creation date")
-        self.read("maj_ver", "<H", "Major version")
-        self.read("named_entries", "<H", "Named entries")
-        self.read("indexed_entries", "<H", "Indexed entries")
-
-        stream.seek( stream.tell() + 0x10)
-        self.readArray("item", PE_ResourceEntry, "PE resource entry", self.checkEndOfRes)
-    
-    def checkEndOfRes(self, stream, array, dir):
-        return len(array) == (self["named_entries"] + self["indexed_entries"])
-
-class PE_Section(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_section", "PE section", stream, parent)
-        self.read("name", "8s", "Name")
-        # TODO: use chunk post proces
-        self.name = self["name"].strip(" \0")
-        self.read("rva", "<L", "RVA")
-        self.read("size", "<L", "Size")
-        self.read("file_size", "<L", "File size")
-        self.read("file_offset", "<L", "File offset")
-        self.read("reloc_ptr", "<L", "Relocation pointer")
-        self.read("lines_ptr", "<L", "File line numbers pointer")
-        self.read("nb_reloc", "<H", "Number of relocations")
-        self.read("nb_lines", "<H", "Number of file line")
-        self.read("options", "<L", "Options")
-
-class PE_Directory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_dir", "PE directory", stream, parent)
-        self.read("size", "<L", "Size")
-        self.read("rva", "<L", "RVA")
-
-class PE_OptionnalHeader(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_opt_hdr", "PE optionnal header", stream, parent)
-        self.read("header", "<H", "Header")
-        assert self["header"] == 0x010B
-        self.read("linker_maj_ver", "B", "Linker major version")
-        self.read("linker_min_ver", "B", "Linker minor version")
-        self.read("code_size", "<L", "Code size (bytes)")
-        self.read("data_size", "<L", "Data size (bytes)")
-        self.read("heap_size", "<L", "Heap size (bytes)")
-        self.read("entry_point_rva", "<L", "Entry point offset (RVA)")
-        self.read("code_rva", "<L", "Code offset (RVA)")
-        self.read("data_rva", "<L", "Data offset (RVA)")
-        self.read("base_image_rva", "<L", "Base image offset (RVA)")
-        self.read("memory_alignment", "<L", "Memory alignment")
-        self.read("file_alignment", "<L", "File alignment")
-        self.read("os_maj_ver", "<H", "OS major version")
-        self.read("os_min_ver", "<H", "OS minor version")
-        self.read("prog_maj_ver", "<H", "Program major version")
-        self.read("prog_min_ver", "<H", "Program minor version")
-        self.read("api_maj_ver", "<H", "API major version?!")
-        self.read("api_min_ver", "<H", "API minor version?!")
-        self.read("windows_ver", "<L", "Windows version?!")
-        self.read("image_size", "<L", "Image size")
-        self.read("headers_size", "<L", "Headers size")
-        self.read("checksum", "<L", "Checkum")
-        self.read("neeed_api", "<H", "Needed API?!")
-        self.read("dll_options", "<H", "DLL options (only for DLL)")
-        self.read("reserved_stack_size", "<L", "Reserved stack size")
-        self.read("common_stack_size", "<L", "Common stack size")
-        self.read("reserved_heap_size", "<L", "Reserved heap size")
-        self.read("common_heap_size", "<L", "Common heap size")
-        self.read("loader_options", "<L", "Loader options")
-        self.read("nb_directories", "<L", "Number of directories (16)")
-        assert self["nb_directories"] == 16
-        self.readArray("directories", PE_Directory, "PE directories", self.checkEndOfDir)
-
-    def checkEndOfDir(self, stream, array, dir):
-        return len(array) == self.nb_directories
-
-class PE_Filter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_header", "PE header", stream, parent)
-        self.read("header", "4s", "File header")
-        assert self["header"] == "PE\0\0"
-        self.read("cpu_type", "<H", "CPU type")
-        self.read("nb_sections", "<H", "Number of sections")
-        self.read("creation_date", "<L", "Creation date")
-        self.read("ptr_to_symbols", "<L", "Pointer to symbol table")
-        self.read("nb_symbols", "<L", "Number of symbols")
-        self.read("opt_header_size", "<H", "Optionnal header size")
-        self.read("options", "<H", "Options")
-
-    def getCpuType(self):
-        cpu_name = {
-            0x014C: "Intel 80386 or greater",
-            0x014D: "Intel 80486 or greater",
-            0x014E: "Intel Pentium or greader", 
-            0x0160: "R3000 (MIPS), big endian",
-            0x0162: "R3000 (MIPS), little endian",
-            0x0166: "R4000 (MIPS), little endian",
-            0x0168: "R10000 (MIPS), little endian",
-            0x0184: "DEC Alpha AXP",
-            0x01F0: "IBM Power PC, little endian"}
-        return cpu_name.get(self["cpu_type"], "unknow")
-
-class MS_Dos(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "msdos_header", "MS-Dos executable header", stream, parent)
-        self.read("header", "2s", "File header")
-        assert self["header"] == "MZ"
-        self.read("filesize_mod_512", ">H", "Filesize mod 512")
-        self.read("filesize_div_512", ">H", "Filesize div 512")
-        self.filesize = self["filesize_div_512"] * 512 + self["filesize_mod_512"]
-        self.read("reloc_entries", ">H", "Number of relocation entries")
-        self.read("code_offset", "<H", "Offset to the code in the file (div 16)")
-        self.code_offset = self["code_offset"] * 16
-        self.read("needed_memory", ">H", "Memory needed to run (div 16)")
-        self.needed_memory = self["needed_memory"] * 16
-        self.read("max_memory", ">H", "Maximum memory needed to run (div 16)")
-        self.max_memory = self["max_memory"] * 16
-        self.read("init_ss_sp", ">L", "Initial value of SP:SS registers.")
-        self.read("checksum", ">H", "Checksum")
-        self.read("init_cs_ip", ">L", "Initial value of CS:IP registers.")
-        self.read("reloc_offset", "<H", "Offset in file to relocation table.")
-        self.read("overlay_number", ">H", "Overlay number")
-        self.read("reserved", ">4H", "Reserverd")
-        self.read("oem_id", ">H", "OEM id")
-        self.read("oem_info", ">H", "OEM info")
-        self.read("reserved2", "!10H", "Reserved")
-        self.read("pe_offset", "<L", "Offset to PE header")
-
-class ExeFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "exe_file", "EXE file", stream, parent)
-
-        self.readChild("ms_dos", MS_Dos)
-
-        if self["ms_dos"]["reloc_offset"] == 0x40:
-            stream.seek(self["ms_dos"]["pe_offset"], 0)
-
-            self.readChild("pe", PE_Filter)
-            self.pe = self["pe"]
-            self.readChild("pe_opt", PE_OptionnalHeader)
-            self.readArray("pe_sections", PE_Section, "PE sections", self.checkEndOfSections)
-
-            # TODO: Fix this ...
-            
-            offset_res_section = None
-            for section in self["pe_sections"]:
-                section = section.getFilter()
-                if section.name == ".rsrc":
-                    offset_res_section = section.file_offset
-                    self.getStream().seek( offset_res_section )
-                    break
-            if offset_res_section != None:
-                #for i in range(1): #range(self.pe.nb_sections):
-                self.readChild("pe_resources", PE_ResourceDirectory)
-        else:
-            self.pe = None
-
-    def checkEndOfSections(self, stream, array, section):
-        return len(array) == self["pe"]["nb_sections"]
-
-registerPlugin(ExeFile, "application/x-dosexec")

Copied: haypo/hachoir/trunk/plugins/elf.py (from rev 351, haypo/hachoir/trunk/broken_plugins/elf.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/elf.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/elf.py	2005-12-28 05:35:04 UTC (rev 371)
@@ -0,0 +1,153 @@
+"""
+ELF (Unix/BSD executable file format) parser.
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter, DeflateFilter
+from chunk import FormatChunk, EnumChunk
+from plugin import registerPlugin
+from text_handler import hexadecimal
+
+class ElfHeader(OnDemandFilter):
+    machine_name = {
+        0: "No machine",
+        1: "AT&T WE 32100",
+        2: "SPARC",
+        3: "Intel 80386",
+        4: "Motorolla 68000",
+        5: "Motorolla 88000",
+        7: "Intel 80860",
+        8: "MIPS RS3000"
+    }
+    type_name = {
+        0: "No file type",
+        1: "Relocable file",
+        2: "Executable file",
+        3: "Shared object file",
+        4: "Core file",
+        0xFF00: "Processor-specific (0xFF00)",
+        0xFFFF: "Processor-specific (0xFFFF)"
+    }
+
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "elf_header", "ELF header", stream, parent, "<")
+        self.read("id", "Identifier", (FormatChunk, "string[4]"))
+        assert self["id"] == "\x7FELF"
+        self.read("class", "Class", (FormatChunk, "uint8"))
+        self.read("encoding", "Encoding", (FormatChunk, "uint8"))
+        self.read("file_version", "File version", (FormatChunk, "uint8"))
+        self.read("pad", "Pad", (FormatChunk, "string[8]"))
+        self.read("nb_ident", "Size of ident[]", (FormatChunk, "uint8"))
+        self.read("type", "File type", (EnumChunk, "uint16", ElfHeader.type_name))
+        self.read("machine", "Machine type", (EnumChunk, "uint16", ElfHeader.machine_name))
+        self.read("version", "ELF format version", (FormatChunk, "uint32"))
+        self.read("entry", "Number of entries", (FormatChunk, "uint32"))
+        self.read("phoff", "Program header offset", (FormatChunk, "uint32"))
+        self.read("shoff", "Section header offset", (FormatChunk, "uint32"))
+        self.read("flags", "Flags", (FormatChunk, "uint32"))
+        self.read("ehsize", "Elf header size (this header)", (FormatChunk, "uint16"))
+        self.read("phentsize", "Program header entry size", (FormatChunk, "uint16"))
+        self.read("phnum", "Program header entry count", (FormatChunk, "uint16"))
+        self.read("shentsize", "Section header entry size", (FormatChunk, "uint16"))
+        self.read("shnum", "Section header entre count", (FormatChunk, "uint16"))
+        self.read("shstrndx", "Section header strtab index", (FormatChunk, "uint16"))
+
+class SectionHeader32(OnDemandFilter):
+    type_name = {
+        8: "BSS"
+    }
+    
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "section_header", "Section header", stream, parent, "<")
+        self.read("name", "Name", (FormatChunk, "uint32"))
+        self.read("type", "Type", (EnumChunk, "uint32", SectionHeader32.type_name))
+        self.read("flags", "Flags", (FormatChunk, "uint32"))
+        self.read("VMA", "Virtual memory address", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("LMA", "Logical memory address (in file)", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("size", "Size", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("link", "Link", (FormatChunk, "uint32"))
+        self.read("info", "Information", (FormatChunk, "uint32"))
+        self.read("addr_align", "Address alignment", (FormatChunk, "uint32"))
+        self.read("entry_size", "Entry size", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        name = self["name"]
+        type = self.getChunk("type").getDisplayData()
+        desc = "Section header (name: %s, type: %s)" % (name, type)
+        chunk.description = desc
+
+class ProgramHeader32(OnDemandFilter):
+    type_name = {
+        3: "Dynamic library"
+    }
+    
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "prg_header", "Program header", stream, parent, "<")
+        self.read("type", "Type", (EnumChunk, "uint16", ProgramHeader32.type_name))
+        self.read("flags", "Flags", (FormatChunk, "uint16"))
+        self.read("offset", "Offset", (FormatChunk, "uint32"))
+        self.read("vaddr", "V. address", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("paddr", "P. address", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("file_size", "File size", (FormatChunk, "uint32"))
+        self.read("mem_size", "Memory size", (FormatChunk, "uint32"))
+        self.read("align", "Alignement", (FormatChunk, "uint32"))
+        self.read("padding", "(padding?)", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        type = self.getChunk("type").getDisplayData() 
+        chunk.description = "Program Header (%s)" % type
+
+def seek(filter, stream, offset):
+    current = stream.tell()
+    if current != offset:
+        filter.read("padding[]", "Padding", (FormatChunk, "string[%u]" % (offset-current)))
+
+def sortSection(a, b):
+    return int(a["offset"] - b["offset"])
+
+class Section(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "elf_section", "Elf section", stream, parent, "<")
+        # TODO ...
+        self.read("raw", "Raw data", (FormatChunk, "string[%u]" % stream.getSize()))
+        
+class Sections(OnDemandFilter):
+    def __init__(self, stream, parent, sections):
+        OnDemandFilter.__init__(self, "elf_sections", "ELF sections", stream, parent, "<")
+        for section in sections:
+            ofs = section["offset"]
+            size = section["file_size"]
+            if size != 0:
+                sub = stream.createSub(ofs, size)
+                #self.read("section[]", "Section", (DeflateFilter, sub, size, Section))
+                chunk = self.doRead("section[]", "Section", (Section,), {"stream": sub}) 
+            else:
+                chunk = self.doRead("section[]", "Section", (FormatChunk, "string[0]"))
+            chunk.description = "ELF section (in file: %s..%s)" % (ofs, ofs+size)
+
+class ElfFile(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "elf_file", "ELF file", stream, parent, "<")
+        elf = self.doRead("header", "Header", (ElfHeader,))
+        sections = []
+        for i in range(0, elf["phnum"]):
+            section = self.doRead("prg_header[]", "Program header", (ProgramHeader32,))
+            sections.append(section)
+
+#        i = 1
+#        for section in sections:
+#            print "Section %u: type %u, data in %u..%u " % (i, section["type"], section["offset"], section["offset"]+section["file_size"])
+#            i = i + 1
+            
+        size = elf["shoff"] - stream.tell()
+        newstream = stream.clone()
+        chunk = self.doRead("data", "Data", (DeflateFilter, newstream, size, Sections, sections))
+        chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
+        assert stream.tell() == elf["shoff"]
+
+        for i in range(0, elf["shnum"]):
+            chunk = self.doRead("section_header[]", "Section header", (SectionHeader32,))
+            assert chunk.getSize() == 40
+
+registerPlugin(ElfFile, ["application/x-executable", "application/x-object", "application/x-sharedlib"])

Copied: haypo/hachoir/trunk/plugins/exe.py (from rev 351, haypo/hachoir/trunk/broken_plugins/exe.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/exe.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/exe.py	2005-12-28 05:35:04 UTC (rev 371)
@@ -0,0 +1,239 @@
+"""
+EXE filter.
+
+Status: read ms-dos and pe headers
+Todo: support resources ... and disassembler ? :-)
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk, BitsStruct, BitsChunk
+from text_handler import unixTimestamp
+from tools import humanFilesize
+
+class PE_ResourceData(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_rsrc_data", "PE resource data", stream, parent, "<")
+        self.read("offset", "Offset", (FormatChunk, "uint32"))
+        self.read("size", "Size", (FormatChunk, "uint32"))
+        self.read("page_code", "Page code (language)", (FormatChunk, "uint32"))
+        self.read("language", "Page code (language)", (FormatChunk, "<l"))
+        self.read("reserved", "Reserverd", (FormatChunk, "!L"))
+
+class PE_ResourceEntry(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_rsrc_entry", "PE resource entry", stream, parent, "<")
+        self.read("id", "ID or name", (FormatChunk, "uint32"))
+        self.read("offset", "Offset", (FormatChunk, "uint32"))
+        
+class PE_ResourceDirectory(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_rsrc_dir", "PE resource directory", stream, parent, "<")
+        self.offset_res_section = stream.tell()
+        self.read("option", "Options", (FormatChunk, "uint32"))
+        self.read("creation_date", "Creation date", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("maj_ver", "Major version", (FormatChunk, "uint16"))
+        self.read("named_entries", "Named entries", (FormatChunk, "uint16"))
+        self.read("indexed_entries", "Indexed entries", (FormatChunk, "uint16"))
+
+        self.read("xxx", "???", (FormatChunk, "string[%u]" % 0x10))
+
+        n = (self["named_entries"] + self["indexed_entries"])
+        for i in range(0,n):
+            self.read("item[]", "PE resource entry", (PE_ResourceEntry,))
+
+class PE_Section(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_section", "PE section", stream, parent, "<")
+        self.read("name", "Name", (FormatChunk, "string[8]"))
+        # TODO: use chunk post proces
+        self.name = self["name"].strip(" \0")
+        self.read("rva", "RVA", (FormatChunk, "uint32"))
+        self.read("size", "Size", (FormatChunk, "uint32"))
+        self.read("file_size", "File size", (FormatChunk, "uint32"))
+        self.read("file_offset", "File offset", (FormatChunk, "uint32"))
+        self.read("reloc_ptr", "Relocation pointer", (FormatChunk, "uint32"))
+        self.read("lines_ptr", "File line numbers pointer", (FormatChunk, "uint32"))
+        self.read("nb_reloc", "Number of relocations", (FormatChunk, "uint16"))
+        self.read("nb_lines", "Number of file line", (FormatChunk, "uint16"))
+        self.read("options", "Options", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        name = self["name"].strip("\0")
+        chunk.description = "Section: \"%s\" (size=%s)" % (name, humanFilesize(self["size"]))
+
+class PE_Directory(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_dir", "PE directory", stream, parent, "<")
+        self.read("size", "Size", (FormatChunk, "uint32"))
+        self.read("rva", "RVA", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        if self["rva"] != 0:
+            chunk.description = "Directory: size=%s" % humanFilesize(self["size"])
+        else:
+            chunk.description = "Directory: (unused)"
+
+class PE_OptionnalHeader(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_opt_hdr", "PE optionnal header", stream, parent, "<")
+        self.read("header", "Header", (FormatChunk, "uint16"))
+        assert self["header"] == 0x010B
+        self.read("linker_maj_ver", "Linker major version", (FormatChunk, "uint8"))
+        self.read("linker_min_ver", "Linker minor version", (FormatChunk, "uint8"))
+        self.read("code_size", "Code size (bytes)", (FormatChunk, "uint32"))
+        self.read("data_size", "Data size (bytes)", (FormatChunk, "uint32"))
+        self.read("heap_size", "Heap size (bytes)", (FormatChunk, "uint32"))
+        self.read("entry_point_rva", "Entry point offset (RVA)", (FormatChunk, "uint32"))
+        self.read("code_rva", "Code offset (RVA)", (FormatChunk, "uint32"))
+        self.read("data_rva", "Data offset (RVA)", (FormatChunk, "uint32"))
+        self.read("base_image_rva", "Base image offset (RVA)", (FormatChunk, "uint32"))
+        self.read("memory_alignment", "Memory alignment", (FormatChunk, "uint32"))
+        self.read("file_alignment", "File alignment", (FormatChunk, "uint32"))
+        self.read("os_maj_ver", "OS major version", (FormatChunk, "uint16"))
+        self.read("os_min_ver", "OS minor version", (FormatChunk, "uint16"))
+        self.read("prog_maj_ver", "Program major version", (FormatChunk, "uint16"))
+        self.read("prog_min_ver", "Program minor version", (FormatChunk, "uint16"))
+        self.read("api_maj_ver", "API major version?!", (FormatChunk, "uint16"))
+        self.read("api_min_ver", "API minor version?!", (FormatChunk, "uint16"))
+        self.read("windows_ver", "Windows version?!", (FormatChunk, "uint32"))
+        self.read("image_size", "Image size", (FormatChunk, "uint32"))
+        self.read("headers_size", "Headers size", (FormatChunk, "uint32"))
+        self.read("checksum", "Checkum", (FormatChunk, "uint32"))
+        self.read("neeed_api", "Needed API?!", (FormatChunk, "uint16"))
+        self.read("dll_options", "DLL options (only for DLL)", (FormatChunk, "uint16"))
+        self.read("reserved_stack_size", "Reserved stack size", (FormatChunk, "uint32"))
+        self.read("common_stack_size", "Common stack size", (FormatChunk, "uint32"))
+        self.read("reserved_heap_size", "Reserved heap size", (FormatChunk, "uint32"))
+        self.read("common_heap_size", "Common heap size", (FormatChunk, "uint32"))
+        self.read("loader_options", "Loader options", (FormatChunk, "uint32"))
+        self.read("nb_directories", "Number of directories (16)", (FormatChunk, "uint32"))
+        assert self["nb_directories"] == 16
+        for i in range(0, self["nb_directories"]):
+            self.read("directorie[]", "PE directory", (PE_Directory,))
+
+class PE_Header(OnDemandFilter):
+    cpu_type_name = {
+        0x00: "Unknow (any type)",
+        0x184: "Alpha AXP",
+        0x1c0: "ARM",
+        0x284: "Alpha AXP 64 bits",
+        0x14c: "Intel 386",
+        0x200: "Intel IA64",
+        0x268: "Motorolla 68000",
+        0x266: "MIPS",
+        0x366: "MIPS with FPU",
+        0x466: "MIPS16 with FPU",
+        0x1f0: "PowerPC little endian",
+        0x162: "R3000",
+        0x166: "MIPS little endian (R4000)",
+        0x168: "R10000",
+        0x1a2: "Hitachi SH3",
+        0x1a6: "Hitachi SH4",
+        0x1c2: "Thumb (?)"
+    }
+    
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "pe_header", "PE header", stream, parent, "<")
+        self.read("header", "File header", (FormatChunk, "string[4]"))
+        assert self["header"] == "PE\0\0"
+        self.read("cpu_type", "CPU type", (EnumChunk, "uint16", PE_Header.cpu_type_name))
+        self.read("nb_sections", "Number of sections", (FormatChunk, "uint16"))
+        self.read("creation_date", "Creation date", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("ptr_to_symbols", "Pointer to symbol table", (FormatChunk, "uint32"))
+        self.read("nb_symbols", "Number of symbols", (FormatChunk, "uint32"))
+        self.read("opt_header_size", "Optionnal header size", (FormatChunk, "uint16"))
+
+        bits = (
+            (1, "reloc_stripped", "If true, don't contain base relocations."),
+            (1, "exec_image", "Exectuable image?"),
+            (1, "line_nb_stripped", "COFF line numbers stripped?"),
+            (1, "local_sym_stripped", "COFF symbol table entries stripped?"),
+            (1, "aggr_ws", "Aggressively trim working set"),
+            (1, "large_addr", "Application can handle addresses greater than 2 GB"),
+            (1, "reserved", "(reserved)"),
+            (1, "reverse_lo", "Little endian: LSB precedes MSB in memory"),
+            (1, "32bit", "Machine based on 32-bit-word architecture"),
+            (1, "debug_stripped", "Debugging information removed?"),
+            (1, "swap", "If image is on removable media, copy and run from swap file"),
+            (1, "reserved2", "(reserved)"),
+            (1, "system", "It's a system file"),
+            (1, "dll", "It's a dynamic-link library (DLL)"),
+            (1, "up", "File should be run only on a UP machine"),
+            (1, "reverse_hi", "Big endian: MSB precedes LSB in memory"),
+        )
+        self.read("options", "Options", (BitsChunk, BitsStruct(bits)))
+        #self.read("options", "Options", (FormatChunk, "uint16"))
+
+    def getCpuType(self):
+        cpu_name = {
+            0x014C: "Intel 80386 or greater",
+            0x014D: "Intel 80486 or greater",
+            0x014E: "Intel Pentium or greader", 
+            0x0160: "R3000 (MIPS), big endian",
+            0x0162: "R3000 (MIPS), little endian",
+            0x0166: "R4000 (MIPS), little endian",
+            0x0168: "R10000 (MIPS), little endian",
+            0x0184: "DEC Alpha AXP",
+            0x01F0: "IBM Power PC, little endian"}
+        return cpu_name.get(self["cpu_type"], "unknow")
+
+class MS_Dos(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "msdos_header", "MS-Dos executable header", stream, parent, ">")
+        self.read("header", "File header", (FormatChunk, "string[2]"))
+        assert self["header"] == "MZ"
+        self.read("filesize_mod_512", "Filesize mod 512", (FormatChunk, "uint16"))
+        self.read("filesize_div_512", "Filesize div 512", (FormatChunk, "uint16"))
+        self.filesize = self["filesize_div_512"] * 512 + self["filesize_mod_512"]
+        self.read("reloc_entries", "Number of relocation entries", (FormatChunk, "uint16"))
+        self.read("code_offset", "Offset to the code in the file (div 16)", (FormatChunk, "<uint16"))
+        self.code_offset = self["code_offset"] * 16
+        self.read("needed_memory", "Memory needed to run (div 16)", (FormatChunk, "uint16"))
+        self.needed_memory = self["needed_memory"] * 16
+        self.read("max_memory", "Maximum memory needed to run (div 16)", (FormatChunk, "uint16"))
+        self.max_memory = self["max_memory"] * 16
+        self.read("init_ss_sp", "Initial value of SP:SS registers.", (FormatChunk, "uint32"))
+        self.read("checksum", "Checksum", (FormatChunk, "uint16"))
+        self.read("init_cs_ip", "Initial value of CS:IP registers.", (FormatChunk, "uint32"))
+        self.read("reloc_offset", "Offset in file to relocation table.", (FormatChunk, "<uint16"))
+        self.read("overlay_number", "Overlay number", (FormatChunk, "uint16"))
+        self.read("reserved", "Reserverd", (FormatChunk, "string[8]"))
+        self.read("oem_id", "OEM id", (FormatChunk, "uint16"))
+        self.read("oem_info", "OEM info", (FormatChunk, "uint16"))
+        self.read("reserved2", "Reserved", (FormatChunk, "string[20]"))
+        self.read("pe_offset", "Offset to PE header", (FormatChunk, "<uint32"))
+
+class ExeFile(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "exe_file", "EXE file", stream, parent, "<")
+
+        msdos = self.doRead("msdos_header", "MS-Dos header", (MS_Dos,))
+
+        if msdos["reloc_offset"] == 0x40:
+            # Read PE header
+            size = msdos["pe_offset"] - stream.tell()
+            self.read("msdos_code", "Padding", (FormatChunk, "string[%u]" % size))
+            self.pe = self.doRead("pe", "PE header", (PE_Header,))
+           
+            # Read PE optionnal header
+            self.read("pe_opt", "PE optionnal header", (PE_OptionnalHeader,))
+
+            # Read sections
+            sections = []
+            for i in range(0, self["pe"]["nb_sections"]):
+                section = self.doRead("pe_section[]", "PE section", (PE_Section,))
+                sections.append(section)
+
+            # TODO: Finish the code ... 
+#            for section in sections:
+#                if section.name == ".rsrc":
+#                    offset_res_section = section["file_offset"]
+#                    size = offset_res_section - stream.tell()
+#                    self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % size))
+#                    self.read("pe_resources", "PE resources", (PE_ResourceDirectory,))
+        else:
+            self.pe = None
+
+registerPlugin(ExeFile, ["application/x-dosexec", "application/x-ms-dos-executable"])

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-28 04:12:28 UTC (rev 370)
+++ haypo/hachoir/trunk/text_handler.py	2005-12-28 05:35:04 UTC (rev 371)
@@ -10,7 +10,10 @@
     day = (val >> 16) & 31            # 5 bits: day
     month = (val >> 21) & 15          # 4 bits: month
     year = 1980 + ((val >> 25) & 127) # 7 bits: year
-    return str(datetime.datetime(year, month, day, hour, min, sec))
+    try:
+        return str(datetime.datetime(year, month, day, hour, min, sec))
+    except:
+        return "invalid msdos datetime (%s)" % val
     
 def humanFilesize(chunk):
     return doHumanFilesize(chunk.value)



From haypo at berlios.de  Wed Dec 28 06:45:56 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 06:45:56 +0100
Subject: [Happyboom-svn] r372 - in haypo/hachoir/trunk: broken_plugins plugins
Message-ID: <200512280545.jBS5jutI010363@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 06:45:55 +0100 (Wed, 28 Dec 2005)
New Revision: 372

Added:
   haypo/hachoir/trunk/plugins/asn1.py
Removed:
   haypo/hachoir/trunk/broken_plugins/asn1.py
Log:
Upgrade ASN1 plugin to new synta


Deleted: haypo/hachoir/trunk/broken_plugins/asn1.py
===================================================================
--- haypo/hachoir/trunk/broken_plugins/asn1.py	2005-12-28 05:35:04 UTC (rev 371)
+++ haypo/hachoir/trunk/broken_plugins/asn1.py	2005-12-28 05:45:55 UTC (rev 372)
@@ -1,92 +0,0 @@
-"""
-ASN1 Parser
-
-Information: http://www.openssl.org/docs/apps/asn1parse.html
-
-Author: Victor Stinner
-"""
-
-from filter import Filter
-
-class ASN1_Sequence(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "asn1_seq", "ASN1 sequence", stream, parent)
-        self.readArray("item", ASN1_Object, "Items", self.checkEnd)
-
-    def checkEnd(self, stream, array, last):        
-        return stream.eof()
-
-class ASN1_Object(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "asn1_obj", "ASN1 object", stream, parent)
-        
-        import sys
-        sys.stdout.write("%s: " % stream.tell())
-        
-        self.read("type", "B", "type")
-        tag = self.type & 0x1f
-        if tag == 0x1f:
-            raise Exception("Error in ASN1 parser: TODO ...")
-        else:
-            length = stream.getFormat("B", False)[0]
-            if 128 <= length:
-                size = length & 0x7f 
-                length = 0
-                oldpos = stream.tell()
-                for i in range(0,size):
-                    stream.seek(oldpos+1+i)
-                    new = stream.getFormat("B", False)[0]
-                    length = length * 256 + new
-                    assert length < (1 << 32)
-                stream.seek(oldpos)
-                self.length = length
-                self.read("dummylength", "%uB" % (1+size), "Length")
-            else:
-                self.read("length", "B", "Length")
-            print "Length = %s" % self.length
-            self.getChunk("type").description = "type (tag=%s)" % tag
-            handler = {
-                0: self.readEOC,
-                1: self.readBoolean,
-                4: self.readOctetString,
-#                6: self.readObject,
-                10: self.readEnum,
-                12: self.readUTF8,
-                16: self.readSequence
-            }
-            if tag in handler:
-                handler[tag]()
-            else:
-                self.read("value", "%us" % length, \
-                    "Value (don't know tag %s)" % tag)
-
-    def readEnum(self):
-        self.read("value", "%us" % self.length, "Value (EOC)")
-
-    def readObject(self):
-        self.readChild("object", ASN1_Object)
-
-    def readEOC(self):
-        self.read("value", "%us" % self.length, "Value (EOC)")
-
-    def readOctetString(self):
-        self.read("value", "%us" % self.length, "Value (octet string)")
-
-    def readBoolean(self):
-        self.read("value", "B", "Value (boolean)")
-
-    def readUTF8(self):
-        self.read("value", "%us" % self.length, "Value (string)")
-        
-    def readSequence(self):
-        self.readLimitedChild("sequence", self.length, ASN1_Sequence)
-
-class ASN1_Parser(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "asn1", "ASN1 parser", stream, parent)
-        #self.readArray("item", ASN1_Object, "Items", self.checkEnd)
-        self.readChild("a", ASN1_Object)
-#        self.readChild("b", ASN1_Object)
-
-    def checkEnd(self, stream, array, last):        
-        return stream.eof()

Copied: haypo/hachoir/trunk/plugins/asn1.py (from rev 351, haypo/hachoir/trunk/broken_plugins/asn1.py)
===================================================================
--- haypo/hachoir/trunk/broken_plugins/asn1.py	2005-12-26 03:53:11 UTC (rev 351)
+++ haypo/hachoir/trunk/plugins/asn1.py	2005-12-28 05:45:55 UTC (rev 372)
@@ -0,0 +1,79 @@
+"""
+(Very experimental) ASN1 Parser
+
+Information: http://www.openssl.org/docs/apps/asn1parse.html
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+
+class ASN1_Sequence(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "asn1_seq", "ASN1 sequence", stream, parent)
+        while not stream.eof():
+            self.read("item[]", "Item", (ASN1_Object,))
+
+class ASN1_Object(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "asn1_obj", "ASN1 object", stream, parent)
+        self.read("type", "type", (FormatChunk, "uint8"))
+        tag = self.type & 0x1f
+        if tag == 0x1f:
+            raise Exception("Error in ASN1 parser: TODO ...")
+        else:
+            length = stream.getFormat("uint8", False)[0]
+            if 128 <= length:
+                size = length & 0x7f 
+                length = 0
+                oldpos = stream.tell()
+                for i in range(0,size):
+                    stream.seek(oldpos+1+i)
+                    new = stream.getFormat("uint8", False)[0]
+                    length = length * 256 + new
+                    assert length < (1 << 32)
+                stream.seek(oldpos)
+                self.length = length
+                self.read("dummylength", "Length", (FormatChunk, "string[%u]" % (1+size)))
+            else:
+                self.read("length", "Length", (FormatChunk, "uint8"))
+            self.getChunk("type").description = "type (tag=%s)" % tag
+            handler = {
+                0: self.readEOC,
+                1: self.readBoolean,
+                4: self.readOctetString,
+#                6: self.readObject,
+                10: self.readEnum,
+                12: self.readUTF8,
+                16: self.readSequence
+            }
+            if tag in handler:
+                handler[tag] ()
+            else:
+                self.read("value", "Value (don't know tag %s)" % tag, (FormatChunk, "string[%u]" % length))
+
+    def readEnum(self):
+        self.read("value", "Value (EOC)", (FormatChunk, "string[%u]" % self.length))
+
+    def readObject(self):
+        self.read("object", "Object", (ASN1_Object,))
+
+    def readEOC(self):
+        self.read("value", "Value (EOC)", (FormatChunk, "string[%u]" % self.length))
+
+    def readOctetString(self):
+        self.read("value", "Value (octet string)", (FormatChunk, "string[%u]" % self.length))
+
+    def readBoolean(self):
+        self.read("value", "Value (boolean)", (FormatChunk, "uint8"))
+
+    def readUTF8(self):
+        self.read("value", "Value (string)", (FormatChunk, "string[%u]" % self.length))
+        
+    def readSequence(self):
+        self.readLimitedChild("sequence", self.length, ASN1_Sequence)
+
+class ASN1_Parser(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "asn1", "ASN1 parser", stream, parent)
+        self.read("object", "Ojbect", (ASN1_Object,))



From haypo at berlios.de  Wed Dec 28 09:15:06 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 09:15:06 +0100
Subject: [Happyboom-svn] r373 - in haypo/hachoir/trunk: . plugins ui
Message-ID: <200512280815.jBS8F6xm000737@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 09:15:04 +0100 (Wed, 28 Dec 2005)
New Revision: 373

Removed:
   haypo/hachoir/trunk/broken_plugins/
Modified:
   haypo/hachoir/trunk/TODO
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/plugins/mp3.py
   haypo/hachoir/trunk/plugins/png.py
   haypo/hachoir/trunk/release.sh
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/hachoir.glade
   haypo/hachoir/trunk/ui/ui_window.py
Log:
- Create a lot of functions to manage bits: reverseBits, str2long, long2bin
- Disable user filter, popup menu, operations on filter and on chunks
- Fix release date
- Add flags parser in PNG plugin
- Improve chunk description in PNG plugin (thanks to updateParent())
- Fix escape key handler in UI (called function name was wrong)


Modified: haypo/hachoir/trunk/TODO
===================================================================
--- haypo/hachoir/trunk/TODO	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/TODO	2005-12-28 08:15:04 UTC (rev 373)
@@ -1,2 +1,5 @@
 List of TODO can be found which following command:
   grep TODO -A3 $(find -name "*.py")
+
+And count them using:
+  grep TODO $(find -name "*.py") | wc -l

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/chunk.py	2005-12-28 08:15:04 UTC (rev 373)
@@ -2,7 +2,7 @@
 import config
 from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsArray, formatIsInteger, formatIsArray
 from error import warning, error
-from tools import convertDataToPrintableString
+from tools import convertDataToPrintableString, str2long
 
 class Chunk(object):
     """
@@ -371,12 +371,14 @@
         return self._dict.get(value, "Unknow (%s)" % value)
 
 class BitsStruct(object):
-    def __init__(self, items=None):
+    def __init__(self, items=None, do_reverse=False):
         self._items_list = []
         self._items_dict = {}
         self._size = 0
         self._source = None
         if items != None:
+            if do_reverse:
+                items = reversed(items)
             for item in items:
                 if 3<len(item):
                     type = item[3]
@@ -411,13 +413,9 @@
         start = addr / 8
         mask = (1 << size) - 1
         byte_size = (size + (addr % 8) + 7) / 8
-        shift = (start+byte_size) * 8 - (size+addr)
+        shift = addr - start*8
         data = data[start:start+byte_size]
-        value = 0
-        for character in data:
-            value <<= 8
-            value += ord(character)
-#        print "%u..%u : " % (addr, addr+size), "bytes %u..%u : " % (start, start+byte_size), "shift=", shift, "mask=", mask, "value=", value, "final=",(value >> shift) & mask
+        value = str2long(data)
         value = (value >> shift) & mask
         if size == 1:
             return value == 1

Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/hachoir_class.py	2005-12-28 08:15:04 UTC (rev 373)
@@ -2,10 +2,12 @@
 from plugin import getPluginByStream
 from chunk import FilterChunk, FormatChunk
 from default import DefaultFilter
-from user_filter import UserFilterDescriptor, loadUserFilter
 from error import error, warning
 from mime import getStreamMime
 
+# TODO: Re-enable that :-)
+#from user_filter import UserFilterDescriptor, loadUserFilter
+
 class Hachoir:
     instance = None
     

Modified: haypo/hachoir/trunk/plugins/mp3.py
===================================================================
--- haypo/hachoir/trunk/plugins/mp3.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/plugins/mp3.py	2005-12-28 08:15:04 UTC (rev 373)
@@ -175,20 +175,13 @@
             (2, "layer", "MPEG audio layer"), # MP3_File.layer[self.layer]
             (1, "protection", "Protected?"))
         self.header = self.doRead("header", "Header", (BitsChunk, BitsStruct(bits)))
-        assert self.header["sync"] == 2047
+        #assert self.header["sync"] == 2047
 
-        if False:
-            bits = (
-                (1, "xxx", "???"),
-                (1, "padding", "Stream chunk use padding?"),
-                (2, "sampling_rate", "Sampling rate"),
-                (4, "bit_rate", "Bit rate"))
-        else:
-            bits = (
-                (4, "bit_rate", "Bit rate"),
-                (2, "sampling_rate", "Sampling rate"),
-                (1, "padding", "Stream chunk use padding?"),
-                (1, "xxx", "???"))
+        bits = (
+            (1, "extension", "Extension"),
+            (1, "padding", "Stream chunk use padding?"),
+            (2, "sampling_rate", "Sampling rate"),
+            (4, "bit_rate", "Bit rate"))
         self.rates = self.doRead("rates", "Rates and padding", (BitsChunk, BitsStruct(bits)))
 
         bits = (
@@ -199,8 +192,9 @@
             (2, "channel_mode", "Channel mode")) # MP3_File.channel_mode[channel_mode]
         self.various = self.doRead("various", "Channel mode, mode extension, copyright, original", (BitsChunk, BitsStruct(bits)))
 
+        # Get sampling rate
         version = self.header["version"]
-        layer = self.header["layer"]
+        layer = 4 - self.header["layer"]
         self.sampling_rate = MP3_File.sampling_rate[version][self.rates["sampling_rate"]]
 
         # Get bit rates
@@ -210,15 +204,20 @@
             rates = MP3_File.bit_rate[2] # MPEG2 / MPEG2.5
         self.bit_rate = rates[layer][self.rates["bit_rate"]]
 
+        # Calculate frame size
         frame_size = (144 * self.sampling_rate) / self.bit_rate + self.rates["padding"]
-        print "Frame size=%s" % frame_size
-        print "MPEG: %u bps, %s Hz" % (self.bit_rate, self.sampling_rate)
 
-#       TODO: :-)
+#       TODO: Read audio content
 #        size = ??? 
 #        self.read("content", "Content", (FormatChunk, "string[%u]" % size))
         
         size = stream.getSize() - stream.tell()
         self.read("end", "End", (FormatChunk, "string[%u]" % size))
+
+        #--- Display summary ---
+        print "MPEG version %s, layer %s" % \
+            (MP3_File.version[version], MP3_File.layer[layer])
+        print "  format: %u bps, %s Hz" % (self.bit_rate, self.sampling_rate)
+        print "  frame size=%s bytes" % frame_size
         
 registerPlugin(MP3_File, "audio/mpeg")

Modified: haypo/hachoir/trunk/plugins/png.py
===================================================================
--- haypo/hachoir/trunk/plugins/png.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/plugins/png.py	2005-12-28 08:15:04 UTC (rev 373)
@@ -6,7 +6,7 @@
 
 import datetime
 from filter import OnDemandFilter
-from chunk import FormatChunk, StringChunk
+from chunk import FormatChunk, StringChunk, EnumChunk, BitsStruct, BitsChunk
 from plugin import registerPlugin
 from text_handler import hexadecimal
 from generic.image import RGB
@@ -25,19 +25,40 @@
         OnDemandFilter.__init__(self, "header", "Header", stream, parent, "!")
         self.read("width", "Width (pixels)", (FormatChunk, "uint32"))
         self.read("height", "Height (pixels)", (FormatChunk, "uint32"))
-        self.read("bit_depth", "Bit depth", (FormatChunk, "uint8"))
-        self.read("color_type", "Color type", (FormatChunk, "uint8"))
+        self.read("bpp", "Bits per pixel", (FormatChunk, "uint8"))
+        bits = (
+            (1, "palette", "Palette used?"),
+            (1, "color", "Color used?"),
+            (1, "alpha", "Alpha channel used?"),
+            (5, "reserved", "(reserved)"))
+        self.read("color_type", "Color type", (BitsChunk, BitsStruct(bits)))
         self.read("compression", "Compression method", (FormatChunk, "uint8"))
         self.read("filter", "Filter method", (FormatChunk, "uint8"))
         self.read("interlace", "Interlace method", (FormatChunk, "uint8"))
 
+    def updateParent(self, chunk):
+        chunk.description = "Header: %ux%u pixels and %u bits/pixel" \
+            % (self["width"], self["height"], self["bpp"])
+
 class Physical(OnDemandFilter):
+    unit_name = {
+        0: "Unknow",
+        1: "Meter"
+    }
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "physical", "Physical", stream, parent, "!")
         self.read("pixel_per_unit_x", "Pixel per unit, X axis", (FormatChunk, "uint32"))
         self.read("pixel_per_unit_y", "Pixel per unit, Y axis", (FormatChunk, "uint32"))
-        self.read("unit_type", "Unit type", (FormatChunk, "uint8"))
+        self.read("unit", "Unit type", (EnumChunk, "uint8", Physical.unit_name))
 
+    def updateParent(self, chunk):
+        x = self["pixel_per_unit_x"]
+        y = self["pixel_per_unit_y"]
+        desc = "Physical: %ux%u pixels" % (x,y)
+        if self["unit"] == 1:
+            desc += " per meter"
+        chunk.description = desc 
+
 class Gamma(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "gamma", "Gamma", stream, parent, "!")
@@ -56,12 +77,12 @@
 class Time(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "time", "Time", stream, parent, "!")
-        self.read("year", "Year", [FormatChunk, "H"])
-        self.read("month", "Month", [FormatChunk, "uint8"])
-        self.read("day", "Day", [FormatChunk, "uint8"])
-        self.read("hour", "Hour", [FormatChunk, "uint8"])
-        self.read("minute", "Minute", [FormatChunk, "uint8"])
-        self.read("second", "Second", [FormatChunk, "uint8"])
+        self.read("year", "Year", (FormatChunk, "uint16"))
+        self.read("month", "Month", (FormatChunk, "uint8"))
+        self.read("day", "Day", (FormatChunk, "uint8"))
+        self.read("hour", "Hour", (FormatChunk, "uint8"))
+        self.read("minute", "Minute", (FormatChunk, "uint8"))
+        self.read("second", "Second", (FormatChunk, "uint8"))
 
     def updateParent(self, chunk):
         time = datetime.datetime(self["year"], self["month"], self["day"], self["hour"], self["minute"], self["second"])
@@ -77,8 +98,8 @@
         "tEXt": Text
     }
     name = {
-        "tIME": ("time", "Creation time"),
-        "pHYs": ("physical", "Physical informations"),
+        "tIME": ("time", "Time"),
+        "pHYs": ("physical", "Physical"),
         "IHDR": ("header", "Header"),
         "PLTE": ("palette", "Palette"),
         "gAMA": ("gamma", "Gamma"),
@@ -96,10 +117,11 @@
             oldpos = self._stream.tell()
             sub = stream.createLimited(size=size)
             handler = Chunk.handler[type]
-            self.read("data", "Data", (handler,), {"stream": sub, "size": size})
+            self.data = self.doRead("data", "Data", (handler,), {"stream": sub, "size": size})
             assert stream.tell() == (oldpos + size) 
         else:
-            self.read("data", "Data", [FormatChunk, "string[%u]" % self["size"]])
+            self.read("data", "Data", (FormatChunk, "string[%u]" % self["size"]))
+            self.data = None
         self.read("crc32", "CRC32", (FormatChunk, "uint32"), {"post": hexadecimal})
 
     def updateParent(self, chunk):
@@ -111,7 +133,16 @@
             type = name[1] 
         else:
             type = "Unknow (%s)" % type
-        chunk.description = "Chunk: %s" % type
+        if self.data:            
+            desc = "[Chunk] %s" % self.data.getDescription()
+        else:
+            desc = "[Chunk] %s" % type
+            type = self["type"]
+            if type == "IEND":
+                desc += ": end of file"
+            elif type == "IDAT":
+                desc += ": image data"
+        chunk.description = desc
 
 class PngFile(OnDemandFilter):
     def __init__(self, stream, parent=None):

Modified: haypo/hachoir/trunk/release.sh
===================================================================
--- haypo/hachoir/trunk/release.sh	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/release.sh	2005-12-28 08:15:04 UTC (rev 373)
@@ -1,5 +1,5 @@
 PACKAGE=hachoir
-VERSION=20051115
+VERSION=2005-12-28
 ARCHIVE=$PACKAGE-$VERSION.tar.bz2
 TMP_DIR=/tmp
 DIR=$PWD

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/tools.py	2005-12-28 08:15:04 UTC (rev 373)
@@ -1,21 +1,59 @@
 import traceback, sys, string, re
 
-def byte2bin(x):
+def reverseBits(x):
+    y = 0
+    for i in range(0,8):
+        mask = (1 << i)
+        if (x & mask) == mask:
+            y |= (1 << (7-i))
+    return y
+
+def str2long(data, reverse_byte=False):
+    """
+    Convert a string into a number with big endian order.
+    Eg. "\0\1\2" => 0x001020
+    """
+    shift = 0
+    value = 0
+    for character in data:
+        byte = ord(character)
+        if reverse_byte:
+            byte = reverseBits(byte)
+        value += (byte << shift) 
+        shift += 8
+    return value        
+
+
+def byte2bin(x, reverse=True):
     text = ""
     for i in range(0,8):
-        mask = 1 << (7-i)
+        if reverse:
+            mask = 1 << (7-i)
+        else:
+            mask = 1 << i
         if (x & mask) == mask:
             text += "1"
         else:
             text += "0"
     return text            
 
-def str2bin(value):
+def long2bin(value, reverse=True):
     text = ""
+    while (value != 0 or text == ""):
+        if text != "":
+            text += " "
+        byte = value & 0xFF            
+        text += byte2bin(byte, not reverse)
+        value >>= 8
+    return text        
+ 
+def str2bin(value, reverse=False):
+    text = ""
     for character in value:
         if text != "":
             text += " "
-        text += byte2bin(ord(character))
+        byte = ord(character)
+        text += byte2bin(byte, not reverse)
     return text
 
 def str2hex(value):

Modified: haypo/hachoir/trunk/ui/hachoir.glade
===================================================================
--- haypo/hachoir/trunk/ui/hachoir.glade	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/ui/hachoir.glade	2005-12-28 08:15:04 UTC (rev 373)
@@ -302,336 +302,257 @@
 	  <property name="enable_popup">False</property>
 
 	  <child>
-	    <widget class="GtkVBox" id="vbox8">
+	    <widget class="GtkTable" id="table5">
+	      <property name="border_width">6</property>
 	      <property name="visible">True</property>
+	      <property name="n_rows">3</property>
+	      <property name="n_columns">4</property>
 	      <property name="homogeneous">False</property>
-	      <property name="spacing">0</property>
+	      <property name="row_spacing">6</property>
+	      <property name="column_spacing">6</property>
 
 	      <child>
-		<widget class="GtkTable" id="table5">
-		  <property name="border_width">6</property>
+		<widget class="GtkLabel" id="label31">
 		  <property name="visible">True</property>
-		  <property name="n_rows">3</property>
-		  <property name="n_columns">4</property>
-		  <property name="homogeneous">False</property>
-		  <property name="row_spacing">6</property>
-		  <property name="column_spacing">6</property>
+		  <property name="label" translatable="yes">Name:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label31">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Name:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="filter_name">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="filter_name">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label32">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Decription:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label32">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Decription:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="filter_description">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="filter_description">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="filter_type">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="filter_type">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label39">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Type:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label39">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Type:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label28">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Stream:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label28">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Stream:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">2</property>
-		      <property name="right_attach">3</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="stream_size">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">3</property>
-		      <property name="right_attach">4</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="label29">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Size:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">2</property>
-		      <property name="right_attach">3</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="stream_type">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">3</property>
-		      <property name="right_attach">4</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="stream_size">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
 		</widget>
 		<packing>
-		  <property name="padding">0</property>
-		  <property name="expand">True</property>
-		  <property name="fill">True</property>
+		  <property name="left_attach">3</property>
+		  <property name="right_attach">4</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkHButtonBox" id="hbuttonbox3">
-		  <property name="border_width">6</property>
+		<widget class="GtkLabel" id="label29">
 		  <property name="visible">True</property>
-		  <property name="layout_style">GTK_BUTTONBOX_DEFAULT_STYLE</property>
-		  <property name="spacing">0</property>
+		  <property name="label" translatable="yes">Size:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkButton" id="info_filter_open">
-		      <property name="visible">True</property>
-		      <property name="can_default">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label">gtk-open</property>
-		      <property name="use_stock">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="on_toolbutton_open" last_modification_time="Thu, 01 Dec 2005 23:27:22 GMT"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="info_filter_save">
-		      <property name="visible">True</property>
-		      <property name="can_default">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label">gtk-save</property>
-		      <property name="use_stock">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="on_toolbutton_save" last_modification_time="Thu, 01 Dec 2005 23:27:31 GMT"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="info_filter_export">
-		      <property name="visible">True</property>
-		      <property name="can_default">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label">gtk-convert</property>
-		      <property name="use_stock">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="on_toolbutton_export" last_modification_time="Thu, 01 Dec 2005 23:29:48 GMT"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="info_filter_property">
-		      <property name="visible">True</property>
-		      <property name="can_default">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label">gtk-properties</property>
-		      <property name="use_stock">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="on_toolbutton_property" last_modification_time="Thu, 01 Dec 2005 23:22:25 GMT"/>
-		    </widget>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="stream_type">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
 		</widget>
 		<packing>
-		  <property name="padding">0</property>
-		  <property name="expand">True</property>
-		  <property name="fill">True</property>
+		  <property name="left_attach">3</property>
+		  <property name="right_attach">4</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 	    </widget>
@@ -964,19 +885,6 @@
 		      <signal name="clicked" handler="onChunkCopy" last_modification_time="Sun, 11 Dec 2005 08:45:53 GMT"/>
 		    </widget>
 		  </child>
-
-		  <child>
-		    <widget class="GtkButton" id="info_chunk_delete">
-		      <property name="visible">True</property>
-		      <property name="can_default">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="label">gtk-delete</property>
-		      <property name="use_stock">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="onDeleteChunk" last_modification_time="Thu, 01 Dec 2005 23:25:43 GMT"/>
-		    </widget>
-		  </child>
 		</widget>
 		<packing>
 		  <property name="padding">0</property>
@@ -1469,7 +1377,7 @@
 <widget class="GtkAboutDialog" id="about_dialog">
   <property name="visible">True</property>
   <property name="destroy_with_parent">True</property>
-  <property name="name" translatable="yes">Hachoir version 2005-10-30</property>
+  <property name="name" translatable="yes">Hachoir version 2005-12-28</property>
   <property name="copyright" translatable="yes">Copyright 2005 Victor Stinner</property>
   <property name="comments" translatable="yes">Split binary stream into filters and chunks ...</property>
   <property name="license" translatable="yes">Under GNU GPL licence</property>

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/trunk/ui/ui_window.py	2005-12-28 08:15:04 UTC (rev 373)
@@ -56,10 +56,10 @@
         self.hexa_path = xml.get_widget('hexa_path')
         self.hexa_content = xml.get_widget('hexa_content')
         self.menu_close = xml.get_widget('menu_close')
-        self.info_filter_open = xml.get_widget('info_filter_open')
-        self.info_filter_save = xml.get_widget('info_filter_save')
-        self.info_filter_export = xml.get_widget('info_filter_export')
-        self.info_filter_property = xml.get_widget('info_filter_property')
+#        self.info_filter_open = xml.get_widget('info_filter_open')
+#        self.info_filter_save = xml.get_widget('info_filter_save')
+#        self.info_filter_export = xml.get_widget('info_filter_export')
+#        self.info_filter_property = xml.get_widget('info_filter_property')
         self.info = InfoNotebook(xml)
         self.table = xml.get_widget('table')
         self.table_store = None
@@ -71,7 +71,6 @@
         
     def onChunkCopy(self, event):
         chunk = self.getActiveChunk()
-        print "Copy %s" % chunk
         assert chunk != None
         text = chunk.getStringValue()
         self.ui.getClipboard().set_text(text)
@@ -103,10 +102,10 @@
         if not file_present:
             self.toolbutton_parent.set_sensitive(False)
         self.toolbutton_close.set_sensitive(file_present)
-        self.info_filter_open.set_sensitive(filter_present)
-        self.info_filter_save.set_sensitive(filter_present)
-        self.info_filter_export.set_sensitive(filter_present)
-        self.info_filter_property.set_sensitive(filter_present)
+#        self.info_filter_open.set_sensitive(filter_present)
+#        self.info_filter_save.set_sensitive(filter_present)
+#        self.info_filter_export.set_sensitive(filter_present)
+#        self.info_filter_property.set_sensitive(filter_present)
         self.menu_close.set_sensitive(file_present)
 
     def getTableChunk(self, col):
@@ -115,6 +114,8 @@
         return self.ui.hachoir.getFilter().getChunk(chunk_id)
 
     def on_treeview_button_press_event(self, treeview, event):
+        return
+        # TODO: Re-enable popup menu :-)
         if event.button == 3:
             x = int(event.x)
             y = int(event.y)
@@ -156,7 +157,7 @@
 
     def onKeyUp(self, widget, key, data=None):
         if key.keyval == gtk.keysyms.Escape:
-            self.on_go_parent()
+            self.ui.on_go_parent()
         
     def onTableRowActivate(self, widget, iter, data=None):
         row = self.table_store[iter]
@@ -290,18 +291,7 @@
         path = chunk.getParent().getPath()+"/"+chunk.id
         self.ascii_path.set_text(path)
         raw = chunk.getRaw(config.max_ascii_length)
-        # TODO: Remove old code
-        if False:
-            # TODO: Use better str=>ascii code ...
-            content = ""
-            wrap = 16
-            while len(raw) != 0:
-                if len(content) != 0:
-                    content = content + "\n"
-                content = content + convertDataToPrintableString(raw[:wrap])
-                raw = raw[wrap:]
-        else:
-            content = convertDataToPrintableString(raw, True)
+        content = convertDataToPrintableString(raw, True)
         if config.max_hexa_length < chunk.size:
             if len(content) != 0:
                 content = content + "\n"



From haypo at berlios.de  Wed Dec 28 09:21:32 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 28 Dec 2005 09:21:32 +0100
Subject: [Happyboom-svn] r374 - haypo/hachoir/trunk/ui
Message-ID: <200512280821.jBS8LW7X001154@sheep.berlios.de>

Author: haypo
Date: 2005-12-28 09:21:31 +0100 (Wed, 28 Dec 2005)
New Revision: 374

Modified:
   haypo/hachoir/trunk/ui/hachoir.glade
Log:
Add missing hints in UI


Modified: haypo/hachoir/trunk/ui/hachoir.glade
===================================================================
--- haypo/hachoir/trunk/ui/hachoir.glade	2005-12-28 08:15:04 UTC (rev 373)
+++ haypo/hachoir/trunk/ui/hachoir.glade	2005-12-28 08:21:31 UTC (rev 374)
@@ -119,11 +119,14 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_open">
 		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Open a filter and apply it to this level</property>
+		  <property name="tooltip" translatable="yes">Open a new file</property>
 		  <property name="stock_id">gtk-open</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
 		  <property name="is_important">False</property>
+		  <accessibility>
+		    <atkproperty name="AtkObject::accessible_description" translatable="yes">Open a new file</atkproperty>
+		  </accessibility>
 		  <signal name="clicked" handler="on_toolbutton_new" last_modification_time="Thu, 01 Dec 2005 23:30:26 GMT"/>
 		</widget>
 		<packing>
@@ -135,6 +138,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_close">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Close current file</property>
 		  <property name="stock_id">gtk-close</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
@@ -181,6 +185,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_purge_cache">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Purge all caches</property>
 		  <property name="label" translatable="yes">Purge cache</property>
 		  <property name="use_underline">True</property>
 		  <property name="stock_id">gtk-clear</property>
@@ -863,6 +868,7 @@
 		  <child>
 		    <widget class="GtkButton" id="info_chunk_save">
 		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Save chunk content to a file</property>
 		      <property name="can_default">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="label">gtk-save</property>
@@ -876,6 +882,7 @@
 		  <child>
 		    <widget class="GtkButton" id="on_chunk_copy">
 		      <property name="visible">True</property>
+		      <property name="tooltip" translatable="yes">Copy chunk displayed value to clipboard</property>
 		      <property name="can_default">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="label">gtk-copy</property>
@@ -1025,6 +1032,7 @@
 	      <child>
 		<widget class="GtkButton" id="button3">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Read selected chunk content in display it as hexadecimal</property>
 		  <property name="can_focus">True</property>
 		  <property name="label">gtk-refresh</property>
 		  <property name="use_stock">True</property>
@@ -1171,6 +1179,7 @@
 	      <child>
 		<widget class="GtkButton" id="button4">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Read selected chunk content in display it as ASCII</property>
 		  <property name="can_focus">True</property>
 		  <property name="label">gtk-refresh</property>
 		  <property name="use_stock">True</property>



From haypo at berlios.de  Thu Dec 29 01:49:40 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 29 Dec 2005 01:49:40 +0100
Subject: [Happyboom-svn] r375 - in haypo/hachoir/trunk: . plugins
Message-ID: <200512290049.jBT0neJc028089@sheep.berlios.de>

Author: haypo
Date: 2005-12-29 01:49:11 +0100 (Thu, 29 Dec 2005)
New Revision: 375

Added:
   haypo/hachoir/trunk/plugins/wav.py
Modified:
   haypo/hachoir/trunk/NEWS
   haypo/hachoir/trunk/error.py
   haypo/hachoir/trunk/plugins/gzip.py
   haypo/hachoir/trunk/plugins/tar.py
Log:
- Create WAV plugin (based on AVI plugin)
- Add NEWS of 2005-12-28 release
- Fix Gzip plugin flags parser
- Don't display message box for warnings


Modified: haypo/hachoir/trunk/NEWS
===================================================================
--- haypo/hachoir/trunk/NEWS	2005-12-28 08:21:31 UTC (rev 374)
+++ haypo/hachoir/trunk/NEWS	2005-12-29 00:49:11 UTC (rev 375)
@@ -1,3 +1,16 @@
+News in version 2005-12-28
+    o Create EnumChunk: associate a string to a key (useful in a lot of
+      binary formats)
+    o Create BitsChunks: it's now possible to split bytes in bits (useful
+      for 'flags' fields)
+    o Use new syntax for all plugins: only use read() and doRead() methods,
+      new FormatChunk syntax (eg. "uint16" instead of "<H"), use OnDemandFilter
+      instead of Filter class (Filter was removed)
+    o Improve plugins display result using updateParent()
+    o Lot of small bugfixes in plugins
+    o Clean code (remove old useless code)
+    o Disable all operations (create / delete / edit) on filters and chunks
+
 News in version 2005-12-26
     o Some speed up:
       - use more caches (eg. for format operations like getting format size)

Modified: haypo/hachoir/trunk/error.py
===================================================================
--- haypo/hachoir/trunk/error.py	2005-12-28 08:21:31 UTC (rev 374)
+++ haypo/hachoir/trunk/error.py	2005-12-29 00:49:11 UTC (rev 375)
@@ -9,15 +9,15 @@
     if config.debug:
         message = log_message
     log.warning(log_message)   
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_WARNING,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()
+#    if ui.ui.ui != None:
+#        import gtk
+#        dlg = gtk.MessageDialog( \
+#            parent=ui.ui.ui.window.window,
+#            type=gtk.MESSAGE_WARNING,
+#            buttons=gtk.BUTTONS_OK,
+#            message_format=message)
+#        dlg.run()
+#        dlg.destroy()
 
 def error(message, backtrace=None):
     log_message = message + "\n\n" + getBacktrace()

Modified: haypo/hachoir/trunk/plugins/gzip.py
===================================================================
--- haypo/hachoir/trunk/plugins/gzip.py	2005-12-28 08:21:31 UTC (rev 374)
+++ haypo/hachoir/trunk/plugins/gzip.py	2005-12-29 00:49:11 UTC (rev 375)
@@ -39,19 +39,26 @@
         assert self["id"] == (31, 139)
         self.read("compression", "Compression method", (FormatChunk, "uint8"), {"post": self.getCompressionMethod})
         bits = (
-            (1, "text", "Text (?)"),
-            (1, "crc16", "CRC16"),
+            (1, "text", "File content is probably ASCII text"),
+            (1, "crc16", "Header CRC16"),
             (1, "extra", "Extra informations (variable size)"),
             (1, "filename", "Contains filename?"),
             (1, "comment", "Contains comment?"),
             (3, "unused", "Unused bits"))
         flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
         self.read("mtime", "Modification time", (FormatChunk, "uint32"), {"post": unixTimestamp})
-        self.read("extra", "Extra flags", (FormatChunk, "uint8"))
+
+        bits = (
+            (1, "unused", "(unused)"),
+            (1, "slowest", "Compressor used maximum compression (slowest)"),
+            (1, "fastest", "Compressor used the fastest compression"),
+            (5, "unused2", "(unused)"))
+        extra_flags = self.doRead("extra_flags", "Extra flags", (BitsChunk, BitsStruct(bits)))
+
         self.read("os", "Operating system", (EnumChunk, "uint8", GzipFile.os_name))
 
         # Optionnal fields
-        if self["extra"] & 4 == 4:
+        if flags["extra"] & 4 == 4:
             self.read("extra_length", "Extra length", (FormatChunk, "uint16"))
             self.read("extra", "Extra", (FormatChunk, "string[%u]"  % self["extra_length"]))
         if flags["filename"]:
@@ -59,7 +66,7 @@
         if flags["comment"]:
             self.read("comment", "Comment", (StringChunk, "C"))
         if flags["crc16"]:
-            self.read("crc16", "CRC16", (FormatChunk, "uint16"), post=hexadecimal)
+            self.read("hdr_crc16", "Header CRC16", (FormatChunk, "uint16"), post=hexadecimal)
 
         # Read content           
         oldpos = stream.tell()

Modified: haypo/hachoir/trunk/plugins/tar.py
===================================================================
--- haypo/hachoir/trunk/plugins/tar.py	2005-12-28 08:21:31 UTC (rev 374)
+++ haypo/hachoir/trunk/plugins/tar.py	2005-12-29 00:49:11 UTC (rev 375)
@@ -16,37 +16,6 @@
 from error import error
 from tools import getBacktrace, humanFilesize
 
-def displayModeItem(mode):
-    if mode & 4 == 4: r="r"
-    else: r="-"
-    if mode & 2 == 2: w="w"
-    else: w="-"
-    if mode & 1 == 1: x="x"
-    else: x="-"
-    return "%c%c%c" % (r, w, x)
-
-def displayMode(mode):
-    owner = displayModeItem(mode >> 6 & 7)
-    group = displayModeItem(mode >> 3 & 7)
-    other = displayModeItem(mode & 7)
-    print "Mode = %04o (%s%s%s)" % (mode, owner, group, other)
-    
-def displayFile(tar):
-    print "name = \"%s\"" % (tar.name)
-    displayMode(tar.mode)
-    print "User = \"%s\" (id %s)" % (tar.uname, tar.uid)
-    print "Group = \"%s\" (id %s)" % (tar.gname, tar.gid)
-    print "Size = %s bytes" % (tar.size)
-    print "Modification time = %s" % (tar.mtime)
-    print "Magic = %s" % (tar.magic)
-    print "Type = %s" % (tar.getType())
-    
-def displayTar(tar):
-    for file in tar.files:
-        file = file.getFilter()
-        print "[ File %s ]" % file.name
-        displayFile(file)
-
 class FileEntry(OnDemandFilter):
     type_name = {
         0: "Normal disk file (old format)",

Added: haypo/hachoir/trunk/plugins/wav.py
===================================================================
--- haypo/hachoir/trunk/plugins/wav.py	2005-12-28 08:21:31 UTC (rev 374)
+++ haypo/hachoir/trunk/plugins/wav.py	2005-12-29 00:49:11 UTC (rev 375)
@@ -0,0 +1,86 @@
+"""
+WAV audio file parser
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk
+
+class WAV_Fact(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "fact", "Stream length (\"fact\" chunk)", stream, parent, "<")
+        self.read("nb_samples", "Number of samples in audio stream", (FormatChunk, "int32"))
+
+class WAV_Format(OnDemandFilter):
+    codec_name = {
+        1: "Uncompressed"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "format", "Audio format", stream, parent, "<")
+        self.read("codec", "Audio codec", (EnumChunk, "int16", WAV_Format.codec_name))
+        self.read("channels", "Channels", (FormatChunk, "uint16"))
+        self.read("sample_per_sec", "Samples per second", (FormatChunk, "uint32"))
+        self.read("byte_per_sec", "Average bytes per second", (FormatChunk, "uint32"))
+        self.read("block_align", "Block align", (FormatChunk, "uint16"))
+        self.read("bits_per_sample", "Bits per sample", (FormatChunk, "uint16"))
+
+    def updateParent(self, chunk):
+        if self["channels"] == 2:
+            channels = "stereo"
+        else:
+            channels = "mono"
+        chunk.description = "Audio format: %u kHz, %s" \
+            % (self["sample_per_sec"], channels)
+
+class Chunk(OnDemandFilter):
+    handler = {
+        "fmt ": WAV_Format,
+        'fact': WAV_Fact
+    }
+
+    tag_name = {
+        "fmt ": "format",
+        "data": "audio_data"
+    }
+
+    tag_description = {
+        "fmt": "Audio format",
+        "data": "Audio stream data"
+    }
+
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "chunk", "Chunk", stream, parent, "<")
+        tag = self.doRead("tag", "Tag", (FormatChunk, "string[4]")).value
+        size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
+        if tag in Chunk.handler:
+            end = stream.tell() + size
+            sub = stream.createSub(size=size)
+            self.read("content", "Data content", (Chunk.handler[tag],), {"size": size, "stream": sub})
+            assert stream.tell() == end
+        else:
+            self.read("content", "Raw data content", (FormatChunk, "string[%u]" % size))
+
+    def updateParent(self, chunk):
+        tag = self["tag"].strip("\0")
+        type = Chunk.tag_description.get(tag, "\"%s\"" % tag)
+        if tag in Chunk.tag_name:
+            chunk.id = Chunk.tag_name[tag]
+        chunk.description = "Chunk: %s" % type
+
+class WavFile(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "wav_file", "WAV audio file", stream, parent, "<")
+        self.read("header", "RIFF header (\"RIFF\")", (FormatChunk, "string[4]"))
+        assert self["header"] == "RIFF"
+        self.read("filesize", "File size", (FormatChunk, "uint32"))
+        self.read("wave", "\"WAVE\" string", (FormatChunk, "string[4]"))
+        assert self["wave"] == "WAVE"
+        self.format = None
+        while not stream.eof():
+            id = self.read("chunk[]", "Chunk", (Chunk,))
+            if id == "format":
+                self.format = self["format"]
+
+registerPlugin(WavFile, "audio/x-wav")



From haypo at berlios.de  Thu Dec 29 02:54:58 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 29 Dec 2005 02:54:58 +0100
Subject: [Happyboom-svn] r376 - in haypo/hachoir/trunk: . generic plugins
Message-ID: <200512290154.jBT1swdT016902@sheep.berlios.de>

Author: haypo
Date: 2005-12-29 02:54:53 +0100 (Thu, 29 Dec 2005)
New Revision: 376

Added:
   haypo/hachoir/trunk/generic/win32.py
   haypo/hachoir/trunk/plugins/ico.py
Modified:
   haypo/hachoir/trunk/generic/image.py
   haypo/hachoir/trunk/mime.py
Log:
Add ICO picture plugin.


Modified: haypo/hachoir/trunk/generic/image.py
===================================================================
--- haypo/hachoir/trunk/generic/image.py	2005-12-29 00:49:11 UTC (rev 375)
+++ haypo/hachoir/trunk/generic/image.py	2005-12-29 01:54:53 UTC (rev 376)
@@ -1,6 +1,8 @@
 from chunk import FormatChunk
 from filter import OnDemandFilter
 
+# TODO: Merge RGB and RGBA classes? (same for Palette and PaletteRGBA)
+
 class RGB(OnDemandFilter):
     name = {
         0x000000: "Black",
@@ -28,3 +30,34 @@
         OnDemandFilter.__init__(self, "palette", "Palette of %u RGB colors" % count, stream, parent)
         for i in range(0, count):
             self.read("color[]", "Color", (RGB,))
+            
+class RGBA(OnDemandFilter):
+    name = {
+        0x000000: "Black",
+        0xFFFFFF: "White"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "rgb_color", "RGB color", stream, parent, "!")
+        self.read("red", "Red", (FormatChunk, "uint8"))
+        self.read("green", "Green", (FormatChunk, "uint8"))
+        self.read("blue", "Blue", (FormatChunk, "uint8"))
+        self.read("alpha", "Blue", (FormatChunk, "uint8"))
+
+    def getStaticSize(stream, args):
+        return 4
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        value = (self["red"] << 16) + (self["green"] << 8) + self["blue"]
+        desc = "RGBA color: "
+        if value in RGB.name:
+            desc += RGB.name[value]
+        else:
+            desc += "#%02X%02X%02X" % (self["red"], self["green"], self["blue"])
+        chunk.description = desc+", opacity=%u%%" % (self["alpha"]*100/256)
+
+class PaletteRGBA(OnDemandFilter):
+    def __init__(self, stream, parent, count):
+        OnDemandFilter.__init__(self, "palette", "Palette of %u RGBA colors" % count, stream, parent)
+        for i in range(0, count):
+            self.read("color[]", "Color", (RGBA,))

Added: haypo/hachoir/trunk/generic/win32.py
===================================================================
--- haypo/hachoir/trunk/generic/win32.py	2005-12-29 00:49:11 UTC (rev 375)
+++ haypo/hachoir/trunk/generic/win32.py	2005-12-29 01:54:53 UTC (rev 376)
@@ -0,0 +1,42 @@
+"""
+Windows (Win32) structures parsers.
+"""
+
+from filter import OnDemandFilter
+from chunk import FormatChunk, EnumChunk
+
+class BitmapInfoHeader(OnDemandFilter):
+    """ Win32 BITMAPINFOHEADER structure from GDI """
+
+    compression_name = {
+        0: "Uncompressed (RGB)",
+        1: "RLE (8 bits)",
+        2: "RLE (4 bits)",
+        3: "Bitfields",
+        4: "JPEG",
+        5: "PNG"
+    }
+    
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "icon_header3", "Icon header3", stream, parent, "<")
+        self.read("hdr_size", "Header size (in bytes) (=40)", (FormatChunk, "uint32"))
+        assert self["hdr_size"] == 40
+        self.read("width", "Width", (FormatChunk, "uint32"))
+        self.read("height", "Height", (FormatChunk, "uint32"))
+        self.read("planes", "Color planes", (FormatChunk, "uint16"))
+        assert self["planes"] == 1
+        self.read("bpp", "Bits/pixel", (FormatChunk, "uint16"))
+        self.read("compression", "Compression", (EnumChunk, "uint32", BitmapInfoHeader.compression_name))
+        self.read("size", "Image size (in bytes)", (FormatChunk, "uint32"))
+        self.read("xres", "X pixels per meter", (FormatChunk, "uint32"))
+        self.read("yres", "Y pixels per meter", (FormatChunk, "uint32"))
+        self.read("color_used", "Number of used colors", (FormatChunk, "uint32"))
+        self.read("color_important", "Number of important colors", (FormatChunk, "uint32"))
+
+    def getStaticSize(stream, args):
+        return 40 
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        chunk.description = "Bitmap info header: %ux%u pixels, %u bits/pixel" \
+            % (self["width"], self["height"], self["bpp"])

Modified: haypo/hachoir/trunk/mime.py
===================================================================
--- haypo/hachoir/trunk/mime.py	2005-12-29 00:49:11 UTC (rev 375)
+++ haypo/hachoir/trunk/mime.py	2005-12-29 01:54:53 UTC (rev 376)
@@ -14,6 +14,11 @@
 
 instance = None
 
+_mime_by_ext = {
+    '.gz':  'application/x-gzip',
+    '.ico': 'image/x-ico'
+}
+
 class GuessMime:
     def __init__(self):
         self.use_fallback = False
@@ -50,9 +55,8 @@
     return getBufferMime(buffer, filename)
 
 def getMimeByExt(ext):    
-    if ext == '.gz':
-        return 'application/x-gzip'
-    return None        
+    global _mime_by_ext
+    return _mime_by_ext.get(ext, None)
 
 def getStreamMime(stream, filename):
     oldpos = stream.tell()
@@ -74,6 +78,11 @@
     if buffer[:14] == "gimp xcf file\0":
         return "image/x-xcf"
 
+    if buffer[0:2] == "\0\0" \
+    and buffer[2:4] in ("\x01\0", "\x02\0") \
+    and buffer[9] == "\0":
+        return "image/x-ico"
+
     if buffer[0] == "\x0A" \
     and buffer[1] in "\x00\x02\x03\x04\x05" \
     and buffer[64] == "\0":

Added: haypo/hachoir/trunk/plugins/ico.py
===================================================================
--- haypo/hachoir/trunk/plugins/ico.py	2005-12-29 00:49:11 UTC (rev 375)
+++ haypo/hachoir/trunk/plugins/ico.py	2005-12-29 01:54:53 UTC (rev 376)
@@ -0,0 +1,71 @@
+"""
+ICO picture file format parser.
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk
+from generic.image import PaletteRGBA
+from generic.win32 import BitmapInfoHeader
+
+class IconData(OnDemandFilter):
+    def __init__(self, stream, parent, header):
+        OnDemandFilter.__init__(self, "icon_data", "Icon data", stream, parent, "<")
+        start = stream.tell()
+        self.read("header", "Header", (BitmapInfoHeader,))
+        
+        # Read palette if needed
+        nb_color = header["nb_color"]
+        if header["bpp"] == 8:
+            nb_color = 256
+        if nb_color != 0:            
+            self.read("palette", "Palette", (PaletteRGBA, nb_color))
+
+        # Read pixels
+        size = header["width"] * header["height"] * header["bpp"] / 8
+        self.read("pixels", "Image pixels", (FormatChunk, "string[%u]" % size))
+
+        padding = stream.getLastPos() - stream.tell() + 1
+        if 0 < padding:
+            self.read("padding", "(padding)", (FormatChunk, "string[%u]" % padding))
+
+class IconHeader(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "icon", "Icon header", stream, parent, "<")
+        self.read("width", "Width", (FormatChunk, "uint8"))
+        self.read("height", "Height", (FormatChunk, "uint8"))
+        self.read("nb_color", "Number of colors", (FormatChunk, "uint8"))
+        self.read("reserved", "(reserved)", (FormatChunk, "uint8"))
+        self.read("planes", "Color planes (=1)", (FormatChunk, "uint16"))
+        assert self["planes"] == 1
+        self.read("bpp", "Bits per pixel", (FormatChunk, "uint16"))
+        self.read("size", "Content size in bytes", (FormatChunk, "uint32"))
+        self.read("offset", "Data offset", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        chunk.description = "Icon: %ux%u pixels, %u bits/pixel" \
+            % (self["width"], self["height"], self["bpp"])
+
+class IcoFile(OnDemandFilter):
+    type_name = {
+        1: "Icon",
+        2: "Mouse cursor"
+    }
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "ico_file", "ICO picture file", stream, parent, "<")
+        self.read("id", "Identifier (\"\\0\\0\")", (FormatChunk, "string[2]"))
+        assert self["id"] == "\0\0"
+        self.read("type", "Resource type", (EnumChunk, "uint16", IcoFile.type_name))
+        self.read("nb_items", "Number of items", (FormatChunk, "uint16"))
+        items = []
+        for i in range(0, self["nb_items"]):
+            item = self.doRead("icon_header[]", "Icon header %u" % i, (IconHeader,))
+            items.append(item)
+        for header in items:
+            assert header["offset"] == stream.tell()
+            sub = stream.createLimited(size=header["size"])
+            self.read("icon_data[]", "Icon data", (IconData, header), {"stream": sub})
+
+registerPlugin(IcoFile, "image/x-ico")



From haypo at berlios.de  Thu Dec 29 14:35:27 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 29 Dec 2005 14:35:27 +0100
Subject: [Happyboom-svn] r377 - haypo/hachoir/trunk/plugins
Message-ID: <200512291335.jBTDZRq7002892@sheep.berlios.de>

Author: haypo
Date: 2005-12-29 14:35:25 +0100 (Thu, 29 Dec 2005)
New Revision: 377

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Worms2 plugin: improve sprite parser.


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-29 01:54:53 UTC (rev 376)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-29 13:35:25 UTC (rev 377)
@@ -47,82 +47,77 @@
         chunk.description = "Image: %ux%u pixels" % \
             (self["width"], self["height"])
 
+class SpriteItem(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "sprite_item", "Sprite item", stream, parent, "<")
+        self.read("a", "???", (FormatChunk, "uint8"))
+        self.read("b", "???", (FormatChunk, "uint16"))
+        self.read("c", "???", (FormatChunk, "uint8"))
+        self.read("x", "Offset X", (FormatChunk, "uint16"))
+        self.read("y", "Offset Y", (FormatChunk, "uint16"))
+        self.read("width", "Width", (FormatChunk, "uint16"))
+        self.read("height", "Height", (FormatChunk, "uint16"))
+
+    def updateParent(self, chunk):            
+        chunk.description = "Sprite item: %ux%u pixels at (%u,%u)" % \
+            (self["width"], self["height"], self["x"], self["y"])
+
 class Sprite(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
         name = parent.name
         self.read("palette", "Palette", (Palette, 81))
+        self.read("header116", "Header 116", (FormatChunk, "uint8"))
+        assert self["header116"] == 116 
+        self.read("type", "Type?", (FormatChunk, "uint8"))
+        self.read("zero[]", "???", (FormatChunk, "string[9]"))
+        self.read("flags[]", "???", (FormatChunk, "uint16"), {"post": binary})
+        self.read("zero[]", "???", (FormatChunk, "uint16"))
+        import re
+        marker = False
+        if re.match("^Tv", name) != None:
+            size = 2
+        elif re.match("^Holy", name) != None:
+            size = 26
+        elif re.match("^Banana", name) != None:
+            size = 29-15+2
+        elif re.match("^Homing", name) != None:
+            size = 29-15+3+8-1+2
+        elif re.match("^Marker", name) != None:
+            marker = True
+            size = 29+2-15 
+        else:
+            size = 29-15
+        flags = self.doRead("flags[]", "???", (FormatChunk, "uint16"), {"post": binary}).value
         if True:
-            self.read("header116", "Header 116", (FormatChunk, "uint8"))
-            assert self["header116"] == 116 
-            self.read("type", "Type?", (FormatChunk, "uint8"))
-            self.read("zero", "Zeros", (FormatChunk, "string[9]"))
-            assert self["zero"] == ("\0" * 9)
-            if False:
-                bits = (
-                    (1, "info1", ""),
-                    (1, "various1", ""),
-                    (1, "info2", ""),
-                    (3, "various2", ""),
-                    (3, "zero", ""),
-                    (3, "various3", ""),
-                    (1, "info3", ""),
-                    (1, "one", ""),
-                    (2, "various4", "")
-                )
-                flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
-                assert flags["zero"] == 0
-                assert flags["one"] == True
-            else:
-                self.read("flags", "???", (FormatChunk, "uint16"), {"post": binary})
-            self.read("zero2", "Zero2", (FormatChunk, "uint16"))
-            assert self["zero2"] == 0
-            import re
-            if re.match("^Tv", name) != None:
-                size = 2
-            elif re.match("^Holy", name) != None:
-                size = 26
-            elif re.match("^Banana", name) != None:
-                size = 29-15+2
-            elif re.match("^Homing", name) != None:
-                size = 29-15+3+8-1+2
-            elif re.match("^Marker", name) != None:
-                size = 29+2-15 
-            else:
-                size = 29-15
-            self.read("end_of_header", "End of mysterious header", (FormatChunk, "string[%u]" % size))
-            if True: 
-                self.x = self.doRead("offset_x[]", "Offset X", (FormatChunk, "uint16")).value
-                self.y = self.doRead("offset_y[]", "Offset Y", (FormatChunk, "uint16")).value
-                self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
-                self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
-                size = (self.width - self.x) * (self.height - self.y)
-                if size <= (stream.getLastPos() - stream.tell()+1-1):
-                    self.read("image_data[]", "Data", (FormatChunk, "string[%u]" % size))
-            else:
-                image = self.doRead("image[]", "Image", (ImageData,))
-                self.width = image.width
-                self.height = image.height
+            if flags != 0:
+                size = 12
+                if re.match("^Batrope", name) != None:
+                    size += 24
+                self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
+            self.x = self.doRead("x[]", "Offset X", (FormatChunk, "uint16")).value
+            self.y = self.doRead("y[]", "Offset Y", (FormatChunk, "uint16")).value
+            self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
+            self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
+            self.count = self.doRead("count", "Item count", (FormatChunk, "uint16")).value
+            for i in range(0, self.count):
+                self.read("item[]", "Item", (SpriteItem,))
+#                real_width = self.width - self.x
+#                real_height = self.height - self.y
+#                size = real_width * real_height
+#                if size <= (stream.getLastPos() - stream.tell()+1-1):
+#                    self.read("image_data[]", "Data (%ux%u pixels)" % (real_width, real_height), (FormatChunk, "string[%u]" % size))
 
-            #print "Sprite % 20s: x=%s, header=% 2s, header=%s | %s" \
-            #    % (name, x, size, str2bin(self["end_of_header"][:2]), str2hex(self["end_of_header"]))
-            #print "Sprite % 20s: a=%s, header=% 2s, header=%s" \
-            #    % (name, self["a"], size, str2hex(self["end_of_header"]))
-
-#            print "Sprite % 20s, a=%s, header=% 2s, flags=%s (%s), size=%ux%u at (%u,%u)" \
-#                % (name, self["a"], size, str2bin(self.getChunk("flags").getRaw()), self["flags"], width, height, x, y)
-
-        else:                
-            self.read("data", "Data", (FormatChunk, "string[40]"))
-            print "Sprite % 20s: %s" \
-                % (name, str2hex(self["data"]))
-            
         size = stream.getLastPos() - stream.tell() + 1
         self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):            
-        chunk.description = "Sprite: %ux%u pixels" % \
-            (self.width, self.height)
+        if self.count is not None:
+            chunk.description = "Animation: %ux%u pixels, %u frame(s)" % \
+                (self.width, self.height, self.count)
+        else:                
+            chunk.description = "Sprite: %ux%u pixels" % \
+                (self.width, self.height)
 
 class Font(OnDemandFilter):
     def __init__(self, stream, parent):



From haypo at berlios.de  Thu Dec 29 14:51:09 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 29 Dec 2005 14:51:09 +0100
Subject: [Happyboom-svn] r378 - haypo/hachoir/trunk/plugins
Message-ID: <200512291351.jBTDp9bt024433@sheep.berlios.de>

Author: haypo
Date: 2005-12-29 14:51:09 +0100 (Thu, 29 Dec 2005)
New Revision: 378

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Worms2: Improve mysterious size recognition


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-29 13:35:25 UTC (rev 377)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-29 13:51:09 UTC (rev 378)
@@ -71,45 +71,42 @@
         assert self["header116"] == 116 
         self.read("type", "Type?", (FormatChunk, "uint8"))
         self.read("zero[]", "???", (FormatChunk, "string[9]"))
-        self.read("flags[]", "???", (FormatChunk, "uint16"), {"post": binary})
+        self.read("flags_a", "???", (FormatChunk, "uint16"), {"post": binary})
         self.read("zero[]", "???", (FormatChunk, "uint16"))
+        flags_b = self.doRead("flags_b", "???", (FormatChunk, "uint16"), {"post": binary}).value
         import re
-        marker = False
-        if re.match("^Tv", name) != None:
-            size = 2
-        elif re.match("^Holy", name) != None:
-            size = 26
-        elif re.match("^Banana", name) != None:
-            size = 29-15+2
-        elif re.match("^Homing", name) != None:
-            size = 29-15+3+8-1+2
-        elif re.match("^Marker", name) != None:
-            marker = True
-            size = 29+2-15 
-        else:
-            size = 29-15
-        flags = self.doRead("flags[]", "???", (FormatChunk, "uint16"), {"post": binary}).value
-        if True:
-            if flags != 0:
-                size = 12
-                if re.match("^Batrope", name) != None:
-                    size += 24
-                self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
-            self.x = self.doRead("x[]", "Offset X", (FormatChunk, "uint16")).value
-            self.y = self.doRead("y[]", "Offset Y", (FormatChunk, "uint16")).value
-            self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
-            self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
-            self.count = self.doRead("count", "Item count", (FormatChunk, "uint16")).value
-            for i in range(0, self.count):
-                self.read("item[]", "Item", (SpriteItem,))
-#                real_width = self.width - self.x
-#                real_height = self.height - self.y
-#                size = real_width * real_height
-#                if size <= (stream.getLastPos() - stream.tell()+1-1):
-#                    self.read("image_data[]", "Data (%ux%u pixels)" % (real_width, real_height), (FormatChunk, "string[%u]" % size))
+        if flags_b != 0:
+            n = 1
+            if re.match("^Batrope", name) != None:
+                n = 3
+            elif re.match("^Homing", name) != None:
+                n = 2
+            elif re.match("^Sheep", name) != None:
+                n = 5
+            elif re.match("^Network", name) != None:
+                n = 18
+            size = n * 12
+            self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
+        self.x = self.doRead("x[]", "Offset X", (FormatChunk, "uint16")).value
+        self.y = self.doRead("y[]", "Offset Y", (FormatChunk, "uint16")).value
+        self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
+        self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
+        self.count = self.doRead("count", "Item count", (FormatChunk, "uint16")).value
+        for i in range(0, self.count):
+            self.read("item[]", "Item", (SpriteItem,))
+        if False:            
+            real_width = self.width - self.x
+            real_height = self.height - self.y
+            size = real_width * real_height
+            if size <= (stream.getLastPos() - stream.tell()+1-1):
+                self.read("image_data[]", "Data (%ux%u pixels)" % (real_width, real_height), (FormatChunk, "string[%u]" % size))
+        else:                
+            size = stream.getLastPos() - stream.tell() + 1
+            self.read("raw", "Raw data", (FormatChunk, "string[%u]" % size))
 
         size = stream.getLastPos() - stream.tell() + 1
-        self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+        if 0 < size:
+            self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):            
         if self.count is not None:



From haypo at berlios.de  Mon Dec 26 04:31:08 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 26 Dec 2005 04:31:08 +0100
Subject: [Happyboom-svn] r349 - in haypo/hachoir: . trunk
Message-ID: <200512260331.jBQ3V8dG013847@sheep.berlios.de>

Author: haypo
Date: 2005-12-26 04:31:06 +0100 (Mon, 26 Dec 2005)
New Revision: 349

Added:
   haypo/hachoir/tags/
   haypo/hachoir/trunk/
   haypo/hachoir/trunk/AUTHORS
   haypo/hachoir/trunk/BUGS
   haypo/hachoir/trunk/COPYING
   haypo/hachoir/trunk/ChangeLog
   haypo/hachoir/trunk/INSTALL
   haypo/hachoir/trunk/Makefile
   haypo/hachoir/trunk/README
   haypo/hachoir/trunk/bmp_filter.xml
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/config.py
   haypo/hachoir/trunk/default.py
   haypo/hachoir/trunk/error.py
   haypo/hachoir/trunk/export.template
   haypo/hachoir/trunk/fallback/
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/format.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/log.py
   haypo/hachoir/trunk/mime.py
   haypo/hachoir/trunk/ogg_page.xml
   haypo/hachoir/trunk/plugin.py
   haypo/hachoir/trunk/plugins/
   haypo/hachoir/trunk/program.py
   haypo/hachoir/trunk/release.sh
   haypo/hachoir/trunk/stream/
   haypo/hachoir/trunk/text_handler.py
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/
   haypo/hachoir/trunk/user_filter.py
Removed:
   haypo/hachoir/AUTHORS
   haypo/hachoir/BUGS
   haypo/hachoir/COPYING
   haypo/hachoir/ChangeLog
   haypo/hachoir/INSTALL
   haypo/hachoir/Makefile
   haypo/hachoir/README
   haypo/hachoir/bmp_filter.xml
   haypo/hachoir/chunk.py
   haypo/hachoir/config.py
   haypo/hachoir/default.py
   haypo/hachoir/error.py
   haypo/hachoir/export.template
   haypo/hachoir/fallback/
   haypo/hachoir/filter.py
   haypo/hachoir/format.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/log.py
   haypo/hachoir/mime.py
   haypo/hachoir/ogg_page.xml
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/
   haypo/hachoir/program.py
   haypo/hachoir/release.sh
   haypo/hachoir/stream/
   haypo/hachoir/text_handler.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui/
   haypo/hachoir/user_filter.py
Log:
Create subdirectories trunk and tags.


Deleted: haypo/hachoir/AUTHORS
===================================================================
--- haypo/hachoir/AUTHORS	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/AUTHORS	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-Aur?lien Jacobs - <aurel AT gnuage.org>
-Victor Stinner - <victor.stinner AT haypocalc.com>

Deleted: haypo/hachoir/BUGS
===================================================================
--- haypo/hachoir/BUGS	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/BUGS	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-- Set format to last chunk in a sub-filter doesn't work
-  (last chunk always converted to "!%ss" % padding)

Deleted: haypo/hachoir/COPYING
===================================================================
--- haypo/hachoir/COPYING	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/COPYING	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.

Deleted: haypo/hachoir/ChangeLog
===================================================================
--- haypo/hachoir/ChangeLog	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/ChangeLog	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-2005-10-20
-	- Creation of the project

Deleted: haypo/hachoir/INSTALL
===================================================================
--- haypo/hachoir/INSTALL	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/INSTALL	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,12 +0,0 @@
-To use Hachoir, you will need:
-- Python 2.2 (maybe 2.3 ?) 
-  http://www.python.org/
-- pyGTK 2.0 with Glade support
-  http://www.pygtk.org/
-- Python module "magic" (*)
-  (part of libmagic)
-- Python XML DOM extension ("xml.dom.ext")
-
-(*) If you don't have python module magic, download:
-      http://www.haypocalc.com/perso/prog/hachoir/magic.so.bz2
-    Decompress it and move it to Hachoir directory.

Deleted: haypo/hachoir/Makefile
===================================================================
--- haypo/hachoir/Makefile	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/Makefile	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,2 +0,0 @@
-clean:
-	rm -f *.pyc plugins/*.pyc hachoir.gladep *.bak

Deleted: haypo/hachoir/README
===================================================================
--- haypo/hachoir/README	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/README	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,10 +0,0 @@
-Hachoir
-=======
-
-Hachoir is a Python program which parse binary streams. It uses plugins
-to support new (file) formats using MIME type detection to choose right
-plugin. It can do uncompress bz2, gzip and deflate streams.
-
-If you had problems to install it, read INSTALL file.
-
-Website: http://www.haypocalc.com/wiki/Hachoir

Deleted: haypo/hachoir/bmp_filter.xml
===================================================================
--- haypo/hachoir/bmp_filter.xml	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/bmp_filter.xml	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,18 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<user_filter hachoir_version='2005-10-27' id='bmp_file' description='Bitmap picture file (BMP)'>
-  <chunk format='!2s' id='header' description='Header ("BM")'/>
-  <chunk format='&lt;L' id='file_size' description='File size (bytes)'/>
-  <chunk format='&lt;L' id='notused' description='Reseved'/>
-  <chunk format='&lt;L' id='data_start' description='Data start position'/>
-  <chunk format='&lt;L' id='header_size' description='Header size'/>
-  <chunk format='&lt;L' id='width' description='Width (pixels)'/>
-  <chunk format='&lt;L' id='height' description='Height (pixels)'/>
-  <chunk format='&lt;H' id='nb_plan' description='Number of plan (=1)'/>
-  <chunk format='&lt;H' id='bits_pixel' description='Bits per pixel'/>
-  <chunk format='&lt;L' id='compression' description='Compression method'/>
-  <chunk format='&lt;L' id='image_size' description='Image size (bytes)'/>
-  <chunk format='&lt;L' id='horizontal_dpi' description='Horizontal DPI'/>
-  <chunk format='&lt;L' id='vertical_dpi' description='Vertical DPI'/>
-  <chunk format='&lt;L' id='used_colors' description='Number of color used'/>
-  <chunk format='&lt;L' id='important_color' description='Number of import colors'/>
-</user_filter>

Deleted: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/chunk.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,377 +0,0 @@
-import struct, re, types
-import config
-from format import checkFormat, splitFormat, getFormatSize 
-from error import warning, error
-from tools import convertDataToPrintableString
-
-class Chunk(object):
-    def __init__(self, id, description, stream, addr, size, parent):
-        self._id = id
-        self.description = description
-        self._size = size
-        self._addr = addr
-        self._parent = parent
-        self._stream = stream
-        self.post_process = None
-        self.display = None
-
-    def clone(self):
-        raise Exception("%s doesn't implement clone() method!" % self)
-
-    def postProcess(self):        
-        if self.post_process != None:
-            self.display = self.post_process(self)
-
-    def getFormat(self):
-        return self.__class__.__name__
-
-    def getSmallFormat(self):
-        return self.__class__.__name__
-
-    def update(self):
-        self.display = None
-        self.postProcess()
-
-    def getStream(self):
-        return self._stream
-
-    def getStringValue(self):
-        value = self.getDisplayData()
-        if type(value) == types.TupleType:
-            return "(%s)" % ", ".join( map(str,value) )
-        else:
-            return "%s" % value
-
-    def getRaw(self, max_size=None):
-        oldpos = self._stream.tell()
-        self._stream.seek(self.addr)
-        size = self._size
-        if max_size != None and max_size<size:
-            size = max_size
-        data = self._stream.getN(size)
-        self._stream.seek(oldpos)
-        return data
-
-    def getValue(self, max_size=None):
-        return self.getRaw(max_size)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        else:
-            return self.getRaw(40)
-
-    def setParent(self, parent):
-        self._parent = parent
-    def getParent(self): return self._parent
-    def _setAddr(self, addr): self._addr = addr
-    def _getAddr(self): return self._addr
-    def _getSize(self): return self._size
-    def _getId(self): return self._id
-    def _setId(self, id):
-        if self._id == id: return
-        self._parent.updateChunkId(self, id)
-        self._id = id
-    addr = property(_getAddr, _setAddr)        
-    size = property(_getSize)        
-    id = property(_getId, _setId)
-    value = property(getValue)
-    raw = property(getRaw)
-    
-class FilterChunk(Chunk):
-    def __init__(self, id, filter, parent, parent_addr):
-        self._description = None
-        self.parent_addr = parent_addr
-        self._filter = filter
-        self._filter.filter_chunk = self
-        self._parent = None
-        Chunk.__init__(self, id, \
-            filter.getDescription(), filter.getStream(), filter.getAddr(), \
-            filter.getSize(), parent)
-        self._description = filter.getDescription()
-    
-    def clone(self, addr=None):
-        filter_copy = self._filter.clone(addr=addr)
-        # TODO: Is it always alright? (or use parent_addr = self.parent_addr)
-        parent_addr = addr
-        return FilterChunk(self.id, filter_copy, self.getParent(), parent_addr)
-    
-    def getFormat(self):
-        return self.__class__.__name__ + " (%s)" % self._filter.__class__.__name__
-
-    def getSmallFormat(self):
-        return self._filter.__class__.__name__
-
-    def update(self):
-        new = self._filter.clone()
-        if new != None:
-            self.setFilter(new)
-        Chunk.update(self)
-
-    def setFilter(self, filter):
-        self._filter = filter
-        self._filter.updateParent(self)
-    
-    def _setAddr(self, addr):
-        self._addr = addr
-        self._filter.setAddr(addr)
-    addr = property(Chunk._getAddr, _setAddr)        
-        
-    def _getSize(self):
-        return self._filter.getSize()
-    size = property(_getSize)        
-        
-    def getDisplayData(self):
-        return "(...)" 
-        
-    def getValue(self, max_size=None):
-        return self._filter
-    value = property(getValue)
-
-    def getFilter(self):
-        return self._filter
-
-    def _setId(self, id):
-        Chunk._setId(self, id)
-        self._filter.setId(id)
-    id = property(Chunk._getId, _setId)
-
-    def _getDescription(self):
-        return self._description
-    def _setDescription(self, description):
-        if self._description != None:
-            self._description = description
-            self._filter.setDescription(description)
-            self._parent.updateChunkDescription(self._id, description)
-    description = property(_getDescription, _setDescription)
-
-class StringChunk(Chunk):
-    regex_eol_nr = re.compile("[\n\r]")
-    names = {
-        "C": "c-string",
-        "MacLine": "mac line",
-        "UnixLine": "unix line",
-        "AutoLine": "line",
-        "Pascal16": "pascal16",
-        "Pascal32": "pascal32",
-        "WindowsLine": "windows line"
-    }
-
-    def __init__(self, id, description, stream, str_type, parent, strip=None):
-        """
-        Strip: if strip=None, call read text.strip()
-               if strip is a string, call read text.strip(self.strip)
-        """
-        assert str_type in StringChunk.names
-        Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
-        self._str_type = str_type
-        self.eol = None
-        self._findSize()
-        self._cache_addr = None
-        self._cache_max_size = None
-        self._cache_value = None
-        self.strip = strip
-
-    def getFormat(self):
-        return StringChunk.names[self._str_type]
-
-    def getSmallFormat(self):
-        return StringChunk.names[self._str_type]
-
-    def _findSize(self):
-        self._stream.seek(self.addr)
-        if self._str_type == "Pascal16":
-            self.length = self._stream.getFormat("!H")[0]
-            self._size = 2 + self.length
-            self.eol = ""
-            return
-        if self._str_type == "Pascal32":
-            self.length = self._stream.getFormat("!L")[0]
-            self._size = 4 + self.length
-            self.eol = ""
-            return
-            
-        if self._str_type == "AutoLine":
-            self._size = self._stream.searchLength(StringChunk.regex_eol_nr, True)
-            assert self._size != -1
-            self._stream.seek(self.addr + self._size-1)
-            self.eol = self._stream.getN(1)
-            if self.eol == "\r" and self._stream.read(1) == "\n":
-                self.eol = "\r\n"
-                self._size = self._size + 1
-            self.length = self._size - len(self.eol)
-            return
-
-        if self._str_type == "UnixLine":
-            self.eol = "\n"
-        elif self._str_type == "WindowsLine":
-            self.eol = "\r\n"
-        elif self._str_type == "MacLine":
-            self.eol = "\r"
-        else: 
-            self.eol = "\0"
-        self._size = self._stream.searchLength(self.eol, True)
-        assert self._size != -1
-        self.length = self._size - len(self.eol)
-        self._stream.seek(self.addr + self._size)
-        
-    def _read(self, max_size):
-        if self._cache_addr==self.addr and self._cache_max_size==max_size:
-            return self._cache_value
-        self._cache_addr = self.addr
-        self._cache_max_size = max_size
-
-        self._stream.seek(self.addr)
-        if self._str_type == "Pascal32":
-            self._stream.seek(4,1)
-            size = self.length
-        elif self._str_type == "Pascal16":
-            self._stream.seek(2,1)
-            size = self.length
-        else:
-            size = self._size - len(self.eol)
-        if max_size != None and max_size<size:
-            text = self._stream.getN(max_size)+"(...)"
-        else:
-            text = self._stream.getN(size)
-        self._stream.seek(self.addr + self._size)
-        if self.strip != None:
-            if self.strip == True:
-                text = text.strip()
-            else:
-                text = text.strip(self.strip)
-        self._cache_value = text
-        return text
-
-    def update(self):
-        Chunk.update(self)
-        self._findSize()
-
-    def getValue(self, max_size=None):
-        return self._read(None)
-    value = property(getValue)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        else:
-            text = self._read(config.max_string_length)
-            return convertDataToPrintableString(text)
-        
-class FormatChunk(Chunk):
-    regex_sub_format = re.compile(r'\{([^}]+)\}')
-
-    def __init__(self, id, description, stream, addr, format, parent):
-        Chunk.__init__(self, id, description, stream, addr, None, parent)
-        self._format = None
-        self._doSetFormat(format)
-
-    def _doSetFormat(self, format):
-        if format == self._format:
-            return
-        self._format = format
-        self._is_string = self.isString()
-        if not self._is_string:
-            count = splitFormat(self._format)[1]
-            self._is_array = (count != 1)
-        else:
-            self._is_array = False
-        self._size = getFormatSize(self._format)
-        self._value = {}
-       
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self._addr
-        return FormatChunk(self.id, self.description, self._stream, addr, self._format, self._parent)
-
-    def _setAddr(self, addr):
-        self._addr = addr
-        self._value = {}
-    addr = property(Chunk._getAddr, _setAddr)
-
-    def getFormat(self):
-        return self.__class__.__name__ + " (%s)" % self._format
-
-    def getSmallFormat(self):
-        return self._format
-
-    def isString(self):
-        return self._format[-1] == "s"
-
-    def convertToStringSize(self, size):
-        self._doSetFormat("%us" % size)
-
-    def setFormat(self, format, method, new_id=None, new_description=None):
-        """ Method:
-        - split => create new raw array if chunk is smaller
-        - rescan => if size changed, rescan chunks"""
-
-        # Check format
-        if not checkFormat(format):
-            raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
-        
-        # Check new size
-        size = getFormatSize(format)
-        if self._stream.getLastPos() < (self.addr + size - 1):
-            raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
-
-        # Update format
-        old_size = self._size
-        self._doSetFormat(format)
-        new_size = self._size
-        diff_size = new_size - old_size
-
-        # Update id and description
-        old_id = self.id
-        if new_id != None:
-            new_id = self.getParent().getUniqChunkId(new_id)
-            self.id = new_id
-        old_description = self.description
-        if new_description != None:
-            self.description = new_description
-
-        # Update filter if needed
-        if diff_size != 0:
-            if method == "split" and diff_size < 0:
-                self._parent.addRawChunk(self, old_id, -diff_size, old_description)
-            else:
-                self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description, truncate=True)
-        self._parent.updateFormatChunk(self)
-
-    def _getRawData(self, max_size=None):
-        oldpos = self._stream.tell()
-        self._stream.seek(self._addr)
-        if (max_size == None or self._size<=max_size) or not self._is_string:
-            data = self._stream.getN(self._size, False)
-            self._stream.seek(oldpos)
-            return data, False
-        else:
-            data = self._stream.getN(max_size, False)
-            self._stream.seek(oldpos)
-            return data, True
-
-    def getRaw(self, max_size=None):
-        return self._getRawData(max_size)[0]
-    raw = property(getRaw)
-   
-    def getValue(self, max_size=None):
-        if max_size not in self._value:
-            data, truncated = self._getRawData(max_size)
-            if not truncated:
-                data = struct.unpack(self._format, data)
-                if not self._is_array:
-                    data = data[0]
-            else:
-                data = data + "(...)"
-            self._value[max_size] = data
-        return self._value[max_size]
-    value = property(getValue)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        data = self.getValue(config.max_string_length)
-        if type(data)==types.StringType:
-            return convertDataToPrintableString(data)
-        else:
-            return data 

Deleted: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/config.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,5 +0,0 @@
-max_string_length = 10
-max_hexa_length = 4096 
-max_ascii_length = 4096 
-debug = False
-verbose = False

Deleted: haypo/hachoir/default.py
===================================================================
--- haypo/hachoir/default.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/default.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,10 +0,0 @@
-from filter import Filter
-
-class EmptyFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "empty", "Empty filter", stream, parent)
-
-class DefaultFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "default", "Default filter", stream, parent)
-        self.read("data", "%us" % stream.getSize(), "Data")

Deleted: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/error.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,33 +0,0 @@
-import os
-import config
-from log import log
-import ui.ui
-from tools import getBacktrace
-
-def warning(message):
-    if config.debug:
-        message = message + "\n\n" + getBacktrace()
-    log.warning(message)   
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_WARNING,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()
-
-def error(message, backtrace=None):
-    if config.debug:
-        message = message + "\n\n" + getBacktrace()
-    log.error(message)
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_ERROR,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()

Deleted: haypo/hachoir/export.template
===================================================================
--- haypo/hachoir/export.template	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/export.template	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,16 +0,0 @@
-"""
-Exported filter.
-
-Description:
-{description}
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class MyFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "{id}", "{description}", stream, parent)
-{chunks}
-
-#registerPlugin(MyFilter, "")

Deleted: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/filter.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,689 +0,0 @@
-"""
-Base class for all splitter filters.
-"""
-
-import struct, re, sys, string, types
-import config
-import ui.ui as ui
-from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
-from error import error
-from tools import getBacktrace
-from format import getFormatSize
-
-class BasicFilter:
-    def __init__(self, id, description, stream, parent, addr):
-        self._id = id
-        self._description = description
-        self._stream = stream
-        self._parent = parent
-        self._addr = addr 
-        self._chunks_counter = {}
-        self._chunks_dict = {}
-
-    def updateParent(self, chunk): pass
-    def getId(self): return self._id
-    def setId(self, id): self._id = id
-    def getDescription(self): return self._description
-    def setDescription(self, description): self._description = description
-    def getAddr(self): return self._addr
-    def setAddr(self, addr): self._addr = addr
-    def getParent(self): return self._parent
-    def getStream(self): return self._stream
-    def purgeCache(self): pass
-    def updateChunkDescription(self, id, desc): pass
-    def __len__(self): return len(self._chunks_dict)
-
-    def getPath(self):
-        """
-        Get path to the filter.
-        Example: "grandparent > parent > item"
-        """
-        text = ""
-        current = self
-        while current != None:
-            if text != "": text = "/" + text
-            text = current.getId() + text
-            current = current.getParent()
-        return "/"+text
-
-    def _getUniqChunkId(self, root, index):
-        if root in self._chunks_counter:
-            self._chunks_counter[root] = self._chunks_counter[root] + 1
-        else:
-            self._chunks_counter[root] = index
-        return self._chunks_counter[root]
-
-    def getUniqChunkId(self, id):
-        # No collision
-        if id not in self._chunks_dict and id[-2:] != "[]":
-            return id
-
-        # Pattern like "block[]"
-        if id[-2:] == "[]":
-            root = id[:-2]
-            start = 0
-            pattern = "%s[%u]"
-        else:
-            # Manage id collision
-            m = Filter.regex_chunk_uniq_id.match(id)
-            if m != None:
-                root = m.group(1)
-                start = int(m.group(2)) + 1
-            else:
-                root = id
-                start = 2
-            pattern = "%s%u"
-        if root in self._chunks_counter:
-            self._chunks_counter[root] = self._chunks_counter[root] + 1
-        else:
-            self._chunks_counter[root] = start 
-        return pattern % (root, self._chunks_counter[root])
-        
-    def hasChunk(self, id):
-        return id in self._chunks_dict
-
-    # --- Pure virtual methods -----------
-    def getSize(self): assert False
-    def __getitem__(self, chunk_id): assert False
-    def getChunk(self, chunk_id): assert False
-    def display(self): assert False
-
-class OnDemandFilter(BasicFilter):
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self._size = 0
-        self._chunks = []
-        self._chunks_cache = {}
-    
-    def updateChunkDescription(self, id, desc):
-        pos = self._chunks.index(id)
-        assert pos != -1
-        self._chunks_dict[id][1] = desc
-
-        info = self.displayChunkInfo(id)
-        ui.window.update_table(self, pos, *info)
-
-    def purgeCache(self):
-        if len(self._chunks_cache) != 0:
-            print "Purge cache: destroy %s chunks" % len(self._chunks_cache)
-        self._chunks_cache = {}
-        
-    def doReadChild(self, id, description, filter_class, *args):
-        id = self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        return self.getChunk(id)
-        
-    def readChild(self, id, description, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        
-    def readSizedChild(self, id, description, size, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, size, filter_class, *args)
-        
-    def readStreamChild(self, id, description, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, None, filter_class, *args)
-
-    def readSizedStreamChild(self, id, description, size, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, size, filter_class, *args)
-
-    def _readStreamChild(self, id, description, filter_stream, size, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
-        filter_addr = filter_stream.tell()
-        
-        if size == None:
-            filter = filter_class(filter_stream, self, *args)
-            description = filter.getDescription()
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            size = filter.getSize()
-            if config.verbose:
-                print "%s: Instanciate filter %s" % (self.getPath(), id)
-        else:
-            chunk = None
-
-        chunk_info = [id, description, addr, size, \
-                (filter_class, filter_stream, filter_addr, args), None, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        if chunk != None:
-            filter.updateParent(chunk)
-            self._chunks_cache[id] = chunk
-        self._size = self._size + size
-        self._stream.seek(addr + size)
-        return id
-
-    def doRead(self, id, format, description, post=None):
-        id = self.read(id, format, description, post)
-        return self.getChunk(id)
-
-    def read(self, id, format, description, post=None):
-        id = self.getUniqChunkId(id)
-        size = getFormatSize(format)
-        addr = self._stream.tell()
-        chunk_info = [id, description, addr, size, \
-                (FormatChunk, id, description, self._stream, addr, format, self,), post, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
-
-    def readString(self, id, format, description, post=None, strip=None):
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
-
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        size = chunk.size
-
-        chunk_info = [id, description, addr, size, \
-                (StringChunk, id, description, self._stream, format, self,), post, {"strip": strip}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._chunks_cache[id] = chunk
-#        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
-
-    def displayChunkInfo(self, id):
-        info = self._chunks_dict[id]
-        chunk_class = info[4][0]
-        if issubclass(chunk_class, BasicFilter):
-            display = "(...)"
-            format = chunk_class.__name__
-        else:
-            chunk = self.getChunk(id)
-            display = chunk.getDisplayData()
-            format = chunk.getSmallFormat()
-        addr = info[2]
-        size = info[3]
-        return (None, addr, size, format, info[0], info[1], display)
-
-    def display(self):
-        ui.window.enableParentButton(self.getParent() != None)
-        ui.window.clear_table()
-        for id in self._chunks:
-            info = self.displayChunkInfo(id)
-            ui.window.add_table(*info)
- 
-    def getSize(self): return self._size
-
-    def _createInstance(self, id):
-        addr = self._chunks_dict[id][2]
-        desc = self._chunks_dict[id][4]
-        post = self._chunks_dict[id][5]
-        chunks_kw = self._chunks_dict[id][6]
-        oldpos = self._stream.tell()
-        self._stream.seek(addr)
-        if config.verbose:
-            print "%s: Instanciate %s (of type %s)" % (self.getPath(), id, desc[0].__name__)
-        if not issubclass(desc[0], BasicFilter):
-            chunk_class = desc[0]
-            chunk_args = desc[1:]
-            chunk = chunk_class(*chunk_args, **chunks_kw)
-            if post != None:
-                chunk.display = post(chunk)
-        else:
-            filter_stream = desc[1]
-            if filter_stream != self._stream:
-                filter_stream.seek(desc[2])
-            filter = desc[0] (filter_stream, self, *desc[3])
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            if filter.getDescription() != desc[1]:
-                self.updateChunkDescription(id, filter.getDescription())
-            filter.updateParent(chunk)
-        self._stream.seek(oldpos)
-        return chunk
-
-    def getChunk(self, id):
-        if id not in self._chunks_dict:
-            return None
-        if id not in self._chunks_cache:
-            self._chunks_cache[id] = self._createInstance(id) 
-        return self._chunks_cache[id]
-
-    def __getitem__(self, id):
-        assert id in self._chunks_dict
-        chunk = self.getChunk(id)
-        if isinstance(chunk.__class__, FilterChunk):
-            return chunk.getFilter()
-        else:
-            return chunk.value
-
-class Filter(BasicFilter):
-    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
-
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self.filter_chunk = None 
-        self._chunks = []
-        self._chunks_dict = {}
-        self._cache_valid = False
-        self._cache_size = None
-
-    def __getitem__(self, chunk_id):
-        return self.getChunk(chunk_id).getValue()
-
-    def clone(self, addr=None):
-        if self.__class__ == Filter:
-            return None
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        try:
-            new = self.__class__(self.getStream(), self.getParent())
-        except:
-            error("Error while clone class of type %s!" % self.__class__)
-            raise
-        new.filter_chunk = self.filter_chunk
-        return new
-
-    def _deleteChunk(self, pos):
-        self._cache_valid = False
-        chunk = self._chunks[pos]
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)        
-        del self._chunks[pos]
-
-    def deleteChunk(self, chunk):
-        if len(self._chunks) < 2:
-            error("Can't not delete the chunk %s (there is only one chunk)." % chunk.id)
-            return            
-        chunk_size = chunk.size
-        pos = self._chunks.index(chunk)
-        self._deleteChunk(pos)
-        # Delete last chunk of a sub filter? It true, truncate the sub filter
-        truncate = (self.getParent() != None and pos == len(self._chunks))
-        self.rescanFromPos(pos, -chunk_size, truncate=truncate)
-        self.redisplay()
-
-    def getChunks(self):
-        return self._chunks
-
-    def updateChunkId(self, chunk, new_id):
-        if chunk.id == new_id: return
-        if new_id in self._chunks_dict or hasattr(self, new_id):
-            raise Exception("Chunk identifier \"%s\" already exist!" % new_id)
-        if hasattr(self, chunk.id):
-            value = getattr(self, chunk.id)
-            delattr(self, chunk.id)
-            setattr(self, new_id, value)
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        self._chunks_dict[new_id] = chunk
-        
-    def addRawChunk(self, prev_chunk, id, size, description):
-        if prev_chunk != None:
-            addr = prev_chunk.addr + prev_chunk.size
-            chunk_pos = self._chunks.index(prev_chunk)+1
-        else:
-            addr = self.getAddr()
-            chunk_pos = len(self._chunks)
-        chunk = FormatChunk(id, description, self.getStream(), addr, "!%ss" % size, self)
-        self.appendChunk(chunk, position=chunk_pos)
-
-    def rescan(self, from_chunk, diff_size, new_id=None, new_description=None, truncate=False):
-        if from_chunk != None:
-            start = self._chunks.index(from_chunk)+1
-        else:
-            start = 0
-        self.rescanFromPos(start, diff_size, new_id, new_description, truncate)
-            
-    def _rescanUpdateSize(self, diff_size, new_id=None, new_description=None):
-        # Only process diff_size < 0
-        if 0 <= diff_size: return
-
-        # Get last chunk
-        if 0 < len(self._chunks):
-            prev_chunk = self._chunks[-1]
-        else:
-            prev_chunk = None
-        
-        if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
-            # If last chunk is a FormatChunk, update it's size
-            size = prev_chunk.size - diff_size
-            prev_chunk.convertToStringSize(size)
-            self._cache_valid = False
-        else:
-            # Get id
-            if new_id != None:
-                id = new_id
-            else:
-                id = "raw"
-            id = self.getUniqChunkId(id)
-
-            # Get description
-            if new_description != None:
-                description = new_description
-            else:
-                description = ""
-
-            # Get size
-            if self.getParent() == None:
-                size = self._stream.getSize() - self.getSize() 
-            else:
-                size = -diff_size
-            self.addRawChunk(prev_chunk, id, size, description)
-
-    def _rescanUpdateChunks(self, start, prev_chunk):
-        self._cache_valid = False
-        pos = start
-        try:
-            for chunk in self._chunks[start:]:
-                # Update start address
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error("Exception while updating a filter:\n%s\n%s" \
-                % (msg,getBacktrace()))
-            iter = len(self._chunks)-1
-            while pos<=iter:
-                self._deleteChunk(iter)
-                iter = iter - 1
-
-    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate=False):
-        assert 0<=start and start <= len(self._chunks)
-        self._cache_valid = False
-        if 0<start:
-            prev_chunk = self._chunks[start-1]
-        else:
-            prev_chunk = None
-
-        # Update chunks address
-        old_size = self.getSize()
-        self._rescanUpdateChunks(start, prev_chunk)
-        diff_size = diff_size + (self.getSize() - old_size)
-
-        # Update last chunk size if needed
-        if not truncate:
-            self._rescanUpdateSize(diff_size, new_id, new_description)
-            diff_size = 0
-               
-        if self.getParent() != None:
-            self.getParent().rescan(self.filter_chunk, diff_size)
-
-    def getLastPos(self):
-        if len(self._array) == 0: return self.getAddr()
-        last_chunk = self._array[-1]
-        return last_chunk.addr + last_chunk.size
-
-    def getSize(self):
-        if not self._cache_valid:
-            self._cache_valid = True
-            size = 0
-            for chunk in self._chunks:
-                size = size + chunk.size
-            self._cache_size = size
-        return self._cache_size
-
-    def addString(self, str_type, before_chunk):
-        if before_chunk != None:
-            pos = self._chunks.index(before_chunk)
-            addr = before_chunk.addr
-        else:
-            pos = len(self._chunks)
-            addr = self.getAddr()
-        stream = self.getStream()
-        stream.seek(addr)
-        id = self.getUniqChunkId("str")
-        str_chunk = StringChunk(id, "String", stream, str_type, self)
-        self.appendChunk(str_chunk, position=pos)
-        str_chunk.postProcess()
-        before_chunk.addr = before_chunk.addr + str_chunk.size
-        before_chunk.convertToStringSize(before_chunk.size - str_chunk.size)
-        self.redisplay()
-        return str_chunk
-
-    def updateParent(self, chunk):
-        pass
-
-    def getChunk(self, chunk_id):
-        chunk = self._chunks_dict.get(chunk_id, None)
-        if chunk == None:
-            raise Exception("Filter \"%s\" has no chunk with id \"%s\"." \
-                % (self.getId(), chunk_id))
-        return chunk
-
-    def displayChunk(self, chunk):
-        type = chunk.getSmallFormat()
-        if isinstance(chunk, FilterChunk):
-            addr = chunk.parent_addr
-        else:
-            addr = chunk.addr
-        ui.window.add_table(None, addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
-
-    def redisplay(self):  
-        self.display()
-    
-    def display(self):  
-        ui.window.enableParentButton(self.getParent() != None)
-            
-        # Update table
-        ui.window.clear_table()
-        for chunk in self._chunks:
-            self.displayChunk(chunk)
-
-    def readField(self, id, description, delimiter):
-        lg = self._stream.searchLength(delimiter, False)
-        if lg == -1:
-            raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
-        self.read(id, "!%us" % lg, description) 
-        self.read(id+"_delimiter", "!%us" % len(delimiter), "Delimiter of %s" % id) 
-
-    def searchEol(self, eol):
-        lg = self._stream.searchLength(eol, True)
-        if lg == -1:
-            return self._stream.getLastPos() - self._stream.tell()
-        else:
-            return lg
-
-    def readLine(self, id, description, eol="\n", fails_if_not_found=False, can_truncate=False):
-        lg = self.searchEol(eol)
-        self.read(id, "!%us" % lg, description, truncate=can_truncate)
-        line = getattr(self, id)
-        setattr(self, id, line[:-len(eol)])
-
-    def updateFormatChunk(self, chunk):
-        if chunk.id == None: return
-        self._cache_valid = False
-        data = chunk.getValue(config.max_string_length)
-        setattr(self, chunk.id, data)       
-
-    def appendChunk(self, chunk, position=None):
-        self._cache_valid = False
-        if position == None:
-            self._chunks.append(chunk)
-        else:
-            self._chunks.insert(position, chunk)
-        self._chunks_dict[chunk.id] = chunk
-
-    def readLimitedChild(self, id, size, filter_class, *args):
-        start = self._stream.tell()
-        limited = self._stream.createLimited(start, size)
-        chunk = self.readStreamChild(id, limited, filter_class, *args)
-        assert self._stream.tell() == (start+size)
-        return chunk
-        
-    def readStreamChild(self, id, stream, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        oldpos = self._stream.tell()
-        filter = filter_class(stream, self, *args)
-        filter.setId(id)
-        chunk = self.addFilter(id, filter, oldpos)
-        chunk.postProcess()
-        self._stream.seek(oldpos + chunk.size)
-        return chunk
-        
-    def readChild(self, id, filter_class, *args): 
-        return self.readStreamChild(id, self._stream, filter_class, *args)
-    
-    def addFilter(self, id, filter, addr): 
-        chunk = FilterChunk(id, filter, self, addr)
-        self.appendChunk(chunk)
-        filter.updateParent(chunk)
-        return chunk
-
-    def readArray(self, id, entry_class, description, end_func): 
-        """
-        end_func: def isEnd(stream, array, last_filter)
-        """
-        addr = self._stream.tell()
-        filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
-        chunk = self.addFilter(id, filter, addr)
-        chunk.postProcess()
-        return chunk
-    
-    def readString(self, id, format, description, post=None, strip=None):
-        """ Returns chunk """
-        id = self.getUniqChunkId(id)
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-    
-    def read(self, id, format, description, post=None):
-        """ Returns chunk """
-        id = self.getUniqChunkId(id)
-        chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-
-    def __str__(self):
-        return "Filter(%s) <id=%s, description=%s>" % \
-            (self.__class__, self.getId(), self.getDescription())
-
-    def addNewFilter(self, chunk, id, size, desc):
-        chunk.setFormat("%us" % size, "split", id, desc)
-        self.convertChunkToFilter(chunk)
-
-    def convertFilterToChunk(self, chunk):
-        # Create new format chunk
-        filter = chunk.getFilter()
-        id = self.getUniqChunkId(filter.getId())
-        new_chunk = FormatChunk(id, filter.getDescription(), filter.getStream(), filter.getAddr(), "!%us" % filter.getSize(), self)
-
-        # Delete old chunk
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)
-
-        # Assign new chunk
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[id] = new_chunk
-        setattr(self, id, chunk.getValue(40))
-        self.redisplay()
-        return new_chunk 
-
-    def convertChunkToFilter(self, chunk):
-        # Create new filter
-        stream = self.getStream()
-        stream.seek(chunk.addr)
-        filter = Filter(chunk.id, chunk.description, stream, self)
-        chunk.setParent(filter)
-        filter.appendChunk(chunk)
-        
-        # Create new chunk and add it into self 
-        new_chunk = FilterChunk(chunk.id, filter, self, chunk.addr)
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[chunk.id] = new_chunk
-        self.redisplay()
-        return filter
-
-class ArrayFilter(Filter):
-    def __init__(self, id, description, stream, parent, entry_class, end_func):
-        Filter.__init__(self, id, description, stream, parent)
-        self._entry_class = entry_class
-        self._end_func = end_func
-        self._read()
-
-    def _read(self):
-        self._array = []
-        nb = 0
-        last_filter = None
-        while not self._end_func(self._stream, self._array, last_filter):
-            chunk_id = "%s[%u]" % (self.getId(), nb)
-            addr = self._stream.tell()
-            filter = self._entry_class(self._stream, self)
-            filter.setId(chunk_id)
-            nb = nb + 1
-            chunk = FilterChunk(chunk_id, filter, self, addr)
-            self._array.append( chunk )
-            self.appendChunk(chunk)
-            last_filter = filter
-
-        for chunk in self._array:
-            chunk.getFilter().updateParent(chunk)
-        if 1<nb:
-            self.setDescription( "%s (%s items)" % (self.getDescription(), nb))
-        else:
-            self.setDescription( "%s (%s item)" % (self.getDescription(), nb))
-
-    def getArray(self):
-        return self._array
-    
-    def _deleteChunk(self, pos):
-        Filter._deleteChunk(self, pos)
-        if pos < len(self._array):
-            del self._array[pos]
-
-    def update(self):
-        self._cache_valid = False
-        prev_chunk = None
-        pos = 0
-        try:
-            for chunk in self._array:
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error("Exception while updating an ArrayFilter:\n%s" % msg)
-            chunk = self._array[pos]
-            addr = chunk.addr
-            size = self.getLastPos() - addr
-            del self._array[pos:]
-            if size != 0:
-                chunk = FormatChunk("raw", "Raw data", chunk.getStream(), addr, "!%us" % size, self)
-                self._array.append(chunk)
-
-    def __len__(self):
-        return len(self._array)
-
-    def __getitem__(self, index):
-        return self._array[index]
-
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        new = ArrayFilter( self.getId(), self.getDescription(), \
-            self.getStream(), self.getParent(), self._entry_class, self._end_func)
-        new.filter_chunk = self.filter_chunk
-        return new
-
-class DeflateFilter(Filter):
-    def __init__(self, stream, parent, bz_stream, size, filter, *args):
-        Filter.__init__(self, "deflate", "Deflate", bz_stream, parent)
-        self._addr = stream.tell()
-        self.readChild("data", filter, *args)
-        self._compressed_size = size
-
-    def getSize(self):
-        return self._compressed_size

Deleted: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/format.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,40 +0,0 @@
-import re, struct
-
-_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLbhscfd]$")
-_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLbhscfd])$")
-_format_size_cache = {}
-
-def _getFormatCache(format):
-    global _format_size_cache
-    if format not in _format_size_cache:
-        assert checkFormat(format)
-        endian, count, type = _doSplitFormat(format)
-        size = count * struct.calcsize(type)
-        _format_size_cache[format] = (endian, count, type, size)
-    return _format_size_cache[format]   
-
-def getFormatSize(format):
-    cache = _getFormatCache(format)
-    return cache[3]   
-
-def checkFormat(format):
-    m = _regex_format1.match(format)
-    return m != None
-
-def splitFormat(format):
-    cache = _getFormatCache(format)
-    return cache[:3]   
-
-def _doSplitFormat(format):
-    m = _regex_format2.match(format)
-    assert m != None
-    endian = m.group(1)
-    count = m.group(2)
-    type = m.group(3)
-    if endian == "":
-        endian = "!"
-    if count != "":
-        count = long(count)
-    else:
-        count = 1
-    return (endian, count, type,)

Deleted: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/hachoir.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,137 +0,0 @@
-#!/usr/bin/python
-"""
-Hachoir: tool to split a binary file into human readable data.
-Because it's written in Python, it would be easy to write new plugins
-(supports new file format).
-
-Author: Victor Stinner
-"""
-
-import sys, os, re, traceback
-import config
-from program import PROGRAM, VERSION, WEBSITE
-from log import log
-from error import error
-from hachoir_class import Hachoir
-import ui.ui as ui
-
-def usage(defval):
-    print "%s version %s" % (PROGRAM, VERSION)
-    print "%s\n" % WEBSITE
-    print "Usage: %s [options] file" % (sys.argv[0])
-    print ""
-    print "Options:"
-    print "\t--script file.py  : Load python script"
-    print "\t--no-ui           : Don't load user interface"
-    print "\t--use-profiler    : Use profiler"
-    print "\t--version         : Show the program version"
-    print "\t--verbose         : Activate verbose mode"
-    print "\t--help            : Show this help"
-    print "\t--debug           : Enable debug mode (eg. display backtrace)"
-
-def parseArgs(val):
-    import getopt
-    def_val = val.copy()
-    
-    try:
-        short = ""
-        long = ["verbose", "help", "version", "script=", "no-ui", "debug", "use-profiler"]
-        opts, args = getopt.getopt(sys.argv[1:], short, long)
-    except getopt.GetoptError:
-        usage(def_val)
-        sys.exit(2)
-   
-    if 1 < len(args):
-        usage(def_val)
-        sys.exit(2)
-    if len(args) == 1:
-        filename = args[0]
-    else:
-        filename = None
-        
-    for o, a in opts:
-        if o == "--help":
-            usage(def_val)
-            sys.exit()
-        elif o == "--version":
-            print "%s version %s" % (PROGRAM, VERSION)
-            sys.exit()
-        elif o == "--no-ui":
-            val["load_ui"] = False
-        elif o == "--script":
-            val["script"] = a
-        elif o == "--verbose":
-            config.verbose = True
-        elif o == "--debug":
-            config.debug = True
-        elif o == "--use-profiler":
-            val["use_profiler"] = True
-    return (val, filename,)
-
-def main():
-    try:        
-        print "%s version %s" % (PROGRAM, VERSION)
-        print "%s\n" % WEBSITE
-    
-        import imp
-        plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")
-        plugins_files = os.listdir(plugins_dir)
-        file_py = re.compile("^([a-z0-9_]+)\.py$")
-        modules = []
-        for file in plugins_files:
-            m = file_py.match(file)
-            if file != "__init__.py" and m != None:
-                module = "plugins."+m.group(1)
-                __import__(module)
-                modules.append(m.group(1))
-        log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
-
-        opt = {
-            "verbose": False,
-            "script": None,
-            "load_ui": True,
-            "use_profiler": False
-        }
-        opt, filename = parseArgs(opt)
-        global hachoir 
-        hachoir = Hachoir()
-        for key in opt:
-            setattr(hachoir, key, opt[key])
-        if hachoir.load_ui:
-            try:
-                print "Load user interface"
-                ui.loadInterface(hachoir)
-            except ImportError, err:
-                error("""Error: a Python module is missing:
-%s
-
-You can find PyGTK at: http://www.pygtk.org/
-and PyGlade at: http://glade.gnome.org/
-
-Gentoo: emerge pytgtk
-Debian: apt-get install python2.4-gtk python2.4-magic
-Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
-                sys.exit(1)
-        if opt["use_profiler"]:
-            import profile, pstats
-            stat_filename = 'hachoir.pystat'
-            if filename != None:
-                str_filename = "\"%s\"" % filename
-            else:
-                str_filename = "None"
-            profile.run('global hachoir; hachoir.run(%s)' % str_filename, stat_filename)
-            #pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
-            pstats.Stats(stat_filename).sort_stats('time').print_stats()
-            os.unlink(stat_filename)
-        else:
-            hachoir.run(filename)
-
-    except SystemExit:
-        pass
-    except Exception, err:
-        where = "".join(traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback))
-        error("Exception:\n%s\n%s" % (err, where))
-	sys.exit(1)
-
-if __name__=="__main__": main()    

Deleted: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/hachoir_class.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,142 +0,0 @@
-from stream.file import FileStream
-from plugin import getPluginByStream
-from chunk import FilterChunk
-from default import DefaultFilter
-from user_filter import UserFilterDescriptor, loadUserFilter
-from error import error, warning
-from mime import getStreamMime
-
-class Hachoir:
-    instance = None
-    
-    def __init__(self):
-        Hachoir.instance = self
-        self.display = True
-        self.depth = 5
-        self.ui = None 
-        self._main_filter = None
-        self._filter = None
-        self.script = None
-        self.load_ui = True
-
-    def getFilter(self):
-        return self._filter
-
-    def setFilter(self, filter):
-#        if self._filter != None:
-#            self._filter.purgeCache()
-        self._main_filter = filter
-        self._filter = filter
-        if filter != None:
-            if self.load_ui:
-                self._filter.display()
-                self.ui.window.info.updateFilter(filter)
-        else:
-            if self.load_ui:
-                self.ui.window.clear_table()
-        if self.load_ui:
-            self.ui.window.updateToolbar()
-
-    def onGoParent(self):
-        if self._filter.getParent() == None: return
-        self._filter = self._filter.getParent()
-        self.ui.window.info.updateFilter(self._filter)
-        self._filter.display()
-        
-    def onRowClick(self, chunk_id):
-        if chunk_id == None: return
-        chunk = self._filter.getChunk(chunk_id)
-        if issubclass(chunk.__class__, FilterChunk):
-            filter = chunk.getFilter()
-            self.setFilter (filter)
-
-    def loadUser(self, filename):
-        try:
-            old_filter = self._filter
-            old_size = old_filter.getSize()
-            user = UserFilterDescriptor(xml_file=filename)
-            stream = self._filter.getStream()
-            parent = self._filter.getParent()
-            stream.seek(self._filter.getAddr())
-            new_filter = loadUserFilter(user, stream, parent)
-        except Exception, err:
-            error("Error while loading user XML filter \"%s\":\n%s" % (filename, err))
-            return
-        self._filter = new_filter           
-        if parent == None:
-            self._main_filter = self._filter
-            self._addPadding()
-        else:
-            chunk = old_filter.filter_chunk
-            chunk.setFilter(self._filter)
-            diff_size = self._filter.getSize() - old_size
-            chunk.getParent().rescan(chunk, diff_size)
-        if self.load_ui:
-            self._filter.display()
-        self.ui.window.updateToolbar()
-    
-    def saveUser(self, filename):
-        my = UserFilterDescriptor(filter=self._filter)
-        my.writeIntoXML(filename)
-    
-    def exportUser(self, filename):
-        my = UserFilterDescriptor(filter=self._filter)
-        my.exportPython(filename)
-        
-    def _addPadding(self):
-        filter_size = self._main_filter.getSize()
-        stream_size = self._main_filter.getStream().getSize()
-        diff_size = filter_size - stream_size
-        if diff_size < 0:
-            self._main_filter.read("end", "%us" % (-diff_size), "Raw data")
-
-    def loadFile(self, filename):
-        try:
-            print "Load file %s" % filename
-            file = open(filename, 'r')
-            stream = FileStream(file, filename)
-        except IOError, err:
-            error("Can't load file %s:\n%s" % (filename, err))
-            return
-        self.loadStream(stream, filename)
-
-    def loadStream(self, stream, filename=None):
-        # Look for a plugin
-        split_class = getPluginByStream(stream, filename, None)
-        if split_class == None:
-            mimes = [ item[0] for item in getStreamMime(stream, filename)]
-            warning("Warning: No plugin found for MIME %s." % ", ".join(mimes))
-            split_class = DefaultFilter
-            
-        # Split 
-        try:
-            stream.seek(0)
-            filter = split_class(stream, None)
-        except Exception, msg:
-            error("Exception while processing file %s:\n%s" \
-                % (filename, msg))
-            stream.seek(0)
-            filter = DefaultFilter(stream)
-        self._main_filter = filter
-        self._addPadding()
-        self.setFilter(filter)
-
-    def loadScript(self, filename):
-        try:
-            f = open(self.script, 'r')
-            script = f.read()
-            f.close()
-            compiled = compile(script, self.script, 'exec')
-            exec compiled
-        except Exception, msg:
-            error("Exception while loading script \"%s\":\n%s\n%s" \
-                % (filename, msg))
-
-    def run(self, filename):
-        if self.script:
-            self.loadScript(self.script)
-        elif filename != None:
-            self.loadFile(filename)
-        if self.load_ui:
-            print "Run user interface ..."
-            self.ui.run()      

Deleted: haypo/hachoir/log.py
===================================================================
--- haypo/hachoir/log.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/log.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,93 +0,0 @@
-#!/usr/bin/python
-# -*- coding: UTF-8 -*-
-
-import time
-
-class Log:
-    LOG_INFO   = 0
-    LOG_WARN   = 1
-    LOG_ERROR  = 2
-
-    def __init__(self):
-        self.__buffer = {}
-        self.__file = None
-        self.use_print = True
-        self.on_new_message = None # (level, prefix, text)
-
-    def setFilename(self, filename):
-        """
-        Use a file to store all messages. The
-        UTF-8 encoding will be used. Write an informative
-        message if the file can't be created.
-
-        @param filename: C{L{string}}
-        """
-
-        try:
-            import codecs
-            self.__file = codecs.open(filename, "w", "utf-8")
-        except IOError, errno:
-            if errno[0] == 2:
-                self.__file = None
-                self.info("Log.setFilename(%s) fails : no such file." % filename)
-                return
-            raise
-
-    def getLevelPrefix(self, level):
-        """
-        String prefix which depends on message level.
-        Eg. information returns "[info]".
-        @return: C{str}
-        """
-        if level==Log.LOG_WARN: return "[warn]"
-        if level==Log.LOG_ERROR: return "[err!]"
-        return "[info]"
-
-    def newMessage(self, level, str):
-        """
-        Write a new message : append it in the buffer,
-        display it to the screen (if needed), and write
-        it in the log file (if needed).
-
-        @param level: Message level.
-        @type level: C{int}
-        @param str: Message content.
-        @type str: C{str}
-        """
-
-        if not self.__buffer.has_key(level):
-            self.__buffer[level] = [str]
-        else:
-            self.__buffer[level].append(str)
-        prefix = self.getLevelPrefix(level)            
-        if self.use_print:
-            print "%s %s" % (prefix, str)
-        if self.__file:
-            self.__file.write(u"%s - %s %s\n" \
-                % (time.strftime("%Y-%M-%d %H:%M:%S"),
-                   prefix, str))
-        if self.on_new_message:
-            self.on_new_message (level, prefix, str)
-
-    def info(self, str):
-        """
-        New informative message.
-        @type str: C{str}
-        """
-        self.newMessage(Log.LOG_INFO, str)
-
-    def warning(self, str):
-        """
-        New warning message.
-        @type str: C{str}
-        """
-        self.newMessage(Log.LOG_WARN, str)
-
-    def error(self, str):
-        """
-        New error message.
-        @type str: C{str}
-        """
-        self.newMessage(Log.LOG_ERROR, str)
-
-log = Log()        

Deleted: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/mime.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,141 +0,0 @@
-#!/usr/bin/python
-
-"""
-MIME type detection using libmagic library.
-
-See also:
-- ftp://ftp.astron.com/pub/file/ (libmagic)
-- http://www.demonseed.net/~jp/code/magic.py (100% Python)
-- http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
-"""
-
-import os, sys, stat, string, re
-from error import warning
-
-instance = None
-
-class GuessMime:
-    def __init__(self):
-        self.use_fallback = False
-        self.func = None
-        try:
-            path = os.path.dirname(__file__)
-            sys.path.append(path)
-            import magic
-            self.func = magic.open(magic.MAGIC_MIME)
-            self.func.load()
-        except ImportError:
-            warning("Warning: The library libmagic for Python is unavailable. Using internal fallback engine.")
-            self.use_fallback = True
-        if self.use_fallback:
-            from  fallback.magic import whatis
-            self.func = whatis
-
-    def guess(self, buffer):
-        if not self.use_fallback:
-            return self.func.buffer(buffer)
-        else:
-            mime = self.func(buffer)
-            return mime
-
-def getFileMime(realname, filename=None):
-    if filename == None:
-        filename = realname
-    mode = os.stat(filename)[stat.ST_MODE]
-    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
-    
-    f = file(filename, "rb")
-    buffer = f.read(4096)
-    f.close()
-    return getBufferMime(buffer, filename)
-
-def getMimeByExt(ext):    
-    if ext == '.gz':
-        return 'application/x-gzip'
-    return None        
-
-def getStreamMime(stream, filename):
-    oldpos = stream.tell()
-    stream.seek(0)
-    size = stream.getSize()
-    if 4096<size:
-        size = 4096
-    data = stream.getN(size)
-    stream.seek(oldpos)
-    return getBufferMime(data, filename)
-
-def getAnotherBufferMime(buffer):    
-    if buffer[:2] == "\x4d\x4d" and buffer[6:12]=="\x02\0\x0A\0\0\0":
-        return "image/x-3ds"
-    if 2<=len(buffer) and ord(buffer[0])==31 and ord(buffer[1])==139:
-        return "application/x-gzip"
-    if buffer[:4] == "%PDF":
-        return "application/pdf"
-    if buffer[:14] == "gimp xcf file\0":
-        return "image/x-xcf"
-
-    if buffer[0] == "\x0A" \
-    and buffer[1] in "\x00\x02\x03\x04\x05" \
-    and buffer[64] == "\0":
-        return "image/x-pcx"
-        
-    if 4096<=len(buffer) \
-    and buffer[1080:1082]=="\x53\xEF" \
-    and buffer[1116:1120]=="\x04\x00\x00\x00":
-        return "hachoir/fs-ext2"
-        
-    if buffer[0:3] == "DIR":
-        return "hachoir/worms2"
-        
-    if 512<=len(buffer) \
-    and buffer[0] in "\xEB\xFA" \
-    and buffer[510:512] == "\x55\xAA" \
-    and buffer[446] in "\x00\x80" \
-    and buffer[446+16*1] in "\x00\x80" \
-    and buffer[446+16*2] in "\x00\x80" \
-    and buffer[446+16*3] in "\x00\x80":
-        return "hachoir/master-boot-record"
-    return None        
-
-def splitMimes(mimes):
-    """
-    Split MIME types into a list.
-    Examples:
-    - "text/plain; encoding=latin-1" => [["text/plain", {"encoding": latin-1"}]
-    - "text/plain, text/xml" => [["text/plain"],["text/xml"]]
-    - "text/plain; charset=ISO-8859-1; format=flowed"
-      => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
-    - "application/x-archive application/x-debian-package"
-    """
-
-    regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
-    mimes = regex.findall(mimes)    
-    
-    list = []
-    for mime in mimes:
-        mime = mime.strip(" ,")
-        parts = mime.split(";")
-        mime = parts[0]
-        parts = map(string.strip, parts[1:])
-        values = {}
-        for part in parts:
-            if part != "":
-                split_part = part.split("=", 1)             
-                values[ split_part[0] ] = split_part[1]
-        list.append([mime,values])
-    return list
-
-def getBufferMime(buffer, filename):
-    global instance
-    if instance == None:
-        instance = GuessMime()
-    mimes = instance.guess(buffer)
-    mimes = splitMimes(mimes)
-    if len(mimes) == 0 or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
-        new_mime = getAnotherBufferMime(buffer)
-        if new_mime == None and filename != None:
-            ext = os.path.splitext(filename)[1]
-            new_mime = getMimeByExt(ext)
-        if new_mime != None:
-            mimes = ((new_mime,),)
-    return mimes

Deleted: haypo/hachoir/ogg_page.xml
===================================================================
--- haypo/hachoir/ogg_page.xml	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/ogg_page.xml	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,12 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<user_filter hachoir_version='2005-10-27' id='ogg_page' description='ogg_page'>
-  <chunk format='!4s' id='header' description='Header (OggS)'/>
-  <chunk format='!1B' id='version' description='Version'/>
-  <chunk format='!1B' id='type' description='Type'/>
-  <chunk format='!8s' id='pos' description='Position'/>
-  <chunk format='!L' id='serial' description='Serial number'/>
-  <chunk format='!L' id='seq_nb' description='Sequence number'/>
-  <chunk format='!L' id='checksum' description='Checksum'/>
-  <chunk format='!1B' id='page_segm' description='Raw'/>
-  <chunk format='!31s' id='something' description='Raw'/>
-</user_filter>

Deleted: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/plugin.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,40 +0,0 @@
-import re
-from mime import getFileMime, getStreamMime
-from default import DefaultFilter
-from error import warning
-
-def guessPlugin(stream, filename, default=DefaultFilter):
-    return getPluginByStream(stream, filename, default)
-
-def getPluginByMime(mimes, default=DefaultFilter):
-    global hachoir_plugins
-    plugins = []
-    for mime in mimes:
-        mime = mime[0]
-        if mime in hachoir_plugins:
-            plugins = plugins + hachoir_plugins[mime]
-    if len(plugins)==0:
-        return default
-    if 1<len(plugins):
-        warning("More than one plugin have same MIME...")
-    return plugins[0]
-    
-def getPluginByStream(stream, filename, default=DefaultFilter):
-    mime = getStreamMime(stream, filename)
-    return getPluginByMime(mime, default)
-
-def getPluginByFile(filename, realname=None, default=DefaultFilter):
-    mime = getFileMime(filename, realname)
-    return getPluginByMime(mime, default)
-    
-def registerPlugin(filter_class, mimes):
-    global hachoir_plugins
-    if isinstance(mimes, str):
-        mimes = [mimes]
-    for mime in mimes:
-        if mime in hachoir_plugins:
-            hachoir_plugins[mime].append(filter_class)
-        else:
-            hachoir_plugins[mime] = [filter_class]
-
-hachoir_plugins = {} 

Deleted: haypo/hachoir/program.py
===================================================================
--- haypo/hachoir/program.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/program.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,3 +0,0 @@
-PROGRAM="Hachoir"
-VERSION="2005-12-11"
-WEBSITE="http://www.haypocalc.com/wiki/Hachoir"

Deleted: haypo/hachoir/release.sh
===================================================================
--- haypo/hachoir/release.sh	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/release.sh	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,16 +0,0 @@
-PACKAGE=hachoir
-VERSION=20051115
-ARCHIVE=$PACKAGE-$VERSION.tar.bz2
-TMP_DIR=/tmp
-DIR=$PWD
-if [ -e $TMP_DIR/$PACKAGE ]; then
-        rm -rf $TMP_DIR/$PACKAGE
-fi
-
-echo "* Export data"
-svn export . $TMP_DIR/$PACKAGE
-
-echo "* Create $ARCHIVE"
-(cd $TMP_DIR && tar cjf $DIR/$ARCHIVE $PACKAGE)
-
-echo "$DIR/$ARCHIVE wrote."

Deleted: haypo/hachoir/text_handler.py
===================================================================
--- haypo/hachoir/text_handler.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/text_handler.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,10 +0,0 @@
-from tools import humanFilesize as doHumanFilesize
-
-def humanFilesize(chunk):
-    return doHumanFilesize(chunk.value)
-
-def hexadecimal(chunk):
-    size = chunk.size
-    assert size in (2, 4, 8)
-    pattern = "%0" + str(2*size) + "X"
-    return pattern % chunk.value

Deleted: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/tools.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,181 +0,0 @@
-import traceback, sys, string, re
-
-def _regexMaxLength(pattern, in_parenthesis=False):
-    """
-    Don't use this function directly, use regexMagLength!
-    """
-
-    re_letter = re.compile( r"^[^][()|.?+*{}](.*)$")
-    re_set = re.compile( r"^\[" + r"[^]]*" + r"\](.*)$" )
-    re_min_repetition = re.compile( r"^\{([0-9]+)\}(.*)$" )
-    re_min_max_repetition = re.compile( r"^\{([0-9]+),([0-9]+)\}(.*)$" )
-
-    size = 0
-    atom_size = 0
-    state = 0 # get atom
-    is_end = len(pattern) == 0
-    if in_parenthesis and not is_end:
-        is_end = pattern[0] in ("|", ")")
-    while not is_end:
-        if state==0:
-            size = size + atom_size
-
-            # Pattern: [...] => size=1
-            if pattern[0] == '(':
-                pattern = pattern[1:]
-                atom_size = None
-                while True:
-                    tmp_atom_size, pattern = _regexMaxLength(pattern, True)
-                    if tmp_atom_size == None:
-                        return None, pattern
-                    if atom_size==None or atom_size<tmp_atom_size:
-                        atom_size = tmp_atom_size
-                    if pattern[0] == ')':
-                        break
-                    assert pattern[0] == '|'
-                    pattern = pattern[1:]
-                pattern = pattern[1:]
-            else:
-                m = re_set.match(pattern)
-                if m != None:
-                    pattern = m.group(1)
-                    atom_size = 1
-                else:
-                    m = re_letter.match(pattern)
-                    if m == None:
-                        return (-1, pattern,)
-                    atom_size = 1
-                    pattern = m.group(1)
-            state = 1                
-        else:
-            assert state==1
-
-            # Repetiton: + or * => no limit
-            if pattern[0] in ("*", "+"):
-                return (None, pattern,)
-            
-            # Repetition: {2}
-            m = re_min_repetition.match(pattern)
-            if m != None:
-                repetition = int(m.group(1))
-                print "(rep=%sx%s)" % (atom_size, repetition)
-                pattern = m.group(2)
-                atom_size = atom_size * repetition
-            else:
-                # Repetition: {1,2}
-                m = re_min_max_repetition.match(pattern)
-                if m != None:
-                    repetition = int(m.group(2))
-                    pattern = m.group(3)
-                    atom_size = atom_size * repetition
-            state = 0
-
-        is_end = len(pattern) == 0
-        if in_parenthesis and not is_end:
-            is_end = pattern[0] in ("|", ")")
-
-    return (size + atom_size, pattern,)
-
-def regexMaxLength(pattern):
-    """
-    Get maximum size of a regular expression pattern.
-    Returns (size, pattern). If size=-1, an error occurs (pattern contains
-    the buggy pattern). If size=-1, no limit does exist.
-    """
-
-    size, pattern = _regexMaxLength(pattern)
-    if size == -1:
-        raise "Can't parse regular expression: %s" % pattern 
-    return size 
-
-def humanDuration(ms):
-    # Milliseconds
-    if ms < 1000:
-        return "%u ms" % ms
-        
-    # Seconds
-    sec = ms/1000
-    ms = ms%1000
-    if sec < 60:
-        return  "%u sec" % sec
-
-    # Minutes
-    min = sec/60
-    sec = sec%60
-    if min<60:
-        text = "%u min %u sec" % (min, sec)
-
-    # Hours
-    hour = min/60
-    min = min/60
-    if hour < 24:
-        text = "%u hour(s) %u min" % (hour, min)
-
-    # Days
-    day = hour/24
-    hour = hour%24
-    if hour != 0:
-        text = "%u day(s) %u hour(s)" % (day, hour)    
-    else:
-        text = "%u day(s)" % (day)
-    return text
-
-def humanFilesize(size):
-    if size < 1000:
-        return "%u bytes" % size
-    units = ["KB", "MB", "GB"]
-    size = float(size)
-    for unit in units:
-        size = size / 1024
-        if size < 100:
-            return "%.1f %s" % (size, unit)
-        if size < 1000:
-            return "%u %s" % (size, unit)
-        last_unit = unit
-    return "%u %s" % (size, unit)
-
-def convertDataToPrintableString(data, keep_n=False):
-    if len(data) == 0:
-        return "(empty)"
-    display = ""
-    for c in data:
-        if ord(c)<32:
-            know = { \
-                "\n": "\\n",
-                "\r": "\\r",
-                "\t": "\\t",
-                "\0": "\\0"}
-            if c in know:
-                if not keep_n or c != "\n":
-                    display = display + know[c]
-                else:
-                    display = display + c
-            else:
-#                display = display + "\\x%02X" % ord(c)
-                display = display + "."
-        elif c in string.printable:
-            display = display + c
-        else:
-            display = display + "."
-    return "\"%s\"" % display
-
-def getBacktrace():
-    try:
-        bt = traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback)
-        return "".join(bt)
-    except:
-        return "Error while trying to get backtrace"
-
-def getUnixRWX(mode):
-#-- TODO --
-#EXT2_S_ISUID  0x0800  SUID
-#EXT2_S_ISGID  0x0400  SGID
-#EXT2_S_ISVTX  0x0200  sticky bit
-    rwx = ("---", "rwx")
-    text = ""
-    for i in range(0,3):
-        for j in range(0,3):
-            mask = 1 << (3*(2-i)) << (2-j)
-            text = text + rwx[int(mode & mask == mask)][j]
-    return text

Copied: haypo/hachoir/trunk/AUTHORS (from rev 348, haypo/hachoir/AUTHORS)

Copied: haypo/hachoir/trunk/BUGS (from rev 348, haypo/hachoir/BUGS)

Copied: haypo/hachoir/trunk/COPYING (from rev 348, haypo/hachoir/COPYING)

Copied: haypo/hachoir/trunk/ChangeLog (from rev 348, haypo/hachoir/ChangeLog)

Copied: haypo/hachoir/trunk/INSTALL (from rev 348, haypo/hachoir/INSTALL)

Copied: haypo/hachoir/trunk/Makefile (from rev 348, haypo/hachoir/Makefile)

Copied: haypo/hachoir/trunk/README (from rev 348, haypo/hachoir/README)

Copied: haypo/hachoir/trunk/bmp_filter.xml (from rev 348, haypo/hachoir/bmp_filter.xml)

Copied: haypo/hachoir/trunk/chunk.py (from rev 348, haypo/hachoir/chunk.py)

Copied: haypo/hachoir/trunk/config.py (from rev 348, haypo/hachoir/config.py)

Copied: haypo/hachoir/trunk/default.py (from rev 348, haypo/hachoir/default.py)

Copied: haypo/hachoir/trunk/error.py (from rev 348, haypo/hachoir/error.py)

Copied: haypo/hachoir/trunk/export.template (from rev 348, haypo/hachoir/export.template)

Copied: haypo/hachoir/trunk/fallback (from rev 348, haypo/hachoir/fallback)

Copied: haypo/hachoir/trunk/filter.py (from rev 348, haypo/hachoir/filter.py)

Copied: haypo/hachoir/trunk/format.py (from rev 348, haypo/hachoir/format.py)

Copied: haypo/hachoir/trunk/hachoir.py (from rev 348, haypo/hachoir/hachoir.py)

Copied: haypo/hachoir/trunk/hachoir_class.py (from rev 348, haypo/hachoir/hachoir_class.py)

Copied: haypo/hachoir/trunk/log.py (from rev 348, haypo/hachoir/log.py)

Copied: haypo/hachoir/trunk/mime.py (from rev 348, haypo/hachoir/mime.py)

Copied: haypo/hachoir/trunk/ogg_page.xml (from rev 348, haypo/hachoir/ogg_page.xml)

Copied: haypo/hachoir/trunk/plugin.py (from rev 348, haypo/hachoir/plugin.py)

Copied: haypo/hachoir/trunk/plugins (from rev 348, haypo/hachoir/plugins)

Copied: haypo/hachoir/trunk/program.py (from rev 348, haypo/hachoir/program.py)

Copied: haypo/hachoir/trunk/release.sh (from rev 348, haypo/hachoir/release.sh)

Copied: haypo/hachoir/trunk/stream (from rev 348, haypo/hachoir/stream)

Copied: haypo/hachoir/trunk/text_handler.py (from rev 348, haypo/hachoir/text_handler.py)

Copied: haypo/hachoir/trunk/tools.py (from rev 348, haypo/hachoir/tools.py)

Copied: haypo/hachoir/trunk/ui (from rev 348, haypo/hachoir/ui)

Copied: haypo/hachoir/trunk/user_filter.py (from rev 348, haypo/hachoir/user_filter.py)

Deleted: haypo/hachoir/user_filter.py
===================================================================
--- haypo/hachoir/user_filter.py	2005-12-24 01:47:07 UTC (rev 348)
+++ haypo/hachoir/user_filter.py	2005-12-26 03:31:06 UTC (rev 349)
@@ -1,136 +0,0 @@
-from filter import Filter
-from chunk import FilterChunk
-from xml.dom.minidom import getDOMImplementation, parse
-from program import VERSION
-from xml.dom.ext import PrettyPrint
-
-class UserChunk:
-    def __init__(self, id, format, description):
-        self.id = id
-        self.format = format
-        self.description = description
-        
-    def __str__(self):
-        return "UserChunk <id=%s, format=%s, description=%s>" % \
-            (self.id, self.format, self.description)
-
-class UserSubChunk(UserChunk):
-    def __init__(self, id, sub, sub_format, description):
-        UserChunk.__init__(self, id, "sub", description)
-        self.sub = sub
-        self.sub_format = sub_format
-
-def loadUserFilter(desc, stream, parent):
-    filter = Filter(desc.id, desc.description, stream, parent)
-    for chunk in desc.chunks:
-        if chunk.format == "sub":
-            modules = chunk.sub_format.split('.')
-            chunk_class = modules[-1]
-            module = ".".join(modules[:-1])
-            mod = __import__(module, globals(), locals(), [chunk_class])
-            chunk_class = getattr(mod, chunk_class)
-            filter.readChild(chunk.id, chunk_class, chunk.description)
-        else:
-            filter.read(chunk.id, chunk.format, chunk.description)
-    return filter            
-
-class UserFilterDescriptor:
-    def __init__(self, filter=None, xml_file=None):
-        self.chunks = []
-        if filter != None:
-            self.createFromFilter(filter)
-        elif xml_file != None:
-            self.createFromXML(xml_file)
-        else:
-            self.id = None 
-            self.description = None 
-            
-    def exportPython(self, filename):
-        file = open(filename, "w")
-        file.write(self.toPython())
-        file.close()
-            
-    def writeIntoXML(self, filename):
-        file = open(filename, "w")
-        PrettyPrint(self.toXML(), file)
-        file.close()
-        
-    def createFromXML(self, filename):
-        xml = parse(filename)
-        self.chunks = []
-        root = xml.documentElement
-        self.id = root.getAttribute("id")
-        self.description = root.getAttribute("description")
-        self.__loadXML(root)
-        
-    def __loadXML(self, node):
-        for chunk in node.childNodes:
-            if chunk.nodeType == chunk.ELEMENT_NODE and chunk.tagName == "chunk":
-                id = chunk.getAttribute("id") 
-                description = chunk.getAttribute("description") 
-                format = chunk.getAttribute("format")
-                
-                if format == "sub":
-                    sub_format = chunk.getAttribute("sub_format") 
-                    sub = UserFilterDescriptor()
-                    sub.__loadXML(chunk)
-                    user_chunk = UserSubChunk(id, sub, sub_format, description)
-                else:
-                    user_chunk = UserChunk(id, format, description)
-                self.chunks.append(user_chunk)
-
-    def toPython(self):
-        f = open('export.template', 'r')
-        tpl = f.read()
-        f.close()
-
-        chunks = ""
-        for chunk in self.chunks:
-            if chunks != "": chunks = chunks + "\n"
-            chunks = chunks \
-                + " " * 8 \
-                + "self.read(\"%s\", \"%s\", \"%s\")" \
-                  % (chunk.id, chunk.format, chunk.description)
-        return tpl.replace("{id}", self.id).replace("{description}", self.description).replace("{chunks}", chunks)
-
-    def toXML(self):
-        impl = getDOMImplementation()
-        doc = impl.createDocument(None, "user_filter", None)
-        root = doc.documentElement
-        root.setAttribute("hachoir_version", VERSION)
-        root.setAttribute("id", self.id)
-        root.setAttribute("description", self.id)
-        self.__toXML(doc, root)
-        return doc
-
-    def __toXML(self, doc, node):
-        for chunk in self.chunks:
-            item = doc.createElement("chunk")
-            item.setAttribute("id", chunk.id)
-            item.setAttribute("description", chunk.description)
-            item.setAttribute("format", chunk.format)
-            node.appendChild(item)
-            if issubclass(chunk.__class__, UserSubChunk):
-                item.setAttribute("sub_format", chunk.sub_format)
-#                chunk.sub.__toXML(doc, item)
-
-    def createFromFilter(self, filter):
-        self.id = filter.getId()
-        self.description = filter.getDescription()
-        self.chunks = []
-        self.__createFromChunks(filter.getChunks())
-
-    def __createFromChunks(self, chunks):
-        for chunk in chunks:
-            if False: #issubclass(chunk.__class__, ArrayChunk):
-                # TODO: Fix ArrayFilter
-                self.__createFromChunks(chunk)
-            else:
-                if issubclass(chunk.__class__, FilterChunk):
-                    format = str(chunk.getFilter().__class__)
-                    #sub = UserFilterDescriptor(filter=chunk.getFilter())
-                    sub = None
-                    user = UserSubChunk(chunk.id, sub, format, chunk.description)
-                else:
-                    user = UserChunk(chunk.id, chunk.getFormat(), chunk.description)
-                self.chunks.append(user)



From haypo at berlios.de  Mon Dec 26 04:53:32 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 26 Dec 2005 04:53:32 +0100
Subject: [Happyboom-svn] r351 - in haypo/hachoir/trunk: . broken_plugins generic plugins ui
Message-ID: <200512260353.jBQ3rWtr015356@sheep.berlios.de>

Author: haypo
Date: 2005-12-26 04:53:11 +0100 (Mon, 26 Dec 2005)
New Revision: 351

Added:
   haypo/hachoir/trunk/broken_plugins/
   haypo/hachoir/trunk/broken_plugins/3ds.py
   haypo/hachoir/trunk/broken_plugins/ar.py
   haypo/hachoir/trunk/broken_plugins/asn1.py
   haypo/hachoir/trunk/broken_plugins/bmp.py
   haypo/hachoir/trunk/broken_plugins/bzip2.py
   haypo/hachoir/trunk/broken_plugins/elf.py
   haypo/hachoir/trunk/broken_plugins/email.py
   haypo/hachoir/trunk/broken_plugins/exe.py
   haypo/hachoir/trunk/broken_plugins/exif.py
   haypo/hachoir/trunk/broken_plugins/ext2.py
   haypo/hachoir/trunk/broken_plugins/gif.py
   haypo/hachoir/trunk/broken_plugins/id3.py
   haypo/hachoir/trunk/broken_plugins/mbr.py
   haypo/hachoir/trunk/broken_plugins/mp3.py
   haypo/hachoir/trunk/broken_plugins/pcx.py
   haypo/hachoir/trunk/broken_plugins/pdf.py
   haypo/hachoir/trunk/broken_plugins/rpm.py
   haypo/hachoir/trunk/broken_plugins/worms2.py
   haypo/hachoir/trunk/broken_plugins/xcf.py
   haypo/hachoir/trunk/broken_plugins/zip.py
   haypo/hachoir/trunk/generic/
   haypo/hachoir/trunk/generic/__init__.py
   haypo/hachoir/trunk/generic/image.py
Removed:
   haypo/hachoir/trunk/plugins/3ds.py
   haypo/hachoir/trunk/plugins/ar.py
   haypo/hachoir/trunk/plugins/asn1.py
   haypo/hachoir/trunk/plugins/bmp.py
   haypo/hachoir/trunk/plugins/bzip2.py
   haypo/hachoir/trunk/plugins/elf.py
   haypo/hachoir/trunk/plugins/email.py
   haypo/hachoir/trunk/plugins/exe.py
   haypo/hachoir/trunk/plugins/exif.py
   haypo/hachoir/trunk/plugins/ext2.py
   haypo/hachoir/trunk/plugins/gif.py
   haypo/hachoir/trunk/plugins/id3.py
   haypo/hachoir/trunk/plugins/mbr.py
   haypo/hachoir/trunk/plugins/mp3.py
   haypo/hachoir/trunk/plugins/pcx.py
   haypo/hachoir/trunk/plugins/pdf.py
   haypo/hachoir/trunk/plugins/rpm.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/plugins/xcf.py
   haypo/hachoir/trunk/plugins/zip.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/default.py
   haypo/hachoir/trunk/error.py
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/format.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/plugins/avi.py
   haypo/hachoir/trunk/plugins/gzip.py
   haypo/hachoir/trunk/plugins/jpeg.py
   haypo/hachoir/trunk/plugins/png.py
   haypo/hachoir/trunk/plugins/tar.py
   haypo/hachoir/trunk/text_handler.py
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/ui_window.py
   haypo/hachoir/trunk/user_filter.py
Log:
- Rewrite Filter read*() methods, just use read() and doRead() yet
- Better result with humanFilesize() (which supports TB unit yet)
- Use new syntax for FormatChunk, more human readable (see below)
- Always display backtrace in log
- When chunk id/description is changed, tells the (filter) parent which can
  update display
- Create EnumChunk: FormatChunk + dictionnary to associate value to string
- Create BitsChunk: can be used to split bytes in bits ;-)

New read() method:
- replace self.read(id, format, desc) with self.read(id, desc, (FormatChunk, format))
- replace self.read(id, format, desc, post=func) with self.read(id, desc, (FormatChunk, format), {"post": func})
- replace self.readChild(id, class, arg1, ...) with self.read(id, *desc*, (class, arg1, ...))
- replace self.readStreamChild(id, stream, class, arg1, ...) with self.read(id, *desc*, (class, arg1, ...), {"stream": stream})

New FormatChunk syntax:
- use global endian for filter (be can be overridden)
- replace "10s" with "string[10]"
- replace "c" with "char"
- replace "B" with "uint8"
- replace "H" with "unit16"
- replace "L" with "uint32"
- replace "f" with "float"



Copied: haypo/hachoir/trunk/broken_plugins/3ds.py (from rev 349, haypo/hachoir/trunk/plugins/3ds.py)

Copied: haypo/hachoir/trunk/broken_plugins/ar.py (from rev 349, haypo/hachoir/trunk/plugins/ar.py)

Copied: haypo/hachoir/trunk/broken_plugins/asn1.py (from rev 349, haypo/hachoir/trunk/plugins/asn1.py)

Copied: haypo/hachoir/trunk/broken_plugins/bmp.py (from rev 349, haypo/hachoir/trunk/plugins/bmp.py)

Copied: haypo/hachoir/trunk/broken_plugins/bzip2.py (from rev 349, haypo/hachoir/trunk/plugins/bzip2.py)

Copied: haypo/hachoir/trunk/broken_plugins/elf.py (from rev 349, haypo/hachoir/trunk/plugins/elf.py)

Copied: haypo/hachoir/trunk/broken_plugins/email.py (from rev 349, haypo/hachoir/trunk/plugins/email.py)

Copied: haypo/hachoir/trunk/broken_plugins/exe.py (from rev 349, haypo/hachoir/trunk/plugins/exe.py)

Copied: haypo/hachoir/trunk/broken_plugins/exif.py (from rev 349, haypo/hachoir/trunk/plugins/exif.py)

Copied: haypo/hachoir/trunk/broken_plugins/ext2.py (from rev 349, haypo/hachoir/trunk/plugins/ext2.py)

Copied: haypo/hachoir/trunk/broken_plugins/gif.py (from rev 349, haypo/hachoir/trunk/plugins/gif.py)

Copied: haypo/hachoir/trunk/broken_plugins/id3.py (from rev 349, haypo/hachoir/trunk/plugins/id3.py)

Copied: haypo/hachoir/trunk/broken_plugins/mbr.py (from rev 349, haypo/hachoir/trunk/plugins/mbr.py)

Copied: haypo/hachoir/trunk/broken_plugins/mp3.py (from rev 349, haypo/hachoir/trunk/plugins/mp3.py)

Copied: haypo/hachoir/trunk/broken_plugins/pcx.py (from rev 349, haypo/hachoir/trunk/plugins/pcx.py)

Copied: haypo/hachoir/trunk/broken_plugins/pdf.py (from rev 349, haypo/hachoir/trunk/plugins/pdf.py)

Copied: haypo/hachoir/trunk/broken_plugins/rpm.py (from rev 349, haypo/hachoir/trunk/plugins/rpm.py)

Copied: haypo/hachoir/trunk/broken_plugins/worms2.py (from rev 349, haypo/hachoir/trunk/plugins/worms2.py)

Copied: haypo/hachoir/trunk/broken_plugins/xcf.py (from rev 349, haypo/hachoir/trunk/plugins/xcf.py)

Copied: haypo/hachoir/trunk/broken_plugins/zip.py (from rev 349, haypo/hachoir/trunk/plugins/zip.py)

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/chunk.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,6 +1,6 @@
 import struct, re, types
 import config
-from format import checkFormat, splitFormat, getFormatSize 
+from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsInteger
 from error import warning, error
 from tools import convertDataToPrintableString
 
@@ -67,11 +67,14 @@
     def _setAddr(self, addr): self._addr = addr
     def _getAddr(self): return self._addr
     def _getSize(self): return self._size
-    def _getId(self): return self._id
-    def _setId(self, id):
-        if self._id == id: return
-        self._parent.updateChunkId(self, id)
-        self._id = id
+    def _getId(self):
+        return self._id
+    def _setId(self, new_id):
+        old_id = self.id
+        if new_id == old_id:
+            return
+        self._id = new_id
+        self._parent.updateChunkId(old_id, new_id)
     addr = property(_getAddr, _setAddr)        
     size = property(_getSize)        
     id = property(_getId, _setId)
@@ -131,9 +134,11 @@
     def getFilter(self):
         return self._filter
 
-    def _setId(self, id):
-        Chunk._setId(self, id)
-        self._filter.setId(id)
+    def _setId(self, new_id):
+        if new_id == self.id:
+            return
+        self._filter.setId(new_id)
+        Chunk._setId(self, new_id)
     id = property(Chunk._getId, _setId)
 
     def _getDescription(self):
@@ -257,25 +262,31 @@
         else:
             text = self._read(config.max_string_length)
             return convertDataToPrintableString(text)
-        
+
 class FormatChunk(Chunk):
-    regex_sub_format = re.compile(r'\{([^}]+)\}')
-
-    def __init__(self, id, description, stream, addr, format, parent):
-        Chunk.__init__(self, id, description, stream, addr, None, parent)
+    def __init__(self, id, description, stream, format, parent):
+        Chunk.__init__(self, id, description, stream, stream.tell(), None, parent)
         self._format = None
         self._doSetFormat(format)
 
     def _doSetFormat(self, format):
         if format == self._format:
             return
+
+        # Add endian if needed
+        splited = splitFormat(format)
+        if splited[0] == None and splited[2] not in "scbB":
+            endian = self._parent.endian
+            assert endian != None
+            format = endian + format
+            
         self._format = format
-        self._is_string = self.isString()
+        self._real_format = getRealFormat(format)
+        self._is_string = formatIsString(self._format)
         if not self._is_string:
-            count = splitFormat(self._format)[1]
-            self._is_array = (count != 1)
+            self._is_array = (1 < splited[1])
         else:
-            self._is_array = False
+            self._is_array = False 
         self._size = getFormatSize(self._format)
         self._value = {}
        
@@ -295,9 +306,6 @@
     def getSmallFormat(self):
         return self._format
 
-    def isString(self):
-        return self._format[-1] == "s"
-
     def convertToStringSize(self, size):
         self._doSetFormat("%us" % size)
 
@@ -358,7 +366,7 @@
         if max_size not in self._value:
             data, truncated = self._getRawData(max_size)
             if not truncated:
-                data = struct.unpack(self._format, data)
+                data = struct.unpack(self._real_format, data)
                 if not self._is_array:
                     data = data[0]
             else:
@@ -375,3 +383,102 @@
             return convertDataToPrintableString(data)
         else:
             return data 
+
+class EnumChunk(FormatChunk):
+    def __init__(self, id, description, stream, format, dict, parent):
+        assert formatIsInteger(format)
+        FormatChunk.__init__(self, id, description, stream, format, parent)
+        self._dict = dict
+
+    def getDisplayData(self):
+        value = self.getValue()
+        return self._dict.get(value, "Unknow (%s)" % value)
+
+class BitsStruct(object):
+    size_to_struct = {
+        1: "B",
+        2: "H",
+        3: "L",
+        4: "L"}
+
+    def __init__(self, items=None):
+        self._items_list = []
+        self._items_dict = {}
+        self._size = 0
+        self._source = None
+        if items != None:
+            for item in items:
+                if 3<len(item):
+                    type = item[3]
+                else:
+                    type = None
+                self.add(item[0], item[1], item[2], type)
+            assert self.isValid()
+
+    def isValid(self):
+        return (0 < self._size) and ((self._size % 8) == 0)
+
+    def add(self, bits, id, description, type=None):
+        # TODO: (Maybe) Generate new id if another already exist
+        assert id not in self._items_dict
+        assert 0<bits
+        assert bits <= 32
+        if type == None:
+            if 1<bits:
+                type = "bits"
+            else:
+                type = "bit"
+        self._items_list.append(id)
+        self._items_dict[id] = (self._size, bits, type, description)
+        self._size += bits
+
+    def __getitem__(self, id):
+        assert self.isValid() 
+        item = self._items_dict[id]
+        addr = item[0]
+        size = item[1]
+        data = self._source.getRaw()
+        start = addr / 8
+        shift = addr % 8
+        mask = (1 << size) - 1
+        byte_size = (size + 7) / 8
+        data = data[start:start+byte_size]
+        type = BitsStruct.size_to_struct[byte_size]
+        value = struct.unpack(type, data)[0]
+        value = (value >> shift) & mask
+        if size == 1:
+            return value == 1
+        else:
+            return value
+
+    def setSource(self, source):
+        self._source = source
+
+    def _getSize(self):
+        assert self.isValid() 
+        return self._size / 8
+    size = property(_getSize)
+
+    def display(self, ui, parent):
+        for id in self._items_list:
+            item = self._items_dict[id]
+            addr = item[0]
+            size = item[1]
+            format = item[2]
+            desc = item[3]
+            display = self[id]
+            ui.add_table(parent, addr, size, format, id, desc, display)
+
+class BitsChunk(Chunk):
+    def __init__(self, id, description, stream, struct, parent):
+        Chunk.__init__(self, id, description, stream, stream.tell(), struct.size, parent)
+        self._struct = struct
+        self._struct.setSource(self)
+        stream.seek(self.size, 1)
+
+    def uiDisplay(self, ui):
+        path = ui.add_table(None, self.addr, self.size, "bits", self.id, self.description, "*bits*")
+        self._struct.display(ui, path)
+
+    def __getitem__(self, id):
+        return self._struct[id]

Modified: haypo/hachoir/trunk/default.py
===================================================================
--- haypo/hachoir/trunk/default.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/default.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,10 +1,11 @@
-from filter import Filter
+from filter import OnDemandFilter
+from chunk import FormatChunk
 
-class EmptyFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "empty", "Empty filter", stream, parent)
+#class EmptyFilter(OnDemandFilter):
+#    def __init__(self, stream, parent=None):
+#        OnDemandFilter.__init__(self, "empty", "Empty filter", stream, parent)
 
-class DefaultFilter(Filter):
+class DefaultFilter(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, "default", "Default filter", stream, parent)
-        self.read("data", "%us" % stream.getSize(), "Data")
+        OnDemandFilter.__init__(self, "default", "Default filter", stream, parent)
+        self.read("data", "Raw data", (FormatChunk, "string[%u]" % stream.getSize()))

Modified: haypo/hachoir/trunk/error.py
===================================================================
--- haypo/hachoir/trunk/error.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/error.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -5,9 +5,10 @@
 from tools import getBacktrace
 
 def warning(message):
+    log_message = message + "\n\n" + getBacktrace()
     if config.debug:
-        message = message + "\n\n" + getBacktrace()
-    log.warning(message)   
+        message = log_message
+    log.warning(log_message)   
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \
@@ -19,9 +20,10 @@
         dlg.destroy()
 
 def error(message, backtrace=None):
+    log_message = message + "\n\n" + getBacktrace()
     if config.debug:
-        message = message + "\n\n" + getBacktrace()
-    log.error(message)
+        message = log_message
+    log.error(log_message)
     if ui.ui.ui != None:
         import gtk
         dlg = gtk.MessageDialog( \

Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/filter.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -5,13 +5,14 @@
 import struct, re, sys, string, types
 import config
 import ui.ui as ui
-from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
+from chunk import Chunk, FormatChunk, FilterChunk, StringChunk, BitsChunk
 from error import error
-from tools import getBacktrace
-from format import getFormatSize
+from format import getFormatSize, splitFormat
 
-class BasicFilter:
-    def __init__(self, id, description, stream, parent, addr):
+class BasicFilter(object):
+    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
+
+    def __init__(self, id, description, stream, parent, addr, endian):
         self._id = id
         self._description = description
         self._stream = stream
@@ -19,17 +20,24 @@
         self._addr = addr 
         self._chunks_counter = {}
         self._chunks_dict = {}
+        self._endian = endian
+        self.filter_chunk = None
 
     def updateParent(self, chunk): pass
     def getId(self): return self._id
-    def setId(self, id): self._id = id
+    def setId(self, id):
+        if self._id == id:
+            return
+        self._id = id
+        if self.filter_chunk != None:
+            self.filter_chunk.id = id
     def getDescription(self): return self._description
     def setDescription(self, description): self._description = description
     def getAddr(self): return self._addr
     def setAddr(self, addr): self._addr = addr
     def getParent(self): return self._parent
     def getStream(self): return self._stream
-    def purgeCache(self): pass
+    def updateChunkId(self, old_id, new_id): pass
     def updateChunkDescription(self, id, desc): pass
     def __len__(self): return len(self._chunks_dict)
 
@@ -65,7 +73,7 @@
             pattern = "%s[%u]"
         else:
             # Manage id collision
-            m = Filter.regex_chunk_uniq_id.match(id)
+            m = BasicFilter.regex_chunk_uniq_id.match(id)
             if m != None:
                 root = m.group(1)
                 start = int(m.group(2)) + 1
@@ -88,13 +96,38 @@
     def getChunk(self, chunk_id): assert False
     def display(self): assert False
 
+    def _getEndian(self): return self._endian
+    endian = property(_getEndian)
+
 class OnDemandFilter(BasicFilter):
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
+    def __init__(self, id, description, stream, parent, endian=None):
+        BasicFilter.__init__(self, id, description, stream, parent, stream.tell(), endian)
         self._size = 0
         self._chunks = []
         self._chunks_cache = {}
     
+    def updateChunkId(self, old_id, new_id):
+        # Update self._chunks
+        pos = self._chunks.index(old_id)
+        assert pos != -1
+        self._chunks[pos] = new_id
+
+        # Update self._chunks_dict
+        info = self._chunks_dict[old_id]
+        info[0] = new_id
+        del self._chunks_dict[old_id]
+        self._chunks_dict[new_id] = info
+        
+        # Update self._chunks_dict
+        if old_id in self._chunks_cache:
+            cache = self._chunks_cache[old_id]
+            del self._chunks_cache[old_id]
+            self._chunks_cache[new_id] = cache
+
+        # Update display
+        info = self.displayChunkInfo(new_id)
+        ui.window.update_table(self, pos, *info)
+
     def updateChunkDescription(self, id, desc):
         pos = self._chunks.index(id)
         assert pos != -1
@@ -108,81 +141,78 @@
             print "Purge cache: destroy %s chunks" % len(self._chunks_cache)
         self._chunks_cache = {}
         
-    def doReadChild(self, id, description, filter_class, *args):
-        id = self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        return self.getChunk(id)
-        
-    def readChild(self, id, description, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, None, filter_class, *args)
-        
-    def readSizedChild(self, id, description, size, filter_class, *args): 
-        return self._readStreamChild(id, description, self._stream, size, filter_class, *args)
-        
-    def readStreamChild(self, id, description, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, None, filter_class, *args)
-
-    def readSizedStreamChild(self, id, description, size, filter_stream, filter_class, *args): 
-        return self._readStreamChild(id, description, filter_stream, size, filter_class, *args)
-
-    def _readStreamChild(self, id, description, filter_stream, size, filter_class, *args): 
+    def read(self, id, description, info, optionnal={}): 
+        chunk_class = info[0]
         id = self.getUniqChunkId(id)
         addr = self._stream.tell()
-        filter_addr = filter_stream.tell()
-        
-        if size == None:
-            filter = filter_class(filter_stream, self, *args)
-            description = filter.getDescription()
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            size = filter.getSize()
-            if config.verbose:
-                print "%s: Instanciate filter %s" % (self.getPath(), id)
-        else:
-            chunk = None
+        if issubclass(chunk_class, BasicFilter):
+            filter_stream = optionnal.get("stream", self._stream)
+            size = optionnal.get("size", None)
+            filter_addr = filter_stream.tell()
+            args = info[1:]
 
-        chunk_info = [id, description, addr, size, \
-                (filter_class, filter_stream, filter_addr, args), None, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        if chunk != None:
-            filter.updateParent(chunk)
-            self._chunks_cache[id] = chunk
-        self._size = self._size + size
-        self._stream.seek(addr + size)
-        return id
+            if size == None:
+                filter = chunk_class(filter_stream, self, *args)
+                description = filter.getDescription()
+                filter.setId(id)
+                chunk = FilterChunk(id, filter, self, addr)
+                size = filter.getSize()
+                if config.verbose:
+                    print "%s: Instanciate filter %s" % (self.getPath(), id)
+            else:
+                chunk = None
 
-    def doRead(self, id, format, description, post=None):
-        id = self.read(id, format, description, post)
-        return self.getChunk(id)
+            chunk_info = [id, description, addr, size, \
+                    (chunk_class, filter_stream, filter_addr, args), None, {}]
+            self._chunks_dict[id] = chunk_info
+            self._chunks.append(id)
+            if chunk != None:
+                filter.updateParent(chunk)
+                self._chunks_cache[id] = chunk
+            self._size = self._size + size
+            self._stream.seek(addr + size)
+            return id
 
-    def read(self, id, format, description, post=None):
-        id = self.getUniqChunkId(id)
-        size = getFormatSize(format)
-        addr = self._stream.tell()
-        chunk_info = [id, description, addr, size, \
-                (FormatChunk, id, description, self._stream, addr, format, self,), post, {}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
+        else:
+            post = optionnal.get("post", None)
+            if "post" in optionnal:
+                del optionnal["post"]
+            if isinstance(info, list):
+                args = info[1:]
+            else:
+                args = [ i for i in info[1:] ]
+            instance_info = [info[0], id, description, self._stream]+args+[self]
+            # TODO: Use static method to get chunk fixed size (if existing)
+            if chunk_class == FormatChunk:
+                size = getFormatSize(info[1])
+                self._stream.seek(size, 1)
+            else:
+                seek = False
+                chunk = info[0] (*instance_info[1:], **optionnal)
+                size = chunk.size
+                id = chunk.id
+                self._chunks_cache[id] = chunk
+            chunk_info = [id, description, addr, size, instance_info, post, optionnal]
+#            else:       
+#                assert chunk_class == StringChunk
+#                strip = optionnal.get("strip", None)
+#                chunk = chunk_class (id, description, self._stream, info[1:], self, strip=strip)
+#                chunk_info = [id, description, addr, size, \
+#                        (info[0], id, description, self._stream, info[1:], self,), post, optionnal]
+#                self._chunks_cache[id] = chunk
+            self._chunks_dict[id] = chunk_info
+            self._chunks.append(id)
+            self._size = self._size + size
+            return id
 
-    def readString(self, id, format, description, post=None, strip=None):
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
+    def doRead(self, id, description, info, optionnal={}):
+        id = self.read(id, description, info, optionnal)
+        chunk = self.getChunk(id)
+        if isinstance(chunk, FilterChunk):
+            return chunk.getFilter()
+        else:
+            return chunk
 
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        size = chunk.size
-
-        chunk_info = [id, description, addr, size, \
-                (StringChunk, id, description, self._stream, format, self,), post, {"strip": strip}]
-        self._chunks_dict[id] = chunk_info
-        self._chunks.append(id)
-        self._chunks_cache[id] = chunk
-#        self._stream.seek(size, 1)
-        self._size = self._size + size
-        return id
-
     def displayChunkInfo(self, id):
         info = self._chunks_dict[id]
         chunk_class = info[4][0]
@@ -202,7 +232,10 @@
         ui.window.clear_table()
         for id in self._chunks:
             info = self.displayChunkInfo(id)
-            ui.window.add_table(*info)
+            if self._chunks_dict[id][4][0] == BitsChunk:
+                self.getChunk(id).uiDisplay(ui.window)
+            else:
+                ui.window.add_table(*info)
  
     def getSize(self): return self._size
 
@@ -238,8 +271,11 @@
         if id not in self._chunks_dict:
             return None
         if id not in self._chunks_cache:
-            self._chunks_cache[id] = self._createInstance(id) 
-        return self._chunks_cache[id]
+            chunk = self._createInstance(id) 
+            self._chunks_cache[chunk.id] = chunk 
+            return chunk
+        else:
+            return self._chunks_cache[id]
 
     def __getitem__(self, id):
         assert id in self._chunks_dict
@@ -249,440 +285,11 @@
         else:
             return chunk.value
 
-class Filter(BasicFilter):
-    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
-
-    def __init__(self, id, description, stream, parent):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell())
-        self.filter_chunk = None 
-        self._chunks = []
-        self._chunks_dict = {}
-        self._cache_valid = False
-        self._cache_size = None
-
-    def __getitem__(self, chunk_id):
-        return self.getChunk(chunk_id).getValue()
-
-    def clone(self, addr=None):
-        if self.__class__ == Filter:
-            return None
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        try:
-            new = self.__class__(self.getStream(), self.getParent())
-        except:
-            error("Error while clone class of type %s!" % self.__class__)
-            raise
-        new.filter_chunk = self.filter_chunk
-        return new
-
-    def _deleteChunk(self, pos):
-        self._cache_valid = False
-        chunk = self._chunks[pos]
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)        
-        del self._chunks[pos]
-
-    def deleteChunk(self, chunk):
-        if len(self._chunks) < 2:
-            error("Can't not delete the chunk %s (there is only one chunk)." % chunk.id)
-            return            
-        chunk_size = chunk.size
-        pos = self._chunks.index(chunk)
-        self._deleteChunk(pos)
-        # Delete last chunk of a sub filter? It true, truncate the sub filter
-        truncate = (self.getParent() != None and pos == len(self._chunks))
-        self.rescanFromPos(pos, -chunk_size, truncate=truncate)
-        self.redisplay()
-
-    def getChunks(self):
-        return self._chunks
-
-    def updateChunkId(self, chunk, new_id):
-        if chunk.id == new_id: return
-        if new_id in self._chunks_dict or hasattr(self, new_id):
-            raise Exception("Chunk identifier \"%s\" already exist!" % new_id)
-        if hasattr(self, chunk.id):
-            value = getattr(self, chunk.id)
-            delattr(self, chunk.id)
-            setattr(self, new_id, value)
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        self._chunks_dict[new_id] = chunk
-        
-    def addRawChunk(self, prev_chunk, id, size, description):
-        if prev_chunk != None:
-            addr = prev_chunk.addr + prev_chunk.size
-            chunk_pos = self._chunks.index(prev_chunk)+1
-        else:
-            addr = self.getAddr()
-            chunk_pos = len(self._chunks)
-        chunk = FormatChunk(id, description, self.getStream(), addr, "!%ss" % size, self)
-        self.appendChunk(chunk, position=chunk_pos)
-
-    def rescan(self, from_chunk, diff_size, new_id=None, new_description=None, truncate=False):
-        if from_chunk != None:
-            start = self._chunks.index(from_chunk)+1
-        else:
-            start = 0
-        self.rescanFromPos(start, diff_size, new_id, new_description, truncate)
-            
-    def _rescanUpdateSize(self, diff_size, new_id=None, new_description=None):
-        # Only process diff_size < 0
-        if 0 <= diff_size: return
-
-        # Get last chunk
-        if 0 < len(self._chunks):
-            prev_chunk = self._chunks[-1]
-        else:
-            prev_chunk = None
-        
-        if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
-            # If last chunk is a FormatChunk, update it's size
-            size = prev_chunk.size - diff_size
-            prev_chunk.convertToStringSize(size)
-            self._cache_valid = False
-        else:
-            # Get id
-            if new_id != None:
-                id = new_id
-            else:
-                id = "raw"
-            id = self.getUniqChunkId(id)
-
-            # Get description
-            if new_description != None:
-                description = new_description
-            else:
-                description = ""
-
-            # Get size
-            if self.getParent() == None:
-                size = self._stream.getSize() - self.getSize() 
-            else:
-                size = -diff_size
-            self.addRawChunk(prev_chunk, id, size, description)
-
-    def _rescanUpdateChunks(self, start, prev_chunk):
-        self._cache_valid = False
-        pos = start
-        try:
-            for chunk in self._chunks[start:]:
-                # Update start address
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error("Exception while updating a filter:\n%s\n%s" \
-                % (msg,getBacktrace()))
-            iter = len(self._chunks)-1
-            while pos<=iter:
-                self._deleteChunk(iter)
-                iter = iter - 1
-
-    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate=False):
-        assert 0<=start and start <= len(self._chunks)
-        self._cache_valid = False
-        if 0<start:
-            prev_chunk = self._chunks[start-1]
-        else:
-            prev_chunk = None
-
-        # Update chunks address
-        old_size = self.getSize()
-        self._rescanUpdateChunks(start, prev_chunk)
-        diff_size = diff_size + (self.getSize() - old_size)
-
-        # Update last chunk size if needed
-        if not truncate:
-            self._rescanUpdateSize(diff_size, new_id, new_description)
-            diff_size = 0
-               
-        if self.getParent() != None:
-            self.getParent().rescan(self.filter_chunk, diff_size)
-
-    def getLastPos(self):
-        if len(self._array) == 0: return self.getAddr()
-        last_chunk = self._array[-1]
-        return last_chunk.addr + last_chunk.size
-
-    def getSize(self):
-        if not self._cache_valid:
-            self._cache_valid = True
-            size = 0
-            for chunk in self._chunks:
-                size = size + chunk.size
-            self._cache_size = size
-        return self._cache_size
-
-    def addString(self, str_type, before_chunk):
-        if before_chunk != None:
-            pos = self._chunks.index(before_chunk)
-            addr = before_chunk.addr
-        else:
-            pos = len(self._chunks)
-            addr = self.getAddr()
-        stream = self.getStream()
-        stream.seek(addr)
-        id = self.getUniqChunkId("str")
-        str_chunk = StringChunk(id, "String", stream, str_type, self)
-        self.appendChunk(str_chunk, position=pos)
-        str_chunk.postProcess()
-        before_chunk.addr = before_chunk.addr + str_chunk.size
-        before_chunk.convertToStringSize(before_chunk.size - str_chunk.size)
-        self.redisplay()
-        return str_chunk
-
-    def updateParent(self, chunk):
-        pass
-
-    def getChunk(self, chunk_id):
-        chunk = self._chunks_dict.get(chunk_id, None)
-        if chunk == None:
-            raise Exception("Filter \"%s\" has no chunk with id \"%s\"." \
-                % (self.getId(), chunk_id))
-        return chunk
-
-    def displayChunk(self, chunk):
-        type = chunk.getSmallFormat()
-        if isinstance(chunk, FilterChunk):
-            addr = chunk.parent_addr
-        else:
-            addr = chunk.addr
-        ui.window.add_table(None, addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
-
-    def redisplay(self):  
-        self.display()
-    
-    def display(self):  
-        ui.window.enableParentButton(self.getParent() != None)
-            
-        # Update table
-        ui.window.clear_table()
-        for chunk in self._chunks:
-            self.displayChunk(chunk)
-
-    def readField(self, id, description, delimiter):
-        lg = self._stream.searchLength(delimiter, False)
-        if lg == -1:
-            raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
-        self.read(id, "!%us" % lg, description) 
-        self.read(id+"_delimiter", "!%us" % len(delimiter), "Delimiter of %s" % id) 
-
-    def searchEol(self, eol):
-        lg = self._stream.searchLength(eol, True)
-        if lg == -1:
-            return self._stream.getLastPos() - self._stream.tell()
-        else:
-            return lg
-
-    def readLine(self, id, description, eol="\n", fails_if_not_found=False, can_truncate=False):
-        lg = self.searchEol(eol)
-        self.read(id, "!%us" % lg, description, truncate=can_truncate)
-        line = getattr(self, id)
-        setattr(self, id, line[:-len(eol)])
-
-    def updateFormatChunk(self, chunk):
-        if chunk.id == None: return
-        self._cache_valid = False
-        data = chunk.getValue(config.max_string_length)
-        setattr(self, chunk.id, data)       
-
-    def appendChunk(self, chunk, position=None):
-        self._cache_valid = False
-        if position == None:
-            self._chunks.append(chunk)
-        else:
-            self._chunks.insert(position, chunk)
-        self._chunks_dict[chunk.id] = chunk
-
-    def readLimitedChild(self, id, size, filter_class, *args):
-        start = self._stream.tell()
-        limited = self._stream.createLimited(start, size)
-        chunk = self.readStreamChild(id, limited, filter_class, *args)
-        assert self._stream.tell() == (start+size)
-        return chunk
-        
-    def readStreamChild(self, id, stream, filter_class, *args): 
-        id = self.getUniqChunkId(id)
-        oldpos = self._stream.tell()
-        filter = filter_class(stream, self, *args)
-        filter.setId(id)
-        chunk = self.addFilter(id, filter, oldpos)
-        chunk.postProcess()
-        self._stream.seek(oldpos + chunk.size)
-        return chunk
-        
-    def readChild(self, id, filter_class, *args): 
-        return self.readStreamChild(id, self._stream, filter_class, *args)
-    
-    def addFilter(self, id, filter, addr): 
-        chunk = FilterChunk(id, filter, self, addr)
-        self.appendChunk(chunk)
-        filter.updateParent(chunk)
-        return chunk
-
-    def readArray(self, id, entry_class, description, end_func): 
-        """
-        end_func: def isEnd(stream, array, last_filter)
-        """
-        addr = self._stream.tell()
-        filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
-        chunk = self.addFilter(id, filter, addr)
-        chunk.postProcess()
-        return chunk
-    
-    def readString(self, id, format, description, post=None, strip=None):
-        """ Returns chunk """
-        id = self.getUniqChunkId(id)
-        chunk = StringChunk(id, description, self._stream, format, self, strip=strip)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-    
-    def read(self, id, format, description, post=None):
-        """ Returns chunk """
-        id = self.getUniqChunkId(id)
-        chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
-        self.appendChunk(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
-        chunk.post_process = post
-        chunk.postProcess()
-        return chunk
-
-    def __str__(self):
-        return "Filter(%s) <id=%s, description=%s>" % \
-            (self.__class__, self.getId(), self.getDescription())
-
-    def addNewFilter(self, chunk, id, size, desc):
-        chunk.setFormat("%us" % size, "split", id, desc)
-        self.convertChunkToFilter(chunk)
-
-    def convertFilterToChunk(self, chunk):
-        # Create new format chunk
-        filter = chunk.getFilter()
-        id = self.getUniqChunkId(filter.getId())
-        new_chunk = FormatChunk(id, filter.getDescription(), filter.getStream(), filter.getAddr(), "!%us" % filter.getSize(), self)
-
-        # Delete old chunk
-        if chunk.id in self._chunks_dict:
-            del self._chunks_dict[chunk.id]
-        if hasattr(self, chunk.id):
-            delattr(self, chunk.id)
-
-        # Assign new chunk
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[id] = new_chunk
-        setattr(self, id, chunk.getValue(40))
-        self.redisplay()
-        return new_chunk 
-
-    def convertChunkToFilter(self, chunk):
-        # Create new filter
-        stream = self.getStream()
-        stream.seek(chunk.addr)
-        filter = Filter(chunk.id, chunk.description, stream, self)
-        chunk.setParent(filter)
-        filter.appendChunk(chunk)
-        
-        # Create new chunk and add it into self 
-        new_chunk = FilterChunk(chunk.id, filter, self, chunk.addr)
-        pos = self._chunks.index(chunk)
-        self._chunks[pos] = new_chunk
-        self._chunks_dict[chunk.id] = new_chunk
-        self.redisplay()
-        return filter
-
-class ArrayFilter(Filter):
-    def __init__(self, id, description, stream, parent, entry_class, end_func):
-        Filter.__init__(self, id, description, stream, parent)
-        self._entry_class = entry_class
-        self._end_func = end_func
-        self._read()
-
-    def _read(self):
-        self._array = []
-        nb = 0
-        last_filter = None
-        while not self._end_func(self._stream, self._array, last_filter):
-            chunk_id = "%s[%u]" % (self.getId(), nb)
-            addr = self._stream.tell()
-            filter = self._entry_class(self._stream, self)
-            filter.setId(chunk_id)
-            nb = nb + 1
-            chunk = FilterChunk(chunk_id, filter, self, addr)
-            self._array.append( chunk )
-            self.appendChunk(chunk)
-            last_filter = filter
-
-        for chunk in self._array:
-            chunk.getFilter().updateParent(chunk)
-        if 1<nb:
-            self.setDescription( "%s (%s items)" % (self.getDescription(), nb))
-        else:
-            self.setDescription( "%s (%s item)" % (self.getDescription(), nb))
-
-    def getArray(self):
-        return self._array
-    
-    def _deleteChunk(self, pos):
-        Filter._deleteChunk(self, pos)
-        if pos < len(self._array):
-            del self._array[pos]
-
-    def update(self):
-        self._cache_valid = False
-        prev_chunk = None
-        pos = 0
-        try:
-            for chunk in self._array:
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.getAddr()
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error("Exception while updating an ArrayFilter:\n%s" % msg)
-            chunk = self._array[pos]
-            addr = chunk.addr
-            size = self.getLastPos() - addr
-            del self._array[pos:]
-            if size != 0:
-                chunk = FormatChunk("raw", "Raw data", chunk.getStream(), addr, "!%us" % size, self)
-                self._array.append(chunk)
-
-    def __len__(self):
-        return len(self._array)
-
-    def __getitem__(self, index):
-        return self._array[index]
-
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self.getAddr()
-        self.getStream().seek(addr)
-        new = ArrayFilter( self.getId(), self.getDescription(), \
-            self.getStream(), self.getParent(), self._entry_class, self._end_func)
-        new.filter_chunk = self.filter_chunk
-        return new
-
-class DeflateFilter(Filter):
+class DeflateFilter(OnDemandFilter):
     def __init__(self, stream, parent, bz_stream, size, filter, *args):
-        Filter.__init__(self, "deflate", "Deflate", bz_stream, parent)
+        OnDemandFilter.__init__(self, "deflate", "Deflate", bz_stream, parent)
         self._addr = stream.tell()
-        self.readChild("data", filter, *args)
+        self.read("data", "Data", [filter]+[i for i in args])
         self._compressed_size = size
 
     def getSize(self):

Modified: haypo/hachoir/trunk/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/format.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,40 +1,74 @@
 import re, struct
 
-_regex_format1 = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLbhscfd]$")
-_regex_format2 = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLbhscfd])$")
+_regex_array =  re.compile("^([a-z]+[0-9]*)\[([0-9]+)\]$")
 _format_size_cache = {}
+_format_type = {
+    "string": "s",
+    "char": "c",
+    "float": "f",
+    "double": "d",
+    "int8": "b",
+    "uint8": "B",
+    "int16": "h",
+    "uint16": "H",
+    "int32": "l",
+    "uint32": "L"
+}
 
+def _convertNewFormat(format):
+    old_format = format
+    if format[0] in "!<>":
+        endian = format[0]
+        str_endian = format[0]
+        format = format[1:]
+    else:
+        endian = None
+        str_endian = ""
+    m = _regex_array.match(format)
+    if m != None:
+        format = m.group(1)
+        str_count = m.group(2)
+        count = int(str_count)
+    else:
+        str_count = "" 
+        count = 1
+    if format not in _format_type:
+        raise Exception("Format \"%s\" is invalid!" % old_format)
+    type = _format_type[format]
+    return (str_endian + str_count + type, endian, count, type)
+
 def _getFormatCache(format):
     global _format_size_cache
     if format not in _format_size_cache:
-        assert checkFormat(format)
-        endian, count, type = _doSplitFormat(format)
+        real_format, endian, count, type = _convertNewFormat(format)
         size = count * struct.calcsize(type)
-        _format_size_cache[format] = (endian, count, type, size)
+        _format_size_cache[format] = (real_format, endian, count, type, size)
     return _format_size_cache[format]   
 
+def formatIsString(format):
+    cache = _getFormatCache(format)
+    return cache[3] == "s"
+
+def formatIsInteger(format):
+    cache = _getFormatCache(format)
+    return cache[3] in "bBhHlL"
+
 def getFormatSize(format):
     cache = _getFormatCache(format)
-    return cache[3]   
+    return cache[4]   
 
+def getRealFormat(format):
+    cache = _getFormatCache(format)
+    return cache[0]   
+
 def checkFormat(format):
-    m = _regex_format1.match(format)
-    return m != None
+    # TODO: Don't use try/except, but something better
+    try:
+        conv = _convertNewFormat(format)
+        return True
+    except:
+        return False
 
 def splitFormat(format):
     cache = _getFormatCache(format)
-    return cache[:3]   
-
-def _doSplitFormat(format):
-    m = _regex_format2.match(format)
-    assert m != None
-    endian = m.group(1)
-    count = m.group(2)
-    type = m.group(3)
-    if endian == "":
-        endian = "!"
-    if count != "":
-        count = long(count)
-    else:
-        count = 1
-    return (endian, count, type,)
+    return cache[1:4]   

Added: haypo/hachoir/trunk/generic/__init__.py
===================================================================

Added: haypo/hachoir/trunk/generic/image.py
===================================================================
--- haypo/hachoir/trunk/generic/image.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/generic/image.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -0,0 +1,20 @@
+from chunk import FormatChunk
+from filter import OnDemandFilter
+
+class RGB(OnDemandFilter):
+    name = {
+        0x000000: "Black",
+        0xFFFFFF: "White"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "rgb_color", "RGB color", stream, parent, "!")
+        self.read("red", "Red", (FormatChunk, "uint8"))
+        self.read("green", "Green", (FormatChunk, "uint8"))
+        self.read("blue", "Blue", (FormatChunk, "uint8"))
+
+    def updateParent(self, chunk):
+        value = self["red"] << 16 + self["green"] << 8 + self["blue"]
+        if value in RGB.name:
+            chunk.description = "RGB color: "+RGB.name[value]
+        else:
+            chunk.description = "RGB color: #%02X%02X%02X" % (self["red"], self["green"], self["blue"])

Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/hachoir.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -129,9 +129,7 @@
     except SystemExit:
         pass
     except Exception, err:
-        where = "".join(traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback))
-        error("Exception:\n%s\n%s" % (err, where))
+        error("Python Exception: %s" % err)
 	sys.exit(1)
 
 if __name__=="__main__": main()    

Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/hachoir_class.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,6 +1,6 @@
 from stream.file import FileStream
 from plugin import getPluginByStream
-from chunk import FilterChunk
+from chunk import FilterChunk, FormatChunk
 from default import DefaultFilter
 from user_filter import UserFilterDescriptor, loadUserFilter
 from error import error, warning
@@ -88,7 +88,8 @@
         stream_size = self._main_filter.getStream().getSize()
         diff_size = filter_size - stream_size
         if diff_size < 0:
-            self._main_filter.read("end", "%us" % (-diff_size), "Raw data")
+            print "Pad", "string[%u]" % -diff_size
+            self._main_filter.read("end", "Raw data", (FormatChunk, "string[%u]" % -diff_size))
 
     def loadFile(self, filename):
         try:

Deleted: haypo/hachoir/trunk/plugins/3ds.py
===================================================================
--- haypo/hachoir/trunk/plugins/3ds.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/3ds.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,175 +0,0 @@
-"""
-3D Studio Max file (.3ds) parser.
-Author: Victor Stinner
-"""
-
-from filter import Filter, OnDemandFilter
-from plugin import registerPlugin
-
-def readTextureFilename(filter, stream, last_pos):
-    filter.readString("filename", "C", "Texture filename")
-
-def readVersion(filter, stream, last_pos):
-    filter.read("version", "<L", "Version")
-
-def readMaterialName(filter, stream, last_pos):
-    filter.readString("name", "C", "Material name")
-
-def readObject(filter, stream, last_pos):
-    chunk = filter.readString("name", "C", "Object name")
-    while stream.tell() < last_pos:
-        filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
-
-class Filter_3DS_MapUV(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_map", "3DS UV map", stream, parent)
-        self.read("u", "f", "Map U")
-        self.read("v", "f", "Map V")
-
-class Filter_3DS_Vertex(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_vertex", "3DS vertex", stream, parent)
-        self.read("x", "f", "X")
-        self.read("y", "f", "Y")
-        self.read("z", "f", "Z")
-
-class Filter_3DS_Polygon(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_polygon", "3DS polygon", stream, parent)
-        self.read("a", "<H", "Vertex A")
-        self.read("b", "<H", "Vertex B")
-        self.read("c", "<H", "Vertex C")
-        self.read("flags", "<H", "Flags")
-    
-def readMapList(filter, stream, last_pos):
-    filter.read("count", "<H", "Map count")
-    for i in range(0, filter["count"]):
-        filter.readSizedChild("map[]", "Map UV", 2*4, Filter_3DS_MapUV)
-
-def readColor(filter, stream, last_pos):
-    filter.read("red", "B", "Red componant")
-    filter.read("green", "B", "Green componant")
-    filter.read("blue", "B", "Blue componant")
-
-def readVertexList(filter, stream, last_pos):
-    filter.read("count", "<H", "Vertex count")
-    for i in range(0, filter["count"]):
-        filter.readSizedChild("vertex[]", "Vertex", 3*4, Filter_3DS_Vertex)
-    
-def readPolygonList(filter, stream, last_pos):
-    filter.read("count", "<H", "Vertex count")
-    for i in range(0, filter["count"]):
-        filter.readSizedChild("polygon[]", "Polygon", 4*2, Filter_3DS_Polygon)
-    while stream.tell() < last_pos:
-        filter.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
-
-class Filter_3DS_Chunk(OnDemandFilter):
-    # List of chunk type name
-    type_name = {
-        0x0011: "Color",
-        0x4D4D: "Main chunk",
-        0x0002: "File version",
-        0x3D3D: "Materials and objects",
-        0x4000: "Object",
-        0x4100: "Mesh (triangular)",
-        0x4110: "Vertices list",
-        0x4120: "Polygon (faces) list",
-        0x4140: "Map UV list",
-        0x4130: "Object material",
-        0xAFFF: "New material",
-        0xA000: "Material name",
-        0xA010: "Material ambiant",
-        0xA020: "Material diffuse",
-        0xA030: "Texture specular",
-        0xA200: "Texture",
-        0xA300: "Texture filename",
-
-        # Key frames
-        0xB000: "Keyframes",
-        0xB002: "Object node tag",
-        0xB006: "Light target node tag",
-        0xB007: "Spot light node tag",
-        0xB00A: "Keyframes header",
-        0xB009: "Keyframe current time",
-        0xB030: "Node identifier",
-        0xB010: "Node header",
-        0x7001: "Viewport layout"
-    }
-
-    chunk_id_by_type = {
-        0x4d4d: "main",
-        0x0002: "version",
-        0x3d3d: "obj_mat",
-        0xb000: "keyframes",
-        0xafff: "material",
-        0x4000: "object"
-    }
-
-    # List of chunks which contains other chunks
-    sub_chunks = \
-        (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
-         0xB002, 0xB006, 0xB007,
-         0xA010, 0xA030, 0xA020, 0xB000)
-
-    # List of chunk type handlers
-    handlers = {
-        0xA000: readMaterialName,
-        0x4000: readObject,
-        0xA300: readTextureFilename,
-        0x0011: readColor,
-        0x0002: readVersion,
-# TODO: Uncomment these functions, it's too slow yet            
-         0x4110: readVertexList,
-         0x4120: readPolygonList,
-         0x4140: readMapList
-    }
-    
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
-        chunk = self.doRead("type", "<H", "Chunk type", post=self.toHex)
-        chunk.description = "Chunk type (%s)" % self.getType()
-        self.read("size", "<L", "Chunk size")
-        size = self["size"] - 6
-        type = self["type"] 
-        end = stream.tell() + size
-        if type in Filter_3DS_Chunk.sub_chunks:
-            while stream.tell() < end:
-                self.readChild("chunk[]", "Chunk", Filter_3DS_Chunk)
-            assert stream.tell() == end 
-        else:
-            if type in Filter_3DS_Chunk.handlers: 
-                end = stream.tell() + size
-                Filter_3DS_Chunk.handlers[type] (self, stream, end)
-                assert stream.tell() == end
-            else:
-                self.read("data", "%us" % size, "Raw data")
-
-    def checkEnd(self, stream, array, last):
-        return stream.eof()
-
-    def updateParent(self, chunk):
-        type = self.getType()
-        chunk.description = "Chunk of type \"%s\"" % type
-        self.setDescription("Chunk type (%s)" % type)
-        if self["type"] in Filter_3DS_Chunk.chunk_id_by_type:
-            id = Filter_3DS_Chunk.chunk_id_by_type[self["type"]]
-# TODO: Re-enable that            
-#            chunk.id = id
-            self.setId(id) 
-        else:
-            self.setId("chunk_%04x" % self["type"])
-
-    def toHex(self, chunk):
-        return "%04X" % chunk.value
-        
-    def getType(self):
-        type = self["type"]
-        return Filter_3DS_Chunk.type_name.get(type, "%04X" % type)
-
-class Filter_3DS_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "3ds_file", "3DS file", stream, parent)
-        while not stream.eof():
-            self.readChild("chunk[]", Filter_3DS_Chunk)
-
-registerPlugin(Filter_3DS_File, "image/x-3ds")

Deleted: haypo/hachoir/trunk/plugins/ar.py
===================================================================
--- haypo/hachoir/trunk/plugins/ar.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/ar.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,39 +0,0 @@
-"""
-GNU ar archive : archive file (.a) and Debian (.deb) archive.
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin, guessPlugin
-from error import error
-   
-class ArchiveFileEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "file_entry", "File entry", stream, parent)
-        self.readString("header", "UnixLine", "Header")
-        info = self["header"].split()
-        assert len(info) == 7
-        self.filename = info[0]
-        self.size = int(info[5])
-        dataio = stream.createSub(stream.tell(), self.size)
-        plugin = guessPlugin(dataio, self.filename)
-        self.readChild("data", DeflateFilter, dataio, self.size, plugin)
-
-    def updateParent(self, chunk):
-        desc = "File entry (%s)" % self.filename
-        chunk.description = desc
-        self.setDescription(desc)
-        
-class ArchiveFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "ar_file", "GNU ar file", stream, parent)
-        self.readString("id", "UnixLine", "ar archive identifier")
-        while not stream.eof():
-            while True:
-                data = stream.read(1, False)
-                if data == "\n":
-                    self.readString("empty_line[]", "UnixLine", "Empty line")
-                else:
-                    break
-            self.readChild("file[]", ArchiveFileEntry)
-        
-registerPlugin(ArchiveFile, ["application/x-debian-package", "application/x-archive"])

Deleted: haypo/hachoir/trunk/plugins/asn1.py
===================================================================
--- haypo/hachoir/trunk/plugins/asn1.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/asn1.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,92 +0,0 @@
-"""
-ASN1 Parser
-
-Information: http://www.openssl.org/docs/apps/asn1parse.html
-
-Author: Victor Stinner
-"""
-
-from filter import Filter
-
-class ASN1_Sequence(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "asn1_seq", "ASN1 sequence", stream, parent)
-        self.readArray("item", ASN1_Object, "Items", self.checkEnd)
-
-    def checkEnd(self, stream, array, last):        
-        return stream.eof()
-
-class ASN1_Object(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "asn1_obj", "ASN1 object", stream, parent)
-        
-        import sys
-        sys.stdout.write("%s: " % stream.tell())
-        
-        self.read("type", "B", "type")
-        tag = self.type & 0x1f
-        if tag == 0x1f:
-            raise Exception("Error in ASN1 parser: TODO ...")
-        else:
-            length = stream.getFormat("B", False)[0]
-            if 128 <= length:
-                size = length & 0x7f 
-                length = 0
-                oldpos = stream.tell()
-                for i in range(0,size):
-                    stream.seek(oldpos+1+i)
-                    new = stream.getFormat("B", False)[0]
-                    length = length * 256 + new
-                    assert length < (1 << 32)
-                stream.seek(oldpos)
-                self.length = length
-                self.read("dummylength", "%uB" % (1+size), "Length")
-            else:
-                self.read("length", "B", "Length")
-            print "Length = %s" % self.length
-            self.getChunk("type").description = "type (tag=%s)" % tag
-            handler = {
-                0: self.readEOC,
-                1: self.readBoolean,
-                4: self.readOctetString,
-#                6: self.readObject,
-                10: self.readEnum,
-                12: self.readUTF8,
-                16: self.readSequence
-            }
-            if tag in handler:
-                handler[tag]()
-            else:
-                self.read("value", "%us" % length, \
-                    "Value (don't know tag %s)" % tag)
-
-    def readEnum(self):
-        self.read("value", "%us" % self.length, "Value (EOC)")
-
-    def readObject(self):
-        self.readChild("object", ASN1_Object)
-
-    def readEOC(self):
-        self.read("value", "%us" % self.length, "Value (EOC)")
-
-    def readOctetString(self):
-        self.read("value", "%us" % self.length, "Value (octet string)")
-
-    def readBoolean(self):
-        self.read("value", "B", "Value (boolean)")
-
-    def readUTF8(self):
-        self.read("value", "%us" % self.length, "Value (string)")
-        
-    def readSequence(self):
-        self.readLimitedChild("sequence", self.length, ASN1_Sequence)
-
-class ASN1_Parser(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "asn1", "ASN1 parser", stream, parent)
-        #self.readArray("item", ASN1_Object, "Items", self.checkEnd)
-        self.readChild("a", ASN1_Object)
-#        self.readChild("b", ASN1_Object)
-
-    def checkEnd(self, stream, array, last):        
-        return stream.eof()

Modified: haypo/hachoir/trunk/plugins/avi.py
===================================================================
--- haypo/hachoir/trunk/plugins/avi.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/avi.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -6,9 +6,10 @@
 Author: Victor Stinner
 """
 
-from filter import Filter, OnDemandFilter
+from filter import OnDemandFilter
 from plugin import registerPlugin
 from tools import humanFilesize
+from chunk import FormatChunk
 
 class MovieChunk(OnDemandFilter):
     twocc_description = {
@@ -19,9 +20,9 @@
     }
 
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "movie_chunk", "Movie chunk", stream, parent)
-        self.read("fourcc", "4s", "Stream chunk four character code")
-        size = self.doRead("size", "<L", "Size").value
+        OnDemandFilter.__init__(self, "movie_chunk", "Movie chunk", stream, parent, "<")
+        self.read("fourcc", "Stream chunk four character code", (FormatChunk, "string[4]"))
+        size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
         if size == 0:
             self.type = "(empty)"
             return
@@ -33,10 +34,10 @@
             desc = "Junk"
         else:
             desc = "Raw data"
-        self.read("data", "%us" % size, desc)
+        self.read("data", desc, (FormatChunk, "string[%u]" % size))
         self.type = desc
         if size & 1:
-            self.read("padding", "%us" % 1, "Padding")
+            self.read("padding", "Padding", (FormatChunk, "uint8"))
 
     def updateParent(self, chunk):
         desc = "Movie chunk: %s" % self.type
@@ -55,97 +56,97 @@
         self.chunk_count = 0
         start = stream.tell()
         while 8 <= end - stream.tell():
-            #?Little hack to read chunk size
+            # Little hack to read chunk size
             stream.seek(4, 1)
-            chunk_size = stream.getFormat("<L", False)[0]
+            chunk_size = stream.getFormat("<uint32", False)
             stream.seek(-4, 1)
             chunk_size = 8 + chunk_size + chunk_size % 2
             # End of little hack :-)
-            self.readSizedChild("chunk[]", "Movie chunk", chunk_size, MovieChunk)
+            self.read("chunk[]", "Movie chunk", (MovieChunk,), {"size": chunk_size})
             self.chunk_count += 1
             if self.chunk_count % 1000 == 0:
                 print "Parse stream: %u %%" % ((stream.tell() - start) * 100 / size)
         size = end - stream.tell()
         if size > 0:
-            self.read("end", "%us" % size, "Raw data")
+            self.read("end", "Raw data", (FormatChunk, "string[%u]" % size))
         print " ********* END OF STREAM PARSING ************"
 
     def updateParent(self, chunk):
         chunk.description = "Movie stream: %u chunks" % self.chunk_count
 
-class Header(Filter):
+class Header(OnDemandFilter):
     def __init__(self, stream, parent, stream_type):
-        Filter.__init__(self, "header", "Header", stream, parent)
-        tag = self.read("tag", "4s", "Tag").value
-        size = self.read("size", "<L", "Size").value
+        OnDemandFilter.__init__(self, "header", "Header", stream, parent, "<")
+        tag = self.doRead("tag", "Tag", (FormatChunk, "string[4]")).value
+        size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
         self.type = "Unknow"
         if tag == "strh" and size >= 56:
             # Stream header
             self.type = "Stream header"
             hend = stream.tell() + size
-            self.read("type_fourcc", "4s", "Stream type four character code")
-            self.read("fourcc", "4s", "Stream four character code")
-            self.read("flags", "<L", "Stream flags")
-            self.read("priority", "<H", "Stream priority")
-            self.read("langage", "2s", "Stream language")
-            self.read("init_frames", "<L", "InitialFrames")
-            self.read("scale", "<L", "Time scale")
-            self.read("rate", "<L", "Divide by scale to give frame rate")
-            self.read("start", "<L", "Stream start time (unit: rate/scale)")
-            self.read("length", "<L", "Stream length (unit: rate/scale)")
-            self.read("buf_size", "<L", "Suggested buffer size")
-            self.read("quality", "<L", "Stream quality")
-            self.read("sample_size", "<L", "Size of samples")
-            self.read("left", "<H", "Destination rectangle (left)")
-            self.read("top", "<H", "Destination rectangle (top)")
-            self.read("right", "<H", "Destination rectangle (right)")
-            self.read("bottom", "<H", "Destination rectangle (bottom)")
+            self.read("type_fourcc", "Stream type four character code", (FormatChunk, "string[4]"))
+            self.read("fourcc", "Stream four character code", (FormatChunk, "string[4]"))
+            self.read("flags", "Stream flags", (FormatChunk, "uint32"))
+            self.read("priority", "Stream priority", (FormatChunk, "uint16"))
+            self.read("langage", "Stream language", (FormatChunk, "string[2]"))
+            self.read("init_frames", "InitialFrames", (FormatChunk, "uint32"))
+            self.read("scale", "Time scale", (FormatChunk, "uint32"))
+            self.read("rate", "Divide by scale to give frame rate", (FormatChunk, "uint32"))
+            self.read("start", "Stream start time (unit: rate/scale)", (FormatChunk, "uint32"))
+            self.read("length", "Stream length (unit: rate/scale)", (FormatChunk, "uint32"))
+            self.read("buf_size", "Suggested buffer size", (FormatChunk, "uint32"))
+            self.read("quality", "Stream quality", (FormatChunk, "uint32"))
+            self.read("sample_size", "Size of samples", (FormatChunk, "uint32"))
+            self.read("left", "Destination rectangle (left)", (FormatChunk, "uint16"))
+            self.read("top", "Destination rectangle (top)", (FormatChunk, "uint16"))
+            self.read("right", "Destination rectangle (right)", (FormatChunk, "uint16"))
+            self.read("bottom", "Destination rectangle (bottom)", (FormatChunk, "uint16"))
             diff = hend-stream.tell()
             if 0 < diff:
-                self.read("h_extra", "%us" % diff, "Extra junk")
+                self.read("h_extra", "Extra junk", (FormatChunk, "string[%u]" % diff))
             assert stream.tell() == hend
         elif tag == "strf" and stream_type == "vids" and size == 40:
             # Video header
             self.type = "Video header"
-            self.read("v_size", "<L", "Video format: Size")                    
-            self.read("v_width", "<L", "Video format: Width")                    
-            self.read("v_height", "<L", "Video format: Height")                    
-            self.read("v_panes", "<H", "Video format: Panes")                    
-            self.read("v_depth", "<H", "Video format: Depth")                    
-            self.read("v_tag1", "<L", "Video format: Tag1")                    
-            self.read("v_img_size", "<L", "Video format: Image size")                    
-            self.read("v_xpels_meter", "<L", "Video format: XPelsPerMeter")
-            self.read("v_ypels_meter", "<L", "Video format: YPelsPerMeter")
-            self.read("v_clr_used", "<L", "Video format: ClrUsed")
-            self.read("v_clr_importand", "<L", "Video format: ClrImportant")
+            self.read("v_size", "Video format: Size", (FormatChunk, "uint32"))                    
+            self.read("v_width", "Video format: Width", (FormatChunk, "uint32"))                    
+            self.read("v_height", "Video format: Height", (FormatChunk, "uint32"))                    
+            self.read("v_panes", "Video format: Panes", (FormatChunk, "uint16"))
+            self.read("v_depth", "Video format: Depth", (FormatChunk, "uint16"))                    
+            self.read("v_tag1", "Video format: Tag1", (FormatChunk, "uint32"))                    
+            self.read("v_img_size", "Video format: Image size", (FormatChunk, "uint32"))                    
+            self.read("v_xpels_meter", "Video format: XPelsPerMeter", (FormatChunk, "uint32"))
+            self.read("v_ypels_meter", "Video format: YPelsPerMeter", (FormatChunk, "uint32"))
+            self.read("v_clr_used", "Video format: ClrUsed", (FormatChunk, "uint32"))
+            self.read("v_clr_importand", "Video format: ClrImportant", (FormatChunk, "uint32"))
         elif tag == "strf" and stream_type == "auds":
             # Audio (wav) header
             self.type = "Audio header"
             aend = stream.tell() + size
-            self.read("a_id", "<H", "Audio format: Codec id")                    
-            a_chan = self.read("a_channel", "<H", "Audio format: Channels").value
-            self.read("a_sample_rate", "<L", "Audio format: Sample rate")                    
-            self.read("a_bit_rate", "<L", "Audio format: Bit rate")
-            self.read("a_block_align", "<H", "Audio format: Block align")
+            self.read("a_id", "Audio format: Codec id", (FormatChunk, "uint16"))
+            a_chan = self.doRead("a_channel", "Audio format: Channels", (FormatChunk, "uint16")).value
+            self.read("a_sample_rate", "Audio format: Sample rate", (FormatChunk, "uint32"))                    
+            self.read("a_bit_rate", "Audio format: Bit rate", (FormatChunk, "uint32"))
+            self.read("a_block_align", "Audio format: Block align", (FormatChunk, "uint16"))
             if size >= 16:
-                self.read("a_bits_per_sample", "<H", "Audio format: Bits per sample")
+                self.read("a_bits_per_sample", "Audio format: Bits per sample", (FormatChunk, "uint16"))
             if size >= 18:
-                self.read("ext_size", "<H", "Audio format: Size of extra information")
+                self.read("ext_size", "Audio format: Size of extra information", (FormatChunk, "uint16"))
             if a_chan > 2 and size >= 28:
-                self.read("reserved", "<H", "Audio format: ")
-                self.read("channel_mask", "<L", "Audio format: channels placement bitmask")
-                self.read("subformat", "<L", "Audio format: Subformat id")
+                self.read("reserved", "Audio format: ", (FormatChunk, "uint16"))
+                self.read("channel_mask", "Audio format: channels placement bitmask", (FormatChunk, "uint32"))
+                self.read("subformat", "Audio format: Subformat id", (FormatChunk, "uint32"))
             diff = aend-stream.tell()
             if 0 < diff:
-                self.read("a_extra", "%us" % diff, "Audio format: Extra")
+                self.read("a_extra", "Audio format: Extra", (FormatChunk, "string[%u]" % diff))
             assert stream.tell() == aend
         elif tag == "strn":
             # Stream description
-            self.read("desc", "%us" % size, "Stream description")
+            self.read("desc", "Stream description", (FormatChunk, "string[%u]" % size))
         else:
             if tag == "JUNK":
                 self.type = "Junk"
-            self.read("svalue[]", "%us" % size, "String value")
+            self.read("junk", "Junk", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, chunk):
         chunk.description = "Header: %s" % self.type
@@ -157,35 +158,34 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
         self.type = "Unknow"
-        tag = self.doRead("tag", "4s", "Tag").value
+        tag = self.doRead("tag", "Tag", (FormatChunk, "string[4]")).value
         size = stream.getSize()-4
         end = stream.tell() + size
         if tag in ChunkList.handler:
             # Handler
             sub = stream.createSub(size=size)
-            self.readSizedStreamChild("data", "Chunk data", size, sub, ChunkList.handler[tag])
+            self.read("data", "Chunk data", (ChunkList.handler[tag],), {"size": size, "stream": sub})
         elif tag in ("hdrl", "INFO"):
-            #?(Headers) Chunks
+            # (Headers) Chunks
             self.type = "List of chunks"
             while 8 < end - stream.tell():
-                size = self.doReadChild("chunk[]", "Chunk", Chunk).size
-                padding = size % 2
-                if padding != 0:
-                    self.read("padding[]", "%us" % padding, "Padding")
+                size = self.doRead("chunk[]", "Chunk", (Chunk,)).getSize()
+                if size % 2 != 0:
+                    self.read("padding[]", "Padding", (FormatChunk, "uint8"))
         elif tag == "strl":
             # Headers
             self.type = "Headers"
             stream_type = None
             while 8 <= end - stream.tell():
-                header = self.doReadChild("header[]", "Header", Header, stream_type).getFilter()
+                header = self.doRead("header[]", "Header", (Header, stream_type))
                 if header.hasChunk("type_fourcc"):
                     stream_type = header["type_fourcc"]
         else:
-            #?Raw data
-            self.read("raw", "%us" % size, "Raw data")
+            # Raw data
+            self.read("raw", "Raw data", (FormatChunk, "string[%u]" % size))
         padding = end - stream.tell()
         if padding != 0:
-            self.read("padding[]", "%us" % padding, "Padding")
+            self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % padding))
         assert stream.tell() == end
 
     def updateParent(self, chunk):
@@ -209,39 +209,39 @@
     }
 
     def __init__(self, stream, parent=None):
-        OnDemandFilter.__init__(self, "avi_chunk", "AVI chunk", stream, parent)
-        tag = self.doRead("tag", "4s", "Tag").value
-        size = self.doRead("size", "<L", "Size").value
+        OnDemandFilter.__init__(self, "chunk", "Chunk", stream, parent, "<")
+        tag = self.doRead("tag", "Tag", (FormatChunk, "string[4]")).value
+        size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
         if tag in Chunk.handler:
             end = stream.tell() + size
             sub = stream.createSub(size=size)
-            self.readSizedStreamChild("data", "Data", size, sub, Chunk.handler[tag])
+            self.read("data", "Data", (Chunk.handler[tag],), {"size": size, "stream": sub})
             assert stream.tell() == end
         else:
-            self.read("content", "%us" % size, "Raw data content")
+            self.read("content", "Raw data content", (FormatChunk, "string[%u]" % size))
 
     def updateParent(self, parent):
-        tag = self["tag"]
+        tag = self["tag"].strip("\0")
         if tag == "LIST":
             tag = self["data"]["tag"]
             type = "LIST (%s)" % Chunk.tag_description.get(tag, tag)
         else:
-            type = Chunk.tag_description.get(tag, tag)
+            type = Chunk.tag_description.get(tag, "\"%s\"" % tag)
         if tag in Chunk.tag_name:
             parent.id = Chunk.tag_name[tag]
         desc = "Chunk: %s" % type
         self.setDescription(desc)
         parent.description = desc
 
-class AVI_File(Filter):
+class AVI_File(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, "avi_file", "AVI file", stream, parent)
-        self.read("header", "4s", "AVI header (RIFF)")
+        OnDemandFilter.__init__(self, "avi_file", "AVI file", stream, parent, "<")
+        self.read("header", "AVI header (RIFF)", (FormatChunk, "string[4]"))
         assert self["header"] == "RIFF"
-        self.read("filesize", "<L", "File size")
-        self.read("avi", "4s", "\"AVI \" string")
+        self.read("filesize", "File size", (FormatChunk, "uint32"))
+        self.read("avi", "\"AVI \" string", (FormatChunk, "string[4]"))
         assert self["avi"] == "AVI "
         while not stream.eof():
-            self.readChild("chunk[]", Chunk)
+            self.read("chunk[]", "Chunk", (Chunk,))
 
 registerPlugin(AVI_File, "video/x-msvideo")

Deleted: haypo/hachoir/trunk/plugins/bmp.py
===================================================================
--- haypo/hachoir/trunk/plugins/bmp.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/bmp.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,32 +0,0 @@
-"""
-Microsoft Bitmap picture parseer.
-
-Author: Victor Stinner
-Creation: 16 december 2005
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class BitmapFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "bmp_file", "Bitmap picture file (BMP)", stream, parent)
-        self.read("header", "!2s", "Header (\"BM\")")
-        self.read("file_size", "<L", "File size (bytes)")
-        self.read("notused", "<L", "Reseved")
-        self.read("data_start", "<L", "Data start position")
-        header_size = self.read("header_size", "<L", "Header size").value
-        assert header_size in (12, 40)
-        self.read("width", "<L", "Width (pixels)")
-        self.read("height", "<L", "Height (pixels)")
-        self.read("nb_plan", "<H", "Number of plan (=1)")
-        self.read("bits_pixel", "<H", "Bits per pixel")
-        if header_size == 40:
-            self.read("compression", "<L", "Compression method")
-            self.read("image_size", "<L", "Image size (bytes)")
-            self.read("horizontal_dpi", "<L", "Horizontal DPI")
-            self.read("vertical_dpi", "<L", "Vertical DPI")
-            self.read("used_colors", "<L", "Number of color used")
-            self.read("important_color", "<L", "Number of import colors")
-
-registerPlugin(BitmapFile, "image/x-ms-bmp")

Deleted: haypo/hachoir/trunk/plugins/bzip2.py
===================================================================
--- haypo/hachoir/trunk/plugins/bzip2.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/bzip2.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,41 +0,0 @@
-"""
-BZIP2 archive file
-"""
-
-from plugin import guessPlugin
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-from stream.bunzip import BunzipStream
-
-class Bzip2_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "bz2_file", "Bzip2 archive file", stream, parent)
-        self.read("id", "3s", "Identifier (BZh)")
-        assert self["id"] == "BZh"
-        self.read("blocksize", "c", "Block size")
-        assert "1" <= self["blocksize"] and self["blocksize"] <= "9"
-        # Size of memory needed to decompress (on classic mode, not "small" mode)
-        size = (ord(self["blocksize"]) - ord("0")) * 100
-        self.getChunk("blocksize").description = "Block size (will need %u KB of memory)" % size
-        self.read("blockheader", "B", "Block header")
-        assert self["blockheader"] in (0x17, 0x31)
-        if self["blockheader"] == 0x17:
-            self.readA()
-        else: # blockheader = 0x31 ("1")
-            self.readB()
-        dataio = BunzipStream(stream)
-        plugin = guessPlugin(dataio, None)
-        size = stream.getSize()-stream.tell()
-        self.readChild("data", DeflateFilter, dataio, size, plugin)
-
-    def readB(self):
-        self.read("id2", "5s", "Identifier 2 (AY&SY)")
-        assert self["id2"] == "AY&SY"
-        self.read("crc", "<L", "CRC32")
-        
-    def readA(self):
-        self.read("id2", "4s", "Identifier2 (re8P)")
-        self.read("id3", "B", "Identifier3 (0x90)")
-        self.read("crc", "<L", "CRC32")
-         
-registerPlugin(Bzip2_File, "application/x-bzip2")

Deleted: haypo/hachoir/trunk/plugins/elf.py
===================================================================
--- haypo/hachoir/trunk/plugins/elf.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/elf.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,171 +0,0 @@
-"""
-ELF filter.
-Author: Victor Stinner
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-
-def processAddr(chunk):
-    return "%08X" % chunk.value
-
-class ElfHeader(Filter):
-    machine = {
-        0: "No machine",
-        1: "AT&T WE 32100",
-        2: "SPARC",
-        3: "Intel 80386",
-        4: "Motorolla 68000",
-        5: "Motorolla 88000",
-        7: "Intel 80860",
-        8: "MIPS RS3000"
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "elf_header", "ELF header", stream, parent)
-        self.read("id", "4s", "Identifier")
-        assert self["id"] == (chr(127) + "ELF")
-        self.read("class", "B", "Class")
-        self.read("encoding", "B", "Encoding")
-        self.read("file_version", "B", "File version")
-        self.read("pad", "8s", "Pad")
-        self.read("nident", "B", "Size of ident[]")
-        self.read("type", "<H", "File type", post=self.getType)
-        self.read("machine", "<H", "Machine type", post=self.getMachine)
-        self.read("version", "<L", "ELF format version")
-        self.read("entry", "<L", "Number of entries")
-        self.read("phoff", "<L", "Program header offset")
-        self.read("shoff", "<L", "Section header offset")
-        self.read("flags", "<L", "Flags")
-        self.read("ehsize", "<H", "Elf header size (this header)")
-        self.read("phentsize", "<H", "Program header entry size")
-        self.read("phnum", "<H", "Program header entry count")
-        self.read("shentsize", "<H", "Section header entry size")
-        self.read("shnum", "<H", "Section header entre count")
-        self.read("shstrndx", "<H", "Section header strtab index")
-
-    def getType(self, chunk):
-        type = chunk.value
-        types = {
-            0: "No file type",
-            1: "Relocable file",
-            2: "Executable file",
-            3: "Shared object file",
-            4: "Core file",
-            0xFF00: "Processor-specific (0xFF00)",
-            0xFFFF: "Processor-specific (0xFFFF)"
-        }
-        return types.get(type, "Unknow type (%u)" % type)
-
-    def getMachine(self, chunk):
-        type = chunk.value
-        return ElfHeader.machine.get(type, "Unknow machine (%u)" % type)
-
-class SectionHeader32(Filter):
-    types = {
-        8: "BSS"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "section_header", "Section header", stream, parent)
-        self.read("name", "<L", "")
-        self.read("type", "<L", "")
-        self.read("flags", "<L", "")
-        self.read("VMA", "<L", "Virtual memory address")#, post=processAddr)
-        self.read("LMA", "<L", "Logical memory address (in file)")#, post=processAddr)
-        self.read("size", "<L", "", post=processAddr)
-        self.read("link", "<L", "")
-        self.read("info", "<L", "")
-        self.read("addralign", "<L", "")
-        self.read("entsize", "<L", "")
-
-    def getType(self):
-        type = self["type"]
-        return SectionHeader32.types.get(type, "unknow type=%u" % type)
-
-    def getName(self):
-        #?TODO: Look in symbol name
-        return self["name"]
-
-    def updateParent(self, chunk):
-        desc = "Section header (name: %s, type: %s)" % (self.getName(), self.getType())
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ProgramHeader32(Filter):
-    type = {
-        3: "Dynamic library"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "prg_header", "Program header", stream, parent)
-        self.read("type", "<H", "")
-        self.read("flags", "<H", "")
-        self.read("offset", "<L", "")
-        self.read("vaddr", "<L", "", post=processAddr)
-        self.read("paddr", "<L", "", post=processAddr)
-        self.read("file_size", "<L", "")
-        self.read("mem_size", "<L", "")
-        self.read("align", "<L", "")
-        self.read("padding", "<L", "(padding?)")
-
-    def getType(self):
-        type = self["type"]
-        return ProgramHeader32.type.get(type, "unknow, %u" % type)
-
-    def updateParent(self, chunk):
-        desc = "Program Header (%s)" % self.getType() 
-        self.setDescription(desc)
-        chunk.description = desc 
-
-def seek(filter, stream, offset):
-    current = stream.tell()
-    if current != offset:
-        filter.read("padding[]", "%us" % (offset-current), "Padding")
-
-def sortSection(a, b):
-    return int(a["offset"] - b["offset"])
-
-class Section(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "elf_section", "Elf section", stream, parent)
-        # TODO ...
-        self.read("raw", "%us" % stream.getSize(), "Raw data")
-        
-class Sections(Filter):
-    def __init__(self, stream, parent, sections):
-        Filter.__init__(self, "elf_sections", "ELF sections", stream, parent)
-        for section in sections:
-            ofs = section["offset"]
-            size = section["file_size"]
-            sub = stream.createSub(ofs, size)
-            #self.readChild("section[]", DeflateFilter, sub, size, Section) 
-            chunk = self.readStreamChild("section[]", sub, Section) 
-            chunk.description = "ELF section (in file: %s..%s)" % (ofs, ofs+size)
-
-class ElfFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "elf_file", "ELF file", stream, parent)
-        self.readChild("elf_header", ElfHeader)
-        elf = self["elf_header"]
-        sections = []
-        for i in range(0, elf["phnum"]):
-            section = self.readChild("prg_header[]", ProgramHeader32)
-            sections.append(section.getFilter())
-
-#        i = 1
-#        for section in sections:
-#            print "Section %u: type %u, data in %u..%u " % (i, section["type"], section["offset"], section["offset"]+section["file_size"])
-#            i = i + 1
-            
-        size = elf["shoff"] - stream.tell()
-        newstream = stream.clone()
-        chunk = self.readChild("data", DeflateFilter, newstream, size, Sections, sections) 
-        chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
-        assert stream.tell() == elf["shoff"]
-
-        for i in range(0, elf["shnum"]):
-            chunk = self.readChild("section_header[]", SectionHeader32)
-            assert chunk.size == 40
-
-registerPlugin(ElfFile, ["application/x-executable", "application/x-object", "application/x-sharedlib"])

Deleted: haypo/hachoir/trunk/plugins/email.py
===================================================================
--- haypo/hachoir/trunk/plugins/email.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/email.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,223 +0,0 @@
-"""
-Email parser
-
-Author: Victor Stinner
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin, guessPlugin, getPluginByMime
-from default import DefaultFilter
-from mime import splitMimes
-from error import warning, error
-from stream.base_64 import Base64Stream
-import re
-
-class EmailHeader(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email_hdr", "Email header", stream, parent)
-        self._dict = {}
-        regex_new = re.compile("^([A-Za-z][A-Za-z0-9-]*): (.*)$")
-        regex_continue = re.compile("^[\t ]+(.*)$")
-        linenb = 1
-        last_key = None
-        last_index = None
-        while True:
-            id = "header[%u]" % linenb
-            chunk = self.readString(id, "AutoLine", "Header line")
-            if chunk.length == 0: return
-            line = chunk.value
-
-            m = regex_new.match(line)
-            if m != None:
-                last_key = m.group(1)
-                last_index = self._newHeader(last_key, m.group(2))
-            else:
-                m = regex_continue.match(line)
-                if m != None:
-                    assert last_key != None
-                    self._appendHeader(last_key, last_index, m.group(1))
-                else:
-                    warning("Can't parse email header: %s" % line)
-
-            linenb = linenb + 1
-
-    def __contains__(self, key):
-        key = key.lower()
-        return key in self._dict
-
-    def _appendHeader(self, key, index, value):
-        key = key.lower()
-        self._dict[key][index] = self._dict[key][index] + " " + value
-        
-    def _newHeader(self, key, value):
-        key = key.lower()
-        if key in self._dict:
-            index = len(self._dict[key])
-            self._dict[key].append(value)
-        else:
-            index = 0
-            self._dict[key] = [value]
-        return index
-
-    def __getitem__(self, index):
-        index = index.lower()
-        return self._dict[index]
-
-class EmailPart(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email_part", "Email part", stream, parent)
-        self.readChild("header", EmailHeader)
-        readEmailContent(self, stream.createSub())
-
-class EmailBody(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email_body", "Email body", stream, parent)
-        linenb = 1 
-        while not stream.eof():
-            guess = stream.read(5, False)
-            if guess=="From ":
-                break
-            id = "body[%u]" % linenb
-            chunk = self.readString(id, "AutoLine", "Body text")
-            linenb = linenb + 1
-
-def readEmailContent(self, stream):
-    mime = getEmailMime(self)
-    if mime != None and re.match("^multipart/", mime[0]) != None:
-        readMultipartEmail(self, stream, mime[1]["boundary"])
-    else:
-        if mime == None:
-            warning("Can't get MIME type for email %s" % self)
-        readBody(self, stream, mime)
-
-def readBody(self, stream, mime):
-    # Read encoding
-    header = self["header"]
-    if "Content-Transfer-Encoding" in header:
-        encoding = header["Content-Transfer-Encoding"][0]
-    else:
-        encoding = None
-
-    # Get filename
-    if mime != None:
-        filename = mime[1].get("name", None)
-    else:
-        raise Exception("No MIME in readBody()")
-        filename = None
-    if filename == None:
-        if "Content-Disposition" in header:
-            disp = header["Content-Disposition"][0].split(";")
-            regex = re.compile("filename=\"([^\"]+)\"")
-            for item in disp:
-                m = regex.match(item.strip())
-                if m != None:
-                    filename = m.group(1)
-                    break
-    elif filename[0] == '"':
-        filename = filename[1:-1]
-
-    # Handler base64 encodocing
-    if encoding == "base64":
-        size = stream.getSize() - stream.tell()
-        data = stream.getN(size, False)
-        substream = Base64Stream(data)
-        deflate = True
-    else:
-#        regex_new_mail = re.compile("[\r\n]From ")
-#        pos = stream.search(regex_new_mail)
-#        if pos != -1:
-#            substream = stream.createSub(size=pos)
-#        else:
-#            substream = stream
-        substream = stream.createSub()
-        deflate = False
-
-    # Guess plugin
-    if mime != None:
-        plugin = getPluginByMime((mime,), None)
-    else:
-        plugin = None
-    if plugin == None:
-        plugin = guessPlugin(substream, filename, None)
-    if plugin == None or plugin == EmailFilter:
-        plugin = EmailBody
-
-    # Finally read data
-    try:
-        if deflate:
-            self.readChild("body", DeflateFilter, substream, size, plugin) 
-        else:
-            self.readStreamChild("body", substream, plugin)
-    except Exception, msg:
-        error("Error while parsing email body: %s" % msg)
-        substream.seek(0)
-        self.readStreamChild("body", substream, DefaultFilter)
-
-def readMultipartEmail(self, stream, boundary):
-    assert boundary[0] == '"' and boundary[-1] == '"'
-    boundary = "--" + boundary[1:-1]
-    end_boundary = boundary + "--"
-    count = 1
-    while True:
-        id = "multipart_space[%u]" % count
-        chunk = self.readString(id, "AutoLine", "Space before first email parts")
-        value = chunk.value
-        if value == boundary:
-            break
-        count = count + 1
-
-    part = 1
-    boundary_index = 1
-    while True:
-        start = stream.tell()
-        size = stream.searchLength(boundary, False)
-        sub = stream.createSub(start, size)
-        self.readStreamChild("part[%u]" % part, sub, EmailPart)
-        stream.seek(start+size)
-        chunk = self.readString("boundary[%u]" % boundary_index, "AutoLine", "Boundary")
-        part = part + 1
-        boundary_index = boundary_index + 1
-        if chunk.value == boundary+"--":
-            break
-
-def getEmailMime(self):
-    header = self["header"]
-    if not("Content-Type" in header):
-        raise Exception("No mime")
-        return None
-    content_type = header["Content-Type"]
-    assert len(content_type) == 1
-    mimes = splitMimes(content_type[0])
-    assert len(mimes) == 1
-    return mimes[0]
-
-class Email(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "email", "Email", stream, parent)
-        self.readString("id", "AutoLine", "Email identifier")
-        self.readChild("header", EmailHeader)
-        readEmailContent(self, stream.createSub())
-
-    def __str__(self):
-        header = self["header"]
-        text = "Email"
-        if "From" in header:
-            text = text + " from %s" % header["From"]
-        if "Date" in header:
-            text = text + " (date %s)" % header["Date"]
-        return text
-
-class EmailFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email", "Email maildir parser", stream, parent)
-        while not stream.eof():
-            chunk = self.readChild("email[]", Email)
-            if stream.eof():
-                break
-            while not stream.eof():
-                guess = stream.read(5, False)
-                if guess == "From ":
-                    break
-                self.readString("space[]", "AutoLine", "Space")
-
-registerPlugin(EmailFilter, ["message/rfc822", "text/x-mail"])

Deleted: haypo/hachoir/trunk/plugins/exe.py
===================================================================
--- haypo/hachoir/trunk/plugins/exe.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/exe.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,196 +0,0 @@
-"""
-EXE filter.
-
-Status: read ms-dos and pe headers
-Todo: support resources ... and disassembler ? :-)
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class PE_ResourceData(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_rsrc_data", "PE resource data", stream, parent)
-        self.read("offset", "<L", "Offset")
-        self.read("size", "<L", "Size")
-        self.read("page_code", "<L", "Page code (language)")
-        self.read("language", "<l", "Page code (language)")
-#        self.language = -self["language"]
-        self.read("reserved", "!L", "Reserverd")
-
-        oldpos = stream.tell()
-        
-        #stream.seek(XXX + self.offset - self.offset_res_section)
-        stream.seek(self["offset"])
-        stream.seek(oldpos)
-
-class PE_ResourceEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_rsrc_entry", "PE resource entry", stream, parent)
-        self.read("id", "<L", "ID or name")
-        self.read("offset", "<L", "Offset")
-        
-class PE_ResourceDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_rsrc_dir", "PE resource directory", stream, parent)
-        self.offset_res_section = stream.tell()
-        self.read("option", "<L", "Options")
-        self.read("creation_date", "<L", "Creation date")
-        self.read("maj_ver", "<H", "Major version")
-        self.read("named_entries", "<H", "Named entries")
-        self.read("indexed_entries", "<H", "Indexed entries")
-
-        stream.seek( stream.tell() + 0x10)
-        self.readArray("item", PE_ResourceEntry, "PE resource entry", self.checkEndOfRes)
-    
-    def checkEndOfRes(self, stream, array, dir):
-        return len(array) == (self["named_entries"] + self["indexed_entries"])
-
-class PE_Section(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_section", "PE section", stream, parent)
-        self.read("name", "8s", "Name")
-        # TODO: use chunk post proces
-        self.name = self["name"].strip(" \0")
-        self.read("rva", "<L", "RVA")
-        self.read("size", "<L", "Size")
-        self.read("file_size", "<L", "File size")
-        self.read("file_offset", "<L", "File offset")
-        self.read("reloc_ptr", "<L", "Relocation pointer")
-        self.read("lines_ptr", "<L", "File line numbers pointer")
-        self.read("nb_reloc", "<H", "Number of relocations")
-        self.read("nb_lines", "<H", "Number of file line")
-        self.read("options", "<L", "Options")
-
-class PE_Directory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_dir", "PE directory", stream, parent)
-        self.read("size", "<L", "Size")
-        self.read("rva", "<L", "RVA")
-
-class PE_OptionnalHeader(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_opt_hdr", "PE optionnal header", stream, parent)
-        self.read("header", "<H", "Header")
-        assert self["header"] == 0x010B
-        self.read("linker_maj_ver", "B", "Linker major version")
-        self.read("linker_min_ver", "B", "Linker minor version")
-        self.read("code_size", "<L", "Code size (bytes)")
-        self.read("data_size", "<L", "Data size (bytes)")
-        self.read("heap_size", "<L", "Heap size (bytes)")
-        self.read("entry_point_rva", "<L", "Entry point offset (RVA)")
-        self.read("code_rva", "<L", "Code offset (RVA)")
-        self.read("data_rva", "<L", "Data offset (RVA)")
-        self.read("base_image_rva", "<L", "Base image offset (RVA)")
-        self.read("memory_alignment", "<L", "Memory alignment")
-        self.read("file_alignment", "<L", "File alignment")
-        self.read("os_maj_ver", "<H", "OS major version")
-        self.read("os_min_ver", "<H", "OS minor version")
-        self.read("prog_maj_ver", "<H", "Program major version")
-        self.read("prog_min_ver", "<H", "Program minor version")
-        self.read("api_maj_ver", "<H", "API major version?!")
-        self.read("api_min_ver", "<H", "API minor version?!")
-        self.read("windows_ver", "<L", "Windows version?!")
-        self.read("image_size", "<L", "Image size")
-        self.read("headers_size", "<L", "Headers size")
-        self.read("checksum", "<L", "Checkum")
-        self.read("neeed_api", "<H", "Needed API?!")
-        self.read("dll_options", "<H", "DLL options (only for DLL)")
-        self.read("reserved_stack_size", "<L", "Reserved stack size")
-        self.read("common_stack_size", "<L", "Common stack size")
-        self.read("reserved_heap_size", "<L", "Reserved heap size")
-        self.read("common_heap_size", "<L", "Common heap size")
-        self.read("loader_options", "<L", "Loader options")
-        self.read("nb_directories", "<L", "Number of directories (16)")
-        assert self["nb_directories"] == 16
-        self.readArray("directories", PE_Directory, "PE directories", self.checkEndOfDir)
-
-    def checkEndOfDir(self, stream, array, dir):
-        return len(array) == self.nb_directories
-
-class PE_Filter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pe_header", "PE header", stream, parent)
-        self.read("header", "4s", "File header")
-        assert self["header"] == "PE\0\0"
-        self.read("cpu_type", "<H", "CPU type")
-        self.read("nb_sections", "<H", "Number of sections")
-        self.read("creation_date", "<L", "Creation date")
-        self.read("ptr_to_symbols", "<L", "Pointer to symbol table")
-        self.read("nb_symbols", "<L", "Number of symbols")
-        self.read("opt_header_size", "<H", "Optionnal header size")
-        self.read("options", "<H", "Options")
-
-    def getCpuType(self):
-        cpu_name = {
-            0x014C: "Intel 80386 or greater",
-            0x014D: "Intel 80486 or greater",
-            0x014E: "Intel Pentium or greader", 
-            0x0160: "R3000 (MIPS), big endian",
-            0x0162: "R3000 (MIPS), little endian",
-            0x0166: "R4000 (MIPS), little endian",
-            0x0168: "R10000 (MIPS), little endian",
-            0x0184: "DEC Alpha AXP",
-            0x01F0: "IBM Power PC, little endian"}
-        return cpu_name.get(self["cpu_type"], "unknow")
-
-class MS_Dos(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "msdos_header", "MS-Dos executable header", stream, parent)
-        self.read("header", "2s", "File header")
-        assert self["header"] == "MZ"
-        self.read("filesize_mod_512", ">H", "Filesize mod 512")
-        self.read("filesize_div_512", ">H", "Filesize div 512")
-        self.filesize = self["filesize_div_512"] * 512 + self["filesize_mod_512"]
-        self.read("reloc_entries", ">H", "Number of relocation entries")
-        self.read("code_offset", "<H", "Offset to the code in the file (div 16)")
-        self.code_offset = self["code_offset"] * 16
-        self.read("needed_memory", ">H", "Memory needed to run (div 16)")
-        self.needed_memory = self["needed_memory"] * 16
-        self.read("max_memory", ">H", "Maximum memory needed to run (div 16)")
-        self.max_memory = self["max_memory"] * 16
-        self.read("init_ss_sp", ">L", "Initial value of SP:SS registers.")
-        self.read("checksum", ">H", "Checksum")
-        self.read("init_cs_ip", ">L", "Initial value of CS:IP registers.")
-        self.read("reloc_offset", "<H", "Offset in file to relocation table.")
-        self.read("overlay_number", ">H", "Overlay number")
-        self.read("reserved", ">4H", "Reserverd")
-        self.read("oem_id", ">H", "OEM id")
-        self.read("oem_info", ">H", "OEM info")
-        self.read("reserved2", "!10H", "Reserved")
-        self.read("pe_offset", "<L", "Offset to PE header")
-
-class ExeFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "exe_file", "EXE file", stream, parent)
-
-        self.readChild("ms_dos", MS_Dos)
-
-        if self["ms_dos"]["reloc_offset"] == 0x40:
-            stream.seek(self["ms_dos"]["pe_offset"], 0)
-
-            self.readChild("pe", PE_Filter)
-            self.pe = self["pe"]
-            self.readChild("pe_opt", PE_OptionnalHeader)
-            self.readArray("pe_sections", PE_Section, "PE sections", self.checkEndOfSections)
-
-            # TODO: Fix this ...
-            
-            offset_res_section = None
-            for section in self["pe_sections"]:
-                section = section.getFilter()
-                if section.name == ".rsrc":
-                    offset_res_section = section.file_offset
-                    self.getStream().seek( offset_res_section )
-                    break
-            if offset_res_section != None:
-                #for i in range(1): #range(self.pe.nb_sections):
-                self.readChild("pe_resources", PE_ResourceDirectory)
-        else:
-            self.pe = None
-
-    def checkEndOfSections(self, stream, array, section):
-        return len(array) == self["pe"]["nb_sections"]
-
-registerPlugin(ExeFile, "application/x-dosexec")

Deleted: haypo/hachoir/trunk/plugins/exif.py
===================================================================
--- haypo/hachoir/trunk/plugins/exif.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/exif.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,238 +0,0 @@
-"""
-Exif filter.
-
-Informations about Exif at:
-- http://www.exif.org/
-- http://libexif.sourceforge.net/
-
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from format import getFormatSize
-import struct
-
-class ExifEntry(Filter):
-    format = {
-        1: (1, "B"),
-        2: (1, "s"),
-        3: (1, "H"),
-        4: (1, "L"),
-        5: (2, "L"),
-        7: (1, "s"),
-#        9: (1, "l"),
-#        10: (2, "l")
-        9: (1, "L"),
-        10: (2, "L")
-    }
-
-    type_name = {    
-        1: "BYTE (8 bits)",
-        2: "ASCII (8 bits)",
-        3: "SHORT (16 bits)",
-        4: "LONG (32 bits)",
-        5: "RATIONAL (two LONGs)",
-        7: "UNDEFINED (8 bits)",
-        9: "SLONG (32 bits)",
-        10: "SRATIONTAL (two SLONGs)"
-    }
-
-    tag_name = {    
-        0x0100: "Image width",
-        0x0101: "Image height",
-        0x0102: "Number of bits per component",
-        0x0103: "Compression scheme",
-        0x0106: "Pixel composition",
-        0x0112: "Orientation of image",
-        0x0115: "Number of components",
-        0x011C: "Image data arrangement",
-        0x0212: "Subsampling ratio Y to C",
-        0x0213: "Y and C positioning",
-        0x011A: "Image resolution width direction",
-        0x011B: "Image resolution in height direction",
-        0x0128: "Unit of X and Y resolution",
-        
-        0x0111: "Image data location",
-        0x0116: "Number of rows per strip",
-        0x0117: "Bytes per compressed strip",
-        0x0201: "Offset to JPEG SOI",
-        0x0202: "Bytes of JPEG data",
-        
-        0x012D: "Transfer function",
-        0x013E: "White point chromaticity",
-        0x013F: "Chromaticities of primaries",
-        0x0211: "Color space transformation matrix coefficients",
-        0x0214: "Pair of blank and white reference values",
-        
-        0x0132: "File change date and time",
-        0x010e: "Image title",
-        0x010f: "Camera (Image input equipment) manufacturer",
-        0x0110: "Camera (Input input equipment) model",
-        0x0131: "Software",
-        0x013B: "File change date and time",
-        0x8298: "Copyright holder",
-        0x8769: "Exif IFD Pointer",
-
-        0x829A: "Exposure time",
-        0x829D: "F number",
-        0x8822: "Exposure program",
-        0x8824: "Spectral sensitivity",
-        0x8827: "ISO speed rating",
-        0x8828: "Optoelectric conversion factor OECF",
-        0x9201: "Shutter speed",
-        0x9202: "Aperture",
-        0x9203: "Brightness",
-        0x9204: "Exposure bias",
-        0x9205: "Maximum lens aperture",
-        0x9206: "Subject distance",
-        0x9207: "Metering mode",
-        0x9208: "Light source",
-        0x9209: "Flash",
-        0x920A: "Lens focal length",
-        0x9214: "Subject area",
-        0xA20B: "Flash energy",
-        0xA20C: "Spatial frequency response",
-        0xA20E: "Focal plane X resolution",
-        0xA20F: "Focal plane Y resolution",
-        0xA210: "Focal plane resolution unit",
-        0xA214: "Subject location",
-        0xA215: "Exposure index",
-        0xA217: "Sensing method",
-        0xA300: "File source",
-        0xA301: "Scene type",
-        0xA302: "CFA pattern",
-        0xA401: "Custom image processing",
-        0xA402: "Exposure mode",
-        0xA403: "White balance",
-        0xA404: "Digital zoom ratio",
-        0xA405: "Focal length in 35 mm film",
-        0xA406: "Scene capture type",
-        0xA407: "Gain control",
-        0xA408: "Contrast",
-
-        0x9000: "Exif version",
-        0xA000: "Supported Flashpix version",
-        0xA001: "Color space information",
-        0x9101: "Meaning of each component",
-        0x9102: "Image compression mode",
-        0xA002: "Valid image width",
-        0xA003: "Valid image height",
-        0x927C: "Manufacturer notes",
-        0x9286: "User comments",
-        0xA004: "Related audio file",
-        0x9003: "Date and time of original data generation",
-        0x9004: "Date and time of digital data generation",
-        0x9290: "DateTime subseconds",
-        0x9291: "DateTimeOriginal subseconds",
-        0x9292: "DateTimeDigitized subseconds",
-        0xA420: "Unique image ID",
-        0xA005: "Interoperability IFD Pointer"
-    }
-
-    def __init__(self, stream, parent, endian):
-        Filter.__init__(self, "exif_entry", "Exif entry", stream, parent)
-        self.endian = endian
-        self.read("tag", endian+"H", "Tag", post=self.processTag)
-        self.read("type", endian+"H", "Type", post=self.processType)
-        self.read("count", endian+"L", "Count")
-
-        # Create format
-        format = ExifEntry.format.get(self["type"], (1, "B"))
-        self.format = "%s%u%s" % (self.endian, format[0]*self["count"], format[1])
-
-        # Get size
-        self.size = getFormatSize(self.format)
-
-        # Get offset/value
-        if 4 < self.size:
-            self.read("offset", endian+"L", "Value offset")
-        else:
-            self.read("value", self.format, "Value")
-            if self.size < 4:
-                self.read("padding", "%us" % (4-self.size), "Padding")
-
-    def updateParent(self, parent):
-        parent.description = "Exif entry (%s)" % self.getTag() 
-
-    def getTag(self):
-        return ExifEntry.tag_name.get(self["tag"], "Unknown tag (0x%04X)" % self["tag"])
-
-    def processType(self, chunk):
-        return ExifEntry.type_name.get(chunk.value, "%u" % chunk.value) 
-
-    def processTag(self, chunk):
-        chunk.description = self.getTag()
-        return "0x%04X" % chunk.value 
-
-def sortExifEntry(a,b):
-    return int( a["offset"] - b["offset"] )
-
-class ExifIFD(Filter):
-    def __init__(self, stream, parent, endian, offset_diff):
-        Filter.__init__(self, "exif", "Exif IFD", stream, parent)
-        self.endian = endian
-        self.read("id", endian+"H", "IFD identifier")
-        entries = []
-        next_chunk_offset = None
-        while True:
-            next = stream.getFormat("!L", False)[0]
-            if next in (0, 0xF0000000):
-                break
-            chunk = self.readChild("entry[]", ExifEntry, endian)
-            entry = chunk.getFilter()
-            if entry["tag"] in (0x8769, 0x0201):
-                next_chunk_offset = entry["value"]+offset_diff
-                break
-            if 4 < entry.size:
-                entries.append(entry)
-        self.read("next", endian+"L", "Next IFD offset")
-        entries.sort( sortExifEntry )
-        for entry in entries:
-            offset = entry["offset"]+offset_diff
-            padding = offset - stream.tell()
-            if 0 < padding:
-                self.read("padding[]", "%us" % padding, "Padding (?)")
-            assert offset == stream.tell()
-            self.read("entry_value[]", entry.format, "Value of %s" % entry.getId())
-        if next_chunk_offset != None:
-            padding = next_chunk_offset - stream.tell()
-            if 0 < padding:
-                self.read("padding[]", "%us" % padding, "Padding (?)")
-
-    def updateParent(self, chunk):
-        desc = "Exif IFD (id %s)" % self["id"]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ExifFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "exif", "Exif", stream, parent)
-
-        # Headers
-        self.read("header", "6s", "Header (Exif\\0\\0)")
-        assert self["header"] == "Exif\0\0"
-        self.read("byte_order", "2s", "Byte order")
-        assert self["byte_order"] in ("II", "MM")
-        if self["byte_order"] == "II":
-           endian = "<"
-        else:
-           endian = ">"
-        self.read("header2", endian+"H", "Header2 (42)")
-
-        self.read("nb_entry", endian+"H", "Number of entries")
-        self.read("whatsthis?", endian+"H", "What's this ??")
-        while True:
-            tag = stream.getN(2, False)
-            if tag == "\xFF\xD8":
-                size = stream.getSize() - stream.tell()
-                sub = stream.createLimited(size=size)
-                from jpeg import JpegFile
-                self.readStreamChild("thumbnail", sub, JpegFile)
-                break
-            if tag == "\xFF\xFF":
-                break
-            self.readChild("ifd[]", ExifIFD, endian, 6)
-        size = stream.getSize() - stream.tell()
-        if 0 < size:
-            self.read("end", "%us" % size, "End")
-        assert self.getSize() == stream.getSize()

Deleted: haypo/hachoir/trunk/plugins/ext2.py
===================================================================
--- haypo/hachoir/trunk/plugins/ext2.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/ext2.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,424 +0,0 @@
-"""
-EXT2 (Linux) file system parser.
-
-Sources:
-- EXT2FS source code
-  http://ext2fsd.sourceforge.net/
-- Analysis of the Ext2fs structure
-  http://www.nondot.org/sabre/os/files/FileSystems/ext2fs/
-"""
-
-from datetime import datetime
-from filter import Filter, OnDemandFilter
-from plugin import registerPlugin
-from tools import humanDuration, getUnixRWX, humanFilesize
-
-class DirectoryEntry(OnDemandFilter):
-    file_type = {
-        1: "Regular",
-        2: "Directory",
-        3: "Char. dev.",
-        4: "Block dev.",
-        5: "Fifo",
-        6: "Socket",
-        7: "Symlink",
-        8: "Max"
-    }
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "dir", "EXT2 directory entry", stream, parent)
-        self.read("inode", "<L", "Inode")
-        self.read("rec_len", "<H", "Record length")
-        name_length = self.doRead("name_len", "B", "Name length").value
-        self.read("file_type", "B", "File type", post=self.postFileType)
-        self.read("name", "%us" % name_length, "Name")
-        size = self["rec_len"]-8-name_length 
-        if size != 0:
-            self.read("padding", "%us" % size, "Padding")
-
-    def updateParent(self, chunk):        
-        name = self["name"].strip("\0")
-        if name != "":
-            desc = "Directory entry: %s" % name
-        else:
-            desc = "Directory entry (empty)"
-        chunk.description = desc
-        self.setDescription(desc)
-
-    def postFileType(self, chunk):
-        type = chunk.value
-        return DirectoryEntry.file_type.get(type, "Unknow (%02X)" % type)
-
-class Inode(OnDemandFilter):
-    name = {
-        1: "list of bad blocks",
-        2: "Root directory",
-        3: "ACL inode",
-        4: "ACL inode",
-        5: "Boot loader",
-        6: "Undelete directory",
-        8: "EXT3 journal"
-    }
-    
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, "inode", "EXT2 inode", stream, parent)
-        self.index = index
-        self.read("mode", "<H", "Mode", post=self.postMode)
-        self.read("uid", "<H", "User ID")
-        self.read("size", "<L", "File size")
-        self.read("atime", "<L", "Last access time", post=self.getTime)
-        self.read("ctime", "<L", "Creation time", post=self.getTime)
-        self.read("mtime", "<L", "Last modification time", post=self.getTime)
-        self.read("dtime", "<L", "Delete time", post=self.getTime)
-        self.read("gid", "<H", "Group ID")
-        self.read("links_count", "<H", "Links count")
-        self.read("blocks", "<L", "Number of blocks")
-        self.read("flags", "<L", "Flags")
-        self.read("reserved1", "<L", "Reserved")
-        for i in range(0,15):
-            self.read("block[]", "<L", "Block %i" % i)
-        self.read("version", "<L", "Version")
-        self.read("file_acl", "<L", "File ACL")
-        self.read("dir_acl", "<L", "Directory ACL")
-        self.read("faddr", "<L", "Block where the fragment of the file resides")
-        os = parent.getParent().getParent().superblock["creator_os"]
-        if os == SuperBlock.OS_LINUX:
-            self.read("frag", "B", "Number of fragments in the block")
-            self.read("fsize", "B", "Fragment size")
-            self.read("padding", "<H", "Padding")
-            self.read("uid_high", "<H", "High 16 bits of user ID")
-            self.read("gid_high", "<H", "High 16 bits of group ID")
-            self.read("reserved", "<L", "Reserved")
-        elif os == SuperBlock.OS_HURD:
-            self.read("frag", "B", "Number of fragments in the block")
-            self.read("fsize", "B", "Fragment size")
-            self.read("mode_high", "<H", "High 16 bits of mode")
-            self.read("uid_high", "<H", "High 16 bits of user ID")
-            self.read("gid_high", "<H", "High 16 bits of group ID")
-            self.read("author", "<L", "Author ID (?)")
-        else:
-            self.read("raw", "12s", "Reserved")
-
-    def updateParent(self, chunk):
-        desc = "Inode %s: " % self.index
-        size = humanFilesize(self["size"])
-        if 11 <= self.index:
-            desc = desc + "file, size=%s, mode=%s" % (size, self.getChunk("mode").display)
-        else:
-            if self.index in Inode.name:
-                desc = desc + Inode.name[self.index]
-                if self.index == 2:
-                    desc = desc + " (%s)" % getUnixRWX(self["mode"])
-            else:
-                desc = desc + "special"
-            if size == 0:
-                desc = desc + " (unused)"
-        chunk.description = desc
-        self.setDescription(desc)
-
-    def postMode(self, chunk):
-        mode = chunk.value
-        text = ""
-        if mode & 0100000 != 0:
-            text = "regular (%s)" % getUnixRWX(mode)
-        elif mode & 0040000:
-            text = "directory (%s)" % getUnixRWX(mode)
-        elif mode & 0020000:
-            text = "char. dev."
-        elif mode & 0060000:
-            text = "block dev."
-        elif mode & 0010000:
-            text = "fifo"
-        elif mode & 0120000:
-            text = "sym. link"
-        elif mode & 0140000:
-            text = "socket"
-        elif mode == 0:
-            text = "(empty)"
-        else:
-            text = "???"
-        return text
-
-    def getTime(self, chunk):
-        if chunk.value != 0:
-            return datetime.fromtimestamp(chunk.value)
-        else:
-            return "(empty)"
-
-class Bitmap(OnDemandFilter):
-    def __init__(self, stream, parent, description, count, start):
-        OnDemandFilter.__init__(self, "bitmap", "%s: %s items" % (description, count), stream, parent)
-        self.start = start
-        size = count / 8
-        self.read("block_bitmap", "%us" % size, "Bitmap")
-
-    def showFree(self, type="Block"):
-        data = self["block_bitmap"]
-        cpt = self.start
-        for octet in data:
-            octet = ord(octet)
-            mask = 1
-            for i in range(0,8):
-                if octet & mask == 0:
-                    print "%s %s free." % (type, cpt)
-                cpt = cpt + 1
-                mask = mask << 1
-
-BlockBitmap = Bitmap
-InodeBitmap = Bitmap
-
-class GroupDescriptor(OnDemandFilter):
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, "group", "Group descriptor", stream, parent)
-        self.index = index
-        self.read("block_bitmap", "<L", "Points to the blocks bitmap block")
-        self.read("inode_bitmap", "<L", "Points to the inodes bitmap block")
-        self.read("inode_table", "<L", "Points to the inodes table first block")
-        self.read("free_blocks_count", "<H", "Number of free blocks")
-        self.read("free_inodes_count", "<H", "Number of free inodes")
-        self.read("used_dirs_count", "<H", "Number of inodes allocated to directories")
-        self.read("padding", "<H", "Padding")
-        self.read("reserved", "12s", "Reserved")
-
-    def updateParent(self, chunk):
-        superblock = self.getParent().getParent().superblock
-        blocks_per_group = superblock["blocks_per_group"]
-        start = self.index * blocks_per_group
-        end = start + blocks_per_group 
-        chunk.description = "Group descriptor: blocks %s-%s" % (start, end)
-    
-
-class SuperBlock(OnDemandFilter):
-    error_handling = {
-        1: "Continue"
-    }
-    OS_LINUX = 0
-    OS_HURD = 1
-    os_name = {
-        0: "Linux",
-        1: "Hurd",
-        2: "Masix",
-        3: "FreeBSD",
-        4: "Lites",
-        5: "WinNT"
-    }
-    state = {
-        1: "Valid",
-        2: "Error"
-    }
-    
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "super_block", "Super block", stream, parent)
-        self.read("inodes_count", "<L", "Inodes count")
-        self.read("blocks_count", "<L", "Blocks count")
-        self.read("r_blocks_count", "<L", "Reserved blocks count")
-        self.read("free_blocks_count", "<L", "Free blocks count")
-        self.read("free_inodes_count", "<L", "Free inodes count")
-        first = self.doRead("first_data_block", "<L", "First data block").value
-        assert (first == 0)
-        self.read("log_block_size", "<L", "Block size")
-        self.read("log_frag_size", "<L", "Fragment size")
-        self.read("blocks_per_group", "<L", "Blocks per group")
-        self.read("frags_per_group", "<L", "Fragments per group")
-        self.read("inodes_per_group", "<L", "Inodes per group")
-        self.read("mtime", "<L", "Mount time", post=self.getTime)
-        self.read("wtime", "<L", "Write time", post=self.getTime)
-        self.read("mnt_count", "<H", "Mount count")
-        self.read("max_mnt_count", "<h", "Max mount count")
-        id = self.doRead("magic", ">H", "Magic number (0x53EF)").value
-        assert id == 0x53EF
-
-        # Read state
-        chunk = self.doRead("state", "<H", "File system state")
-        chunk.description = "Behaviour when detecting errors: %s" % \
-            SuperBlock.state.get(chunk.value, "Unknow (%s)" % chunk.value)
-
-        # Read error handling
-        chunk = self.doRead("errors", "<H", "")
-        desc = "Behaviour when detecting errors"
-        if chunk.value in SuperBlock.error_handling:
-            desc = "%s: %s" % (desc, SuperBlock.error_handling[chunk.value])
-        chunk.description = desc
-        
-        self.read("minor_rev_level", "<H", "Minor revision level")
-        self.read("last_check", "<L", "Time of last check", post=self.getTime)
-        self.read("check_interval", "<L", "Maximum time between checks", post=self.postMaxTime)
-        
-        chunk = self.doRead("creator_os", "<L", "")
-        desc = "Creator OS"
-        if chunk.value in SuperBlock.os_name:
-            desc = "%s: %s" % (desc, SuperBlock.os_name[chunk.value])
-        chunk.description = desc
-        
-        self.read("rev_level", "<L", "Revision level")
-        self.read("def_resuid", "<H", "Default uid for reserved blocks")
-        self.read("def_resgid", "<H", "Default guid for reserverd blocks")
-
-        # ---------
-
-        self.read("first_ino", "<L", "First non-reserved inode")
-        inode_size = self.doRead("inode_size", "<H", "Size of inode structure").value
-        assert inode_size == (68 + 15*4)
-        self.read("block_group_nr", "<H", "Block group # of this superblock")
-        self.read("feature_compat", "<L", "Compatible feature set")
-        self.read("feature_incompat", "<L", "Incompatible feature set")
-        self.read("feature_ro_compat", "<L", "Read-only compatible feature set")
-        self.read("uuid", "16s", "128-bit uuid for volume")
-        self.read("volume_name", "16s", "Volume name")
-        self.read("last_mounted", "64s", "Directory where last mounted")
-        self.read("compression", "<L", "For compression (algorithm usage bitmap)")
-        
-        self.read("prealloc_blocks", "B", "Number of blocks to try to preallocate")
-        self.read("prealloc_dir_blocks", "B", "Number to preallocate for directories")
-        self.read("padding", "H", "Padding")
-        
-        self.read("journal_uuid", "16s", "uuid of journal superblock")
-        self.read("journal_inum", "<L", "inode number of journal file")
-        self.read("journal_dev", "<L", "device number of journal file")
-        self.read("last_orphan", "<L", "start of list of inodes to delete")
-        
-        self.read("reserved", "197s", "Padding to the end of the block")
-
-        blocks_per_group = self["blocks_per_group"]
-        self.group_count = (self["blocks_count"] - self["first_data_block"] + blocks_per_group - 1) / blocks_per_group
-
-    def updateParent(self, chunk):
-        if self["feature_compat"] & 4 == 4:
-            type = "ext3"
-        else:
-            type = "ext2"
-        desc = "Superblock: %s file system" % type
-        self.setDescription(desc)
-        chunk.description = desc
-
-    def postMaxTime(self, chunk):
-        return humanDuration(chunk.value * 1000)
-
-    def getTime(self, chunk):
-        return datetime.fromtimestamp(chunk.value)
-
-class GroupDescriptors(OnDemandFilter):
-    def __init__(self, stream, parent, count, start):
-        OnDemandFilter.__init__(self, "groups", "Group descriptors: %s items" % count, stream, parent)
-        self.start = start
-        for i in range(0, count):
-            self.readSizedChild("group[]", "Group", 32, GroupDescriptor, i)
-
-    def getGroup(self, index):
-        return self["group[%s]" % (self.start + index)]
-
-class InodeTable(OnDemandFilter):
-    def __init__(self, stream, parent, start, count):
-        OnDemandFilter.__init__(self, "ino_table", "Inode table: %s inodes" % count, stream, parent)
-        self.start = start
-        chunk_size = parent.getParent().superblock["inode_size"]
-        for index in range(self.start, self.start+count):
-            self.readSizedChild("inode[]", "Inode %s" % index, chunk_size, Inode, index)
-
-    def __getitem__(self, index):
-        index = index - self.start - 1
-        return self.getChunk("inode[%u]" % index).getFilter()
-
-def testSuperblock(stream):
-    oldpos = stream.tell()
-    stream.seek(80-24, 1)
-    is_super = stream.getN(2) == "\x53\xEF"    
-    stream.seek(oldpos)
-    return is_super
-
-class Group(OnDemandFilter):
-    def __init__(self, stream, parent, index):
-        OnDemandFilter.__init__(self, "group", "Group %u" % index, stream, parent)
-        self.index = index
-        group = parent["group_desc"].getGroup(index)
-        superblock = parent.superblock
-        block_size = parent.block_size
-    
-        # Read block bitmap
-        self.superblock_copy = False
-        if testSuperblock(stream):
-            self.readChild("superblock_copy", "Superblock", SuperBlock)
-            self.superblock_copy = True
-        self.seek(group["block_bitmap"] * block_size)
-            
-        count = superblock["blocks_per_group"]
-        self.readSizedChild("block_bitmap[]", "Block bitmap", count / 8, BlockBitmap, "Block bitmap", count, 0)
-
-        # Read inode bitmap
-        assert (group["inode_bitmap"] * block_size) == stream.tell()
-        count = superblock["inodes_per_group"]
-        self.readSizedChild("inode_bitmap[]", "Inode bitmap", count / 8, InodeBitmap, "Inode bitmap", count, 1)
-        addr = stream.tell() % 4096
-        if addr != 0:
-            addr = stream.tell() + (4096 - addr % 4096)
-            self.seek(addr)
-             
-        count = superblock["inodes_per_group"]
-        size = superblock["inode_size"] * count
-        inode_index = 1 + index * count
-        self.readSizedChild("inode_table[]", "Inode table", size, InodeTable, inode_index, count)
-
-        size = (index+1) * superblock["blocks_per_group"] * block_size
-        if stream.getSize() < size:
-            size = stream.getSize()
-        size = size - stream.tell() 
-        self.read("data", "%us" % size, "Data")
-
-    def updateParent(self, chunk):
-        desc = "Group %s: %s" % (self.index, humanFilesize(self.getSize()))
-        if self.superblock_copy:
-            desc = desc + " (with superblock copy)"
-        chunk.description = desc 
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 <= size
-        if 0 < size:
-            self.read("raw[]", "%us" % size, "Raw")
-
-
-class EXT2_FS(OnDemandFilter):
-    def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)
-        
-        # Read superblock
-        self.seek(1024) 
-        self.superblock = self.doReadChild("superblock", "Super block", SuperBlock).getFilter()
-        self.block_size = 1024 << self.superblock["log_block_size"]
-
-        # Read groups
-        self.seek(4096) 
-        groups = self.doReadChild("group_desc", "Group descriptors", GroupDescriptors, self.superblock.group_count, 0).getFilter()
-        self.seek(groups.getGroup(0)["block_bitmap"] * self.block_size)
-        for i in range(0,self.superblock.group_count):
-            self.readChild("group[]", "Group", Group, i)
-
-        size = stream.getSize() - stream.tell()
-        if size != 0:
-            self.read("end", "%us" % size, "End (raw)")
-
-    def seek(self, to):
-        size = to - self.getStream().tell()
-        assert 0 <= size
-        if 0 < size:
-            self.read("raw[]", "%us" % size, "Raw")
-
-    def readDirectory(self, inode):
-        stream = self.getStream()
-        block_index = 0
-        while True:
-            assert block_index < 12
-            block = inode["block[%u]" % block_index]
-            if block == 0:
-                return
-            self.seek(block * self.block_size)
-
-            total = 0
-            while total < self.block_size:
-                entry = self.doReadChild("directory[]", "Directory entry", DirectoryEntry).getFilter()
-                if entry["inode"] == 0:
-                    return
-                total = total + entry.getSize()
-            assert total == self.block_size
-            block_index = block_index + 1
-
-registerPlugin(EXT2_FS, "hachoir/fs-ext2")

Deleted: haypo/hachoir/trunk/plugins/gif.py
===================================================================
--- haypo/hachoir/trunk/plugins/gif.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/gif.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,130 +0,0 @@
-"""
-GIF splitter.
-
-Status: loads header, don't load image data (stop filter), and is buggy ...
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-from error import warning
-
-class GifColor(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_color", "GIF color (RGB)", stream, parent)
-        self.read("red", "<B", "Red")
-        self.read("green", "<B", "Green")
-        self.read("blue", "<B", "Blue")
-
-class GifImage(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_image", "GIF image data", stream, parent)
-        self.read("left", "<H", "Left")
-        self.read("top", "<H", "Top")
-        self.read("width", "<H", "Width")
-        self.read("height", "<H", "Height")
-
-        # TODO: Fix this ...
-        self.read("flags", "<H", "Flags")
-        self.global_map = ((self["flags"] & 0x80) == 0x80)
-        self.interlaced = ((self["flags"] & 0x40) == 0x40)
-        self.bits_per_pixel = 1 + (self["flags"] & 0x07)
-        if not self.global_map:
-            self.readChild("local_map", GifColorMap)
-            self.local_map = self["local_map"]
-        else:
-            self.local_map = None
-        # -- End of TODO
-
-class GifColorMap(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_colormap", "GIF color map", stream, parent)
-        if issubclass(parent.__class__, GifImage):
-            self._nb_colors = (1 << parent.bits_per_pixel)
-        else:
-            assert issubclass(parent.__class__, GifFile)
-            screen = parent.getChunk("screen").getFilter()
-            self._nb_colors = (1 << screen.bits_per_pixel)
-        n = 0
-        while n<self._nb_colors:
-            self.readChild("color[]", GifColor)
-            n = n + 1
-
-    def checkEndOfMap(self, stream, array, color):
-        return len(array) == self._nb_colors 
-
-class GifExtensionChunk(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_ext_data", "GIF extension data", stream, parent)
-        self.read("size", "B", "Size (in bytes)")
-        self.read("content", "%us" % self["size"], "Content")
-
-class GifExtension(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_ext", "GIF extension", stream, parent)
-        self.read("func", "<B", "Function")
-        while True:
-            chunk = self.readChild("chunk[]", GifExtensionChunk)
-            if chunk.getFilter()["size"] == 0:
-                break
-        
-class GifScreenDescriptor(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "gif_screen_desc", "GIF screen descriptor", stream, parent)
-        self.read("width", "<H", "Width")
-        self.read("height", "<H", "Height")
-
-        # TODO: Fix this
-        self.read("flags", "<B", "Flags", post=self.processFlags)
-        # -- End of TODO
-        
-        self.read("background", "<B", "Background color")
-        self.read("notused", "<B", "Not used (zero)")
-
-    def processFlags(self, chunk):
-        flags = chunk.value
-        self.global_map = ((flags & 0x80) == 0x80) # ok
-        self.color_res = 1 + ((flags >> 4) & 0x7) # ??
-        self.bits_per_pixel = 1 + (flags & 0x7) # ok
-        if self.global_map:
-            text = "global map, "
-        else:
-            text = ""
-        return text + "color res=%u, bits/pixel=%u" % (self.color_res, self.bits_per_pixel)
-        
-class GifFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "gif_file", "GIF picture file", stream, parent)
-        # Header
-        self.read("header", "6s", "File header")
-        assert (self["header"] == "GIF87a") or (self["header"] == "GIF89a")
-        
-        self.readChild("screen", GifScreenDescriptor)
-        if self["screen"].global_map:
-            self.readChild("color_map", GifColorMap)
-            self.color_map = self["color_map"]
-        else:
-            self.color_map = None
-            
-        self.images = []
-        while True:
-            code = self.read("separator[]", "c", "Separator code")
-            code = code.getValue()
-            if code == "!":
-                self.readChild("extensions[]", GifExtension)
-            elif code == ",":
-                self.readChild("images[]", GifImage)
-                # TODO: Write Huffman parser code :-)
-#                self.readImage(stream)
-                return
-            elif code == ";":
-                # GIF Terminator
-                return
-            else:
-                raise Exception("Wrong GIF image separator: ASCII %02X." % ord(code))
-
-    def readImage(self, stream):              
-        size = stream.getSize() - stream.tell()
-        self.read("data", "%us" % size, "Image data")
-
-registerPlugin(GifFile, "image/gif")

Modified: haypo/hachoir/trunk/plugins/gzip.py
===================================================================
--- haypo/hachoir/trunk/plugins/gzip.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/gzip.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,95 +1,90 @@
 """
-Exported filter.
+GZIP archive parser.
 
-Description:
-GZIP archive file
+Author: Victor Stinner
 """
 
 import datetime
-from filter import Filter, DeflateFilter
+from filter import OnDemandFilter, DeflateFilter
+from chunk import FormatChunk, StringChunk, EnumChunk, BitsChunk, BitsStruct
 from plugin import registerPlugin
 from stream.gunzip import GunzipStream
 from plugin import getPluginByStream
 from error import error
 from default import DefaultFilter
-from tools import getBacktrace
+from text_handler import hexadecimal, humanFilesize, unixTimestamp
    
-class GzipFile(Filter):
+class GzipFile(OnDemandFilter):
+    os_name = {
+        0: "FAT filesystem",
+        1: "Amiga",
+        2: "VMS (or OpenVMS)",
+        3: "Unix",
+        4: "VM/CMS",
+        5: "Atari TOS",
+        6: "HPFS filesystem (OS/2, NT)",
+        7: "Macintosh",
+        8: "Z-System",
+        9: "CP/M",
+        10: "TOPS-20",
+        11: "NTFS filesystem (NT)",
+        12: "QDOS",
+        13: "Acorn RISCOS"} 
+
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, "gzip_file", "GZIP archive file", stream, parent)
-        self.read("id", "!2B", "Identifier (31,139)")
+        OnDemandFilter.__init__(self, "gzip_file", "GZIP archive file", stream, parent, "<")
+
+        # Gzip header
+        self.read("id", "Identifier (31,139)", (FormatChunk, "uint8[2]"))
         assert self["id"] == (31, 139)
-        self.read("comp_method", "!B", "Compression method", post=self.getCompressionMethod)
-        self.read("flags", "!B", "Flags", post=self.getFlags)
-        self.read("mtime", "<1L", "Modification time", post=self.getMTime)
-        self.read("extra", "!B", "Extra flags")
-        self.read("os", "!B", "OS", post=self.getOS)
+        self.read("compression", "Compression method", (FormatChunk, "uint8"), {"post": self.getCompressionMethod})
+        bits = (
+            (1, "text", "Text (?)"),
+            (1, "crc16", "CRC16"),
+            (1, "extra", "Extra informations (variable size)"),
+            (1, "filename", "Contains filename?"),
+            (1, "comment", "Contains comment?"),
+            (3, "unused", "Unused bits"))
+        flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+        self.read("mtime", "Modification time", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("extra", "Extra flags", (FormatChunk, "uint8"))
+        self.read("os", "Operating system", (EnumChunk, "uint8", GzipFile.os_name))
 
+        # Optionnal fields
         if self["extra"] & 4 == 4:
-            self.read("extra_length", "<2H", "Extra length")
-            self.read("extra", "%us" % self["extra_length"], "Extra")
-        if self["flags"] & 8 == 8:
-            self.readString("filename", "C", "Filename")
-        if self["flags"] & 16 == 16:
-            self.readString("comment", "C", "Comment")
-        if self["flags"] & 2 == 2:
-            self.read("crc16", "!H", "CRC16")
+            self.read("extra_length", "Extra length", (FormatChunk, "uint16"))
+            self.read("extra", "Extra", (FormatChunk, "string[%u]"  % self["extra_length"]))
+        if flags["filename"]:
+            self.read("filename", "Filename", (StringChunk, "C"))
+        if flags["comment"]:
+            self.read("comment", "Comment", (StringChunk, "C"))
+        if flags["crc16"]:
+            self.read("crc16", "CRC16", (FormatChunk, "uint16"), post=hexadecimal)
 
+        # Read content           
         oldpos = stream.tell()
         size = stream.getSize() - oldpos - 8
         try:
             gz_stream = GunzipStream(stream)
-            if hasattr(self, "filename"):
+            if self.hasChunk("filename"):
                 plugin = getPluginByStream(gz_stream, self["filename"])
             else:
                 plugin = getPluginByStream(gz_stream, None)
 
-            self.readChild("data", DeflateFilter, gz_stream, size, plugin) 
+            self.read("data", "Data", (DeflateFilter, gz_stream, size, plugin)) 
         except Exception, msg:
-            error("Error while processing file in gzip: %s\ns%s" % (msg, getBacktrace()))
+            error("Error while processing file in gzip: %s" % msg)
             stream.seek(oldpos)
-            self.read("data", "!%us" % size, "Compressed data")
-        
-        self.read("crc32", "<L", "CRC32")
-        self.read("size", "<L", "Uncompressed size")
+            self.read("data", "Compressed data", (FormatChunk, "string[%u]" % size))
 
-    def getFlags(self, chunk):
-        val = chunk.value
-        flags = []
-        if val & 1 == 1: flags.append("text")
-        if val & 2 == 2: flags.append("crc16")
-        if val & 4 == 4: flags.append("extra")
-        if val & 8 == 8: flags.append("filename")
-        if val & 16 == 16: flags.append("comment")
-        return "|".join(flags)
-        
+        # Footer
+        self.read("crc32", "CRC32", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("size", "Uncompressed size", (FormatChunk, "uint32"), {"post": humanFilesize})
+
     def getCompressionMethod(self, chunk):
         val = chunk.value
         if val < 8: return "reserved"
         if val == 8: return "deflate"
         return "Unknow (%s)" % val
 
-    def getMTime(self, chunk):
-        dt = datetime.datetime.fromtimestamp(chunk.value)
-        return str(dt)
-
-    def getOS(self, chunk):
-        os = { \
-            0: "FAT filesystem",
-            1: "Amiga",
-            2: "VMS (or OpenVMS)",
-            3: "Unix",
-            4: "VM/CMS",
-            5: "Atari TOS",
-            6: "HPFS filesystem (OS/2, NT)",
-            7: "Macintosh",
-            8: "Z-System",
-            9: "CP/M",
-            10: "TOPS-20",
-            11: "NTFS filesystem (NT)",
-            12: "QDOS",
-            13: "Acorn RISCOS"}            
-        val = chunk.value
-        return os.get(val, "Unknow (%s)" % val)
-        
 registerPlugin(GzipFile, "application/x-gzip")

Deleted: haypo/hachoir/trunk/plugins/id3.py
===================================================================
--- haypo/hachoir/trunk/plugins/id3.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/id3.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,120 +0,0 @@
-"""
-AVI splitter.
-
-Creation: 12 decembre 2005
-Status: alpha
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from tools import humanDuration
-
-class ID3_String(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "id3_string", "ID3 string", stream, parent)
-        self.read("zero", "B", "Zero")
-        assert self["zero"] == 0
-        size = stream.getSize()-1
-        self.read("content", "%us" % size, "Content")
-
-class ID3_Private(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "id3_priv", "ID3 private", stream, parent)
-        size = stream.getSize()
-        if stream.read(9, False) == "PeakValue":
-            self.read("text", "%us" % 9, "Text")
-            size = size - 9
-            self.read("content", "%us" % size, "Content")
-        else:
-            self.read("content", "%us" % size, "Content")
-
-class ID3_TrackLength(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "id3_tlen", "ID3 track length", stream, parent)
-        self.read("zero", "B", "Zero")
-        assert self["zero"] == 0
-        size = stream.getSize()-1
-        self.read("length", "%us" % size, "Length in ms", post=self.computeLength)
-
-    def computeLength(self, chunk):
-        try:
-            ms = int(chunk.value)
-            return humanDuration(ms)
-        except:
-            return chunk.value
-        
-
-class ID3_Chunk(Filter):
-    name = {
-        "COMM": "Comment",
-        "PRIV": "Private",
-        "TPE1": "Artist",
-        "TCOP": "Copyright",
-        "TALB": "Album",
-        "TENC": "Encoder",
-        "TYER": "Year",
-        "TSSE": "Encoder settings",
-        "TCOM": "Composer",
-        "TRCK": "Track number",
-        "PCNT": "Play counter",
-        "TCON": "Content type",
-        "TLEN": "Track length",
-        "TIT2": "Track title"
-    }
-    handler = {
-        "TYER": ID3_String,
-        "TALB": ID3_String,
-        "TCON": ID3_String,
-        "TPE1": ID3_String,
-        "TCOP": ID3_String,
-        "TRCK": ID3_String,
-        "TIT2": ID3_String,
-        "TSSE": ID3_String,
-        "PRIV": ID3_Private,
-        "TLEN": ID3_TrackLength
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "id3_chunk", "ID3 Chunk", stream, parent)
-        tag = self.read("tag", "!4s", "Tag").value
-        self.read("size", ">L", "Size")
-        self.read("flags", ">H", "Flags")
-        size = self["size"]
-        if tag in ID3_Chunk.handler:
-            end = stream.tell() + size
-            if size != 0:
-                substream = stream.createLimited(size=size)
-                self.readStreamChild("content", substream, ID3_Chunk.handler[tag])
-            assert stream.tell() == end
-        else:
-            self.read("data", "%us" % size, "Raw data")
-
-    def updateParent(self, chunk):
-        type = self["tag"].strip("\0")
-        if type != "":
-            type = ID3_Chunk.name.get(type, "Unknow (\"%s\")" % type)
-            desc = "ID3 Chunk: %s" % type
-        else:
-            desc = "(empty ID3 chunk)"
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ID3_Parser(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "id3", "ID3", stream, parent)
-        header = self.read("header", "!3s", "Header (ID3)").value
-        assert header == "ID3"
-        ver_major = self.read("ver_major", "!1B", "Version (major)").value
-        assert ver_major in (3,4)
-        ver_minor = self.read("ver_minor", "!B", "Version (minor)").value
-#        assert ver_minor == 0
-        self.read("flags", "!B", "Flags")
-        self.read("size", "!L", "Size")
-        end = stream.tell() + self["size"]
-        while stream.tell() < end:
-            chunk = self.readChild("chunk[]", ID3_Chunk)
-            if chunk.getFilter()["size"] == 0:
-                break
-        padding = end - stream.tell()
-        if 0 < padding:
-            self.read("padding", "%us" % padding, "Padding")
-#        assert stream.tell() == end

Modified: haypo/hachoir/trunk/plugins/jpeg.py
===================================================================
--- haypo/hachoir/trunk/plugins/jpeg.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/jpeg.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,32 +1,32 @@
 """
-Exported filter.
+JPEG picture parser.
 
-Description:
-Default filter
+Author: Victor Stinner
 """
 
-from filter import Filter, OnDemandFilter
+from filter import OnDemandFilter
 from plugin import registerPlugin
-from exif import ExifFilter
+from chunk import FormatChunk
+#from exif import ExifFilter
 
 class JpegChunkApp0(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "jpeg_chunk", "JPEG chunk App0", stream, parent)
-        self.read("jfif", "5s", "JFIF string")
-        self.read("ver_maj", "B", "Major version")
-        self.read("ver_min", "B", "Minor version")
-        self.read("units", "B", "Units (=0)")
+        OnDemandFilter.__init__(self, "app0", "JPEG APP0", stream, parent, "!")
+        self.read("jfif", "JFIF string", (FormatChunk, "string[5]"))
+        self.read("ver_maj", "Major version", (FormatChunk, "uint8"))
+        self.read("ver_min", "Minor version", (FormatChunk, "uint8"))
+        self.read("units", "Units (=0)", (FormatChunk, "uint8"))
         if self["units"] == 0:
-            self.read("aspect_x", "!H", "Aspect ratio (X)")
-            self.read("aspect_y", "!H", "Aspect ratio (Y)")
+            self.read("aspect_x", "Aspect ratio (X)", (FormatChunk, "uint16"))
+            self.read("aspect_y", "Aspect ratio (Y)", (FormatChunk, "uint16"))
         else:
-            self.read("x_density", "!H", "X density")
-            self.read("y_density", "!H", "Y density")
-        self.read("thumb_w", "B", "Thumbnail width")
-        self.read("thumb_h", "B", "Thumbnail height")
+            self.read("x_density", "X density", (FormatChunk, "uint16"))
+            self.read("y_density", "Y density", (FormatChunk, "uint16"))
+        self.read("thumb_w", "Thumbnail width", (FormatChunk, "uint8"))
+        self.read("thumb_h", "Thumbnail height", (FormatChunk, "uint8"))
         thumb = self["thumb_w"] * self["thumb_h"]
         if thumb != 0:
-            self.read("thumb_data", "%us" % size, "Thumbnail data")
+            self.read("thumb_data", "Thumbnail data", (FormatChunk, "string[%u]" % size))
 
 class JpegChunk(OnDemandFilter):
     type_name = {
@@ -44,28 +44,28 @@
     }
     handler = {
         0xE0: JpegChunkApp0,
-        0xE1: ExifFilter
+#        0xE1: ExifFilter
     }
 
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
-        self.read("header", "B", "Header")
+        OnDemandFilter.__init__(self, "chunk", "Chunk", stream, parent, "!")
+        self.read("header", "Header", (FormatChunk, "uint8"))
         assert self["header"] == 0xFF
-        self.read("type", "B", "Type", post=self.postType)
-        self.read("size", "!H", "Size")
+        self.read("type", "Type", (FormatChunk, "uint8"), {"post": self.postType})
+        self.read("size", "Size", (FormatChunk, "uint16"))
         type = self["type"]
         size = self["size"] - 2
         if type in JpegChunk.handler:
             end = stream.tell() + size
             sub = stream.createSub(size=size)
-            self.readStreamChild("content", "Chunk content", sub, JpegChunk.handler[type])
+            self.read("content", "Chunk content", (JpegChunk.handler[type],), {"stream": sub, "size": size})
             assert stream.tell() == end
         else:
-            self.read("data", "!%us" % size, "Data")
+            self.read("data", "Data", (FormatChunk, "string[%u]" % size))
             
     def updateParent(self, chunk):
         type = self.getChunk("type").display
-        desc = "JPEG chunk \"%s\"" % type
+        desc = "Chunk: %s" % type
         chunk.description = desc
 
     def postType(self, chunk):
@@ -75,13 +75,13 @@
 class JpegFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
         OnDemandFilter.__init__(self, "jpeg_file", "JPEG file", stream, parent)
-        self.read("header", "2s", "Header \"start of image\" (0xFF xD8)")
+        self.read("header", "Header \"start of image\" (0xFF xD8)", (FormatChunk, "string[2]"))
         assert self["header"] == "\xFF\xD8"
         while not stream.eof():
-            id = self.readChild("chunk[]", "Jpeg Chunk", JpegChunk)
-            if self[id]["type"] == 0xDA:
+            chunk = self.doRead("chunk[]", "Chunk", (JpegChunk,))
+            if chunk["type"] == 0xDA:
                 break
         size = stream.getSize() - self.getSize()
-        self.read("data", "%us" % size, "JPEG data")
+        self.read("data", "JPEG data", (FormatChunk, "string[%u]" % size))
         
 registerPlugin(JpegFile, "image/jpeg")

Deleted: haypo/hachoir/trunk/plugins/mbr.py
===================================================================
--- haypo/hachoir/trunk/plugins/mbr.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/mbr.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,66 +0,0 @@
-"""
-Master Boot Record.
-
-
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class PartitionEntry(Filter):
-    system_name = {
-        0x00: "Unused",
-        0x05: "Extended",
-        0x06: "FAT16",
-        0x0E: "FAT16",
-        0x0B: "FAT32",
-        0x0C: "FAT32",
-        0x82: "Linux swap",
-        0x83: "Linux"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "default", "Default filter", stream, parent)
-        bootable = self.read("bootable", "B", "Bootable flag (true if equals to 0x80)").value
-        assert bootable in (0x00, 0x80)
-        self.read("start_head", "B", "Starting head number of the partition")
-        self.read("start_sector", "B", "Starting sector number of the partition")
-        self.read("start_low_cylinder", "B", "Lower 8 bits of starting cylinder number of the partition")
-        self.read("system", "B", "System indicator", post=self.postSystem)
-        self.read("end_head", "B", "Ending head number of the partition")
-        self.read("end_sector", "B", "Ending sector number of the partition")
-        self.read("end_low_cylinder", "B", "Lower 8 bits of ending cylinder number of the partition")
-        self.read("LBA", "<L", "LBA (number of sectors before this partition)")
-        self.read("size", "<L", "Size")
-
-    def updateParent(self, parent):
-        block_size = self.getParent().block_size
-        size_mb = self["size"] / ((1 << 20) / block_size)
-
-        desc = "Partition entry (type %s, %u MB)" % (self.type, size_mb)
-        parent.description = desc
-        self.setDescription(desc)        
-
-    def postSystem(self, chunk):
-        type = chunk.value
-        self.type = PartitionEntry.system_name.get(type, "Unknow (%02X)" % type)
-        return self.type      
-
-class MasterBootRecordFilter(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "default", "Default filter", stream, parent)
-        # TODO: Get right block size!
-        self.block_size = 512
-        assert 512<=stream.getSize()
-        jmp = self.read("jmp", "B", "Jump instruction").value
-        assert jmp in (0xEB, 0xFA)
-        size = 446 - stream.tell()
-        self.read("data", "%us" % size, "Raw data")
-        self.readChild("partition[]", PartitionEntry)
-        self.readChild("partition[]", PartitionEntry)
-        self.readChild("partition[]", PartitionEntry)
-        self.readChild("partition[]", PartitionEntry)
-        id = self.read("id", "<H", "Identifier (0xAA55)").value
-        assert id == 0xAA55
-
-registerPlugin(MasterBootRecordFilter, "hachoir/master-boot-record")

Deleted: haypo/hachoir/trunk/plugins/mp3.py
===================================================================
--- haypo/hachoir/trunk/plugins/mp3.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/mp3.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,244 +0,0 @@
-"""
-AVI splitter.
-
-Creation: 12 decembre 2005
-Status: alpha
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-from id3 import ID3_Parser
-
-class MP3_File(Filter):
-    version = {
-        0: "2.5",
-        2: "2",
-        3: "1"
-    }
-    layer = {
-        0: "(reserved)",
-        1: "III",
-        2: "II",
-        3: "I"
-    }
-    bit_rate = {
-        # MPEG1
-        1: {
-            # MPEG1, layer I
-            3: {
-                1: 32,
-                2: 64,
-                3: 96,
-                4: 128,
-                5: 160,
-                6: 192,
-                7: 224,
-                8: 256,
-                9: 288,
-                10: 320,
-                11: 352,
-                12: 384,
-                13: 416,
-                14: 448
-            },
-
-            # MPEG1, layer II
-            2: {
-                1: 32,
-                2: 48,
-                3: 56,
-                4: 64,
-                5: 80,
-                6: 96,
-                7: 112,
-                8: 128,
-                9: 160,
-                10: 192,
-                11: 224,
-                12: 256,
-                13: 320,
-                14: 384
-            },
-
-            # MPEG1, layer III
-            1: {
-                1: 32,
-                2: 40,
-                3: 48,
-                4: 56,
-                5: 64,
-                6: 80,
-                7: 96,
-                8: 112,
-                9: 128,
-                10: 160,
-                11: 192,
-                12: 224,
-                13: 256,
-                14: 320
-            }
-        },
-        
-        # MPEG2 / MPEG2.5
-        2: {
-            # MPEG2 / MPEG2.5, layer I
-            3: {
-                1: 32,
-                2: 64,
-                3: 96,
-                4: 128,
-                5: 160,
-                6: 192,
-                7: 224,
-                8: 256,
-                9: 288,
-                10: 320,
-                11: 352,
-                12: 384,
-                13: 416,
-                14: 448},
-
-            # MPEG2 / MPEG2.5, layer II
-            2: {
-                1: 32,
-                2: 48,
-                3: 56,
-                4: 64,
-                5: 80,
-                6: 96,
-                7: 112,
-                8: 128,
-                9: 160,
-                10: 192,
-                11: 224,
-                12: 256,
-                13: 320,
-                14: 384},
-
-            # MPEG2 / MPEG2.5, layer III
-            1: {
-                1: 8, # 8
-                2: 16, # 16
-                3: 24, # 24
-                4: 32, # 32
-                5: 64, # 40
-                6: 80, # 48
-                7: 56, # 56
-                8: 64, # 64
-                9: 128, # 80
-                10: 160, # 96
-                11: 112, # 112
-                12: 128, # 128
-                13: 256, # 144 
-                14: 320} # 160
-        }
-    }
-    sampling_rate = {
-        # MPEG1
-        3: {
-            0: 44100,
-            1: 48000,
-            2: 32000},
-        # MPEG2
-        2: {
-            0: 22050,
-            1: 24000,
-            2: 16000},
-        # MPEG2.5
-        1: {
-            0: 11025,
-            1: 12000,
-            2: 8000}
-    }
-    emphasis = {
-        0: "none",
-        1: "50/15 ms",
-        3: "CCIT J.17"
-    }
-    channel_mode = {
-        0: "Stereo",
-        1: "Joint stereo",
-        2: "Dual channel",
-        3: "Single channel"
-    }
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "mp3", "MP3 file", stream, parent)
-        if stream.getN(3, False)=="ID3":
-            self.readChild("id3", ID3_Parser)
-        self.read("header", "!H", "Header", post=self.postHeader)
-        self.read("rate", "B", "Rates and padding", post=self.postRate)
-        self.read("various", "B", "Channel mode, mode extension, copyright, original", post=self.postVarious)
-
-        print (self.sampling_rate, self.bit_rate, self.padding)
-        frame_size = (144 * self.sampling_rate) / self.bit_rate + self.padding
-        print "Frame size=%s" % frame_size
-        
-    def postVarious(self, chunk):
-        # Get channel mode
-        channel_mode = chunk.value >> 6 & 3
-        text = MP3_File.channel_mode[channel_mode]
-
-#        mode_extension = chunk.value >> 4 & 3
-
-        # Get copyright bit
-        copyright = chunk.value >> 3 & 1
-        if copyright == 1:
-            text = text + ", copyrighted"
-
-        # Get original bit
-        original = chunk.value >> 2 & 1
-        if original == 1:
-            text = text + ", is original"
-        else:
-            text = text + ", copied"
-
-        # Get emphasis
-        emphasis = chunk.value & 3
-        assert emphasis in MP3_File.emphasis
-        emphasis = MP3_File.emphasis[emphasis]
-        if emphasis != "none":
-            text = text + ", emphasis=%s" % emphasis
-        return text 
-
-    def postHeader(self, chunk):
-        header = chunk.value
-        sync = header >> 5
-        assert sync == 2047
-        self.version = header >> 3 & 3
-        assert self.version in MP3_File.version
-        self.layer = header >> 1 & 3
-        protection = header & 1
-        text = "MPEG%s, layer %s" % (\
-            MP3_File.version[self.version],
-            MP3_File.layer[self.layer])
-        if protection==1:
-            text = "%s, protected" % text
-        return text
-
-    def postRate(self, chunk):
-        # Get bit rates
-        bit_rate = chunk.value >> 4
-        if self.version == 3: # MPEG1
-            rates = MP3_File.bit_rate[1] # MPEG1
-        else:
-            rates = MP3_File.bit_rate[2] # MPEG2 / MPEG2.5
-        assert self.layer in rates
-        rates = rates[self.layer]
-        assert bit_rate in rates
-        self.bit_rate = rates[bit_rate]
-        
-        # Get sampling rate
-        sampling_rate = chunk.value >> 2 & 3
-        rates = MP3_File.sampling_rate[self.version]
-        assert sampling_rate in rates
-        self.sampling_rate = rates[sampling_rate]
-        text = "%u bps, %s Hz" % (self.bit_rate, self.sampling_rate)
-        
-        # Get Padding
-        self.padding = chunk.value >> 1 & 1
-        if self.padding==1:
-            text = text + ", padded"
-        return text
-
-registerPlugin(MP3_File, "audio/mpeg")

Deleted: haypo/hachoir/trunk/plugins/pcx.py
===================================================================
--- haypo/hachoir/trunk/plugins/pcx.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/pcx.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,94 +0,0 @@
-"""
-PCX picture filter.
-"""
-
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-from stream.file import FileStream
-from cStringIO import StringIO
-
-class RGB(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rgb_color", "RGB color", stream, parent)
-        self.read("red", "B", "Red")
-        self.read("green", "B", "Green")
-        self.read("blue", "B", "Blue")
-    def updateParent(self, chunk):
-        chunk.description = "RGB color: #%02X%02X%02X" % (self["red"], self["green"], self["blue"])
-
-class Palette(Filter):
-    def __init__(self, stream, parent, count):
-        Filter.__init__(self, "rgb_color", "RGB color (8 bits/component)", stream, parent)
-        for i in range(0, count):
-            self.readChild("color[]", RGB)
-
-def StreamDeflateRLE(filter, stream, size):
-    start = stream.tell()
-    end = start + size - 1
-    data = ""
-    width = filter.width
-    for y in range(0, filter.height):
-        line = ""
-        while len(line) < width:
-            character = stream.getN(1)
-            byte = ord(character)
-            if byte & 192 == 192:
-                repeat = byte & 63
-                character = stream.getN(1)
-                line = line + character * repeat                
-            else:
-                line = line + character
-        assert len(line) == width
-        data = data + line
-    assert stream.tell() == end
-    stream.seek(start)
-    return FileStream(StringIO(data),None)
-
-class PCX_Content(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pcx_content", "PCX content", stream, parent)
-        pcx = parent.getParent()
-        bytes_per_line = pcx["bytes_per_line"]
-        height = pcx["bytes_per_line"]
-        for y in range(0, height):
-            self.read("line[]", "%us" % bytes_per_line, "Line")
-
-class PCX_File(Filter):
-    compression_name = {
-        1: "RLE"
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pcx_file", "PCX picture", stream, parent)
-        id = self.read("id", "B", "PCX identifier (10)").value
-        assert id == 10
-        self.read("version", "B", "PCX version")
-        self.read("compression", "B", "Compression", post=self.postCompression)
-        self.bpp = self.read("bpp", "B", "Bits / pixel").value
-        # TODO: Support 4 and 24 bits/pxiel
-        assert self.bpp == 8
-        self.read("xmin", "<H", "Minimum X")
-        self.read("ymin", "<H", "Minimum Y")
-        self.width = self.read("width", "<H", "Width minus one").value+1
-        self.height = self.read("height", "<H", "Height minus one").value+1
-        self.read("horiz_dpi", "<H", "Horizontal DPI")
-        self.read("vert_dpi", "<H", "Vertical DPI")
-        self.readChild("palette_4bits", Palette, 16)
-        self.read("reserved", "B", "Reserved")
-        self.read("nb_color_plan", "B", "Number of color plans")
-        self.read("bytes_per_line", "<H", "Bytes per line")
-        self.read("color_mode", "<H", "Color mode")
-        self.read("reserved2", "58s", "Reserved")
-
-        size = stream.getSize() - stream.tell()
-        if self.bpp == 8:
-            size = size - 256*3
-        deflate = StreamDeflateRLE(self, stream, size)
-        self.readChild("data", DeflateFilter, deflate, size, PCX_Content)
-        if self.bpp == 8:
-            self.readChild("palette_8bits", Palette, 256)
-
-    def postCompression(self, chunk):
-        mode = chunk.value
-        return PCX_File.compression_name.get(mode, "Unknow (%s)" % mode)
-
-registerPlugin(PCX_File, "image/x-pcx")

Deleted: haypo/hachoir/trunk/plugins/pdf.py
===================================================================
--- haypo/hachoir/trunk/plugins/pdf.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/pdf.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,140 +0,0 @@
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
-import re
-from stream.error import StreamError
-from stream.deflate import DeflateStream
-from tools import convertDataToPrintableString, getBacktrace
-from error import warning
-from default import DefaultFilter
-
-def isEnd(stream, array, last):
-    return stream.eof()
-
-class PdfObject(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "pdf_obj", "PDF object", stream, parent)
-        self.metadata = {}
-        chunk = self.readString("header", "AutoLine", "Object header", strip=True)
-        header = chunk.value 
-        assert header != ""
-        if header == "xref":
-            self.type = "xref"
-            self.readXref()
-        else: 
-            self.type = "obj"
-            m = re.match(r"([0-9]+) [0-9]+ obj", header)
-            if m != None:
-                id = int(m.group(1))
-                self.metadata["id"] = id
-                self.setDescription("Object (id %s)" % id)
-            else:
-                self.metadata["id"] = header
-                self.setDescription("Object (%s)" % header)
-            self.readObj()                
-        self.updateDescription()
-
-    def updateDescription(self):
-        if self.type == "obj":
-            info = "id %s" % self.metadata["id"]
-            if "type" in self.metadata:
-                info = info + ", %s" % self.metadata["type"]
-                if "fontname" in self.metadata:
-                    info = info + ", name: %s" % self.metadata["fontname"]
-        else:
-            info = "XREF"
-        self.setDescription("Object (%s)" % info)
-
-    def readContent(self):
-        text = "" 
-        deflate = False
-        while text not in ("endobj", "stream"):
-            self.processLine(text)
-            chunk = self.readString("line[]", "AutoLine", "", strip=True)
-            text = chunk.value
-            if re.match(r".*/Filter /FlateDecode.*", chunk.value) != None:
-                deflate = True
-            if self.getStream().eof():
-                return "eof"
-        if chunk.value == "endobj":
-            chunk.id = "endobj"
-            chunk.description = "Object end"
-            return "end"
-        elif deflate:
-            return "deflate"
-        else:
-            return "stream"
-    
-    def readObj(self):
-        what = self.readContent()
-        if what == "eof":
-            return
-        if what in ("stream","deflate"):
-            start = self.getStream().tell()
-            size = self._stream.searchLength("endstream", False)
-            if size == -1:
-                raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
-
-            if what=="deflate":
-                try:
-                    old = self.getStream().tell()
-                    new_stream = DeflateStream( self.getStream().getN(size,False) )
-                    self.readChild("deflate", DeflateFilter, new_stream, size, DefaultFilter)
-                except:
-                    warning("Error while decompressing data of an objet.")
-                    self.getStream().seek(start)
-                    self.read("data", "!%us" % size, "Data (compressed with deflate)")
-            else:
-                self.read("data", "!%us" % size, "Data")
-            assert self.getStream().tell() == (start+size)
-            
-            self.readString("data_end[]", "AutoLine", "Data end")
-            self.readString("endobj", "AutoLine", "Object end", strip=True)
-        ver = self.getParent().version
-        eol = self.getStream().read(1, seek=False)
-        if eol in ("\n", "\r"):
-            self.readString("emptyline", "AutoLine", "")
-
-    def readXref(self):
-        chunk = self.readString("xref_header", "AutoLine", "XRef header", strip=True)
-        m = re.match(r"^[0-9]+ ([0-9]+)$", chunk.value)
-        assert m != None
-        nb_ref = int(m.group(1)) - 1
-        n = 0
-        while n<nb_ref:
-            chunk = self.readString("ref[]", "AutoLine", "Reference", strip=True)
-            n = n + 1
-        self.readString("endobj", "AutoLine", "Object end", strip=True)
-
-    def processLine(self, line):
-        tests = {
-            "type":  r"^.*Type /([A-Za-z]+)$",
-            "fontname":  r"^.*(?:BaseFont|FontName) /(?:[A-Z]A+\+)?([A-Za-z-]+)$"
-        }
-        for field in tests:
-            m = re.match(tests[field], line)
-            if m != None:
-                self.metadata[field] = m.group(1)
-                break 
-
-class PdfFile(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "id", "", stream, parent)
-        self.readString("pdf_version", "AutoLine", "PDF version")
-        m = re.match("^%PDF-([0-9]+)\.([0-9]+)$", self["pdf_version"])
-        assert m != None
-        self.version = ( int(m.group(1)), int(m.group(2)) )
-        if self.version[0] == 1 and self.version[1] > 0:
-            # PDF > 1.0
-            self.readString("header", "AutoLine", "PDF header")
-        self.nb_ref = None
-        while not stream.eof():
-            try:
-                self.readChild("obj[]", PdfObject)
-            except StreamError, err:
-                return
-            except Exception, err:
-                print "Exception in PDF: %s" % err
-                print getBacktrace()
-                return
-
-registerPlugin(PdfFile, "application/pdf")

Modified: haypo/hachoir/trunk/plugins/png.py
===================================================================
--- haypo/hachoir/trunk/plugins/png.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/png.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,121 +1,126 @@
 """
-PNG splitter.
+PNG picture parser.
 
-Status: split into chunks, can only resplit tIME chunk.
 Author: Victor Stinner
 """
 
-from filter import Filter
+import datetime
+from filter import OnDemandFilter
+from chunk import FormatChunk, StringChunk
 from plugin import registerPlugin
+from text_handler import hexadecimal
+from generic.image import RGB
 
-class PngHeader(Filter):
+class Palette(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "png_header", "PNG header", stream, parent)
-        self.read("width", "!L", "Width (pixels)")
-        self.read("height", "!L", "Height (pixels)")
-        self.read("bit_depth", "!B", "Bit depth")
-        self.read("color_type", "!B", "Color type")
-        self.read("compression_method", "!B", "Compression method")
-        self.read("filter_method", "!B", "Filter method")
-        self.read("interlace_method", "!B", "Interlace method")
+        size = stream.getSize()
+        assert (size % 3) == 0
+        count = size / 3
+        OnDemandFilter.__init__(self, "palette", "Palette: %u colors" % count, stream, parent, "!")
+        for i in range(0, count):
+            self.read("color[]", "Color", (RGB,))
 
-    def __str__(self):
-        return "PNG header <size=%ux%u, depth=%u bits/pixel>" % \
-            (self["width"], self["height"],
-             self["bit_depth"])
+class Header(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "header", "Header", stream, parent, "!")
+        self.read("width", "Width (pixels)", (FormatChunk, "uint32"))
+        self.read("height", "Height (pixels)", (FormatChunk, "uint32"))
+        self.read("bit_depth", "Bit depth", (FormatChunk, "uint8"))
+        self.read("color_type", "Color type", (FormatChunk, "uint8"))
+        self.read("compression", "Compression method", (FormatChunk, "uint8"))
+        self.read("filter", "Filter method", (FormatChunk, "uint8"))
+        self.read("interlace", "Interlace method", (FormatChunk, "uint8"))
 
-class PngPhysical(Filter):
+class Physical(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "png_physical", "PNG physical", stream, parent)
-        self.read("pixel_per_unit_x", "!L", "Pixel per unit, X axis")
-        self.read("pixel_per_unit_y", "!L", "Pixel per unit, Y axis")
-        self.read("unit_type", "!B", "Unit type")
+        OnDemandFilter.__init__(self, "physical", "Physical", stream, parent, "!")
+        self.read("pixel_per_unit_x", "Pixel per unit, X axis", (FormatChunk, "uint32"))
+        self.read("pixel_per_unit_y", "Pixel per unit, Y axis", (FormatChunk, "uint32"))
+        self.read("unit_type", "Unit type", (FormatChunk, "uint8"))
 
-    def __str__(self):
-        if self["unit_type"] == 0:
-            unit = "unknow"
-        else:
-            unit = "meter"
-        return "PNG physical chunk <pixel per unit=(%u,%u), unit=%s>" % \
-            (self["pixel_per_unit_x"], self["pixel_per_unit_y"], unit)
-
-class PngGamma(Filter):
+class Gamma(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "png_gamma", "PNG gamma", stream, parent)
-        self.read("gamma", "!L", "Gamma (x10,000)", post=self.getGamma)
+        OnDemandFilter.__init__(self, "gamma", "Gamma", stream, parent, "!")
+        self.read("gamma", "Gamma (x10,000)", (FormatChunk, "uint32"), {"post": self.getGamma})
 
     def getGamma(self, chunk):
         return float(chunk.value) / 10000
 
-    def __str__(self):
-        return "PNG gamma <gamma=%0.2f>" % (self["gamma"])
-
-class PngText(Filter):
+class Text(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "png_text", "PNG text", stream, parent)
-        chunk = self.readString("keyword", "C", "Keyword")
+        OnDemandFilter.__init__(self, "text", "Text", stream, parent)
+        chunk = self.read("keyword", "Keyword", (StringChunk, "C"))
         lg = stream.getSize() - chunk.size
-        self.read("text", "!%us" % lg, "Text")
+        self.read("text", "Text", (FormatChunk, "string[%u]" % lg))
 
-    def __str__(self):
-        return "PNG text <keyword=\"%s\", text=\"%s\">" % \
-            (self["keyword"], self["text"])
-
-class PngTime(Filter):
+class Time(OnDemandFilter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "png_time", "PNG time", stream, parent)
-        self.read("year", "!H", "Year")
-        self.read("month", "!B", "Month")
-        self.read("day", "!B", "Day")
-        self.read("hour", "!B", "Hour")
-        self.read("minute", "!B", "Minute")
-        self.read("second", "!B", "Second")
+        OnDemandFilter.__init__(self, "time", "Time", stream, parent, "!")
+        self.read("year", "Year", [FormatChunk, "H"])
+        self.read("month", "Month", [FormatChunk, "uint8"])
+        self.read("day", "Day", [FormatChunk, "uint8"])
+        self.read("hour", "Hour", [FormatChunk, "uint8"])
+        self.read("minute", "Minute", [FormatChunk, "uint8"])
+        self.read("second", "Second", [FormatChunk, "uint8"])
 
-    def __str__(self):
-        return "PNG time chunk <%04u-%02u-%02u %02u:%02u:%02u>" % \
-            (self["year"], self["month"], self["day"],
-             self["hour"], self["minute"], self["second"])
-        
-class PngChunk(Filter):
+    def updateParent(self, chunk):
+        time = datetime.datetime(self["year"], self["month"], self["day"], self["hour"], self["minute"], self["second"])
+        chunk.description = "Time: %s" % time
+
+class Chunk(OnDemandFilter):
     handler = {
-        "tIME": PngTime,
-        "pHYs": PngPhysical,
-        "IHDR": PngHeader,
-        "gAMA": PngGamma,
-        "tEXt": PngText
+        "tIME": Time,
+        "pHYs": Physical,
+        "IHDR": Header,
+        "PLTE": Palette,
+        "gAMA": Gamma,
+        "tEXt": Text
     }
+    name = {
+        "tIME": ("time", "Creation time"),
+        "pHYs": ("physical", "Physical informations"),
+        "IHDR": ("header", "Header"),
+        "PLTE": ("palette", "Palette"),
+        "gAMA": ("gamma", "Gamma"),
+        "IDAT": ("data[]", "Image data"),
+        "IEND": ("end", "End"),
+        "tEXt": ("text", "Text")
+    }
     def __init__(self, stream, parent):
-        Filter.__init__(self, "png_chunk", "PNG chunk", stream, parent)
-        self.read("size", "!L", "Chunk size")
-        self.read("type", "!4s", "Chunk type")
+        OnDemandFilter.__init__(self, "chunk", "Chunk", stream, parent, "!")
+        self.read("size", "Size", (FormatChunk, "uint32"))
+        self.read("type", "Type", (FormatChunk, "string[4]"))
         type = self["type"]
-        if type in PngChunk.handler:
+        if type in Chunk.handler:
             size = self["size"]
+            print "%s.SIZE=%s" % (self.getId(), size)
             oldpos = self._stream.tell()
             sub = stream.createSub(size=size)
-            self.readStreamChild("chunk_data", sub, PngChunk.handler[type])
+            handler = Chunk.handler[type]
+            self.read("data", "Data", (handler,), {"stream": sub, "size": size})
             assert stream.tell() == (oldpos + size) 
         else:
-            self.read("data", "%us" % self["size"], "Chunk data")
-        self.read("crc32", "!L", "Chunk CRC32")
+            self.read("data", "Data", [FormatChunk, "string[%u]" % self["size"]])
+        self.read("crc32", "CRC32", (FormatChunk, "uint32"), {"post": hexadecimal})
 
     def updateParent(self, chunk):
-        self.description = "PNG chunk (type %s)" % self["type"]
-        chunk.description = "PNG chunk (type %s)" % self["type"]
+        type = self["type"]
+        if type in Chunk.name:
+            name = Chunk.name[type]
+            id = self.getParent().getUniqChunkId(name[0])
+            self.setId(id)
+            type = name[1] 
+        else:
+            type = "Unknow (%s)" % type
+        chunk.description = "Chunk: %s" % type
 
-    def __str__(self):
-        return "PngChunk <size=%u, type=%s>" % (self["size"], self["type"])
-
-class PngFile(Filter):
-    """
-    Split a PNG file into chunks.
-    """
-
+class PngFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, "png_file", "PNG file", stream, parent)
-        self.read("header", "!8s", "File header")
-        assert self["header"] == "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"
+        OnDemandFilter.__init__(self, "png", "PNG picture", stream, parent, "!")
+        self.read("id", "PNG identifier", [FormatChunk, "string[8]"])
+        assert self["id"] == "\x89PNG\r\n\x1A\n"
         while not stream.eof():
-            self.readChild("chunks[]", PngChunk)
+            size = 4*3 + stream.getFormat("!uint32", False)
+            self.read("chunks[]", "Chunk", (Chunk,), {"size": size})
 
 registerPlugin(PngFile, ["image/png", "image/x-png"])

Deleted: haypo/hachoir/trunk/plugins/rpm.py
===================================================================
--- haypo/hachoir/trunk/plugins/rpm.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/rpm.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,261 +0,0 @@
-"""
-RPM archive parser.
-
-Author: Victor Stinner, 1st December 2005.
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-from format import getFormatSize
-from gzip import GzipFile
-
-class RpmItem(Filter):
-    format = {
-        #  (use FormatChunk? else use StringChunk, chunk format, count)
-        0: (True, "B", 1),
-        1: (True, "c", 1),
-        2: (True, "B", 1),
-        3: (True, "H", 1),
-        4: (True, "L", 1),
-        5: (True, "L", 2),
-        6: (False, "C", 1),
-        7: (True, "s", 1),
-        8: (True, "s", 1),
-        9: (False, "C", 1)
-    }
-    type_name = {
-        0: "NULL",
-        1: "CHAR",
-        2: "INT8",
-        3: "INT16",
-        4: "INT32",
-        5: "INT64",
-        6: "STRING",
-        7: "BIN",
-        8: "STRING_ARRAY",
-        9: "STRING?"
-    }
-    tag_name = {
-        1000: "File size",
-        1001: "(Broken) MD5 signature",
-        1002: "PGP 2.6.3 signature",
-        1003: "(Broken) MD5 signature",
-        1004: "MD5 signature",
-        1005: "GnuPG signature",
-        1006: "PGP5 signature",
-        1007: "Uncompressed payload size (bytes)",
-        256+8: "Broken SHA1 header digest",
-        256+9: "Broken SHA1 header digest",
-        256+13: "Broken SHA1 header digest",
-        256+11: "DSA header signature",
-        256+12: "RSA header signature"
-    }
-    
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rpm_item", "RPM item", stream, parent)
-        self.read("tag", "!L", "Tag")
-        self.read("type", "!L", "Type", post=self.postType)
-        self.read("offset", "!L", "Offset")
-        self.read("count", "!L", "Count")
-
-    def postType(self, chunk):
-        return self.getType(chunk.value)
-
-    def updateParent(self, chunk):
-        type = self.getType(self["type"])
-        tag = self.getTagName()
-        chunk.description = "RPM item: %s (%s)" % (tag, type)
-        
-    def getTagName(self):
-        tag = self["tag"]
-        return RpmItem.tag_name.get(tag, "Unknow tag (%s)" % tag)
-
-    def doRead(self, filter):
-        type = self["type"]
-        desc = "Value of item %s, %s" % (self.getId(), self.getDescription())
-        if type != 8:
-            format = RpmItem.format[type]
-            if format[0]:
-                if 2 < self["count"] and format[1] != "s":
-                    format = "!" + str(format[2] * self["count"] * getFormatSize(format[1])) + "s"
-                else:
-                    format = "!" + str(format[2] * self["count"]) + format[1]
-                filter.read("data[]", format, desc)
-            else:     
-                format = format[1]
-                filter.readString("data[]", format, desc)
-        else:
-            id = filter.getUniqChunkId("data[]")
-            for i in range(0, self["count"]):
-                filter.readString(id+"[]", "C", desc)
-    
-    def getType(self, type):
-        return RpmItem.type_name.get(type, "Unknow type (%s)" % type)
-
-class RpmHeaderItem(RpmItem):
-    tag_name = {
-        61: "Current image",
-        62: "Signatures",
-        63: "Immutable",
-        64: "Regions",
-        100: "I18N string locales",
-        1000: "Name",
-        1001: "Version",
-        1002: "Release",
-        1003: "Epoch",
-        1004: "Summary",
-        1005: "Description",
-        1006: "Build time",
-        1007: "Build host",
-        1008: "Install time",
-        1009: "Size",
-        1010: "Distribution",
-        1011: "Vendor",
-        1012: "Gif",
-        1013: "Xpm",
-        1014: "Licence",
-        1015: "Packager",
-        1016: "Group",
-        1017: "Changelog",
-        1018: "Source",
-        1019: "Patch",
-        1020: "Url",
-        1021: "OS",
-        1022: "Arch",
-        1023: "Prein",
-        1024: "Postin",
-        1025: "Preun",
-        1026: "Postun",
-        1027: "Old filenames",
-        1028: "File sizes",
-        1029: "File states",
-        1030: "File modes",
-        1031: "File uids",
-        1032: "File gids",
-        1033: "File rdevs",
-        1034: "File mtimes",
-        1035: "File MD5s",
-        1036: "File link to's",
-        1037: "File flags",
-        1038: "Root",
-        1039: "File username",
-        1040: "File groupname",
-        1043: "Icon",
-        1044: "Source rpm",
-        1045: "File verify flags",
-        1046: "Archive size",
-        1047: "Provide name",
-        1048: "Require flags",
-        1049: "Require name",
-        1050: "Require version",
-        1051: "No source",
-        1052: "No patch",
-        1053: "Conflict flags",
-        1054: "Conflict name",
-        1055: "Conflict version",
-        1056: "Default prefix",
-        1057: "Build root",
-        1058: "Install prefix",
-        1059: "Exclude arch",
-        1060: "Exclude OS",
-        1061: "Exclusive arch",
-        1062: "Exclusive OS",
-        1064: "RPM version",
-        1065: "Trigger scripts",
-        1066: "Trigger name",
-        1067: "Trigger version",
-        1068: "Trigger flags",
-        1069: "Trigger index",
-        1079: "Verify script",
-        #TODO: Finish the list (id 1070..1162 using rpm library source code)
-    }
-        
-    def getTagName(self):
-        tag = self["tag"]
-        return RpmHeaderItem.tag_name.get(tag, "Unknow tag (%s)" % tag)
-            
-def sortRpmItem(a,b):
-    return int( a["offset"] - b["offset"] )
-
-class Header(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "header", "Header", stream, parent)
-        id = self.read("id", "4s", "Identifier").value
-        assert id == "\x8E\xAD\xE8\x01"
-        self.read("padding", "4s", "Padding")
-        self.read("count", "!L", "Count")
-        self.read("size", "!L", "Store size")
-        items = []
-        for i in range(0, self["count"]):
-            item = self.readChild("item[]", RpmHeaderItem).getFilter()
-            items.append(item)
-        items.sort( sortRpmItem )
-
-        start = stream.tell()
-        end = stream.tell() + self["size"]
-        for item in items:
-            offset = item["offset"]
-            diff = offset - (stream.tell() - start)
-            if 0 < diff:
-                self.read("padding[]", "%us" % diff, "Padding")
-
-            print "Read %s" % item.getId()                
-            item.doRead(self)
-        size = end - stream.tell()
-        if 0 < size:    
-            self.read("padding[]", "%us" % size, "Padding")
-
-class RpmSignature(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rpm_sig", "RPM signature", stream, parent)
-        self.read("id", "!3B", "Identifier")
-        assert self["id"] == (142, 173, 232)
-        self.read("version", "!B", "Signature version")
-        self.read("reserved", "4s", "Reserved")
-        self.read("count", "!L", "Count")
-        self.read("size", "!L", "Size")
-        items = []
-        for i in range(0, self["count"]):
-            item = self.readChild("item[]", RpmItem).getFilter()
-            items.append(item)
-        items.sort( sortRpmItem )
-
-        start = stream.tell()
-        end = stream.tell() + self["size"]
-        for item in items:
-            offset = item["offset"]
-            diff = offset - (stream.tell() - start)
-            if 0 < diff:
-                self.read("padding[]", "%us" % diff, "Padding")
-            item.doRead(self)
-        size = end - stream.tell()
-        if 0 < size:    
-            self.read("padding[]", "%us" % size, "Padding")
-
-class RpmFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "rpm_file", "RPM File", stream, parent)
-        self.read("id", "!4B", "Identifier")
-        assert self["id"] == (237, 171, 238, 219)
-        self.read("major_ver", "!B", "Major version")
-        self.read("minor_ver", "!B", "Minor version")
-        self.read("type", "!H", "RPM type", post=self.postType)
-        self.read("architecture", "!H", "Architecture")
-        self.read("name", "!66s", "Archive name")
-        self.read("osnum", "!H", "OS")
-        self.read("signature_type", "!H", "Type of signature")
-        self.read("reserved", "16s", "Reserved")
-        self.readChild("signature", RpmSignature)
-        self.readChild("header", Header)
-        sub = stream.createSub()
-        self.readStreamChild("gz_content", sub, GzipFile)
-
-    def postType(self, chunk):
-        if chunk.value == 0:
-            return "Binary"
-        elif chunk.value == 1:
-            return "Source"
-        else:
-            return "Unknown (%s)" % chunk.value
-
-registerPlugin(RpmFile, "application/x-rpm")

Modified: haypo/hachoir/trunk/plugins/tar.py
===================================================================
--- haypo/hachoir/trunk/plugins/tar.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/tar.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -7,10 +7,11 @@
 
 import re
 from datetime import datetime
-from filter import Filter, DeflateFilter
-from plugin import registerPlugin
+from filter import OnDemandFilter, DeflateFilter
 from tools import convertDataToPrintableString
-from default import EmptyFilter
+from plugin import registerPlugin
+from chunk import FormatChunk, EnumChunk
+from default import DefaultFilter
 from plugin import guessPlugin 
 from error import error
 from tools import getBacktrace, humanFilesize
@@ -46,10 +47,53 @@
         print "[ File %s ]" % file.name
         displayFile(file)
 
-class TarFileEntry(Filter):
-    def stripNul(self, chunk):
-        return chunk.value.strip("\0")
+class FileEntry(OnDemandFilter):
+    type_name = {
+        0: "Normal disk file (old format)",
+        # 48 is "0", 49 is "1", ...
+        48: "Normal disk file",
+        49: "Link to previously dumped file",
+        50: "Symbolic link",
+        51: "Character special file",
+        52: "Block special file",
+        53: "Directory",
+        54: "FIFO special file",
+        55: "Contiguous file"
+    }
 
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "file", "File entry", stream, parent)
+        self.read("name", "Name", (FormatChunk, "string[100]"), {"post": self.printable})
+        self.read("mode", "Mode", (FormatChunk, "string[8]"), {"post": self.convertOctal})
+        self.read("uid", "User ID", (FormatChunk, "string[8]"), {"post": self.convertOctal})
+        self.read("gid", "Group ID", (FormatChunk, "string[8]"), {"post": self.convertOctal})
+        self.read("size", "Size", (FormatChunk, "string[12]"), {"post": self.convertOctal})
+        self.read("mtime", "Modification time", (FormatChunk, "string[12]"), {"post": self.getTime})
+        self.read("check_sum", "Check sum", (FormatChunk, "string[8]"), {"post": self.convertOctal})
+        self.read("type", "Type", (EnumChunk, "uint8", FileEntry.type_name))
+        self.read("lname", "Link name", (FormatChunk, "string[100]"), {"post": self.printable})
+        self.read("magic", "Magic", (FormatChunk, "string[8]"), {"post": self.printable})
+        self.read("uname", "User name", (FormatChunk, "string[32]"), {"post": self.printable})
+        self.read("gname", "Group name", (FormatChunk, "string[32]"), {"post": self.printable})
+        self.read("devmajor", "Dev major", (FormatChunk, "string[8]"), {"post": self.printable})
+        self.read("devminor", "Dev minor", (FormatChunk, "string[8]"), {"post": self.printable})
+        self.read("padding", "Padding (zero)", (FormatChunk, "string[167]"))
+
+        self.name = self["name"].strip("\0")
+        self.size = self.octal2int(self["size"])
+        if self["type"] in (0, ord("0")) and self.size != 0:
+            substream = stream.createSub(stream.tell(), self.size)
+            plugin = guessPlugin(substream, self.name)
+            self.read("content", "Compressed file content", (DeflateFilter, substream, self.size, plugin), {"stream": substream, "size": self.size})
+
+        padding = 512 - stream.tell() % 512
+        if padding != 512:
+            self.read("padding_end", "Padding (512 align)", (FormatChunk, "string[%u]" % padding))
+
+    def printable(self, chunk):
+        value = chunk.value.strip(" \0")
+        return convertDataToPrintableString(value)
+
     def getMode(self, chunk):
         mode = self.octal2int(chunk.value)
         owner = self._getModeItem(mode >> 6 & 7)
@@ -69,57 +113,15 @@
     def convertOctal(self, chunk):
         return self.octal2int(chunk.value)
 
-    def stripNul(self, chunk):
-        val = chunk.value.strip("\0")
-        return convertDataToPrintableString(val)
-
     def getTime(self, chunk):
         value = self.octal2int(chunk.value) 
-        return datetime.fromtimestamp(value)
+        return str(datetime.fromtimestamp(value))
 
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "tar_file_entry","Tar file entry", stream, parent)
-        self.read("name", "!100s", "Name", post=self.stripNul)
-        self.name = self["name"].strip("\0")
-        self.read("mode", "!8s", "Mode", post=self.convertOctal)
-        self.read("uid", "!8s", "User ID", post=self.convertOctal)
-        self.read("gid", "!8s", "Group ID", post=self.convertOctal)
-        self.read("size", "!12s", "Size", post=self.convertOctal)
-        self.size = self.octal2int(self["size"])
-        self.read("mtime", "!12s", "Modification time", self.getTime)
-        self.read("check_sum", "!8s", "Check sum")
-        self.read("type", "!c", "Type")
-        self.read("lname", "!100s", "Link name", post=self.stripNul)
-        self.read("magic", "!8s", "Magic", post=self.stripNul)
-        self.read("uname", "!32s", "User name", post=self.stripNul)
-        self.read("gname", "!32s", "Group name", post=self.stripNul)
-        self.read("devmajor", "!8s", "Dev major")
-        self.read("devminor", "!8s", "Dev minor")
-        self.read("header_padding", "!167s", "Padding (zero)")
-        if self["type"] in ("\0", "0") and self.size != 0:
-            substream = stream.createSub(stream.tell(), self.size)
-            plugin = guessPlugin(substream, self.name)
-
-            oldpos = stream.tell()
-            try:
-                chunk = self.readChild("filedata", DeflateFilter, substream, self.size, plugin)
-#                chunk = self.readLimitedChild("filedata", stream, self.size, plugin)
-            except Exception, msg:
-                error("Error while processing tar file \"%s\": %s\n%s" % (self.name, msg, getBacktrace()))
-                stream.seek(oldpos)
-                chunk = self.readChild("filedata", EmptyFilter)
-                filter = chunk.getFilter()
-                filter.read("filedata", "!%us" % self.size, "File data")
-
-        if stream.tell() % 512 != 0:
-            padding = 512 - stream.tell() % 512
-            self.read("padding", "!%ss" % padding, "Padding (512 align)")
-
     def isEmpty(self):
         return self.name == ""
 
     def octal2int(self, str):
-        str = str.strip("\0")
+        str = str.strip(" \0")
         if str=="": return 0
         assert re.match("^[0-7]+$", str)
         try:
@@ -127,38 +129,23 @@
         except:
             return 0
 
-    def getType(self):
-        name = { \
-            "\0": "Normal disk file (old format), Unix compatible",
-            "0": "Normal disk file",
-            "1": "Link to previously dumped file",
-            "2": "Symbolic link",
-            "3": "Character special file",
-            "4": "Block special file",
-            "5": "Directory",
-            "6": "FIFO special file",
-            "7": "Contiguous file"
-        }
-        name.get(self["type"], "Unknow type (%02X)" % ord(self["type"]))
-
     def updateParent(self, chunk):
         if not self.isEmpty():
             text = "Tar File (%s: %s, %s)" \
-                % (self.name, self.getType(), humanFilesize(self.size))
+                % (self.name, self.getChunk("type").display, humanFilesize(self.size))
         else:
             text = "Tar File (terminator, empty header)"
         chunk.description = text
         self.setDescription(text)
 
-class TarFile(Filter):
+class TarFile(OnDemandFilter):
     def __init__(self, stream, parent=None):
-        Filter.__init__(self, "tar_file", "TAR archive file", stream, parent)
+        OnDemandFilter.__init__(self, "tar_file", "TAR archive file", stream, parent)
         while not stream.eof():
-            chunk = self.readChild("file[]", TarFileEntry)
-            if chunk.getFilter().isEmpty():
+            file = self.doRead("file[]", "File", (FileEntry,))
+            if file.isEmpty():
                 break
-        
         padding = stream.getSize() - stream.tell()
-        self.read("padding", "!%ss" % padding, "Padding (4096 align)")
-        
+        self.read("padding", "Padding", (FormatChunk, "string[%u]" % padding))
+
 registerPlugin(TarFile, ["application/x-gtar", "application/x-tar"])

Deleted: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/worms2.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,83 +0,0 @@
-"""
-Worms2 DIR file.
-"""
-
-from plugin import registerPlugin 
-from filter import Filter
-from plugin import registerPlugin
-from tools import humanFilesize
-
-class Worms2_Image(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_image", "Worms2 image", stream, parent)
-        nb_color = 244/3
-        self.read("palette", "%us" % (nb_color*3), "Palette (%u colors)" % nb_color)
-        self.read("padding", "B", "Padding")
-        self.read("width", "<H", "Width")
-        self.read("height", "<H", "Height")
-        size = self["width"] * self["height"]
-        self.read("img_data", "%us" % size, "Data")
-        size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "Raw end")
-
-class Worms2_Sprite(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
-        # TODO ...
-        size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "Raw end")
-
-class Worms2_Font(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_sprite", "Worms2 sprite", stream, parent)
-        self.read("palette", "%us" % (244+33), "Palette (?)")
-        self.read("charset", "%us" % (32), "Charset")
-        self.read("data", "%us" % (32+30+4+136), "Data")
-        # TODO ...
-        size = stream.getSize() - stream.tell()
-        self.read("end", "%us" % size, "Raw end")
-
-class Worms2_Resource(Filter):
-    handler = {
-        "IMG": Worms2_Image,
-        "SPR": Worms2_Sprite,
-        "FNT": Worms2_Font
-    }
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_res", "Worms2 resource", stream, parent)
-        pos = stream.tell()
-        self.tag = self.read("tag", "3s", "Type").value.strip("\0\n")
-        self.valid = self.tag.strip("\0\n") != ""
-        self.read("tag_end", "1s", "Type end")
-        size = self.read("size", "<L", "Size").value
-        if not self.valid:
-            return
-        self.readString("name", "C", "Name")
-        size = pos + size + 1 - stream.tell()
-        if self.tag in Worms2_Resource.handler:
-            sub = stream.createSub(size=size)
-            self.readStreamChild("data", sub, Worms2_Resource.handler[self.tag])
-        else:
-            self.read("data", "%us" % size, "Data")
-
-    def updateParent(self, chunk):            
-        size = humanFilesize(self["size"])
-        tag = self.tag
-        if tag != "":
-            name = self["name"]
-        else:
-            tag = "(invalid)"
-            name = "(invalid)"
-        chunk.description = "Resource \"%s\" (type=%s, size=%s)" % (name, tag, size)
-
-class Worms2_Dir_File(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent)
-        self.read("id", "3s", "Identifier (DIR)")
-        self.read("raw", "%us" % (12-stream.tell()), "Raw data")
-        while stream.tell() < 3432805:
-            file = self.readChild("file[]", Worms2_Resource).getFilter()
-            if not file.valid:
-                break
-         
-registerPlugin(Worms2_Dir_File, "hachoir/worms2")

Deleted: haypo/hachoir/trunk/plugins/xcf.py
===================================================================
--- haypo/hachoir/trunk/plugins/xcf.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/xcf.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,226 +0,0 @@
-"""
-Exif filter.
-
-Informations about Exif at:
-- http://www.exif.org/
-- http://libexif.sourceforge.net/
-
-Author: Victor Stinner
-"""
-
-from filter import Filter
-from plugin import registerPlugin
-
-class XcfCompression(Filter):
-    name = {
-        0: "None",
-        1: "RLE",
-        2: "Zlib",
-        3: "Fractal"
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "compression", "Compression", stream, parent)
-        chunk = self.read("compression", "B", "")
-        type = XcfCompression.name.get(chunk.value, "Unknow (%s)" % chunk.value)
-        chunk.description = "Compress type (%s)" % type
-
-class XcfResolution(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "resolution", "Resolution", stream, parent)
-        self.read("xres", "f", "X resolution")
-        self.read("yres", "f", "Y resolution")
-
-class XcfTattoo(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "tattoo", "Tattoo", stream, parent)
-        self.read("tattoo", "!L", "Tattoo")
-
-class XcfUnit(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "unit", "Unit", stream, parent)
-        self.read("unit", "!L", "Unit")
-
-def readString(filter, stream, name, description):
-    filter.readString(name, "Pascal32", description, strip="\0")
-    return
-    
-    chunk = filter.read(name+"_size", "!L", description+" length")
-    filter.read(name, "%us" % chunk.value, description)
-
-class XcfParasiteEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_para", "XCF parasite", stream, parent)
-        readString(self, stream, "name", "Name")
-        self.read("flags", "!L", "Flags")
-        self.read("size", "!L", "Size")
-        if 0 < self["size"]:
-            self.read("data", "%us" % self["size"], "Data")
-
-class XcfLevel(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_level", "XCF level", stream, parent)
-        self.read("width", "!L", "Width")
-        self.read("height", "!L", "Height")
-        self.read("offset", "!L", "Offset")
-        offset = self["offset"]
-        if offset == 0:
-            return
-        data_offsets = []
-        while stream.tell() < offset:
-            chunk = self.read("data_offset[]", "!L", "Data offset")
-            if chunk.value == 0:
-                break
-            data_offsets.append(chunk.value)
-        assert stream.tell() == offset
-        previous = offset
-        for data_offset in data_offsets:
-            size = data_offset - previous
-            self.read("data[]", "%us" % size, "Data")
-            previous = data_offset
-
-class XcfHierarchie(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_hier", "XCF hierarchie", stream, parent)
-        self.read("width", "!L", "Width")
-        self.read("height", "!L", "Height")
-        self.read("bpp", "!L", "Bits/pixel")
-            
-        offsets = []
-        while True:
-            chunk = self.read("offset[]", "!L", "Level offset")
-            if chunk.value == 0:
-                break
-            offsets.append(chunk.value)
-        for offset in offsets:
-            seek(self, stream, offset)
-            self.readChild("level[]", XcfLevel)
-#        self.readChild("channel[]", XcfChannel)
-
-class XcfChannel(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_channel", "XCF channel", stream, parent)
-        self.read("width", "!L", "Channel width")
-        self.read("height", "!L", "Channel height")
-        readString(self, stream, "name", "Channel name")
-        readProperties(self, stream)
-        self.read("hierarchie_ofs", "!L", "Hierarchie offset")
-        self.readChild("hierarchie", XcfHierarchie)
-
-class XcfLayer(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_layer", "XCF layer", stream, parent)
-        self.read("width", "!L", "Layer width")
-        self.read("height", "!L", "Layer height")
-        self.read("type", "!L", "Layer type")
-        readString(self, stream, "name", "Layer name")
-        readProperties(self, stream)
-        # TODO: Hack for Gimp 1.2 files
-        self.read("hierarchie_ofs", "!L", "Hierarchie offset")
-        self.read("mask_ofs", "!L", "Layer mask offset")
-        seek(self, stream, self["hierarchie_ofs"])
-        self.readChild("hierarchie", XcfHierarchie)
-        # TODO: Read layer mask if needed: self["mask_ofs"] != 0
-
-    def updateParent(self, chunk):
-        desc = "Layer \"%s\"" % self["name"]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class XcfParasites(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "parasites", "Parasites", stream, parent)
-        while not stream.eof():
-            self.readChild("parasite[]", XcfParasiteEntry)
-
-class XcfProperty(Filter):
-    known_types = {
-        0: "End",
-        1: "Colormap",
-        2: "Active layer",
-        3: "Active channel",
-        4: "Selection",
-        5: "Floating selection",
-        6: "Opacity",
-        7: "Mode",
-        8: "Visible",
-        9: "Linked",
-        10: "Lock alpha",
-        11: "Apply mask",
-        12: "Edit mask",
-        13: "Show mask",
-        14: "Show masked",
-        15: "Offsets",
-        16: "Color",
-        17: "Compression",
-        18: "Guides",
-        19: "Resolution",
-        20: "Tattoo",
-        21: "Parasites",
-        22: "Unit",
-        23: "Paths",
-        24: "User unit",
-        25: "Vectors",
-        26: "Text layer flags"
-    }
-    handler = {
-        17: XcfCompression,
-        19: XcfResolution,
-        20: XcfTattoo,
-        21: XcfParasites,
-        22: XcfUnit
-    }
-
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf_prop", "XCF property", stream, parent)
-        chunk = self.read("type", "!L", "")
-        chunk.description = "Property type (%s)" % self.getType()
-        self.read("size", "!L", "Property size")
-        type = self["type"]
-        if type in XcfProperty.handler:
-            end = stream.tell() + self["size"]
-            substream = stream.createSub(size=self["size"])
-            self.readStreamChild("data", substream, XcfProperty.handler[type])
-            assert stream.tell() == end
-        elif 0 < self["size"]:
-            self.read("data", "%us" % self["size"], "Data")
-
-    def updateParent(self, parent):
-        parent.description = "XCF property (%s)" % self.getType()
-
-    def getType(self):
-        return XcfProperty.known_types.get(self["type"], "Unknow type (%u)" % self["type"])
-
-def readProperties(filter, stream):        
-    while True:
-        chunk = filter.readChild("property[]", XcfProperty)
-        type = chunk.getFilter()["type"]
-        if type == 0:
-            break
-
-def seek(filter, stream, offset):
-    current = stream.tell()
-    if current != offset:
-        filter.read("padding[]", "%us" % (offset-current), "Padding")
-
-class XcfFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "xcf", "XCF file", stream, parent)
-        self.readString("header", "C", "Header")
-        assert self["header"] == "gimp xcf file"
-        self.read("width", "!L", "Image width")
-        self.read("height", "!L", "Image height")
-        self.read("type", "!L", "Image type")
-        readProperties(self, stream)
-
-        offsets = []
-        while True:
-            chunk = self.read("layer_offset[]", "!L", "Layer offset")
-            if chunk.value == 0:
-                break
-            offsets.append(chunk.value)
-        for offset in offsets:
-            seek(self, stream, offset)
-            self.readChild("layer[]", XcfLayer)
-
-registerPlugin(XcfFile, "image/x-xcf")

Deleted: haypo/hachoir/trunk/plugins/zip.py
===================================================================
--- haypo/hachoir/trunk/plugins/zip.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/plugins/zip.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,115 +0,0 @@
-"""
-Zip splitter.
-
-Status: can read most important headers
-Author: Victor Stinner
-"""
-
-import sys
-from filter import Filter
-from plugin import registerPlugin
-from error import error
-from text_handler import humanFilesize, hexadecimal
-
-class ZipCentralDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_central_dir", "ZIP central directory", stream, parent)
-        self.read("version_made_by", "<H", "Version made by")
-        self.read("version_needed", "<H", "Version neede")
-        self.read("flags", "<H", "General purpose flag")
-        self.read("compression_method", "<H", "Compression method")
-        self.read("last_mod_file_time", "<H", "Last moditication file time")
-        self.read("last_mod_file_date", "<H", "Last moditication file date")
-        self.read("crc32", "<L", "CRC-32")
-        self.read("compressed_size", "<L", "Compressed size")
-        self.read("uncompressed_size", "<L", "Uncompressed size")
-        self.read("filename_length", "<H", "Filename length")
-        self.read("extra_length", "<H", "Extra fields length")
-        self.read("file_comment_length", "<H", "File comment length")
-        self.read("disk_number_start", "<H", "Disk number start")
-        self.read("internal_attr", "<H", "Internal file attributes")
-        self.read("external_attr", "<L", "External file attributes")
-        self.read("offset_header", "<L", "Relative offset of local header")
-        self.read("filename", "%us" % self["filename_length"], "Filename")
-        self.read("extra", "%us" % self["extra_length"], "Extra fields")
-        self.read("file_comment", "%us" % self["file_comment_length"], "File comment")
-
-    def updateParent(self, chunk):
-        desc = "Central directory: %s" % self["filename"]
-        chunk.description = desc
-        self.setDescription(desc)
-
-class ZipEndCentralDirectory(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_end_dir", "ZIP end central directory", stream, parent)
-        self.read("number_disk", "<H", "Number of this disk")
-        self.read("number_disk2", "<H", "Number of this disk2")
-        self.read("total_number_disk", "<H", "Total number of entries")
-        self.read("total_number_disk2", "<H", "Total number of entries2")
-        self.read("size", "<L", "Size of the central directory")
-        self.read("offset", "<L", "Offset of start of central directory")
-        self.readString("comment", "Pascal16", "ZIP comment")
-
-#class ZipZip64(Filter):
-#    def __init__(self, stream, parent):
-#        Filter.__init__(self, "zip_zip64, "ZIP ZIP64", stream, parent)
-#        self.read("size", "<Q", "Directory size")
-#        self.read("version_made_by", "<H", "Version made by")
-#        self.read("version_needed", "<H", "Version neede")
-#        self.read("disk_index", "<L", "Disk index")
-#        self.read("disk_index2", "<L", "Disk index2")
-#        self.read("disk_number", "<Q", "Disk number")
-#        self.read("disk_number2", "<Q", "Disk number2")
-#        self.read("size2", "<Q", "Directory size2")
-#        self.read("offset", "<Q", "Offset")
-        
-class ZipFileEntry(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_file_entry", "ZIP file entry", stream, parent)
-        self.read("version", "<H", "Version")
-        self.read("flags", "<H", "Flags")
-        self.read("compression_method", "<H", "Compression method")
-        self.read("last_mod_time", "<H", "Last modification time")
-        self.read("last_mod_date", "<H", "Last modification date")
-        self.read("crc32", "<L", "Checksum (CRC32)")
-        self.read("compressed_size", "<L", "Compressed size (bytes)", post=humanFilesize)
-        self.read("uncompressed_size", "<L", "Uncompressed size (bytes)", post=humanFilesize)
-        self.read("filename_length", "<H", "Filename length")
-        self.read("extra_length", "<H", "Extra length")
-        self.read("filename", "%us" % self["filename_length"], "Filename")
-        self.read("extra", "%us" % self["extra_length"], "Extra")
-        self.read("compressed_data", "%us" % self["compressed_size"], "Compressed data")
-        if (self["flags"] & 4) == 4:
-            self.read("file_crc32", "<L", "Checksum (CRC32)")
-            self.read("file_compressed_size", "<L", "Compressed size (bytes)")
-            self.read("file_uncompressed_size", "<L", "Uncompressed size (bytes)")
-
-    def updateParent(self, chunk):
-        size = self.getChunk("compressed_size").display
-        desc = "File entry: %s (%s)" % (self["filename"], size)
-        chunk.description = desc
-        self.setDescription(desc)
-        
-class ZipFile(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "zip_file", "ZIP archive file", stream, parent)
-        # File data
-        self.signature = None
-        self.central_directory = []
-        self.files = []
-        while not stream.eof():
-            header = self.read("header[]", "<L", "Header", post=hexadecimal).value
-            if header == 0x04034B50:
-                self.readChild("files[]", ZipFileEntry)
-            elif header == 0x02014b50:
-                self.readChild("central_directory[]", ZipCentralDirectory)
-            elif header == 0x06054b50:
-                self.readChild("end_central_directory", ZipEndCentralDirectory)
-            elif header == 0x05054b50:
-                self.readString("signature", "Pascal16", "Signature")
-            else:
-                error("Error, unknow ZIP header (0x%08X)." % header)
-                size = stream.getSize() - stream.tell()
-                self.read("raw", "%us" % size, "Raw")
-        
-registerPlugin(ZipFile, "application/x-zip")

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/text_handler.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,8 +1,12 @@
-from tools import humanFilesize as doHumanFilesize
-
 def humanFilesize(chunk):
+    from tools import humanFilesize as doHumanFilesize
     return doHumanFilesize(chunk.value)
 
+def unixTimestamp(chunk):
+    import datetime
+    timestamp = datetime.datetime.fromtimestamp(chunk.value)
+    return str(timestamp) 
+
 def hexadecimal(chunk):
     size = chunk.size
     assert size in (2, 4, 8)

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/tools.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -123,15 +123,12 @@
 def humanFilesize(size):
     if size < 1000:
         return "%u bytes" % size
-    units = ["KB", "MB", "GB"]
+    units = ["KB", "MB", "GB", "TB"]
     size = float(size)
     for unit in units:
         size = size / 1024
-        if size < 100:
+        if size < 1024:
             return "%.1f %s" % (size, unit)
-        if size < 1000:
-            return "%u %s" % (size, unit)
-        last_unit = unit
     return "%u %s" % (size, unit)
 
 def convertDataToPrintableString(data, keep_n=False):

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/ui/ui_window.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -152,7 +152,7 @@
     def add_table(self, parent, addr, size, format, id, description, value):
         addr = str(addr)
         size = str(size)
-        self.table_store.append(parent, (addr, format, size, id, value, description, ))
+        return self.table_store.append(parent, (addr, format, size, id, value, description, ))
 
     def onKeyUp(self, widget, key, data=None):
         if key.keyval == gtk.keysyms.Escape:

Modified: haypo/hachoir/trunk/user_filter.py
===================================================================
--- haypo/hachoir/trunk/user_filter.py	2005-12-26 03:33:53 UTC (rev 350)
+++ haypo/hachoir/trunk/user_filter.py	2005-12-26 03:53:11 UTC (rev 351)
@@ -1,4 +1,4 @@
-from filter import Filter
+from filter import OnDemandFilter
 from chunk import FilterChunk
 from xml.dom.minidom import getDOMImplementation, parse
 from program import VERSION
@@ -21,7 +21,7 @@
         self.sub_format = sub_format
 
 def loadUserFilter(desc, stream, parent):
-    filter = Filter(desc.id, desc.description, stream, parent)
+    filter = OnDemandFilter(desc.id, desc.description, stream, parent)
     for chunk in desc.chunks:
         if chunk.format == "sub":
             modules = chunk.sub_format.split('.')



