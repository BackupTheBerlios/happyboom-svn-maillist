From haypo at berlios.de  Sun Jan  1 17:08:51 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 1 Jan 2006 17:08:51 +0100
Subject: [Happyboom-svn] r379 - in haypo/hachoir/trunk: . stream
Message-ID: <200601011608.k01G8pDD009664@sheep.berlios.de>

Author: haypo
Date: 2006-01-01 17:08:50 +0100 (Sun, 01 Jan 2006)
New Revision: 379

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/stream/stream.py
Log:
- Bugfix in LimitedStream and SubStream: they use their own stream 'seed' now.
- Bugifx in Filter: only update UI in updateChunkDescription when UI is loaded ...
- Create method addPadding() for Filter


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2005-12-29 13:51:09 UTC (rev 378)
+++ haypo/hachoir/trunk/filter.py	2006-01-01 16:08:50 UTC (rev 379)
@@ -97,6 +97,11 @@
     def _getEndian(self): return self._endian
     endian = property(_getEndian)
 
+    def addPadding(self):
+        size = self._stream.getLastPos() - self._stream.tell()
+        if size != 0:
+            self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+
     # --- Pure virtual methods -----------
     def getSize(self): todoWriteMethod(self, "getSize") 
     def __getitem__(self, chunk_id): todoWriteMethod(self, "__getitem__") 
@@ -141,8 +146,9 @@
         assert pos != -1
         self._chunks_dict[id][1] = desc
 
-        info = self.displayChunkInfo(id)
-        ui.window.update_table(self, pos, *info)
+        if ui.ui != None:
+            info = self.displayChunkInfo(id)
+            ui.window.update_table(self, pos, *info)
 
     def purgeCache(self):
         if len(self._chunks_cache) != 0 and config.verbose:

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2005-12-29 13:51:09 UTC (rev 378)
+++ haypo/hachoir/trunk/stream/stream.py	2006-01-01 16:08:50 UTC (rev 379)
@@ -46,6 +46,7 @@
             start = self.tell()
         if size == None:
             size = self.getSize()-start
+        print "create sub : start=%s, size=%s" % (start, size)            
         return SubStream(self, start, size, self.filename)
 
     def createLimited(self, start=None, size=None):
@@ -147,7 +148,7 @@
         self._size = size
         self._end = self._start + self._size
         self._last_pos = self._end - 1
-        self._stream.seek(self._start)
+        self._seed = self._start
 
     def getType(self):
         return "%s of %s: %s..%s" % \
@@ -163,18 +164,26 @@
         
     def read(self, size, seek=True):
         """ Works like Posix read (can returns less than size bytes. """
-        return self._stream.read(size, seek)
+        self._stream.seek(self._seed)
+        data = self._stream.read(size, seek)
+        if seek:
+            self._seed += len(data)
+        return data
 
     def getN(self, size, seek=True):
-        if self._start+self._size<self._stream.tell()+size:
+        if self._start+self._size<self._seed+size:
             raise StreamError( \
                 "Can't read outsize the stream\n"
                 +"(try to read %u byte(s) from position %s, where stream in limited in [%u;%u])" \
-                % (size, self._stream.tell(), self._start, self._end))
-        return self._stream.getN(size, seek)
+                % (size, self._seed, self._start, self._end))
+        self._stream.seek(self._seed)
+        data = self._stream.getN(size, seek)
+        if seek:
+            self._seed += size
+        return data
 
     def tell(self):
-        return self._stream.tell()
+        return self._seed
 
     def seek(self, pos, where=0):
         if where == 2:
@@ -182,9 +191,9 @@
         elif where == 0:
             pos = pos
         elif where == 1:
-            pos = self._stream.tell() + pos
+            pos = self._seed + pos
         assert self._start <= pos and pos <= self._end
-        self._stream.seek(pos, 0)
+        self._seed = pos
         
     def getSize(self):
         return self._size
@@ -207,22 +216,18 @@
             pos = pos - self._start
         return pos
                
-    def read(self, size, seek=True):
-        """ Works like Posix read (can returns less than size bytes. """
-        return self._stream.read(size, seek)
- 
     def seek(self, pos, where=0):
         if where == 2:
             pos = self.getLastPos() - pos
         elif where == 0:
             pos = self._start + pos
         elif where == 1:
-            pos = self._stream.tell() + pos
+            pos = self._seed + pos
         assert self._start <= pos and pos <= self._end
-        self._stream.seek(pos, 0)
+        self._seed = pos
 
     def tell(self):
-        return self._stream.tell() - self._start
+        return self._seed - self._start
     
     def getLastPos(self):
         return self._end - self._start



From haypo at berlios.de  Sun Jan  1 17:09:24 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 1 Jan 2006 17:09:24 +0100
Subject: [Happyboom-svn] r380 - haypo/hachoir/trunk/stream
Message-ID: <200601011609.k01G9O9C009727@sheep.berlios.de>

Author: haypo
Date: 2006-01-01 17:09:24 +0100 (Sun, 01 Jan 2006)
New Revision: 380

Modified:
   haypo/hachoir/trunk/stream/stream.py
Log:
Ooops, remove dummy print in stream.py


Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2006-01-01 16:08:50 UTC (rev 379)
+++ haypo/hachoir/trunk/stream/stream.py	2006-01-01 16:09:24 UTC (rev 380)
@@ -46,7 +46,6 @@
             start = self.tell()
         if size == None:
             size = self.getSize()-start
-        print "create sub : start=%s, size=%s" % (start, size)            
         return SubStream(self, start, size, self.filename)
 
     def createLimited(self, start=None, size=None):



From haypo at berlios.de  Sun Jan  1 20:31:36 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 1 Jan 2006 20:31:36 +0100
Subject: [Happyboom-svn] r381 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601011931.k01JVaUm023430@sheep.berlios.de>

Author: haypo
Date: 2006-01-01 20:31:30 +0100 (Sun, 01 Jan 2006)
New Revision: 381

Added:
   haypo/hachoir/trunk/bits.py
   haypo/hachoir/trunk/reverse.py
Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/text_handler.py
   haypo/hachoir/trunk/tools.py
Log:
- Move all functions about bits into bits.py
- Create Reverse class which will help for reverse engineering


Added: haypo/hachoir/trunk/bits.py
===================================================================
--- haypo/hachoir/trunk/bits.py	2006-01-01 16:09:24 UTC (rev 380)
+++ haypo/hachoir/trunk/bits.py	2006-01-01 19:31:30 UTC (rev 381)
@@ -0,0 +1,79 @@
+def str2hex(value):
+    text = "(hex) "
+    for character in value:
+        if text != "":
+            text += " "
+        text += "%02X" % ord(character)
+    return text
+
+def countBits(value):
+    """
+    0 -> 0 bit
+    1 -> 1 bit
+    2 -> 2 bits
+    4 -> 3 bits
+    ...
+    """
+    bits = 0
+    if value < 0:
+        bits += 1
+        value = -value
+    while value >= 1:
+        bits += 1
+        value >>= 1
+    return bits        
+
+def byte2bin(x, reverse=True):
+    text = ""
+    for i in range(0,8):
+        if reverse:
+            mask = 1 << (7-i)
+        else:
+            mask = 1 << i
+        if (x & mask) == mask:
+            text += "1"
+        else:
+            text += "0"
+    return text            
+
+def long2bin(value, reverse=True):
+    text = ""
+    while (value != 0 or text == ""):
+        if text != "":
+            text += " "
+        byte = value & 0xFF            
+        text += byte2bin(byte, not reverse)
+        value >>= 8
+    return text        
+
+def str2bin(value, reverse=False):
+    text = ""
+    for character in value:
+        if text != "":
+            text += " "
+        byte = ord(character)
+        text += byte2bin(byte, not reverse)
+    return text
+
+def reverseBits(x):
+    y = 0
+    for i in range(0,8):
+        mask = (1 << i)
+        if (x & mask) == mask:
+            y |= (1 << (7-i))
+    return y
+
+def str2long(data, reverse_byte=False):
+    """
+    Convert a string into a number with big endian order.
+    Eg. "\0\1\2" => 0x001020
+    """
+    shift = 0
+    value = 0
+    for character in data:
+        byte = ord(character)
+        if reverse_byte:
+            byte = reverseBits(byte)
+        value += (byte << shift) 
+        shift += 8
+    return value        

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2006-01-01 16:09:24 UTC (rev 380)
+++ haypo/hachoir/trunk/chunk.py	2006-01-01 19:31:30 UTC (rev 381)
@@ -2,7 +2,8 @@
 import config
 from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsArray, formatIsInteger, formatIsArray
 from error import warning, error
-from tools import convertDataToPrintableString, str2long
+from tools import convertDataToPrintableString
+from bits import str2long
 
 class Chunk(object):
     """

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-01 16:09:24 UTC (rev 380)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-01 19:31:30 UTC (rev 381)
@@ -14,7 +14,6 @@
 
 # Only for debug purpose
 from text_handler import binary
-from tools import str2hex, str2bin
 
 class ImageData(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -39,9 +38,7 @@
         self.read("height", "Height", (FormatChunk, "uint16"))
         size = self["width"] * self["height"]
         self.read("img_data", "Data", (FormatChunk, "string[%u]" % size))
-        size = stream.getLastPos() - stream.tell()
-        if size != 0:
-            self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+        self.addPadding()
 
     def updateParent(self, chunk):            
         chunk.description = "Image: %ux%u pixels" % \
@@ -75,43 +72,42 @@
         self.read("zero[]", "???", (FormatChunk, "uint16"))
         flags_b = self.doRead("flags_b", "???", (FormatChunk, "uint16"), {"post": binary}).value
         import re
+        self.n = 0
         if flags_b != 0:
-            n = 1
+            self.n = 1
             if re.match("^Batrope", name) != None:
-                n = 3
+                self.n = 3
             elif re.match("^Homing", name) != None:
-                n = 2
+                self.n = 2
             elif re.match("^Sheep", name) != None:
-                n = 5
+                self.n = 5
             elif re.match("^Network", name) != None:
-                n = 18
-            size = n * 12
+                self.n = 18
+        size = self.n * 12
+        if size != 0:
             self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
         self.x = self.doRead("x[]", "Offset X", (FormatChunk, "uint16")).value
         self.y = self.doRead("y[]", "Offset Y", (FormatChunk, "uint16")).value
         self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
         self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
         self.count = self.doRead("count", "Item count", (FormatChunk, "uint16")).value
-        for i in range(0, self.count):
-            self.read("item[]", "Item", (SpriteItem,))
+#        for i in range(0, self.count):
+#            self.read("item[]", "Item", (SpriteItem,))
         if False:            
             real_width = self.width - self.x
             real_height = self.height - self.y
             size = real_width * real_height
-            if size <= (stream.getLastPos() - stream.tell()+1-1):
+            if size <= (stream.getLastPos() - stream.tell()):
                 self.read("image_data[]", "Data (%ux%u pixels)" % (real_width, real_height), (FormatChunk, "string[%u]" % size))
-        else:                
-            size = stream.getLastPos() - stream.tell() + 1
+        elif False:                
+            size = stream.getLastPos() - stream.tell()
             self.read("raw", "Raw data", (FormatChunk, "string[%u]" % size))
+        self.addPadding()
 
-        size = stream.getLastPos() - stream.tell() + 1
-        if 0 < size:
-            self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
-
     def updateParent(self, chunk):            
         if self.count is not None:
-            chunk.description = "Animation: %ux%u pixels, %u frame(s)" % \
-                (self.width, self.height, self.count)
+            chunk.description = "Animation: n=%u, %ux%u pixels, %u frame(s)" % \
+                (self.n, self.width, self.height, self.count)
         else:                
             chunk.description = "Sprite: %ux%u pixels" % \
                 (self.width, self.height)
@@ -134,8 +130,7 @@
                 self.width = image.width
                 self.height = image.height
             self.nb_characters += 1
-        size = stream.getLastPos() - stream.tell() + 1
-        self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+        self.addPadding()
 
     def updateParent(self, chunk):
         chunk.description = "Font: %ux%u pixels, %u characters" \
@@ -166,7 +161,8 @@
             
             size = pos + size + 1 - stream.tell()
             if self.tag in Resource.handler:
-                sub = stream.createLimited(size=size)
+                #sub = stream.createLimited(size=size)
+                sub = stream.createSub(size=size)
                 self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})
             else:
                 self.read("data", "Data", (FormatChunk, "string[%u]" % size))

Added: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-01 16:09:24 UTC (rev 380)
+++ haypo/hachoir/trunk/reverse.py	2006-01-01 19:31:30 UTC (rev 381)
@@ -0,0 +1,359 @@
+from stream.file import FileStream
+from plugins.worms2 import Worms2_Dir_File
+from plugins.gzip import GzipFile
+from format import getFormatSize
+from bits import countBits
+import sys
+
+class IntValues:
+    def __init__(self, data=None):
+        self.items = None
+        self.min = None
+        self.max = None
+        if data != None:
+            self.set(data)
+
+    def hasValue(self, value):
+        return self._in(self.items, value)
+        
+    def _in(self, values, x):
+        if isinstance(values, tuple):
+            return values[0] <= x and x <= values[1]
+        elif isinstance(values, list):
+            result = 0
+            for item in values:
+                if self._in(item, x):
+                    return True
+            return False
+        elif values != None:        
+            return values == x
+        else:
+            return False
+
+    def set(self, value):
+        self.items = None
+        self.min = self.max = None
+        self.add(value)
+
+    def __str__(self):
+        return str(self.items)        
+
+    def isEmpty(self):
+        return self.items == None
+
+    def __len__(self):
+        return self._length(self.items)
+        
+    def _length(self, values):
+        if isinstance(values, tuple):
+            return values[1] - values[0] + 1
+        elif isinstance(values, list):
+            result = 0
+            for item in values:
+                result += self._length(item)
+            return result
+        elif values != None:        
+            return 1 
+        else:
+            return 0
+
+    def values(self):
+        return self._values(self.items)
+        
+    def _values(self, values):
+        if isinstance(values, tuple):
+            return range(values[0], values[1]+1)
+        elif isinstance(values, list):
+            result = []
+            for item in values:
+                result.extend( self._values(item) )
+            return result
+        elif values != None:        
+            return [values]
+        else:
+            return []
+
+    def add(self, new):
+        if isinstance(new, IntValues):
+            new = new.items
+
+        # TODO: Fix that!
+        if isinstance(new, int):
+            if self.min == None or new < self.min:
+                self.min = new
+            if self.max == None or new > self.max:
+                self.max = new
+        elif isinstance(new, tuple):
+            if self.min == None or new[0] < self.min:
+                self.min = new[0]
+            if self.max == None or new[1] > self.max:
+                self.max = new[1]
+
+        if isinstance(self.items, tuple):
+            if isinstance(new, tuple):
+                if self.items[0] <= new[0] and new[1] <= self.items[1]:
+                    return
+                assert False # TODO: Finish ..
+            elif isinstance(new, int):
+                if (new - self.items[1]) == 1:
+                    self.items = (self.items[0], new)
+                else:
+                    self.items = [self.items, new]
+            else:            
+                assert False # TODO: Finish ..
+            return
+        elif isinstance(self.items, list):
+            for index in range(0, len(self.items)):
+                item = self.items[index]
+                if item == new:
+                    return
+                if new < item:
+                    self.items.insert(index-1, new)
+                    return
+ #               if isinstance(item, tuple):
+#                    ...
+            if isinstance(new, list):
+                for item in new:
+                    self.add(item)
+            else:
+                self.items.append(new)
+        elif self.items != None:        
+            if isinstance(self.items, int) and isinstance(new, int):
+                if (self.items-new) == 1:
+                    self.items = (new, self.items)
+                    return
+                elif (self.items-new) == -1:
+                    self.items = (self.items, new)
+                    return
+            self.items = [self.items]
+            self.add(new)
+        else:
+            self.items = new
+
+    def intersection(self, second):
+        first = set( self.values() ) 
+        second = set( second.values() )
+        result = first.intersection(second)
+        result = list(result)
+        return IntValues(result)
+
+class Field:
+    def __init__(self, id):
+        self.id = id    
+        self.values = {}
+        self.streams = {}
+
+    def getStreamsByValue(self, value):
+        return self.streams.get(value, [])
+
+    def getValueByStream(self, stream, default=None):
+        return self.values.get(stream, default)
+
+    def getValues(self):
+        return self.streams.keys()
+
+    def addValue(self, stream, value):
+        self.values[stream] = value
+        if value not in self.streams:
+            self.streams[value] = []
+        self.streams[value].append(stream)
+
+class Reverse:
+    def __init__(self):
+        self.fields = {}
+        self.streams = []
+        
+        # Feeded after analyse
+        self.started = False
+        self.min_size, self.max_size = None, None
+        self.data_range = None
+        self.cst_list = None
+        self.data_list = None
+
+    def _initAnalyse(self, data_range):
+        if self.started:
+            assert data_range == self.data_range
+            return
+        assert 0 < len(self.streams)
+        self.started = True        
+        self.data_range = data_range
+
+        # Find mimimum/maximum stream size
+        self.min_size = self.max_size = self.streams[0].getSize()
+        for stream in self.streams[1:]:
+            size = stream.getSize()
+            if size < self.min_size:
+                self.min_size = size
+            if size > self.max_size:
+                self.max_size = size            
+        assert 1 <= self.min_size                
+
+    def _findConstant(self, streams, data_range):
+        assert 2 <= len(streams)
+
+        # Find mimimum/maximum stream size
+        min_size = streams[0].getSize()
+        for stream in streams[1:]:
+            size = stream.getSize()
+            if size < min_size:
+                min_size = size
+        assert 1 <= min_size                
+
+        # Verify data range
+        if not isinstance(data_range, IntValues):
+            data_range = IntValues(data_range)
+        assert 0 <= data_range.min and data_range.max < min_size
+
+        # Compare streams ...
+        cst_list = IntValues()
+        data_list = IntValues()
+        input = streams[0] 
+        for addr in data_range.values():
+            input.seek(addr)
+            byte = input.getFormat("uint8")
+            cst = True
+            for stream in streams[1:]:
+                stream.seek(addr)
+                if stream.getFormat("uint8") != byte:
+                    cst = False
+                    break
+            if cst:
+                cst_list.add(addr)
+            else:
+                data_list.add(addr)
+        return (cst_list, data_list)                
+
+    def displayConstant(self, data_range):
+        cst_list, data_list = self._findConstant(self.streams, data_range)
+        stream = self.streams[0]
+        for addr in cst_list.values():
+            stream.seek(addr)
+            byte = stream.getFormat("uint8")
+            print "Constant %u: %02X" % (addr, byte)
+
+    def displayData(self, data_range):
+        cst_list, data_list = self._findConstant(self.streams, data_range)
+        for id in self.fields:
+            field = self.fields[id]
+            data = []
+            for stream in self.streams:
+                value = field.getValueByStream(stream)
+                data.append(value)
+            data = [ "%02X" % x for x in data ]
+            data = " ".join(data)
+            print "       %s: %s" % (id, data)
+            
+        for addr in data_list.values():
+            data = []
+            for stream in self.streams:
+                stream.seek(addr)
+                byte = stream.getFormat("uint8")
+                data.append(byte)                    
+            data = [ "%02X" % x for x in data ]
+            data = " ".join(data)
+            print "Data %u: %s" % (addr, data)
+
+    def OLDfindField(self, id, data_range):
+        self.cst_list, self.data_list = self._findConstant(self.streams, data_range)
+        field = self.fields[id]
+        values = field.getValues()
+        addr = IntValues()
+        possible_addr = self.data_list
+        first = True
+        for value in values:
+            streams = field.getStreamsByValue(value)
+            if 1<len(streams):
+                cst_list, data_list = self._findConstant(streams, self.data_list)
+            else:
+                cst_list = self.data_list
+            if first:
+                addr.add(cst_list)
+                first = False
+            else:
+                addr = addr.intersection(cst_list)
+            if addr.isEmpty():
+                break            
+        return (addr, possible_addr)
+
+    def findInteger(self, stream, value, range, size_bits):
+        assert size_bits <= 32
+        formats = ["<uint32", ">uint32"]
+        if size_bits <= 16:
+            formats.extend(["<uint16", ">uint16"])
+        if size_bits <= 8:
+            formats.append("uint8")
+        ok = IntValues()
+        endian = {}
+        for addr in range.values():
+            stream.seek(addr)
+            for format in formats:
+                size = getFormatSize(format)
+                if addr+size <= stream.getLastPos():
+                    read = int( stream.getFormat(format, False) )
+                    if value.hasValue(read):
+                        ok.add(addr)
+        return ok                    
+
+    def findField(self, id, data_range):
+        field = self.fields[id]
+        ok = data_range
+        max_values = map(lambda x: x.max, field.getValues())
+        min_values = map(lambda x: x.min, field.getValues())
+        size_bits = max(countBits(max(max_values)), countBits(min(min_values)))
+        print size_bits
+        for stream in self.streams:
+            value = field.getValueByStream(stream)
+            addr = self.findInteger(stream, value, data_range, size_bits)
+            ok = ok.intersection(addr)
+        return ok            
+
+    def addSource(self, stream, fields={}):
+        assert not self.started
+        self.streams.append(stream)
+        for id in fields:
+            if id not in self.fields:
+                self.fields[id] = Field(id)
+            self.fields[id].addValue(stream, fields[id])
+
+def main():
+    name = '/home/haypo/worms/Gfx.dir'
+    f = open(name, 'r')
+    input = FileStream(f, name)
+    root = Worms2_Dir_File(input, None)
+    res = root["resources"]
+    reverse = Reverse()
+#    sprite_range = IntValues( [(0,13), 67, 72] )
+    sprite_range = IntValues( (0,72) )
+    for i in sprite_range.values():
+        sprite = res["res[%u]" % i]["data"]
+        stream = sprite.getStream().createSub(start=sprite.getAddr(), size=sprite.getSize())
+#        assert sprite.n < 5
+        reverse.addSource(stream, {"n": sprite.n})
+    header = IntValues( (243, 258) )
+    print "Find field in range %s" % header
+#    reverse.displayData(header)        
+#     reverse.displayConstant(header)
+    addr = reverse.findField("n", header)
+    print "Address of field n: %s\n(or in %s)" % (addr[0], addr[1])
+
+def loadGZ(filename):
+    f = open(filename, 'r')
+    input = FileStream(f, filename)
+    return GzipFile(input, None) 
+
+def main():
+    reverse = Reverse()
+    for filename in sys.argv[1:]:
+        g = loadGZ(filename)
+        stream = g.getStream()
+        sub = stream.createSub(start=stream.getSize()-50)
+        size = int(g["size"])
+        size = IntValues( (size-30, size+30) )
+        reverse.addSource(sub, {"size": size})
+    header = IntValues( (0,49) )
+#    reverse.displayConstant(header)
+    addr = reverse.findField("size", header)
+    print "Address of field n: %s" % addr 
+
+if __name__=="__main__":
+    main()


Property changes on: haypo/hachoir/trunk/reverse.py
___________________________________________________________________
Name: svn:executable
   + *

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2006-01-01 16:09:24 UTC (rev 380)
+++ haypo/hachoir/trunk/text_handler.py	2006-01-01 19:31:30 UTC (rev 381)
@@ -1,5 +1,6 @@
 import datetime
-from tools import humanFilesize as doHumanFilesize, str2bin
+from tools import humanFilesize as doHumanFilesize
+from bits import str2bin
 
 def msdosDatetime(chunk):
     assert chunk.size == 4

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2006-01-01 16:09:24 UTC (rev 380)
+++ haypo/hachoir/trunk/tools.py	2006-01-01 19:31:30 UTC (rev 381)
@@ -1,69 +1,5 @@
 import traceback, sys, string, re
 
-def reverseBits(x):
-    y = 0
-    for i in range(0,8):
-        mask = (1 << i)
-        if (x & mask) == mask:
-            y |= (1 << (7-i))
-    return y
-
-def str2long(data, reverse_byte=False):
-    """
-    Convert a string into a number with big endian order.
-    Eg. "\0\1\2" => 0x001020
-    """
-    shift = 0
-    value = 0
-    for character in data:
-        byte = ord(character)
-        if reverse_byte:
-            byte = reverseBits(byte)
-        value += (byte << shift) 
-        shift += 8
-    return value        
-
-
-def byte2bin(x, reverse=True):
-    text = ""
-    for i in range(0,8):
-        if reverse:
-            mask = 1 << (7-i)
-        else:
-            mask = 1 << i
-        if (x & mask) == mask:
-            text += "1"
-        else:
-            text += "0"
-    return text            
-
-def long2bin(value, reverse=True):
-    text = ""
-    while (value != 0 or text == ""):
-        if text != "":
-            text += " "
-        byte = value & 0xFF            
-        text += byte2bin(byte, not reverse)
-        value >>= 8
-    return text        
- 
-def str2bin(value, reverse=False):
-    text = ""
-    for character in value:
-        if text != "":
-            text += " "
-        byte = ord(character)
-        text += byte2bin(byte, not reverse)
-    return text
-
-def str2hex(value):
-    text = "(hex) "
-    for character in value:
-        if text != "":
-            text += " "
-        text += "%02X" % ord(character)
-    return text
-
 def _regexMaxLength(pattern, in_parenthesis=False):
     """
     Don't use this function directly, use regexMagLength!



From haypo at berlios.de  Mon Jan  2 01:48:55 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 2 Jan 2006 01:48:55 +0100
Subject: [Happyboom-svn] r382 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601020048.k020mt2S021335@sheep.berlios.de>

Author: haypo
Date: 2006-01-02 01:48:42 +0100 (Mon, 02 Jan 2006)
New Revision: 382

Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/reverse.py
Log:
- Worms2 plugin: Fix Sprite mysterious header count
- Worms2 plugin: Fix Font character count
- Add "Fixed" StringChunk format (size is given by optionnal argument)
- Small bugfixes in Reverse


Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2006-01-01 19:31:30 UTC (rev 381)
+++ haypo/hachoir/trunk/chunk.py	2006-01-02 00:48:42 UTC (rev 382)
@@ -146,10 +146,11 @@
         "AutoLine": "line",
         "Pascal16": "pascal16",
         "Pascal32": "pascal32",
-        "WindowsLine": "windows line"
+        "WindowsLine": "windows line",
+        "Fixed": "fixed"
     }
 
-    def __init__(self, id, description, stream, str_type, parent, strip=None, charset="ascii"):
+    def __init__(self, id, description, stream, str_type, parent, strip=None, charset="ascii", size=None):
         """
         Strip: if strip=None, call read text.strip()
                if strip is a string, call read text.strip(self.strip)
@@ -158,7 +159,7 @@
         Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
         self._str_type = str_type
         self.eol = None
-        self._findSize()
+        self._findSize(size)
         self.strip = strip
         self.charset = charset
 
@@ -168,9 +169,13 @@
             self.charset)
     getSmallFormat = getFormat
 
-    def _findSize(self):
+    def _findSize(self, size):
         self._stream.seek(self.addr)
-        if self._str_type == "Pascal16":
+        if self._str_type == "Fixed":
+            self.length = size 
+            self._size = size
+            self.eol = ""
+        elif self._str_type == "Pascal16":
             self.length = self._stream.getFormat("!uint16")
             self._size = 2 + self.length
             self.eol = ""

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-01 19:31:30 UTC (rev 381)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 00:48:42 UTC (rev 382)
@@ -25,6 +25,15 @@
         size = (self.width-self.x) * (self.height-self.y)
         self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
 
+    def getStaticSize(stream, args):
+        oldpos = stream.tell()
+        x, y = stream.getFormat("<uint16"), stream.getFormat("<uint16")
+        w, h = stream.getFormat("<uint16"), stream.getFormat("<uint16")
+        size = 2*4 + (w-x) * (h-y)
+        stream.seek(oldpos)
+        return size
+    getStaticSize = staticmethod(getStaticSize)
+
     def updateParent(self, chunk):
         chunk.description = "Image data: %ux%u pixels at (%u,%u)" \
             % (self.width, self.height, self.x, self.y)
@@ -44,9 +53,23 @@
         chunk.description = "Image: %ux%u pixels" % \
             (self["width"], self["height"])
 
-class SpriteItem(OnDemandFilter):
+class MysteriousHeader(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite_item", "Sprite item", stream, parent, "<")
+        self.read("a", "???", (FormatChunk, "uint16"))
+        self.read("b", "???", (FormatChunk, "uint16"))
+        self.read("c", "???", (FormatChunk, "uint16"))
+        self.read("d", "???", (FormatChunk, "uint16"))
+        self.read("e", "???", (FormatChunk, "uint16"))
+        self.read("f", "???", (FormatChunk, "uint16"))
+        
+    def updateParent(self, chunk):            
+        chunk.description = "Mysterious: d=%s f=%s a=%s b=%s c=%s e=%s" % \
+            (self["d"],self["f"],self["a"],self["b"],self["c"],self["e"])
+
+class SpriteFrame(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "frame", "Sprite frame", stream, parent, "<")
         self.read("a", "???", (FormatChunk, "uint8"))
         self.read("b", "???", (FormatChunk, "uint16"))
         self.read("c", "???", (FormatChunk, "uint8"))
@@ -56,7 +79,7 @@
         self.read("height", "Height", (FormatChunk, "uint16"))
 
     def updateParent(self, chunk):            
-        chunk.description = "Sprite item: %ux%u pixels at (%u,%u)" % \
+        chunk.description = "Frame: %ux%u pixels at (%u,%u)" % \
             (self["width"], self["height"], self["x"], self["y"])
 
 class Sprite(OnDemandFilter):
@@ -66,75 +89,85 @@
         self.read("palette", "Palette", (Palette, 81))
         self.read("header116", "Header 116", (FormatChunk, "uint8"))
         assert self["header116"] == 116 
-        self.read("type", "Type?", (FormatChunk, "uint8"))
-        self.read("zero[]", "???", (FormatChunk, "string[9]"))
-        self.read("flags_a", "???", (FormatChunk, "uint16"), {"post": binary})
-        self.read("zero[]", "???", (FormatChunk, "uint16"))
-        flags_b = self.doRead("flags_b", "???", (FormatChunk, "uint16"), {"post": binary}).value
-        import re
-        self.n = 0
-        if flags_b != 0:
-            self.n = 1
-            if re.match("^Batrope", name) != None:
-                self.n = 3
-            elif re.match("^Homing", name) != None:
-                self.n = 2
-            elif re.match("^Sheep", name) != None:
-                self.n = 5
-            elif re.match("^Network", name) != None:
-                self.n = 18
-        size = self.n * 12
-        if size != 0:
-            self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
-        self.x = self.doRead("x[]", "Offset X", (FormatChunk, "uint16")).value
-        self.y = self.doRead("y[]", "Offset Y", (FormatChunk, "uint16")).value
-        self.width = self.doRead("width[]", "Width", (FormatChunk, "uint16")).value
-        self.height = self.doRead("height[]", "Height", (FormatChunk, "uint16")).value
-        self.count = self.doRead("count", "Item count", (FormatChunk, "uint16")).value
-#        for i in range(0, self.count):
-#            self.read("item[]", "Item", (SpriteItem,))
+
+        if False:
+            self.read("n", "Type?", (FormatChunk, "uint8"))
+            self.read("zero[]", "???", (FormatChunk, "string[9]"))
+            self.read("flags_a", "???", (FormatChunk, "uint16"), {"post": binary})
+            self.read("zero[]", "???", (FormatChunk, "uint16"))
+            flags_b = self.doRead("flags_b", "???", (FormatChunk, "uint16"), {"post": binary}).value
+            for i in range(0, self["n"]-1):
+                self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
+        else:
+            self.read("n", "Type?", (FormatChunk, "uint16"))
+            self.read("m", "Type?", (FormatChunk, "uint16"))
+            for i in range(0, self["n"]):
+                self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
+            
+        self.read("x", "Offset X", (FormatChunk, "uint16"))
+        self.read("y", "Offset Y", (FormatChunk, "uint16"))
+        self.read("width", "Width", (FormatChunk, "uint16"))
+        self.read("height", "Height", (FormatChunk, "uint16"))
+        self.read("count", "Frame count", (FormatChunk, "uint16"))
+        for i in range(0, self["count"]):
+            self.read("item[]", "Frame", (SpriteFrame,))
         if False:            
-            real_width = self.width - self.x
-            real_height = self.height - self.y
+            real_width = self["width"] - self["x"]
+            real_height = self["height"] - self["y"]
             size = real_width * real_height
             if size <= (stream.getLastPos() - stream.tell()):
                 self.read("image_data[]", "Data (%ux%u pixels)" % (real_width, real_height), (FormatChunk, "string[%u]" % size))
-        elif False:                
-            size = stream.getLastPos() - stream.tell()
-            self.read("raw", "Raw data", (FormatChunk, "string[%u]" % size))
         self.addPadding()
 
     def updateParent(self, chunk):            
-        if self.count is not None:
-            chunk.description = "Animation: n=%u, %ux%u pixels, %u frame(s)" % \
-                (self.n, self.width, self.height, self.count)
-        else:                
-            chunk.description = "Sprite: %ux%u pixels" % \
-                (self.width, self.height)
+        chunk.description = "Animation: %ux%u pixels, %u mysterious, %u frame(s)" % \
+            (self["width"], self["height"], self["n"], self["count"])
 
 class Font(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "font", "Font", stream, parent, "<")
         self.read("palette", "Palette", (Palette, 81))
 
-        size = 261 
-        # TODO: Decode header
-        self.read("header", "Header !?", (FormatChunk, "string[%u]" % size))
+        self.read("header116", "Header 116", (FormatChunk, "uint8"))
 
-        self.nb_characters = 0
-#        while 2*4 < (stream.getLastPos() - stream.tell() + 1):
-        for i in range(0, 160):
-            id = self.read("image[]", "Image", (ImageData,))
-            if self.nb_characters == 0:
-                image = self[id]
-                self.width = image.width
-                self.height = image.height
-            self.nb_characters += 1
+        #--- Ugly header ---
+        size = 32+2-1
+        self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
+        size = 32 
+        self.read("charset", "???", (FormatChunk, "string[%u]" % size))
+        size = 25+2-1 
+        self.read("iter", "???", (FormatChunk, "string[%u]" % size))
+        size = 6 
+        self.read("charset2", "???", (FormatChunk, "string[%u]" % size))
+        size = 6
+        self.read("iter2", "???", (FormatChunk, "string[%u]" % size))
+        size = 24
+        self.read("charset3", "???", (FormatChunk, "string[%u]" % size))
+        size = 32
+        self.read("zero", "???", (FormatChunk, "string[%u]" % size))
+        self.read("a", "???", (FormatChunk, "uint16"))
+        self.read("b", "???", (FormatChunk, "uint16"))
+        self.read("c", "???", (FormatChunk, "uint16"))
+        size = 27
+        self.read("zero", "???", (FormatChunk, "string[%u]" % size))
+        size = 64 
+        self.read("charset4", "???", (StringChunk, "Fixed"), {"size": size, "charset": "iso-8859-1"})
+        self.read("d", "???", (FormatChunk, "uint16"))
+
+        # Read images
+        self.read("nb_char", "Number of characters", (FormatChunk, "uint16"))
+        for i in range(0, self["nb_char"]):
+            self.read("image[]", "Image", (ImageData,))
+
+        # Get image size
+        image = self["image[0]"]
+        self.width = image.width
+        self.height = image.height
         self.addPadding()
 
     def updateParent(self, chunk):
         chunk.description = "Font: %ux%u pixels, %u characters" \
-            % (self.width, self.height, self.nb_characters)
+            % (self.width, self.height, self["nb_char"])
 
 class Resource(OnDemandFilter):
     name = {

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-01 19:31:30 UTC (rev 381)
+++ haypo/hachoir/trunk/reverse.py	2006-01-02 00:48:42 UTC (rev 382)
@@ -2,7 +2,7 @@
 from plugins.worms2 import Worms2_Dir_File
 from plugins.gzip import GzipFile
 from format import getFormatSize
-from bits import countBits
+from bits import countBits, long2bin, str2hex
 import sys
 
 class IntValues:
@@ -13,6 +13,9 @@
         if data != None:
             self.set(data)
 
+    def __hash__(self):
+        return hash(self.items)
+
     def hasValue(self, value):
         return self._in(self.items, value)
         
@@ -141,22 +144,33 @@
     def __init__(self, id):
         self.id = id    
         self.values = {}
+        self.values_list = {}
         self.streams = {}
 
     def getStreamsByValue(self, value):
-        return self.streams.get(value, [])
+        return self.streams.get(hash(value), [])
 
     def getValueByStream(self, stream, default=None):
         return self.values.get(stream, default)
 
+    def getBitSize(self):
+        values = self.getValues()
+        max_value = max([ value.max for value in values])
+        min_value = min([ value.min for value in values])
+        return max(countBits(max_value), countBits(min_value))
+
     def getValues(self):
-        return self.streams.keys()
+        return self.values_list.values()
 
     def addValue(self, stream, value):
+        if not isinstance(value, IntValues):
+            value = IntValues(value)
         self.values[stream] = value
-        if value not in self.streams:
-            self.streams[value] = []
-        self.streams[value].append(stream)
+        if hash(value) not in self.streams:
+            self.streams[hash(value)] = []
+        self.streams[hash(value)].append(stream)
+        if hash(value) not in self.values_list:
+            self.values_list[hash(value)] = value
 
 class Reverse:
     def __init__(self):
@@ -292,19 +306,21 @@
                     read = int( stream.getFormat(format, False) )
                     if value.hasValue(read):
                         ok.add(addr)
+                        break
         return ok                    
 
     def findField(self, id, data_range):
         field = self.fields[id]
         ok = data_range
-        max_values = map(lambda x: x.max, field.getValues())
-        min_values = map(lambda x: x.min, field.getValues())
-        size_bits = max(countBits(max(max_values)), countBits(min(min_values)))
-        print size_bits
+        size_bits = field.getBitSize()
+        print "Find integer field \"%s\" (at least %u bits long) ..." % (id, size_bits)
+        i = 1
         for stream in self.streams:
+            print "  find in stream %u/%u ..." % (i, len(self.streams))
             value = field.getValueByStream(stream)
             addr = self.findInteger(stream, value, data_range, size_bits)
             ok = ok.intersection(addr)
+            i += 1
         return ok            
 
     def addSource(self, stream, fields={}):
@@ -315,33 +331,12 @@
                 self.fields[id] = Field(id)
             self.fields[id].addValue(stream, fields[id])
 
-def main():
-    name = '/home/haypo/worms/Gfx.dir'
-    f = open(name, 'r')
-    input = FileStream(f, name)
-    root = Worms2_Dir_File(input, None)
-    res = root["resources"]
-    reverse = Reverse()
-#    sprite_range = IntValues( [(0,13), 67, 72] )
-    sprite_range = IntValues( (0,72) )
-    for i in sprite_range.values():
-        sprite = res["res[%u]" % i]["data"]
-        stream = sprite.getStream().createSub(start=sprite.getAddr(), size=sprite.getSize())
-#        assert sprite.n < 5
-        reverse.addSource(stream, {"n": sprite.n})
-    header = IntValues( (243, 258) )
-    print "Find field in range %s" % header
-#    reverse.displayData(header)        
-#     reverse.displayConstant(header)
-    addr = reverse.findField("n", header)
-    print "Address of field n: %s\n(or in %s)" % (addr[0], addr[1])
-
 def loadGZ(filename):
     f = open(filename, 'r')
     input = FileStream(f, filename)
     return GzipFile(input, None) 
 
-def main():
+def gzip_size():
     reverse = Reverse()
     for filename in sys.argv[1:]:
         g = loadGZ(filename)
@@ -355,5 +350,100 @@
     addr = reverse.findField("size", header)
     print "Address of field n: %s" % addr 
 
+def int16Bits(value):
+    v = []
+    for i in range(0,16):
+        mask = 1 << i
+        if (value & mask) == mask:
+            v.append(1)
+        else:
+            v.append(0)  
+    return v
+
+def guessBits(d):    
+    for n in d:
+        val = d[n]
+        data = val[0]
+        print "====== n=%u, data set=%u items" % (n, len(val))
+        if 1<len(val):
+            for i in range(0, 11):
+                cst = True
+                for bits in val[1:]:
+                    if bits[i] != data[i]:
+                        cst = False
+                        break
+                if cst:
+                    print "bit %u: const=%s" % (i, data[i])
+        else:
+            print "(not enough data)"
+   
+def worms2_sprite(res):    
+    #sprite_range = IntValues( (0,73) )
+    #sprite_range = IntValues( (0,100) )
+    sprite_range = IntValues( (0,100) )
+    d = {}
+    for i in sprite_range.values():
+        sprite = res["res[%u]" % i]["data"]
+        flags = sprite["flags_b"]
+        w,h = sprite["width[0]"],sprite["height[0]"]
+        if w < 10 or 1000<w or h<10 or 1000<h:
+            print "res[%u] errone" % i
+        else:
+            n = sprite.n
+            stream = sprite.getStream()
+            stream.seek(81*3+1) ; m = stream.getFormat("uint8")-1
+            #stream.seek(258) ;  data = stream.getN(14)
+            stream.seek(81*3) ;  data = stream.getN(272-243)
+            if n not in d:
+                d[n] = []
+#            d[n].append( (sprite["type"],int16Bits(flags),sprite["width[0]"],sprite["height[0]"],i) )
+            d[n].append( (i, m, data) )
+#    guessBits(d)        
+#    return
+        
+    for n in d:
+        print "======== %s =========" % n
+        for data in d[n]:
+            print "% 3s] n=% 2s m=% 2s %s" % (data[0], n, data[1], str2hex(data[2]))
+#            xxx = "".join(map(str,bits[1]))
+#            print "%s] %s (%ux%u), id=res[%u]" % (bits[0], xxx, bits[2], bits[3], bits[4])
+
+def worms2_n(res):
+    reverse = Reverse()
+    sprite_range = IntValues( (0,72) )
+    for i in sprite_range.values():
+        sprite = res["res[%u]" % i]["data"]
+        #stream = sprite.getStream().createSub(start=sprite.getAddr(), size=sprite.getSize())
+        reverse.addSource(stream, {"n": sprite.n})
+    header = IntValues( (243, 258) )
+    print "Find field in range %s" % header
+#    reverse.displayData(header)        
+#     reverse.displayConstant(header)
+    addr = reverse.findField("n", header)
+    print "Address of field n: %s\n(or in %s)" % (addr[0], addr[1])
+
+def worms2_font(res):
+    reverse = Reverse()
+    sprite_range = IntValues( (713,739) )
+    for i in sprite_range.values():
+        font = res["res[%u]" % i]["data"]
+        reverse.addSource(font.getStream(), {"nb": font["nb_char"]})
+    header = IntValues( (0, 600) )
+    print "Find field in range %s" % header
+#    reverse.displayData(header)        
+#     reverse.displayConstant(header)
+    addr = reverse.findField("nb", header)
+    print "Address of field n: %s" % (addr)
+#    print "Address of field n: %s\n(or in %s)" % (addr[0], addr[1])
+
+def worms2():
+    f = open('/home/haypo/worms/Gfx.dir', 'r')
+    input = FileStream(f, None)
+    res = Worms2_Dir_File(input, None)["resources"]
+#    worms2_sprite(res)
+#    worms2_n(res)
+    worms2_font(res)
+ 
 if __name__=="__main__":
-    main()
+    worms2()
+#    gzip_size()



From haypo at berlios.de  Mon Jan  2 04:18:27 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 2 Jan 2006 04:18:27 +0100
Subject: [Happyboom-svn] r383 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601020318.k023IRwf029372@sheep.berlios.de>

Author: haypo
Date: 2006-01-02 04:18:22 +0100 (Mon, 02 Jan 2006)
New Revision: 383

Modified:
   haypo/hachoir/trunk/default.py
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/format.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/reverse.py
Log:
- Worms2 plugin: Extract palette from filters
- Reverse: create guessPattern() method which can recognize pattern like:
  (header, size1, data1, size2, data2, ...)
- Reverse: fix Field.getValues()
- Filter: fix addPadding() (only add padding if needed ...)


Modified: haypo/hachoir/trunk/default.py
===================================================================
--- haypo/hachoir/trunk/default.py	2006-01-02 00:48:42 UTC (rev 382)
+++ haypo/hachoir/trunk/default.py	2006-01-02 03:18:22 UTC (rev 383)
@@ -1,9 +1,9 @@
 from filter import OnDemandFilter
 from chunk import FormatChunk
 
-#class EmptyFilter(OnDemandFilter):
-#    def __init__(self, stream, parent=None):
-#        OnDemandFilter.__init__(self, "empty", "Empty filter", stream, parent)
+class EmptyFilter(OnDemandFilter):
+    def __init__(self, stream, parent=None):
+        OnDemandFilter.__init__(self, "empty", "Empty filter", stream, parent)
 
 class DefaultFilter(OnDemandFilter):
     def __init__(self, stream, parent=None):

Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-02 00:48:42 UTC (rev 382)
+++ haypo/hachoir/trunk/filter.py	2006-01-02 03:18:22 UTC (rev 383)
@@ -99,7 +99,7 @@
 
     def addPadding(self):
         size = self._stream.getLastPos() - self._stream.tell()
-        if size != 0:
+        if 0 < size:
             self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 
     # --- Pure virtual methods -----------

Modified: haypo/hachoir/trunk/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2006-01-02 00:48:42 UTC (rev 382)
+++ haypo/hachoir/trunk/format.py	2006-01-02 03:18:22 UTC (rev 383)
@@ -79,6 +79,10 @@
     cache = FormatCache.getInstance()[format]
     return cache[3] in "bBhHlL"
 
+def getFormatEndian(format):
+    cache = FormatCache.getInstance()[format]
+    return cache[1]   
+
 def getFormatSize(format):
     cache = FormatCache.getInstance()[format]
     return cache[4]   

Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2006-01-02 00:48:42 UTC (rev 382)
+++ haypo/hachoir/trunk/hachoir_class.py	2006-01-02 03:18:22 UTC (rev 383)
@@ -131,7 +131,7 @@
             compiled = compile(script, self.script, 'exec')
             exec compiled
         except Exception, msg:
-            error("Exception while loading script \"%s\":\n%s\n%s" \
+            error("Exception while loading script \"%s\":\n%s" \
                 % (filename, msg))
 
     def run(self, filename):

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 00:48:42 UTC (rev 382)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 03:18:22 UTC (rev 383)
@@ -41,7 +41,6 @@
 class Image(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "image", "Image", stream, parent, "<")
-        self.read("palette", "Palette", (Palette, 81))
         self.read("padding", "Padding", (FormatChunk, "uint8"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
@@ -86,7 +85,6 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
         name = parent.name
-        self.read("palette", "Palette", (Palette, 81))
         self.read("header116", "Header 116", (FormatChunk, "uint8"))
         assert self["header116"] == 116 
 
@@ -100,7 +98,7 @@
                 self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
         else:
             self.read("n", "Type?", (FormatChunk, "uint16"))
-            self.read("m", "Type?", (FormatChunk, "uint16"))
+            self.read("zero", "Zero?", (FormatChunk, "uint16"))
             for i in range(0, self["n"]):
                 self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
             
@@ -126,33 +124,16 @@
 class Font(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "font", "Font", stream, parent, "<")
-        self.read("palette", "Palette", (Palette, 81))
 
         self.read("header116", "Header 116", (FormatChunk, "uint8"))
 
         #--- Ugly header ---
-        size = 32+2-1
+        size = 33
         self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
-        size = 32 
-        self.read("charset", "???", (FormatChunk, "string[%u]" % size))
-        size = 25+2-1 
-        self.read("iter", "???", (FormatChunk, "string[%u]" % size))
-        size = 6 
-        self.read("charset2", "???", (FormatChunk, "string[%u]" % size))
-        size = 6
-        self.read("iter2", "???", (FormatChunk, "string[%u]" % size))
-        size = 24
-        self.read("charset3", "???", (FormatChunk, "string[%u]" % size))
-        size = 32
-        self.read("zero", "???", (FormatChunk, "string[%u]" % size))
-        self.read("a", "???", (FormatChunk, "uint16"))
-        self.read("b", "???", (FormatChunk, "uint16"))
-        self.read("c", "???", (FormatChunk, "uint16"))
-        size = 27
-        self.read("zero", "???", (FormatChunk, "string[%u]" % size))
-        size = 64 
-        self.read("charset4", "???", (StringChunk, "Fixed"), {"size": size, "charset": "iso-8859-1"})
-        self.read("d", "???", (FormatChunk, "uint16"))
+        size = 256 - stream.tell()
+        self.read("xxx", "???", (FormatChunk, "string[%u]" % size))
+        self.read("nb_char8bit", "???", (FormatChunk, "uint8"))
+        self.read("align", "Next factor of four to height?", (FormatChunk, "uint16"))
 
         # Read images
         self.read("nb_char", "Number of characters", (FormatChunk, "uint16"))
@@ -194,6 +175,8 @@
             
             size = pos + size + 1 - stream.tell()
             if self.tag in Resource.handler:
+                self.read("palette", "Palette", (Palette, 81))
+                size = size-81*3
                 #sub = stream.createLimited(size=size)
                 sub = stream.createSub(size=size)
                 self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-02 00:48:42 UTC (rev 382)
+++ haypo/hachoir/trunk/reverse.py	2006-01-02 03:18:22 UTC (rev 383)
@@ -1,10 +1,58 @@
 from stream.file import FileStream
 from plugins.worms2 import Worms2_Dir_File
 from plugins.gzip import GzipFile
-from format import getFormatSize
+from format import getFormatSize, getFormatEndian
 from bits import countBits, long2bin, str2hex
+from error import error, warning
+from chunk import FormatChunk
+from default import EmptyFilter
+import config
 import sys
 
+class Pattern:
+    def check(self, stream):
+        return False
+    
+class FirstPattern(Pattern):
+    def __init__(self, header_size, chunk_size_format, chunk_size_delta):
+        self.header_size = header_size
+        self.chunk_size_format = chunk_size_format
+        self.chunk_size_delta = chunk_size_delta
+
+    def check(self, stream, min_ok=2):
+        count, done = self._createFilter(stream, True)
+        return done or min_ok <= count
+
+    def testFilter(self, stream):
+        return self._createFilter(stream, False)
+        
+    def _createFilter(self, stream, check):
+        count = 0
+        done = False
+        try:
+            stream.seek(0)
+            filter = EmptyFilter(stream, None)
+            if 0 < self.header_size:
+                filter.read("header", "Header", (FormatChunk, "string[%u]" % self.header_size))
+            last_ok = stream.tell()                
+            while not stream.eof():
+                last_ok = stream.tell()                
+                size = filter.doRead("chunk_size[]", "Chunk size", (FormatChunk, self.chunk_size_format)).value
+                size += self.chunk_size_delta
+                filter.read("chunk_data[]", "Chunk data", (FormatChunk, "string[%u]" % size))
+                count = count + 1
+            last_ok = stream.tell()                
+            done = True
+        except Exception, msg:
+            if config.debug:
+                warning("Error when testing a pattern: %s" % msg)
+        if check:
+            return (count, done) 
+        else:
+            stream.seek(last_ok)
+            filter.addPadding()
+            return filter
+        
 class IntValues:
     def __init__(self, data=None):
         self.items = None
@@ -110,15 +158,25 @@
                 item = self.items[index]
                 if item == new:
                     return
-                if new < item:
+                if isinstance(item, int) and new < item:
                     self.items.insert(index-1, new)
                     return
- #               if isinstance(item, tuple):
-#                    ...
+                if isinstance(item, tuple) and (new-item[1])==1:
+                    self.items[index] = (item[0], new)
+                    return
+
+            # Can create an interval?
+            item = self.items[-1]
+            if isinstance(item, int) and (new-item) == 1:
+                self.items[-1] = (item, new)
+                return
+
             if isinstance(new, list):
+                # Extend current vector
                 for item in new:
                     self.add(item)
             else:
+                # Just append value to vector
                 self.items.append(new)
         elif self.items != None:        
             if isinstance(self.items, int) and isinstance(new, int):
@@ -137,15 +195,19 @@
         first = set( self.values() ) 
         second = set( second.values() )
         result = first.intersection(second)
-        result = list(result)
+        if 0 < len(result):
+            result = list(result)
+        else:
+            result = None
         return IntValues(result)
 
 class Field:
-    def __init__(self, id):
+    def __init__(self, id, type):
         self.id = id    
         self.values = {}
         self.values_list = {}
         self.streams = {}
+        self.type = type
 
     def getStreamsByValue(self, value):
         return self.streams.get(hash(value), [])
@@ -163,8 +225,7 @@
         return self.values_list.values()
 
     def addValue(self, stream, value):
-        if not isinstance(value, IntValues):
-            value = IntValues(value)
+        assert type(value) == self.type
         self.values[stream] = value
         if hash(value) not in self.streams:
             self.streams[hash(value)] = []
@@ -176,32 +237,7 @@
     def __init__(self):
         self.fields = {}
         self.streams = []
-        
-        # Feeded after analyse
-        self.started = False
-        self.min_size, self.max_size = None, None
-        self.data_range = None
-        self.cst_list = None
-        self.data_list = None
 
-    def _initAnalyse(self, data_range):
-        if self.started:
-            assert data_range == self.data_range
-            return
-        assert 0 < len(self.streams)
-        self.started = True        
-        self.data_range = data_range
-
-        # Find mimimum/maximum stream size
-        self.min_size = self.max_size = self.streams[0].getSize()
-        for stream in self.streams[1:]:
-            size = stream.getSize()
-            if size < self.min_size:
-                self.min_size = size
-            if size > self.max_size:
-                self.max_size = size            
-        assert 1 <= self.min_size                
-
     def _findConstant(self, streams, data_range):
         assert 2 <= len(streams)
 
@@ -267,33 +303,17 @@
             data = " ".join(data)
             print "Data %u: %s" % (addr, data)
 
-    def OLDfindField(self, id, data_range):
-        self.cst_list, self.data_list = self._findConstant(self.streams, data_range)
-        field = self.fields[id]
-        values = field.getValues()
-        addr = IntValues()
-        possible_addr = self.data_list
-        first = True
-        for value in values:
-            streams = field.getStreamsByValue(value)
-            if 1<len(streams):
-                cst_list, data_list = self._findConstant(streams, self.data_list)
-            else:
-                cst_list = self.data_list
-            if first:
-                addr.add(cst_list)
-                first = False
-            else:
-                addr = addr.intersection(cst_list)
-            if addr.isEmpty():
-                break            
-        return (addr, possible_addr)
-
-    def findInteger(self, stream, value, range, size_bits):
+    def findInteger(self, stream, value, range, size_bits, endian=None):
         assert size_bits <= 32
-        formats = ["<uint32", ">uint32"]
+        if endian == None:
+            formats = ["<uint32", ">uint32"]
+        else:            
+            formats = [endian+"uint32"]
         if size_bits <= 16:
-            formats.extend(["<uint16", ">uint16"])
+            if endian == None:
+                formats.extend(["<uint16", ">uint16"])
+            else:
+                formats.append(endian+"uint16")
         if size_bits <= 8:
             formats.append("uint8")
         ok = IntValues()
@@ -306,9 +326,51 @@
                     read = int( stream.getFormat(format, False) )
                     if value.hasValue(read):
                         ok.add(addr)
-                        break
-        return ok                    
+        return ok       
 
+    def guessPattern(self, stream, min_ok):
+        """
+        Try differents parameters to obtain pattern like:
+           (header, size1, data1, size2, data2, ...)
+        
+        Notes:
+        - header is optionnal
+        - sizes may be shifted (ex: size+4) to get data size
+        """
+        filter = self.guessPatternFormat(stream, "<uint32", min_ok)
+        if filter == None:
+            filter = self.guessPatternFormat(stream, ">uint32", min_ok)
+        if filter == None:
+            filter = self.guessPatternFormat(stream, "<uint16", min_ok)
+        if filter == None:
+            filter = self.guessPatternFormat(stream, ">uint16", min_ok)
+        return filter            
+
+    def guessPatternFormat(self, stream, chunk_size_format, min_ok):
+        """
+        See guessPattern().
+        """
+        # Config
+        max_header_size = 64 
+        chunk_size_deltas = IntValues((-20,20))
+
+        # Find possible header sizes
+        range = IntValues((0, max_header_size))
+        size_bits = getFormatSize(chunk_size_format)*8
+        value = IntValues((0, stream.getSize() - size_bits/8))
+        endian = getFormatEndian(chunk_size_format)
+        header_sizes = self.findInteger(stream, value, range, size_bits, endian)
+        print "Possible header sizes: %s" % header_sizes
+
+        # Find chunk size delta
+        for header_size in header_sizes.values():
+            for chunk_size_delta in chunk_size_deltas.values(): 
+                # Try a pattern ...
+                pattern = FirstPattern(header_size, chunk_size_format, chunk_size_delta)
+                if pattern.check(stream, min_ok):
+                    print "Found filter -> header size=%s, chunk size delta=%s (format \"%s\")" % (header_size, chunk_size_delta, chunk_size_format)
+                    return pattern.testFilter(stream)
+
     def findField(self, id, data_range):
         field = self.fields[id]
         ok = data_range
@@ -320,130 +382,15 @@
             value = field.getValueByStream(stream)
             addr = self.findInteger(stream, value, data_range, size_bits)
             ok = ok.intersection(addr)
+            if ok.isEmpty():
+                break
             i += 1
         return ok            
 
     def addSource(self, stream, fields={}):
-        assert not self.started
         self.streams.append(stream)
         for id in fields:
+            value = fields[id]
             if id not in self.fields:
-                self.fields[id] = Field(id)
-            self.fields[id].addValue(stream, fields[id])
-
-def loadGZ(filename):
-    f = open(filename, 'r')
-    input = FileStream(f, filename)
-    return GzipFile(input, None) 
-
-def gzip_size():
-    reverse = Reverse()
-    for filename in sys.argv[1:]:
-        g = loadGZ(filename)
-        stream = g.getStream()
-        sub = stream.createSub(start=stream.getSize()-50)
-        size = int(g["size"])
-        size = IntValues( (size-30, size+30) )
-        reverse.addSource(sub, {"size": size})
-    header = IntValues( (0,49) )
-#    reverse.displayConstant(header)
-    addr = reverse.findField("size", header)
-    print "Address of field n: %s" % addr 
-
-def int16Bits(value):
-    v = []
-    for i in range(0,16):
-        mask = 1 << i
-        if (value & mask) == mask:
-            v.append(1)
-        else:
-            v.append(0)  
-    return v
-
-def guessBits(d):    
-    for n in d:
-        val = d[n]
-        data = val[0]
-        print "====== n=%u, data set=%u items" % (n, len(val))
-        if 1<len(val):
-            for i in range(0, 11):
-                cst = True
-                for bits in val[1:]:
-                    if bits[i] != data[i]:
-                        cst = False
-                        break
-                if cst:
-                    print "bit %u: const=%s" % (i, data[i])
-        else:
-            print "(not enough data)"
-   
-def worms2_sprite(res):    
-    #sprite_range = IntValues( (0,73) )
-    #sprite_range = IntValues( (0,100) )
-    sprite_range = IntValues( (0,100) )
-    d = {}
-    for i in sprite_range.values():
-        sprite = res["res[%u]" % i]["data"]
-        flags = sprite["flags_b"]
-        w,h = sprite["width[0]"],sprite["height[0]"]
-        if w < 10 or 1000<w or h<10 or 1000<h:
-            print "res[%u] errone" % i
-        else:
-            n = sprite.n
-            stream = sprite.getStream()
-            stream.seek(81*3+1) ; m = stream.getFormat("uint8")-1
-            #stream.seek(258) ;  data = stream.getN(14)
-            stream.seek(81*3) ;  data = stream.getN(272-243)
-            if n not in d:
-                d[n] = []
-#            d[n].append( (sprite["type"],int16Bits(flags),sprite["width[0]"],sprite["height[0]"],i) )
-            d[n].append( (i, m, data) )
-#    guessBits(d)        
-#    return
-        
-    for n in d:
-        print "======== %s =========" % n
-        for data in d[n]:
-            print "% 3s] n=% 2s m=% 2s %s" % (data[0], n, data[1], str2hex(data[2]))
-#            xxx = "".join(map(str,bits[1]))
-#            print "%s] %s (%ux%u), id=res[%u]" % (bits[0], xxx, bits[2], bits[3], bits[4])
-
-def worms2_n(res):
-    reverse = Reverse()
-    sprite_range = IntValues( (0,72) )
-    for i in sprite_range.values():
-        sprite = res["res[%u]" % i]["data"]
-        #stream = sprite.getStream().createSub(start=sprite.getAddr(), size=sprite.getSize())
-        reverse.addSource(stream, {"n": sprite.n})
-    header = IntValues( (243, 258) )
-    print "Find field in range %s" % header
-#    reverse.displayData(header)        
-#     reverse.displayConstant(header)
-    addr = reverse.findField("n", header)
-    print "Address of field n: %s\n(or in %s)" % (addr[0], addr[1])
-
-def worms2_font(res):
-    reverse = Reverse()
-    sprite_range = IntValues( (713,739) )
-    for i in sprite_range.values():
-        font = res["res[%u]" % i]["data"]
-        reverse.addSource(font.getStream(), {"nb": font["nb_char"]})
-    header = IntValues( (0, 600) )
-    print "Find field in range %s" % header
-#    reverse.displayData(header)        
-#     reverse.displayConstant(header)
-    addr = reverse.findField("nb", header)
-    print "Address of field n: %s" % (addr)
-#    print "Address of field n: %s\n(or in %s)" % (addr[0], addr[1])
-
-def worms2():
-    f = open('/home/haypo/worms/Gfx.dir', 'r')
-    input = FileStream(f, None)
-    res = Worms2_Dir_File(input, None)["resources"]
-#    worms2_sprite(res)
-#    worms2_n(res)
-    worms2_font(res)
- 
-if __name__=="__main__":
-    worms2()
-#    gzip_size()
+                self.fields[id] = Field(id, type(value))
+            self.fields[id].addValue(stream, value)



From haypo at berlios.de  Mon Jan  2 14:41:22 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 2 Jan 2006 14:41:22 +0100
Subject: [Happyboom-svn] r384 - haypo/hachoir/trunk/plugins
Message-ID: <200601021341.k02DfM14022001@sheep.berlios.de>

Author: haypo
Date: 2006-01-02 14:41:18 +0100 (Mon, 02 Jan 2006)
New Revision: 384

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Worms2: Read number of used color, bpp and right color palette.


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 03:18:22 UTC (rev 383)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 13:41:18 UTC (rev 384)
@@ -23,7 +23,8 @@
         self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
         self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
         size = (self.width-self.x) * (self.height-self.y)
-        self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
+#        self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
+        self.addPadding()
 
     def getStaticSize(stream, args):
         oldpos = stream.tell()
@@ -41,7 +42,6 @@
 class Image(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "image", "Image", stream, parent, "<")
-        self.read("padding", "Padding", (FormatChunk, "uint8"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
         size = self["width"] * self["height"]
@@ -85,9 +85,6 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
         name = parent.name
-        self.read("header116", "Header 116", (FormatChunk, "uint8"))
-        assert self["header116"] == 116 
-
         if False:
             self.read("n", "Type?", (FormatChunk, "uint8"))
             self.read("zero[]", "???", (FormatChunk, "string[9]"))
@@ -125,12 +122,10 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "font", "Font", stream, parent, "<")
 
-        self.read("header116", "Header 116", (FormatChunk, "uint8"))
-
         #--- Ugly header ---
         size = 33
         self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
-        size = 256 - stream.tell()
+        size = 255 - stream.tell()
         self.read("xxx", "???", (FormatChunk, "string[%u]" % size))
         self.read("nb_char8bit", "???", (FormatChunk, "uint8"))
         self.read("align", "Next factor of four to height?", (FormatChunk, "uint16"))
@@ -174,10 +169,12 @@
             self.name = self.doRead("name", "Name", (StringChunk, "C")).value
             
             size = pos + size + 1 - stream.tell()
+            self.read("bpp", "Bits / pixel", (FormatChunk, "uint8"))
+            self.read("xxx", "???", (FormatChunk, "uint8"))
+            nb_color = self.doRead("nb_color", "Number of colors", (FormatChunk, "uint16")).value
+            self.read("palette", "Palette", (Palette, nb_color))
+            size -= (4 + nb_color*3)
             if self.tag in Resource.handler:
-                self.read("palette", "Palette", (Palette, 81))
-                size = size-81*3
-                #sub = stream.createLimited(size=size)
                 sub = stream.createSub(size=size)
                 self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})
             else:



From haypo at berlios.de  Mon Jan  2 15:21:09 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 2 Jan 2006 15:21:09 +0100
Subject: [Happyboom-svn] r385 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601021421.k02EL9Xj021325@sheep.berlios.de>

Author: haypo
Date: 2006-01-02 15:21:08 +0100 (Mon, 02 Jan 2006)
New Revision: 385

Modified:
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/plugins/worms2.py
Log:
- Clean up Worms2 parser
- Load script after loading input file


Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2006-01-02 13:41:18 UTC (rev 384)
+++ haypo/hachoir/trunk/hachoir_class.py	2006-01-02 14:21:08 UTC (rev 385)
@@ -21,6 +21,9 @@
         self.script = None
         self.load_ui = True
 
+    def getMainFilter(self):
+        return self._main_filter
+
     def getFilter(self):
         return self._filter
 
@@ -135,10 +138,10 @@
                 % (filename, msg))
 
     def run(self, filename):
+        if filename != None:
+            self.loadFile(filename)
         if self.script:
             self.loadScript(self.script)
-        elif filename != None:
-            self.loadFile(filename)
         if self.load_ui:
             print "Run user interface ..."
             self.ui.run()      

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 13:41:18 UTC (rev 384)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 14:21:08 UTC (rev 385)
@@ -8,13 +8,10 @@
 from plugin import registerPlugin 
 from filter import OnDemandFilter
 from plugin import registerPlugin
-from tools import humanFilesize
 from chunk import FormatChunk, StringChunk, EnumChunk, BitsChunk, BitsStruct
 from generic.image import Palette
+from text_handler import humanFilesize
 
-# Only for debug purpose
-from text_handler import binary
-
 class ImageData(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "image_data", "Image data (uncompressed)", stream, parent, "<")
@@ -23,8 +20,7 @@
         self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
         self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
         size = (self.width-self.x) * (self.height-self.y)
-#        self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
-        self.addPadding()
+        self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
 
     def getStaticSize(stream, args):
         oldpos = stream.tell()
@@ -85,20 +81,10 @@
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
         name = parent.name
-        if False:
-            self.read("n", "Type?", (FormatChunk, "uint8"))
-            self.read("zero[]", "???", (FormatChunk, "string[9]"))
-            self.read("flags_a", "???", (FormatChunk, "uint16"), {"post": binary})
-            self.read("zero[]", "???", (FormatChunk, "uint16"))
-            flags_b = self.doRead("flags_b", "???", (FormatChunk, "uint16"), {"post": binary}).value
-            for i in range(0, self["n"]-1):
-                self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
-        else:
-            self.read("n", "Type?", (FormatChunk, "uint16"))
-            self.read("zero", "Zero?", (FormatChunk, "uint16"))
-            for i in range(0, self["n"]):
-                self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
-            
+        self.read("n", "Type?", (FormatChunk, "uint16"))
+        self.read("zero", "Zero?", (FormatChunk, "uint16"))
+        for i in range(0, self["n"]):
+            self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
         self.read("x", "Offset X", (FormatChunk, "uint16"))
         self.read("y", "Offset Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
@@ -164,22 +150,31 @@
         pos = stream.tell()
         self.tag = self.doRead("tag", "Type", (EnumChunk, "string[3]", Resource.name)).value
         self.read("tag_end", "Type end", (FormatChunk, "string[1]"))
-        size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
         if self.tag != "DIR":
+            size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
+            # Read resource name
             self.name = self.doRead("name", "Name", (StringChunk, "C")).value
+            size += (pos - stream.tell() + 1)
             
-            size = pos + size + 1 - stream.tell()
+            # Read informations about colors
             self.read("bpp", "Bits / pixel", (FormatChunk, "uint8"))
             self.read("xxx", "???", (FormatChunk, "uint8"))
             nb_color = self.doRead("nb_color", "Number of colors", (FormatChunk, "uint16")).value
             self.read("palette", "Palette", (Palette, nb_color))
-            size -= (4 + nb_color*3)
-            if self.tag in Resource.handler:
+            size -= (4 + nb_color*3 + 1)
+            
+            if self.tag in Resource.handler:    
+                # Data content handler
                 sub = stream.createSub(size=size)
                 self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})
             else:
                 self.read("data", "Data", (FormatChunk, "string[%u]" % size))
+
+            # Separator
+            self.read("separator", "Separator (0x1A = 26)", (FormatChunk, "uint8"))
+            assert self["separator"] == 0x1A
         else:
+            self.read("filesize", "File size", (FormatChunk, "uint32"), {"post": humanFilesize})
             self.name = "(directory)"
             end = self.doRead("last_pos", "Last position", (FormatChunk, "uint32")).value
             while stream.tell() < end:
@@ -201,9 +196,7 @@
         if self["tag"] != "DIR":
             chunk.description = "[%s] %s" % (self.name, self["data"].getDescription())
         else:
-            tag = self.getChunk("tag").getDisplayData()
-            size = humanFilesize(self["size"])
-            chunk.description = tag+": %s (size=%s)" % (self.name, size)
+            chunk.description = "Directory" 
 
 class Worms2_Dir_File(OnDemandFilter):
     def __init__(self, stream, parent):



From haypo at berlios.de  Tue Jan  3 00:09:46 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 3 Jan 2006 00:09:46 +0100
Subject: [Happyboom-svn] r386 - in haypo/hachoir/trunk: . plugins stream
Message-ID: <200601022309.k02N9kq0031699@sheep.berlios.de>

Author: haypo
Date: 2006-01-03 00:09:45 +0100 (Tue, 03 Jan 2006)
New Revision: 386

Modified:
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/plugins/exif.py
   haypo/hachoir/trunk/plugins/jpeg.py
   haypo/hachoir/trunk/plugins/zip.py
   haypo/hachoir/trunk/reverse.py
   haypo/hachoir/trunk/stream/stream.py
Log:
- LimitedStream & SubStream: seek() may now raise exception (instead of
  use assertion)
- Zip plugin: add post-process functions
- Reverse: add optionnal arguments size_bits and endian for findField
- Exif: fix JPEG SOI recognition


Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2006-01-02 14:21:08 UTC (rev 385)
+++ haypo/hachoir/trunk/hachoir.py	2006-01-02 23:09:45 UTC (rev 386)
@@ -21,7 +21,7 @@
     print "Usage: %s [options] file" % (sys.argv[0])
     print ""
     print "Options:"
-    print "\t--script file.py  : Load python script"
+    print "\t--script file.py  : Load python script after loading file (if any specified)"
     print "\t--no-ui           : Don't load user interface"
     print "\t--use-profiler    : Use profiler"
     print "\t--version         : Show the program version"

Modified: haypo/hachoir/trunk/plugins/exif.py
===================================================================
--- haypo/hachoir/trunk/plugins/exif.py	2006-01-02 14:21:08 UTC (rev 385)
+++ haypo/hachoir/trunk/plugins/exif.py	2006-01-02 23:09:45 UTC (rev 386)
@@ -36,6 +36,9 @@
         10: "SRATIONTAL (two SLONGs)"
     }
 
+    OFFSET_JPEG_SOI = 0x0201
+    EXIF_IFD_POINTER = 0x8769
+
     tag_name = {    
         0x0100: "Image width",
         0x0101: "Image height",
@@ -167,8 +170,10 @@
             if next in (0, 0xF0000000):
                 break
             entry = self.doRead("entry[]", "Entry", (ExifEntry, self._endian))
-            if entry["tag"] in (0x8769, 0x0201):
+            if entry["tag"] in (ExifEntry.EXIF_IFD_POINTER, ExifEntry.OFFSET_JPEG_SOI):
                 next_chunk_offset = entry["value"]+offset_diff
+                if entry["tag"] == ExifEntry.OFFSET_JPEG_SOI:
+                   parent.jpeg_soi = next_chunk_offset
                 break
             if 4 < entry.size:
                 entries.append(entry)
@@ -180,11 +185,17 @@
             if 0 < padding:
                 self.read("padding[]", "Padding (?)", (FormatChunk, "string[%u]" % padding))
             assert offset == stream.tell()
-            self.read("entry_value[]", "Value of %s" % entry.getId(), (FormatChunk, entry.format))
+            id = self.read("entry_value[]", "Value of %s" % entry.getId(), (FormatChunk, entry.format))
         if next_chunk_offset != None:
             padding = next_chunk_offset - stream.tell()
             if 0 < padding:
                 self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % padding))
+        size = self.getSize()
+        if (size % 4) != 0:
+            if parent.jpeg_soi != None and parent.jpeg_soi <= stream.tell():
+                return
+            padding = 4 - (size % 4)
+            self.read("padding[]", "Padding to be aligned to 4", (FormatChunk, "string[%u]" % padding))
 
     def updateParent(self, chunk):
         chunk.description = "Exif IFD (id %s)" % self["id"]
@@ -194,6 +205,7 @@
         OnDemandFilter.__init__(self, "exif", "Exif", stream, parent, None)
 
         # Headers
+        self.jpeg_soi = None
         self.read("header", "Header (Exif\\0\\0)", (FormatChunk, "string[6]"))
         assert self["header"] == "Exif\0\0"
         self.read("byte_order", "Byte order", (FormatChunk, "string[2]"))
@@ -215,8 +227,6 @@
                 break
             elif tag == 0xFFFF:
                 break
-            id = self.read("ifd[]", "IFD", (ExifIFD, self._endian, 6))
-        size = stream.getSize() - stream.tell()
-        if 0 < size:
-            self.read("end", "End", (FormatChunk, "string[%u]" % size))
+            self.read("ifd[]", "IFD", (ExifIFD, self._endian, 6))
+        self.addPadding()            
         assert self.getSize() == stream.getSize()

Modified: haypo/hachoir/trunk/plugins/jpeg.py
===================================================================
--- haypo/hachoir/trunk/plugins/jpeg.py	2006-01-02 14:21:08 UTC (rev 385)
+++ haypo/hachoir/trunk/plugins/jpeg.py	2006-01-02 23:09:45 UTC (rev 386)
@@ -15,7 +15,7 @@
         self.read("jfif", "JFIF string", (FormatChunk, "string[5]"))
         self.read("ver_maj", "Major version", (FormatChunk, "uint8"))
         self.read("ver_min", "Minor version", (FormatChunk, "uint8"))
-        self.read("units", "Units (=0)", (FormatChunk, "uint8"))
+        self.read("units", "Units", (FormatChunk, "uint8"))
         if self["units"] == 0:
             self.read("aspect_x", "Aspect ratio (X)", (FormatChunk, "uint16"))
             self.read("aspect_y", "Aspect ratio (Y)", (FormatChunk, "uint16"))

Modified: haypo/hachoir/trunk/plugins/zip.py
===================================================================
--- haypo/hachoir/trunk/plugins/zip.py	2006-01-02 14:21:08 UTC (rev 385)
+++ haypo/hachoir/trunk/plugins/zip.py	2006-01-02 23:09:45 UTC (rev 386)
@@ -12,6 +12,8 @@
 from error import error
 from text_handler import humanFilesize, hexadecimal, msdosDatetime
 
+# TODO: Merge ZipCentralDirectory and FileEntry (looks very similar)
+
 class ZipCentralDirectory(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "zip_central_dir", "ZIP central directory", stream, parent, "<")
@@ -77,11 +79,9 @@
             (6, "unused", "Unused bits"),
             (4, "pkware", "Reserved by PKWARE"))
         flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
-#        self.read("flags", "Flags", (FormatChunk, "uint16"))
         self.read("compression", "Compression method", (EnumChunk, "uint16", FileEntry.compression_name))
-        self.read("last_mod_time", "Last modification time", (FormatChunk, "uint16"))
-        self.read("last_mod_date", "Last modification date", (FormatChunk, "uint16"))
-        self.read("crc32", "Checksum (CRC32)", (FormatChunk, "uint32"))
+        self.read("last_mod", "Last modification time", (FormatChunk, "uint32"), {"post": msdosDatetime})
+        self.read("crc32", "Checksum (CRC32)", (FormatChunk, "uint32"), {"post": hexadecimal})
         self.read("compressed_size", "Compressed size (bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
         self.read("uncompressed_size", "Uncompressed size (bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
         self.read("filename_length", "Filename length", (FormatChunk, "uint16"))
@@ -90,9 +90,9 @@
         self.read("extra", "Extra", (FormatChunk, "string[%u]" % self["extra_length"]))
         self.read("compressed_data", "Compressed data", (FormatChunk, "string[%u]" % self["compressed_size"]))
         if flags["use_data_desc"]:
-            self.read("file_crc32", "Checksum (CRC32)", (FormatChunk, "uint32"))
-            self.read("file_compressed_size", "Compressed size (bytes)", (FormatChunk, "uint32"))
-            self.read("file_uncompressed_size", "Uncompressed size (bytes)", (FormatChunk, "uint32"))
+            self.read("file_crc32", "Checksum (CRC32)", (FormatChunk, "uint32"), {"post": hexadecimal})
+            self.read("file_compressed_size", "Compressed size (bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
+            self.read("file_uncompressed_size", "Uncompressed size (bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
 
     def updateParent(self, chunk):
         size = self.getChunk("compressed_size").display

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-02 14:21:08 UTC (rev 385)
+++ haypo/hachoir/trunk/reverse.py	2006-01-02 23:09:45 UTC (rev 386)
@@ -371,16 +371,17 @@
                     print "Found filter -> header size=%s, chunk size delta=%s (format \"%s\")" % (header_size, chunk_size_delta, chunk_size_format)
                     return pattern.testFilter(stream)
 
-    def findField(self, id, data_range):
+    def findField(self, id, data_range, size_bits=None, endian=None):
         field = self.fields[id]
         ok = data_range
-        size_bits = field.getBitSize()
+        if size_bits == None:
+            size_bits = field.getBitSize()
         print "Find integer field \"%s\" (at least %u bits long) ..." % (id, size_bits)
         i = 1
         for stream in self.streams:
             print "  find in stream %u/%u ..." % (i, len(self.streams))
             value = field.getValueByStream(stream)
-            addr = self.findInteger(stream, value, data_range, size_bits)
+            addr = self.findInteger(stream, value, data_range, size_bits, endian)
             ok = ok.intersection(addr)
             if ok.isEmpty():
                 break
@@ -391,6 +392,8 @@
         self.streams.append(stream)
         for id in fields:
             value = fields[id]
+            if isinstance(value, int) or isinstance(value, tuple):
+                value = IntValues(value)
             if id not in self.fields:
                 self.fields[id] = Field(id, type(value))
             self.fields[id].addValue(stream, value)

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2006-01-02 14:21:08 UTC (rev 385)
+++ haypo/hachoir/trunk/stream/stream.py	2006-01-02 23:09:45 UTC (rev 386)
@@ -185,13 +185,15 @@
         return self._seed
 
     def seek(self, pos, where=0):
+        oldpos = pos
         if where == 2:
             pos = self.getLastPos() - pos
         elif where == 0:
             pos = pos
         elif where == 1:
             pos = self._seed + pos
-        assert self._start <= pos and pos <= self._end
+        if not(self._start <= pos and pos <= self._end):
+            raise StreamError("Error in a limited stream: can't seek to (%i,%u)." % (oldpos, where))
         self._seed = pos
         
     def getSize(self):
@@ -216,13 +218,15 @@
         return pos
                
     def seek(self, pos, where=0):
+        oldpos = pos
         if where == 2:
             pos = self.getLastPos() - pos
         elif where == 0:
             pos = self._start + pos
         elif where == 1:
             pos = self._seed + pos
-        assert self._start <= pos and pos <= self._end
+        if not(self._start <= pos and pos <= self._end):
+            raise StreamError("Error in a sub-stream: can't seek to (%i,%u)." % (oldpos, where))
         self._seed = pos
 
     def tell(self):



From haypo at berlios.de  Tue Jan  3 00:42:49 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 3 Jan 2006 00:42:49 +0100
Subject: [Happyboom-svn] r387 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601022342.k02NgnOR017718@sheep.berlios.de>

Author: haypo
Date: 2006-01-03 00:42:46 +0100 (Tue, 03 Jan 2006)
New Revision: 387

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/plugins/exif.py
Log:
- Revert hack in Exif (doesn't work on most JPEG)
- Filter._createInstance() convert chunk into raw if create a filter fails


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-02 23:09:45 UTC (rev 386)
+++ haypo/hachoir/trunk/filter.py	2006-01-02 23:42:46 UTC (rev 387)
@@ -43,6 +43,7 @@
     def getStream(self): return self._stream
     def updateChunkId(self, old_id, new_id): pass
     def updateChunkDescription(self, id, desc): pass
+    def updateChunkDisplay(self, id): pass
     def __len__(self): return len(self._chunks_dict)
 
     def getPath(self):
@@ -138,18 +139,22 @@
             self._chunks_cache[new_id] = cache
 
         # Update display
-        info = self.displayChunkInfo(new_id)
+        self.updateChunkDisplay(new_id)
+
+    def updateChunkDisplay(self, id):
+        if ui.ui == None:
+            return
+        pos = self._chunks.index(id)
+        assert pos != -1
+        info = self.displayChunkInfo(id)
         ui.window.update_table(self, pos, *info)
 
     def updateChunkDescription(self, id, desc):
         pos = self._chunks.index(id)
         assert pos != -1
         self._chunks_dict[id][1] = desc
+        self.updateChunkDisplay(id)
 
-        if ui.ui != None:
-            info = self.displayChunkInfo(id)
-            ui.window.update_table(self, pos, *info)
-
     def purgeCache(self):
         if len(self._chunks_cache) != 0 and config.verbose:
             print "Purge cache: destroy %s chunks" % len(self._chunks_cache)
@@ -209,13 +214,6 @@
                 id = chunk.id
                 self._chunks_cache[id] = chunk
             chunk_info = [id, description, addr, size, instance_info, post, optionnal]
-#            else:       
-#                assert chunk_class == StringChunk
-#                strip = optionnal.get("strip", None)
-#                chunk = chunk_class (id, description, self._stream, info[1:], self, strip=strip)
-#                chunk_info = [id, description, addr, size, \
-#                        (info[0], id, description, self._stream, info[1:], self,), post, optionnal]
-#                self._chunks_cache[id] = chunk
             self._chunks_dict[id] = chunk_info
             self._chunks.append(id)
             self._size = self._size + size
@@ -256,30 +254,49 @@
     def getSize(self): return self._size
 
     def _createInstance(self, id):
+        description = self._chunks_dict[id][1]
         addr = self._chunks_dict[id][2]
+        size = self._chunks_dict[id][3]
         desc = self._chunks_dict[id][4]
         post = self._chunks_dict[id][5]
         chunks_kw = self._chunks_dict[id][6]
         oldpos = self._stream.tell()
-        self._stream.seek(addr)
         if config.verbose:
             print "%s: Instanciate %s (of type %s)" % (self.getPath(), id, desc[0].__name__)
         if not issubclass(desc[0], BasicFilter):
+            # Chunk
             chunk_class = desc[0]
             chunk_args = desc[1:]
+            self._stream.seek(addr)
             chunk = chunk_class(*chunk_args, **chunks_kw)
             if post != None:
                 chunk.display = post(chunk)
         else:
+            # Filter
             filter_stream = desc[1]
             if filter_stream != self._stream:
                 filter_stream.seek(desc[2])
-            filter = desc[0] (filter_stream, self, *desc[3])
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            if filter.getDescription() != desc[1]:
-                self.updateChunkDescription(id, filter.getDescription())
-            filter.updateParent(chunk)
+            else:
+                self._stream.seek(addr)
+            try:
+                filter = desc[0] (filter_stream, self, *desc[3])
+                filter.setId(id)
+                chunk = FilterChunk(id, filter, self, addr)
+                if filter.getDescription() != desc[1]:
+                    self.updateChunkDescription(id, filter.getDescription())
+                filter.updateParent(chunk)
+            except Exception, msg:
+                error("Error when loading filter %s: %s" % (id, msg))
+                if filter_stream != self._stream:
+                    filter_stream.seek(desc[2])
+                else:
+                    self._stream.seek(addr)
+                assert isinstance(size, int)
+                self._chunks_dict[id][4] = (FormatChunk, id, description, filter_stream, "string[%u]" % size, self)
+                self._chunks_dict[id][5] = None
+                self._chunks_dict[id][6] = {}
+                self.updateChunkDisplay(id)
+                return self._createInstance(id)
         self._stream.seek(oldpos)
         return chunk
 

Modified: haypo/hachoir/trunk/plugins/exif.py
===================================================================
--- haypo/hachoir/trunk/plugins/exif.py	2006-01-02 23:09:45 UTC (rev 386)
+++ haypo/hachoir/trunk/plugins/exif.py	2006-01-02 23:42:46 UTC (rev 387)
@@ -190,12 +190,13 @@
             padding = next_chunk_offset - stream.tell()
             if 0 < padding:
                 self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % padding))
-        size = self.getSize()
-        if (size % 4) != 0:
-            if parent.jpeg_soi != None and parent.jpeg_soi <= stream.tell():
-                return
-            padding = 4 - (size % 4)
-            self.read("padding[]", "Padding to be aligned to 4", (FormatChunk, "string[%u]" % padding))
+        # TODO: When padding is needed !?                
+#        size = self.getSize()
+#        if (size % 4) != 0:
+#            if parent.jpeg_soi != None and parent.jpeg_soi <= stream.tell():
+#                return
+#            padding = 4 - (size % 4)
+#            self.read("padding[]", "Padding to be aligned to 4", (FormatChunk, "string[%u]" % padding))
 
     def updateParent(self, chunk):
         chunk.description = "Exif IFD (id %s)" % self["id"]



From haypo at berlios.de  Tue Jan  3 05:02:27 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 3 Jan 2006 05:02:27 +0100
Subject: [Happyboom-svn] r388 - in haypo/hachoir/trunk: . plugins stream
Message-ID: <200601030402.k0342RtY024422@sheep.berlios.de>

Author: haypo
Date: 2006-01-03 05:02:25 +0100 (Tue, 03 Jan 2006)
New Revision: 388

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/plugins/ico.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/reverse.py
   haypo/hachoir/trunk/stream/stream.py
   haypo/hachoir/trunk/tools.py
Log:
- Worms2 plugin is able to read "file system" and the strange XXX structure
- tools.py: create alignValue function
- some bugfix around stream.getSize() VS stream.getLastPos()
- fix in LimitedStream: don't clone parent anymore
- fix SubStream and LimitedStream search() method (seek in parent stream)
- remove Chunk.clone() and Stream.clone() methods
- reverse.py: create entropy() function


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-02 23:42:46 UTC (rev 387)
+++ haypo/hachoir/trunk/filter.py	2006-01-03 04:02:25 UTC (rev 388)
@@ -99,7 +99,7 @@
     endian = property(_getEndian)
 
     def addPadding(self):
-        size = self._stream.getLastPos() - self._stream.tell()
+        size = self._stream.getRemainSize()
         if 0 < size:
             self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
 

Modified: haypo/hachoir/trunk/plugins/ico.py
===================================================================
--- haypo/hachoir/trunk/plugins/ico.py	2006-01-02 23:42:46 UTC (rev 387)
+++ haypo/hachoir/trunk/plugins/ico.py	2006-01-03 04:02:25 UTC (rev 388)
@@ -26,11 +26,8 @@
         # Read pixels
         size = header["width"] * header["height"] * header["bpp"] / 8
         self.read("pixels", "Image pixels", (FormatChunk, "string[%u]" % size))
+        self.addPadding()
 
-        padding = stream.getLastPos() - stream.tell() + 1
-        if 0 < padding:
-            self.read("padding", "(padding)", (FormatChunk, "string[%u]" % padding))
-
 class IconHeader(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "icon", "Icon header", stream, parent, "<")

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-02 23:42:46 UTC (rev 387)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-03 04:02:25 UTC (rev 388)
@@ -11,6 +11,7 @@
 from chunk import FormatChunk, StringChunk, EnumChunk, BitsChunk, BitsStruct
 from generic.image import Palette
 from text_handler import humanFilesize
+from tools import alignValue
 
 class ImageData(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -74,8 +75,8 @@
         self.read("height", "Height", (FormatChunk, "uint16"))
 
     def updateParent(self, chunk):            
-        chunk.description = "Frame: %ux%u pixels at (%u,%u)" % \
-            (self["width"], self["height"], self["x"], self["y"])
+        chunk.description = "Frame: a=%s b=%s c=%s %ux%u pixels at (%u,%u)" % \
+            (self["a"], self["b"], self["c"], self["width"], self["height"], self["x"], self["y"])
 
 class Sprite(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -177,8 +178,10 @@
             self.read("filesize", "File size", (FormatChunk, "uint32"), {"post": humanFilesize})
             self.name = "(directory)"
             end = self.doRead("last_pos", "Last position", (FormatChunk, "uint32")).value
+            self.count = 0
             while stream.tell() < end:
                 self.read("res[]", "Resource", (Resource,))
+                self.count += 1
 
     def getStaticSize(stream, args):
         oldpos = stream.tell()
@@ -196,11 +199,55 @@
         if self["tag"] != "DIR":
             chunk.description = "[%s] %s" % (self.name, self["data"].getDescription())
         else:
-            chunk.description = "Directory" 
+            chunk.description = "Directory: %u resources" % self.count 
 
+class File(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "fs", "File system", stream, parent, "<")
+        self.read("position", "Position in file", (FormatChunk, "uint32"))
+        self.read("size", "File size (in bytes)", (FormatChunk, "uint32"), {"post": humanFilesize})
+        size = self.doRead("name", "Name", (StringChunk,"C")).size
+        padding = 4 + alignValue(size, 4) - size
+        max = stream.getLastPos() - stream.tell() + 1
+        if max<padding:
+            padding = max
+        self.read("padding", "Padding", (FormatChunk,"string[%u]" % padding))
+        
+    def updateParent(self, chunk):
+        size = self.getChunk("size").getDisplayData()
+        chunk.description = "File: %s (%s)" \
+            % (self["name"], size)
+
+class XXX(OnDemandFilter):
+    def __init__(self, stream, parent, count):
+        OnDemandFilter.__init__(self, "fs", "File system", stream, parent, "<")
+        self.count = count
+        for i in range(0, self.count):
+            self.read("value32[]", "?", (FormatChunk, "uint32"))
+        
+    def updateParent(self, chunk):
+        chunk.description = "XXX: %u integers (uint32)" % (self.count)
+
+class FileSystem(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "fs", "File system", stream, parent, "<")
+        self.count = 0 
+        while not stream.eof():
+            self.read("file[]", "File", (File,))
+            self.count += 1
+        
+    def updateParent(self, chunk):
+        chunk.description = "File system: %u files" % (self.count)
+
 class Worms2_Dir_File(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent, "<")
-        self.read("resources", "Directory of resources", (Resource,))
+        self.read("resources", "Directory", (Resource,))
+        if True:
+            count = 1026
+            self.read("xxx", "XXX", (XXX,count), {"size": count*4})
+        
+            size = stream.getRemainSize()
+            self.read("fs", "File system", (FileSystem,), {"size": size})
          
 registerPlugin(Worms2_Dir_File, "hachoir/worms2")

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-02 23:42:46 UTC (rev 387)
+++ haypo/hachoir/trunk/reverse.py	2006-01-03 04:02:25 UTC (rev 388)
@@ -7,8 +7,26 @@
 from chunk import FormatChunk
 from default import EmptyFilter
 import config
-import sys
+import sys, math
 
+def entropy(raw):
+    assert 0<len(raw)
+    assert isinstance(raw, str)
+    # Create list of 
+    count = [ 0 for i in range(0, 256) ]
+    length = len(raw)        
+    p = []
+    for i in raw:
+        count[ord(i)] += 1
+    for i in range(0,256):
+        if count[i] != 0:
+            p.append( float(count[i]) / length )
+    h = 0
+    n = len(p)
+    for p_i in p:
+        h += p_i * math.log(p_i, 2)
+    return -h
+
 class Pattern:
     def check(self, stream):
         return False

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2006-01-02 23:42:46 UTC (rev 387)
+++ haypo/hachoir/trunk/stream/stream.py	2006-01-03 04:02:25 UTC (rev 388)
@@ -10,12 +10,13 @@
     #--- Virtual functions --------------------------------------------------
     
     def getSize(self):
+        """ Stream size in bytes. """
         return 0
 
-    def clone(self):
-        return None
-    
     def getLastPos(self):
+        """
+        Position of last byte in stream.
+        """
         return 0
 
     def tell(self):
@@ -45,14 +46,14 @@
         if start == None:
             start = self.tell()
         if size == None:
-            size = self.getSize()-start
+            size = self.getLastPos()-start+1
         return SubStream(self, start, size, self.filename)
 
     def createLimited(self, start=None, size=None):
         if start==None:
             start = self.tell()
         if size == None:
-            size = self.getSize()-start
+            size = self.getLastPos()-start+1
         return LimitedStream(self, start, size, self.filename)
 
     def getFormat(self, format, seek=True):
@@ -132,17 +133,16 @@
             newpos = oldpos + size 
         return -1 
 
+    def getRemainSize(self):
+        return self.getLastPos() - self.tell() + 1
+
 class LimitedStream(Stream):
     def __init__(self, stream, start=0, size=0, filename=None):
         Stream.__init__(self, filename)
         assert 1 <= size            
         assert 0 <= start
         assert not(stream.getLastPos()+1 < start+size)
-        self._stream = stream.clone()
-#        if start<0:
-#            start = 0
-#        if self._stream.getLastPos()+1 < start+size:
-#            size = self._stream.getLastPos()-start+1
+        self._stream = stream
         self._start = start
         self._size = size
         self._end = self._start + self._size
@@ -159,7 +159,8 @@
         if size_max == None or self._end-self.tell() < size_max:
             size_max = self._end-self.tell()
         assert 0<=size_max  and size_max<=self._size
-        return self._stream.search(str, size_max)
+        self._stream.seek(self._seed)
+        return self._stream.search(str, size_max) 
         
     def read(self, size, seek=True):
         """ Works like Posix read (can returns less than size bytes. """
@@ -170,7 +171,7 @@
         return data
 
     def getN(self, size, seek=True):
-        if self._start+self._size<self._seed+size:
+        if self._start+self._size < self._seed+size:
             raise StreamError( \
                 "Can't read outsize the stream\n"
                 +"(try to read %u byte(s) from position %s, where stream in limited in [%u;%u])" \
@@ -202,16 +203,18 @@
     def getLastPos(self):
         return self._last_pos
 
-    def clone(self):
-        return LimitedStream(self._stream, self._start, self._size, self.filename)
-
 class SubStream(LimitedStream):
+    def __init__(self, stream, start=0, size=0, filename=None):
+        LimitedStream.__init__(self, stream, start, size, filename)
+        self._last_pos = self._size - 1
+
     def search(self, str, size_max=None):
         if self._end == 0: return -1
         max = self._end-self.tell()-self._start-1
         if size_max == None or max < size_max:
             size_max = max
         assert 0<=size_max  and size_max<=self._size
+        self._stream.seek(self._seed)
         pos = self._stream.search(str, size_max)
         if pos != -1:
             pos = pos - self._start
@@ -231,9 +234,3 @@
 
     def tell(self):
         return self._seed - self._start
-    
-    def getLastPos(self):
-        return self._end - self._start
-
-    def clone(self):
-        return SubStream(self._stream, self._start, self._size, self.filename)

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2006-01-02 23:42:46 UTC (rev 387)
+++ haypo/hachoir/trunk/tools.py	2006-01-03 04:02:25 UTC (rev 388)
@@ -1,5 +1,11 @@
 import traceback, sys, string, re
 
+def alignValue(value, align):
+    if value % align != 0:
+        return value + align - (value % align)
+    else:
+        return value        
+
 def _regexMaxLength(pattern, in_parenthesis=False):
     """
     Don't use this function directly, use regexMagLength!



From haypo at berlios.de  Tue Jan  3 17:33:13 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 3 Jan 2006 17:33:13 +0100
Subject: [Happyboom-svn] r389 - in haypo/hachoir/trunk: . plugins stream
Message-ID: <200601031633.k03GXD6H001518@sheep.berlios.de>

Author: haypo
Date: 2006-01-03 17:33:12 +0100 (Tue, 03 Jan 2006)
New Revision: 389

Modified:
   haypo/hachoir/trunk/bits.py
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/plugins/elf.py
   haypo/hachoir/trunk/plugins/png.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/stream/file.py
Log:
- Remove clone() methods in FileStream and Chunk
- Worms2: Replace "mysterious header" with "step"
- Worms2: Replace (a, b) with "offset" and c with "step" in SpriteFrame 
- PNG: Fix Text handler
- Filter: only replace filter when raw data when fails if size is an integer


Modified: haypo/hachoir/trunk/bits.py
===================================================================
--- haypo/hachoir/trunk/bits.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/bits.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -1,5 +1,5 @@
 def str2hex(value):
-    text = "(hex) "
+    text = ""
     for character in value:
         if text != "":
             text += " "

Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/chunk.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -23,9 +23,6 @@
         return None
     getStaticSize = staticmethod(getStaticSize)
 
-    def clone(self):
-        raise Exception("%s doesn't implement clone() method!" % self)
-
     def postProcess(self):        
         if self.post_process != None:
             self.display = self.post_process(self)
@@ -275,11 +272,6 @@
         self._size = getFormatSize(self._format)
         self._value = {}
        
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self._addr
-        return FormatChunk(self.id, self.description, self._stream, addr, self._format, self._parent)
-
     def getFormat(self):
         return self.__class__.__name__ + " (%s)" % self._format
 

Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/filter.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -291,12 +291,12 @@
                     filter_stream.seek(desc[2])
                 else:
                     self._stream.seek(addr)
-                assert isinstance(size, int)
-                self._chunks_dict[id][4] = (FormatChunk, id, description, filter_stream, "string[%u]" % size, self)
-                self._chunks_dict[id][5] = None
-                self._chunks_dict[id][6] = {}
-                self.updateChunkDisplay(id)
-                return self._createInstance(id)
+                if isinstance(size, int) or isinstance(size, long):
+                    self._chunks_dict[id][4] = (FormatChunk, id, description, filter_stream, "string[%u]" % size, self)
+                    self._chunks_dict[id][5] = None
+                    self._chunks_dict[id][6] = {}
+                    self.updateChunkDisplay(id)
+                    return self._createInstance(id)
         self._stream.seek(oldpos)
         return chunk
 

Modified: haypo/hachoir/trunk/plugins/elf.py
===================================================================
--- haypo/hachoir/trunk/plugins/elf.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/plugins/elf.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -141,8 +141,7 @@
 #            i = i + 1
             
         size = elf["shoff"] - stream.tell()
-        newstream = stream.clone()
-        chunk = self.doRead("data", "Data", (DeflateFilter, newstream, size, Sections, sections))
+        chunk = self.doRead("data", "Data", (DeflateFilter, stream, size, Sections, sections))
         chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
         assert stream.tell() == elf["shoff"]
 

Modified: haypo/hachoir/trunk/plugins/png.py
===================================================================
--- haypo/hachoir/trunk/plugins/png.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/plugins/png.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -70,10 +70,14 @@
 class Text(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "text", "Text", stream, parent)
-        chunk = self.read("keyword", "Keyword", (StringChunk, "C"))
+        chunk = self.doRead("keyword", "Keyword", (StringChunk, "C"))
         lg = stream.getSize() - chunk.size
         self.read("text", "Text", (FormatChunk, "string[%u]" % lg))
 
+    def updateParent(self, chunk):
+        text = self.getChunk("text").getValue(40)
+        chunk.description = "Text: \"%s\"" % text        
+
 class Time(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "time", "Time", stream, parent, "!")
@@ -134,9 +138,9 @@
         else:
             type = "Unknow (%s)" % type
         if self.data:            
-            desc = "[Chunk] %s" % self.data.getDescription()
+            desc = self.data.getDescription()
         else:
-            desc = "[Chunk] %s" % type
+            desc = "Chunk %s" % type
             type = self["type"]
             if type == "IEND":
                 desc += ": end of file"

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -49,43 +49,47 @@
         chunk.description = "Image: %ux%u pixels" % \
             (self["width"], self["height"])
 
-class MysteriousHeader(OnDemandFilter):
+class Step(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite_item", "Sprite item", stream, parent, "<")
         self.read("a", "???", (FormatChunk, "uint16"))
         self.read("b", "???", (FormatChunk, "uint16"))
         self.read("c", "???", (FormatChunk, "uint16"))
-        self.read("d", "???", (FormatChunk, "uint16"))
+        self.read("size", "Size in byte", (FormatChunk, "uint16"))
         self.read("e", "???", (FormatChunk, "uint16"))
-        self.read("f", "???", (FormatChunk, "uint16"))
+        self.read("f1", "???", (FormatChunk, "uint8"))
+        self.read("f2", "???", (FormatChunk, "uint8"))
         
     def updateParent(self, chunk):            
-        chunk.description = "Mysterious: d=%s f=%s a=%s b=%s c=%s e=%s" % \
-            (self["d"],self["f"],self["a"],self["b"],self["c"],self["e"])
+        chunk.description = "Step: size=%s f1=%s f2=%s a=%s b=%s c=%s e=%s" % \
+            (self["size"],self["f1"],self["f2"],self["a"],self["b"],self["c"],self["e"])
 
 class SpriteFrame(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "frame", "Sprite frame", stream, parent, "<")
-        self.read("a", "???", (FormatChunk, "uint8"))
-        self.read("b", "???", (FormatChunk, "uint16"))
-        self.read("c", "???", (FormatChunk, "uint8"))
+        self.read("offset", "???", (FormatChunk, "uint16"))
+        self.read("zero", "???", (FormatChunk, "uint8"))
+        assert self["zero"] == 0
+        self.read("step", "???", (FormatChunk, "uint8"))
         self.read("x", "Offset X", (FormatChunk, "uint16"))
         self.read("y", "Offset Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
 
     def updateParent(self, chunk):            
-        chunk.description = "Frame: a=%s b=%s c=%s %ux%u pixels at (%u,%u)" % \
-            (self["a"], self["b"], self["c"], self["width"], self["height"], self["x"], self["y"])
+        w = self["width"] - self["x"]
+        h = self["height"] - self["y"]
+        chunk.description = "Frame: %ux%u bytes - %ux%u pixels at (%u,%u) offset=%s step=%s" % \
+            (w, h, self["width"], self["height"], self["x"], self["y"], self["offset"], self["step"])
 
 class Sprite(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
         name = parent.name
-        self.read("n", "Type?", (FormatChunk, "uint16"))
+        self.read("nb_step", "Number of steps", (FormatChunk, "uint16"))
         self.read("zero", "Zero?", (FormatChunk, "uint16"))
-        for i in range(0, self["n"]):
-            self.read("mysterious[]", "Mysterious header", (MysteriousHeader,))
+        for i in range(0, self["nb_step"]):
+            self.read("step[]", "Step", (Step,))
         self.read("x", "Offset X", (FormatChunk, "uint16"))
         self.read("y", "Offset Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
@@ -102,8 +106,8 @@
         self.addPadding()
 
     def updateParent(self, chunk):            
-        chunk.description = "Animation: %ux%u pixels, %u mysterious, %u frame(s)" % \
-            (self["width"], self["height"], self["n"], self["count"])
+        chunk.description = "Animation: %ux%u pixels, %u step(s), %u frame(s)" % \
+            (self["width"], self["height"], self["nb_step"], self["count"])
 
 class Font(OnDemandFilter):
     def __init__(self, stream, parent):

Modified: haypo/hachoir/trunk/stream/file.py
===================================================================
--- haypo/hachoir/trunk/stream/file.py	2006-01-03 04:02:25 UTC (rev 388)
+++ haypo/hachoir/trunk/stream/file.py	2006-01-03 16:33:12 UTC (rev 389)
@@ -103,9 +103,6 @@
             self._seed = self._seed + len(data)
         return data            
 
-    def clone(self):
-        return FileStream(self._file, self.filename, copy=self)
-
     def seek(self, pos, where=0):
         """ Read file seek document to understand where. """
         if where==0:



From haypo at berlios.de  Tue Jan  3 17:36:03 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 3 Jan 2006 17:36:03 +0100
Subject: [Happyboom-svn] r390 - haypo
Message-ID: <200601031636.k03Ga3al001884@sheep.berlios.de>

Author: haypo
Date: 2006-01-03 17:36:03 +0100 (Tue, 03 Jan 2006)
New Revision: 390

Modified:
   haypo/tachatte.py
Log:
Set default mode to "tachatte".


Modified: haypo/tachatte.py
===================================================================
--- haypo/tachatte.py	2006-01-03 16:33:12 UTC (rev 389)
+++ haypo/tachatte.py	2006-01-03 16:36:03 UTC (rev 390)
@@ -42,7 +42,7 @@
         self.encode_number = True
         self.encode_string = True
         self.encode_syntax = False 
-        self.mode = "words"
+        self.mode = "tachatte"
         self.eat_comments = False 
         self.eat_spaces = False 
         self.sort_thesaurus = False # most used names are shorter
@@ -352,7 +352,8 @@
     print "Options :"
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
-    print "\t--mode=MODE       : Mode (words, moo, tachatte, letter or shit)"
+    print "\t--mode=MODE       : Mode=words, moo, tachatte, letter or shit."
+    print "\t                    (default: tachatte)"
     print "\t--random          : Shuffle thesaurus (default: off)"
     print "\t--eat-comments    : Eat comments (default: off)"
     print "\t--eat-spaces      : Eat white spaces (default: off)"



From haypo at berlios.de  Tue Jan  3 17:39:10 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 3 Jan 2006 17:39:10 +0100
Subject: [Happyboom-svn] r391 - in haypo/hachoir/tags: . 2005-12-26/plugins 2005-12-28
Message-ID: <200601031639.k03GdAQ0002149@sheep.berlios.de>

Author: haypo
Date: 2006-01-03 17:39:09 +0100 (Tue, 03 Jan 2006)
New Revision: 391

Added:
   haypo/hachoir/tags/2005-12-28/
   haypo/hachoir/tags/2005-12-28/NEWS
   haypo/hachoir/tags/2005-12-28/TODO
   haypo/hachoir/tags/2005-12-28/chunk.py
   haypo/hachoir/tags/2005-12-28/default.py
   haypo/hachoir/tags/2005-12-28/error.py
   haypo/hachoir/tags/2005-12-28/filter.py
   haypo/hachoir/tags/2005-12-28/format.py
   haypo/hachoir/tags/2005-12-28/generic/
   haypo/hachoir/tags/2005-12-28/hachoir.py
   haypo/hachoir/tags/2005-12-28/hachoir_class.py
   haypo/hachoir/tags/2005-12-28/mime.py
   haypo/hachoir/tags/2005-12-28/plugins/
   haypo/hachoir/tags/2005-12-28/release.sh
   haypo/hachoir/tags/2005-12-28/stream/
   haypo/hachoir/tags/2005-12-28/text_handler.py
   haypo/hachoir/tags/2005-12-28/tools.py
   haypo/hachoir/tags/2005-12-28/ui/
Removed:
   haypo/hachoir/tags/2005-12-28/NEWS
   haypo/hachoir/tags/2005-12-28/TODO
   haypo/hachoir/tags/2005-12-28/broken_plugins/
   haypo/hachoir/tags/2005-12-28/chunk.py
   haypo/hachoir/tags/2005-12-28/default.py
   haypo/hachoir/tags/2005-12-28/error.py
   haypo/hachoir/tags/2005-12-28/filter.py
   haypo/hachoir/tags/2005-12-28/format.py
   haypo/hachoir/tags/2005-12-28/generic/
   haypo/hachoir/tags/2005-12-28/hachoir.py
   haypo/hachoir/tags/2005-12-28/hachoir_class.py
   haypo/hachoir/tags/2005-12-28/mime.py
   haypo/hachoir/tags/2005-12-28/plugins/
   haypo/hachoir/tags/2005-12-28/release.sh
   haypo/hachoir/tags/2005-12-28/stream/
   haypo/hachoir/tags/2005-12-28/text_handler.py
   haypo/hachoir/tags/2005-12-28/tools.py
   haypo/hachoir/tags/2005-12-28/ui/
Modified:
   haypo/hachoir/tags/2005-12-26/plugins/exe.py
Log:
- Create 2005-12-26 release
- Fix EXE plugin in 2005-12-26 release


Modified: haypo/hachoir/tags/2005-12-26/plugins/exe.py
===================================================================
--- haypo/hachoir/tags/2005-12-26/plugins/exe.py	2006-01-03 16:36:03 UTC (rev 390)
+++ haypo/hachoir/tags/2005-12-26/plugins/exe.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -107,7 +107,7 @@
         self.readArray("directories", PE_Directory, "PE directories", self.checkEndOfDir)
 
     def checkEndOfDir(self, stream, array, dir):
-        return len(array) == self.nb_directories
+        return len(array) == self["nb_directories"]
 
 class PE_Filter(Filter):
     def __init__(self, stream, parent):
@@ -181,7 +181,7 @@
             for section in self["pe_sections"]:
                 section = section.getFilter()
                 if section.name == ".rsrc":
-                    offset_res_section = section.file_offset
+                    offset_res_section = section["file_offset"]
                     self.getStream().seek( offset_res_section )
                     break
             if offset_res_section != None:
@@ -193,4 +193,4 @@
     def checkEndOfSections(self, stream, array, section):
         return len(array) == self["pe"]["nb_sections"]
 
-registerPlugin(ExeFile, "application/x-dosexec")
+registerPlugin(ExeFile, ["application/x-dosexec", "application/x-ms-dos-executable"])

Copied: haypo/hachoir/tags/2005-12-28 (from rev 372, haypo/hachoir/trunk)

Deleted: haypo/hachoir/tags/2005-12-28/NEWS
===================================================================
--- haypo/hachoir/trunk/NEWS	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/NEWS	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,31 +0,0 @@
-News in version 2005-12-26
-    o Some speed up:
-      - use more caches (eg. for format operations like getting format size)
-      - merge FormatChunkCache and FormatChunk to limit function calls
-    o New command line options: "--use-profiler" and "--debug"
-    o Hide backtrace by default (need "--debug" command line option)
-    o Delete ArrayFilter class, replace it with classical while Python
-      structure.
-    o Add "copy to clipboard" in user interface
-    o Add AVI (written with a new author, Aur?lien Jacobs), MP3, ID3, MBR,
-      EXT2, PCX, BMP, WORMS2 plugins. RPM plugin can now read all headers
-      and also file content.
-    o Kill arbitrary limits (address/size) ;-) (in Chunk/Filter classes and in UI)
-    o Don't support FormatChunk dynamic format (like "{size}s"),
-      nor "@end@" keyword anymore
-    o Start work on "on demand filter": create OnlyFormatsChunkFilter class
-      which only instanciate objects when needed. It's only used
-      in EXT2 plugin yet.
-
-News in version 2005-12-11 (svn commit 314)
-    o First public release
-    o Use GTK+ interface with Glade XML files (dynamically loaded) 
-    o Available plugins : jpeg, ar, email, bzip2, exif, elf, exe, gif,
-      pdf, png, rpm, tar, xcf, zip, gzip, asn1, 3ds
-    o Support three types of chunks: FormatChunk, FilterChunk, StringChunk.
-      String format can be: C, UnixLine, WindowsLine, MacLine, AutoLine.
-    o Use cache for FormatChunk value and FileStream access.
-    o Use MIME type detection to choose the best filter.
-    o Development features:
-      - it's possible to edit chunks list: create, edit, remove chunk
-      - it's possible to store and load a filter into/from XML file

Copied: haypo/hachoir/tags/2005-12-28/NEWS (from rev 389, haypo/hachoir/trunk/NEWS)

Deleted: haypo/hachoir/tags/2005-12-28/TODO
===================================================================
--- haypo/hachoir/trunk/TODO	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/TODO	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,2 +0,0 @@
-List of TODO can be found which following command:
-  grep TODO -A3 $(find -name "*.py")

Copied: haypo/hachoir/tags/2005-12-28/TODO (from rev 389, haypo/hachoir/trunk/TODO)

Deleted: haypo/hachoir/tags/2005-12-28/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/chunk.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,457 +0,0 @@
-import struct, re, types
-import config
-from format import checkFormat, splitFormat, getFormatSize, getRealFormat, formatIsString, formatIsArray, formatIsInteger, formatIsArray
-from error import warning, error
-from tools import convertDataToPrintableString
-
-class Chunk(object):
-    """
-    A chunk address is fixed. If you want to move the chunk, delete it :-P
-    """
-    def __init__(self, id, description, stream, addr, size, parent):
-        self._id = id
-        self.description = description
-        self._size = size
-        self._addr = addr
-        self._parent = parent
-        self._stream = stream
-        self.post_process = None
-        self.display = None
-
-    def getStaticSize(stream, args):
-        return None
-    getStaticSize = staticmethod(getStaticSize)
-
-    def clone(self):
-        raise Exception("%s doesn't implement clone() method!" % self)
-
-    def postProcess(self):        
-        if self.post_process != None:
-            self.display = self.post_process(self)
-
-    def getFormat(self):
-        return self.__class__.__name__
-
-    def getSmallFormat(self):
-        return self.__class__.__name__
-
-    def getStream(self):
-        return self._stream
-
-    def getStringValue(self):
-        value = self.getDisplayData()
-        if type(value) == types.TupleType:
-            return "(%s)" % ", ".join( map(str,value) )
-        else:
-            return "%s" % value
-
-    def getRaw(self, max_size=None):
-        oldpos = self._stream.tell()
-        self._stream.seek(self.addr)
-        size = self._size
-        if max_size != None and max_size<size:
-            size = max_size
-        data = self._stream.getN(size)
-        self._stream.seek(oldpos)
-        return data
-
-    def getValue(self, max_size=None):
-        return self.getRaw(max_size)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        else:
-            return self.getRaw(40)
-
-    def setParent(self, parent):
-        self._parent = parent
-    def getParent(self): return self._parent
-    def _getAddr(self): return self._addr
-    def _getSize(self): return self._size
-    def _getId(self):
-        return self._id
-    def _setId(self, new_id):
-        old_id = self.id
-        if new_id == old_id:
-            return
-        self._id = new_id
-        self._parent.updateChunkId(old_id, new_id)
-    addr = property(_getAddr)
-    size = property(_getSize)        
-    id = property(_getId, _setId)
-    value = property(getValue)
-    raw = property(getRaw)
-    
-class FilterChunk(Chunk):
-    def __init__(self, id, filter, parent, parent_addr):
-        self._description = None
-        self.parent_addr = parent_addr
-        self._filter = filter
-        self._filter.filter_chunk = self
-        self._parent = None
-        Chunk.__init__(self, id, \
-            filter.getDescription(), filter.getStream(), filter.getAddr(), \
-            filter.getSize(), parent)
-        self._description = filter.getDescription()
-    
-    def getFormat(self):
-        return self.__class__.__name__ + " (%s)" % self._filter.__class__.__name__
-
-    def getSmallFormat(self):
-        return self._filter.__class__.__name__
-
-    def setFilter(self, filter):
-        self._filter = filter
-        self._filter.updateParent(self)
-    
-    def _getSize(self):
-        return self._filter.getSize()
-    size = property(_getSize)        
-        
-    def getDisplayData(self):
-        return "(...)" 
-        
-    def getValue(self, max_size=None):
-        return self._filter
-    value = property(getValue)
-
-    def getFilter(self):
-        return self._filter
-
-    def _setId(self, new_id):
-        if new_id == self.id:
-            return
-        self._filter.setId(new_id)
-        Chunk._setId(self, new_id)
-    id = property(Chunk._getId, _setId)
-
-    def _getDescription(self):
-        return self._description
-    def _setDescription(self, description):
-        if self._description != None:
-            self._description = description
-            self._filter.setDescription(description)
-            self._parent.updateChunkDescription(self._id, description)
-    description = property(_getDescription, _setDescription)
-
-class StringChunk(Chunk):
-    regex_eol_nr = re.compile("[\n\r]")
-    regex_not_ascii = re.compile("[^\x00-\x7F]")
-    names = {
-        "C": "c-string",
-        "MacLine": "mac line",
-        "UnixLine": "unix line",
-        "AutoLine": "line",
-        "Pascal16": "pascal16",
-        "Pascal32": "pascal32",
-        "WindowsLine": "windows line"
-    }
-
-    def __init__(self, id, description, stream, str_type, parent, strip=None, charset="ascii"):
-        """
-        Strip: if strip=None, call read text.strip()
-               if strip is a string, call read text.strip(self.strip)
-        """
-        assert str_type in StringChunk.names
-        Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
-        self._str_type = str_type
-        self.eol = None
-        self._findSize()
-        self.strip = strip
-        self.charset = charset
-
-    def getFormat(self):
-        return "%s (%s)" % (\
-            StringChunk.names[self._str_type],
-            self.charset)
-    getSmallFormat = getFormat
-
-    def _findSize(self):
-        self._stream.seek(self.addr)
-        if self._str_type == "Pascal16":
-            self.length = self._stream.getFormat("!uint16")
-            self._size = 2 + self.length
-            self.eol = ""
-        elif self._str_type == "Pascal32":
-            self.length = self._stream.getFormat("!uint32")
-            self._size = 4 + self.length
-            self.eol = ""
-        elif self._str_type == "AutoLine":
-            self._size = self._stream.searchLength(StringChunk.regex_eol_nr, True)
-            assert self._size != -1
-            self._stream.seek(self.addr + self._size-1)
-            self.eol = self._stream.getN(1)
-            if self.eol == "\r" and self._stream.read(1) == "\n":
-                self.eol = "\r\n"
-                self._size = self._size + 1
-            self.length = self._size - len(self.eol)
-        else:            
-            if self._str_type == "UnixLine":
-                self.eol = "\n"
-            elif self._str_type == "WindowsLine":
-                self.eol = "\r\n"
-            elif self._str_type == "MacLine":
-                self.eol = "\r"
-            else: 
-                self.eol = "\0"
-            self._size = self._stream.searchLength(self.eol, True)
-            assert self._size != -1
-            self.length = self._size - len(self.eol)
-        self._stream.seek(self.addr + self._size)
-        
-    def _read(self, max_size):
-        self._stream.seek(self.addr)
-        if self._str_type == "Pascal32":
-            self._stream.seek(4,1)
-            size = self.length
-        elif self._str_type == "Pascal16":
-            self._stream.seek(2,1)
-            size = self.length
-        else:
-            size = self._size - len(self.eol)
-        if max_size != None and max_size<size:
-            text = self._stream.getN(max_size)+"(...)"
-        else:
-            text = self._stream.getN(size)
-        self._stream.seek(self.addr + self._size)
-        if self.strip != None:
-            if self.strip == True:
-                text = text.strip()
-            else:
-                text = text.strip(self.strip)
-        if self.charset != "ascii":
-            try:                
-                text = unicode(text, self.charset)
-            except:
-                self.charset = "ascii"
-                text = StringChunk.regex_not_ascii.sub(".", text)
-                text = unicode(text, "ascii")
-        return text
-
-    def getValue(self, max_size=None):
-        return self._read(None)
-    value = property(getValue)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        else:
-            text = self._read(config.max_string_length)
-            return convertDataToPrintableString(text)
-
-class FormatChunk(Chunk):
-    def __init__(self, id, description, stream, format, parent):
-        Chunk.__init__(self, id, description, stream, stream.tell(), None, parent)
-        self._format = None
-        self._doSetFormat(format)
-        stream.seek(self.size, 1)
-
-    def getStaticSize(stream, args):
-        return getFormatSize(args[0])
-    getStaticSize = staticmethod(getStaticSize)
-
-    def _doSetFormat(self, format):
-        if format == self._format:
-            return
-
-        # Add endian if needed
-        splited = splitFormat(format)
-        if splited[0] == None and splited[2] not in "scbB":
-            endian = self._parent.endian
-            assert endian != None
-            format = endian + format
-            
-        self._format = format
-        self._real_format = getRealFormat(format)
-        self._is_string = formatIsString(self._format)
-        self._is_array = formatIsArray(format)
-        self._size = getFormatSize(self._format)
-        self._value = {}
-       
-    def clone(self, addr=None):
-        if addr == None:
-            addr = self._addr
-        return FormatChunk(self.id, self.description, self._stream, addr, self._format, self._parent)
-
-    def getFormat(self):
-        return self.__class__.__name__ + " (%s)" % self._format
-
-    def getSmallFormat(self):
-        return self._format
-
-    def convertToStringSize(self, size):
-        self._doSetFormat("%us" % size)
-
-    def setFormat(self, format, method, new_id=None, new_description=None):
-        """ Method:
-        - split => create new raw array if chunk is smaller
-        - rescan => if size changed, rescan chunks"""
-
-        # Check format
-        if not checkFormat(format):
-            raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
-        
-        # Check new size
-        size = getFormatSize(format)
-        if self._stream.getLastPos() < (self.addr + size - 1):
-            raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
-
-        # Update format
-        old_size = self._size
-        self._doSetFormat(format)
-        new_size = self._size
-        diff_size = new_size - old_size
-
-        # Update id and description
-        old_id = self.id
-        if new_id != None:
-            new_id = self.getParent().getUniqChunkId(new_id)
-            self.id = new_id
-        old_description = self.description
-        if new_description != None:
-            self.description = new_description
-
-        # Update filter if needed
-        if diff_size != 0:
-            if method == "split" and diff_size < 0:
-                self._parent.addRawChunk(self, old_id, -diff_size, old_description)
-            else:
-                self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description, truncate=True)
-        self._parent.updateFormatChunk(self)
-
-    def _getRawData(self, max_size=None):
-        oldpos = self._stream.tell()
-        self._stream.seek(self._addr)
-        if (max_size == None or self._size<=max_size) or not self._is_string:
-            data = self._stream.getN(self._size, False)
-            self._stream.seek(oldpos)
-            return data, False
-        else:
-            data = self._stream.getN(max_size, False)
-            self._stream.seek(oldpos)
-            return data, True
-
-    def getRaw(self, max_size=None):
-        return self._getRawData(max_size)[0]
-    raw = property(getRaw)
-   
-    def getValue(self, max_size=None):
-        if max_size not in self._value:
-            data, truncated = self._getRawData(max_size)
-            if not truncated:
-                data = struct.unpack(self._real_format, data)
-                if not self._is_array:
-                    data = data[0]
-            else:
-                data = data + "(...)"
-            self._value[max_size] = data
-        return self._value[max_size]
-    value = property(getValue)
-
-    def getDisplayData(self):
-        if self.display != None:
-            return self.display
-        data = self.getValue(config.max_string_length)
-        if type(data)==types.StringType:
-            return convertDataToPrintableString(data)
-        else:
-            return data 
-
-class EnumChunk(FormatChunk):
-    def __init__(self, id, description, stream, format, dict, parent):
-        assert not formatIsArray(format)
-        FormatChunk.__init__(self, id, description, stream, format, parent)
-        self._dict = dict
-#        value = self.getValue()
-#        self.description = self.description + ": " + self._dict.get(value, "Unknow (%s)" % value)
-
-    def getDisplayData(self):
-        value = self.getValue()
-        return self._dict.get(value, "Unknow (%s)" % value)
-
-class BitsStruct(object):
-    def __init__(self, items=None):
-        self._items_list = []
-        self._items_dict = {}
-        self._size = 0
-        self._source = None
-        if items != None:
-            for item in items:
-                if 3<len(item):
-                    type = item[3]
-                else:
-                    type = None
-                self.add(item[0], item[1], item[2], type)
-            assert self.isValid()
-
-    def isValid(self):
-        return (0 < self._size) and ((self._size % 8) == 0)
-
-    def add(self, bits, id, description, type=None):
-        # TODO: (Maybe) Generate new id if another already exist
-        assert id not in self._items_dict
-        assert 0<bits
-        assert bits <= 32
-        if type == None:
-            if 1<bits:
-                type = "bits"
-            else:
-                type = "bit"
-        self._items_list.append(id)
-        self._items_dict[id] = (self._size, bits, type, description)
-        self._size += bits
-
-    def __getitem__(self, id):
-        assert self.isValid() 
-        item = self._items_dict[id]
-        addr = item[0]
-        size = item[1]
-        data = self._source.getRaw()
-        start = addr / 8
-        mask = (1 << size) - 1
-        byte_size = (size + (addr % 8) + 7) / 8
-        shift = (start+byte_size) * 8 - (size+addr)
-        data = data[start:start+byte_size]
-        value = 0
-        for character in data:
-            value <<= 8
-            value += ord(character)
-#        print "%u..%u : " % (addr, addr+size), "bytes %u..%u : " % (start, start+byte_size), "shift=", shift, "mask=", mask, "value=", value, "final=",(value >> shift) & mask
-        value = (value >> shift) & mask
-        if size == 1:
-            return value == 1
-        else:
-            return value
-
-    def setSource(self, source):
-        self._source = source
-
-    def _getSize(self):
-        assert self.isValid() 
-        return self._size / 8
-    size = property(_getSize)
-
-    def display(self, ui, parent):
-        for id in self._items_list:
-            item = self._items_dict[id]
-            addr = item[0]
-            size = item[1]
-            format = item[2]
-            desc = item[3]
-            display = self[id]
-            ui.add_table(parent, addr, size, format, id, desc, display)
-
-class BitsChunk(Chunk):
-    def __init__(self, id, description, stream, struct, parent):
-        Chunk.__init__(self, id, description, stream, stream.tell(), struct.size, parent)
-        self._struct = struct
-        self._struct.setSource(self)
-        stream.seek(self.size, 1)
-
-    def uiDisplay(self, ui):
-        path = ui.add_table(None, self.addr, self.size, "bits", self.id, self.description, "*bits*")
-        self._struct.display(ui, path)
-
-    def __getitem__(self, id):
-        return self._struct[id]

Copied: haypo/hachoir/tags/2005-12-28/chunk.py (from rev 389, haypo/hachoir/trunk/chunk.py)

Deleted: haypo/hachoir/tags/2005-12-28/default.py
===================================================================
--- haypo/hachoir/trunk/default.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/default.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,11 +0,0 @@
-from filter import OnDemandFilter
-from chunk import FormatChunk
-
-#class EmptyFilter(OnDemandFilter):
-#    def __init__(self, stream, parent=None):
-#        OnDemandFilter.__init__(self, "empty", "Empty filter", stream, parent)
-
-class DefaultFilter(OnDemandFilter):
-    def __init__(self, stream, parent=None):
-        OnDemandFilter.__init__(self, "default", "Default filter", stream, parent)
-        self.read("data", "Raw data", (FormatChunk, "string[%u]" % stream.getSize()))

Copied: haypo/hachoir/tags/2005-12-28/default.py (from rev 389, haypo/hachoir/trunk/default.py)

Deleted: haypo/hachoir/tags/2005-12-28/error.py
===================================================================
--- haypo/hachoir/trunk/error.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/error.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,35 +0,0 @@
-import os
-import config
-from log import log
-import ui.ui
-from tools import getBacktrace
-
-def warning(message):
-    log_message = message + "\n\n" + getBacktrace()
-    if config.debug:
-        message = log_message
-    log.warning(log_message)   
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_WARNING,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()
-
-def error(message, backtrace=None):
-    log_message = message + "\n\n" + getBacktrace()
-    if config.debug:
-        message = log_message
-    log.error(log_message)
-    if ui.ui.ui != None:
-        import gtk
-        dlg = gtk.MessageDialog( \
-            parent=ui.ui.ui.window.window,
-            type=gtk.MESSAGE_ERROR,
-            buttons=gtk.BUTTONS_OK,
-            message_format=message)
-        dlg.run()
-        dlg.destroy()

Copied: haypo/hachoir/tags/2005-12-28/error.py (from rev 389, haypo/hachoir/trunk/error.py)

Deleted: haypo/hachoir/tags/2005-12-28/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/filter.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,306 +0,0 @@
-"""
-Base class for all splitter filters.
-"""
-
-import struct, re, sys, string, types
-import config
-import ui.ui as ui
-from chunk import Chunk, FormatChunk, FilterChunk, StringChunk, BitsChunk
-from error import error
-from format import getFormatSize, splitFormat
-from cache import Cache
-
-class BasicFilter(object):
-    regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
-
-    def __init__(self, id, description, stream, parent, addr, endian):
-        self._id = id
-        self._description = description
-        self._stream = stream
-        self._parent = parent
-        self._addr = addr 
-        self._chunks_counter = {}
-        self._chunks_dict = {}
-        self._endian = endian
-        self.filter_chunk = None
-
-    def getStaticSize(stream, args):
-        return None
-    getStaticSize = staticmethod(getStaticSize)
-
-    def updateParent(self, chunk): pass
-    def getId(self): return self._id
-    def setId(self, id):
-        if self._id == id:
-            return
-        self._id = id
-        if self.filter_chunk != None:
-            self.filter_chunk.id = id
-    def getDescription(self): return self._description
-    def setDescription(self, description): self._description = description
-    def getAddr(self): return self._addr
-    def getParent(self): return self._parent
-    def getStream(self): return self._stream
-    def updateChunkId(self, old_id, new_id): pass
-    def updateChunkDescription(self, id, desc): pass
-    def __len__(self): return len(self._chunks_dict)
-
-    def getPath(self):
-        """
-        Get path to the filter.
-        Example: "grandparent > parent > item"
-        """
-        text = ""
-        current = self
-        while current != None:
-            if text != "": text = "/" + text
-            text = current.getId() + text
-            current = current.getParent()
-        return "/"+text
-
-    def _getUniqChunkId(self, root, index):
-        if root in self._chunks_counter:
-            self._chunks_counter[root] = self._chunks_counter[root] + 1
-        else:
-            self._chunks_counter[root] = index
-        return self._chunks_counter[root]
-
-    def getUniqChunkId(self, id):
-        # No collision
-        if id not in self._chunks_dict and id[-2:] != "[]":
-            return id
-
-        # Pattern like "block[]"
-        if id[-2:] == "[]":
-            root = id[:-2]
-            start = 0
-            pattern = "%s[%u]"
-        else:
-            # Manage id collision
-            m = BasicFilter.regex_chunk_uniq_id.match(id)
-            if m != None:
-                root = m.group(1)
-                start = int(m.group(2)) + 1
-            else:
-                root = id
-                start = 2
-            pattern = "%s%u"
-        if root in self._chunks_counter:
-            self._chunks_counter[root] = self._chunks_counter[root] + 1
-        else:
-            self._chunks_counter[root] = start 
-        return pattern % (root, self._chunks_counter[root])
-        
-    def hasChunk(self, id):
-        return id in self._chunks_dict
-
-    def _getEndian(self): return self._endian
-    endian = property(_getEndian)
-
-    # --- Pure virtual methods -----------
-    def getSize(self): todoWriteMethod(self, "getSize") 
-    def __getitem__(self, chunk_id): todoWriteMethod(self, "__getitem__") 
-    def getChunk(self, chunk_id): todoWriteMethod(self, "getChunk")
-    def display(self): todoWriteMethod(self, "display")
-
-class OnDemandFilter(BasicFilter, Cache):
-    def __init__(self, id, description, stream, parent, endian=None):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell(), endian)
-        Cache.__init__(self, "Filter %s" % id)
-        self._size = 0
-        self._chunks = []
-        self._chunks_cache = {}
-   
-    def getCacheSize(self):
-        return len(self._chunks_cache)
-
-    def updateChunkId(self, old_id, new_id):
-        # Update self._chunks
-        pos = self._chunks.index(old_id)
-        assert pos != -1
-        self._chunks[pos] = new_id
-
-        # Update self._chunks_dict
-        info = self._chunks_dict[old_id]
-        info[0] = new_id
-        del self._chunks_dict[old_id]
-        self._chunks_dict[new_id] = info
-        
-        # Update self._chunks_dict
-        if old_id in self._chunks_cache:
-            cache = self._chunks_cache[old_id]
-            del self._chunks_cache[old_id]
-            self._chunks_cache[new_id] = cache
-
-        # Update display
-        info = self.displayChunkInfo(new_id)
-        ui.window.update_table(self, pos, *info)
-
-    def updateChunkDescription(self, id, desc):
-        pos = self._chunks.index(id)
-        assert pos != -1
-        self._chunks_dict[id][1] = desc
-
-        info = self.displayChunkInfo(id)
-        ui.window.update_table(self, pos, *info)
-
-    def purgeCache(self):
-        if len(self._chunks_cache) != 0 and config.verbose:
-            print "Purge cache: destroy %s chunks" % len(self._chunks_cache)
-        self._chunks_cache = {}
-        
-    def read(self, id, description, info, optionnal={}): 
-        chunk_class = info[0]
-        id = self.getUniqChunkId(id)
-        addr = self._stream.tell()
-        if issubclass(chunk_class, BasicFilter):
-            filter_stream = optionnal.get("stream", self._stream)
-            size = optionnal.get("size", None)
-            filter_addr = filter_stream.tell()
-            args = info[1:]
-            if size == None:
-                size = chunk_class.getStaticSize(self._stream, info[1:])
-            if size == None:
-                filter = chunk_class(filter_stream, self, *args)
-                description = filter.getDescription()
-                filter.setId(id)
-                chunk = FilterChunk(id, filter, self, addr)
-                size = filter.getSize()
-                if config.verbose:
-                    print "%s: Instanciate filter %s" % (self.getPath(), id)
-            else:
-                chunk = None
-
-            chunk_info = [id, description, addr, size, \
-                    (chunk_class, filter_stream, filter_addr, args), None, {}]
-            self._chunks_dict[id] = chunk_info
-            self._chunks.append(id)
-            if chunk != None:
-                filter.updateParent(chunk)
-                self._chunks_cache[id] = chunk
-            self._size = self._size + size
-            self._stream.seek(addr + size)
-            return id
-
-        else:
-            post = optionnal.get("post", None)
-            if "post" in optionnal:
-                del optionnal["post"]
-            if isinstance(info, list):
-                args = info[1:]
-            else:
-                args = [ i for i in info[1:] ]
-            instance_info = [info[0], id, description, self._stream]+args+[self]
-
-            size = chunk_class.getStaticSize(self._stream, info[1:])
-            if size != None:
-                self._stream.seek(size, 1)
-            else:
-                # Instanciate the chunk
-                seek = False
-                chunk = info[0] (*instance_info[1:], **optionnal)
-                size = chunk.size
-                id = chunk.id
-                self._chunks_cache[id] = chunk
-            chunk_info = [id, description, addr, size, instance_info, post, optionnal]
-#            else:       
-#                assert chunk_class == StringChunk
-#                strip = optionnal.get("strip", None)
-#                chunk = chunk_class (id, description, self._stream, info[1:], self, strip=strip)
-#                chunk_info = [id, description, addr, size, \
-#                        (info[0], id, description, self._stream, info[1:], self,), post, optionnal]
-#                self._chunks_cache[id] = chunk
-            self._chunks_dict[id] = chunk_info
-            self._chunks.append(id)
-            self._size = self._size + size
-            return id
-
-    def doRead(self, id, description, info, optionnal={}):
-        id = self.read(id, description, info, optionnal)
-        chunk = self.getChunk(id)
-        if isinstance(chunk, FilterChunk):
-            return chunk.getFilter()
-        else:
-            return chunk
-
-    def displayChunkInfo(self, id):
-        info = self._chunks_dict[id]
-        chunk_class = info[4][0]
-        if issubclass(chunk_class, BasicFilter):
-            display = "(...)"
-            format = chunk_class.__name__
-        else:
-            chunk = self.getChunk(id)
-            display = chunk.getDisplayData()
-            format = chunk.getSmallFormat()
-        addr = info[2]
-        size = info[3]
-        return (None, addr, size, format, info[0], info[1], display)
-
-    def display(self):
-        ui.window.enableParentButton(self.getParent() != None)
-        ui.window.clear_table()
-        for id in self._chunks:
-            info = self.displayChunkInfo(id)
-            if self._chunks_dict[id][4][0] == BitsChunk:
-                self.getChunk(id).uiDisplay(ui.window)
-            else:
-                ui.window.add_table(*info)
- 
-    def getSize(self): return self._size
-
-    def _createInstance(self, id):
-        addr = self._chunks_dict[id][2]
-        desc = self._chunks_dict[id][4]
-        post = self._chunks_dict[id][5]
-        chunks_kw = self._chunks_dict[id][6]
-        oldpos = self._stream.tell()
-        self._stream.seek(addr)
-        if config.verbose:
-            print "%s: Instanciate %s (of type %s)" % (self.getPath(), id, desc[0].__name__)
-        if not issubclass(desc[0], BasicFilter):
-            chunk_class = desc[0]
-            chunk_args = desc[1:]
-            chunk = chunk_class(*chunk_args, **chunks_kw)
-            if post != None:
-                chunk.display = post(chunk)
-        else:
-            filter_stream = desc[1]
-            if filter_stream != self._stream:
-                filter_stream.seek(desc[2])
-            filter = desc[0] (filter_stream, self, *desc[3])
-            filter.setId(id)
-            chunk = FilterChunk(id, filter, self, addr)
-            if filter.getDescription() != desc[1]:
-                self.updateChunkDescription(id, filter.getDescription())
-            filter.updateParent(chunk)
-        self._stream.seek(oldpos)
-        return chunk
-
-    def getChunk(self, id):
-        if id not in self._chunks_dict:
-            return None
-        if id not in self._chunks_cache:
-            chunk = self._createInstance(id) 
-            self._chunks_cache[chunk.id] = chunk 
-            return chunk
-        else:
-            return self._chunks_cache[id]
-
-    def __getitem__(self, id):
-        assert id in self._chunks_dict
-        chunk = self.getChunk(id)
-        if isinstance(chunk.__class__, FilterChunk):
-            return chunk.getFilter()
-        else:
-            return chunk.value
-
-class DeflateFilter(OnDemandFilter):
-    def __init__(self, stream, parent, bz_stream, size, filter, *args):
-        OnDemandFilter.__init__(self, "deflate", "Deflate", bz_stream, parent)
-        self._addr = stream.tell()
-        self.read("data", "Data", [filter]+[i for i in args])
-        self._compressed_size = size
-
-    def getSize(self):
-        return self._compressed_size

Copied: haypo/hachoir/tags/2005-12-28/filter.py (from rev 389, haypo/hachoir/trunk/filter.py)

Deleted: haypo/hachoir/tags/2005-12-28/format.py
===================================================================
--- haypo/hachoir/trunk/format.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/format.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,105 +0,0 @@
-import re, struct
-from cache import Cache
-
-class FormatCache(Cache):
-    # Uniq instance of the class
-    _instance = None
-
-    # Check if a format is an array or not
-    # "string[4]" is an array, "char" isn't
-    regex_array =  re.compile("^([a-z]+[0-9]*)\[([0-9]+)\]$")
-
-    # Convert Hachoir syntax to struct module syntax
-    format_type = {
-        "string": "s",
-        "char": "c",
-        "float": "f",
-        "double": "d",
-        "int8": "b",
-        "uint8": "B",
-        "int16": "h",
-        "uint16": "H",
-        "int32": "l",
-        "uint32": "L"
-    }
-    
-    def __init__(self):
-        assert FormatCache._instance == None
-        Cache.__init__(self, "FormatCache")
-        self._dict = {}
-
-    def getCacheSize(self):
-        return len(self._dict)
-
-    def purgeCache(self):
-        self._dict = {}
-
-    def convertNewFormat(self, format):
-        old_format = format
-        if format[0] in "!<>":
-            endian = format[0]
-            str_endian = format[0]
-            format = format[1:]
-        else:
-            endian = None
-            str_endian = ""
-        m = FormatCache.regex_array.match(format)
-        if m != None:
-            format = m.group(1)
-            str_count = m.group(2)
-            count = int(str_count)
-        else:
-            str_count = "" 
-            count = 1
-        if format not in FormatCache.format_type:
-            raise Exception("Format \"%s\" is invalid!" % old_format)
-        type = FormatCache.format_type[format]
-        return (str_endian + str_count + type, endian, count, type)
-
-    def __getitem__(self, format):
-        if format not in self._dict:
-            real_format, endian, count, type = self.convertNewFormat(format)
-            size = count * struct.calcsize(type)
-            self._dict[format] = (real_format, endian, count, type, size)
-        return self._dict[format]   
-
-    def getInstance():
-        if FormatCache._instance == None:
-            FormatCache._instance = FormatCache()
-        return FormatCache._instance
-    getInstance = staticmethod(getInstance)        
-
-_format_size_cache = {}
-
-def formatIsString(format):
-    cache = FormatCache.getInstance()[format]
-    return cache[3] == "s"
-
-def formatIsInteger(format):
-    cache = FormatCache.getInstance()[format]
-    return cache[3] in "bBhHlL"
-
-def getFormatSize(format):
-    cache = FormatCache.getInstance()[format]
-    return cache[4]   
-
-def getRealFormat(format):
-    cache = FormatCache.getInstance()[format]
-    return cache[0]   
-
-def checkFormat(format):
-    # TODO: Don't use try/except, but something better
-    try:
-        cache = FormatCache.getInstance()
-        conv = cache.convertNewFormat(format)
-        return True
-    except:
-        return False
-
-def splitFormat(format):
-    cache = FormatCache.getInstance()[format]
-    return cache[1:4]   
-
-def formatIsArray(format):
-    cache = FormatCache.getInstance()[format]
-    return (1 < cache[2]) and (cache[3] != "s")

Copied: haypo/hachoir/tags/2005-12-28/format.py (from rev 389, haypo/hachoir/trunk/format.py)

Copied: haypo/hachoir/tags/2005-12-28/generic (from rev 389, haypo/hachoir/trunk/generic)

Deleted: haypo/hachoir/tags/2005-12-28/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/hachoir.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,136 +0,0 @@
-#!/usr/bin/python
-"""
-Hachoir: tool to split a binary file into human readable data.
-Because it's written in Python, it would be easy to write new plugins
-(supports new file format).
-
-Author: Victor Stinner
-"""
-
-import sys, os, re, traceback
-import config
-from program import PROGRAM, VERSION, WEBSITE
-from log import log
-from error import error
-from hachoir_class import Hachoir
-import ui.ui as ui
-
-def usage(defval):
-    print "%s version %s" % (PROGRAM, VERSION)
-    print "%s\n" % WEBSITE
-    print "Usage: %s [options] file" % (sys.argv[0])
-    print ""
-    print "Options:"
-    print "\t--script file.py  : Load python script"
-    print "\t--no-ui           : Don't load user interface"
-    print "\t--use-profiler    : Use profiler"
-    print "\t--version         : Show the program version"
-    print "\t--verbose         : Activate verbose mode"
-    print "\t--help            : Show this help"
-    print "\t--debug           : Enable debug mode (eg. display backtrace)"
-
-def parseArgs(val):
-    import getopt
-    def_val = val.copy()
-    
-    try:
-        short = ""
-        long = ["verbose", "help", "version", "script=", "no-ui", "debug", "use-profiler"]
-        opts, args = getopt.getopt(sys.argv[1:], short, long)
-    except getopt.GetoptError:
-        usage(def_val)
-        sys.exit(2)
-   
-    if 1 < len(args):
-        usage(def_val)
-        sys.exit(2)
-    if len(args) == 1:
-        filename = args[0]
-    else:
-        filename = None
-        
-    for o, a in opts:
-        if o == "--help":
-            usage(def_val)
-            sys.exit()
-        elif o == "--version":
-            print "%s version %s" % (PROGRAM, VERSION)
-            sys.exit()
-        elif o == "--no-ui":
-            val["load_ui"] = False
-        elif o == "--script":
-            val["script"] = a
-        elif o == "--verbose":
-            config.verbose = True
-        elif o == "--debug":
-            config.debug = True
-        elif o == "--use-profiler":
-            val["use_profiler"] = True
-    return (val, filename,)
-
-def main():
-    try:        
-        print "%s version %s" % (PROGRAM, VERSION)
-        print "%s\n" % WEBSITE
-    
-        import imp
-        plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")
-        plugins_files = os.listdir(plugins_dir)
-        file_py = re.compile("^([a-z0-9_]+)\.py$")
-        modules = []
-        for file in plugins_files:
-            m = file_py.match(file)
-            if file != "__init__.py" and m != None:
-                module = "plugins."+m.group(1)
-                __import__(module)
-                modules.append(m.group(1))
-        log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
-
-        opt = {
-            "verbose": False,
-            "script": None,
-            "load_ui": True,
-            "use_profiler": False
-        }
-        opt, filename = parseArgs(opt)
-        global hachoir 
-        hachoir = Hachoir()
-        for key in opt:
-            setattr(hachoir, key, opt[key])
-        if hachoir.load_ui:
-            try:
-                print "Load user interface"
-                ui.loadInterface(hachoir)
-            except ImportError, err:
-                error("""Error: a Python module is missing:
-%s
-
-You can find PyGTK at: http://www.pygtk.org/
-and PyGlade at: http://glade.gnome.org/
-
-Gentoo: emerge pytgtk
-Debian: apt-get install python2.4-gtk python2.4-magic
-Ubuntu: apt-get install python-gtk2 python-glade2
-Mandriva: urpmi pygtk2.0-libglade-2.6.2-1mdk (or pygtk2.0-libglade?)""" % (err))
-                sys.exit(1)
-        if opt["use_profiler"]:
-            import profile, pstats
-            stat_filename = 'hachoir.pystat'
-            if filename != None:
-                str_filename = "\"%s\"" % filename
-            else:
-                str_filename = "None"
-            profile.run('global hachoir; hachoir.run(%s)' % str_filename, stat_filename)
-            #pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
-            pstats.Stats(stat_filename).sort_stats('time').print_stats()
-            os.unlink(stat_filename)
-        else:
-            hachoir.run(filename)
-
-    except SystemExit:
-        pass
-    except Exception, err:
-        error("Python Exception: %s" % err)
-	sys.exit(1)
-
-if __name__=="__main__": main()    

Copied: haypo/hachoir/tags/2005-12-28/hachoir.py (from rev 389, haypo/hachoir/trunk/hachoir.py)

Deleted: haypo/hachoir/tags/2005-12-28/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/hachoir_class.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,142 +0,0 @@
-from stream.file import FileStream
-from plugin import getPluginByStream
-from chunk import FilterChunk, FormatChunk
-from default import DefaultFilter
-from user_filter import UserFilterDescriptor, loadUserFilter
-from error import error, warning
-from mime import getStreamMime
-
-class Hachoir:
-    instance = None
-    
-    def __init__(self):
-        Hachoir.instance = self
-        self.display = True
-        self.depth = 5
-        self.ui = None 
-        self._main_filter = None
-        self._filter = None
-        self.script = None
-        self.load_ui = True
-
-    def getFilter(self):
-        return self._filter
-
-    def setFilter(self, filter):
-#        if self._filter != None:
-#            self._filter.purgeCache()
-        self._main_filter = filter
-        self._filter = filter
-        if filter != None:
-            if self.load_ui:
-                self._filter.display()
-                self.ui.window.info.updateFilter(filter)
-        else:
-            if self.load_ui:
-                self.ui.window.clear_table()
-        if self.load_ui:
-            self.ui.window.updateToolbar()
-
-    def onGoParent(self):
-        if self._filter.getParent() == None: return
-        self._filter = self._filter.getParent()
-        self.ui.window.info.updateFilter(self._filter)
-        self._filter.display()
-        
-    def onRowClick(self, chunk_id):
-        if chunk_id == None: return
-        chunk = self._filter.getChunk(chunk_id)
-        if issubclass(chunk.__class__, FilterChunk):
-            filter = chunk.getFilter()
-            self.setFilter (filter)
-
-    def loadUser(self, filename):
-        try:
-            old_filter = self._filter
-            old_size = old_filter.getSize()
-            user = UserFilterDescriptor(xml_file=filename)
-            stream = self._filter.getStream()
-            parent = self._filter.getParent()
-            stream.seek(self._filter.getAddr())
-            new_filter = loadUserFilter(user, stream, parent)
-        except Exception, err:
-            error("Error while loading user XML filter \"%s\":\n%s" % (filename, err))
-            return
-        self._filter = new_filter           
-        if parent == None:
-            self._main_filter = self._filter
-            self._addPadding()
-        else:
-            chunk = old_filter.filter_chunk
-            chunk.setFilter(self._filter)
-            diff_size = self._filter.getSize() - old_size
-            chunk.getParent().rescan(chunk, diff_size)
-        if self.load_ui:
-            self._filter.display()
-        self.ui.window.updateToolbar()
-    
-    def saveUser(self, filename):
-        my = UserFilterDescriptor(filter=self._filter)
-        my.writeIntoXML(filename)
-    
-    def exportUser(self, filename):
-        my = UserFilterDescriptor(filter=self._filter)
-        my.exportPython(filename)
-        
-    def _addPadding(self):
-        filter_size = self._main_filter.getSize()
-        stream_size = self._main_filter.getStream().getSize()
-        diff_size = filter_size - stream_size
-        if diff_size < 0:
-            self._main_filter.read("end", "Raw data", (FormatChunk, "string[%u]" % -diff_size))
-
-    def loadFile(self, filename):
-        try:
-            print "Load file %s" % filename
-            file = open(filename, 'r')
-            stream = FileStream(file, filename)
-        except IOError, err:
-            error("Can't load file %s:\n%s" % (filename, err))
-            return
-        self.loadStream(stream, filename)
-
-    def loadStream(self, stream, filename=None):
-        # Look for a plugin
-        split_class = getPluginByStream(stream, filename, None)
-        if split_class == None:
-            mimes = [ item[0] for item in getStreamMime(stream, filename)]
-            warning("Warning: No plugin found for MIME %s." % ", ".join(mimes))
-            split_class = DefaultFilter
-            
-        # Split 
-        try:
-            stream.seek(0)
-            filter = split_class(stream, None)
-        except Exception, msg:
-            error("Exception while processing file %s:\n%s" \
-                % (filename, msg))
-            stream.seek(0)
-            filter = DefaultFilter(stream)
-        self._main_filter = filter
-        self._addPadding()
-        self.setFilter(filter)
-
-    def loadScript(self, filename):
-        try:
-            f = open(self.script, 'r')
-            script = f.read()
-            f.close()
-            compiled = compile(script, self.script, 'exec')
-            exec compiled
-        except Exception, msg:
-            error("Exception while loading script \"%s\":\n%s\n%s" \
-                % (filename, msg))
-
-    def run(self, filename):
-        if self.script:
-            self.loadScript(self.script)
-        elif filename != None:
-            self.loadFile(filename)
-        if self.load_ui:
-            print "Run user interface ..."
-            self.ui.run()      

Copied: haypo/hachoir/tags/2005-12-28/hachoir_class.py (from rev 389, haypo/hachoir/trunk/hachoir_class.py)

Deleted: haypo/hachoir/tags/2005-12-28/mime.py
===================================================================
--- haypo/hachoir/trunk/mime.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/mime.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,141 +0,0 @@
-#!/usr/bin/python
-
-"""
-MIME type detection using libmagic library.
-
-See also:
-- ftp://ftp.astron.com/pub/file/ (libmagic)
-- http://www.demonseed.net/~jp/code/magic.py (100% Python)
-- http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
-"""
-
-import os, sys, stat, string, re
-from error import warning
-
-instance = None
-
-class GuessMime:
-    def __init__(self):
-        self.use_fallback = False
-        self.func = None
-        try:
-            path = os.path.dirname(__file__)
-            sys.path.append(path)
-            import magic
-            self.func = magic.open(magic.MAGIC_MIME)
-            self.func.load()
-        except ImportError:
-            warning("Warning: The library libmagic for Python is unavailable. Using internal fallback engine.")
-            self.use_fallback = True
-        if self.use_fallback:
-            from  fallback.magic import whatis
-            self.func = whatis
-
-    def guess(self, buffer):
-        if not self.use_fallback:
-            return self.func.buffer(buffer)
-        else:
-            mime = self.func(buffer)
-            return mime
-
-def getFileMime(realname, filename=None):
-    if filename == None:
-        filename = realname
-    mode = os.stat(filename)[stat.ST_MODE]
-    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
-    
-    f = file(filename, "rb")
-    buffer = f.read(4096)
-    f.close()
-    return getBufferMime(buffer, filename)
-
-def getMimeByExt(ext):    
-    if ext == '.gz':
-        return 'application/x-gzip'
-    return None        
-
-def getStreamMime(stream, filename):
-    oldpos = stream.tell()
-    stream.seek(0)
-    size = stream.getSize()
-    if 4096<size:
-        size = 4096
-    data = stream.getN(size)
-    stream.seek(oldpos)
-    return getBufferMime(data, filename)
-
-def getAnotherBufferMime(buffer):    
-    if buffer[:2] == "\x4d\x4d" and buffer[6:12]=="\x02\0\x0A\0\0\0":
-        return "image/x-3ds"
-    if 2<=len(buffer) and ord(buffer[0])==31 and ord(buffer[1])==139:
-        return "application/x-gzip"
-    if buffer[:4] == "%PDF":
-        return "application/pdf"
-    if buffer[:14] == "gimp xcf file\0":
-        return "image/x-xcf"
-
-    if buffer[0] == "\x0A" \
-    and buffer[1] in "\x00\x02\x03\x04\x05" \
-    and buffer[64] == "\0":
-        return "image/x-pcx"
-        
-    if 4096<=len(buffer) \
-    and buffer[1080:1082]=="\x53\xEF" \
-    and buffer[1116:1120]=="\x04\x00\x00\x00":
-        return "hachoir/fs-ext2"
-        
-    if buffer[0:3] == "DIR":
-        return "hachoir/worms2"
-        
-    if 512<=len(buffer) \
-    and buffer[0] in "\xEB\xFA" \
-    and buffer[510:512] == "\x55\xAA" \
-    and buffer[446] in "\x00\x80" \
-    and buffer[446+16*1] in "\x00\x80" \
-    and buffer[446+16*2] in "\x00\x80" \
-    and buffer[446+16*3] in "\x00\x80":
-        return "hachoir/master-boot-record"
-    return None        
-
-def splitMimes(mimes):
-    """
-    Split MIME types into a list.
-    Examples:
-    - "text/plain; encoding=latin-1" => [["text/plain", {"encoding": latin-1"}]
-    - "text/plain, text/xml" => [["text/plain"],["text/xml"]]
-    - "text/plain; charset=ISO-8859-1; format=flowed"
-      => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
-    - "application/x-archive application/x-debian-package"
-    """
-
-    regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
-    mimes = regex.findall(mimes)    
-    
-    list = []
-    for mime in mimes:
-        mime = mime.strip(" ,")
-        parts = mime.split(";")
-        mime = parts[0]
-        parts = map(string.strip, parts[1:])
-        values = {}
-        for part in parts:
-            if part != "":
-                split_part = part.split("=", 1)             
-                values[ split_part[0] ] = split_part[1]
-        list.append([mime,values])
-    return list
-
-def getBufferMime(buffer, filename):
-    global instance
-    if instance == None:
-        instance = GuessMime()
-    mimes = instance.guess(buffer)
-    mimes = splitMimes(mimes)
-    if len(mimes) == 0 or mimes[0][0] in ('application/octet-stream', 'image/tiff'):
-        new_mime = getAnotherBufferMime(buffer)
-        if new_mime == None and filename != None:
-            ext = os.path.splitext(filename)[1]
-            new_mime = getMimeByExt(ext)
-        if new_mime != None:
-            mimes = ((new_mime,),)
-    return mimes

Copied: haypo/hachoir/tags/2005-12-28/mime.py (from rev 389, haypo/hachoir/trunk/mime.py)

Copied: haypo/hachoir/tags/2005-12-28/plugins (from rev 389, haypo/hachoir/trunk/plugins)

Deleted: haypo/hachoir/tags/2005-12-28/release.sh
===================================================================
--- haypo/hachoir/trunk/release.sh	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/release.sh	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,16 +0,0 @@
-PACKAGE=hachoir
-VERSION=20051115
-ARCHIVE=$PACKAGE-$VERSION.tar.bz2
-TMP_DIR=/tmp
-DIR=$PWD
-if [ -e $TMP_DIR/$PACKAGE ]; then
-        rm -rf $TMP_DIR/$PACKAGE
-fi
-
-echo "* Export data"
-svn export . $TMP_DIR/$PACKAGE
-
-echo "* Create $ARCHIVE"
-(cd $TMP_DIR && tar cjf $DIR/$ARCHIVE $PACKAGE)
-
-echo "$DIR/$ARCHIVE wrote."

Copied: haypo/hachoir/tags/2005-12-28/release.sh (from rev 389, haypo/hachoir/trunk/release.sh)

Copied: haypo/hachoir/tags/2005-12-28/stream (from rev 389, haypo/hachoir/trunk/stream)

Deleted: haypo/hachoir/tags/2005-12-28/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/text_handler.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,32 +0,0 @@
-import datetime
-from tools import humanFilesize as doHumanFilesize, str2bin
-
-def msdosDatetime(chunk):
-    assert chunk.size == 4
-    val = chunk.value
-    sec = 2 * (val & 31)              # 5 bits: second
-    min = (val >> 5) & 63             # 6 bits: minute
-    hour = (val >> 11) & 31           # 5 bits: hour
-    day = (val >> 16) & 31            # 5 bits: day
-    month = (val >> 21) & 15          # 4 bits: month
-    year = 1980 + ((val >> 25) & 127) # 7 bits: year
-    try:
-        return str(datetime.datetime(year, month, day, hour, min, sec))
-    except:
-        return "invalid msdos datetime (%s)" % val
-    
-def humanFilesize(chunk):
-    return doHumanFilesize(chunk.value)
-
-def unixTimestamp(chunk):
-    timestamp = datetime.datetime.fromtimestamp(chunk.value)
-    return str(timestamp) 
-
-def binary(chunk):
-    return str2bin(chunk.getRaw()) + " (%s)" % chunk.value
-
-def hexadecimal(chunk):
-    size = chunk.size
-    assert size in (2, 4, 8)
-    pattern = "0x%0" + str(2*size) + "X"
-    return pattern % chunk.value

Copied: haypo/hachoir/tags/2005-12-28/text_handler.py (from rev 389, haypo/hachoir/trunk/text_handler.py)

Deleted: haypo/hachoir/tags/2005-12-28/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2005-12-28 05:45:55 UTC (rev 372)
+++ haypo/hachoir/tags/2005-12-28/tools.py	2006-01-03 16:39:09 UTC (rev 391)
@@ -1,221 +0,0 @@
-import traceback, sys, string, re
-
-def byte2bin(x):
-    text = ""
-    for i in range(0,8):
-        mask = 1 << (7-i)
-        if (x & mask) == mask:
-            text += "1"
-        else:
-            text += "0"
-    return text            
-
-def str2bin(value):
-    text = ""
-    for character in value:
-        if text != "":
-            text += " "
-        text += byte2bin(ord(character))
-    return text
-
-def str2hex(value):
-    text = "(hex) "
-    for character in value:
-        if text != "":
-            text += " "
-        text += "%02X" % ord(character)
-    return text
-
-def _regexMaxLength(pattern, in_parenthesis=False):
-    """
-    Don't use this function directly, use regexMagLength!
-    """
-
-    re_letter = re.compile( r"^[^][()|.?+*{}](.*)$")
-    re_set = re.compile( r"^\[" + r"[^]]*" + r"\](.*)$" )
-    re_min_repetition = re.compile( r"^\{([0-9]+)\}(.*)$" )
-    re_min_max_repetition = re.compile( r"^\{([0-9]+),([0-9]+)\}(.*)$" )
-
-    size = 0
-    atom_size = 0
-    state = 0 # get atom
-    is_end = len(pattern) == 0
-    if in_parenthesis and not is_end:
-        is_end = pattern[0] in ("|", ")")
-    while not is_end:
-        if state==0:
-            size = size + atom_size
-
-            # Pattern: [...] => size=1
-            if pattern[0] == '(':
-                pattern = pattern[1:]
-                atom_size = None
-                while True:
-                    tmp_atom_size, pattern = _regexMaxLength(pattern, True)
-                    if tmp_atom_size == None:
-                        return None, pattern
-                    if atom_size==None or atom_size<tmp_atom_size:
-                        atom_size = tmp_atom_size
-                    if pattern[0] == ')':
-                        break
-                    assert pattern[0] == '|'
-                    pattern = pattern[1:]
-                pattern = pattern[1:]
-            else:
-                m = re_set.match(pattern)
-                if m != None:
-                    pattern = m.group(1)
-                    atom_size = 1
-                else:
-                    m = re_letter.match(pattern)
-                    if m == None:
-                        return (-1, pattern,)
-                    atom_size = 1
-                    pattern = m.group(1)
-            state = 1                
-        else:
-            assert state==1
-
-            # Repetiton: + or * => no limit
-            if pattern[0] in ("*", "+"):
-                return (None, pattern,)
-            
-            # Repetition: {2}
-            m = re_min_repetition.match(pattern)
-            if m != None:
-                repetition = int(m.group(1))
-                print "(rep=%sx%s)" % (atom_size, repetition)
-                pattern = m.group(2)
-                atom_size = atom_size * repetition
-            else:
-                # Repetition: {1,2}
-                m = re_min_max_repetition.match(pattern)
-                if m != None:
-                    repetition = int(m.group(2))
-                    pattern = m.group(3)
-                    atom_size = atom_size * repetition
-            state = 0
-
-        is_end = len(pattern) == 0
-        if in_parenthesis and not is_end:
-            is_end = pattern[0] in ("|", ")")
-
-    return (size + atom_size, pattern,)
-
-def regexMaxLength(pattern):
-    """
-    Get maximum size of a regular expression pattern.
-    Returns (size, pattern). If size=-1, an error occurs (pattern contains
-    the buggy pattern). If size=-1, no limit does exist.
-    """
-
-    size, pattern = _regexMaxLength(pattern)
-    if size == -1:
-        raise "Can't parse regular expression: %s" % pattern 
-    return size 
-
-def humanDuration(ms):
-    # Milliseconds
-    if ms < 1000:
-        return "%u ms" % ms
-        
-    # Seconds
-    sec = ms/1000
-    ms = ms%1000
-    if sec < 60:
-        return  "%u sec" % sec
-
-    # Minutes
-    min = sec/60
-    sec = sec%60
-    if min<60:
-        return "%u min %u sec" % (min, sec)
-
-    # Hours
-    hour = min/60
-    min = min/60
-    if hour < 24:
-        return "%u hour(s) %u min" % (hour, min)
-
-    # Days
-    day = hour/24
-    hour = hour%24
-    if day < 365:
-        return "%u day(s) %u hour(s)" % (day, hour)    
-
-    # Years
-    # TODO: Better estimation !?
-    year = day / 365
-    day = day % 365
-    if hour != 0:
-        text = "%u year(s) %u day(s)" % (year, day)    
-    else:
-        text = "%u year(s)" % (year)
-    return text
-
-def humanFilesize(size):
-    if size < 1000:
-        return "%u bytes" % size
-    units = ["KB", "MB", "GB", "TB"]
-    size = float(size)
-    for unit in units:
-        size = size / 1024
-        if size < 1024:
-            return "%.1f %s" % (size, unit)
-    return "%u %s" % (size, unit)
-
-def convertDataToPrintableString(data, keep_n=False):
-    if len(data) == 0:
-        return "(empty)"
-    if not isinstance(data, unicode):
-        data = re.sub("[^\x00-\x7F]", ".", data)
-        data = unicode(data, "ascii")
-    display = ""
-    for c in data:
-        if ord(c)<32:
-            know = { \
-                "\n": "\\n",
-                "\r": "\\r",
-                "\t": "\\t",
-                "\0": "\\0"}
-            if c in know:
-                if not keep_n or c != "\n":
-                    display = display + know[c]
-                else:
-                    display = display + c
-            else:
-                display = display + "."
-        else:
-            display = display + c
-#            if is_8bit:
-#                if ord(c) != 0xFF:
-#                    display = display + c
-#                else:
-#                    display = display + "."
-#            else:                    
-#                if c in string.printable:
-#                    display = display + c
-#                else:
-#                    display = display + "."
-    return u"\"%s\"" % display
-
-def getBacktrace():
-    try:
-        bt = traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback)
-        return "".join(bt)
-    except:
-        return "Error while trying to get backtrace"
-
-def getUnixRWX(mode):
-#-- TODO --
-#EXT2_S_ISUID  0x0800  SUID
-#EXT2_S_ISGID  0x0400  SGID
-#EXT2_S_ISVTX  0x0200  sticky bit
-    rwx = ("---", "rwx")
-    text = ""
-    for i in range(0,3):
-        for j in range(0,3):
-            mask = 1 << (3*(2-i)) << (2-j)
-            text = text + rwx[int(mode & mask == mask)][j]
-    return text

Copied: haypo/hachoir/tags/2005-12-28/tools.py (from rev 389, haypo/hachoir/trunk/tools.py)

Copied: haypo/hachoir/tags/2005-12-28/ui (from rev 389, haypo/hachoir/trunk/ui)



From haypo at berlios.de  Wed Jan  4 03:12:15 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 4 Jan 2006 03:12:15 +0100
Subject: [Happyboom-svn] r392 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601040212.k042CFRk010302@sheep.berlios.de>

Author: haypo
Date: 2006-01-04 03:11:59 +0100 (Wed, 04 Jan 2006)
New Revision: 392

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/plugins/worms2.py
Log:
- Filter: only get chunk size if it isn't instanciated
- Worms2: lot of bugfix to support more .dir files
  o Support uncompressed sprite
  o Support Bank resource
  o Support INF resource
  o Support Index resource
  o Support font using offset
  o etc.


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-03 16:39:09 UTC (rev 391)
+++ haypo/hachoir/trunk/filter.py	2006-01-04 02:11:59 UTC (rev 392)
@@ -98,10 +98,10 @@
     def _getEndian(self): return self._endian
     endian = property(_getEndian)
 
-    def addPadding(self):
+    def addPadding(self, id="end", description="Raw end"):
         size = self._stream.getRemainSize()
         if 0 < size:
-            self.read("end", "Raw end", (FormatChunk, "string[%u]" % size))
+            self.read(id, description, (FormatChunk, "string[%u]" % size))
 
     # --- Pure virtual methods -----------
     def getSize(self): todoWriteMethod(self, "getSize") 
@@ -161,6 +161,9 @@
         self._chunks_cache = {}
         
     def read(self, id, description, info, optionnal={}): 
+        self._read(id, description, info, optionnal, False)
+
+    def _read(self, id, description, info, optionnal, instanciate):
         chunk_class = info[0]
         id = self.getUniqChunkId(id)
         addr = self._stream.tell()
@@ -169,9 +172,9 @@
             size = optionnal.get("size", None)
             filter_addr = filter_stream.tell()
             args = info[1:]
-            if size == None:
+            if not instanciate and size == None:
                 size = chunk_class.getStaticSize(self._stream, info[1:])
-            if size == None:
+            if instanciate or size == None:
                 filter = chunk_class(filter_stream, self, *args)
                 description = filter.getDescription()
                 filter.setId(id)
@@ -191,8 +194,6 @@
                 self._chunks_cache[id] = chunk
             self._size = self._size + size
             self._stream.seek(addr + size)
-            return id
-
         else:
             post = optionnal.get("post", None)
             if "post" in optionnal:
@@ -203,7 +204,10 @@
                 args = [ i for i in info[1:] ]
             instance_info = [info[0], id, description, self._stream]+args+[self]
 
-            size = chunk_class.getStaticSize(self._stream, info[1:])
+            if not instanciate:
+                size = chunk_class.getStaticSize(self._stream, info[1:])
+            else:
+                size = None
             if size != None:
                 self._stream.seek(size, 1)
             else:
@@ -217,11 +221,13 @@
             self._chunks_dict[id] = chunk_info
             self._chunks.append(id)
             self._size = self._size + size
+        if instanciate:
+            return chunk
+        else:
             return id
 
     def doRead(self, id, description, info, optionnal={}):
-        id = self.read(id, description, info, optionnal)
-        chunk = self.getChunk(id)
+        chunk = self._read(id, description, info, optionnal, True)
         if isinstance(chunk, FilterChunk):
             return chunk.getFilter()
         else:

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-03 16:39:09 UTC (rev 391)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-04 02:11:59 UTC (rev 392)
@@ -14,16 +14,22 @@
 from tools import alignValue
 
 class ImageData(OnDemandFilter):
-    def __init__(self, stream, parent):
+    def __init__(self, stream, parent, use_bank):
         OnDemandFilter.__init__(self, "image_data", "Image data (uncompressed)", stream, parent, "<")
         self.x = self.doRead("x", "Offset X", (FormatChunk, "uint16")).value
         self.y = self.doRead("y", "Offset Y", (FormatChunk, "uint16")).value
         self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
         self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
-        size = (self.width-self.x) * (self.height-self.y)
-        self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
+        self.use_bank = use_bank
+        if use_bank:
+            self.read("offset", "Offset", (FormatChunk, "uint32"))
+        else:
+            size = (self.width-self.x) * (self.height-self.y)
+            self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
 
     def getStaticSize(stream, args):
+        if args[0] == True:
+            return 12 
         oldpos = stream.tell()
         x, y = stream.getFormat("<uint16"), stream.getFormat("<uint16")
         w, h = stream.getFormat("<uint16"), stream.getFormat("<uint16")
@@ -33,16 +39,20 @@
     getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
-        chunk.description = "Image data: %ux%u pixels at (%u,%u)" \
+        desc = "Image data: " 
+        if self.use_bank:
+            desc += "offset=%u " % self["offset"]
+        chunk.description = desc+"%ux%u pixels at (%u,%u)" \
             % (self.width, self.height, self.x, self.y)
 
 class Image(OnDemandFilter):
-    def __init__(self, stream, parent):
+    def __init__(self, stream, parent, use_bank):
         OnDemandFilter.__init__(self, "image", "Image", stream, parent, "<")
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
         size = self["width"] * self["height"]
-        self.read("img_data", "Data", (FormatChunk, "string[%u]" % size))
+        if size <= stream.getRemainSize():
+            self.read("img_data", "Image data: %ux%u pixels in 8 bits/pixels" % (self["width"], self["height"]), (FormatChunk, "string[%u]" % size))
         self.addPadding()
 
     def updateParent(self, chunk):            
@@ -69,35 +79,42 @@
         OnDemandFilter.__init__(self, "frame", "Sprite frame", stream, parent, "<")
         self.read("offset", "???", (FormatChunk, "uint16"))
         self.read("zero", "???", (FormatChunk, "uint8"))
-        assert self["zero"] == 0
+#        assert self["zero"] == 0
         self.read("step", "???", (FormatChunk, "uint8"))
         self.read("x", "Offset X", (FormatChunk, "uint16"))
         self.read("y", "Offset Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
+        self.real_width = self["width"] - self["x"]
+        self.real_height = self["height"] - self["y"]
 
     def updateParent(self, chunk):            
-        w = self["width"] - self["x"]
-        h = self["height"] - self["y"]
-        chunk.description = "Frame: %ux%u bytes - %ux%u pixels at (%u,%u) offset=%s step=%s" % \
-            (w, h, self["width"], self["height"], self["x"], self["y"], self["offset"], self["step"])
+        chunk.description = "Frame: zero=%s %ux%u bytes - %ux%u pixels at (%u,%u) offset=%s step=%s" % \
+            (self["zero"], self.real_width, self.real_height, self["width"], self["height"], self["x"], self["y"], self["offset"], self["step"])
 
 class Sprite(OnDemandFilter):
-    def __init__(self, stream, parent):
+    def __init__(self, stream, parent, use_bank):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
         name = parent.name
         self.read("nb_step", "Number of steps", (FormatChunk, "uint16"))
-        self.read("zero", "Zero?", (FormatChunk, "uint16"))
-        for i in range(0, self["nb_step"]):
-            self.read("step[]", "Step", (Step,))
+        if 0 < self["nb_step"]:
+            self.read("zero", "Zero?", (FormatChunk, "uint16"))
+            for i in range(0, self["nb_step"]):
+                self.read("step[]", "Step", (Step,))
         self.read("x", "Offset X", (FormatChunk, "uint16"))
         self.read("y", "Offset Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
         self.read("count", "Frame count", (FormatChunk, "uint16"))
+        frames = []
         for i in range(0, self["count"]):
-            self.read("item[]", "Frame", (SpriteFrame,))
-        if False:            
+            frame = self.doRead("frame[]", "Frame", (SpriteFrame,))
+            frames.append(frame)
+        if self["nb_step"] == 0:
+            for frame in frames:
+                size = frame.real_width * frame.real_height
+                self.read("data[]", "Frame data: %ux%u pixels in 8 bits/pixel" % (frame.real_width, frame.real_height), (FormatChunk,"string[%u]" % size))
+        elif False:            
             real_width = self["width"] - self["x"]
             real_height = self["height"] - self["y"]
             size = real_width * real_height
@@ -106,92 +123,267 @@
         self.addPadding()
 
     def updateParent(self, chunk):            
-        chunk.description = "Animation: %ux%u pixels, %u step(s), %u frame(s)" % \
-            (self["width"], self["height"], self["nb_step"], self["count"])
+        desc = "Animation: %ux%u pixels, %u frame(s)" % (self["width"], self["height"], self["count"])
+        if self["nb_step"] == 0:
+            desc += " (uncompressed)"
+        else:
+            desc += ", %u step(s)" % (self["nb_step"])
+        chunk.description = desc
 
+class TextRes(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "textres", "Text resource", stream, parent, "<")
+        for i in range(0, 6):
+            self.read("line[]", "Line", (StringChunk, "WindowsLine"))
+        self.read("name", "File name", (StringChunk, "WindowsLine"))
+        self.read("line[]", "Line", (StringChunk, "WindowsLine"))
+        self.read("empty_line[]", "(empty line)", (StringChunk, "WindowsLine"))
+        self.read("empty_line[]", "(empty line)", (StringChunk, "WindowsLine"))
+        self.read("separator", "Separator (26)", (FormatChunk, "uint8"))
+
+    def updateParent(self, chunk):
+        chunk.description = "INF: %s" % (self["name"])
+
+class TextIndex(OnDemandFilter):
+    def __init__(self, stream, parent, use_bank):
+        OnDemandFilter.__init__(self, "text_idx", "Text index", stream, parent, "<")
+        self.count = 0
+        while True:
+            name = self.doRead("name[]", "Name", (StringChunk, "WindowsLine")).value
+            if name == "!":
+                break
+            self.count += 1
+        self.read("empty_line", "(empty line)", (StringChunk, "WindowsLine"))
+        self.read("separator", "Separator (26)", (FormatChunk, "uint8"))
+
+    def updateParent(self, chunk):
+        chunk.description = "Index: %s items" % (self.count)
+
+class BankItem(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "bank_item", "Bank item", stream, parent, "<")
+        self.x = self.doRead("x", "Offset X", (FormatChunk, "uint16")).value
+        self.y = self.doRead("y", "Offset Y", (FormatChunk, "uint16")).value
+        self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
+        self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
+        self.read("offset", "Offset?", (FormatChunk, "uint16"))
+        self.read("xxx", "???", (FormatChunk, "uint16"))
+
+    def getStaticSize(stream, args):
+        return 12 
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        desc = "Bank item: " 
+        desc += "%ux%u pixels at (%u,%u)" % (self.width, self.height, self.x, self.y)
+        desc += " offset=%s xxx=%s" % (self["offset"], self["xxx"])
+
+        chunk.description = desc
+
+class BankItem2(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "bank_item", "Bank item", stream, parent, "<")
+        self.read("offset", "Offset?", (FormatChunk, "uint16"))
+        self.read("step", "Step?", (FormatChunk, "uint16"))
+        self.read("size", "Size?", (FormatChunk, "uint16"))
+        self.read("zero", "Zero", (FormatChunk, "string[6]"))
+        assert self["zero"] == "\0" * 6 
+
+    def getStaticSize(stream, args):
+        return 12 
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        chunk.description = "Bank item2: size=%s offset=%s step=%s" % (self["size"], self["offset"], self["step"])
+
+class BigBank(OnDemandFilter):
+    def __init__(self, stream, parent, chunk_info, count):
+        OnDemandFilter.__init__(self, "bigbank", "Big bank", stream, parent, "<")
+        self.count = count
+        for i in range(0, self.count):
+            self.read("item[]", "Item", chunk_info)
+
+    def getStaticSize(stream, args):
+        size = args[0][0].getStaticSize(stream, [])
+        count = args[1]
+        assert size != None
+        return count * size
+    getStaticSize = staticmethod(getStaticSize)
+
+    def updateParent(self, chunk):
+        chunk.description = "Big Bank: %s items" % (self.count)
+
+class Bank(OnDemandFilter):
+    def __init__(self, stream, parent, use_bank):
+        OnDemandFilter.__init__(self, "text_idx", "Text index", stream, parent, "<")
+        nb_color = self.doRead("nb_color", "Number of colors", (FormatChunk, "uint16")).value
+        self.read("palette", "Palette", (Palette, nb_color))
+        self.read("xxx[]", "??", (FormatChunk, "uint16"))
+       
+        # Items (1)
+        self.count = self.doRead("count", "Number of items (1)", (FormatChunk, "uint16")).value
+        self.read("items1", "Items (1)", (BigBank, (BankItem,), self.count))
+            
+        # Items (2)
+        self.read("zero1", "Zero?", (FormatChunk, "uint16"))
+        assert self["zero1"] == 0
+        self.count2 = self.doRead("count2", "Number of items (2)", (FormatChunk, "uint32")).value
+        self.read("zero2", "Zero?", (FormatChunk, "uint32"))
+        assert self["zero2"] == 0
+        self.read("items2", "Items (2)", (BigBank, (BankItem,), self.count2))
+
+        # Items (3)
+        self.count3 = self["items2"]["item[%u]" % (self.count2-1)]["offset"]       
+        self.read("items3", "Items (3)", (BigBank, (BankItem2,), self.count3))
+       
+        if False:
+            # TODO: Finish the parser... 
+            size = stream.getRemainSize() - 1
+            self.read("data", "Images data", (FormatChunk, "string[%u]" % size))
+            
+            self.read("separator", "Separator (26)", (FormatChunk, "uint8"))
+        else:
+            self.addPadding()
+
+    def updateParent(self, chunk):
+        chunk.description = "Bank: %s items, %s items2, %s items3" % (self.count, self.count2, self.count3)
+
 class Font(OnDemandFilter):
-    def __init__(self, stream, parent):
+    def __init__(self, stream, parent, use_bank):
         OnDemandFilter.__init__(self, "font", "Font", stream, parent, "<")
 
         #--- Ugly header ---
         size = 33
-        self.read("zero[]", "???", (FormatChunk, "string[%u]" % size))
-        size = 255 - stream.tell()
-        self.read("xxx", "???", (FormatChunk, "string[%u]" % size))
-        self.read("nb_char8bit", "???", (FormatChunk, "uint8"))
-        self.read("align", "Next factor of four to height?", (FormatChunk, "uint16"))
+        self.read("zero", "Zero", (FormatChunk, "string[%u]" % size))
+        assert self["zero"] == "\0" * size
+        size = 223
+        self.read("header", "Header", (FormatChunk, "string[%u]" % size))
+        self.read("size", "Font width and height", (FormatChunk, "uint16"))
 
         # Read images
         self.read("nb_char", "Number of characters", (FormatChunk, "uint16"))
+        
         for i in range(0, self["nb_char"]):
-            self.read("image[]", "Image", (ImageData,))
+            self.read("image[]", "Image", (ImageData, use_bank))
 
         # Get image size
-        image = self["image[0]"]
-        self.width = image.width
-        self.height = image.height
+        if use_bank:
+            for i in range(0, self["nb_char"]):
+                image = self["image[%u]" % i]
+                size = image.width * image.height
+                self.read("image_data[]", "Image data content", (FormatChunk, "string[%u]" % size))
         self.addPadding()
 
     def updateParent(self, chunk):
         chunk.description = "Font: %ux%u pixels, %u characters" \
-            % (self.width, self.height, self["nb_char"])
+            % (self["size"], self["size"], self["nb_char"])
 
 class Resource(OnDemandFilter):
-    name = {
+    tag_name = {
         "IMG": "Image",
         "SPR": "Sprite",
         "FNT": "Font",
-        "DIR": "Directory"
+        "DIR": "Directory",
+        "BNK": "Bank"
     }
 
     handler = {
         "IMG": Image,
         "SPR": Sprite,
-        "FNT": Font
+        "FNT": Font,
+        "BNK": Bank
     }
 
-    def __init__(self, stream, parent):
+    def __init__(self, stream, parent, has_name, use_bank, has_separator):
         OnDemandFilter.__init__(self, "worms2_res", "Worms2 resource", stream, parent, "<")
-        pos = stream.tell()
-        self.tag = self.doRead("tag", "Type", (EnumChunk, "string[3]", Resource.name)).value
+        guess = stream.getN(3, False)
+        if guess not in Resource.tag_name:
+            self.name = "Strange chunk!?"
+            self.addPadding()
+            return
+        self.tag = self.doRead("tag", "Type", (EnumChunk, "string[3]", Resource.tag_name)).value
         self.read("tag_end", "Type end", (FormatChunk, "string[1]"))
         if self.tag != "DIR":
-            size = self.doRead("size", "Size", (FormatChunk, "uint32")).value
+            self.read("size", "Size", (FormatChunk, "uint32"))
+
             # Read resource name
-            self.name = self.doRead("name", "Name", (StringChunk, "C")).value
-            size += (pos - stream.tell() + 1)
+            if has_name:
+                self.name = self.doRead("name", "Name", (StringChunk, "C")).value
+            else:
+                self.name = self.getChunk("tag").getDisplayData() 
             
-            # Read informations about colors
-            self.read("bpp", "Bits / pixel", (FormatChunk, "uint8"))
-            self.read("xxx", "???", (FormatChunk, "uint8"))
-            nb_color = self.doRead("nb_color", "Number of colors", (FormatChunk, "uint16")).value
-            self.read("palette", "Palette", (Palette, nb_color))
-            size -= (4 + nb_color*3 + 1)
-            
+            if self.tag != "BNK":
+                # Read informations about colors
+                self.read("bpp", "Bits / pixel", (FormatChunk, "uint8"))
+                self.read("xxx", "???", (FormatChunk, "uint8"))
+                nb_color = self.doRead("nb_color", "Number of colors", (FormatChunk, "uint16")).value
+
+                self.read("palette", "Palette", (Palette, nb_color))
+            else:
+                has_separator = False
+           
+            size = self["size"] - self.getSize()
             if self.tag in Resource.handler:    
                 # Data content handler
-                sub = stream.createSub(size=size)
-                self.read("data", "Data", (Resource.handler[self.tag],), {"stream": sub})
+                self.handled = True
+                #sub = stream.createSub(size=size)
+                sub = stream.createLimited(size=size)
+                self.read("data", "Data", (Resource.handler[self.tag], use_bank), {"stream": sub})
             else:
+                self.handled = False
                 self.read("data", "Data", (FormatChunk, "string[%u]" % size))
 
             # Separator
-            self.read("separator", "Separator (0x1A = 26)", (FormatChunk, "uint8"))
-            assert self["separator"] == 0x1A
+            if has_separator:
+                if not use_bank or stream.getN(1) == "\x1A":
+                    self.read("separator", "Separator (0x1A = 26)", (FormatChunk, "uint8"))
+                #assert self["separator"] == 0x1A
         else:
             self.read("filesize", "File size", (FormatChunk, "uint32"), {"post": humanFilesize})
             self.name = "(directory)"
             end = self.doRead("last_pos", "Last position", (FormatChunk, "uint32")).value
             self.count = 0
+            guess = stream.getN(3, False)
+            has_name = True
+            use_bank = False
+            has_separator = True
+            if guess == "1\r\n":
+                while guess == "1\r\n":
+                    self.read("res[]", "Resource", (TextRes,))
+                    guess = stream.getN(3, False)
+                self.read("res[]", "Index", (TextIndex, use_bank))
+            elif guess == "BNK":
+                use_bank = True
+                has_name = False
             while stream.tell() < end:
-                self.read("res[]", "Resource", (Resource,))
+                guess = stream.getN(4, False)
+                if guess[0:4] == "\0\0\0\0":
+                    self.read("padding", "Padding", (FormatChunk, "string[4]"))
+                elif guess[0:3] == "\0\0\0":
+                    self.read("padding", "Padding", (FormatChunk, "string[3]"))
+                elif guess[0:2] == "\0\0":
+                    self.read("padding[]", "Padding", (FormatChunk, "string[2]"))
+                elif guess[0:1] == "\0":
+                    self.read("padding[]", "Padding", (FormatChunk, "string[1]"))
+                size = end - self.getSize()
+                if use_bank and size <= 20:
+                    # TODO: Remove self.addPadding() (shouldn't work so)
+                    self.read("cdrom_str", "cdrom.spr text", (StringChunk, "C"))
+                    self.read("cdrom_a", "", (FormatChunk, "uint32"))
+                    self.read("cdrom_b", "", (FormatChunk, "uint32"))
+                    assert self.getSize() == end
+                    break                
+                self.read("res[]", "Resource", (Resource, has_name, use_bank, has_separator))
                 self.count += 1
 
     def getStaticSize(stream, args):
         oldpos = stream.tell()
-        if stream.getFormat("string[3]", False) != "DIR":
+        tag = stream.getN(3, False)
+        if tag != "DIR":
             stream.seek(4, 1)
-            size = 1 + stream.getFormat("<uint32")
+            size = stream.getFormat("<uint32")
+            if args[2] and (not args[1] or tag != "SPR"):
+                size += 1
         else:
             stream.seek(8, 1)
             size = stream.getFormat("<uint32")
@@ -201,7 +393,10 @@
 
     def updateParent(self, chunk):            
         if self["tag"] != "DIR":
-            chunk.description = "[%s] %s" % (self.name, self["data"].getDescription())
+            if self.handled:
+                chunk.description = "[%s] %s" % (self.name, self["data"].getDescription())
+            else:
+                chunk.description = "[%s]" % (self.name)
         else:
             chunk.description = "Directory: %u resources" % self.count 
 
@@ -222,7 +417,7 @@
         chunk.description = "File: %s (%s)" \
             % (self["name"], size)
 
-class XXX(OnDemandFilter):
+class Numbers(OnDemandFilter):
     def __init__(self, stream, parent, count):
         OnDemandFilter.__init__(self, "fs", "File system", stream, parent, "<")
         self.count = count
@@ -230,7 +425,7 @@
             self.read("value32[]", "?", (FormatChunk, "uint32"))
         
     def updateParent(self, chunk):
-        chunk.description = "XXX: %u integers (uint32)" % (self.count)
+        chunk.description = "Numbers: %u integers (uint32)" % (self.count)
 
 class FileSystem(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -246,10 +441,10 @@
 class Worms2_Dir_File(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent, "<")
-        self.read("resources", "Directory", (Resource,))
+        self.read("resources", "Directory", (Resource, True, None, True))
         if True:
             count = 1026
-            self.read("xxx", "XXX", (XXX,count), {"size": count*4})
+            self.read("numbers", "Numbers?", (Numbers, count), {"size": count*4})
         
             size = stream.getRemainSize()
             self.read("fs", "File system", (FileSystem,), {"size": size})



From haypo at berlios.de  Wed Jan  4 03:32:02 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 4 Jan 2006 03:32:02 +0100
Subject: [Happyboom-svn] r393 - haypo/hachoir/trunk/plugins
Message-ID: <200601040232.k042W2gb017055@sheep.berlios.de>

Author: haypo
Date: 2006-01-04 03:31:50 +0100 (Wed, 04 Jan 2006)
New Revision: 393

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Clean up Worms2 plugin code.


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-04 02:11:59 UTC (rev 392)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-04 02:31:50 UTC (rev 393)
@@ -16,23 +16,24 @@
 class ImageData(OnDemandFilter):
     def __init__(self, stream, parent, use_bank):
         OnDemandFilter.__init__(self, "image_data", "Image data (uncompressed)", stream, parent, "<")
-        self.x = self.doRead("x", "Offset X", (FormatChunk, "uint16")).value
-        self.y = self.doRead("y", "Offset Y", (FormatChunk, "uint16")).value
-        self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
-        self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
+        self.read("x", "X", (FormatChunk, "uint16"))
+        self.read("y", "Y", (FormatChunk, "uint16"))
+        self.read("width", "Width", (FormatChunk, "uint16"))
+        self.read("height", "Height", (FormatChunk, "uint16"))
         self.use_bank = use_bank
         if use_bank:
             self.read("offset", "Offset", (FormatChunk, "uint32"))
         else:
-            size = (self.width-self.x) * (self.height-self.y)
+            size = (self["width"]-self["x"]) * (self["height"]-self["y"])
             self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
 
     def getStaticSize(stream, args):
         if args[0] == True:
             return 12 
         oldpos = stream.tell()
-        x, y = stream.getFormat("<uint16"), stream.getFormat("<uint16")
-        w, h = stream.getFormat("<uint16"), stream.getFormat("<uint16")
+        x, y, w, h, = stream.getFormat("<uint16[4]")
+        #x, y = stream.getFormat("<uint16"), stream.getFormat("<uint16")
+        #w, h = stream.getFormat("<uint16"), stream.getFormat("<uint16")
         size = 2*4 + (w-x) * (h-y)
         stream.seek(oldpos)
         return size
@@ -43,7 +44,7 @@
         if self.use_bank:
             desc += "offset=%u " % self["offset"]
         chunk.description = desc+"%ux%u pixels at (%u,%u)" \
-            % (self.width, self.height, self.x, self.y)
+            % (self["width"], self["height"], self["x"], self["y"])
 
 class Image(OnDemandFilter):
     def __init__(self, stream, parent, use_bank):
@@ -62,35 +63,34 @@
 class Step(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite_item", "Sprite item", stream, parent, "<")
-        self.read("a", "???", (FormatChunk, "uint16"))
-        self.read("b", "???", (FormatChunk, "uint16"))
-        self.read("c", "???", (FormatChunk, "uint16"))
+        self.read("zero1", "???", (FormatChunk, "string[6]"))
+        assert self["zero1"] == "\0" * 6
         self.read("size", "Size in byte", (FormatChunk, "uint16"))
-        self.read("e", "???", (FormatChunk, "uint16"))
+        self.read("zero2", "???", (FormatChunk, "uint16"))
+        assert self["zero2"] == 0
         self.read("f1", "???", (FormatChunk, "uint8"))
         self.read("f2", "???", (FormatChunk, "uint8"))
         
     def updateParent(self, chunk):            
-        chunk.description = "Step: size=%s f1=%s f2=%s a=%s b=%s c=%s e=%s" % \
-            (self["size"],self["f1"],self["f2"],self["a"],self["b"],self["c"],self["e"])
+        chunk.description = "Step: size=%s f1=%s f2=%s" % \
+            (self["size"],self["f1"],self["f2"])
 
 class SpriteFrame(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "frame", "Sprite frame", stream, parent, "<")
-        self.read("offset", "???", (FormatChunk, "uint16"))
-        self.read("zero", "???", (FormatChunk, "uint8"))
-#        assert self["zero"] == 0
-        self.read("step", "???", (FormatChunk, "uint8"))
-        self.read("x", "Offset X", (FormatChunk, "uint16"))
-        self.read("y", "Offset Y", (FormatChunk, "uint16"))
+        self.read("offset", "Offset in data", (FormatChunk, "uint16"))
+        self.read("xxx", "Null or equals to 0, 1, 2, ... in Level.dir", (FormatChunk, "uint8"))
+        self.read("step", "Step", (FormatChunk, "uint8"))
+        self.read("x", "X", (FormatChunk, "uint16"))
+        self.read("y", "Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
         self.real_width = self["width"] - self["x"]
         self.real_height = self["height"] - self["y"]
 
     def updateParent(self, chunk):            
-        chunk.description = "Frame: zero=%s %ux%u bytes - %ux%u pixels at (%u,%u) offset=%s step=%s" % \
-            (self["zero"], self.real_width, self.real_height, self["width"], self["height"], self["x"], self["y"], self["offset"], self["step"])
+        chunk.description = "Frame: %ux%u bytes, %ux%u pixels at (%u,%u), offset=%s step=%s" % \
+            (self.real_width, self.real_height, self["width"], self["height"], self["x"], self["y"], self["offset"], self["step"])
 
 class Sprite(OnDemandFilter):
     def __init__(self, stream, parent, use_bank):
@@ -101,8 +101,8 @@
             self.read("zero", "Zero?", (FormatChunk, "uint16"))
             for i in range(0, self["nb_step"]):
                 self.read("step[]", "Step", (Step,))
-        self.read("x", "Offset X", (FormatChunk, "uint16"))
-        self.read("y", "Offset Y", (FormatChunk, "uint16"))
+        self.read("x", "X", (FormatChunk, "uint16"))
+        self.read("y", "Y", (FormatChunk, "uint16"))
         self.read("width", "Width", (FormatChunk, "uint16"))
         self.read("height", "Height", (FormatChunk, "uint16"))
         self.read("count", "Frame count", (FormatChunk, "uint16"))
@@ -130,9 +130,9 @@
             desc += ", %u step(s)" % (self["nb_step"])
         chunk.description = desc
 
-class TextRes(OnDemandFilter):
+class INF(OnDemandFilter):
     def __init__(self, stream, parent):
-        OnDemandFilter.__init__(self, "textres", "Text resource", stream, parent, "<")
+        OnDemandFilter.__init__(self, "inf", "INF resource", stream, parent, "<")
         for i in range(0, 6):
             self.read("line[]", "Line", (StringChunk, "WindowsLine"))
         self.read("name", "File name", (StringChunk, "WindowsLine"))
@@ -144,9 +144,9 @@
     def updateParent(self, chunk):
         chunk.description = "INF: %s" % (self["name"])
 
-class TextIndex(OnDemandFilter):
+class StringIndex(OnDemandFilter):
     def __init__(self, stream, parent, use_bank):
-        OnDemandFilter.__init__(self, "text_idx", "Text index", stream, parent, "<")
+        OnDemandFilter.__init__(self, "str_idx", "String index", stream, parent, "<")
         self.count = 0
         while True:
             name = self.doRead("name[]", "Name", (StringChunk, "WindowsLine")).value
@@ -157,13 +157,13 @@
         self.read("separator", "Separator (26)", (FormatChunk, "uint8"))
 
     def updateParent(self, chunk):
-        chunk.description = "Index: %s items" % (self.count)
+        chunk.description = "String index: %s strings" % (self.count)
 
 class BankItem(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "bank_item", "Bank item", stream, parent, "<")
-        self.x = self.doRead("x", "Offset X", (FormatChunk, "uint16")).value
-        self.y = self.doRead("y", "Offset Y", (FormatChunk, "uint16")).value
+        self.x = self.doRead("x", "X", (FormatChunk, "uint16")).value
+        self.y = self.doRead("y", "Y", (FormatChunk, "uint16")).value
         self.width = self.doRead("width", "Width", (FormatChunk, "uint16")).value
         self.height = self.doRead("height", "Height", (FormatChunk, "uint16")).value
         self.read("offset", "Offset?", (FormatChunk, "uint16"))
@@ -349,9 +349,9 @@
             has_separator = True
             if guess == "1\r\n":
                 while guess == "1\r\n":
-                    self.read("res[]", "Resource", (TextRes,))
+                    self.read("res[]", "INF", (INF,))
                     guess = stream.getN(3, False)
-                self.read("res[]", "Index", (TextIndex, use_bank))
+                self.read("res[]", "String index", (StringIndex, use_bank))
             elif guess == "BNK":
                 use_bank = True
                 has_name = False



From haypo at berlios.de  Wed Jan  4 04:53:25 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 4 Jan 2006 04:53:25 +0100
Subject: [Happyboom-svn] r394 - in haypo/hachoir/trunk: . plugins ui
Message-ID: <200601040353.k043rP7p002159@sheep.berlios.de>

Author: haypo
Date: 2006-01-04 04:53:20 +0100 (Wed, 04 Jan 2006)
New Revision: 394

Added:
   haypo/hachoir/trunk/plugins/plain_text.py
Modified:
   haypo/hachoir/trunk/mime.py
   haypo/hachoir/trunk/plugins/gzip.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/tools.py
   haypo/hachoir/trunk/ui/ui_window.py
Log:
- Create "text/plain" plugin
- Worms2: can open single .spr, .img or .fnt file
- convertDataToPrintableString display \n if keep_n=True
- Disable "format" column in interface (can be re-enable later)


Modified: haypo/hachoir/trunk/mime.py
===================================================================
--- haypo/hachoir/trunk/mime.py	2006-01-04 02:31:50 UTC (rev 393)
+++ haypo/hachoir/trunk/mime.py	2006-01-04 03:53:20 UTC (rev 394)
@@ -71,11 +71,16 @@
 def getAnotherBufferMime(buffer):    
     if buffer[:2] == "\x4d\x4d" and buffer[6:12]=="\x02\0\x0A\0\0\0":
         return "image/x-3ds"
+
     if 2<=len(buffer) and ord(buffer[0])==31 and ord(buffer[1])==139:
         return "application/x-gzip"
-    if buffer[:4] == "%PDF":
+
+    # Text
+    if buffer[0:4] == "%PDF":
         return "application/pdf"
-    if buffer[:14] == "gimp xcf file\0":
+
+    # Pictures
+    if buffer[0:14] == "gimp xcf file\0":
         return "image/x-xcf"
 
     if buffer[0:2] == "\0\0" \
@@ -87,15 +92,13 @@
     and buffer[1] in "\x00\x02\x03\x04\x05" \
     and buffer[64] == "\0":
         return "image/x-pcx"
-        
+
+    # File system        
     if 4096<=len(buffer) \
     and buffer[1080:1082]=="\x53\xEF" \
     and buffer[1116:1120]=="\x04\x00\x00\x00":
         return "hachoir/fs-ext2"
         
-    if buffer[0:3] == "DIR":
-        return "hachoir/worms2"
-        
     if 512<=len(buffer) \
     and buffer[0] in "\xEB\xFA" \
     and buffer[510:512] == "\x55\xAA" \
@@ -104,6 +107,16 @@
     and buffer[446+16*2] in "\x00\x80" \
     and buffer[446+16*3] in "\x00\x80":
         return "hachoir/master-boot-record"
+    
+    # Worms2 files
+    if buffer[0:4] == "IMG\x1A":
+        return "hachoir/worms2-image"
+    if buffer[0:4] == "SPR\x1A":
+        return "hachoir/worms2-sprite"
+    if buffer[0:4] == "FNT\x1A":
+        return "hachoir/worms2-font"
+    if buffer[0:4] == "DIR\x1A":
+        return "hachoir/worms2-directory"
     return None        
 
 def splitMimes(mimes):

Modified: haypo/hachoir/trunk/plugins/gzip.py
===================================================================
--- haypo/hachoir/trunk/plugins/gzip.py	2006-01-04 02:31:50 UTC (rev 393)
+++ haypo/hachoir/trunk/plugins/gzip.py	2006-01-04 03:53:20 UTC (rev 394)
@@ -58,7 +58,7 @@
         self.read("os", "Operating system", (EnumChunk, "uint8", GzipFile.os_name))
 
         # Optionnal fields
-        if flags["extra"] & 4 == 4:
+        if flags["extra"]:
             self.read("extra_length", "Extra length", (FormatChunk, "uint16"))
             self.read("extra", "Extra", (FormatChunk, "string[%u]"  % self["extra_length"]))
         if flags["filename"]:

Added: haypo/hachoir/trunk/plugins/plain_text.py
===================================================================
--- haypo/hachoir/trunk/plugins/plain_text.py	2006-01-04 02:31:50 UTC (rev 393)
+++ haypo/hachoir/trunk/plugins/plain_text.py	2006-01-04 03:53:20 UTC (rev 394)
@@ -0,0 +1,17 @@
+"""
+Plain text parser.
+
+Author: Victor Stinner
+"""
+
+from filter import OnDemandFilter
+from chunk import StringChunk
+from plugin import registerPlugin
+   
+class PlainTextFile(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "plain", "Plain text file", stream, parent, "<")
+        while not stream.eof():
+            self.read("line[]", "Line", (StringChunk, "AutoLine"))
+
+registerPlugin(PlainTextFile, "text/plain")

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-04 02:31:50 UTC (rev 393)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-04 03:53:20 UTC (rev 394)
@@ -95,7 +95,6 @@
 class Sprite(OnDemandFilter):
     def __init__(self, stream, parent, use_bank):
         OnDemandFilter.__init__(self, "sprite", "Sprite", stream, parent, "<")
-        name = parent.name
         self.read("nb_step", "Number of steps", (FormatChunk, "uint16"))
         if 0 < self["nb_step"]:
             self.read("zero", "Zero?", (FormatChunk, "uint16"))
@@ -294,7 +293,7 @@
         "BNK": Bank
     }
 
-    def __init__(self, stream, parent, has_name, use_bank, has_separator):
+    def __init__(self, stream, parent, has_name=True, use_bank=False, has_separator=False):
         OnDemandFilter.__init__(self, "worms2_res", "Worms2 resource", stream, parent, "<")
         guess = stream.getN(3, False)
         if guess not in Resource.tag_name:
@@ -343,16 +342,17 @@
             self.name = "(directory)"
             end = self.doRead("last_pos", "Last position", (FormatChunk, "uint32")).value
             self.count = 0
-            guess = stream.getN(3, False)
             has_name = True
             use_bank = False
             has_separator = True
-            if guess == "1\r\n":
-                while guess == "1\r\n":
+            guess = stream.getN(5, False)
+            if "\r" in guess:
+                while "\r" in guess:
                     self.read("res[]", "INF", (INF,))
-                    guess = stream.getN(3, False)
+                    guess = stream.getN(5, False)
                 self.read("res[]", "String index", (StringIndex, use_bank))
-            elif guess == "BNK":
+                return
+            elif guess.startswith("BNK"):
                 use_bank = True
                 has_name = False
             while stream.tell() < end:
@@ -414,8 +414,8 @@
         
     def updateParent(self, chunk):
         size = self.getChunk("size").getDisplayData()
-        chunk.description = "File: %s (%s)" \
-            % (self["name"], size)
+        chunk.description = "File: %s (%s), position=%s" \
+            % (self["name"], size, self["position"])
 
 class Numbers(OnDemandFilter):
     def __init__(self, stream, parent, count):
@@ -449,4 +449,5 @@
             size = stream.getRemainSize()
             self.read("fs", "File system", (FileSystem,), {"size": size})
          
-registerPlugin(Worms2_Dir_File, "hachoir/worms2")
+registerPlugin(Resource, ["hachoir/worms2-font", "hachoir/worms2-image", "hachoir/worms2-sprite"])
+registerPlugin(Worms2_Dir_File, "hachoir/worms2-directory")

Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2006-01-04 02:31:50 UTC (rev 393)
+++ haypo/hachoir/trunk/tools.py	2006-01-04 03:53:20 UTC (rev 394)
@@ -64,7 +64,6 @@
             m = re_min_repetition.match(pattern)
             if m != None:
                 repetition = int(m.group(1))
-                print "(rep=%sx%s)" % (atom_size, repetition)
                 pattern = m.group(2)
                 atom_size = atom_size * repetition
             else:
@@ -158,25 +157,16 @@
                 "\r": "\\r",
                 "\t": "\\t",
                 "\0": "\\0"}
-            if c in know:
-                if not keep_n or c != "\n":
-                    display = display + know[c]
-                else:
-                    display = display + c
+            if c == "\n" and keep_n:                
+                display = display + "\\n\n"
+            elif c in know:
+                display = display + know[c]
             else:
                 display = display + "."
+        elif c == "\"":
+            display = display + "\\\""
         else:
             display = display + c
-#            if is_8bit:
-#                if ord(c) != 0xFF:
-#                    display = display + c
-#                else:
-#                    display = display + "."
-#            else:                    
-#                if c in string.printable:
-#                    display = display + c
-#                else:
-#                    display = display + "."
     return u"\"%s\"" % display
 
 def getBacktrace():

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2006-01-04 02:31:50 UTC (rev 393)
+++ haypo/hachoir/trunk/ui/ui_window.py	2006-01-04 03:53:20 UTC (rev 394)
@@ -67,6 +67,9 @@
         self.window.connect("key-press-event", self.onKeyUp)
         self.table.connect("button_press_event", self.on_treeview_button_press_event)
         self.window.set_size_request(600,560)
+
+        self.field_show_format = False 
+        self.row_chunk_id = None
         self.build_table()
         
     def onChunkCopy(self, event):
@@ -109,7 +112,7 @@
         self.menu_close.set_sensitive(file_present)
 
     def getTableChunk(self, col):
-        chunk_id = self.table_store[col][3]
+        chunk_id = self.table_store[col][self.row_chunk_id]
         if chunk_id == None: return None
         return self.ui.hachoir.getFilter().getChunk(chunk_id)
 
@@ -133,7 +136,7 @@
 
     def clear_table(self):
         self.table_store.clear()
-        self.table_store.set_sort_column_id(-1, gtk.SORT_ASCENDING)
+#        self.table_store.set_sort_column_id(-1, gtk.SORT_ASCENDING)
         self.table.columns_autosize()
 
     def set_table_value(self, iter, column, value):
@@ -141,19 +144,31 @@
         row[column] = value
        
     def add_table_child(self, parent, addr, size, format, id, description):
-        return self.table_store.append(parent, (addr, format, size, None, id, description, None,))
+        if self.field_show_format:
+            data = (addr, format, size, None, id, description, None,)
+        else:
+            data = (addr, size, None, id, description, None,)
+        return self.table_store.append(parent, data)
        
     def update_table(self, filter, ROW, parent, addr, size, format, id, description, value):
         if filter != self.ui.hachoir.getFilter():
             return
         addr = str(addr)
         size = str(size)
-        self.table_store[ROW] = (addr, format, size, id, value, description)
+        if self.field_show_format:
+            data = (addr, format, size, id, value, description)
+        else:
+            data = (addr, size, id, value, description)
+        self.table_store[ROW] = data 
 
     def add_table(self, parent, addr, size, format, id, description, value):
         addr = str(addr)
         size = str(size)
-        return self.table_store.append(parent, (addr, format, size, id, value, description, ))
+        if self.field_show_format:
+            data = (addr, format, size, id, value, description, )
+        else:
+            data = (addr, size, id, value, description, )
+        return self.table_store.append(parent, data)
 
     def onKeyUp(self, widget, key, data=None):
         if key.keyval == gtk.keysyms.Escape:
@@ -161,14 +176,14 @@
         
     def onTableRowActivate(self, widget, iter, data=None):
         row = self.table_store[iter]
-        self.ui.on_row_click(row[3])
+        self.ui.on_row_click(row[self.row_chunk_id])
         
     def getActiveChunk(self):
         select = self.table.get_selection()
         iter = select.get_selected()[1]
         if iter != None:
             row = self.table_store[iter]
-            return self.ui.hachoir.getFilter().getChunk(row[3])
+            return self.ui.hachoir.getFilter().getChunk(row[self.row_chunk_id])
         else:
             return None 
 
@@ -177,19 +192,28 @@
         self.info.updateChunk(chunk)
 
     def build_table(self):
-        self.table_store = gtk.TreeStore(str, str, str, str, str, str)
+        types = [str, str, str, str, str]
+        if self.field_show_format:
+            types.append(str)
+        self.table_store = gtk.TreeStore(*types)
         self.table.set_model(self.table_store)
         self.table.connect("cursor-changed", self.onTableClick)
         self.table.connect("row-activated", self.onTableRowActivate)
-        self.treeview_add_column(self.table, "Address", 0)
-        self.table_store.set_sort_func(0, self.cmpColumnsLong, 0)
-        self.treeview_add_column(self.table, "Format", 1)
-        self.treeview_add_column(self.table, "Size", 2)
-        self.table_store.set_sort_func(2, self.cmpColumnsLong, 2)
-        self.treeview_add_column(self.table, "Name", 3)
-        self.treeview_add_column(self.table, "Value", 4)
-        self.treeview_add_column(self.table, "Description", 5)
-        self.table_store.set_default_sort_func(self.cmpDefault)
+
+        i = 0
+        self.treeview_add_column(self.table, "Address", i)
+#        self.table_store.set_sort_func(0, self.cmpColumnsLong, i)
+        i += 1
+        if self.field_show_format:
+            i = self.treeview_add_column(self.table, "Format", i)
+        self.treeview_add_column(self.table, "Size", i)
+#        self.table_store.set_sort_func(i, self.cmpColumnsLong, i)
+        i += 1
+        self.row_chunk_id = i
+        i = self.treeview_add_column(self.table, "Name", i)
+        i = self.treeview_add_column(self.table, "Value", i)
+        i = self.treeview_add_column(self.table, "Description", i)
+#        self.table_store.set_default_sort_func(self.cmpDefault)
         self.table.columns_autosize()
 
     def cmpDefault(self, model, a, b):
@@ -211,6 +235,7 @@
         col.add_attribute(cell, 'text', num)
         treeview.set_search_column(num)
         col.set_sort_column_id(num)
+        return num+1
 
     def on_toolbutton_purge_cache(self, widget, data=None):
         from cache import CacheList



From haypo at berlios.de  Thu Jan  5 23:36:43 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 5 Jan 2006 23:36:43 +0100
Subject: [Happyboom-svn] r395 - in haypo/hachoir/trunk: plugins ui
Message-ID: <200601052236.k05MahpS023920@sheep.berlios.de>

Author: haypo
Date: 2006-01-05 23:36:42 +0100 (Thu, 05 Jan 2006)
New Revision: 395

Modified:
   haypo/hachoir/trunk/plugins/ext2.py
   haypo/hachoir/trunk/plugins/gif.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/ui/ui_window.py
Log:
- Worms2: fix empty line reader in INF
- GIF: fix bits parsing and error handling
- User interface: use boolean to enable or not sorting with long value instead of string value


Modified: haypo/hachoir/trunk/plugins/ext2.py
===================================================================
--- haypo/hachoir/trunk/plugins/ext2.py	2006-01-04 03:53:20 UTC (rev 394)
+++ haypo/hachoir/trunk/plugins/ext2.py	2006-01-05 22:36:42 UTC (rev 395)
@@ -185,7 +185,6 @@
         end = start + blocks_per_group 
         chunk.description = "Group descriptor: blocks %s-%s" % (start, end)
     
-
 class SuperBlock(OnDemandFilter):
     error_handling = {
         1: "Continue"
@@ -352,7 +351,6 @@
         if 0 < size:
             self.read("raw[]", "Raw", (FormatChunk, "string[%u]" % size))
 
-
 class EXT2_FS(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "ext2", "EXT2 file system", stream, parent)

Modified: haypo/hachoir/trunk/plugins/gif.py
===================================================================
--- haypo/hachoir/trunk/plugins/gif.py	2006-01-04 03:53:20 UTC (rev 394)
+++ haypo/hachoir/trunk/plugins/gif.py	2006-01-05 22:36:42 UTC (rev 395)
@@ -7,7 +7,7 @@
 from filter import OnDemandFilter
 from plugin import registerPlugin
 from chunk import FormatChunk, EnumChunk, BitsChunk, BitsStruct
-from error import warning
+from error import warning, error
 from generic.image import Palette
 
 class Image(OnDemandFilter):
@@ -19,11 +19,10 @@
         self.read("height", "Height", (FormatChunk, "uint16"))
 
         bits = (
-            (1, "local_color", "Local color table"),
-            (1, "interlace", "Interlaced?"),
-            (1, "sort", "Sort"),
-            (2, "reserved", "Reserved"),
-            (3, "size_local", "Size of local color"))
+            (3, "bpp", "Bits / pixel minus one"),
+            (3, "nul", "Nul bits (0)"),
+            (1, "interlaced", "Interlaced?"),
+            (1, "local_map", "Use local color map?"))
         self.flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
 
         return
@@ -59,10 +58,10 @@
         self.read("height", "Height", (FormatChunk, "uint16"))
 
         bits = (
-            (1, "global_map", "Has global map?"),
             (3, "bpp", "Bits per pixel minus one"),
+            (1, "nul", "Nul bit (0)"),
             (3, "color_res", "Color resolution minus one"),
-            (1, "xxx", "???"))
+            (1, "global_map", "Has global map?"))
         self.flags = self.doRead("flags", "Flags", (BitsChunk, BitsStruct(bits)))
         self.bits_per_pixel = 1 + self.flags["bpp"]
 
@@ -106,9 +105,10 @@
                 return
             elif code == ";":
                 # GIF Terminator
-                return
+                break
             else:
-                raise Exception("Wrong GIF image separator: ASCII %02X." % ord(code))
-                
+                error("Wrong GIF image separator: ASCII %02X." % ord(code))
+                break
+        self.addPadding()                
 
 registerPlugin(GifFile, "image/gif")

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-04 03:53:20 UTC (rev 394)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-05 22:36:42 UTC (rev 395)
@@ -136,8 +136,8 @@
             self.read("line[]", "Line", (StringChunk, "WindowsLine"))
         self.read("name", "File name", (StringChunk, "WindowsLine"))
         self.read("line[]", "Line", (StringChunk, "WindowsLine"))
-        self.read("empty_line[]", "(empty line)", (StringChunk, "WindowsLine"))
-        self.read("empty_line[]", "(empty line)", (StringChunk, "WindowsLine"))
+        while stream.getN(2, False) == "\r\n":
+            self.read("empty_line[]", "(empty line)", (StringChunk, "WindowsLine"))
         self.read("separator", "Separator (26)", (FormatChunk, "uint8"))
 
     def updateParent(self, chunk):

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2006-01-04 03:53:20 UTC (rev 394)
+++ haypo/hachoir/trunk/ui/ui_window.py	2006-01-05 22:36:42 UTC (rev 395)
@@ -70,6 +70,7 @@
 
         self.field_show_format = False 
         self.row_chunk_id = None
+        self.sort_column_as_long = True
         self.build_table()
         
     def onChunkCopy(self, event):
@@ -136,7 +137,8 @@
 
     def clear_table(self):
         self.table_store.clear()
-#        self.table_store.set_sort_column_id(-1, gtk.SORT_ASCENDING)
+        if self.sort_column_as_long:
+            self.table_store.set_sort_column_id(-1, gtk.SORT_ASCENDING)
         self.table.columns_autosize()
 
     def set_table_value(self, iter, column, value):
@@ -202,18 +204,21 @@
 
         i = 0
         self.treeview_add_column(self.table, "Address", i)
-#        self.table_store.set_sort_func(0, self.cmpColumnsLong, i)
+        if self.sort_column_as_long:
+            self.table_store.set_sort_func(0, self.cmpColumnsLong, i)
         i += 1
         if self.field_show_format:
             i = self.treeview_add_column(self.table, "Format", i)
         self.treeview_add_column(self.table, "Size", i)
-#        self.table_store.set_sort_func(i, self.cmpColumnsLong, i)
+        if self.sort_column_as_long:
+            self.table_store.set_sort_func(i, self.cmpColumnsLong, i)
         i += 1
         self.row_chunk_id = i
         i = self.treeview_add_column(self.table, "Name", i)
         i = self.treeview_add_column(self.table, "Value", i)
         i = self.treeview_add_column(self.table, "Description", i)
-#        self.table_store.set_default_sort_func(self.cmpDefault)
+        if self.sort_column_as_long:
+            self.table_store.set_default_sort_func(self.cmpDefault)
         self.table.columns_autosize()
 
     def cmpDefault(self, model, a, b):



From haypo at berlios.de  Fri Jan  6 01:03:28 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 6 Jan 2006 01:03:28 +0100
Subject: [Happyboom-svn] r396 - in haypo/hachoir/trunk: . plugins stream
Message-ID: <200601060003.k0603S2b019385@sheep.berlios.de>

Author: haypo
Date: 2006-01-06 01:03:17 +0100 (Fri, 06 Jan 2006)
New Revision: 396

Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/stream/stream.py
Log:
- Bugfix in StringChunk: save and restore stream seed
- Bugfix in Stream: Stream.getFormat() returns array if format is an array
- Improve Worms2 plugin: Directory resource (DIR) read file system instead
  of using a lot of hacks


Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2006-01-05 22:36:42 UTC (rev 395)
+++ haypo/hachoir/trunk/chunk.py	2006-01-06 00:03:17 UTC (rev 396)
@@ -204,6 +204,7 @@
         self._stream.seek(self.addr + self._size)
         
     def _read(self, max_size):
+        oldpos = self._stream.tell()
         self._stream.seek(self.addr)
         if self._str_type == "Pascal32":
             self._stream.seek(4,1)
@@ -230,6 +231,7 @@
                 self.charset = "ascii"
                 text = StringChunk.regex_not_ascii.sub(".", text)
                 text = unicode(text, "ascii")
+        self._stream.seek(oldpos)
         return text
 
     def getValue(self, max_size=None):

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-05 22:36:42 UTC (rev 395)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-06 00:03:17 UTC (rev 396)
@@ -12,6 +12,7 @@
 from generic.image import Palette
 from text_handler import humanFilesize
 from tools import alignValue
+import re
 
 class ImageData(OnDemandFilter):
     def __init__(self, stream, parent, use_bank):
@@ -32,8 +33,6 @@
             return 12 
         oldpos = stream.tell()
         x, y, w, h, = stream.getFormat("<uint16[4]")
-        #x, y = stream.getFormat("<uint16"), stream.getFormat("<uint16")
-        #w, h = stream.getFormat("<uint16"), stream.getFormat("<uint16")
         size = 2*4 + (w-x) * (h-y)
         stream.seek(oldpos)
         return size
@@ -293,6 +292,8 @@
         "BNK": Bank
     }
 
+    regex_filename_inf = re.compile(r"^.*\.inf$")
+
     def __init__(self, stream, parent, has_name=True, use_bank=False, has_separator=False):
         OnDemandFilter.__init__(self, "worms2_res", "Worms2 resource", stream, parent, "<")
         guess = stream.getN(3, False)
@@ -338,44 +339,40 @@
                     self.read("separator", "Separator (0x1A = 26)", (FormatChunk, "uint8"))
                 #assert self["separator"] == 0x1A
         else:
+            self.count = 0
             self.read("filesize", "File size", (FormatChunk, "uint32"), {"post": humanFilesize})
             self.name = "(directory)"
-            end = self.doRead("last_pos", "Last position", (FormatChunk, "uint32")).value
-            self.count = 0
             has_name = True
             use_bank = False
             has_separator = True
-            guess = stream.getN(5, False)
-            if "\r" in guess:
-                while "\r" in guess:
-                    self.read("res[]", "INF", (INF,))
-                    guess = stream.getN(5, False)
-                self.read("res[]", "String index", (StringIndex, use_bank))
-                return
-            elif guess.startswith("BNK"):
+            self.read("size", "Directory size", (FormatChunk, "uint32"))
+            guess = stream.getN(3, False)
+            if guess == "BNK":
                 use_bank = True
                 has_name = False
-            while stream.tell() < end:
-                guess = stream.getN(4, False)
-                if guess[0:4] == "\0\0\0\0":
-                    self.read("padding", "Padding", (FormatChunk, "string[4]"))
-                elif guess[0:3] == "\0\0\0":
-                    self.read("padding", "Padding", (FormatChunk, "string[3]"))
-                elif guess[0:2] == "\0\0":
-                    self.read("padding[]", "Padding", (FormatChunk, "string[2]"))
-                elif guess[0:1] == "\0":
-                    self.read("padding[]", "Padding", (FormatChunk, "string[1]"))
-                size = end - self.getSize()
-                if use_bank and size <= 20:
-                    # TODO: Remove self.addPadding() (shouldn't work so)
-                    self.read("cdrom_str", "cdrom.spr text", (StringChunk, "C"))
-                    self.read("cdrom_a", "", (FormatChunk, "uint32"))
-                    self.read("cdrom_b", "", (FormatChunk, "uint32"))
-                    assert self.getSize() == end
-                    break                
-                self.read("res[]", "Resource", (Resource, has_name, use_bank, has_separator))
-                self.count += 1
+            fs = parent["fs"]
+            last_is_inf = False
+            for index in range(0, fs.count):
+                file = fs["file[%u]" % index]
+                self.seek(file["position"])
+                name = file["name"]
+                
+                if Resource.regex_filename_inf.match(name) != None:
+                    self.read("res[]", "INF resource", (INF,))
+                elif name == "index.txt":
+                    self.read("res[]", "String index", (StringIndex, use_bank))
+                else:
+                    self.read("res[]", "Resource", (Resource, has_name, use_bank, has_separator))
+                self.count += 1                        
+            self.addPadding()
 
+    def seek(self, pos):
+        stream = self.getStream()
+        assert stream.tell() <= pos and pos < stream.getSize()
+        size = pos - stream.tell()
+        if size != 0:
+            self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % size))
+
     def getStaticSize(stream, args):
         oldpos = stream.tell()
         tag = stream.getN(3, False)
@@ -441,7 +438,11 @@
 class Worms2_Dir_File(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "worms2_dir_file", "Worms2 directory (.dir) file", stream, parent, "<")
-        self.read("resources", "Directory", (Resource, True, None, True))
+        stream.seek(8, 1)
+        size = size = stream.getFormat("<uint32", False)
+        stream.seek(-8, 1)
+        sub = stream.createSub(size=size)
+        self.read("resources", "Directory", (Resource, True, None, True), {"stream": sub})
         if True:
             count = 1026
             self.read("numbers", "Numbers?", (Numbers, count), {"size": count*4})

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2006-01-05 22:36:42 UTC (rev 395)
+++ haypo/hachoir/trunk/stream/stream.py	2006-01-06 00:03:17 UTC (rev 396)
@@ -1,7 +1,7 @@
 import struct
 from error import StreamError
 from tools import regexMaxLength
-from format import getRealFormat, getFormatSize
+from format import getRealFormat, getFormatSize, formatIsArray
 
 class Stream:
     def __init__(self, filename):
@@ -63,7 +63,10 @@
         size = getFormatSize(format)
         real = getRealFormat(format)
         data = self.getN(size, seek)
-        return struct.unpack(real, data)[0]
+        if formatIsArray(format):
+            return struct.unpack(real, data)
+        else:
+            return struct.unpack(real, data)[0]
 
     def searchLength(self, needle, include_str, size_max=None):        
         pos = self.search(needle, size_max)



From haypo at berlios.de  Fri Jan  6 01:08:07 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 6 Jan 2006 01:08:07 +0100
Subject: [Happyboom-svn] r397 - haypo/hachoir/trunk/plugins
Message-ID: <200601060008.k06087B9021169@sheep.berlios.de>

Author: haypo
Date: 2006-01-06 01:07:53 +0100 (Fri, 06 Jan 2006)
New Revision: 397

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Small bugfix in Worms2.


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-06 00:03:17 UTC (rev 396)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-06 00:07:53 UTC (rev 397)
@@ -292,8 +292,6 @@
         "BNK": Bank
     }
 
-    regex_filename_inf = re.compile(r"^.*\.inf$")
-
     def __init__(self, stream, parent, has_name=True, use_bank=False, has_separator=False):
         OnDemandFilter.__init__(self, "worms2_res", "Worms2 resource", stream, parent, "<")
         guess = stream.getN(3, False)
@@ -351,15 +349,14 @@
                 use_bank = True
                 has_name = False
             fs = parent["fs"]
-            last_is_inf = False
             for index in range(0, fs.count):
                 file = fs["file[%u]" % index]
                 self.seek(file["position"])
                 name = file["name"]
                 
-                if Resource.regex_filename_inf.match(name) != None:
+                if name.endswith(".inf"):
                     self.read("res[]", "INF resource", (INF,))
-                elif name == "index.txt":
+                elif name.endswith("index.txt"):
                     self.read("res[]", "String index", (StringIndex, use_bank))
                 else:
                     self.read("res[]", "Resource", (Resource, has_name, use_bank, has_separator))



From haypo at berlios.de  Fri Jan  6 21:13:06 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 6 Jan 2006 21:13:06 +0100
Subject: [Happyboom-svn] r398 - haypo/hachoir/trunk/stream
Message-ID: <200601062013.k06KD60h028027@sheep.berlios.de>

Author: haypo
Date: 2006-01-06 21:13:05 +0100 (Fri, 06 Jan 2006)
New Revision: 398

Modified:
   haypo/hachoir/trunk/stream/file.py
   haypo/hachoir/trunk/stream/stream.py
Log:
Fix small bug in streams: truncate read() size in FileStream and LimitedStream
if needed.


Modified: haypo/hachoir/trunk/stream/file.py
===================================================================
--- haypo/hachoir/trunk/stream/file.py	2006-01-06 00:07:53 UTC (rev 397)
+++ haypo/hachoir/trunk/stream/file.py	2006-01-06 20:13:05 UTC (rev 398)
@@ -96,6 +96,8 @@
         
     def read(self, size, seek=True):
         if self._cache != None:
+            if self._size < self._seed + size:
+                size = self._size - self._seed
             data = self._cache.read(self._seed, size)
         else:
             self._file.seek(self._seed) ; data = self._file.read(size)

Modified: haypo/hachoir/trunk/stream/stream.py
===================================================================
--- haypo/hachoir/trunk/stream/stream.py	2006-01-06 00:07:53 UTC (rev 397)
+++ haypo/hachoir/trunk/stream/stream.py	2006-01-06 20:13:05 UTC (rev 398)
@@ -168,6 +168,9 @@
     def read(self, size, seek=True):
         """ Works like Posix read (can returns less than size bytes. """
         self._stream.seek(self._seed)
+        max = self._end - self._seed
+        if max<size:
+            size = max
         data = self._stream.read(size, seek)
         if seek:
             self._seed += len(data)



From haypo at berlios.de  Fri Jan  6 21:14:12 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 6 Jan 2006 21:14:12 +0100
Subject: [Happyboom-svn] r399 - in haypo/hachoir/trunk: . ui
Message-ID: <200601062014.k06KECPh028121@sheep.berlios.de>

Author: haypo
Date: 2006-01-06 21:14:11 +0100 (Fri, 06 Jan 2006)
New Revision: 399

Modified:
   haypo/hachoir/trunk/chunk.py
   haypo/hachoir/trunk/config.py
   haypo/hachoir/trunk/reverse.py
   haypo/hachoir/trunk/ui/hachoir.glade
   haypo/hachoir/trunk/ui/ui_popup.py
   haypo/hachoir/trunk/ui/ui_window.py
Log:
- entropy(): works on streams on not more on string
- UI: create a popup menu to compute a chunk entropy


Modified: haypo/hachoir/trunk/chunk.py
===================================================================
--- haypo/hachoir/trunk/chunk.py	2006-01-06 20:13:05 UTC (rev 398)
+++ haypo/hachoir/trunk/chunk.py	2006-01-06 20:14:11 UTC (rev 399)
@@ -27,6 +27,9 @@
         if self.post_process != None:
             self.display = self.post_process(self)
 
+    def createSubStream(self):
+        return self._parent.getStream().createSub(start=self.addr, size=self.size)
+
     def getFormat(self):
         return self.__class__.__name__
 

Modified: haypo/hachoir/trunk/config.py
===================================================================
--- haypo/hachoir/trunk/config.py	2006-01-06 20:13:05 UTC (rev 398)
+++ haypo/hachoir/trunk/config.py	2006-01-06 20:14:11 UTC (rev 399)
@@ -8,5 +8,6 @@
 verbose = False
 
 # Size of file cache (for each opened file)
-file_cache_block_size = 4096
-file_cache_block_count = 10
+file_cache_block_size = 4096  # 4 KB
+file_cache_block_count = 10   # Buffer = 10 * 4 KB
+best_stream_buffer_size = 64 * 1024  # 64 KB

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-06 20:13:05 UTC (rev 398)
+++ haypo/hachoir/trunk/reverse.py	2006-01-06 20:14:11 UTC (rev 399)
@@ -9,16 +9,25 @@
 import config
 import sys, math
 
-def entropy(raw):
-    assert 0<len(raw)
-    assert isinstance(raw, str)
+def entropy(stream):
+    assert 0 < stream.getSize()
     # Create list of 
-    count = [ 0 for i in range(0, 256) ]
-    length = len(raw)        
+    count = {}
+    for i in range(0, 256):
+        count[ chr(i) ] = 0
     p = []
-    for i in raw:
-        count[ord(i)] += 1
+    if 1024 * 1024 < stream.getSize():
+        warning("Warning: Computing entropy is slow, be patient ...")
+    stream.seek(0)
+    n = 0
+    while not stream.eof():
+        raw = stream.read(config.best_stream_buffer_size)
+        n += len(raw)
+        for i in raw:
+            count[i] = count[i] + 1
+    length = stream.getSize()
     for i in range(0,256):
+        i = chr(i)
         if count[i] != 0:
             p.append( float(count[i]) / length )
     h = 0

Modified: haypo/hachoir/trunk/ui/hachoir.glade
===================================================================
--- haypo/hachoir/trunk/ui/hachoir.glade	2006-01-06 20:13:05 UTC (rev 398)
+++ haypo/hachoir/trunk/ui/hachoir.glade	2006-01-06 20:14:11 UTC (rev 399)
@@ -1236,151 +1236,13 @@
 <widget class="GtkMenu" id="table_popup">
 
   <child>
-    <widget class="GtkImageMenuItem" id="new_chunk">
+    <widget class="GtkMenuItem" id="compute_chunk_entropy1">
       <property name="visible">True</property>
-      <property name="label" translatable="yes">_New chunk</property>
+      <property name="label" translatable="yes">Compute chunk entropy</property>
       <property name="use_underline">True</property>
-      <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image55">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-cut</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
+      <signal name="activate" handler="onComputeChunkEntropy" last_modification_time="Fri, 06 Jan 2006 16:13:47 GMT"/>
     </widget>
   </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="new_filter">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">New _filter</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image56">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-cut</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="add_string">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Add string</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onAddString" last_modification_time="Wed, 02 Nov 2005 05:30:33 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image57">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-add</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="convert">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">_Convert chunk &lt;=&gt; filter</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onConvert" last_modification_time="Wed, 02 Nov 2005 02:32:16 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image58">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-convert</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="set_format">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Set chunk _format</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image59">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-edit</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="delete_chunk">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Delete chunk</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image60">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-delete</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="copy_clipboard">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Copy to clipboard</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onCopyClipboard" last_modification_time="Wed, 23 Nov 2005 22:09:19 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image61">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-copy</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
 </widget>
 
 <widget class="GtkAboutDialog" id="about_dialog">

Modified: haypo/hachoir/trunk/ui/ui_popup.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_popup.py	2006-01-06 20:13:05 UTC (rev 398)
+++ haypo/hachoir/trunk/ui/ui_popup.py	2006-01-06 20:14:11 UTC (rev 399)
@@ -6,6 +6,7 @@
 from ui_new_string import NewStringDialog
 from format import splitFormat
 from error import error
+from reverse import entropy
 
 MAX_CHUNK_SIZE=1024 # When copy to clipboard
 
@@ -28,6 +29,13 @@
         self.delete_chunk = xml.get_widget("delete_chunk")
         self.copy_clipboard = xml.get_widget("copy_clipboard")
 
+    def onComputeChunkEntropy(self, widget):
+        assert self.chunk != None
+        stream = self.chunk.createSubStream()
+        e = entropy(stream)
+        msg = "Entropy of <i>%s</i> = <b>%.3f</b> bits/symbol" % (self.chunk.id, e)
+        self.ui.window.messageBox(msg)
+ 
     def show(self, path_info, event):
         col = path_info[0][0]
         self.chunk = self.ui.window.getTableChunk(col)
@@ -38,11 +46,11 @@
         is_format_chunk = issubclass(self.chunk.__class__, FormatChunk)
         is_string_chunk = issubclass(self.chunk.__class__, StringChunk)
         is_filter_chunk = issubclass(self.chunk.__class__, FilterChunk)
-        self.new_chunk.set_sensitive(is_format_chunk or is_string_chunk)
-        self.new_filter.set_sensitive(is_format_chunk)
-        self.add_string.set_sensitive(is_format_chunk)
-        self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
-        self.set_format.set_sensitive(is_format_chunk)
+#        self.new_chunk.set_sensitive(is_format_chunk or is_string_chunk)
+#        self.new_filter.set_sensitive(is_format_chunk)
+#        self.add_string.set_sensitive(is_format_chunk)
+#        self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
+#        self.set_format.set_sensitive(is_format_chunk)
 
         chunk_parent = self.chunk.getParent()
         if self.chunk.getParent().getParent() != None:
@@ -52,9 +60,9 @@
             #can_delete = chunks.index(self.chunk) < (len(chunk_parent)-1) or not is_format_chunk
             can_delete = not is_format_chunk
 
-        self.delete_chunk.set_sensitive(can_delete)
+#        self.delete_chunk.set_sensitive(can_delete)
         can_copy = (self.chunk.size < MAX_CHUNK_SIZE) and not is_filter_chunk
-        self.copy_clipboard.set_sensitive(can_copy)
+#        self.copy_clipboard.set_sensitive(can_copy)
         self.popup.popup( None, None, None, event.button, event.time)
 
     def onDeleteChunk(self, event):

Modified: haypo/hachoir/trunk/ui/ui_window.py
===================================================================
--- haypo/hachoir/trunk/ui/ui_window.py	2006-01-06 20:13:05 UTC (rev 398)
+++ haypo/hachoir/trunk/ui/ui_window.py	2006-01-06 20:14:11 UTC (rev 399)
@@ -72,7 +72,19 @@
         self.row_chunk_id = None
         self.sort_column_as_long = True
         self.build_table()
-        
+
+    def messageBox(self, message, markup=True):
+        dlg = gtk.MessageDialog( \
+            parent=self.window,
+            type=gtk.MESSAGE_INFO,
+            buttons=gtk.BUTTONS_OK)
+        if markup:
+            dlg.set_markup(message)
+        else:                
+            dlg.message_format = message
+        dlg.run()
+        dlg.destroy()
+ 
     def onChunkCopy(self, event):
         chunk = self.getActiveChunk()
         assert chunk != None
@@ -118,8 +130,6 @@
         return self.ui.hachoir.getFilter().getChunk(chunk_id)
 
     def on_treeview_button_press_event(self, treeview, event):
-        return
-        # TODO: Re-enable popup menu :-)
         if event.button == 3:
             x = int(event.x)
             y = int(event.y)



From haypo at berlios.de  Fri Jan  6 21:23:15 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 6 Jan 2006 21:23:15 +0100
Subject: [Happyboom-svn] r400 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601062023.k06KNFDl028897@sheep.berlios.de>

Author: haypo
Date: 2006-01-06 21:23:14 +0100 (Fri, 06 Jan 2006)
New Revision: 400

Modified:
   haypo/hachoir/trunk/plugins/worms2.py
   haypo/hachoir/trunk/reverse.py
Log:
Little bugfix in Worms2, and Worms2 add "(compressed)" in compressed image description.


Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-06 20:14:11 UTC (rev 399)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-06 20:23:14 UTC (rev 400)
@@ -52,13 +52,17 @@
         self.read("height", "Height", (FormatChunk, "uint16"))
         size = self["width"] * self["height"]
         if size <= stream.getRemainSize():
+            self.compressed = False
             self.read("img_data", "Image data: %ux%u pixels in 8 bits/pixels" % (self["width"], self["height"]), (FormatChunk, "string[%u]" % size))
+        else:
+            self.compressed = True
         self.addPadding()
 
     def updateParent(self, chunk):            
-        chunk.description = "Image: %ux%u pixels" % \
-            (self["width"], self["height"])
-
+        desc = "Image: %ux%u pixels" % (self["width"], self["height"])
+        if self.compressed:
+            desc += " (compressed)"
+        chunk.description = desc 
 class Step(OnDemandFilter):
     def __init__(self, stream, parent):
         OnDemandFilter.__init__(self, "sprite_item", "Sprite item", stream, parent, "<")
@@ -268,7 +272,7 @@
         if use_bank:
             for i in range(0, self["nb_char"]):
                 image = self["image[%u]" % i]
-                size = image.width * image.height
+                size = image["width"] * image["height"]
                 self.read("image_data[]", "Image data content", (FormatChunk, "string[%u]" % size))
         self.addPadding()
 

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-06 20:14:11 UTC (rev 399)
+++ haypo/hachoir/trunk/reverse.py	2006-01-06 20:23:14 UTC (rev 400)
@@ -6,6 +6,7 @@
 from error import error, warning
 from chunk import FormatChunk
 from default import EmptyFilter
+from tools import humanFilesize
 import config
 import sys, math
 
@@ -17,7 +18,8 @@
         count[ chr(i) ] = 0
     p = []
     if 1024 * 1024 < stream.getSize():
-        warning("Warning: Computing entropy is slow, be patient ...")
+        size = humanFilesize(stream.getSize())
+        warning("Warning: Computing entropy of %s of data is slow, please be patient ..." % size)
     stream.seek(0)
     n = 0
     while not stream.eof():



From haypo at berlios.de  Fri Jan  6 21:26:44 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 6 Jan 2006 21:26:44 +0100
Subject: [Happyboom-svn] r401 - haypo/hachoir/trunk
Message-ID: <200601062026.k06KQiXp029250@sheep.berlios.de>

Author: haypo
Date: 2006-01-06 21:26:44 +0100 (Fri, 06 Jan 2006)
New Revision: 401

Modified:
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/log.py
   haypo/hachoir/trunk/mime.py
Log:
Fix Python header (first line):
  #!/usr/bin/env python
instead of
  #!/usr/bin/python


Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2006-01-06 20:23:14 UTC (rev 400)
+++ haypo/hachoir/trunk/hachoir.py	2006-01-06 20:26:44 UTC (rev 401)
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python
 """
 Hachoir: tool to split a binary file into human readable data.
 Because it's written in Python, it would be easy to write new plugins

Modified: haypo/hachoir/trunk/log.py
===================================================================
--- haypo/hachoir/trunk/log.py	2006-01-06 20:23:14 UTC (rev 400)
+++ haypo/hachoir/trunk/log.py	2006-01-06 20:26:44 UTC (rev 401)
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python
 # -*- coding: UTF-8 -*-
 
 import time

Modified: haypo/hachoir/trunk/mime.py
===================================================================
--- haypo/hachoir/trunk/mime.py	2006-01-06 20:23:14 UTC (rev 400)
+++ haypo/hachoir/trunk/mime.py	2006-01-06 20:26:44 UTC (rev 401)
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python
 
 """
 MIME type detection using libmagic library.



From haypo at berlios.de  Sat Jan  7 12:00:22 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 7 Jan 2006 12:00:22 +0100
Subject: [Happyboom-svn] r402 - in haypo/lamer: . tool
Message-ID: <200601071100.k07B0MA2001013@sheep.berlios.de>

Author: haypo
Date: 2006-01-07 12:00:21 +0100 (Sat, 07 Jan 2006)
New Revision: 402

Modified:
   haypo/lamer/all.sh
   haypo/lamer/mod_evolution.sh
   haypo/lamer/mod_gaim.sh
   haypo/lamer/mod_gftp.sh
   haypo/lamer/mod_ncftp.sh
   haypo/lamer/mod_yafc.sh
   haypo/lamer/tool/gftp_bookmark.pl
Log:
Fix all script so they can be run from another directory.


Modified: haypo/lamer/all.sh
===================================================================
--- haypo/lamer/all.sh	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/all.sh	2006-01-07 11:00:21 UTC (rev 402)
@@ -1,4 +1,5 @@
 #!/bin/sh
-for i in `find ./ -maxdepth 1 -type f -perm -700 -name 'mod_*' | grep -v '~'`; do
-  ./$i
+DIR=$(dirname $0)
+for i in `find $DIR -maxdepth 1 -type f -perm -700 -name 'mod_*' | grep -v '~'`; do
+  $i
 done

Modified: haypo/lamer/mod_evolution.sh
===================================================================
--- haypo/lamer/mod_evolution.sh	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/mod_evolution.sh	2006-01-07 11:00:21 UTC (rev 402)
@@ -3,8 +3,7 @@
 export MOD=evolution
 IN=~/.gnome2_private/Evolution
 if [ ! -e $IN ]; then exit 0; fi
+DIR=$(dirname $0)
 
-tool/common.sh
-
-tool/evolution.pl $IN
-
+$DIR/tool/common.sh
+$DIR/tool/evolution.pl $IN

Modified: haypo/lamer/mod_gaim.sh
===================================================================
--- haypo/lamer/mod_gaim.sh	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/mod_gaim.sh	2006-01-07 11:00:21 UTC (rev 402)
@@ -2,9 +2,8 @@
 
 export MOD=gaim
 IN=~/.gaim/accounts.xml
+DIR=$(dirname $0)
 if [ ! -e $IN ]; then exit 0; fi
 
-tool/common.sh
-
-tool/gaim.pl $IN
-
+$DIR/tool/common.sh
+$DIR/tool/gaim.pl $IN

Modified: haypo/lamer/mod_gftp.sh
===================================================================
--- haypo/lamer/mod_gftp.sh	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/mod_gftp.sh	2006-01-07 11:00:21 UTC (rev 402)
@@ -2,14 +2,15 @@
 
 export MOD=gftp
 IN=~/.gftp/bookmarks
+DIR=$(dirname $0)
 DESCRAMBLE=tool/gftp_descramble
 
 if [ ! -e $IN ]; then exit 0; fi
+cd $DIR
 if [ ! -e $DESCRAMBLE ]; then
   if [ $VERBOSE ]; then echo "(call make)"; fi
   make
 fi
 
 tool/common.sh
-
 tool/gftp_bookmark.pl $IN

Modified: haypo/lamer/mod_ncftp.sh
===================================================================
--- haypo/lamer/mod_ncftp.sh	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/mod_ncftp.sh	2006-01-07 11:00:21 UTC (rev 402)
@@ -4,6 +4,7 @@
 IN=~/.ncftp/bookmarks
 
 if [ ! -e $IN ]; then exit 0; fi
-tool/common.sh
 
-tail -n +3 $IN | tool/ncftp_bookmark.pl
+DIR=$(dirname $0)
+$DIR/tool/common.sh
+tail -n +3 $IN | $DIR/tool/ncftp_bookmark.pl

Modified: haypo/lamer/mod_yafc.sh
===================================================================
--- haypo/lamer/mod_yafc.sh	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/mod_yafc.sh	2006-01-07 11:00:21 UTC (rev 402)
@@ -2,9 +2,9 @@
 
 export MOD=yafc
 IN=~/.yafc/bookmarks
-
 if [ ! -e $IN ]; then exit 0; fi
+DIR=$(dirname $0)
 
+cd $DIR
 tool/common.sh
-
 tool/yafc.pl $IN

Modified: haypo/lamer/tool/gftp_bookmark.pl
===================================================================
--- haypo/lamer/tool/gftp_bookmark.pl	2006-01-06 20:26:44 UTC (rev 401)
+++ haypo/lamer/tool/gftp_bookmark.pl	2006-01-07 11:00:21 UTC (rev 402)
@@ -20,7 +20,8 @@
     return if ($user =~ /^anonymous$/);
 
     # D?code le mode de passe
-    $pass = `tool/gftp_descramble '$pass'`;
+    $dir = '.';
+    $pass = `$dir/tool/gftp_descramble '$pass'`;
     chop $pass;
 
     # Encode l'user et pass



From haypo at berlios.de  Mon Jan  9 03:52:42 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 9 Jan 2006 03:52:42 +0100
Subject: [Happyboom-svn] r403 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601090252.k092qg9h032445@sheep.berlios.de>

Author: haypo
Date: 2006-01-09 03:52:15 +0100 (Mon, 09 Jan 2006)
New Revision: 403

Added:
   haypo/hachoir/trunk/plugins/rar.py
Modified:
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/mime.py
   haypo/hachoir/trunk/plugins/bmp.py
   haypo/hachoir/trunk/text_handler.py
Log:
- Create RAR archive parser
- Use addPadding() method in Hachoir & BmpFile classes


Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2006-01-07 11:00:21 UTC (rev 402)
+++ haypo/hachoir/trunk/hachoir_class.py	2006-01-09 02:52:15 UTC (rev 403)
@@ -70,7 +70,7 @@
         self._filter = new_filter           
         if parent == None:
             self._main_filter = self._filter
-            self._addPadding()
+            self._main_filter.addPadding()
         else:
             chunk = old_filter.filter_chunk
             chunk.setFilter(self._filter)
@@ -88,13 +88,6 @@
         my = UserFilterDescriptor(filter=self._filter)
         my.exportPython(filename)
         
-    def _addPadding(self):
-        filter_size = self._main_filter.getSize()
-        stream_size = self._main_filter.getStream().getSize()
-        diff_size = filter_size - stream_size
-        if diff_size < 0:
-            self._main_filter.read("end", "Raw data", (FormatChunk, "string[%u]" % -diff_size))
-
     def loadFile(self, filename):
         try:
             print "Load file %s" % filename
@@ -123,7 +116,7 @@
             stream.seek(0)
             filter = DefaultFilter(stream)
         self._main_filter = filter
-        self._addPadding()
+        self._main_filter.addPadding()
         self.setFilter(filter)
 
     def loadScript(self, filename):

Modified: haypo/hachoir/trunk/mime.py
===================================================================
--- haypo/hachoir/trunk/mime.py	2006-01-07 11:00:21 UTC (rev 402)
+++ haypo/hachoir/trunk/mime.py	2006-01-09 02:52:15 UTC (rev 403)
@@ -7,6 +7,7 @@
 - ftp://ftp.astron.com/pub/file/ (libmagic)
 - http://www.demonseed.net/~jp/code/magic.py (100% Python)
 - http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
+- files in /usr/share/misc/file/* (on Unix/BSD systems)
 """
 
 import os, sys, stat, string, re

Modified: haypo/hachoir/trunk/plugins/bmp.py
===================================================================
--- haypo/hachoir/trunk/plugins/bmp.py	2006-01-07 11:00:21 UTC (rev 402)
+++ haypo/hachoir/trunk/plugins/bmp.py	2006-01-09 02:52:15 UTC (rev 403)
@@ -30,7 +30,6 @@
             self.read("vertical_dpi", "Vertical DPI", (FormatChunk, "uint32"))
             self.read("used_colors", "Number of color used", (FormatChunk, "uint32"))
             self.read("important_color", "Number of import colors", (FormatChunk, "uint32"))
-        size = stream.getSize() - stream.tell()            
-        self.read("data", "Image raw data", (FormatChunk, "string[%u]" % size))
+        self.addPadding("data", "Image raw data")
 
 registerPlugin(BitmapFile, "image/x-ms-bmp")

Added: haypo/hachoir/trunk/plugins/rar.py
===================================================================
--- haypo/hachoir/trunk/plugins/rar.py	2006-01-07 11:00:21 UTC (rev 402)
+++ haypo/hachoir/trunk/plugins/rar.py	2006-01-09 02:52:15 UTC (rev 403)
@@ -0,0 +1,116 @@
+"""
+RAR archive parser.
+
+Informations source:
+---
+UniquE RAR File Library (under their license or GNU GPL license)
+The free file lib for the demoscene
+multi-OS version (Win32, Linux and SunOS)
+
+RAR decompression code:
+ (C) Eugene Roshal
+Modifications to a FileLib:
+ (C) 2000-2002 Christian Scheurer aka. UniquE/Vantage (cs at unrarlib.org)
+Linux port:
+ (C) 2000-2002 Johannes Winkelmann (jw at tks6.net)
+---
+
+Author: Victor Stinner
+Creation: 9 january 2006 
+"""
+
+from filter import OnDemandFilter
+from chunk import FormatChunk, StringChunk, BitsStruct, BitsChunk
+from plugin import registerPlugin
+from text_handler import hexadecimal, unixTimestamp, humanFilesize
+
+class MainHeader(OnDemandFilter):
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "head", "Header", stream, parent, "<")
+        self.read("crc", "CRC (16 bits)", (FormatChunk, "uint16"), {"post": hexadecimal})
+        self.read("type", "Type", (FormatChunk, "uint8"), {"post": hexadecimal})
+
+        bits = (
+            (1, "xxx", "???"),
+            (1, "comment", "Has comment"),
+            (1, "lock", "Lock (?)"),
+            (1, "solid", "Solid archive (?)"),
+            (1, "pack_comment", "Pack comment"),
+            (1, "av", "av (audio/video?)"),
+            (1, "protect", "Protect"),
+            (9, "raw", "Raw bits"),
+        )
+        self.read("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+        #self.read("flags", "Flags", (FormatChunk, "uint16"))
+        self.read("size", "Size", (FormatChunk, "uint16"))
+        self.read("reserved", "(reserved)", (FormatChunk, "uint16"))
+        self.read("reserved2", "(reserved)", (FormatChunk, "uint32"))
+
+class FileHeader(OnDemandFilter):
+    window_size = {
+        0: "64 bits",
+        1: "128 bits",
+        2: "256 bits",
+        3: "512 bits",
+        4: "1024 bits"
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "head", "Header", stream, parent, "<")
+        self.read("crc", "CRC (16 bits)", (FormatChunk, "uint16"), {"post": hexadecimal})
+        self.read("type", "Type", (FormatChunk, "uint8"), {"post": hexadecimal})
+        
+        bits = (
+            (1, "split_before", "Split before"),
+            (1, "split_after", "Split after"),
+            (1, "password", "Passowrd"),
+            (1, "comment", "Has comment?"),
+            (1, "solid", "Solid"),
+#            (3, "window_size", "Window size"),
+            (11, "raw", "Bits"),
+        )
+        self.read("flags", "Flags", (BitsChunk, BitsStruct(bits)))
+        
+        self.read("hdr_size", "Header size", (FormatChunk, "uint16"))
+        self.read("pack_size", "Pack size", (FormatChunk, "uint32"), {"post": humanFilesize})
+        self.read("unpack_size", "Unpack size", (FormatChunk, "uint32"), {"post": humanFilesize})
+        self.read("os", "Host OS", (FormatChunk, "uint8"))
+        self.read("crc32", "File CRC32", (FormatChunk, "uint32"), {"post": hexadecimal})
+        self.read("time", "File timestamp", (FormatChunk, "uint32"), {"post": unixTimestamp})
+        self.read("unp_ver", "Unpacker version(?)", (FormatChunk, "uint8"))
+        self.read("method", "Compression method", (FormatChunk, "uint8"))
+        self.read("name_len", "Name size", (FormatChunk, "uint16"))
+        self.read("file_attr", "File attributes", (FormatChunk, "uint32"))
+        self.read("name", "File name", (StringChunk, "Fixed"), {"size": self["name_len"]})
+
+    def updateParent(self, chunk):
+        chunk.description = "File: %s" % (self["name"])
+
+class RAR_File(OnDemandFilter):
+    handler = {
+        0x73: ("main_head", "Main header", (MainHeader,)),
+        0x74: ("file_head", "File header", (FileHeader,))
+    }
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "rar_file", "RAR archive file", stream, parent, "<")
+
+        # Read header:
+        # - "Rar!\x1A\x07\x00" is RAR v2.0 header
+        # - "UniquE!" is Unique RAR header (generated with UniquE RAR library?)
+        # - "\x52\x45\x7e\x5e" ("RE~^") is old header (not supported)
+        self.read("id", "RAR identifier", (FormatChunk, "string[7]"))
+        assert self["id"] in ("Rar!\x1A\x07\x00", "UniquE!")
+
+        # Read blocks
+        while not stream.eof():
+            # Read type
+            stream.seek(2, 1)
+            type = stream.getFormat("uint8", False)
+            stream.seek(-2, 1)
+            if type not in RAR_File.handler:
+                print "RAR: unknow type=%02X" % type
+                break
+            handler = RAR_File.handler[type]
+            self.read(*handler)
+        self.addPadding()
+
+registerPlugin(RAR_File, "application/x-rar")

Modified: haypo/hachoir/trunk/text_handler.py
===================================================================
--- haypo/hachoir/trunk/text_handler.py	2006-01-07 11:00:21 UTC (rev 402)
+++ haypo/hachoir/trunk/text_handler.py	2006-01-09 02:52:15 UTC (rev 403)
@@ -28,6 +28,6 @@
 
 def hexadecimal(chunk):
     size = chunk.size
-    assert size in (2, 4, 8)
+    assert size in (1, 2, 4, 8)
     pattern = "0x%0" + str(2*size) + "X"
     return pattern % chunk.value



From haypo at berlios.de  Mon Jan  9 05:26:32 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 9 Jan 2006 05:26:32 +0100
Subject: [Happyboom-svn] r404 - haypo/hachoir/trunk/plugins
Message-ID: <200601090426.k094QWaT015851@sheep.berlios.de>

Author: haypo
Date: 2006-01-09 05:26:32 +0100 (Mon, 09 Jan 2006)
New Revision: 404

Added:
   haypo/hachoir/trunk/plugins/msoffice.py
Log:
Add experimental Microsoft Word document parser.


Added: haypo/hachoir/trunk/plugins/msoffice.py
===================================================================
--- haypo/hachoir/trunk/plugins/msoffice.py	2006-01-09 02:52:15 UTC (rev 403)
+++ haypo/hachoir/trunk/plugins/msoffice.py	2006-01-09 04:26:32 UTC (rev 404)
@@ -0,0 +1,112 @@
+"""
+Microsoft Office documents parser.
+
+Informations:
+* wordole.c of AntiWord program (v0.35)
+  Copyright (C) 1998-2003 A.J. van Os
+  Released under GPL
+  http://www.winfield.demon.nl/
+
+Author: Victor Stinner
+Creation: 8 january 2005
+"""
+
+from filter import OnDemandFilter
+from chunk import FormatChunk
+from plugin import registerPlugin
+
+class BlockDepot(OnDemandFilter):
+    def __init__(self, stream, parent, count):
+        OnDemandFilter.__init__(self, "block_depot", "Block depot", stream, parent, "<")
+        self.count = count
+        assert self.count != 0
+        for index in range(0, self.count):
+            self.read("item[]", "", (FormatChunk, "uint32"))
+
+    def updateParent(self, chunk):
+        chunk.description = "Block depot: %s item(s)" % self.count
+
+class BigBlockDepot(OnDemandFilter):
+    def __init__(self, stream, parent, count):
+        OnDemandFilter.__init__(self, "bbd", "Big block depot", stream, parent, "<")
+        self.items = []
+        for i in range(0, count):
+            item = self.doRead("item[]", "", (FormatChunk, "uint32")).value
+            self.items.append(item)
+
+    def updateParent(self, chunk):
+        chunk.description = "Big block depot: %s item(s)" % len(self.items)
+
+class OLE_Document(OnDemandFilter):
+    BIG_BLOCK_SIZE = 512
+    END_OF_CHAIN = 0xfffffffe
+
+    def __init__(self, stream, parent):
+        OnDemandFilter.__init__(self, "ole_doc", "OLE document", stream, parent, "<")
+        self.read("id", "OLE object identifier", (FormatChunk, "string[4]"))
+        assert self["id"] == "\xD0\xCF\x11\xE0"
+
+        max_block = stream.getSize() / OLE_Document.BIG_BLOCK_SIZE - 2
+        assert 2 <= max_block
+        tBBDLen =  max_block + 1
+
+        # Header
+        self.seek(0x2c)
+        self.read("nb_bbd_blocks", "Number of Big Block Depot blocks", (FormatChunk, "uint32"))
+        root = self.doRead("root_start_block", "Root start block", (FormatChunk, "uint32")).value
+        self.seek(0x3c)
+        self.read("sbd_start_block", "Small Block Depot start block", (FormatChunk, "uint32"))
+        self.seek(0x44)
+        ulAdditionalBBDlist = self.doRead("add_bbd_list[]", "Additionnal BBD list", (FormatChunk, "uint32")).value
+
+        # Read first bbd
+        iToGo = self["nb_bbd_blocks"]
+        self.seek(0x4c)
+        self.bbd = []
+        bbd = self.doRead("bbd[]", "Big block depot", (BigBlockDepot, min(iToGo, 109)))
+        self.bbd.extend( bbd.items )
+        iToGo -= 109
+        start = 109
+
+        # SBL things
+#        self.seek( (root+1)*OLE_Document.BIG_BLOCK_SIZE + 0x74)
+#        self.read("sbl_start_block", "SDL start block", (FormatChunk, "uint32"))
+#        self.read("sbl_len", "SBL length", (FormatChunk, "uint32"))
+
+        # Read next bbd
+        while (ulAdditionalBBDlist != OLE_Document.END_OF_CHAIN and iToGo > 0):
+            ulBdbListStart = (ulAdditionalBBDlist + 1) * OLE_Document.BIG_BLOCK_SIZE
+            self.seek(ulBdbListStart)
+            bbd = self.doRead("bbd[]", "Big block depot", (BigBlockDepot, min(iToGo, 127)))
+            self.bbd.extend( bbd.items )
+            ulAdditionalBBDlist = self.doRead("add_bdd_list[]", "Additionnal BDD list", (FormatChunk, "uint32")).value
+            ulStart += 127;
+            iToGo -= 127;
+
+        self.bGetBBD(self.bbd, self["nb_bbd_blocks"], tBBDLen)
+
+        self.addPadding()
+
+    def bGetBBD(self, aulDepot, tDepotLen, count):
+        index = 0
+        while count != 0:
+            assert index < tDepotLen
+            pos = (aulDepot[index] + 1) * OLE_Document.BIG_BLOCK_SIZE;
+            self.seek(pos)
+
+            tDone = min(count, OLE_Document.BIG_BLOCK_SIZE / 4)
+            assert not(tDone > count)
+
+            self.read("block_depot[]", "Block depot", (BlockDepot, tDone))
+            
+            assert tDone != 0
+            count -= tDone
+            index += 1
+
+    def seek(self, to):
+        size = to - self.getStream().tell()
+        assert 0 <= size
+        if 0 < size:
+            self.read("raw[]", "Raw", (FormatChunk, "string[%u]" % size))
+
+registerPlugin(OLE_Document, "application/msword")



From haypo at berlios.de  Fri Jan 20 03:31:20 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 20 Jan 2006 03:31:20 +0100
Subject: [Happyboom-svn] r405 - in haypo/hachoir/trunk: . stream
Message-ID: <200601200231.k0K2VKLJ014339@sheep.berlios.de>

Author: haypo
Date: 2006-01-20 03:30:52 +0100 (Fri, 20 Jan 2006)
New Revision: 405

Added:
   haypo/hachoir/trunk/int_values.py
Modified:
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/hachoir_class.py
   haypo/hachoir/trunk/reverse.py
   haypo/hachoir/trunk/stream/file.py
Log:
- Check if a file is empty when loading it
- Need Python 2.4 and check Python version at startup


Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2006-01-09 04:26:32 UTC (rev 404)
+++ haypo/hachoir/trunk/hachoir.py	2006-01-20 02:30:52 UTC (rev 405)
@@ -72,6 +72,10 @@
     try:        
         print "%s version %s" % (PROGRAM, VERSION)
         print "%s\n" % WEBSITE
+
+        if sys.hexversion < 0x02040000:
+            print "Fatal error: you need Python 2.4 or greater!"
+            sys.exit(1)
     
         import imp
         plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")

Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2006-01-09 04:26:32 UTC (rev 404)
+++ haypo/hachoir/trunk/hachoir_class.py	2006-01-20 02:30:52 UTC (rev 405)
@@ -92,6 +92,11 @@
         try:
             print "Load file %s" % filename
             file = open(filename, 'r')
+            file.seek(0,2)
+            if file.tell() == 0:
+                error("Error: file \"%s\" is empty." % filename)
+                return
+            file.seek(0)
             stream = FileStream(file, filename)
         except IOError, err:
             error("Can't load file %s:\n%s" % (filename, err))

Added: haypo/hachoir/trunk/int_values.py
===================================================================
--- haypo/hachoir/trunk/int_values.py	2006-01-09 04:26:32 UTC (rev 404)
+++ haypo/hachoir/trunk/int_values.py	2006-01-20 02:30:52 UTC (rev 405)
@@ -0,0 +1,160 @@
+# 10
+# (10,12)
+# [1,2,3]
+# [1, (3,4), 6]        
+class IntValues:
+    def __init__(self, data=None):
+        self.items = None
+        self.min = None
+        self.max = None
+        if data != None:
+            self.set(data)
+
+    def __hash__(self):
+        return hash(self.items)
+
+    def hasValue(self, value):
+        return self._in(self.items, value)
+        
+    def _in(self, values, x):
+        if isinstance(values, tuple):
+            return values[0] <= x and x <= values[1]
+        elif isinstance(values, list):
+            result = 0
+            for item in values:
+                if self._in(item, x):
+                    return True
+            return False
+        elif values != None:        
+            return values == x
+        else:
+            return False
+
+    def set(self, value):
+        self.items = None
+        self.min = self.max = None
+        self.add(value)
+
+    def __str__(self):
+        return str(self.items)        
+
+    def isEmpty(self):
+        return self.items == None
+
+    def __len__(self):
+        return self._length(self.items)
+        
+    def _length(self, values):
+        if isinstance(values, tuple):
+            return values[1] - values[0] + 1
+        elif isinstance(values, list):
+            result = 0
+            for item in values:
+                result += self._length(item)
+            return result
+        elif values != None:        
+            return 1 
+        else:
+            return 0
+
+    def values(self):
+        return self._values(self.items)
+
+    def __iter__(self):
+        for x in self.values():
+            yield x
+
+    def _values(self, values):
+        if isinstance(values, tuple):
+            return range(values[0], values[1]+1)
+        elif isinstance(values, list):
+            result = []
+            for item in values:
+                result.extend( self._values(item) )
+            return result
+        elif values != None:        
+            return [values]
+        else:
+            return []
+
+    def add(self, new):
+        if isinstance(new, IntValues):
+            new = new.items
+
+        # TODO: Fix that!
+        if isinstance(new, int):
+            if self.min == None or new < self.min:
+                self.min = new
+            if self.max == None or new > self.max:
+                self.max = new
+        elif isinstance(new, tuple):
+            if self.min == None or new[0] < self.min:
+                self.min = new[0]
+            if self.max == None or new[1] > self.max:
+                self.max = new[1]
+
+        if isinstance(self.items, tuple):
+            if isinstance(new, tuple):
+                if self.items[0] <= new[0] and new[1] <= self.items[1]:
+                    return
+                assert False # TODO: Finish ..
+            elif isinstance(new, int):
+                if (new - self.items[1]) == 1:
+                    self.items = (self.items[0], new)
+                else:
+                    self.items = [self.items, new]
+            else:            
+                assert False # TODO: Finish ..
+            return
+        elif isinstance(self.items, list):
+            for index in range(0, len(self.items)):
+                item = self.items[index]
+                if item == new:
+                    return
+                print "two"
+                if isinstance(item, int) and new < item:
+                    self.items.insert(index-1, new)
+                    return
+                if isinstance(item, tuple) and (new-item[1])==1:
+                    self.items[index] = (item[0], new)
+                    return
+                if isinstance(new, tuple) and new[1] < item:
+                    self.items.insert(index-1, new)
+                    return
+
+            # Can create an interval?
+            item = self.items[-1]
+            if isinstance(item, int) and isinstance(new, int) and (new-item) == 1:
+                self.items[-1] = (item, new)
+                return
+
+            if isinstance(new, list):
+                # Extend current vector
+                for item in new:
+                    self.add(item)
+            else:
+                # Just append value to vector
+                self.items.append(new)
+        elif self.items != None:        
+            if isinstance(self.items, int):
+                if isinstance(new, int):
+                    if (self.items-new) == 1:
+                        self.items = (new, self.items)
+                        return
+                    elif (self.items-new) == -1:
+                        self.items = (self.items, new)
+                        return
+            self.items = [self.items]
+            self.add(new)
+        else:
+            self.items = new
+
+    def intersection(self, second):
+        first = set( self.values() ) 
+        second = set( second.values() )
+        result = first.intersection(second)
+        if 0 < len(result):
+            result = list(result)
+        else:
+            result = None
+        return IntValues(result)

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-09 04:26:32 UTC (rev 404)
+++ haypo/hachoir/trunk/reverse.py	2006-01-20 02:30:52 UTC (rev 405)
@@ -1,14 +1,12 @@
-from stream.file import FileStream
-from plugins.worms2 import Worms2_Dir_File
-from plugins.gzip import GzipFile
 from format import getFormatSize, getFormatEndian
-from bits import countBits, long2bin, str2hex
+from bits import countBits
 from error import error, warning
 from chunk import FormatChunk
 from default import EmptyFilter
 from tools import humanFilesize
+from int_values import IntValues
 import config
-import sys, math
+import math
 
 def entropy(stream):
     assert 0 < stream.getSize()
@@ -81,155 +79,7 @@
             stream.seek(last_ok)
             filter.addPadding()
             return filter
-        
-class IntValues:
-    def __init__(self, data=None):
-        self.items = None
-        self.min = None
-        self.max = None
-        if data != None:
-            self.set(data)
 
-    def __hash__(self):
-        return hash(self.items)
-
-    def hasValue(self, value):
-        return self._in(self.items, value)
-        
-    def _in(self, values, x):
-        if isinstance(values, tuple):
-            return values[0] <= x and x <= values[1]
-        elif isinstance(values, list):
-            result = 0
-            for item in values:
-                if self._in(item, x):
-                    return True
-            return False
-        elif values != None:        
-            return values == x
-        else:
-            return False
-
-    def set(self, value):
-        self.items = None
-        self.min = self.max = None
-        self.add(value)
-
-    def __str__(self):
-        return str(self.items)        
-
-    def isEmpty(self):
-        return self.items == None
-
-    def __len__(self):
-        return self._length(self.items)
-        
-    def _length(self, values):
-        if isinstance(values, tuple):
-            return values[1] - values[0] + 1
-        elif isinstance(values, list):
-            result = 0
-            for item in values:
-                result += self._length(item)
-            return result
-        elif values != None:        
-            return 1 
-        else:
-            return 0
-
-    def values(self):
-        return self._values(self.items)
-        
-    def _values(self, values):
-        if isinstance(values, tuple):
-            return range(values[0], values[1]+1)
-        elif isinstance(values, list):
-            result = []
-            for item in values:
-                result.extend( self._values(item) )
-            return result
-        elif values != None:        
-            return [values]
-        else:
-            return []
-
-    def add(self, new):
-        if isinstance(new, IntValues):
-            new = new.items
-
-        # TODO: Fix that!
-        if isinstance(new, int):
-            if self.min == None or new < self.min:
-                self.min = new
-            if self.max == None or new > self.max:
-                self.max = new
-        elif isinstance(new, tuple):
-            if self.min == None or new[0] < self.min:
-                self.min = new[0]
-            if self.max == None or new[1] > self.max:
-                self.max = new[1]
-
-        if isinstance(self.items, tuple):
-            if isinstance(new, tuple):
-                if self.items[0] <= new[0] and new[1] <= self.items[1]:
-                    return
-                assert False # TODO: Finish ..
-            elif isinstance(new, int):
-                if (new - self.items[1]) == 1:
-                    self.items = (self.items[0], new)
-                else:
-                    self.items = [self.items, new]
-            else:            
-                assert False # TODO: Finish ..
-            return
-        elif isinstance(self.items, list):
-            for index in range(0, len(self.items)):
-                item = self.items[index]
-                if item == new:
-                    return
-                if isinstance(item, int) and new < item:
-                    self.items.insert(index-1, new)
-                    return
-                if isinstance(item, tuple) and (new-item[1])==1:
-                    self.items[index] = (item[0], new)
-                    return
-
-            # Can create an interval?
-            item = self.items[-1]
-            if isinstance(item, int) and (new-item) == 1:
-                self.items[-1] = (item, new)
-                return
-
-            if isinstance(new, list):
-                # Extend current vector
-                for item in new:
-                    self.add(item)
-            else:
-                # Just append value to vector
-                self.items.append(new)
-        elif self.items != None:        
-            if isinstance(self.items, int) and isinstance(new, int):
-                if (self.items-new) == 1:
-                    self.items = (new, self.items)
-                    return
-                elif (self.items-new) == -1:
-                    self.items = (self.items, new)
-                    return
-            self.items = [self.items]
-            self.add(new)
-        else:
-            self.items = new
-
-    def intersection(self, second):
-        first = set( self.values() ) 
-        second = set( second.values() )
-        result = first.intersection(second)
-        if 0 < len(result):
-            result = list(result)
-        else:
-            result = None
-        return IntValues(result)
-
 class Field:
     def __init__(self, id, type):
         self.id = id    

Modified: haypo/hachoir/trunk/stream/file.py
===================================================================
--- haypo/hachoir/trunk/stream/file.py	2006-01-09 04:26:32 UTC (rev 404)
+++ haypo/hachoir/trunk/stream/file.py	2006-01-20 02:30:52 UTC (rev 405)
@@ -79,6 +79,8 @@
             self._file.seek(0,2) # Seek to end
             self._size = self._file.tell()
             self._file.seek(0,0) # Seel to beginning
+            if self._size == 0:
+                raise Exception("Error: file %s is empty!" % filename)
             self._seed = 0
             if self._size != 0:
                 self._end = self._size-1



From haypo at berlios.de  Fri Jan 20 03:49:49 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 20 Jan 2006 03:49:49 +0100
Subject: [Happyboom-svn] r406 - in haypo/hachoir/trunk: . plugins
Message-ID: <200601200249.k0K2nnwC018874@sheep.berlios.de>

Author: haypo
Date: 2006-01-20 03:48:56 +0100 (Fri, 20 Jan 2006)
New Revision: 406

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/plugins/3ds.py
   haypo/hachoir/trunk/plugins/ext2.py
   haypo/hachoir/trunk/plugins/worms2.py
Log:
Use new python (2.4) decorator: @staticmethod


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-20 02:30:52 UTC (rev 405)
+++ haypo/hachoir/trunk/filter.py	2006-01-20 02:48:56 UTC (rev 406)
@@ -24,9 +24,9 @@
         self._endian = endian
         self.filter_chunk = None
 
+    @staticmethod
     def getStaticSize(stream, args):
         return None
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk): pass
     def getId(self): return self._id

Modified: haypo/hachoir/trunk/plugins/3ds.py
===================================================================
--- haypo/hachoir/trunk/plugins/3ds.py	2006-01-20 02:30:52 UTC (rev 405)
+++ haypo/hachoir/trunk/plugins/3ds.py	2006-01-20 02:48:56 UTC (rev 406)
@@ -27,9 +27,9 @@
         self.read("u", "Map U", (FormatChunk, "float"))
         self.read("v", "Map V", (FormatChunk, "float"))
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 4*2
-    getStaticSize = staticmethod(getStaticSize)
  
 class Filter_3DS_Vertex(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -38,9 +38,9 @@
         self.read("y", "Y", (FormatChunk, "float"))
         self.read("z", "Z", (FormatChunk, "float"))
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 4*3
-    getStaticSize = staticmethod(getStaticSize)
 
 class Filter_3DS_Polygon(OnDemandFilter):
     def __init__(self, stream, parent):
@@ -50,9 +50,9 @@
         self.read("c", "Vertex C", (FormatChunk, "uint16"))
         self.read("flags", "Flags", (FormatChunk, "uint16"))
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 4*2
-    getStaticSize = staticmethod(getStaticSize)
     
 def readMapList(filter, stream, last_pos):
     filter.read("count", "Map count", (FormatChunk, "uint16"))

Modified: haypo/hachoir/trunk/plugins/ext2.py
===================================================================
--- haypo/hachoir/trunk/plugins/ext2.py	2006-01-20 02:30:52 UTC (rev 405)
+++ haypo/hachoir/trunk/plugins/ext2.py	2006-01-20 02:48:56 UTC (rev 406)
@@ -95,9 +95,9 @@
         else:
             self.read("raw", "Reserved", (FormatChunk, "string[12]"))
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 68 + 15*4
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
         desc = "Inode %s: " % self.index
@@ -174,9 +174,9 @@
         self.read("padding", "Padding", (FormatChunk, "uint16"))
         self.read("reserved", "Reserved", (FormatChunk, "string[12]"))
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 32
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
         superblock = self.getParent().getParent().superblock
@@ -257,9 +257,9 @@
         blocks_per_group = self["blocks_per_group"]
         self.group_count = (self["blocks_count"] - self["first_data_block"] + (blocks_per_group - 1)) / blocks_per_group
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 433
-    getStaticSize = staticmethod(getStaticSize)
  
     def updateParent(self, chunk):
         if self["feature_compat"] & 4 == 4:

Modified: haypo/hachoir/trunk/plugins/worms2.py
===================================================================
--- haypo/hachoir/trunk/plugins/worms2.py	2006-01-20 02:30:52 UTC (rev 405)
+++ haypo/hachoir/trunk/plugins/worms2.py	2006-01-20 02:48:56 UTC (rev 406)
@@ -28,6 +28,7 @@
             size = (self["width"]-self["x"]) * (self["height"]-self["y"])
             self.read("data", "Image content", (FormatChunk, "string[%u]" % size))
 
+    @staticmethod
     def getStaticSize(stream, args):
         if args[0] == True:
             return 12 
@@ -36,7 +37,6 @@
         size = 2*4 + (w-x) * (h-y)
         stream.seek(oldpos)
         return size
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
         desc = "Image data: " 
@@ -171,9 +171,9 @@
         self.read("offset", "Offset?", (FormatChunk, "uint16"))
         self.read("xxx", "???", (FormatChunk, "uint16"))
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 12 
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
         desc = "Bank item: " 
@@ -191,9 +191,9 @@
         self.read("zero", "Zero", (FormatChunk, "string[6]"))
         assert self["zero"] == "\0" * 6 
 
+    @staticmethod
     def getStaticSize(stream, args):
         return 12 
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
         chunk.description = "Bank item2: size=%s offset=%s step=%s" % (self["size"], self["offset"], self["step"])
@@ -205,12 +205,12 @@
         for i in range(0, self.count):
             self.read("item[]", "Item", chunk_info)
 
+    @staticmethod
     def getStaticSize(stream, args):
         size = args[0][0].getStaticSize(stream, [])
         count = args[1]
         assert size != None
         return count * size
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):
         chunk.description = "Big Bank: %s items" % (self.count)
@@ -374,6 +374,7 @@
         if size != 0:
             self.read("padding[]", "Padding", (FormatChunk, "string[%u]" % size))
 
+    @staticmethod
     def getStaticSize(stream, args):
         oldpos = stream.tell()
         tag = stream.getN(3, False)
@@ -387,7 +388,6 @@
             size = stream.getFormat("<uint32")
         stream.seek(oldpos)
         return size
-    getStaticSize = staticmethod(getStaticSize)
 
     def updateParent(self, chunk):            
         if self["tag"] != "DIR":



From haypo at berlios.de  Fri Jan 20 04:44:01 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 20 Jan 2006 04:44:01 +0100
Subject: [Happyboom-svn] r407 - haypo/hachoir/trunk
Message-ID: <200601200344.k0K3i1hq005689@sheep.berlios.de>

Author: haypo
Date: 2006-01-20 04:43:57 +0100 (Fri, 20 Jan 2006)
New Revision: 407

Modified:
   haypo/hachoir/trunk/filter.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/reverse.py
Log:
Clean up code using pylint


Modified: haypo/hachoir/trunk/filter.py
===================================================================
--- haypo/hachoir/trunk/filter.py	2006-01-20 02:48:56 UTC (rev 406)
+++ haypo/hachoir/trunk/filter.py	2006-01-20 03:43:57 UTC (rev 407)
@@ -2,19 +2,18 @@
 Base class for all splitter filters.
 """
 
-import struct, re, sys, string, types
+import re
 import config
 import ui.ui as ui
-from chunk import Chunk, FormatChunk, FilterChunk, StringChunk, BitsChunk
+from chunk import FormatChunk, FilterChunk, BitsChunk
 from error import error
-from format import getFormatSize, splitFormat
 from cache import Cache
 
 class BasicFilter(object):
     regex_chunk_uniq_id = re.compile("^(.*?)([0-9]+)$")
 
-    def __init__(self, id, description, stream, parent, addr, endian):
-        self._id = id
+    def __init__(self, identifier, description, stream, parent, addr, endian):
+        self._id = identifier
         self._description = description
         self._stream = stream
         self._parent = parent
@@ -28,23 +27,34 @@
     def getStaticSize(stream, args):
         return None
 
-    def updateParent(self, chunk): pass
-    def getId(self): return self._id
-    def setId(self, id):
-        if self._id == id:
+    def updateParent(self, chunk):
+        pass
+    def getId(self):
+        return self._id
+    def setId(self, identifier):
+        if self._id == identifier:
             return
-        self._id = id
+        self._id = identifier
         if self.filter_chunk != None:
-            self.filter_chunk.id = id
-    def getDescription(self): return self._description
-    def setDescription(self, description): self._description = description
-    def getAddr(self): return self._addr
-    def getParent(self): return self._parent
-    def getStream(self): return self._stream
-    def updateChunkId(self, old_id, new_id): pass
-    def updateChunkDescription(self, id, desc): pass
-    def updateChunkDisplay(self, id): pass
-    def __len__(self): return len(self._chunks_dict)
+            self.filter_chunk.id = identifier
+    def getDescription(self):
+        return self._description
+    def setDescription(self, description):
+        self._description = description
+    def getAddr(self):
+        return self._addr
+    def getParent(self):
+        return self._parent
+    def getStream(self):
+        return self._stream
+    def updateChunkId(self, old_id, new_id):
+        pass
+    def updateChunkDescription(self, identifier, desc):
+        pass
+    def updateChunkDisplay(self, identifier):
+        pass
+    def __len__(self):
+        return len(self._chunks_dict)
 
     def getPath(self):
         """
@@ -54,7 +64,8 @@
         text = ""
         current = self
         while current != None:
-            if text != "": text = "/" + text
+            if text != "":
+                text = "/" + text
             text = current.getId() + text
             current = current.getParent()
         return "/"+text
@@ -66,24 +77,24 @@
             self._chunks_counter[root] = index
         return self._chunks_counter[root]
 
-    def getUniqChunkId(self, id):
+    def getUniqChunkId(self, identifier):
         # No collision
-        if id not in self._chunks_dict and id[-2:] != "[]":
-            return id
+        if identifier not in self._chunks_dict and identifier[-2:] != "[]":
+            return identifier
 
         # Pattern like "block[]"
-        if id[-2:] == "[]":
-            root = id[:-2]
+        if identifier[-2:] == "[]":
+            root = identifier[:-2]
             start = 0
             pattern = "%s[%u]"
         else:
-            # Manage id collision
-            m = BasicFilter.regex_chunk_uniq_id.match(id)
+            # Manage identifier collision
+            m = BasicFilter.regex_chunk_uniq_id.match(identifier)
             if m != None:
                 root = m.group(1)
                 start = int(m.group(2)) + 1
             else:
-                root = id
+                root = identifier
                 start = 2
             pattern = "%s%u"
         if root in self._chunks_counter:
@@ -92,27 +103,34 @@
             self._chunks_counter[root] = start 
         return pattern % (root, self._chunks_counter[root])
         
-    def hasChunk(self, id):
-        return id in self._chunks_dict
+    def hasChunk(self, identifier):
+        return identifier in self._chunks_dict
 
-    def _getEndian(self): return self._endian
+    def _getEndian(self):
+        return self._endian
     endian = property(_getEndian)
 
-    def addPadding(self, id="end", description="Raw end"):
+    def addPadding(self, identifier="end", description="Raw end"):
         size = self._stream.getRemainSize()
         if 0 < size:
-            self.read(id, description, (FormatChunk, "string[%u]" % size))
+            self.read(identifier, description, \
+                (FormatChunk, "string[%u]" % size))
 
     # --- Pure virtual methods -----------
-    def getSize(self): todoWriteMethod(self, "getSize") 
-    def __getitem__(self, chunk_id): todoWriteMethod(self, "__getitem__") 
-    def getChunk(self, chunk_id): todoWriteMethod(self, "getChunk")
-    def display(self): todoWriteMethod(self, "display")
+    def getSize(self):
+        todoWriteMethod(self, "getSize") 
+    def __getitem__(self, chunk_id):
+        todoWriteMethod(self, "__getitem__") 
+    def getChunk(self, chunk_id):
+        todoWriteMethod(self, "getChunk")
+    def display(self):
+        todoWriteMethod(self, "display")
 
 class OnDemandFilter(BasicFilter, Cache):
-    def __init__(self, id, description, stream, parent, endian=None):
-        BasicFilter.__init__(self, id, description, stream, parent, stream.tell(), endian)
-        Cache.__init__(self, "Filter %s" % id)
+    def __init__(self, identifier, description, stream, parent, endian=None):
+        BasicFilter.__init__(self, identifier, description, stream, parent, \
+            stream.tell(), endian)
+        Cache.__init__(self, "Filter %s" % identifier)
         self._size = 0
         self._chunks = []
         self._chunks_cache = {}
@@ -141,31 +159,31 @@
         # Update display
         self.updateChunkDisplay(new_id)
 
-    def updateChunkDisplay(self, id):
+    def updateChunkDisplay(self, identifier):
         if ui.ui == None:
             return
-        pos = self._chunks.index(id)
+        pos = self._chunks.index(identifier)
         assert pos != -1
-        info = self.displayChunkInfo(id)
+        info = self.displayChunkInfo(identifier)
         ui.window.update_table(self, pos, *info)
 
-    def updateChunkDescription(self, id, desc):
-        pos = self._chunks.index(id)
+    def updateChunkDescription(self, identifier, desc):
+        pos = self._chunks.index(identifier)
         assert pos != -1
-        self._chunks_dict[id][1] = desc
-        self.updateChunkDisplay(id)
+        self._chunks_dict[identifier][1] = desc
+        self.updateChunkDisplay(identifier)
 
     def purgeCache(self):
         if len(self._chunks_cache) != 0 and config.verbose:
             print "Purge cache: destroy %s chunks" % len(self._chunks_cache)
         self._chunks_cache = {}
         
-    def read(self, id, description, info, optionnal={}): 
-        self._read(id, description, info, optionnal, False)
+    def read(self, identifier, description, info, optionnal={}): 
+        self._read(identifier, description, info, optionnal, False)
 
-    def _read(self, id, description, info, optionnal, instanciate):
+    def _read(self, identifier, description, info, optionnal, instanciate):
         chunk_class = info[0]
-        id = self.getUniqChunkId(id)
+        identifier = self.getUniqChunkId(identifier)
         addr = self._stream.tell()
         if issubclass(chunk_class, BasicFilter):
             filter_stream = optionnal.get("stream", self._stream)
@@ -177,21 +195,22 @@
             if instanciate or size == None:
                 filter = chunk_class(filter_stream, self, *args)
                 description = filter.getDescription()
-                filter.setId(id)
-                chunk = FilterChunk(id, filter, self, addr)
+                filter.setId(identifier)
+                chunk = FilterChunk(identifier, filter, self, addr)
                 size = filter.getSize()
                 if config.verbose:
-                    print "%s: Instanciate filter %s" % (self.getPath(), id)
+                    print "%s: Instanciate filter %s" % \
+                        (self.getPath(), identifier)
             else:
                 chunk = None
 
-            chunk_info = [id, description, addr, size, \
+            chunk_info = [identifier, description, addr, size, \
                     (chunk_class, filter_stream, filter_addr, args), None, {}]
-            self._chunks_dict[id] = chunk_info
-            self._chunks.append(id)
+            self._chunks_dict[identifier] = chunk_info
+            self._chunks.append(identifier)
             if chunk != None:
                 filter.updateParent(chunk)
-                self._chunks_cache[id] = chunk
+                self._chunks_cache[identifier] = chunk
             self._size = self._size + size
             self._stream.seek(addr + size)
         else:
@@ -202,7 +221,9 @@
                 args = info[1:]
             else:
                 args = [ i for i in info[1:] ]
-            instance_info = [info[0], id, description, self._stream]+args+[self]
+            instance_info  = [info[0], identifier, description, self._stream]
+            instance_info += args
+            instance_info += [self]
 
             if not instanciate:
                 size = chunk_class.getStaticSize(self._stream, info[1:])
@@ -215,32 +236,33 @@
                 seek = False
                 chunk = info[0] (*instance_info[1:], **optionnal)
                 size = chunk.size
-                id = chunk.id
-                self._chunks_cache[id] = chunk
-            chunk_info = [id, description, addr, size, instance_info, post, optionnal]
-            self._chunks_dict[id] = chunk_info
-            self._chunks.append(id)
+                identifier = chunk.id
+                self._chunks_cache[identifier] = chunk
+            chunk_info = [identifier, description, addr, size, \
+                instance_info, post, optionnal]
+            self._chunks_dict[identifier] = chunk_info
+            self._chunks.append(identifier)
             self._size = self._size + size
         if instanciate:
             return chunk
         else:
-            return id
+            return identifier
 
-    def doRead(self, id, description, info, optionnal={}):
-        chunk = self._read(id, description, info, optionnal, True)
+    def doRead(self, identifier, description, info, optionnal={}):
+        chunk = self._read(identifier, description, info, optionnal, True)
         if isinstance(chunk, FilterChunk):
             return chunk.getFilter()
         else:
             return chunk
 
-    def displayChunkInfo(self, id):
-        info = self._chunks_dict[id]
+    def displayChunkInfo(self, identifier):
+        info = self._chunks_dict[identifier]
         chunk_class = info[4][0]
         if issubclass(chunk_class, BasicFilter):
             display = "(...)"
             format = chunk_class.__name__
         else:
-            chunk = self.getChunk(id)
+            chunk = self.getChunk(identifier)
             display = chunk.getDisplayData()
             format = chunk.getSmallFormat()
         addr = info[2]
@@ -250,25 +272,26 @@
     def display(self):
         ui.window.enableParentButton(self.getParent() != None)
         ui.window.clear_table()
-        for id in self._chunks:
-            info = self.displayChunkInfo(id)
-            if self._chunks_dict[id][4][0] == BitsChunk:
-                self.getChunk(id).uiDisplay(ui.window)
+        for identifier in self._chunks:
+            info = self.displayChunkInfo(identifier)
+            if self._chunks_dict[identifier][4][0] == BitsChunk:
+                self.getChunk(identifier).uiDisplay(ui.window)
             else:
                 ui.window.add_table(*info)
  
     def getSize(self): return self._size
 
-    def _createInstance(self, id):
-        description = self._chunks_dict[id][1]
-        addr = self._chunks_dict[id][2]
-        size = self._chunks_dict[id][3]
-        desc = self._chunks_dict[id][4]
-        post = self._chunks_dict[id][5]
-        chunks_kw = self._chunks_dict[id][6]
+    def _createInstance(self, identifier):
+        description = self._chunks_dict[identifier][1]
+        addr = self._chunks_dict[identifier][2]
+        size = self._chunks_dict[identifier][3]
+        desc = self._chunks_dict[identifier][4]
+        post = self._chunks_dict[identifier][5]
+        chunks_kw = self._chunks_dict[identifier][6]
         oldpos = self._stream.tell()
         if config.verbose:
-            print "%s: Instanciate %s (of type %s)" % (self.getPath(), id, desc[0].__name__)
+            print "%s: Instanciate %s (of type %s)" % \
+                (self.getPath(), identifier, desc[0].__name__)
         if not issubclass(desc[0], BasicFilter):
             # Chunk
             chunk_class = desc[0]
@@ -286,39 +309,40 @@
                 self._stream.seek(addr)
             try:
                 filter = desc[0] (filter_stream, self, *desc[3])
-                filter.setId(id)
-                chunk = FilterChunk(id, filter, self, addr)
+                filter.setId(identifier)
+                chunk = FilterChunk(identifier, filter, self, addr)
                 if filter.getDescription() != desc[1]:
-                    self.updateChunkDescription(id, filter.getDescription())
+                    self.updateChunkDescription(identifier, filter.getDescription())
                 filter.updateParent(chunk)
             except Exception, msg:
-                error("Error when loading filter %s: %s" % (id, msg))
+                error("Error when loading filter %s: %s" % (identifier, msg))
                 if filter_stream != self._stream:
                     filter_stream.seek(desc[2])
                 else:
                     self._stream.seek(addr)
                 if isinstance(size, int) or isinstance(size, long):
-                    self._chunks_dict[id][4] = (FormatChunk, id, description, filter_stream, "string[%u]" % size, self)
-                    self._chunks_dict[id][5] = None
-                    self._chunks_dict[id][6] = {}
-                    self.updateChunkDisplay(id)
-                    return self._createInstance(id)
+                    self._chunks_dict[identifier][4] = (FormatChunk, identifier, description, \
+                        filter_stream, "string[%u]" % size, self)
+                    self._chunks_dict[identifier][5] = None
+                    self._chunks_dict[identifier][6] = {}
+                    self.updateChunkDisplay(identifier)
+                    return self._createInstance(identifier)
         self._stream.seek(oldpos)
         return chunk
 
-    def getChunk(self, id):
-        if id not in self._chunks_dict:
+    def getChunk(self, identifier):
+        if identifier not in self._chunks_dict:
             return None
-        if id not in self._chunks_cache:
-            chunk = self._createInstance(id) 
+        if identifier not in self._chunks_cache:
+            chunk = self._createInstance(identifier) 
             self._chunks_cache[chunk.id] = chunk 
             return chunk
         else:
-            return self._chunks_cache[id]
+            return self._chunks_cache[identifier]
 
-    def __getitem__(self, id):
-        assert id in self._chunks_dict
-        chunk = self.getChunk(id)
+    def __getitem__(self, identifier):
+        assert identifier in self._chunks_dict
+        chunk = self.getChunk(identifier)
         if isinstance(chunk.__class__, FilterChunk):
             return chunk.getFilter()
         else:

Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2006-01-20 02:48:56 UTC (rev 406)
+++ haypo/hachoir/trunk/hachoir.py	2006-01-20 03:43:57 UTC (rev 407)
@@ -7,7 +7,7 @@
 Author: Victor Stinner
 """
 
-import sys, os, re, traceback
+import sys, os, re
 import config
 from program import PROGRAM, VERSION, WEBSITE
 from log import log
@@ -15,56 +15,67 @@
 from hachoir_class import Hachoir
 import ui.ui as ui
 
-def usage(defval):
+def usage():
     print "%s version %s" % (PROGRAM, VERSION)
     print "%s\n" % WEBSITE
     print "Usage: %s [options] file" % (sys.argv[0])
     print ""
     print "Options:"
-    print "\t--script file.py  : Load python script after loading file (if any specified)"
-    print "\t--no-ui           : Don't load user interface"
-    print "\t--use-profiler    : Use profiler"
-    print "\t--version         : Show the program version"
-    print "\t--verbose         : Activate verbose mode"
-    print "\t--help            : Show this help"
-    print "\t--debug           : Enable debug mode (eg. display backtrace)"
+    options = ( \
+        ("script file.py", (
+            "Load python script after loading file",
+            "(if any specified)")),
+        ("no-ui", "Don't load user interface"),
+        ("use-profiler", "Use profiler"),
+        ("version", "Show the program version"),
+        ("verbose", "Activate verbose mode"),
+        ("help", "Show this help"),
+        ("debug", "Enable debug mode (eg. display backtrace)")
+    )
+    width = max([len(option[0]) for option in options])
+    for opt in options:
+        if isinstance(opt[1], tuple):
+            print "   --%s : %s" % (opt[0].ljust(width), opt[1][0])
+            for line in opt[1][1:]:
+                print "   %s%s" % (" " * (width+5), line)
+        else:
+            print "   --%s : %s" % (opt[0].ljust(width), opt[1])
 
 def parseArgs(val):
     import getopt
-    def_val = val.copy()
-    
     try:
-        short = ""
-        long = ["verbose", "help", "version", "script=", "no-ui", "debug", "use-profiler"]
-        opts, args = getopt.getopt(sys.argv[1:], short, long)
+        allowed = ( \
+            "verbose", "help", "version", "debug",
+            "script=", "no-ui", "use-profiler")
+        opts, args = getopt.getopt(sys.argv[1:], "", allowed)
     except getopt.GetoptError:
-        usage(def_val)
+        usage()
         sys.exit(2)
    
     if 1 < len(args):
-        usage(def_val)
+        usage()
         sys.exit(2)
     if len(args) == 1:
         filename = args[0]
     else:
         filename = None
         
-    for o, a in opts:
-        if o == "--help":
-            usage(def_val)
+    for option, value in opts:
+        if option == "--help":
+            usage()
             sys.exit()
-        elif o == "--version":
+        elif option == "--version":
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit()
-        elif o == "--no-ui":
+        elif option == "--no-ui":
             val["load_ui"] = False
-        elif o == "--script":
-            val["script"] = a
-        elif o == "--verbose":
+        elif option == "--script":
+            val["script"] = value
+        elif option == "--verbose":
             config.verbose = True
-        elif o == "--debug":
+        elif option == "--debug":
             config.debug = True
-        elif o == "--use-profiler":
+        elif option == "--use-profiler":
             val["use_profiler"] = True
     return (val, filename,)
 
@@ -77,17 +88,16 @@
             print "Fatal error: you need Python 2.4 or greater!"
             sys.exit(1)
     
-        import imp
         plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")
         plugins_files = os.listdir(plugins_dir)
-        file_py = re.compile("^([a-z0-9_]+)\.py$")
+        match_module_name = re.compile("^([a-z0-9_]+)\.py$")
         modules = []
         for file in plugins_files:
-            m = file_py.match(file)
-            if file != "__init__.py" and m != None:
-                module = "plugins."+m.group(1)
+            module_name = match_module_name.match(file)
+            if file != "__init__.py" and module_name != None:
+                module = "plugins." + module_name.group(1)
                 __import__(module)
-                modules.append(m.group(1))
+                modules.append(module_name.group(1))
         log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 
         opt = {
@@ -124,9 +134,14 @@
                 str_filename = "\"%s\"" % filename
             else:
                 str_filename = "None"
-            profile.run('global hachoir; hachoir.run(%s)' % str_filename, stat_filename)
-            #pstats.Stats(stat_filename).sort_stats('cumulative').print_stats()
-            pstats.Stats(stat_filename).sort_stats('time').print_stats()
+            code = 'global hachoir; hachoir.run(%s)' % str_filename
+            profile.run(code, stat_filename)
+            if False:
+                sort_by = 'cumulative'
+            else:
+                sort_by = 'time'
+            stats = pstats.Stats(stat_filename).sort_stats(sort_by)
+            stats.print_stats()
             os.unlink(stat_filename)
         else:
             hachoir.run(filename)
@@ -135,6 +150,7 @@
         pass
     except Exception, err:
         error("Python Exception: %s" % err)
-	sys.exit(1)
+    sys.exit(1)
 
-if __name__=="__main__": main()    
+if __name__ == "__main__":
+    main()

Modified: haypo/hachoir/trunk/reverse.py
===================================================================
--- haypo/hachoir/trunk/reverse.py	2006-01-20 02:48:56 UTC (rev 406)
+++ haypo/hachoir/trunk/reverse.py	2006-01-20 03:43:57 UTC (rev 407)
@@ -26,7 +26,7 @@
         for i in raw:
             count[i] = count[i] + 1
     length = stream.getSize()
-    for i in range(0,256):
+    for i in range(0, 256):
         i = chr(i)
         if count[i] != 0:
             p.append( float(count[i]) / length )
@@ -231,7 +231,7 @@
         """
         # Config
         max_header_size = 64 
-        chunk_size_deltas = IntValues((-20,20))
+        chunk_size_deltas = IntValues((-20, 20))
 
         # Find possible header sizes
         range = IntValues((0, max_header_size))



From haypo at berlios.de  Sun Jan 22 21:53:00 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 22 Jan 2006 21:53:00 +0100
Subject: [Happyboom-svn] r408 - haypo/poilu/trunk
Message-ID: <200601222053.k0MKr0Ln019086@sheep.berlios.de>

Author: haypo
Date: 2006-01-22 21:53:00 +0100 (Sun, 22 Jan 2006)
New Revision: 408

Modified:
   haypo/poilu/trunk/insulte.txt
   haypo/poilu/trunk/motcle_regex.txt
   haypo/poilu/trunk/pypoil.py
Log:
Ajoute l'insulte "Ta chatte", et repond a son dieu si ce n'est pas une commande.


Modified: haypo/poilu/trunk/insulte.txt
===================================================================
--- haypo/poilu/trunk/insulte.txt	2006-01-20 03:43:57 UTC (rev 407)
+++ haypo/poilu/trunk/insulte.txt	2006-01-22 20:53:00 UTC (rev 408)
@@ -6,3 +6,4 @@
 clanlib:ClanLib c'est affreux, n'utilisez pas cette biblioth??que !
 troll:Troll detected !!! :)
 windows:Windows ??apucpalibre, utilisez Linux ou *BSD !
+tachatte:TA CHATTE TA CHATTE TA CHATTE

Modified: haypo/poilu/trunk/motcle_regex.txt
===================================================================
--- haypo/poilu/trunk/motcle_regex.txt	2006-01-20 03:43:57 UTC (rev 407)
+++ haypo/poilu/trunk/motcle_regex.txt	2006-01-22 20:53:00 UTC (rev 408)
@@ -6,3 +6,4 @@
 clanlib:(ClanLib|clanlib)
 troll:([Mm]andrake|[Gg]entoo|utf-8)
 windows:([Ww]indows)
+tachatte:([Tt]a chatte|TA CHATTE)

Modified: haypo/poilu/trunk/pypoil.py
===================================================================
--- haypo/poilu/trunk/pypoil.py	2006-01-20 03:43:57 UTC (rev 407)
+++ haypo/poilu/trunk/pypoil.py	2006-01-22 20:53:00 UTC (rev 408)
@@ -83,9 +83,10 @@
         # Commande pour le bot
         regs = re.compile("^"+self.connection.get_nickname()+"[:,>]? *(.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
-            if nick==self.god and self.do_priv_command(regs.group(1)): return
-            self.do_pub_command(nick, regs.group(1))
-            return
+            if nick==self.god and self.do_priv_command(regs.group(1)):
+                return
+            if self.do_pub_command(nick, regs.group(1)):
+                return
 
         # Bot d?sactiv? ? Exit !
         if self.enmarche == 0:
@@ -93,8 +94,8 @@
             
         # Sinon, cherche une rime
         reponse = None
+        if reponse==None and self.reponse_motcle: reponse = self.motcle.reponse(cmd)
         if reponse==None and self.reponse_dico: reponse = self.dico.reponse(cmd)
-        if reponse==None and self.reponse_motcle: reponse = self.motcle.reponse(cmd)
         if reponse==None: return
         
         if self.taux_reponse <= random.uniform(0,101): return
@@ -133,9 +134,12 @@
         if (re.compile("^ta gueule", re.IGNORECASE).search(cmd) != None):
             if self.enmarche!=0: self.send_privmsg(self.channel, "Ok, je me tais")
             self.enmarche = 0
-        else:
-            if self.enmarche==0: self.send_privmsg(self.channel, "re")
+            return True
+        elif self.enmarche==0:
+            self.send_privmsg(self.channel, "re")
             self.enmarche = 1
+            return True
+        return False
 
     def do_priv_command(self, cmd):
         c = self.connection
@@ -286,7 +290,7 @@
             self.channel = regs.group(1) 
             self.connection.join(self.channel)
             return True
-        return None
+        return False
 
 def main():
     import sys



From haypo at berlios.de  Wed Jan 25 03:55:19 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 25 Jan 2006 03:55:19 +0100
Subject: [Happyboom-svn] r409 - haypo/hachoir/trunk
Message-ID: <200601250255.k0P2tJTQ023632@sheep.berlios.de>

Author: haypo
Date: 2006-01-25 03:55:03 +0100 (Wed, 25 Jan 2006)
New Revision: 409

Modified:
   haypo/hachoir/trunk/hachoir.py
Log:
Load user interface before the plugins.
Catch plugin loading error: display a warning if loading fails.


Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2006-01-22 20:53:00 UTC (rev 408)
+++ haypo/hachoir/trunk/hachoir.py	2006-01-25 02:55:03 UTC (rev 409)
@@ -11,7 +11,7 @@
 import config
 from program import PROGRAM, VERSION, WEBSITE
 from log import log
-from error import error
+from error import error, warning
 from hachoir_class import Hachoir
 import ui.ui as ui
 
@@ -81,25 +81,16 @@
 
 def main():
     try:        
+        # Welcome message
         print "%s version %s" % (PROGRAM, VERSION)
         print "%s\n" % WEBSITE
 
+        # Check Python version (need 2.4 or greater)
         if sys.hexversion < 0x02040000:
             print "Fatal error: you need Python 2.4 or greater!"
             sys.exit(1)
-    
-        plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")
-        plugins_files = os.listdir(plugins_dir)
-        match_module_name = re.compile("^([a-z0-9_]+)\.py$")
-        modules = []
-        for file in plugins_files:
-            module_name = match_module_name.match(file)
-            if file != "__init__.py" and module_name != None:
-                module = "plugins." + module_name.group(1)
-                __import__(module)
-                modules.append(module_name.group(1))
-        log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 
+        # Parse command line options
         opt = {
             "verbose": False,
             "script": None,
@@ -107,10 +98,14 @@
             "use_profiler": False
         }
         opt, filename = parseArgs(opt)
-        global hachoir 
+
+        # Instanciate the Hachoir
+        global hachoir
         hachoir = Hachoir()
         for key in opt:
             setattr(hachoir, key, opt[key])
+
+        # Load user interface (if needed)
         if hachoir.load_ui:
             try:
                 print "Load user interface"
@@ -127,6 +122,24 @@
 Ubuntu: apt-get install python-gtk2 python-glade2
 Mandriva: urpmi pygtk2.0-libglade-2.6.2-1mdk (or pygtk2.0-libglade?)""" % (err))
                 sys.exit(1)
+    
+        # Load all plugins
+        plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")
+        plugins_files = os.listdir(plugins_dir)
+        match_module_name = re.compile("^([a-z0-9_]+)\.py$")
+        modules = []
+        for file in plugins_files:
+            module_name = match_module_name.match(file)
+            if file != "__init__.py" and module_name != None:
+                module = "plugins." + module_name.group(1)
+                try:
+                    __import__(module)
+                    modules.append(module_name.group(1))
+                except Exception, msg:
+                    warning("Error while loading the plugin \"%s\": %s" % (module, msg))
+        log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
+
+        # Run the Hachoir
         if opt["use_profiler"]:
             import profile, pstats
             stat_filename = 'hachoir.pystat'



From haypo at berlios.de  Wed Jan 25 04:05:48 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 25 Jan 2006 04:05:48 +0100
Subject: [Happyboom-svn] r410 - haypo/hachoir/trunk
Message-ID: <200601250305.k0P35mKA026033@sheep.berlios.de>

Author: haypo
Date: 2006-01-25 04:05:44 +0100 (Wed, 25 Jan 2006)
New Revision: 410

Modified:
   haypo/hachoir/trunk/error.py
   haypo/hachoir/trunk/hachoir.py
   haypo/hachoir/trunk/hachoir_class.py
Log:
- Display message box for warning when --verbose or --debug (command line option) is used
- Sort modules list before displaying the list


Modified: haypo/hachoir/trunk/error.py
===================================================================
--- haypo/hachoir/trunk/error.py	2006-01-25 02:55:03 UTC (rev 409)
+++ haypo/hachoir/trunk/error.py	2006-01-25 03:05:44 UTC (rev 410)
@@ -9,15 +9,15 @@
     if config.debug:
         message = log_message
     log.warning(log_message)   
-#    if ui.ui.ui != None:
-#        import gtk
-#        dlg = gtk.MessageDialog( \
-#            parent=ui.ui.ui.window.window,
-#            type=gtk.MESSAGE_WARNING,
-#            buttons=gtk.BUTTONS_OK,
-#            message_format=message)
-#        dlg.run()
-#        dlg.destroy()
+    if (config.verbose or config.debug) and ui.ui.ui != None:
+        import gtk
+        dlg = gtk.MessageDialog( \
+            parent=ui.ui.ui.window.window,
+            type=gtk.MESSAGE_WARNING,
+            buttons=gtk.BUTTONS_OK,
+            message_format=message)
+        dlg.run()
+        dlg.destroy()
 
 def error(message, backtrace=None):
     log_message = message + "\n\n" + getBacktrace()

Modified: haypo/hachoir/trunk/hachoir.py
===================================================================
--- haypo/hachoir/trunk/hachoir.py	2006-01-25 02:55:03 UTC (rev 409)
+++ haypo/hachoir/trunk/hachoir.py	2006-01-25 03:05:44 UTC (rev 410)
@@ -108,7 +108,7 @@
         # Load user interface (if needed)
         if hachoir.load_ui:
             try:
-                print "Load user interface"
+                print "Load user interface."
                 ui.loadInterface(hachoir)
             except ImportError, err:
                 error("""Error: a Python module is missing:
@@ -128,6 +128,7 @@
         plugins_files = os.listdir(plugins_dir)
         match_module_name = re.compile("^([a-z0-9_]+)\.py$")
         modules = []
+        print "Load plugins."
         for file in plugins_files:
             module_name = match_module_name.match(file)
             if file != "__init__.py" and module_name != None:
@@ -137,6 +138,7 @@
                     modules.append(module_name.group(1))
                 except Exception, msg:
                     warning("Error while loading the plugin \"%s\": %s" % (module, msg))
+        modules.sort()
         log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 
         # Run the Hachoir

Modified: haypo/hachoir/trunk/hachoir_class.py
===================================================================
--- haypo/hachoir/trunk/hachoir_class.py	2006-01-25 02:55:03 UTC (rev 409)
+++ haypo/hachoir/trunk/hachoir_class.py	2006-01-25 03:05:44 UTC (rev 410)
@@ -141,5 +141,5 @@
         if self.script:
             self.loadScript(self.script)
         if self.load_ui:
-            print "Run user interface ..."
+            print "Run user interface."
             self.ui.run()      



From haypo at berlios.de  Wed Jan 25 04:46:10 2006
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 25 Jan 2006 04:46:10 +0100
Subject: [Happyboom-svn] r411 - haypo/hachoir/trunk
Message-ID: <200601250346.k0P3kArv007488@sheep.berlios.de>

Author: haypo
Date: 2006-01-25 04:46:07 +0100 (Wed, 25 Jan 2006)
New Revision: 411

Modified:
   haypo/hachoir/trunk/tools.py
Log:
Clear backtrace state after getting backtrace


Modified: haypo/hachoir/trunk/tools.py
===================================================================
--- haypo/hachoir/trunk/tools.py	2006-01-25 03:05:44 UTC (rev 410)
+++ haypo/hachoir/trunk/tools.py	2006-01-25 03:46:07 UTC (rev 411)
@@ -171,9 +171,13 @@
 
 def getBacktrace():
     try:
-        bt = traceback.format_exception( \
-            sys.exc_type, sys.exc_value, sys.exc_traceback)
-        return "".join(bt)
+        info = sys.exc_info()
+        bt = traceback.format_exception(*info)
+        sys.exc_clear()
+        if bt[0] != "None\n":
+            return "".join(bt)
+        else:
+            return "Empty backtrace."
     except:
         return "Error while trying to get backtrace"
 



