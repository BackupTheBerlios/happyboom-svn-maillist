From dboucard at berlios.de  Fri Sep  2 15:38:19 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Fri, 2 Sep 2005 15:38:19 +0200
Subject: [Happyboom-svn] r106 - / happyboom/trunk/boomboom/client languetudes languetudes/src
Message-ID: <200509021338.j82DcJjO016047@sheep.berlios.de>

Author: dboucard
Date: 2005-09-02 15:38:18 +0200 (Fri, 02 Sep 2005)
New Revision: 106

Added:
   languetudes/
   languetudes/languetudes.conf
   languetudes/languetudes.py
   languetudes/src/
   languetudes/src/__init__.py
   languetudes/src/common.py
   languetudes/src/console.py
   languetudes/src/ncurses.py
   languetudes/src/tkinter.py
Modified:
   happyboom/trunk/boomboom/client/bb_display.py
   happyboom/trunk/boomboom/client/bb_input.py
Log:
projet perso pour aider l'apprentissage de vocabulaire etranger

Modified: happyboom/trunk/boomboom/client/bb_display.py
===================================================================
--- happyboom/trunk/boomboom/client/bb_display.py	2005-08-14 20:54:15 UTC (rev 105)
+++ happyboom/trunk/boomboom/client/bb_display.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -10,7 +10,7 @@
 from bb_drawer import BoomBoomDrawer
 from bb_constructor import BoomBoomConstructor
 from net import io
-from net import io_udp
+from net import io_udp, io_tcp
 import thread
 
 class BoomBoomDisplay(EventLauncher, EventListener):
@@ -60,7 +60,7 @@
         self.port = port
         self.name = name
         self.__protocol_version = "0.1.4"
-        self.__io = io_udp.IO_UDP()
+        self.__io = io_tcp.IO_TCP()
         self.__verbose = verbose
         self.__io.verbose = verbose
         self.__debug = debug

Modified: happyboom/trunk/boomboom/client/bb_input.py
===================================================================
--- happyboom/trunk/boomboom/client/bb_input.py	2005-08-14 20:54:15 UTC (rev 105)
+++ happyboom/trunk/boomboom/client/bb_input.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -8,7 +8,7 @@
 from common.simple_event import EventLauncher
 import bb_events
 from net import io
-from net import io_udp
+from net import io_udp, io_tcp
 from net import net_buffer
 import thread, time, pygame
 
@@ -53,7 +53,7 @@
         self.host = host
         self.port = port
         self.name = name
-        self.__io = io_udp.IO_UDP()
+        self.__io = io_tcp.IO_TCP()
         self.__recv_buffer = net_buffer.NetBuffer()
         self.__verbose = verbose
         self.__io.verbose = verbose

Added: languetudes/languetudes.conf
===================================================================
--- languetudes/languetudes.conf	2005-08-14 20:54:15 UTC (rev 105)
+++ languetudes/languetudes.conf	2005-09-02 13:38:18 UTC (rev 106)
@@ -0,0 +1,15 @@
+################################
+# CONFIGURATION DE LANGUETUDES #
+#               Version Python #
+################################
+
+# Configuration base de donnees
+# #############################
+# "type" est le nom du module python utilise
+# ce module doit respecter le standard API-DB
+[Base]
+type=MySQLdb
+hote=localhost
+utilisateur=languetudes
+#motpasse=prout
+nombase=languetudes

Added: languetudes/languetudes.py
===================================================================
--- languetudes/languetudes.py	2005-08-14 20:54:15 UTC (rev 105)
+++ languetudes/languetudes.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -0,0 +1,40 @@
+import sys, getopt
+
+usage = """
+USAGE:
+    %s [--ihm <interface>]
+    %s -h | --help
+
+Les IHM disponibles sont :
+ ** console : mode interactif dans un terminal texte.
+ ** ncurses : interface graphique dans un terminal texte.
+ ** tkinter : interface graphique utilisant la bibiotheque TK.
+""" % (sys.argv[0], sys.argv[0])
+
+ihm = ("console", "ncurse", "tkinter")
+
+def main():
+    ihmModule = "tkinter"
+    try:
+        opts, args = getopt.getopt(sys.argv[1:], "h", "help, ihm=")
+    except getopt.GetoptError:
+        print "ERREUR: usage incorrect."
+        print usage
+        sys.exit(1)
+    for o, a in opts:
+        if o in ("-h", "--help"):
+            print usage
+            sys.exit()
+        elif o == "--ihm":
+            if a in ihm:
+                ihmModule = a
+            else:
+                print "ERREUR: ihm incorrect."
+                print usage
+                sys.exit(2)
+    src = __import__("src", globals(),  locals(), [ihmModule])
+    mod = getattr(src, ihmModule)
+    mod.Application()
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file

Added: languetudes/src/__init__.py
===================================================================

Added: languetudes/src/common.py
===================================================================
--- languetudes/src/common.py	2005-08-14 20:54:15 UTC (rev 105)
+++ languetudes/src/common.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -0,0 +1,182 @@
+import ConfigParser
+
+class Application:
+    dico_id_sql = """SELECT __dictionnaire.id AS id
+FROM __langue, __dictionnaire
+WHERE __dictionnaire.langue=__langue.id
+  AND __langue.intitule='%s'
+  AND __dictionnaire.intitule='%s'"""
+    
+    def __init__(self):
+        # Chargement du fichier de configuration
+        self.conf = ConfigParser.ConfigParser()
+        #fichConf = __file__[:-2] + "conf"
+        self.conf.read("languetudes.conf")
+        # import de module de base de donnees compatible API-DB
+        bdd = __import__(self.conf.get("Base","type"), globals())
+        bdd = __import__(self.conf.get("Base","type")+".cursors", globals())
+        
+        # recuperation des parametres de connexion
+        params = {"host":"", "user":"", "passwd":"", "db":"", "port":0}
+        if self.conf.has_option("Base","hote"):
+                params["host"] = self.conf.get("Base","hote")
+        if self.conf.has_option("Base","utilisateur"):
+                params["user"] = self.conf.get("Base","utilisateur")
+        if self.conf.has_option("Base","motpasse"):
+                params["passwd"] = self.conf.get("Base","motpasse")
+        if self.conf.has_option("Base","nombase"):
+                params["db"] = self.conf.get("Base","nombase")
+        if self.conf.has_option("Base","port"):
+                params["port"] = int(self.conf.get("Base","port"))
+        # connexion a la base de donnees
+        self.connexion = bdd.connect(**params)
+        # creation d'un curseur de parcours de resultat SQL
+        self.curseur = self.connexion.cursor(bdd.cursors.DictCursor)
+        self.curseur.execute("SHOW tables")
+        result = []
+        for i in self.curseur.fetchall():
+            result.extend(i.values())
+        # Creation des tables
+        if "__langue" not in result:
+            self.curseur.execute("""CREATE TABLE __dictionnaire (
+    id INT(9) primary key auto_increment,
+    intitule VARCHAR(63),
+    langue INT(9) REFERENCES __langue(id),
+    INDEX(langue, intitule)
+    )""")
+            self.curseur.execute("""CREATE TABLE __langue (
+    id INT(9) PRIMARY KEY AUTO_INCREMENT,
+    intitule VARCHAR(31) NOT NULL,
+    INDEX(intitule)
+    )""")
+        
+    def getLangues(self):
+        self.curseur.execute("SELECT intitule FROM __langue ORDER BY intitule")
+        result = []
+        for i in self.curseur.fetchall():
+            result.append(i["intitule"])
+        return result
+        
+    def addLangue(self, langue):
+        self.curseur.execute("INSERT INTO __langue(intitule) VALUES('%s')" %langue.lower())
+
+    def getDictionnaires(self, langue):
+        self.curseur.execute("SELECT __dictionnaire.intitule FROM __langue, __dictionnaire WHERE __dictionnaire.langue = __langue.id AND __langue.intitule = '%s' ORDER BY __dictionnaire.intitule" %langue)
+        result = []
+        for i in self.curseur.fetchall():
+            result.append(i["intitule"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"'))
+        return result
+        
+    def addDictionnaire(self, nom, langue):
+        self.curseur.execute("SELECT id FROM __langue WHERE intitule='%s'" %langue)
+        langue_id = self.curseur.fetchall()[0]["id"]
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        self.curseur.execute("INSERT INTO __dictionnaire(intitule, langue) VALUES('%s', %s)" %(nom, langue_id))
+        self.curseur.execute("SELECT id FROM __dictionnaire WHERE langue=%s AND intitule='%s'" %(langue_id, nom))
+        dico_id = self.curseur.fetchall()[0]["id"]
+        self.curseur.execute("""CREATE TABLE dico%s(
+id INT(9) PRIMARY KEY AUTO_INCREMENT,
+francais VARCHAR(63) NOT NULL,
+etranger VARCHAR(63) NOT NULL,
+INDEX(francais, etranger),
+INDEX(etranger, francais)
+)""" %dico_id)
+        
+    def delDictionnaire(self, nom, langue):
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        self.curseur.execute(self.dico_id_sql %(langue, nom))
+        dico_id = self.curseur.fetchall()[0]["id"]
+        self.curseur.execute("DELETE FROM __dictionnaire WHERE id=%s" %dico_id)
+        self.curseur.execute("DROP TABLE dico%s" %dico_id)
+        
+    def verifierDoublons(self, langue, nom, francais, etranger):
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        self.curseur.execute(self.dico_id_sql %(langue, nom))
+        dico_id = self.curseur.fetchall()[0]["id"]
+        self.curseur.execute("SELECT francais, etranger FROM dico%s WHERE francais='%s' OR etranger='%s'" %(dico_id, francais, etranger))
+        f, e = (False, False)
+        for i in self.curseur.fetchall():
+            if i["francais"] == francais and i["etranger"] == etranger:
+                return (True, True, True)
+            if i["francais"] == francais:
+                f = True
+            if i["etranger"] == etranger:
+                e = True
+        return (f, e, False)
+        
+    def addCouple(self, langue, nom, francais, etranger):
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        self.curseur.execute(self.dico_id_sql %(langue, nom))
+        dico_id = self.curseur.fetchall()[0]["id"]
+        self.curseur.execute("INSERT INTO dico%s(francais, etranger) VALUES ('%s', '%s')" %(dico_id, francais, etranger))
+        
+    def delCouple(self, langue, nom, francais, etranger):
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        self.curseur.execute(self.dico_id_sql %(langue, nom))
+        dico_id = self.curseur.fetchall()[0]["id"]
+        self.curseur.execute("DELETE FROM dico%s WHERE francais='%s' AND etranger='%s'" %(dico_id, francais, etranger))
+        
+    def getCouples(self, langue, nom, ordre="francais ASC", longueur=None, debut=0):
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        self.curseur.execute(self.dico_id_sql %(langue, nom))
+        dico_id = self.curseur.fetchall()[0]["id"]
+        limit = ""
+        if longueur != None:
+            limit = " LIMIT %s, %s" %(debut, longueur)
+        self.curseur.execute("SELECT francais, etranger FROM dico%s ORDER BY %s%s" %(dico_id, ordre, limit))
+        result = self.curseur.fetchall()
+        for i in range(len(result)):
+            result[i]["francais"] = result[i]["francais"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
+            result[i]["etranger"] = result[i]["etranger"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
+        return result
+        
+    def getAleatoire(self, langue, dicos):
+        requete = ""
+        for nom in dicos:
+            nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+            self.curseur.execute(self.dico_id_sql %(langue, nom))
+            dico_id = self.curseur.fetchall()[0]["id"]
+            requete = requete + "SELECT francais, etranger FROM dico%s UNION " %dico_id
+        self.curseur.execute("%s ORDER BY RAND() LIMIT 1" %(requete[:-7]))
+        result = self.curseur.fetchall()[0]
+        result["francais"] = result["francais"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
+        result["etranger"] = result["etranger"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
+        return (result["francais"], result["etranger"])
+        
+    def corriger(self, langue, dicos, francais, etranger, type):
+        francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        if type == "version":
+            test = "etranger='%s'" %etranger
+        else:
+            test = "francais='%s'" %francais
+        requete = ""
+        for nom in dicos:
+            nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+            self.curseur.execute(self.dico_id_sql %(langue, nom))
+            dico_id = self.curseur.fetchall()[0]["id"]
+            requete = requete + "SELECT francais, etranger FROM dico%s WHERE %s UNION " %(dico_id, test)
+        self.curseur.execute(requete[:-7])
+        result = self.curseur.fetchall()
+        if type == "version":
+            for i in result:
+                if i["francais"] == francais:
+                    return True
+            return False
+        else:
+            for i in result:
+                if i["etranger"] == etranger:
+                    return True
+            return False
+        
+    def __del__(self):
+        # fermeture du curseur
+        self.curseur.close()
+        # fermeture de la connexion
+        self.connexion.close()
\ No newline at end of file

Added: languetudes/src/console.py
===================================================================
--- languetudes/src/console.py	2005-08-14 20:54:15 UTC (rev 105)
+++ languetudes/src/console.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -0,0 +1,5 @@
+import common
+
+class Application(common.Application):
+    def __init__(self):
+        print "Pas encore implemente"
\ No newline at end of file

Added: languetudes/src/ncurses.py
===================================================================
--- languetudes/src/ncurses.py	2005-08-14 20:54:15 UTC (rev 105)
+++ languetudes/src/ncurses.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -0,0 +1,5 @@
+import common
+
+class Application(common.Application):
+    def __init__(self):
+        print "Pas encore implemente"
\ No newline at end of file

Added: languetudes/src/tkinter.py
===================================================================
--- languetudes/src/tkinter.py	2005-08-14 20:54:15 UTC (rev 105)
+++ languetudes/src/tkinter.py	2005-09-02 13:38:18 UTC (rev 106)
@@ -0,0 +1,544 @@
+from Tkinter import *
+import tkMessageBox
+import common
+    
+class Application(common.Application, Frame, object):
+    def __init__(self):
+        common.Application.__init__(self)
+        Frame.__init__(self)
+        self.master.title("Languetudes")
+        self.__langue = "aucune"
+        self.dico = []
+        self.pack()
+        self.createWidgets()
+        self.mainloop()
+    
+    def getLangue(self):
+        return self.__langue
+    def setLangue(self, langue):
+        if langue != self.__langue:
+            self.dico = []
+        self.__langue = langue
+        self.btnLangue["text"] = "Langue : %s" %self.__langue
+    langue = property(getLangue, setLangue)
+    
+    def createWidgets(self):
+        self.btnLangue = Button(self)
+        self.btnLangue["text"] = "Langue : %s" %self.__langue
+        self.btnLangue["command"] = self.choisirLangue
+        self.btnLangue["fg"]   = "blue"
+        self.btnLangue.pack({"side": "top", "fill": X})
+        
+        self.btnDico = Button(self)
+        self.btnDico["text"] = "Dictionnaires"
+        self.btnDico["command"] = self.dictionnaire
+        self.btnDico["fg"]   = "darkgreen"
+        self.btnDico.pack({"side": "top", "fill": X})
+        
+        self.btnVersion = Button(self)
+        self.btnVersion["text"] = "Version"
+        self.btnVersion["command"] = self.version
+        self.btnVersion.pack({"side": "top", "fill": X})
+        
+        self.btnTheme = Button(self)
+        self.btnTheme["text"] = "Theme"
+        self.btnTheme["command"] = self.theme
+        self.btnTheme.pack({"side": "top", "fill": X})
+        
+        self.btnQuit = Button(self)
+        self.btnQuit["text"] = " " * 15 + "Sortie" + " " * 15
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.quit
+        self.btnQuit.pack({"side": "top", "fill": X})
+        
+    def choisirLangue(self):
+        Langue(self)
+        
+    def dictionnaire(self):
+        if self.langue == "aucune":
+            tkMessageBox.showinfo("Aucune langue selectionnee", "Veuillez d'abord choisir une langue.")
+            Langue(self)
+        else:
+            Dictionnaire(self, self.langue)
+        
+    def version(self):
+        if self.langue == "aucune":
+            tkMessageBox.showinfo("Aucune langue selectionnee", "Veuillez d'abord choisir une langue.")
+            Langue(self)
+        elif self.dico == []:
+            tkMessageBox.showinfo("Aucun dictionnaire selectionne", "Veuillez d'abord choisir un ou plusieurs dictionnaires.")
+            Dictionnaire(self, self.langue)
+        else:
+            Version(self, self.langue, self.dico)
+    
+    def theme(self):
+        if self.langue == "aucune":
+            tkMessageBox.showinfo("Aucune langue selectionnee", "Veuillez d'abord choisir une langue.")
+            Langue(self)
+        elif self.dico == []:
+            tkMessageBox.showinfo("Aucun dictionnaire selectionne", "Veuillez d'abord choisir un ou plusieurs dictionnaires.")
+            Dictionnaire(self, self.langue)
+        else:
+            Theme(self, self.langue, self.dico)
+        
+class Langue(Toplevel):
+    def __init__(self, master):
+        Toplevel.__init__(self, master)
+        self.title("Choisir une langue")
+        self.createWidgets()
+        
+    def createWidgets(self):
+        self.btnQuit = Button(self)
+        self.btnQuit["text"] = "Annuler"
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.destroy
+        self.btnQuit.pack({"side": "top", "fill": X})
+        
+        self.btn = []
+        for langue in self.master.getLangues():
+            button = Button(self)
+            button["text"] = langue
+            button.bind("<Button-1>", self.choisirLangue)
+            button.pack({"side": "top", "fill": X})
+            self.btn.append(button)
+        
+        self.txtAjouter = Entry(self)
+        self.txtAjouter["text"] = ""
+        self.txtAjouter["fg"]   = "blue"
+        self.txtAjouter.bind("<Return>", self.addLangue)
+        self.txtAjouter.pack({"side": "top", "fill": X})
+        
+        self.btnAjouter = Button(self)
+        self.btnAjouter["text"] = "Ajouter"
+        self.btnAjouter["fg"]   = "blue"
+        self.btnAjouter["command"] =  self.addLangue
+        self.btnAjouter.pack({"side": "top", "fill": X})
+        
+    def choisirLangue(self, event):
+        self.master.langue = event.widget["text"]
+        self.destroy()
+        
+    def addLangue(self, event=None):
+        txt = self.txtAjouter.get().strip().lower()
+        if txt == "":
+            tkMessageBox.showwarning("Nom de langue incorrect", "Veuillez indiquer un nom de langue dans le champ de texte.")
+            self.txtAjouter.focus()
+            return
+        self.master.addLangue(txt)
+        self.master.langue = txt
+        self.destroy()
+        
+class Dictionnaire(Toplevel):
+    def __init__(self, master, langue):
+        Toplevel.__init__(self, master)
+        self.title("%s : dictionnaires" %langue)
+        self.langue = langue
+        self.createWidgets()
+        
+    def createWidgets(self):  
+        self.btnQuit = Button(self)
+        self.defCouleur = self.btnQuit["bg"]
+        self.btnQuit["text"] = " " * 30 + "Fermer" + " " * 30
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.destroy
+        self.btnQuit.grid(row=0, columnspan=5)
+        
+        cptrow = 0
+        self.dicos = []
+        for dico in self.master.getDictionnaires(self.langue):
+            cptrow = cptrow + 1
+            label = Label(self)
+            label["text"] = dico
+            label.grid(row=cptrow, column=0)
+            
+            btnSelect = Button(self)
+            btnSelect["text"] = "Sel"
+            if dico in self.master.dico:
+                btnSelect["bg"] = "green"
+            btnSelect.bind("<Button-1>", self.choisirDico)
+            btnSelect.grid(row=cptrow, column=1)
+            
+            btnEdit = Button(self)
+            btnEdit["text"] = "Edit"
+            btnEdit.bind("<Button-1>", self.editerDico)
+            btnEdit.grid(row=cptrow, column=2)
+            
+            btnVoir = Button(self)
+            btnVoir["text"] = "Voir"
+            btnVoir.bind("<Button-1>", self.voirDico)
+            btnVoir.grid(row=cptrow, column=3)
+            
+            btnSuppr = Button(self)
+            btnSuppr["text"] = "Supp"
+            btnSuppr.bind("<Button-1>", self.supprimerDico)
+            btnSuppr.grid(row=cptrow, column=4)
+            
+            self.dicos.append((label, btnSelect, btnEdit, btnVoir, btnSuppr))
+            
+        self.txtAjouter = Entry(self)
+        self.txtAjouter["text"] = ""
+        self.txtAjouter["fg"]   = "blue"
+        self.txtAjouter.bind("<Return>", self.ajouterDico)
+        self.txtAjouter.grid(row=cptrow+1, columnspan=3)
+        
+        self.btnAjouter = Button(self)
+        self.btnAjouter["text"] = "Ajouter"
+        self.btnAjouter["fg"]   = "blue"
+        self.btnAjouter["command"] =  self.ajouterDico
+        self.btnAjouter.grid(row=cptrow+1, column=3, columnspan=2)
+        
+    def choisirDico(self, event):
+        self.master.langue = self.langue
+        for i in self.dicos:
+            if i[1] == event.widget:
+                if i[1]["bg"] == "green":
+                    i[1]["bg"] = self.defCouleur
+                else:
+                    i[1]["bg"] = "green"
+            if i[1]["bg"] == "green":
+                    self.master.dico.append(i[0]["text"])
+                
+    def editerDico(self, event):
+        for i in self.dicos:
+            if i[2] == event.widget:
+                Editer(self, self.langue, i[0]["text"])
+                return
+                
+    def voirDico(self, event):
+        for i in self.dicos:
+            if i[3] == event.widget:
+                Voir(self, self.langue, i[0]["text"])
+                return
+                
+    def supprimerDico(self, event):
+        for i in self.dicos:
+            if i[4] == event.widget:
+                if tkMessageBox.askquestion("Confirmation de la suppression", "Etes-vous certain de vouloir supprimer le dictionnaire intitule \"%s\" ?" %i[0]["text"])=="yes":
+                    self.master.delDictionnaire(i[0]["text"], self.langue)
+                    Dictionnaire(self.master, self.langue)
+                    self.destroy()
+                return
+        
+    def ajouterDico(self, event=None):
+        txt = self.txtAjouter.get().strip().lower()
+        if txt == "":
+            tkMessageBox.showwarning("Nom de dictionnaire incorrect", "Veuillez indiquer un nom au dictionnaire dans le champ de texte.")
+            self.txtAjouter.focus()
+            return
+        for b in self.dicos:
+            if b[0]["text"] == txt:
+                tkMessageBox.showwarning("Nom de dictionnaire incorrect", "Un dictionnaire existant porte deja ce nom. Veuillez en taper un autre.")
+                self.txtAjouter.delete(0)
+                self.txtAjouter.focus()
+                return
+        self.master.addDictionnaire(txt, self.langue)
+        Dictionnaire(self.master, self.langue)
+        Editer(self, self.langue, txt)
+        self.destroy()
+        
+class Editer(Toplevel):
+    def __init__(self, master, langue, dico):
+        Toplevel.__init__(self, master)
+        self.langue = langue
+        self.dico = dico
+        self.title("%s : %s" %(langue, dico))
+        self.createWidgets()
+        
+    def createWidgets(self):
+        self.btnQuit = Button(self)
+        self.btnQuit["text"] = " " * 15 + "Fermer" + " " * 15
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.destroy
+        self.btnQuit.grid(row=0, columnspan=2)
+        
+        self.lblFrancais = Label(self)
+        self.lblFrancais["text"] = "francais"
+        self.lblFrancais.grid(row=1, column=0)
+        
+        self.txtFrancais = Entry(self)
+        self.txtFrancais["text"] = ""
+        self.txtFrancais["fg"]   = "blue"
+        self.txtFrancais.bind("<Return>", self.valider)
+        self.txtFrancais.grid(row=1, column=1)
+        
+        self.lblEtranger = Label(self)
+        self.lblEtranger["text"] = self.langue
+        self.lblEtranger.grid(row=2, column=0)
+        
+        self.txtEtranger = Entry(self)
+        self.txtEtranger["text"] = ""
+        self.txtEtranger["fg"]   = "blue"
+        self.txtEtranger.bind("<Return>", self.valider)
+        self.txtEtranger.grid(row=2, column=1)
+        
+        self.btnAjouter = Button(self)
+        self.btnAjouter["text"] = "Ajouter"
+        self.btnAjouter["fg"]   = "blue"
+        self.btnAjouter["command"] =  self.valider
+        self.btnAjouter.grid(row=3, columnspan=2)    
+        
+    def valider(self, event=None):
+        francais = self.txtFrancais.get().strip().lower()
+        etranger = self.txtEtranger.get().strip().lower()
+        if francais=="":
+            tkMessageBox.showwarning("Libelle incorrect", "Veuillez remplir tous les champs de cette boite de dialogue.")
+            self.txtFrancais.focus()
+            return
+        if etranger=="":
+            tkMessageBox.showwarning("Libelle incorrect", "Veuillez remplir tous les champs de cette boite de dialogue.")
+            self.txtEtranger.focus()
+            return
+        (f, e, d) = self.master.master.verifierDoublons(self.langue, self.dico, francais, etranger)
+        if d == True:
+            tkMessageBox.showwarning("Doublons detectes", "Ce couple a deja ete entre. Vous ne pouvez pas faire de doublons.")
+            self.txtEtranger.delete(0)
+            self.txtFrancais.delete(0)
+            self.txtFrancais.focus()
+            return
+        if f == True:
+            if tkMessageBox.askquestion("Doublons detectes", "Le mot francais \"%s\" est deja dans le dictionnaire. Etes-vous certain de l'associer a un second mot %s ?" %(francais, self.langue))=="no":
+                self.txtFrancais.delete(0)
+                self.txtFrancais.focus()
+                return
+        if e == True:
+            if tkMessageBox.askquestion("Doublons detectes", "Le mot %s \"%s\" est deja dans le dictionnaire. Etes-vous certain de l'associer a un second mot francais ?" %(self.langue, etranger))=="no":
+                self.txtEtranger.delete(0)
+                self.txtEtranger.focus()
+                return
+        self.master.master.addCouple(self.langue, self.dico, francais, etranger)
+        Editer(self.master, self.langue, self.dico)
+        self.destroy()
+        
+class Voir(Toplevel):
+    def __init__(self, master, langue, dico, ordre="francais ASC", debut=0):
+        Toplevel.__init__(self, master)
+        self.langue = langue
+        self.dico = dico
+        self.ordre = ordre
+        self.debut = debut
+        self.longueur = 20
+        self.title("%s : %s" %(langue, dico))
+        self.createWidgets()
+        
+    def createWidgets(self):
+        self.btnQuit = Button(self)
+        self.btnQuit["text"] = " " * 15 + "Fermer" + " " * 15
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.destroy
+        self.btnQuit.grid(row=0, columnspan=4)
+        
+        self.btnFrancais = Button(self)
+        self.btnFrancais["text"] = "francais"
+        self.btnFrancais["fg"]   = "blue"
+        self.btnFrancais.bind("<Button-1>", self.changerOrdre)
+        self.btnFrancais.grid(row=1, column=0, columnspan=2)
+        
+        self.btnEtranger = Button(self)
+        self.btnEtranger["text"] = self.langue
+        self.btnEtranger["fg"]   = "blue"
+        self.btnEtranger.bind("<Button-1>", self.changerOrdre)
+        self.btnEtranger.grid(row=1, column=2, columnspan=2)
+        
+        rowcpt = 1
+        self.couples = []
+        for i in self.master.master.getCouples(self.langue, self.dico, self.ordre, self.longueur, self.debut):
+            rowcpt = rowcpt + 1
+            
+            lblFr = Label(self)
+            lblFr["text"] = i["francais"]
+            lblFr.grid(row=rowcpt, column=0, columnspan=2)
+            
+            lblEtr = Label(self)
+            lblEtr["text"] = i["etranger"]
+            lblEtr.grid(row=rowcpt, column=2, columnspan=2)
+            
+            btnSuppr = Button(self)
+            btnSuppr["text"] = "x"
+            btnSuppr["fg"]   = "red"
+            btnSuppr.bind("<Button-1>", self.supprimerCouple)
+            btnSuppr.grid(row=rowcpt, column=4)
+        
+            self.couples.append((lblFr, lblEtr, btnSuppr))
+        
+        self.btnRAZ = Button(self)
+        self.btnRAZ["text"] = "| <"
+        self.btnRAZ["fg"]   = "blue"
+        self.btnRAZ["command"] = self.remettreAZero
+        self.btnRAZ.grid(row=rowcpt+1, column=0)
+        
+        self.btnPrec = Button(self)
+        self.btnPrec["text"] = "< <"
+        self.btnPrec["fg"]   = "blue"
+        self.btnPrec["command"] = self.precedent
+        self.btnPrec.grid(row=rowcpt+1, column=1)
+        
+        self.btnSuiv = Button(self)
+        self.btnSuiv["text"] = "> >"
+        self.btnSuiv["fg"]   = "blue"
+        self.btnSuiv["command"] = self.suivant
+        self.btnSuiv.grid(row=rowcpt+1, column=2)
+        
+        self.btnMAJ = Button(self)
+        self.btnMAJ["text"] = "M.A.J"
+        self.btnMAJ["fg"]   = "blue"
+        self.btnMAJ["command"] = self.mettreAJour
+        self.btnMAJ.grid(row=rowcpt+1, column=3)
+        
+    def changerOrdre(self, event):
+        nvOrdre = self.ordre
+        if event.widget == self.btnFrancais:
+            if self.ordre in ("francais ASC", "etranger DESC"):
+                nvOrdre = "francais DESC"
+            else:
+                nvOrdre = "francais ASC"
+        if event.widget == self.btnEtranger:
+            if self.ordre in ("etranger ASC", "francais DESC"):
+                nvOrdre = "etranger DESC"
+            else:
+                nvOrdre = "etranger ASC"
+        Voir(self.master, self.langue, self.dico, ordre=nvOrdre, debut=self.debut)
+        self.destroy()
+
+    def supprimerCouple(self, event):
+        for i in self.couples:
+            if i[2] == event.widget:
+                if tkMessageBox.askquestion("Confirmation suppression", "Etes-vous certain de vouloir supprimer le couple de mot \"%s\" / \"%s\"" %(i[0]["text"], i[1]["text"]))=="yes":
+                    self.master.master.delCouple(self.langue, self.dico, i[0]["text"], i[1]["text"])
+                self.mettreAJour()
+                break
+        
+    def remettreAZero(self):
+        Voir(self.master, self.langue, self.dico, ordre=self.ordre)
+        self.destroy()
+        
+    def precedent(self):
+        nvDebut = self.debut - self.longueur
+        if nvDebut < 0:
+            nvDebut = 0
+        Voir(self.master, self.langue, self.dico, ordre=self.ordre, debut=nvDebut)
+        self.destroy()
+        
+    def suivant(self):
+        nvDebut = self.debut + self.longueur
+        Voir(self.master, self.langue, self.dico, ordre=self.ordre, debut=nvDebut)
+        self.destroy()
+        
+    def mettreAJour(self):
+        Voir(self.master, self.langue, self.dico, ordre=self.ordre, debut=self.debut)
+        self.destroy()
+        
+class Version(Toplevel):
+    def __init__(self, master, langue, dicos, total=0, points=0):
+        Toplevel.__init__(self, master)
+        self.langue = langue
+        self.dicos = dicos
+        self.total = total
+        self.points = points
+        self.title("%s : version" %(langue))
+        self.createWidgets()
+        
+    def createWidgets(self):
+        self.btnQuit = Button(self)
+        self.btnQuit["text"] = " " * 15 + "Terminer" + " " * 15
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.terminer
+        self.btnQuit.grid(row=0, columnspan=2)
+        
+        self.lblScore = Label(self)
+        self.lblScore["text"] = "Score : %s / %s" %(self.points, self.total)
+        self.lblScore["fg"] = "blue"
+        self.lblScore.grid(row=1, columnspan=2)
+        
+        self.lblEtranger = Label(self)
+        self.lblEtranger["text"] = self.langue
+        self.lblEtranger.grid(row=2, column=0)
+        
+        self.txtEtranger = Label(self)
+        self.reponse, self.txtEtranger["text"] = self.master.getAleatoire(self.langue, self.dicos)
+        self.txtEtranger["bg"]   = "green"
+        self.txtEtranger.grid(row=2, column=1, sticky=W+E)
+        
+        self.lblFrancais = Label(self)
+        self.lblFrancais["text"] = "francais"
+        self.lblFrancais.grid(row=3, column=0)
+        
+        self.txtFrancais = Entry(self)
+        self.txtFrancais["text"] = ""
+        self.txtFrancais["fg"]   = "darkgreen"
+        self.txtFrancais.bind("<Return>", self.valider)
+        self.txtFrancais.grid(row=3, column=1)
+        
+        self.btnAjouter = Button(self)
+        self.btnAjouter["text"] = "Valider"
+        self.btnAjouter["fg"]   = "blue"
+        self.btnAjouter["command"] =  self.valider
+        self.btnAjouter.grid(row=4, columnspan=2)
+        
+    def valider(self, event=None):
+        if self.master.corriger(self.langue, self.dicos, self.txtFrancais.get(), self.txtEtranger["text"], "version"):
+            Version(self.master, self.langue, self.dicos, self.total+1, self.points+1)
+        else:
+            tkMessageBox.showinfo("Mauvaise reponse", "Faux. La bonne traduction est : \"%s\"" %self.reponse)
+            Version(self.master, self.langue, self.dicos, self.total+1, self.points)
+        self.destroy()
+        
+    def terminer(self):
+        self.destroy()
+        
+class Theme(Toplevel):
+    def __init__(self, master, langue, dicos, total=0, points=0):
+        Toplevel.__init__(self, master)
+        self.langue = langue
+        self.dicos = dicos
+        self.total = total
+        self.points = points
+        self.title("%s : theme" %(langue))
+        self.createWidgets()
+        
+    def createWidgets(self):
+        self.btnQuit = Button(self)
+        self.btnQuit["text"] = " " * 15 + "Terminer" + " " * 15
+        self.btnQuit["fg"]   = "red"
+        self.btnQuit["command"] =  self.terminer
+        self.btnQuit.grid(row=0, columnspan=2)
+        
+        self.lblScore = Label(self)
+        self.lblScore["text"] = "Score : %s / %s" %(self.points, self.total)
+        self.lblScore["fg"] = "blue"
+        self.lblScore.grid(row=1, columnspan=2)
+        
+        self.lblFrancais = Label(self)
+        self.lblFrancais["text"] = "francais"
+        self.lblFrancais.grid(row=2, column=0)
+        
+        self.txtFrancais = Label(self)
+        self.txtFrancais["text"], self.reponse = self.master.getAleatoire(self.langue, self.dicos)
+        self.txtFrancais["bg"]   = "green"
+        self.txtFrancais.grid(row=2, column=1, sticky=W+E)
+        
+        self.lblEtranger = Label(self)
+        self.lblEtranger["text"] = self.langue
+        self.lblEtranger.grid(row=3, column=0)
+        
+        self.txtEtranger = Entry(self)
+        self.txtEtranger["text"] = ""
+        self.txtEtranger["fg"]   = "darkgreen"
+        self.txtEtranger.bind("<Return>", self.valider)
+        self.txtEtranger.grid(row=3, column=1)
+        
+        self.btnAjouter = Button(self)
+        self.btnAjouter["text"] = "Valider"
+        self.btnAjouter["fg"]   = "blue"
+        self.btnAjouter["command"] =  self.valider
+        self.btnAjouter.grid(row=4, columnspan=2)
+        
+    def valider(self, event=None):
+        if self.master.corriger(self.langue, self.dicos, self.txtFrancais["text"], self.txtEtranger.get(), "theme"):
+            Theme(self.master, self.langue, self.dicos, self.total+1, self.points+1)
+        else:
+            tkMessageBox.showinfo("Mauvaise reponse", "Faux. La bonne traduction est : \"%s\"" %self.reponse)
+            Theme(self.master, self.langue, self.dicos, self.total+1, self.points)
+        self.destroy()
+        
+    def terminer(self):
+        self.destroy()
\ No newline at end of file



From dboucard at berlios.de  Fri Sep  2 16:44:25 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Fri, 2 Sep 2005 16:44:25 +0200
Subject: [Happyboom-svn] r107 - languetudes
Message-ID: <200509021444.j82EiPBq019980@sheep.berlios.de>

Author: dboucard
Date: 2005-09-02 16:44:25 +0200 (Fri, 02 Sep 2005)
New Revision: 107

Added:
   languetudes/languetudes.test.sql
Log:
jeu de donnees pour tester le programme

Added: languetudes/languetudes.test.sql
===================================================================
--- languetudes/languetudes.test.sql	2005-09-02 13:38:18 UTC (rev 106)
+++ languetudes/languetudes.test.sql	2005-09-02 14:44:25 UTC (rev 107)
@@ -0,0 +1,178 @@
+-- MySQL dump 9.11
+--
+-- Host: localhost    Database: languetudes
+-- ------------------------------------------------------
+-- Server version	4.0.23_Debian-3ubuntu2-log
+
+--
+-- Table structure for table `__dictionnaire`
+--
+
+DROP TABLE IF EXISTS `__dictionnaire`;
+CREATE TABLE `__dictionnaire` (
+  `id` int(9) NOT NULL auto_increment,
+  `intitule` varchar(63) default NULL,
+  `langue` int(9) default NULL,
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `langue` (`langue`,`intitule`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `__dictionnaire`
+--
+
+
+/*!40000 ALTER TABLE `__dictionnaire` DISABLE KEYS */;
+LOCK TABLES `__dictionnaire` WRITE;
+INSERT INTO `__dictionnaire` VALUES (13,'nombres',5),(7,'test',7),(12,'lecon no1',8),(10,'test2',7),(11,'nombres',6);
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `__dictionnaire` ENABLE KEYS */;
+
+--
+-- Table structure for table `__langue`
+--
+
+DROP TABLE IF EXISTS `__langue`;
+CREATE TABLE `__langue` (
+  `id` int(9) NOT NULL auto_increment,
+  `intitule` varchar(31) NOT NULL default '',
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `intitule` (`intitule`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `__langue`
+--
+
+
+/*!40000 ALTER TABLE `__langue` DISABLE KEYS */;
+LOCK TABLES `__langue` WRITE;
+INSERT INTO `__langue` VALUES (5,'roumain'),(6,'anglais'),(7,'esperanto'),(8,'chinois');
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `__langue` ENABLE KEYS */;
+
+--
+-- Table structure for table `dico10`
+--
+
+DROP TABLE IF EXISTS `dico10`;
+CREATE TABLE `dico10` (
+  `id` int(9) NOT NULL auto_increment,
+  `francais` varchar(63) NOT NULL default '',
+  `etranger` varchar(63) NOT NULL default '',
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `francais` (`francais`,`etranger`),
+  KEY `etranger` (`etranger`,`francais`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `dico10`
+--
+
+
+/*!40000 ALTER TABLE `dico10` DISABLE KEYS */;
+LOCK TABLES `dico10` WRITE;
+INSERT INTO `dico10` VALUES (1,'un','unu'),(2,'deux','du'),(3,'trois','tri'),(4,'quatre','kvar'),(5,'cinq','kvin'),(6,'six','ses'),(7,'sept','sep'),(8,'huit','ok'),(9,'neuf','naux'),(10,'dix','dek');
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `dico10` ENABLE KEYS */;
+
+--
+-- Table structure for table `dico11`
+--
+
+DROP TABLE IF EXISTS `dico11`;
+CREATE TABLE `dico11` (
+  `id` int(9) NOT NULL auto_increment,
+  `francais` varchar(63) NOT NULL default '',
+  `etranger` varchar(63) NOT NULL default '',
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `francais` (`francais`,`etranger`),
+  KEY `etranger` (`etranger`,`francais`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `dico11`
+--
+
+
+/*!40000 ALTER TABLE `dico11` DISABLE KEYS */;
+LOCK TABLES `dico11` WRITE;
+INSERT INTO `dico11` VALUES (1,'un','one'),(2,'deux','two'),(3,'trois','three'),(4,'quatre','four'),(5,'cinq','five'),(6,'six','six'),(7,'sept','seven'),(8,'huit','eight'),(9,'neuf','nine'),(10,'dix','ten');
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `dico11` ENABLE KEYS */;
+
+--
+-- Table structure for table `dico12`
+--
+
+DROP TABLE IF EXISTS `dico12`;
+CREATE TABLE `dico12` (
+  `id` int(9) NOT NULL auto_increment,
+  `francais` varchar(63) NOT NULL default '',
+  `etranger` varchar(63) NOT NULL default '',
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `francais` (`francais`,`etranger`),
+  KEY `etranger` (`etranger`,`francais`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `dico12`
+--
+
+
+/*!40000 ALTER TABLE `dico12` DISABLE KEYS */;
+LOCK TABLES `dico12` WRITE;
+INSERT INTO `dico12` VALUES (1,'tu','ni'),(2,'bien','hao'),(3,'vieux','lao'),(4,'roi','wang'),(5,'cheval','ma'),(6,'je','wo'),(7,'assez','hen'),(8,'petit','xiao'),(9,'il','ta'),(10,'et ... ?','ne'),(11,'elle','ta'),(12,'aussi','ye'),(13,'et','he'),(14,'demander','wen');
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `dico12` ENABLE KEYS */;
+
+--
+-- Table structure for table `dico13`
+--
+
+DROP TABLE IF EXISTS `dico13`;
+CREATE TABLE `dico13` (
+  `id` int(9) NOT NULL auto_increment,
+  `francais` varchar(63) NOT NULL default '',
+  `etranger` varchar(63) NOT NULL default '',
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `francais` (`francais`,`etranger`),
+  KEY `etranger` (`etranger`,`francais`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `dico13`
+--
+
+
+/*!40000 ALTER TABLE `dico13` DISABLE KEYS */;
+LOCK TABLES `dico13` WRITE;
+INSERT INTO `dico13` VALUES (1,'un','unu'),(2,'deux','doi'),(3,'trois','trei'),(4,'quatre','patru'),(5,'cinq','cinci'),(6,'six','sase'),(7,'sept','sapte'),(8,'huit','opt'),(9,'neuf','noua'),(10,'dix','zece');
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `dico13` ENABLE KEYS */;
+
+--
+-- Table structure for table `dico7`
+--
+
+DROP TABLE IF EXISTS `dico7`;
+CREATE TABLE `dico7` (
+  `id` int(9) NOT NULL auto_increment,
+  `francais` varchar(63) NOT NULL default '',
+  `etranger` varchar(63) NOT NULL default '',
+  PRIMARY KEY  (`id`),
+  UNIQUE KEY `francais` (`francais`,`etranger`),
+  KEY `etranger` (`etranger`,`francais`)
+) TYPE=MyISAM;
+
+--
+-- Dumping data for table `dico7`
+--
+
+
+/*!40000 ALTER TABLE `dico7` DISABLE KEYS */;
+LOCK TABLES `dico7` WRITE;
+INSERT INTO `dico7` VALUES (1,'eau','akvo'),(2,'tasse','taso'),(3,'cafe','kafo'),(4,'homme','viro'),(5,'fils','filo'),(6,'garcon','knabo'),(7,'the','teo'),(8,'ami','amiko'),(9,'etre','esti'),(10,'nouveau','nova'),(11,'en bonne sante','sana'),(12,'je','mi'),(13,'tu','vi'),(14,'il','li'),(15,'elle','sxi'),(16,'nous','ni'),(17,'vous','vi'),(19,'ils','ili'),(20,'elles','ili'),(21,'on','oni'),(22,'soi-meme','si');
+UNLOCK TABLES;
+/*!40000 ALTER TABLE `dico7` ENABLE KEYS */;
+



From haypo at berlios.de  Fri Sep  2 17:41:06 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 2 Sep 2005 17:41:06 +0200
Subject: [Happyboom-svn] r112 - lamer
Message-ID: <200509021541.j82Ff6sv025481@sheep.berlios.de>

Author: haypo
Date: 2005-09-02 17:41:06 +0200 (Fri, 02 Sep 2005)
New Revision: 112

Added:
   lamer/Makefile
Log:
Oups, ajoute le Makefile oublie.


Added: lamer/Makefile
===================================================================
--- lamer/Makefile	2005-09-02 15:38:38 UTC (rev 111)
+++ lamer/Makefile	2005-09-02 15:41:06 UTC (rev 112)
@@ -0,0 +1,10 @@
+CC=gcc
+CFLAGS=-Wall
+IN=tool/src/gftp_descramble.c
+OUT=tool/gftp_descramble
+$(OUT): $(IN)
+	$(CC) $(IN) -o $(OUT) $(CFLAGS)
+exec: $(OUT)
+	./$(OUT)
+clean:
+	rm -f $(OUT)



From haypo at berlios.de  Fri Sep  2 17:10:48 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 2 Sep 2005 17:10:48 +0200
Subject: [Happyboom-svn] r109 - lamer
Message-ID: <200509021510.j82FAm9G023371@sheep.berlios.de>

Author: haypo
Date: 2005-09-02 17:10:47 +0200 (Fri, 02 Sep 2005)
New Revision: 109

Modified:
   lamer/mod_gftp.sh
Log:
Le module gftp appelle make si le programme de descramble n'est pas
encore compile.


Modified: lamer/mod_gftp.sh
===================================================================
--- lamer/mod_gftp.sh	2005-09-02 15:06:02 UTC (rev 108)
+++ lamer/mod_gftp.sh	2005-09-02 15:10:47 UTC (rev 109)
@@ -4,8 +4,13 @@
 DST=export/
 mkdir -p $DST
 IN=~/.gftp/bookmarks
+DESCRAMBLE=tool/gftp_descramble
 
 if [ ! -e $IN ]; then exit 0; fi
+if [ ! -e $DESCRAMBLE ]; then
+  if [ $VERBOSE ]; then echo "(call make)"; fi
+  make
+fi
 
 tool/common.sh
 



From haypo at berlios.de  Fri Sep  2 17:06:03 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 2 Sep 2005 17:06:03 +0200
Subject: [Happyboom-svn] r108 - / lamer lamer/tool lamer/tool/src
Message-ID: <200509021506.j82F635r022772@sheep.berlios.de>

Author: haypo
Date: 2005-09-02 17:06:02 +0200 (Fri, 02 Sep 2005)
New Revision: 108

Added:
   lamer/
   lamer/README
   lamer/all.sh
   lamer/clean.sh
   lamer/mod_evolution.sh
   lamer/mod_gaim.sh
   lamer/mod_gftp.sh
   lamer/mod_ncftp.sh
   lamer/mod_ssh.sh
   lamer/mod_yafc.sh
   lamer/tool/
   lamer/tool/common.sh
   lamer/tool/evolution.pl
   lamer/tool/firefox.pl
   lamer/tool/gaim.pl
   lamer/tool/gftp_bookmark.pl
   lamer/tool/ncftp_bookmark.pl
   lamer/tool/src/
   lamer/tool/src/gftp_descramble.c
   lamer/tool/yafc.pl
Log:
Ajoute l'outil lamer.


Added: lamer/README
===================================================================
--- lamer/README	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/README	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,6 @@
+Hi, Lamer is a toolkit which can be used to list all password on a
+Linux computer. It decrypts each password.
+
+For each software, a "mod_<name>.sh" exists.
+
+Haypo

Added: lamer/all.sh
===================================================================
--- lamer/all.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/all.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,4 @@
+#!/bin/sh
+for i in `find ./ -maxdepth 1 -type f -perm -700 -name 'mod_*' | grep -v '~'`; do
+  ./$i
+done


Property changes on: lamer/all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/clean.sh
===================================================================
--- lamer/clean.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/clean.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,3 @@
+#!/bin/sh
+rm -rf export/
+find -name "*~*" -exec rm {} \;


Property changes on: lamer/clean.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/mod_evolution.sh
===================================================================
--- lamer/mod_evolution.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/mod_evolution.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+export MOD=evolution
+IN=~/.gnome2_private/Evolution
+if [ ! -e $IN ]; then exit 0; fi
+
+tool/common.sh
+
+tool/evolution.pl $IN
+


Property changes on: lamer/mod_evolution.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/mod_gaim.sh
===================================================================
--- lamer/mod_gaim.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/mod_gaim.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+export MOD=gaim
+IN=~/.gaim/accounts.xml
+if [ ! -e $IN ]; then exit 0; fi
+
+tool/common.sh
+
+tool/gaim.pl $IN
+


Property changes on: lamer/mod_gaim.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/mod_gftp.sh
===================================================================
--- lamer/mod_gftp.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/mod_gftp.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+export MOD=gftp
+DST=export/
+mkdir -p $DST
+IN=~/.gftp/bookmarks
+
+if [ ! -e $IN ]; then exit 0; fi
+
+tool/common.sh
+
+tool/gftp_bookmark.pl $IN | tee $DST/$MOD


Property changes on: lamer/mod_gftp.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/mod_ncftp.sh
===================================================================
--- lamer/mod_ncftp.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/mod_ncftp.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+export MOD=ncftp
+DST_DIR=export/
+mkdir -p $DST_DIR
+IN=~/.ncftp/bookmarks
+
+if [ ! -e $IN ]; then exit 0; fi
+tool/common.sh
+
+tail -n +3 $IN | tool/ncftp_bookmark.pl | tee $DST_DIR/$MOD


Property changes on: lamer/mod_ncftp.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/mod_ssh.sh
===================================================================
--- lamer/mod_ssh.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/mod_ssh.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+export MOD="ssh"
+SSH_DIR=~/.ssh
+DST=./export/$MOD
+
+if [ ! -d $SSH_DIR ]; then exit 0; fi
+
+tool/common.sh
+
+mkdir -p $DST
+
+if [ $VERBOSE ]; then echo -n 'Known SSH hosts : '; fi
+
+cut -d' ' -f1 $SSH_DIR/known_hosts | sed 's/^\(.*\),.*$/\1/g'> $DST/known_hosts
+
+if [ $VERBOSE ]; then 
+    for i in `cat $DST/known_hosts`; do echo -n "$i, "; done
+    echo 'copy SSH keys !'
+fi
+
+cp $SSH_DIR/id_rsa $DST/
+cp $SSH_DIR/id_rsa.pub $DST/
\ No newline at end of file


Property changes on: lamer/mod_ssh.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/mod_yafc.sh
===================================================================
--- lamer/mod_yafc.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/mod_yafc.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+export MOD=yafc
+DST=export/
+mkdir -p $DST
+IN=~/.yafc/bookmarks
+
+if [ ! -e $IN ]; then exit 0; fi
+
+tool/common.sh
+
+tool/yafc.pl $IN | tee $DST/$MOD


Property changes on: lamer/mod_yafc.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/common.sh
===================================================================
--- lamer/tool/common.sh	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/common.sh	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+if [ $VERBOSE ]; then echo -e "\n[ $MOD ]"; fi
+mkdir -p export/


Property changes on: lamer/tool/common.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/evolution.pl
===================================================================
--- lamer/tool/evolution.pl	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/evolution.pl	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,41 @@
+#!/usr/bin/perl
+
+use MIME::Base64;
+
+# Read all accounts
+%accounts = ();
+open(FILE, $ARGV[0]);
+while (<FILE>) {
+    chomp();
+    if (/^(pop|imap):__([^@]+)@([^=_]+)=(.+)$/) { 
+		$protocol = $1;
+		$email = $2;
+		$server = $3;
+		$password = $4;
+		if ($email =~ /^([^;]+);auth_(.*)$/)
+		{
+			$email = $1;
+			$auth = $2;
+			$auth = "" if ($auth =~ /^\+APOP$/);
+		} else {
+			$auth = "";
+		}
+		$password = decode_base64($password);
+		$email =~ s/%40/@/;
+
+		# Important key : skip duplicate accounts
+		$key = $server . ":" . $email;
+		if (not exists $accounts{$key})
+		{
+			$accounts{$key} = 1;
+			print "$server : $email : \"$password\"\n";
+
+#			print "Email $email\n";
+#			print "- authentification: $auth\n" if (! $auth =~ /^$/);
+#			print "- protocol: $protocol\n" if not($protocol =~ /^pop$/); 
+#			print "- server: $server\n";
+#			print "- password: $password\n";
+		}
+	}
+}
+close(FILE);


Property changes on: lamer/tool/evolution.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/firefox.pl
===================================================================
--- lamer/tool/firefox.pl	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/firefox.pl	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,54 @@
+#!/usr/bin/perl
+
+use MIME::Base64;
+
+$suite_serveur = 1;
+$suite_id_txt = 2;
+$suite_id = 3;
+$suite_pass_txt = 4;
+$suite_pass = 5;
+
+sub nv_idpass {
+    $user = '';
+    $pass = '';
+}
+
+sub nv_site {
+    $server = '';
+    $ligne = 0;
+    $suite = 0;
+}
+
+sub affiche {
+    if ($server eq '') { return; }
+    $server =~ s/ +\(.*\)$//;
+#     $lg_max = 16;
+#     $user =~ s/^.*(.{$lg_max})$/(...)\1/ if ($lg_max<length($user));
+#     $pass =~ s/^.*(.{$lg_max})$/(...)\1/ if ($lg_max<length($pass));
+    print ("S=$server, U=$user, P=$pass\n");
+}
+
+nv_site();
+nv_idpass();
+open(FILE, $ARGV[0]);
+while (<FILE>) {
+    chomp();
+    next if (/^\#/);
+
+SWITCH: {
+    $suite++;
+    if (/^\./) { nv_site(); last SWITCH; }
+    if ($suite == $suite_serveur) { $server = $_; last SWITCH; }
+    if ($suite == $suite_id) { $user = $_; last SWITCH; }
+    if ($suite == $suite_pass) { 
+	$pass = $_; 
+	$suite = $suite_id_txt-1; 
+	affiche();
+	nv_idpass();
+	last SWITCH; 
+    }
+}
+
+    $ligne++;
+}
+close(AUTOCOMPLETE);


Property changes on: lamer/tool/firefox.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/gaim.pl
===================================================================
--- lamer/tool/gaim.pl	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/gaim.pl	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,28 @@
+#!/usr/bin/perl
+
+use XML::Simple;
+
+my $file = $ARGV[0];
+my $xs1 = XML::Simple->new();
+my $doc = $xs1->XMLin($file);
+
+%accounts = %{$doc->{account}};
+
+%human_protocol = (
+	'prpl-oscar' => "ICQ",
+	'prpl-yahoo' => "Yahoo",
+	'prpl-jabber' => "Jabber",
+	'prpl-msn' => "MSN"
+);
+
+foreach my $key (keys %accounts){
+    $user = $key;
+    $item = $accounts{$key};
+    $protocol = $item->{protocol};
+	$protocol = $human_protocol{$protocol} if exists $human_protocol{$protocol};
+	
+    $pass = ($item->{password});
+    $pass = $pass ? '"'.$pass.'"' : "<unknow>"; 
+	
+    print "$protocol : $user : $pass\n";
+}


Property changes on: lamer/tool/gaim.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/gftp_bookmark.pl
===================================================================
--- lamer/tool/gftp_bookmark.pl	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/gftp_bookmark.pl	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,50 @@
+#!/usr/bin/perl
+
+use Env qw(VERBOSE);
+
+sub urlEncode {
+    my ($string) = @_;
+    $string =~ s/(\W)/"%" . unpack("H2", $1)/ge;
+    #$string# =~ tr/.//;
+    return $string;
+ }
+
+sub nv_site {
+    $server = '';
+    $user = '';
+    $pass = '';
+    $port = 21;
+}
+
+sub affiche {
+    return if ($user =~ /^anonymous$/);
+
+    # D?code le mode de passe
+    $pass = `tool/gftp_descramble '$pass'`;
+    chop $pass;
+
+    # Encode l'user et pass
+    $user = urlEncode($user);
+    $pass = urlEncode($pass);
+
+    # Affiche le FTP
+    print ("ftp://$user:$pass\@$server:$port/\n");
+}
+
+$i = 1;
+nv_site();
+open(FILE, $ARGV[0]);
+while (<FILE>) {
+    $i++;
+    chomp();
+    push(@tab,$_);
+
+    if (/^\[/ && $server) { affiche(); nv_site(); }
+    if (/^hostname=/) { $server = $'; }
+    if (/^port=/) { $port = $'; }
+    if (/^username=/) { $user = $'; }
+    if (/^password=/) { $pass = $'; }
+}
+close(AUTOCOMPLETE);
+
+affiche();


Property changes on: lamer/tool/gftp_bookmark.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/ncftp_bookmark.pl
===================================================================
--- lamer/tool/ncftp_bookmark.pl	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/ncftp_bookmark.pl	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,22 @@
+#!/usr/bin/perl
+# Decode ncftp bookmark file
+
+use MIME::Base64;
+
+while ($input = <STDIN>) {
+  if (! $input eq '') {
+    chop $input;
+    @tab = split(/,/, $input);
+    $id = $tab[2];
+    $server = $tab[1];
+    $pass = $tab[3];
+    $port = $tab[7];
+    if ( $pass =~/\*encoded\*/ ) {
+      $pass=~s/\*encoded\*//;
+      $pass = decode_base64($pass);
+    }
+    $pass =~ s/\0+$//;
+    print ("ftp://$id:$pass\@$server:$port/\n");
+  }
+}
+


Property changes on: lamer/tool/ncftp_bookmark.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: lamer/tool/src/gftp_descramble.c
===================================================================
--- lamer/tool/src/gftp_descramble.c	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/src/gftp_descramble.c	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,53 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+char *
+gftp_descramble_password (const char *password)
+{
+  const char *passwordpos;
+  char *newstr, *newpos;
+  int error;
+
+  if (*password != '$') return strdup (password);
+
+  passwordpos = password + 1;
+  newstr = malloc(strlen (passwordpos) / 2 + 1);
+  newpos = newstr;
+ 
+  error = 0;
+  while (*passwordpos != '\0' && (*passwordpos + 1) != '\0')
+    {
+      if ((*passwordpos & 0xc3) != 0x41 ||
+          (*(passwordpos + 1) & 0xc3) != 0x41)
+        {
+          error = 1;
+          break;
+        }
+
+      *newpos++ = ((*passwordpos & 0x3c) << 2) | 
+                  ((*(passwordpos + 1) & 0x3c) >> 2);
+
+      passwordpos += 2;
+    }
+
+  if (error)
+    {
+      free (newstr);
+      return (strdup (password));
+    }
+
+  *newpos = '\0';
+  return (newstr);
+}
+
+int main(int argc, char **argv)
+{
+  if (argc != 2) {
+    fprintf(stderr, "Need one argument : gftp crambled password.\n");
+    return 1;
+  }
+  char *txt = gftp_descramble_password(argv[1]);
+  printf ("%s", txt);
+  return 0;
+}

Added: lamer/tool/yafc.pl
===================================================================
--- lamer/tool/yafc.pl	2005-09-02 14:44:25 UTC (rev 107)
+++ lamer/tool/yafc.pl	2005-09-02 15:06:02 UTC (rev 108)
@@ -0,0 +1,45 @@
+#!/usr/bin/perl
+
+use MIME::Base64;
+
+sub nv_site {
+    $server = '';
+    $user = '';
+    $pass = '';
+}
+
+sub affiche {
+    if ($server eq '') { return; }
+    $pass = decode_base64($') if ($pass =~ /^\[base64\]/);
+    print ("ftp://$user:$pass\@$server/\n");
+    nv_site();
+}
+
+nv_site();
+open(FILE, $ARGV[0]);
+while (<FILE>) {
+    chomp();
+    next if (/^\#/ || /^$/);
+
+    if ($server eq '') {
+	# Ligne du serveur
+	@mots = split ' ',$_;
+	$server = @mots[1];
+    } else {
+	# Ligne du user+pass
+	if (/^ +login (.*) password (.*)$/) { 
+	    $user=$1; 
+	    $pass=$2;
+	    affiche(); 
+	} if (/^ +anonymous$/) { 
+	    $user="anonymous"; 
+	    $pass="";
+	    affiche(); 
+	} else { 
+	    print ("Ligne non reconnue : $_\n"); 
+	}
+    }
+    
+}
+close(AUTOCOMPLETE);
+affiche();


Property changes on: lamer/tool/yafc.pl
___________________________________________________________________
Name: svn:executable
   + *



From haypo at berlios.de  Fri Sep  2 17:38:38 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 2 Sep 2005 17:38:38 +0200
Subject: [Happyboom-svn] r111 - lamer/tool
Message-ID: <200509021538.j82FccDG025145@sheep.berlios.de>

Author: haypo
Date: 2005-09-02 17:38:38 +0200 (Fri, 02 Sep 2005)
New Revision: 111

Modified:
   lamer/tool/common.sh
Log:
common.sh ne cree plus de repertoire export.


Modified: lamer/tool/common.sh
===================================================================
--- lamer/tool/common.sh	2005-09-02 15:36:17 UTC (rev 110)
+++ lamer/tool/common.sh	2005-09-02 15:38:38 UTC (rev 111)
@@ -1,4 +1,3 @@
 #!/bin/sh
 
 if [ $VERBOSE ]; then echo -e "\n[ $MOD ]"; fi
-mkdir -p export/



From haypo at berlios.de  Fri Sep  2 17:36:17 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 2 Sep 2005 17:36:17 +0200
Subject: [Happyboom-svn] r110 - in lamer: . tool
Message-ID: <200509021536.j82FaH5Q025015@sheep.berlios.de>

Author: haypo
Date: 2005-09-02 17:36:17 +0200 (Fri, 02 Sep 2005)
New Revision: 110

Removed:
   lamer/mod_ssh.sh
Modified:
   lamer/mod_gftp.sh
   lamer/mod_ncftp.sh
   lamer/mod_yafc.sh
   lamer/tool/gftp_bookmark.pl
   lamer/tool/yafc.pl
Log:
Supprime la fonctionnalite d'export (inutile) et le module SSH.


Modified: lamer/mod_gftp.sh
===================================================================
--- lamer/mod_gftp.sh	2005-09-02 15:10:47 UTC (rev 109)
+++ lamer/mod_gftp.sh	2005-09-02 15:36:17 UTC (rev 110)
@@ -1,8 +1,6 @@
 #!/bin/sh
 
 export MOD=gftp
-DST=export/
-mkdir -p $DST
 IN=~/.gftp/bookmarks
 DESCRAMBLE=tool/gftp_descramble
 
@@ -14,4 +12,4 @@
 
 tool/common.sh
 
-tool/gftp_bookmark.pl $IN | tee $DST/$MOD
+tool/gftp_bookmark.pl $IN

Modified: lamer/mod_ncftp.sh
===================================================================
--- lamer/mod_ncftp.sh	2005-09-02 15:10:47 UTC (rev 109)
+++ lamer/mod_ncftp.sh	2005-09-02 15:36:17 UTC (rev 110)
@@ -1,11 +1,9 @@
 #!/bin/bash
 
 export MOD=ncftp
-DST_DIR=export/
-mkdir -p $DST_DIR
 IN=~/.ncftp/bookmarks
 
 if [ ! -e $IN ]; then exit 0; fi
 tool/common.sh
 
-tail -n +3 $IN | tool/ncftp_bookmark.pl | tee $DST_DIR/$MOD
+tail -n +3 $IN | tool/ncftp_bookmark.pl

Deleted: lamer/mod_ssh.sh
===================================================================
--- lamer/mod_ssh.sh	2005-09-02 15:10:47 UTC (rev 109)
+++ lamer/mod_ssh.sh	2005-09-02 15:36:17 UTC (rev 110)
@@ -1,23 +0,0 @@
-#!/bin/sh
-
-export MOD="ssh"
-SSH_DIR=~/.ssh
-DST=./export/$MOD
-
-if [ ! -d $SSH_DIR ]; then exit 0; fi
-
-tool/common.sh
-
-mkdir -p $DST
-
-if [ $VERBOSE ]; then echo -n 'Known SSH hosts : '; fi
-
-cut -d' ' -f1 $SSH_DIR/known_hosts | sed 's/^\(.*\),.*$/\1/g'> $DST/known_hosts
-
-if [ $VERBOSE ]; then 
-    for i in `cat $DST/known_hosts`; do echo -n "$i, "; done
-    echo 'copy SSH keys !'
-fi
-
-cp $SSH_DIR/id_rsa $DST/
-cp $SSH_DIR/id_rsa.pub $DST/
\ No newline at end of file

Modified: lamer/mod_yafc.sh
===================================================================
--- lamer/mod_yafc.sh	2005-09-02 15:10:47 UTC (rev 109)
+++ lamer/mod_yafc.sh	2005-09-02 15:36:17 UTC (rev 110)
@@ -1,12 +1,10 @@
 #!/bin/sh
 
 export MOD=yafc
-DST=export/
-mkdir -p $DST
 IN=~/.yafc/bookmarks
 
 if [ ! -e $IN ]; then exit 0; fi
 
 tool/common.sh
 
-tool/yafc.pl $IN | tee $DST/$MOD
+tool/yafc.pl $IN

Modified: lamer/tool/gftp_bookmark.pl
===================================================================
--- lamer/tool/gftp_bookmark.pl	2005-09-02 15:10:47 UTC (rev 109)
+++ lamer/tool/gftp_bookmark.pl	2005-09-02 15:36:17 UTC (rev 110)
@@ -28,7 +28,9 @@
     $pass = urlEncode($pass);
 
     # Affiche le FTP
-    print ("ftp://$user:$pass\@$server:$port/\n");
+    print ("ftp://$user:$pass\@$server");
+    print (":$port") if ($port != 0 && $port != 21);
+    print ("/\n");
 }
 
 $i = 1;

Modified: lamer/tool/yafc.pl
===================================================================
--- lamer/tool/yafc.pl	2005-09-02 15:10:47 UTC (rev 109)
+++ lamer/tool/yafc.pl	2005-09-02 15:36:17 UTC (rev 110)
@@ -22,22 +22,22 @@
     next if (/^\#/ || /^$/);
 
     if ($server eq '') {
-	# Ligne du serveur
-	@mots = split ' ',$_;
-	$server = @mots[1];
+        # Ligne du serveur
+        @mots = split ' ',$_;
+        $server = @mots[1];
     } else {
-	# Ligne du user+pass
-	if (/^ +login (.*) password (.*)$/) { 
-	    $user=$1; 
-	    $pass=$2;
-	    affiche(); 
-	} if (/^ +anonymous$/) { 
-	    $user="anonymous"; 
-	    $pass="";
-	    affiche(); 
-	} else { 
-	    print ("Ligne non reconnue : $_\n"); 
-	}
+        # Ligne du user+pass
+        if (/^ +login (.*) password (.*)$/) { 
+            $user=$1; 
+            $pass=$2;
+            affiche(); 
+        } if (/^ +anonymous$/) { 
+            $user="anonymous"; 
+            $pass="";
+            affiche(); 
+        } else { 
+            print ("Ligne non reconnue : $_\n"); 
+        }
     }
     
 }



From dboucard at berlios.de  Sat Sep  3 01:51:05 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sat, 3 Sep 2005 01:51:05 +0200
Subject: [Happyboom-svn] r114 - languetudes/src
Message-ID: <200509022351.j82Np5Dj006797@sheep.berlios.de>

Author: dboucard
Date: 2005-09-03 01:50:53 +0200 (Sat, 03 Sep 2005)
New Revision: 114

Modified:
   languetudes/src/common.py
Log:
debug : declaration de self.connexion et self.curseur pour le destructeur


Modified: languetudes/src/common.py
===================================================================
--- languetudes/src/common.py	2005-09-02 22:06:14 UTC (rev 113)
+++ languetudes/src/common.py	2005-09-02 23:50:53 UTC (rev 114)
@@ -8,6 +8,9 @@
 WHERE __dictionnaire.langue=__langue.id
   AND __langue.intitule='%s'
   AND __dictionnaire.intitule='%s'"""
+  
+    connexion = None
+    curseur = None
     
     def __init__(self):
         # Chargement du fichier de configuration
@@ -184,7 +187,9 @@
             return False
         
     def __del__(self):
-        # fermeture du curseur
-        self.curseur.close()
-        # fermeture de la connexion
-        self.connexion.close()
\ No newline at end of file
+        if self.connexion != None:
+            if self.curseur != None:
+                # fermeture du curseur
+                self.curseur.close()
+            # fermeture de la connexion
+            self.connexion.close()
\ No newline at end of file



From haypo at berlios.de  Sat Sep  3 01:59:32 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 3 Sep 2005 01:59:32 +0200
Subject: [Happyboom-svn] r115 - languetudes
Message-ID: <200509022359.j82NxWql012788@sheep.berlios.de>

Author: haypo
Date: 2005-09-03 01:59:15 +0200 (Sat, 03 Sep 2005)
New Revision: 115

Modified:
   languetudes/languetudes.py
Log:
Attrape les erreurs "module absent".


Modified: languetudes/languetudes.py
===================================================================
--- languetudes/languetudes.py	2005-09-02 23:50:53 UTC (rev 114)
+++ languetudes/languetudes.py	2005-09-02 23:59:15 UTC (rev 115)
@@ -18,7 +18,7 @@
 def main():
     ihmModule = "tkinter"
     try:
-        opts, args = getopt.getopt(sys.argv[1:], "h", "help, ihm=")
+        opts, args = getopt.getopt(sys.argv[1:], "h", ["help", "ihm="])
     except getopt.GetoptError:
         print "ERREUR: usage incorrect."
         print usage
@@ -34,9 +34,14 @@
                 print "ERREUR: ihm incorrect."
                 print usage
                 sys.exit(2)
-    src = __import__("src", globals(),  locals(), [ihmModule])
-    mod = getattr(src, ihmModule)
-    mod.Application()
+    try:
+        src = __import__("src", globals(),  locals(), [ihmModule])
+        mod = getattr(src, ihmModule)
+        mod.Application()
+    except ImportError, errmsg:
+        print "Erreur : un module Python est absent alors qu'il est n?cessaire."
+        print errmsg
+        sys.exit(1)
 
 if __name__ == "__main__":
-    main()
\ No newline at end of file
+    main()



From dboucard at berlios.de  Sat Sep  3 02:12:00 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sat, 3 Sep 2005 02:12:00 +0200
Subject: [Happyboom-svn] r116 - languetudes/src
Message-ID: <200509030012.j830C0xO017770@sheep.berlios.de>

Author: dboucard
Date: 2005-09-03 02:11:54 +0200 (Sat, 03 Sep 2005)
New Revision: 116

Modified:
   languetudes/src/tkinter.py
Log:
coquille


Modified: languetudes/src/tkinter.py
===================================================================
--- languetudes/src/tkinter.py	2005-09-02 23:59:15 UTC (rev 115)
+++ languetudes/src/tkinter.py	2005-09-03 00:11:54 UTC (rev 116)
@@ -271,7 +271,7 @@
         self.btnQuit.grid(row=0, columnspan=2)
         
         self.lblFrancais = Label(self)
-        self.lblFrancais["text"] = langue
+        self.lblFrancais["text"] = application_language
         self.lblFrancais.grid(row=1, column=0)
         
         self.txtFrancais = Entry(self)



From dboucard at berlios.de  Sat Sep  3 02:19:47 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sat, 3 Sep 2005 02:19:47 +0200
Subject: [Happyboom-svn] r117 - languetudes/src
Message-ID: <200509030019.j830JlcY027170@sheep.berlios.de>

Author: dboucard
Date: 2005-09-03 02:19:45 +0200 (Sat, 03 Sep 2005)
New Revision: 117

Modified:
   languetudes/src/common.py
Log:
coquille


Modified: languetudes/src/common.py
===================================================================
--- languetudes/src/common.py	2005-09-03 00:11:54 UTC (rev 116)
+++ languetudes/src/common.py	2005-09-03 00:19:45 UTC (rev 117)
@@ -155,7 +155,7 @@
         for nom in dicos:
             dico_id = self.getDicoId(langue, nom)
             requete = requete + u"SELECT francais, etranger FROM dico%s UNION " %dico_id
-            requete = "%s ORDER BY RAND() LIMIT 1" %(requete[:-7])
+        requete = "%s ORDER BY RAND() LIMIT 1" %(requete[:-7])
         self.curseur.execute(requete.encode("utf-8"))
         result = self.curseur.fetchall()[0]
         result["francais"] = result["francais"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')



From dboucard at berlios.de  Sat Sep  3 00:06:14 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sat, 3 Sep 2005 00:06:14 +0200
Subject: [Happyboom-svn] r113 - in languetudes: . locale locale/en locale/en/LC_MESSAGES locale/eo locale/eo/LC_MESSAGES src
Message-ID: <200509022206.j82M6EQe030505@sheep.berlios.de>

Author: dboucard
Date: 2005-09-03 00:06:14 +0200 (Sat, 03 Sep 2005)
New Revision: 113

Added:
   languetudes/locale/
   languetudes/locale/en/
   languetudes/locale/en/LC_MESSAGES/
   languetudes/locale/en/LC_MESSAGES/languetudes.mo
   languetudes/locale/en/LC_MESSAGES/languetudes.po
   languetudes/locale/eo/
   languetudes/locale/eo/LC_MESSAGES/
   languetudes/locale/eo/LC_MESSAGES/languetudes.mo
   languetudes/locale/eo/LC_MESSAGES/languetudes.po
   languetudes/trunk/
Modified:
   languetudes/languetudes.py
   languetudes/src/common.py
   languetudes/src/console.py
   languetudes/src/ncurses.py
   languetudes/src/tkinter.py
Log:
UTF-8 compliant, gettext compliant (EN & EO)


Modified: languetudes/languetudes.py
===================================================================
--- languetudes/languetudes.py	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/languetudes.py	2005-09-02 22:06:14 UTC (rev 113)
@@ -1,3 +1,5 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
 import sys, getopt
 
 usage = """

Added: languetudes/locale/en/LC_MESSAGES/languetudes.mo
===================================================================
(Binary files differ)


Property changes on: languetudes/locale/en/LC_MESSAGES/languetudes.mo
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: languetudes/locale/en/LC_MESSAGES/languetudes.po
===================================================================
--- languetudes/locale/en/LC_MESSAGES/languetudes.po	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/locale/en/LC_MESSAGES/languetudes.po	2005-09-02 22:06:14 UTC (rev 113)
@@ -0,0 +1,192 @@
+# Languetudes : outil d'apprentissage de vocabulaire.
+# Copyright (C) 2005 Damien Boucard <damien POINT boucard AROBE tchoy POINT net>
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: 0.2\n"
+"POT-Creation-Date: 2005-09-02 22:03+CEST\n"
+"PO-Revision-Date: 2005-09-02 22:00+CEST\n"
+"Last-Translator: Damien Boucard <damien POINT boucard AROBE tchoy POINT net>\n"
+"Language-Team: English\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=utf-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Generated-By: pygettext.py 1.5\n"
+
+
+#: tkinter.py:11
+msgid "Languetudes"
+msgstr "Langstudy"
+
+#: tkinter.py:12
+msgid "fran\303\247ais"
+msgstr "english"
+
+#: tkinter.py:19
+msgid "Langue : aucune"
+msgstr "Language : none"
+
+#: tkinter.py:32
+msgid "Langue : %s"
+msgstr "Language : %s"
+
+#: tkinter.py:43
+msgid "Dictionnaires"
+msgstr "Dictionaries"
+
+#: tkinter.py:49
+msgid "Version"
+msgstr "Translation into English"
+
+#: tkinter.py:54
+msgid "Th\303\250me"
+msgstr "Translation from English"
+
+#: tkinter.py:59
+msgid "Sortie"
+msgstr "Exit"
+
+#: tkinter.py:69 tkinter.py:76 tkinter.py:86
+msgid "Aucune langue selectionn\303\251e"
+msgstr "No language selected"
+
+#: tkinter.py:69 tkinter.py:76 tkinter.py:86
+msgid "Veuillez d'abord choisir une langue."
+msgstr "Please choose a language first."
+
+#: tkinter.py:79 tkinter.py:89
+msgid "Aucun dictionnaire selectionn\303\251"
+msgstr "No dictionary selected"
+
+#: tkinter.py:79 tkinter.py:89
+msgid "Veuillez d'abord choisir un ou plusieurs dictionnaires."
+msgstr "Please choose one or more dictionaries first."
+
+#: tkinter.py:97
+msgid "Choisir une langue"
+msgstr "Choose a language"
+
+#: tkinter.py:102
+msgid "Annuler"
+msgstr "Cancel"
+
+#: tkinter.py:122 tkinter.py:201 tkinter.py:291
+msgid "Ajouter"
+msgstr "Add"
+
+#: tkinter.py:134
+msgid "Veuillez indiquer un nom de langue dans le champ de texte."
+msgstr "Please enter a language name into the text field."
+
+#: tkinter.py:134 tkinter.py:139
+msgid "Nom de langue incorrect"
+msgstr "Incorrect language name"
+
+#: tkinter.py:139
+msgid "Le nom de langue saisi est d\303\251j\303\240 dans la liste."
+msgstr "The entered language name is already in the list."
+
+#: tkinter.py:150
+msgid "dictionnaires"
+msgstr "dictionaries"
+
+#: tkinter.py:157 tkinter.py:265 tkinter.py:341
+msgid "Fermer"
+msgstr "Close"
+
+#: tkinter.py:171
+msgid "Sel"
+msgstr "Sel"
+
+#: tkinter.py:178
+msgid "\303\211dit"
+msgstr "Edit"
+
+#: tkinter.py:183
+msgid "Voir"
+msgstr "See"
+
+#: tkinter.py:188
+msgid "Supp"
+msgstr "Rem"
+
+#: tkinter.py:232
+msgid "Confirmation de la suppression"
+msgstr "Removal confirmation"
+
+#: tkinter.py:232
+msgid "\303\212tes-vous certain de vouloir supprimer le dictionnaire intitul\303\251 \"%s\" ?"
+msgstr "Are you sure to remove the dictionary entitled \"%s\" ?"
+
+#: tkinter.py:241
+msgid "Veuillez indiquer un nom au dictionnaire dans le champ de texte."
+msgstr "Please enter a dictionary name in the text field."
+
+#: tkinter.py:241 tkinter.py:246
+msgid "Nom de dictionnaire incorrect"
+msgstr "Incorrect dictionary name"
+
+#: tkinter.py:246
+msgid "Un dictionnaire existant porte d\303\251j\303\240 ce nom. Veuillez en taper un autre."
+msgstr "An existing dictionary already has this title. Please enter another one."
+
+#: tkinter.py:300 tkinter.py:304
+msgid "Libell\303\251 incorrect"
+msgstr "Incorrect label"
+
+#: tkinter.py:300 tkinter.py:304
+msgid "Veuillez remplir tous les champs de cette bo\303\256te de dialogue."
+msgstr "Please fill all the fields of this dialog box."
+
+#: tkinter.py:309
+msgid "Ce couple a d\303\251j\303\240 \303\251t\303\251 entr\303\251. Vous ne pouvez pas faire de doublons."
+msgstr "This tuple has already been entered. Duplicate entries are not allowed."
+
+#: tkinter.py:309 tkinter.py:315 tkinter.py:320
+msgid "Doublons d\303\251tect\303\251s"
+msgstr "Duplicate entries detected"
+
+#: tkinter.py:315 tkinter.py:320
+msgid "Le mot %s \"%s\" est d\303\251j\303\240 dans le dictionnaire. \303\212tes-vous certain de l'associer \303\240 un second mot %s ?"
+msgstr "The %s word \"%s\" is already in the dictionary. Are you sure to link it to a second %s word ?"
+
+#: tkinter.py:398
+msgid "M.A.J"
+msgstr "UPDATE"
+
+#: tkinter.py:421
+msgid "Confirmation suppression"
+msgstr "Removal confirmation"
+
+#: tkinter.py:421
+msgid "\303\212tes-vous certain de vouloir supprimer le couple de mot \"%s\" / \"%s\" ?"
+msgstr "Are you sure to remove the tuple \"%s\" / \"%s\" ?"
+
+#: tkinter.py:453
+msgid "version"
+msgstr "translation into English"
+
+#: tkinter.py:458 tkinter.py:516
+msgid "Terminer"
+msgstr "Finish"
+
+#: tkinter.py:464 tkinter.py:522
+msgid "Score"
+msgstr "Score"
+
+#: tkinter.py:488 tkinter.py:546
+msgid "Valider"
+msgstr "Validate"
+
+#: tkinter.py:497 tkinter.py:555
+msgid "Faux. La bonne traduction est : \"%s\""
+msgstr "Wrong. The correct answer is : \"%s\""
+
+#: tkinter.py:497 tkinter.py:555
+msgid "Mauvaise r\303\251ponse"
+msgstr "Wrong answer"
+
+#: tkinter.py:511
+msgid "th\303\250me"
+msgstr "translation from English"
+

Added: languetudes/locale/eo/LC_MESSAGES/languetudes.mo
===================================================================
(Binary files differ)


Property changes on: languetudes/locale/eo/LC_MESSAGES/languetudes.mo
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: languetudes/locale/eo/LC_MESSAGES/languetudes.po
===================================================================
--- languetudes/locale/eo/LC_MESSAGES/languetudes.po	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/locale/eo/LC_MESSAGES/languetudes.po	2005-09-02 22:06:14 UTC (rev 113)
@@ -0,0 +1,188 @@
+# Languetudes : outils d'apprentissage de vocabulaire.
+# Copyright (C) 2005 Damien Boucard <damien POINT boucard AROBE tchoy POINT net>
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: 0.2\n"
+"POT-Creation-Date: 2005-09-02 23:16+CEST\n"
+"PO-Revision-Date: 2005-09-02 23:20+CEST\n"
+"Last-Translator: Damien Boucard <damien POINT boucard AROBE tchoy POINT net>\n"
+"Language-Team: Esperanto\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=utf-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Generated-By: pygettext.py 1.5\n"
+
+
+#: tkinter.py:14
+msgid "Languetudes"
+msgstr "Lingvostudoj"
+
+#: tkinter.py:15
+msgid "fran\303\247ais"
+msgstr "esperante"
+
+#: tkinter.py:22
+msgid "Langue : aucune"
+msgstr "Lingvo : nenio"
+
+#: tkinter.py:35
+msgid "Langue : %s"
+msgstr "Lingvo : %s"
+
+#: tkinter.py:46
+msgid "Dictionnaires"
+msgstr "Vortaroj"
+
+#: tkinter.py:52
+msgid "Version"
+msgstr "Detraduko"
+
+#: tkinter.py:57
+msgid "Th\303\250me"
+msgstr "Altraduko"
+
+#: tkinter.py:62
+msgid "Sortie"
+msgstr "Eliro"
+
+#: tkinter.py:72 tkinter.py:79 tkinter.py:89
+msgid "Aucune langue selectionn\303\251e"
+msgstr "Neniu elekta lingvo"
+
+#: tkinter.py:72 tkinter.py:79 tkinter.py:89
+msgid "Veuillez d'abord choisir une langue."
+msgstr "Anta?e bonvolu elekti lingvon."
+
+#: tkinter.py:82 tkinter.py:92
+msgid "Aucun dictionnaire selectionn\303\251"
+msgstr "Nenio elekta vortaro"
+
+#: tkinter.py:82 tkinter.py:92
+msgid "Veuillez d'abord choisir un ou plusieurs dictionnaires."
+msgstr "Anta?e bonvolu elekti unu a? plurajn vortarojn."
+
+#: tkinter.py:100
+msgid "Choisir une langue"
+msgstr "Elektu lingvon"
+
+#: tkinter.py:105
+msgid "Annuler"
+msgstr "Nuligi"
+
+#: tkinter.py:125 tkinter.py:204 tkinter.py:294
+msgid "Ajouter"
+msgstr "Almeti"
+
+#: tkinter.py:137
+msgid "Veuillez indiquer un nom de langue dans le champ de texte."
+msgstr "Bonvolu enigi lingvan nomon en la teksta kampo."
+
+#: tkinter.py:137 tkinter.py:142
+msgid "Nom de langue incorrect"
+msgstr "Erara lingva nomo"
+
+#: tkinter.py:142
+msgid "Le nom de langue saisi est d\303\251j\303\240 dans la liste."
+msgstr "La enigita lingva nomo jam estas en la listo."
+
+#: tkinter.py:153
+msgid "dictionnaires"
+msgstr "vortaroj"
+
+#: tkinter.py:160 tkinter.py:268 tkinter.py:344
+msgid "Fermer"
+msgstr "Fermi"
+
+#: tkinter.py:174
+msgid "Sel"
+msgstr "Elekt"
+
+#: tkinter.py:181
+msgid "\303\211dit"
+msgstr "Eldon"
+
+#: tkinter.py:186
+msgid "Voir"
+msgstr "Vid"
+
+#: tkinter.py:191
+msgid "Supp"
+msgstr "Forig"
+
+#: tkinter.py:235
+msgid "\303\212tes-vous certain de vouloir supprimer le dictionnaire intitul\303\251 \"%s\" ?"
+msgstr "?u vi estas certa forigi la vortaron titola \"%s\" ?"
+
+#: tkinter.py:235 tkinter.py:424
+msgid "Confirmation de la suppression"
+msgstr "Konfirmo de la forigo"
+
+#: tkinter.py:244
+msgid "Veuillez indiquer un nom au dictionnaire dans le champ de texte."
+msgstr "Bonvolu enigi vortara nomo en la teksta kampo."
+
+#: tkinter.py:244 tkinter.py:249
+msgid "Nom de dictionnaire incorrect"
+msgstr "Erara vortara nomo"
+
+#: tkinter.py:249
+msgid "Un dictionnaire existant porte d\303\251j\303\240 ce nom. Veuillez en taper un autre."
+msgstr "Ekzistanta vortaro jam havas tiu nomo. Bonvolu enigi alion."
+
+#: tkinter.py:303 tkinter.py:307
+msgid "Libell\303\251 incorrect"
+msgstr "Erara vortigo"
+
+#: tkinter.py:303 tkinter.py:307
+msgid "Veuillez remplir tous les champs de cette bo\303\256te de dialogue."
+msgstr "Bonvolu plenigi cxiujn kampojn de tiu invitilo."
+
+#: tkinter.py:312
+msgid "Ce couple a d\303\251j\303\240 \303\251t\303\251 entr\303\251. Vous ne pouvez pas faire de doublons."
+msgstr "Tiu paro jam estis enigita. Vi ne povas fari duoblojn"
+
+#: tkinter.py:312 tkinter.py:318 tkinter.py:323
+msgid "Doublons d\303\251tect\303\251s"
+msgstr "Eltrova duobloj"
+
+#: tkinter.py:318 tkinter.py:323
+msgid "Le mot %s \"%s\" est d\303\251j\303\240 dans le dictionnaire. \303\212tes-vous certain de l'associer \303\240 un second mot %s ?"
+msgstr "La %s vorto \"%s\" jam estas en la vortaro. ?u vi estas certa de kunligi ?in kun duan %s vorton ?"
+
+#: tkinter.py:401
+msgid "M.A.J"
+msgstr "?isdatig"
+
+#: tkinter.py:424
+msgid "\303\212tes-vous certain de vouloir supprimer le couple de mot \"%s\" / \"%s\" ?"
+msgstr "?u vi estas certa forigi la vortan paron \"%s\" / \"%s\" ?"
+
+#: tkinter.py:456
+msgid "version"
+msgstr "detraduko"
+
+#: tkinter.py:461 tkinter.py:519
+msgid "Terminer"
+msgstr "Fini"
+
+#: tkinter.py:467 tkinter.py:525
+msgid "Score"
+msgstr "Poentaro"
+
+#: tkinter.py:491 tkinter.py:549
+msgid "Valider"
+msgstr "Validigi"
+
+#: tkinter.py:500 tkinter.py:558
+msgid "Faux. La bonne traduction est : \"%s\""
+msgstr "Mal?usta. La ?usta tradukto estas : \"%s\""
+
+#: tkinter.py:500 tkinter.py:558
+msgid "Mauvaise r\303\251ponse"
+msgstr "Mal?usta respondo"
+
+#: tkinter.py:514
+msgid "th\303\250me"
+msgstr "Altraduko"
+

Modified: languetudes/src/common.py
===================================================================
--- languetudes/src/common.py	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/src/common.py	2005-09-02 22:06:14 UTC (rev 113)
@@ -1,3 +1,5 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
 import ConfigParser
 
 class Application:
@@ -32,7 +34,7 @@
         self.connexion = bdd.connect(**params)
         # creation d'un curseur de parcours de resultat SQL
         self.curseur = self.connexion.cursor(bdd.cursors.DictCursor)
-        self.curseur.execute("SHOW tables")
+        self.curseur.execute(u"SHOW tables")
         result = []
         for i in self.curseur.fetchall():
             result.extend(i.values())
@@ -42,94 +44,103 @@
     id INT(9) primary key auto_increment,
     intitule VARCHAR(63),
     langue INT(9) REFERENCES __langue(id),
-    INDEX(langue, intitule)
+    UNIQUE(langue, intitule)
     )""")
             self.curseur.execute("""CREATE TABLE __langue (
     id INT(9) PRIMARY KEY AUTO_INCREMENT,
     intitule VARCHAR(31) NOT NULL,
-    INDEX(intitule)
+    UNIQUE(intitule)
     )""")
         
     def getLangues(self):
         self.curseur.execute("SELECT intitule FROM __langue ORDER BY intitule")
         result = []
         for i in self.curseur.fetchall():
-            result.append(i["intitule"])
+            result.append(i["intitule"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"'))
         return result
         
     def addLangue(self, langue):
-        self.curseur.execute("INSERT INTO __langue(intitule) VALUES('%s')" %langue.lower())
+        langue = langue.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        requete = "INSERT INTO __langue(intitule) VALUES('%s')" %langue.lower()
+        self.curseur.execute(requete.encode("utf-8"))
 
     def getDictionnaires(self, langue):
-        self.curseur.execute("SELECT __dictionnaire.intitule FROM __langue, __dictionnaire WHERE __dictionnaire.langue = __langue.id AND __langue.intitule = '%s' ORDER BY __dictionnaire.intitule" %langue)
+        langue = langue.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        requete = "SELECT __dictionnaire.intitule FROM __langue, __dictionnaire WHERE __dictionnaire.langue = __langue.id AND __langue.intitule = '%s' ORDER BY __dictionnaire.intitule" %langue
+        self.curseur.execute(requete.encode("utf-8"))
         result = []
         for i in self.curseur.fetchall():
             result.append(i["intitule"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"'))
         return result
         
     def addDictionnaire(self, nom, langue):
-        self.curseur.execute("SELECT id FROM __langue WHERE intitule='%s'" %langue)
+        langue = langue.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        requete = "SELECT id FROM __langue WHERE intitule='%s'" %langue
+        self.curseur.execute(requete.encode("utf-8"))
         langue_id = self.curseur.fetchall()[0]["id"]
-        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-        self.curseur.execute("INSERT INTO __dictionnaire(intitule, langue) VALUES('%s', %s)" %(nom, langue_id))
-        self.curseur.execute("SELECT id FROM __dictionnaire WHERE langue=%s AND intitule='%s'" %(langue_id, nom))
+        requete = "INSERT INTO __dictionnaire(intitule, langue) VALUES('%s', %s)" %(nom, langue_id)
+        self.curseur.execute(requete.encode("utf-8"))
+        requete = "SELECT id FROM __dictionnaire WHERE langue=%s AND intitule='%s'" %(langue_id, nom)
+        self.curseur.execute(requete.encode("utf-8"))
         dico_id = self.curseur.fetchall()[0]["id"]
         self.curseur.execute("""CREATE TABLE dico%s(
 id INT(9) PRIMARY KEY AUTO_INCREMENT,
 francais VARCHAR(63) NOT NULL,
 etranger VARCHAR(63) NOT NULL,
-INDEX(francais, etranger),
+UNIQUE(francais, etranger),
 INDEX(etranger, francais)
 )""" %dico_id)
+    
+    def getDicoId(self, langue, nom):
+        langue = langue.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        requete = self.dico_id_sql %(langue, nom)
+        self.curseur.execute(requete.encode("utf-8"))
+        return self.curseur.fetchall()[0]["id"]
         
     def delDictionnaire(self, nom, langue):
-        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-        self.curseur.execute(self.dico_id_sql %(langue, nom))
-        dico_id = self.curseur.fetchall()[0]["id"]
-        self.curseur.execute("DELETE FROM __dictionnaire WHERE id=%s" %dico_id)
-        self.curseur.execute("DROP TABLE dico%s" %dico_id)
+        dico_id = self.getDicoId(langue, nom)
+        self.curseur.execute(u"DELETE FROM __dictionnaire WHERE id=%s" %dico_id)
+        self.curseur.execute(u"DROP TABLE dico%s" %dico_id)
         
     def verifierDoublons(self, langue, nom, francais, etranger):
-        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
+        dico_id = self.getDicoId(langue, nom)
         francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-        self.curseur.execute(self.dico_id_sql %(langue, nom))
-        dico_id = self.curseur.fetchall()[0]["id"]
-        self.curseur.execute("SELECT francais, etranger FROM dico%s WHERE francais='%s' OR etranger='%s'" %(dico_id, francais, etranger))
+        requete = "SELECT francais, etranger FROM dico%s WHERE francais='%s' OR etranger='%s'" %(dico_id, francais, etranger)
+        self.curseur.execute(requete.encode("utf-8"))
         f, e = (False, False)
         for i in self.curseur.fetchall():
-            if i["francais"] == francais and i["etranger"] == etranger:
+            if i["francais"] == francais.encode("utf-8") and i["etranger"] == etranger.encode("utf-8"):
                 return (True, True, True)
-            if i["francais"] == francais:
+            if i["francais"] == francais.encode("utf-8"):
                 f = True
-            if i["etranger"] == etranger:
+            if i["etranger"] == etranger.encode("utf-8"):
                 e = True
         return (f, e, False)
         
     def addCouple(self, langue, nom, francais, etranger):
-        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-        self.curseur.execute(self.dico_id_sql %(langue, nom))
-        dico_id = self.curseur.fetchall()[0]["id"]
-        self.curseur.execute("INSERT INTO dico%s(francais, etranger) VALUES ('%s', '%s')" %(dico_id, francais, etranger))
+        dico_id = self.getDicoId(langue, nom)
+        requete = "INSERT INTO dico%s(francais, etranger) VALUES ('%s', '%s')" %(dico_id, francais, etranger)
+        self.curseur.execute(requete.encode("utf-8"))
         
     def delCouple(self, langue, nom, francais, etranger):
-        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-        self.curseur.execute(self.dico_id_sql %(langue, nom))
-        dico_id = self.curseur.fetchall()[0]["id"]
-        self.curseur.execute("DELETE FROM dico%s WHERE francais='%s' AND etranger='%s'" %(dico_id, francais, etranger))
+        dico_id = self.getDicoId(langue, nom)
+        requete = "DELETE FROM dico%s WHERE francais='%s' AND etranger='%s'" %(dico_id, francais, etranger)
+        self.curseur.execute(requete.encode("utf-8"))
         
     def getCouples(self, langue, nom, ordre="francais ASC", longueur=None, debut=0):
-        nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-        self.curseur.execute(self.dico_id_sql %(langue, nom))
-        dico_id = self.curseur.fetchall()[0]["id"]
-        limit = ""
+        dico_id = self.getDicoId(langue, nom)
+        limit = u""
         if longueur != None:
-            limit = " LIMIT %s, %s" %(debut, longueur)
-        self.curseur.execute("SELECT francais, etranger FROM dico%s ORDER BY %s%s" %(dico_id, ordre, limit))
+            limit = u" LIMIT %s, %s" %(debut, longueur)
+            requete = "SELECT francais, etranger FROM dico%s ORDER BY %s%s" %(dico_id, ordre, limit)
+        self.curseur.execute(requete.encode("utf-8"))
         result = self.curseur.fetchall()
         for i in range(len(result)):
             result[i]["francais"] = result[i]["francais"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
@@ -137,13 +148,12 @@
         return result
         
     def getAleatoire(self, langue, dicos):
-        requete = ""
+        requete = u""
         for nom in dicos:
-            nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-            self.curseur.execute(self.dico_id_sql %(langue, nom))
-            dico_id = self.curseur.fetchall()[0]["id"]
-            requete = requete + "SELECT francais, etranger FROM dico%s UNION " %dico_id
-        self.curseur.execute("%s ORDER BY RAND() LIMIT 1" %(requete[:-7]))
+            dico_id = self.getDicoId(langue, nom)
+            requete = requete + u"SELECT francais, etranger FROM dico%s UNION " %dico_id
+            requete = "%s ORDER BY RAND() LIMIT 1" %(requete[:-7])
+        self.curseur.execute(requete.encode("utf-8"))
         result = self.curseur.fetchall()[0]
         result["francais"] = result["francais"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
         result["etranger"] = result["etranger"].replace("\\\\", "\\").replace("\\'", "'").replace('\\"', '"')
@@ -153,25 +163,23 @@
         francais = francais.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         etranger = etranger.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
         if type == "version":
-            test = "etranger='%s'" %etranger
+            test = u"etranger='%s'" %etranger
         else:
-            test = "francais='%s'" %francais
-        requete = ""
+            test = u"francais='%s'" %francais
+        requete = u""
         for nom in dicos:
-            nom = nom.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
-            self.curseur.execute(self.dico_id_sql %(langue, nom))
-            dico_id = self.curseur.fetchall()[0]["id"]
-            requete = requete + "SELECT francais, etranger FROM dico%s WHERE %s UNION " %(dico_id, test)
-        self.curseur.execute(requete[:-7])
+            dico_id = self.getDicoId(langue, nom)
+            requete = requete + u"SELECT francais, etranger FROM dico%s WHERE %s UNION " %(dico_id, test)
+        self.curseur.execute(requete[:-7].encode("utf-8"))
         result = self.curseur.fetchall()
         if type == "version":
             for i in result:
-                if i["francais"] == francais:
+                if i["francais"] == francais.encode("utf-8"):
                     return True
             return False
         else:
             for i in result:
-                if i["etranger"] == etranger:
+                if i["etranger"] == etranger.encode("utf-8"):
                     return True
             return False
         

Modified: languetudes/src/console.py
===================================================================
--- languetudes/src/console.py	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/src/console.py	2005-09-02 22:06:14 UTC (rev 113)
@@ -1,3 +1,5 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
 import common
 
 class Application(common.Application):

Modified: languetudes/src/ncurses.py
===================================================================
--- languetudes/src/ncurses.py	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/src/ncurses.py	2005-09-02 22:06:14 UTC (rev 113)
@@ -1,3 +1,5 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
 import common
 
 class Application(common.Application):

Modified: languetudes/src/tkinter.py
===================================================================
--- languetudes/src/tkinter.py	2005-09-02 15:41:06 UTC (rev 112)
+++ languetudes/src/tkinter.py	2005-09-02 22:06:14 UTC (rev 113)
@@ -1,13 +1,26 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
 from Tkinter import *
-import tkMessageBox
+import tkMessageBox, gettext
 import common
+
+try:
+    t = gettext.translation('languetudes', './locale')
+    _ = t.ugettext
+except IOError:
+    def ident(s): return s
+    _ = ident
+
+application_name = _("Languetudes")
+application_language = _(u"fran?ais")
     
 class Application(common.Application, Frame, object):
     def __init__(self):
         common.Application.__init__(self)
         Frame.__init__(self)
-        self.master.title("Languetudes")
-        self.__langue = "aucune"
+        self.master.title(application_name)
+        self.aucuneLangue = _("Langue : aucune")
+        self.__langue = self.aucuneLangue
         self.dico = []
         self.pack()
         self.createWidgets()
@@ -19,34 +32,34 @@
         if langue != self.__langue:
             self.dico = []
         self.__langue = langue
-        self.btnLangue["text"] = "Langue : %s" %self.__langue
+        self.btnLangue["text"] = _("Langue : %s") %self.__langue
     langue = property(getLangue, setLangue)
     
     def createWidgets(self):
         self.btnLangue = Button(self)
-        self.btnLangue["text"] = "Langue : %s" %self.__langue
+        self.btnLangue["text"] = self.__langue
         self.btnLangue["command"] = self.choisirLangue
         self.btnLangue["fg"]   = "blue"
         self.btnLangue.pack({"side": "top", "fill": X})
         
         self.btnDico = Button(self)
-        self.btnDico["text"] = "Dictionnaires"
+        self.btnDico["text"] = _("Dictionnaires")
         self.btnDico["command"] = self.dictionnaire
         self.btnDico["fg"]   = "darkgreen"
         self.btnDico.pack({"side": "top", "fill": X})
         
         self.btnVersion = Button(self)
-        self.btnVersion["text"] = "Version"
+        self.btnVersion["text"] = _("Version")
         self.btnVersion["command"] = self.version
         self.btnVersion.pack({"side": "top", "fill": X})
         
         self.btnTheme = Button(self)
-        self.btnTheme["text"] = "Theme"
+        self.btnTheme["text"] = _(u"Th?me")
         self.btnTheme["command"] = self.theme
         self.btnTheme.pack({"side": "top", "fill": X})
         
         self.btnQuit = Button(self)
-        self.btnQuit["text"] = " " * 15 + "Sortie" + " " * 15
+        self.btnQuit["text"] = " " * 15 + _("Sortie") + " " * 15
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.quit
         self.btnQuit.pack({"side": "top", "fill": X})
@@ -55,28 +68,28 @@
         Langue(self)
         
     def dictionnaire(self):
-        if self.langue == "aucune":
-            tkMessageBox.showinfo("Aucune langue selectionnee", "Veuillez d'abord choisir une langue.")
+        if self.langue == self.aucuneLangue:
+            tkMessageBox.showinfo(_(u"Aucune langue selectionn?e"), _(u"Veuillez d'abord choisir une langue."))
             Langue(self)
         else:
             Dictionnaire(self, self.langue)
         
     def version(self):
-        if self.langue == "aucune":
-            tkMessageBox.showinfo("Aucune langue selectionnee", "Veuillez d'abord choisir une langue.")
+        if self.langue == self.aucuneLangue:
+            tkMessageBox.showinfo(_(u"Aucune langue selectionn?e"), _("Veuillez d'abord choisir une langue."))
             Langue(self)
         elif self.dico == []:
-            tkMessageBox.showinfo("Aucun dictionnaire selectionne", "Veuillez d'abord choisir un ou plusieurs dictionnaires.")
+            tkMessageBox.showinfo(_(u"Aucun dictionnaire selectionn?"), _("Veuillez d'abord choisir un ou plusieurs dictionnaires."))
             Dictionnaire(self, self.langue)
         else:
             Version(self, self.langue, self.dico)
     
     def theme(self):
-        if self.langue == "aucune":
-            tkMessageBox.showinfo("Aucune langue selectionnee", "Veuillez d'abord choisir une langue.")
+        if self.langue == self.aucuneLangue:
+            tkMessageBox.showinfo(_(u"Aucune langue selectionn?e"), _("Veuillez d'abord choisir une langue."))
             Langue(self)
         elif self.dico == []:
-            tkMessageBox.showinfo("Aucun dictionnaire selectionne", "Veuillez d'abord choisir un ou plusieurs dictionnaires.")
+            tkMessageBox.showinfo(_(u"Aucun dictionnaire selectionn?"), _("Veuillez d'abord choisir un ou plusieurs dictionnaires."))
             Dictionnaire(self, self.langue)
         else:
             Theme(self, self.langue, self.dico)
@@ -84,12 +97,12 @@
 class Langue(Toplevel):
     def __init__(self, master):
         Toplevel.__init__(self, master)
-        self.title("Choisir une langue")
+        self.title(_("Choisir une langue"))
         self.createWidgets()
         
     def createWidgets(self):
         self.btnQuit = Button(self)
-        self.btnQuit["text"] = "Annuler"
+        self.btnQuit["text"] = _("Annuler")
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.destroy
         self.btnQuit.pack({"side": "top", "fill": X})
@@ -109,7 +122,7 @@
         self.txtAjouter.pack({"side": "top", "fill": X})
         
         self.btnAjouter = Button(self)
-        self.btnAjouter["text"] = "Ajouter"
+        self.btnAjouter["text"] = _("Ajouter")
         self.btnAjouter["fg"]   = "blue"
         self.btnAjouter["command"] =  self.addLangue
         self.btnAjouter.pack({"side": "top", "fill": X})
@@ -121,9 +134,15 @@
     def addLangue(self, event=None):
         txt = self.txtAjouter.get().strip().lower()
         if txt == "":
-            tkMessageBox.showwarning("Nom de langue incorrect", "Veuillez indiquer un nom de langue dans le champ de texte.")
+            tkMessageBox.showwarning(_("Nom de langue incorrect"), _("Veuillez indiquer un nom de langue dans le champ de texte."))
             self.txtAjouter.focus()
             return
+        for btn in self.btn:
+            if btn["text"] == txt:
+                tkMessageBox.showwarning(_("Nom de langue incorrect"), _(u"Le nom de langue saisi est d?j? dans la liste."))
+                self.txtAjouter.delete(0, len(self.txtAjouter.get()))
+                self.txtAjouter.focus()
+                return
         self.master.addLangue(txt)
         self.master.langue = txt
         self.destroy()
@@ -131,14 +150,14 @@
 class Dictionnaire(Toplevel):
     def __init__(self, master, langue):
         Toplevel.__init__(self, master)
-        self.title("%s : dictionnaires" %langue)
+        self.title("%s : %s" %(langue, _("dictionnaires")))
         self.langue = langue
         self.createWidgets()
         
     def createWidgets(self):  
         self.btnQuit = Button(self)
         self.defCouleur = self.btnQuit["bg"]
-        self.btnQuit["text"] = " " * 30 + "Fermer" + " " * 30
+        self.btnQuit["text"] = " " * 30 + _("Fermer") + " " * 30
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.destroy
         self.btnQuit.grid(row=0, columnspan=5)
@@ -152,24 +171,24 @@
             label.grid(row=cptrow, column=0)
             
             btnSelect = Button(self)
-            btnSelect["text"] = "Sel"
+            btnSelect["text"] = _("Sel")
             if dico in self.master.dico:
                 btnSelect["bg"] = "green"
             btnSelect.bind("<Button-1>", self.choisirDico)
             btnSelect.grid(row=cptrow, column=1)
             
             btnEdit = Button(self)
-            btnEdit["text"] = "Edit"
+            btnEdit["text"] = _(u"?dit")
             btnEdit.bind("<Button-1>", self.editerDico)
             btnEdit.grid(row=cptrow, column=2)
             
             btnVoir = Button(self)
-            btnVoir["text"] = "Voir"
+            btnVoir["text"] = _("Voir")
             btnVoir.bind("<Button-1>", self.voirDico)
             btnVoir.grid(row=cptrow, column=3)
             
             btnSuppr = Button(self)
-            btnSuppr["text"] = "Supp"
+            btnSuppr["text"] = _("Supp")
             btnSuppr.bind("<Button-1>", self.supprimerDico)
             btnSuppr.grid(row=cptrow, column=4)
             
@@ -182,7 +201,7 @@
         self.txtAjouter.grid(row=cptrow+1, columnspan=3)
         
         self.btnAjouter = Button(self)
-        self.btnAjouter["text"] = "Ajouter"
+        self.btnAjouter["text"] = _("Ajouter")
         self.btnAjouter["fg"]   = "blue"
         self.btnAjouter["command"] =  self.ajouterDico
         self.btnAjouter.grid(row=cptrow+1, column=3, columnspan=2)
@@ -213,7 +232,7 @@
     def supprimerDico(self, event):
         for i in self.dicos:
             if i[4] == event.widget:
-                if tkMessageBox.askquestion("Confirmation de la suppression", "Etes-vous certain de vouloir supprimer le dictionnaire intitule \"%s\" ?" %i[0]["text"])=="yes":
+                if tkMessageBox.askquestion(_("Confirmation de la suppression"), _(u"?tes-vous certain de vouloir supprimer le dictionnaire intitul? \"%s\" ?") %i[0]["text"])=="yes":
                     self.master.delDictionnaire(i[0]["text"], self.langue)
                     Dictionnaire(self.master, self.langue)
                     self.destroy()
@@ -222,13 +241,13 @@
     def ajouterDico(self, event=None):
         txt = self.txtAjouter.get().strip().lower()
         if txt == "":
-            tkMessageBox.showwarning("Nom de dictionnaire incorrect", "Veuillez indiquer un nom au dictionnaire dans le champ de texte.")
+            tkMessageBox.showwarning(_("Nom de dictionnaire incorrect"), _("Veuillez indiquer un nom au dictionnaire dans le champ de texte."))
             self.txtAjouter.focus()
             return
         for b in self.dicos:
             if b[0]["text"] == txt:
-                tkMessageBox.showwarning("Nom de dictionnaire incorrect", "Un dictionnaire existant porte deja ce nom. Veuillez en taper un autre.")
-                self.txtAjouter.delete(0)
+                tkMessageBox.showwarning(_("Nom de dictionnaire incorrect"), _(u"Un dictionnaire existant porte d?j? ce nom. Veuillez en taper un autre."))
+                self.txtAjouter.delete(0,len(self.txtAjouter.get()))
                 self.txtAjouter.focus()
                 return
         self.master.addDictionnaire(txt, self.langue)
@@ -246,13 +265,13 @@
         
     def createWidgets(self):
         self.btnQuit = Button(self)
-        self.btnQuit["text"] = " " * 15 + "Fermer" + " " * 15
+        self.btnQuit["text"] = " " * 15 + _("Fermer") + " " * 15
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.destroy
         self.btnQuit.grid(row=0, columnspan=2)
         
         self.lblFrancais = Label(self)
-        self.lblFrancais["text"] = "francais"
+        self.lblFrancais["text"] = langue
         self.lblFrancais.grid(row=1, column=0)
         
         self.txtFrancais = Entry(self)
@@ -272,7 +291,7 @@
         self.txtEtranger.grid(row=2, column=1)
         
         self.btnAjouter = Button(self)
-        self.btnAjouter["text"] = "Ajouter"
+        self.btnAjouter["text"] = _("Ajouter")
         self.btnAjouter["fg"]   = "blue"
         self.btnAjouter["command"] =  self.valider
         self.btnAjouter.grid(row=3, columnspan=2)    
@@ -281,28 +300,28 @@
         francais = self.txtFrancais.get().strip().lower()
         etranger = self.txtEtranger.get().strip().lower()
         if francais=="":
-            tkMessageBox.showwarning("Libelle incorrect", "Veuillez remplir tous les champs de cette boite de dialogue.")
+            tkMessageBox.showwarning(_(u"Libell? incorrect"), _(u"Veuillez remplir tous les champs de cette bo?te de dialogue."))
             self.txtFrancais.focus()
             return
         if etranger=="":
-            tkMessageBox.showwarning("Libelle incorrect", "Veuillez remplir tous les champs de cette boite de dialogue.")
+            tkMessageBox.showwarning(_(u"Libell? incorrect"), _(u"Veuillez remplir tous les champs de cette bo?te de dialogue."))
             self.txtEtranger.focus()
             return
         (f, e, d) = self.master.master.verifierDoublons(self.langue, self.dico, francais, etranger)
         if d == True:
-            tkMessageBox.showwarning("Doublons detectes", "Ce couple a deja ete entre. Vous ne pouvez pas faire de doublons.")
-            self.txtEtranger.delete(0)
-            self.txtFrancais.delete(0)
+            tkMessageBox.showwarning(_(u"Doublons d?tect?s"), _(u"Ce couple a d?j? ?t? entr?. Vous ne pouvez pas faire de doublons."))
+            self.txtEtranger.delete(0, len(self.txtEtranger.get()))
+            self.txtFrancais.delete(0, len(self.txtFrancais.get()))
             self.txtFrancais.focus()
             return
         if f == True:
-            if tkMessageBox.askquestion("Doublons detectes", "Le mot francais \"%s\" est deja dans le dictionnaire. Etes-vous certain de l'associer a un second mot %s ?" %(francais, self.langue))=="no":
-                self.txtFrancais.delete(0)
+            if tkMessageBox.askquestion(_(u"Doublons d?tect?s"), _(u"Le mot %s \"%s\" est d?j? dans le dictionnaire. ?tes-vous certain de l'associer ? un second mot %s ?") %(application_language, francais, self.langue))=="no":
+                self.txtFrancais.delete(0, len(self.txtFrancais.get()))
                 self.txtFrancais.focus()
                 return
         if e == True:
-            if tkMessageBox.askquestion("Doublons detectes", "Le mot %s \"%s\" est deja dans le dictionnaire. Etes-vous certain de l'associer a un second mot francais ?" %(self.langue, etranger))=="no":
-                self.txtEtranger.delete(0)
+            if tkMessageBox.askquestion(_(u"Doublons d?tect?s"), _(u"Le mot %s \"%s\" est d?j? dans le dictionnaire. ?tes-vous certain de l'associer ? un second mot %s ?") %(self.langue, etranger, application_language))=="no":
+                self.txtEtranger.delete(0, len(self.txtEtranger.get()))
                 self.txtEtranger.focus()
                 return
         self.master.master.addCouple(self.langue, self.dico, francais, etranger)
@@ -322,13 +341,13 @@
         
     def createWidgets(self):
         self.btnQuit = Button(self)
-        self.btnQuit["text"] = " " * 15 + "Fermer" + " " * 15
+        self.btnQuit["text"] = " " * 15 + _("Fermer") + " " * 15
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.destroy
         self.btnQuit.grid(row=0, columnspan=4)
         
         self.btnFrancais = Button(self)
-        self.btnFrancais["text"] = "francais"
+        self.btnFrancais["text"] = application_language
         self.btnFrancais["fg"]   = "blue"
         self.btnFrancais.bind("<Button-1>", self.changerOrdre)
         self.btnFrancais.grid(row=1, column=0, columnspan=2)
@@ -379,7 +398,7 @@
         self.btnSuiv.grid(row=rowcpt+1, column=2)
         
         self.btnMAJ = Button(self)
-        self.btnMAJ["text"] = "M.A.J"
+        self.btnMAJ["text"] = _("M.A.J")
         self.btnMAJ["fg"]   = "blue"
         self.btnMAJ["command"] = self.mettreAJour
         self.btnMAJ.grid(row=rowcpt+1, column=3)
@@ -402,7 +421,7 @@
     def supprimerCouple(self, event):
         for i in self.couples:
             if i[2] == event.widget:
-                if tkMessageBox.askquestion("Confirmation suppression", "Etes-vous certain de vouloir supprimer le couple de mot \"%s\" / \"%s\"" %(i[0]["text"], i[1]["text"]))=="yes":
+                if tkMessageBox.askquestion(_("Confirmation de la suppression"), _(u"?tes-vous certain de vouloir supprimer le couple de mot \"%s\" / \"%s\" ?") %(i[0]["text"], i[1]["text"]))=="yes":
                     self.master.master.delCouple(self.langue, self.dico, i[0]["text"], i[1]["text"])
                 self.mettreAJour()
                 break
@@ -434,18 +453,18 @@
         self.dicos = dicos
         self.total = total
         self.points = points
-        self.title("%s : version" %(langue))
+        self.title("%s : %s" %(langue, _("version")))
         self.createWidgets()
         
     def createWidgets(self):
         self.btnQuit = Button(self)
-        self.btnQuit["text"] = " " * 15 + "Terminer" + " " * 15
+        self.btnQuit["text"] = " " * 15 + _("Terminer") + " " * 15
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.terminer
         self.btnQuit.grid(row=0, columnspan=2)
         
         self.lblScore = Label(self)
-        self.lblScore["text"] = "Score : %s / %s" %(self.points, self.total)
+        self.lblScore["text"] = "%s : %s / %s" %(_("Score"), self.points, self.total)
         self.lblScore["fg"] = "blue"
         self.lblScore.grid(row=1, columnspan=2)
         
@@ -459,7 +478,7 @@
         self.txtEtranger.grid(row=2, column=1, sticky=W+E)
         
         self.lblFrancais = Label(self)
-        self.lblFrancais["text"] = "francais"
+        self.lblFrancais["text"] = application_language
         self.lblFrancais.grid(row=3, column=0)
         
         self.txtFrancais = Entry(self)
@@ -469,7 +488,7 @@
         self.txtFrancais.grid(row=3, column=1)
         
         self.btnAjouter = Button(self)
-        self.btnAjouter["text"] = "Valider"
+        self.btnAjouter["text"] = _("Valider")
         self.btnAjouter["fg"]   = "blue"
         self.btnAjouter["command"] =  self.valider
         self.btnAjouter.grid(row=4, columnspan=2)
@@ -478,7 +497,7 @@
         if self.master.corriger(self.langue, self.dicos, self.txtFrancais.get(), self.txtEtranger["text"], "version"):
             Version(self.master, self.langue, self.dicos, self.total+1, self.points+1)
         else:
-            tkMessageBox.showinfo("Mauvaise reponse", "Faux. La bonne traduction est : \"%s\"" %self.reponse)
+            tkMessageBox.showinfo(_(u"Mauvaise r?ponse"), _(u"Faux. La bonne traduction est : \"%s\"") %self.reponse)
             Version(self.master, self.langue, self.dicos, self.total+1, self.points)
         self.destroy()
         
@@ -492,23 +511,23 @@
         self.dicos = dicos
         self.total = total
         self.points = points
-        self.title("%s : theme" %(langue))
+        self.title("%s : %s" %(langue, _(u"th?me")))
         self.createWidgets()
         
     def createWidgets(self):
         self.btnQuit = Button(self)
-        self.btnQuit["text"] = " " * 15 + "Terminer" + " " * 15
+        self.btnQuit["text"] = " " * 15 + _("Terminer") + " " * 15
         self.btnQuit["fg"]   = "red"
         self.btnQuit["command"] =  self.terminer
         self.btnQuit.grid(row=0, columnspan=2)
         
         self.lblScore = Label(self)
-        self.lblScore["text"] = "Score : %s / %s" %(self.points, self.total)
+        self.lblScore["text"] = "%s : %s / %s" %(_("Score"), self.points, self.total)
         self.lblScore["fg"] = "blue"
         self.lblScore.grid(row=1, columnspan=2)
         
         self.lblFrancais = Label(self)
-        self.lblFrancais["text"] = "francais"
+        self.lblFrancais["text"] = application_language
         self.lblFrancais.grid(row=2, column=0)
         
         self.txtFrancais = Label(self)
@@ -527,7 +546,7 @@
         self.txtEtranger.grid(row=3, column=1)
         
         self.btnAjouter = Button(self)
-        self.btnAjouter["text"] = "Valider"
+        self.btnAjouter["text"] = _("Valider")
         self.btnAjouter["fg"]   = "blue"
         self.btnAjouter["command"] =  self.valider
         self.btnAjouter.grid(row=4, columnspan=2)
@@ -536,7 +555,7 @@
         if self.master.corriger(self.langue, self.dicos, self.txtFrancais["text"], self.txtEtranger.get(), "theme"):
             Theme(self.master, self.langue, self.dicos, self.total+1, self.points+1)
         else:
-            tkMessageBox.showinfo("Mauvaise reponse", "Faux. La bonne traduction est : \"%s\"" %self.reponse)
+            tkMessageBox.showinfo(_(u"Mauvaise r?ponse"), _(u"Faux. La bonne traduction est : \"%s\"") %self.reponse)
             Theme(self.master, self.langue, self.dicos, self.total+1, self.points)
         self.destroy()
         



From haypo at berlios.de  Mon Sep  5 00:33:01 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 5 Sep 2005 00:33:01 +0200
Subject: [Happyboom-svn] r118 - in happyboom/trunk: . common happywarry happywarry/server
Message-ID: <200509042233.j84MX1OP010026@sheep.berlios.de>

Author: haypo
Date: 2005-09-05 00:32:57 +0200 (Mon, 05 Sep 2005)
New Revision: 118

Added:
   happyboom/trunk/common/log.py
   happyboom/trunk/happywarry/
   happyboom/trunk/happywarry/ChangeLog
   happyboom/trunk/happywarry/happywarry-server.py
   happyboom/trunk/happywarry/server/
   happyboom/trunk/happywarry/server/__init__.py
   happyboom/trunk/happywarry/server/hw_server.py
Log:
Lancement de HappyWarry


Added: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-03 00:19:45 UTC (rev 117)
+++ happyboom/trunk/common/log.py	2005-09-04 22:32:57 UTC (rev 118)
@@ -0,0 +1,54 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
+
+import time
+
+class Log:
+    LOG_INFO   = 0
+    LOG_WARN   = 1
+    LOG_ERROR  = 2
+
+    def __init__(self):
+        self.__buffer = {}
+        self.__file = None
+
+    def setFilename(self, filename):
+        try:
+            self.__file = open(filename, "w")
+        except IOError, errno:
+            if errno[0] == 2:
+                self.__file = None
+                self.info("Log.setFilename(%s) fails : no such file." % filename)
+                return
+            raise
+
+    def dump(self):
+        print self.__buffer
+
+    def getLevelPrefix(self, level):
+        if level==Log.LOG_WARN: return "[warn]"
+        if level==Log.LOG_ERROR: return "[error]"
+        return "[info]"
+
+    def new_message(self, level, str):
+        if not self.__buffer.has_key(level):
+            self.__buffer[level] = [str]
+        else:
+            self.__buffer[level].append(str)
+        print str
+        if self.__file:
+            self.__file.write("%s - %s %s\n" \
+                % (time.strftime("%Y-%M-%d %H:%M:%S"),
+                   self.getLevelPrefix(level),
+                   str))
+
+    def info(self, str):
+        self.new_message(Log.LOG_INFO, str)
+
+    def warn(self, str):
+        self.new_message(Log.LOG_WARN, str)
+
+    def error(self, str):
+        self.new_message(Log.LOG_WARN, str)
+
+log = Log()        

Added: happyboom/trunk/happywarry/ChangeLog
===================================================================
--- happyboom/trunk/happywarry/ChangeLog	2005-09-03 00:19:45 UTC (rev 117)
+++ happyboom/trunk/happywarry/ChangeLog	2005-09-04 22:32:57 UTC (rev 118)
@@ -0,0 +1,5 @@
+2005/09/04
+	- First line of code
+
+Summer 2005
+	- Project started in haypo's head :-)

Added: happyboom/trunk/happywarry/happywarry-server.py
===================================================================
--- happyboom/trunk/happywarry/happywarry-server.py	2005-09-03 00:19:45 UTC (rev 117)
+++ happyboom/trunk/happywarry/happywarry-server.py	2005-09-04 22:32:57 UTC (rev 118)
@@ -0,0 +1,28 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
+VERSION="0.0.0"
+PROGRAM="HappyWarry"
+
+
+def main():
+    # Ajoute APIBoom au PYTHONPATH ("../" pour l'instant)
+    import sys, os
+    sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
+
+    # Cree le systeme de log
+    from common.log import log
+    log.setFilename("/home/haypo/.happywarry/server-log")
+
+    # Instancie une serveur
+    from server.hw_server import HappyWarryServer
+    server = HappyWarryServer()    
+
+    try:
+        log.info("Server started.")
+        server.run()
+    except KeyboardInterrupt:
+        log.info("Program interrupted (CTRL+C).")
+    server.stop()
+    log.info("Server quit.")
+
+if __name__=="__main__": main()


Property changes on: happyboom/trunk/happywarry/happywarry-server.py
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happywarry/server/__init__.py
===================================================================

Added: happyboom/trunk/happywarry/server/hw_server.py
===================================================================
--- happyboom/trunk/happywarry/server/hw_server.py	2005-09-03 00:19:45 UTC (rev 117)
+++ happyboom/trunk/happywarry/server/hw_server.py	2005-09-04 22:32:57 UTC (rev 118)
@@ -0,0 +1,12 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
+
+class HappyWarryServer:
+    def __init__(self):
+        self.x = None
+
+    def run(self):
+        pass
+
+    def stop(self):
+        pass



From haypo at berlios.de  Mon Sep  5 02:02:04 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 5 Sep 2005 02:02:04 +0200
Subject: [Happyboom-svn] r119 - in happyboom/trunk/happywarry: . locale locale/fr locale/fr/LC_MESSAGES
Message-ID: <200509050002.j85024oL028611@sheep.berlios.de>

Author: haypo
Date: 2005-09-05 02:01:49 +0200 (Mon, 05 Sep 2005)
New Revision: 119

Added:
   happyboom/trunk/happywarry/Makefile
   happyboom/trunk/happywarry/locale/
   happyboom/trunk/happywarry/locale/fr/
   happyboom/trunk/happywarry/locale/fr/LC_MESSAGES/
   happyboom/trunk/happywarry/locale/fr/LC_MESSAGES/happywarry.po
Modified:
   happyboom/trunk/happywarry/happywarry-server.py
Log:
Support gettext


Added: happyboom/trunk/happywarry/Makefile
===================================================================
--- happyboom/trunk/happywarry/Makefile	2005-09-04 22:32:57 UTC (rev 118)
+++ happyboom/trunk/happywarry/Makefile	2005-09-05 00:01:49 UTC (rev 119)
@@ -0,0 +1,18 @@
+.PHONY : clean mo
+POT_SOURCES=happywarry-server.py
+POT_OUT=messages.gzz
+what:
+	@echo "Make what?"
+	@echo "o pot: Generate $(POT_OUT) file (gettext)."
+	@echo "o mo: Generate *.mo file (gettext)."
+	@echo "o clean: Remove generated and temporary files (eg. *.pyc)"
+
+mo:
+	@$(foreach file,$(shell find -name "*.po"),echo "Compile $(file)" && msgfmt -o $(patsubst %.po,%.mo,$(file)) $(file))
+	
+pot: $(POT_OUT)
+POT_OUT: $(POT_SOURCES)
+	pygettext -o $(POT_OUT) $(POT_SOURCES)
+
+clean:
+	rm -f $(shell find -name "*.swp" -o -name "*~" -o -name "*.mo" -o -name "*.pyc")

Modified: happyboom/trunk/happywarry/happywarry-server.py
===================================================================
--- happyboom/trunk/happywarry/happywarry-server.py	2005-09-04 22:32:57 UTC (rev 118)
+++ happyboom/trunk/happywarry/happywarry-server.py	2005-09-05 00:01:49 UTC (rev 119)
@@ -2,27 +2,33 @@
 # -*- coding: UTF-8 -*-
 VERSION="0.0.0"
 PROGRAM="HappyWarry"
+import gettext
 
-
 def main():
     # Ajoute APIBoom au PYTHONPATH ("../" pour l'instant)
     import sys, os
-    sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
+    apiboomdir = os.path.join(os.path.dirname(__file__), "..")
+    sys.path.append(apiboomdir)
 
-    # Cree le systeme de log
+    # Setup log
     from common.log import log
     log.setFilename("/home/haypo/.happywarry/server-log")
 
-    # Instancie une serveur
+    # Setup gettext
+    localedir = os.path.join(os.path.dirname(__file__), "./locale")
+    gettext.install('happywarry', localedir, unicode=1)
+
+    # Create the server 
     from server.hw_server import HappyWarryServer
     server = HappyWarryServer()    
-
+   
+    # Run the server
     try:
-        log.info("Server started.")
+        log.info(_("Server started."))
         server.run()
     except KeyboardInterrupt:
-        log.info("Program interrupted (CTRL+C).")
+        log.info(_("Program interrupted (CTRL+C)."))
     server.stop()
-    log.info("Server quit.")
+    log.info(_("Server quit."))
 
 if __name__=="__main__": main()

Added: happyboom/trunk/happywarry/locale/fr/LC_MESSAGES/happywarry.po
===================================================================
--- happyboom/trunk/happywarry/locale/fr/LC_MESSAGES/happywarry.po	2005-09-04 22:32:57 UTC (rev 118)
+++ happyboom/trunk/happywarry/locale/fr/LC_MESSAGES/happywarry.po	2005-09-05 00:01:49 UTC (rev 119)
@@ -0,0 +1,26 @@
+msgid ""
+msgstr ""
+"Project-Id-Version: HappyWarry\n"
+"POT-Creation-Date: \n"
+"PO-Revision-Date: 2005-09-05 01:56+0100\n"
+"Last-Translator: Victor STINNER <victor.stinner at haypocalc.com>\n"
+"Language-Team: Victor Stinner <victor.stinner at haypocalc.com>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=utf-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Poedit-Language: French\n"
+"X-Poedit-Country: FRANCE\n"
+"X-Poedit-SourceCharset: utf-8\n"
+
+#: happywarry-server.py:27
+msgid "Server started."
+msgstr "Le serveur est lanc?."
+
+#: happywarry-server.py:30
+msgid "Program interrupted (CTRL+C)."
+msgstr "Programme interrompu (CTRL+C)."
+
+#: happywarry-server.py:32
+msgid "Server quit."
+msgstr "Le serveur est arr?t?."
+



From haypo at berlios.de  Mon Sep  5 02:28:39 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 5 Sep 2005 02:28:39 +0200
Subject: [Happyboom-svn] r120 - happyboom/trunk/common
Message-ID: <200509050028.j850Sd7P009096@sheep.berlios.de>

Author: haypo
Date: 2005-09-05 02:28:31 +0200 (Mon, 05 Sep 2005)
New Revision: 120

Modified:
   happyboom/trunk/common/log.py
Log:
Comment log class.


Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-05 00:01:49 UTC (rev 119)
+++ happyboom/trunk/common/log.py	2005-09-05 00:28:31 UTC (rev 120)
@@ -13,8 +13,17 @@
         self.__file = None
 
     def setFilename(self, filename):
+        """
+        Use a file to store all messages. The
+        UTF-8 encoding will be used. Write an informative
+        message if the file can't be created.
+
+        @param filename: C{L{string}}
+        """
+
         try:
-            self.__file = open(filename, "w")
+            import codecs
+            self.__file = codecs.open(filename, "w", "utf-8")
         except IOError, errno:
             if errno[0] == 2:
                 self.__file = None
@@ -22,33 +31,58 @@
                 return
             raise
 
-    def dump(self):
-        print self.__buffer
-
     def getLevelPrefix(self, level):
+        """
+        String prefix which depends on message level.
+        Eg. information returns "[info]".
+        @return: C{str}
+        """
         if level==Log.LOG_WARN: return "[warn]"
         if level==Log.LOG_ERROR: return "[error]"
         return "[info]"
 
     def new_message(self, level, str):
+        """
+        Write a new message : append it in the buffer,
+        display it to the screen (if needed), and write
+        it in the log file (if needed).
+
+        @param level: Message level.
+        @type level: C{int}
+        @param str: Message content.
+        @type str: C{str}
+        """
+        
         if not self.__buffer.has_key(level):
             self.__buffer[level] = [str]
         else:
             self.__buffer[level].append(str)
         print str
         if self.__file:
-            self.__file.write("%s - %s %s\n" \
+            self.__file.write(u"%s - %s %s\n" \
                 % (time.strftime("%Y-%M-%d %H:%M:%S"),
                    self.getLevelPrefix(level),
                    str))
 
     def info(self, str):
+        """
+        New informative message.
+        @type str: C{str}
+        """
         self.new_message(Log.LOG_INFO, str)
 
     def warn(self, str):
+        """
+        New warning message.
+        @type str: C{str}
+        """
         self.new_message(Log.LOG_WARN, str)
 
     def error(self, str):
+        """
+        New error message.
+        @type str: C{str}
+        """
         self.new_message(Log.LOG_WARN, str)
 
 log = Log()        



From haypo at berlios.de  Wed Sep  7 19:13:58 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 7 Sep 2005 19:13:58 +0200
Subject: [Happyboom-svn] r121 - happyboom/trunk/happywarry
Message-ID: <200509071713.j87HDwIr025540@sheep.berlios.de>

Author: haypo
Date: 2005-09-07 19:13:52 +0200 (Wed, 07 Sep 2005)
New Revision: 121

Added:
   happyboom/trunk/happywarry/README
Modified:
   happyboom/trunk/happywarry/happywarry-server.py
Log:
Fix HappyWarry initialisation.


Added: happyboom/trunk/happywarry/README
===================================================================
--- happyboom/trunk/happywarry/README	2005-09-05 00:28:31 UTC (rev 120)
+++ happyboom/trunk/happywarry/README	2005-09-07 17:13:52 UTC (rev 121)
@@ -0,0 +1,6 @@
+HappyWarry is a warri game (also knows as Awele) which use HappyBoom kernel.
+
+To try this game, you have to compile gettext messages using this command:
+  make mo
+
+See http://www.happyboom.org/HappyWarry to get more informations.

Modified: happyboom/trunk/happywarry/happywarry-server.py
===================================================================
--- happyboom/trunk/happywarry/happywarry-server.py	2005-09-05 00:28:31 UTC (rev 120)
+++ happyboom/trunk/happywarry/happywarry-server.py	2005-09-07 17:13:52 UTC (rev 121)
@@ -1,23 +1,47 @@
 #!/usr/bin/python
 # -*- coding: UTF-8 -*-
+
+# HappyWarry game
+
 VERSION="0.0.0"
 PROGRAM="HappyWarry"
 import gettext
 
-def main():
-    # Ajoute APIBoom au PYTHONPATH ("../" pour l'instant)
+def init():
+    # Add APIBoom to PYTHONPATH ("../" today, but should be improved)
     import sys, os
-    apiboomdir = os.path.join(os.path.dirname(__file__), "..")
+    file_dir = os.path.dirname(__file__)
+    apiboomdir = os.path.join(file_dir, "..")
     sys.path.append(apiboomdir)
 
-    # Setup log
+    # Get user directory 
     from common.log import log
-    log.setFilename("/home/haypo/.happywarry/server-log")
+    if os.name=="nt":
+        home = os.environ['USERHOME']
+    else:
+        home = os.environ['HOME']
 
+    # Create happywarry directory if needed
+    logdir = os.path.join(home, ".happywarry")
+    try:
+        os.mkdir(logdir)
+    except OSError, err:
+        if err[0]==17: pass
+        logdir = None
+
+    # Setup log filename
+    if logdir != None:
+        logname = os.path.join(logdir, "server-log")    
+        log.setFilename(logname)
+
     # Setup gettext
-    localedir = os.path.join(os.path.dirname(__file__), "./locale")
+    localedir = os.path.join(file_dir, "./locale")
     gettext.install('happywarry', localedir, unicode=1)
 
+def main():
+    # Initialize the application
+    init()
+    
     # Create the server 
     from server.hw_server import HappyWarryServer
     server = HappyWarryServer()    



From haypo at berlios.de  Wed Sep  7 19:19:50 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 7 Sep 2005 19:19:50 +0200
Subject: [Happyboom-svn] r123 - greystoration_gimp
Message-ID: <200509071719.j87HJoOe030242@sheep.berlios.de>

Author: haypo
Date: 2005-09-07 19:19:48 +0200 (Wed, 07 Sep 2005)
New Revision: 123

Modified:
   greystoration_gimp/greycstoration.cpp
Log:
Update the progress bar slower.


Modified: greystoration_gimp/greycstoration.cpp
===================================================================
--- greystoration_gimp/greycstoration.cpp	2005-09-07 17:16:19 UTC (rev 122)
+++ greystoration_gimp/greycstoration.cpp	2005-09-07 17:19:48 UTC (rev 123)
@@ -455,7 +455,7 @@
 		cimg_mapXY(dest,x,y) 
 		{
 			counter++;
-			if (image.use_progress && !((counter)%150)) 
+			if (image.use_progress && !((counter)%100000)) 
 			{
 				gdouble progress = counter;
 				progress /= (gdouble)dest.width*dest.height*nb_iter*(180/dtheta);



From haypo at berlios.de  Wed Sep  7 19:22:45 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 7 Sep 2005 19:22:45 +0200
Subject: [Happyboom-svn] r124 - / greycstoration_gimp
Message-ID: <200509071722.j87HMjjX031216@sheep.berlios.de>

Author: haypo
Date: 2005-09-07 19:22:42 +0200 (Wed, 07 Sep 2005)
New Revision: 124

Added:
   greycstoration_gimp/
   greycstoration_gimp/greycstoration.cpp
Removed:
   greycstoration_gimp/greycstoration.cpp
   greystoration_gimp/
Log:
Fix GREYCstoration dir name.


Copied: greycstoration_gimp (from rev 122, greystoration_gimp)

Deleted: greycstoration_gimp/greycstoration.cpp
===================================================================
--- greystoration_gimp/greycstoration.cpp	2005-09-07 17:16:19 UTC (rev 122)
+++ greycstoration_gimp/greycstoration.cpp	2005-09-07 17:22:42 UTC (rev 124)
@@ -1,592 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "greycstoration.h"
-//----------------------------------------------------------------------------
-using namespace cimg_library;
-typedef unsigned char uchar;
-
-// The line below is necessary for compilation with non-standart C++ compilers.
-#if (( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__))
-#  define std
-#endif
-//----------------------------------------------------------------------------
-
-void get_geom(const char *geom, int &geom_w, int &geom_h) 
-{
-	char tmp[16];
-	std::sscanf(geom,"%d%7[^0-9]%d%7[^0-9]",&geom_w,tmp,&geom_h,tmp+1);
-	if (tmp[0]=='%') geom_w=-geom_w;
-	if (tmp[1]=='%') geom_h=-geom_h;
-}
-
-//----------------------------------------------------------------------------
-
-GREYCstoration::GREYCstoration() : eigen(CImg<>(2,1), CImg<>(2,2))
-{
-	restore = true;
-	inpaint = false;
-	resize = false;
-	visuflow = NULL;
-
-	/* restore */
-	nb_iter        = 1;
-	dt             = 20.0f;
-	sigma          = 0.8f;
-	dlength        = 0.8;
-	dtheta         = 45.0;
-	onormalize     = false;
-	power1         = 0.5;
-	power2         = 0.9;
-
-	/* inpainting *
-	nb_iter                    = 100;
-	dt                         = 50.0f;
-	sigma                      = 2.0;
-	power1                     = 0.1;
-	power2                     = 100;
-	dlength                    = 0.8;
-	dtheta                     = 45.0;
-	 */
-
-	/* resize *
-	nb_iter           = 1;
-	dt                = 30.0f;
-	sigma             = 2.0;
-	dlength           = 0.8;
-	dtheta            = 45.0;
-	power1            = 0.01;
-	power2            = 100.0;
-	 */
-
-	/* visualflow *
-	nb_iter              = 1;
-	dt                   = 30.0f;
-	dlength              = 0.5;
-	dtheta               = 20.0;
-	onormalize = false;
-	*/
-	
-	gauss_prec  = 3.0f;
-	linear = true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::cleanup()
-{
-	img0 = flow = G = dest = sum= W = CImg<>();	
-	mask = CImg<uchar> ();
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare()
-{
-	if (!restore && !inpaint && !resize && !visuflow) 
-	{
-		g_message ("You must specify one of the restore, inpaint, resize or flow mode !");
-		return false;
-	}
-
-	// Init algorithm parameters
-	//---------------------------
-	if (restore) if (!prepare_restore()) return false;
-	if (inpaint) if (!prepare_inpaint()) return false;
-	if (resize) if (!prepare_resize()) return false;
-	if (visuflow) if (!prepare_visuflow()) return false;
-
-	if (!check_args()) return false;
-
-	// Init images
-	//------------
-	dest = CImg<>(img.width,img.height,1,img.dim);
-	sum = CImg<>(img.width,img.height,1);
-	W = CImg<>(img.width,img.height,1,2);
-	
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::check_args()
-{
-	if (power2 < power1)
-	{
-		g_message ("Error : p2<p1 !");
-		return false;
-	}
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_restore()
-{
-	CImgStats stats(img,false);
-	img.normalize((float)stats.min, (float)stats.max);
-	img0=img;
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_inpaint()
-{
-	const char *file_m         = NULL; //cimg_option("-m",(const char*)NULL,"Input inpainting mask");
-	if (!file_m) 
-	{
-		g_message ("You need to specify an inpainting mask (option '-m') !");
-		return false;
-	}
-
-	const unsigned int dilate  = 0; //cimg_option("-dilate",0,"Inpainting mask dilatation");
-	const unsigned int ip_init = 3; //cimg_option("-init",3,"Inpainting init (0=black, 1=white, 2=noise, 3=unchanged, 4=interpol)");
-	if (cimg::strncasecmp("block",file_m,5)) mask = CImg<uchar>(file_m);
-	else {
-		int l=16; std::sscanf(file_m,"block%d",&l);
-		mask = CImg<uchar>(img.width/l,img.height/l);
-		cimg_mapXY(mask,x,y) mask(x,y)=(x+y)%2;
-	}
-	mask.resize(img.width,img.height,1,1);
-	if (dilate) mask.dilate(dilate);
-	switch (ip_init) {
-		case 0 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 0; } break;
-		case 1 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 255; } break;
-		case 2 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = (float)(255*cimg::rand()); } break;
-		case 3 : break;
-		case 4 : {
-					 CImg<uchar> tmask(mask),ntmask(tmask);
-					 CImg_3x3(M,uchar);
-					 CImg_3x3(I,float);
-					 while (CImgStats(ntmask,false).max>0) {
-						 cimg_map3x3(tmask,x,y,0,0,M) if (Mcc && (!Mpc || !Mnc || !Mcp || !Mcn)) {
-							 const float ccp = Mcp?0.0f:1.0f, cpc = Mpc?0.0f:1.0f,
-								   cnc = Mnc?0.0f:1.0f, ccn = Mcn?0.0f:1.0f, csum = ccp + cpc + cnc + ccn;
-							 cimg_mapV(img,k) {
-								 cimg_get3x3(img,x,y,0,k,I);
-								 img(x,y,k) = (ccp*Icp + cpc*Ipc + cnc*Inc + ccn*Icn)/csum;
-							 }
-							 ntmask(x,y) = 0;
-						 }
-						 tmask = ntmask;
-					 }
-				 } break;    
-		default: break;
-	}
-	img0=img;
-	G = CImg<>(img.width,img.height,1,3,0);
-	CImg_3x3(g,uchar);
-	CImg_3x3(I,float);
-	cimg_map3x3(mask,x,y,0,0,g) if (!gcc && !(gnc-gcc) && !(gcc-gpc) && !(gcn-gcc) && !(gcc-gcp)) cimg_mapV(img,k) {
-		cimg_get3x3(img,x,y,0,k,I);
-		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
-		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
-	}
-	G.blur(sigma);
-	{ cimg_mapXY(G,x,y) 
-		{
-			G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
-			const float
-				l1 = eigen(0)[0],
-				   l2 = eigen(0)[1],
-				   u = eigen(1)[0],
-				   v = eigen(1)[1],      
-				   ng = (float)std::sqrt(l1+l2),
-				   n1 = (float)(1.0/std::pow(1+ng,power1)),
-				   n2 = (float)(1.0/std::pow(1+ng,power2)),
-				   sr1 = (float)std::sqrt(n1),
-				   sr2 = (float)std::sqrt(n2);
-			G(x,y,0) = sr1*u*u + sr2*v*v;
-			G(x,y,1) = u*v*(sr1-sr2);
-			G(x,y,2) = sr1*v*v + sr2*u*u;
-		}    
-	}
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_resize()
-{
-	const char *geom  = NULL; //cimg_option("-g",(const char*)NULL,"Output image geometry");
-	const bool anchor = true; //cimg_option("-anchor",true,"Anchor original pixels");
-	if (!geom) throw CImgArgumentException("You need to specify an output geomety (option -g)");
-	int w,h; get_geom(geom,w,h);
-	mask = CImg<uchar>(img.width,img.height,1,1,255);
-	if (!anchor) mask.resize(w,h,1,1,1); else mask = ~mask.resize(w,h,1,1,4);
-	img0 = img.get_resize(w,h,1,-100,1);
-	img.resize(w,h,1,-100,3);
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_visuflow()
-{
-	const char *geom     = "100%x100%"; //cimg_option("-g","100%x100%","Output geometry");
-	//const char *file_i   = (const char *)NULL; //cimg_option("-i",(const char*)NULL,"Input init image");
-	const bool normalize = false; //cimg_option("-norm",false,"Normalize input flow");
-
-	int w,h; get_geom(geom,w,h);
-	if (!cimg::strcasecmp(visuflow,"circle")) { // Create a circular vector flow
-		flow = CImg<>(400,400,1,2);
-		cimg_mapXY(flow,x,y) {
-			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
-			flow(x,y,0) = -(float)std::sin(ang);
-			flow(x,y,1) = (float)std::cos(ang);
-		}
-	}
-	if (!cimg::strcasecmp(visuflow,"radial")) { // Create a radial vector flow
-		flow = CImg<>(400,400,1,2);
-		cimg_mapXY(flow,x,y) {
-			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
-			flow(x,y,0) = (float)std::cos(ang);
-			flow(x,y,1) = (float)std::sin(ang);
-		}
-	}
-	if (!flow.data) flow = CImg<>(visuflow);
-	flow.resize(w,h,1,2,3);
-	if (normalize) flow.orientation_pointwise();
-	/*    if (file_i) img = CImg<>(file_i);
-		  else img = CImg<>(flow.width,flow.height,1,1,0).noise(100,2); */
-	img0=img;
-	img0.fill(0);
-	float color[3]={255,255,255};
-	img0.draw_quiver(flow,color,15,-10);
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_smoothed_tensor()
-{
-	if (visuflow || inpaint) return;
-	CImg_3x3(I,float);
-	G.fill(0);
-	cimg_mapV(img,k) cimg_map3x3(img,x,y,0,k,I) {
-		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
-		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
-	}
-	G.blur(sigma);
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_normalized_tensor()
-{
-	if (restore || resize) cimg_mapXY(G,x,y) {
-		G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
-		const float
-			l1 = eigen(0)[0],
-			   l2 = eigen(0)[1],
-			   u = eigen(1)[0],
-			   v = eigen(1)[1],      
-			   n1 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power1)),
-			   n2 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power2));
-		G(x,y,0) = n1*u*u + n2*v*v;
-		G(x,y,1) = u*v*(n1-n2);
-		G(x,y,2) = n1*v*v + n2*u*u;
-	}    
-	if (visuflow) cimg_mapXY(G,x,y) {
-		const float 
-			u = flow(x,y,0),
-			  v = flow(x,y,1),
-			  n = (float)std::pow(u*u+v*v,0.25f),
-			  nn = n<1e-5?1:nn;
-		G(x,y,0) = u*u/nn;
-		G(x,y,1) = u*v/nn;
-		G(x,y,2) = v*v/nn;
-	}
-
-	const CImgStats stats(G,false);
-	G /= cimg::max(std::fabs(stats.max), std::fabs(stats.min));
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_W(float cost, float sint)
-{
-	cimg_mapXY(W,x,y) {
-		const float 
-			a = G(x,y,0),
-			  b = G(x,y,1),
-			  c = G(x,y,2),
-			  u = a*cost + b*sint,
-			  v = b*cost + c*sint;
-		W(x,y,0) = u;
-		W(x,y,1) = v;
-	}
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_LIC_back_forward(int x, int y)
-{
-	float l, X,Y, cu, cv, lsum=0;
-	const float fsigma2 = 2*dt*(W(x,y,0)*W(x,y,0) + W(x,y,1)*W(x,y,1));
-	const float length = gauss_prec*(float)std::sqrt(fsigma2);
-
-	if (linear) {
-
-		// Integrate with linear interpolation
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = (float)x; 
-		Y  = (float)y;
-		for (l=0; l<length; l+=dlength) 
-		{
-			float u = (float)W.linear_pix2d(X,Y,0);
-			float v = (float)W.linear_pix2d(X,Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X+=dlength*u;
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y+=dlength*v; 
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-		
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = x-dlength*cu; 
-		Y  = y-dlength*cv;
-		for (l=dlength; l<length; l+=dlength) 
-		{
-			float u = (float)W.linear_pix2d(X,Y,0);
-			float v = (float)W.linear_pix2d(X,Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k)+=(float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X-=dlength*u;
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y-=dlength*v;
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u;
-			cv=v;
-		}
-
-	} else {
-
-		// Integrate with non linear interpolation
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = (float)x; 
-		Y  = (float)y; 
-		for (l=0; l<length; l+=dlength) 
-		{
-			float u = W((int)X,(int)Y,0);
-			float v = W((int)X,(int)Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X+=dlength*u; 
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y+=dlength*v; 
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-		
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = x-dlength*cu; 
-		Y  = y-dlength*cv;
-		for (l=dlength; l<length && X>=0 && Y>=0 && X<=W.dimx()-1 && Y<=W.dimy()-1; l+=dlength) 
-		{
-			float u = W((int)X,(int)Y,0);
-			float v = W((int)X,(int)Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X-=dlength*u; 
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y-=dlength*v;
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-	}
-	sum(x,y)+=lsum;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_LIC(int &counter)
-{
-	dest.fill(0);
-	sum.fill(0);
-	for (float theta=(180%(int)dtheta)/2.0f; theta<180; theta+=dtheta) 
-	{
-		const float
-			rad = (float)(theta*cimg::PI/180.0),
-				cost = (float)std::cos(rad),
-				sint = (float)std::sin(rad);
-
-		// Compute vector field w = sqrt(T)*a_alpha
-		compute_W(cost, sint);
-
-		// Compute the LIC along w in backward and forward directions
-		cimg_mapXY(dest,x,y) 
-		{
-			counter++;
-			if (image.use_progress && !((counter)%150)) 
-			{
-				gdouble progress = counter;
-				progress /= (gdouble)dest.width*dest.height*nb_iter*(180/dtheta);
-				gimp_progress_update (progress);
-			}
-			
-			if (!mask.data || mask(x,y)) compute_LIC_back_forward(x,y);
-		}
-	}
-
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_average_LIC()
-{
-	cimg_mapXY(dest,x,y) 
-	{
-		if (sum(x,y)>0) 
-			cimg_mapV(dest,k) dest(x,y,k) /= sum(x,y); 
-		else 
-			cimg_mapV(dest,k) dest(x,y,k) = img(x,y,k);
-	}
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::process()
-{
-	if (!prepare()) return false;
-
-	//-------------------------------------
-	// Begin regularization PDE iterations
-	//-------------------------------------
-	int counter = 0;
-	for (unsigned int iter=0; iter<nb_iter; iter++) 
-	{
-		// Compute smoothed structure tensor field G
-		compute_smoothed_tensor();
-
-		// Compute normalized tensor field sqrt(T) in G
-		compute_normalized_tensor();
-
-		// Compute LIC's along different angle projections a_\alpha
-		compute_LIC(counter);
-
-		// Average all the LIC's
-		compute_average_LIC();
-
-		// Next step
-		img = dest;
-	}
-
-	// Save result and end program
-	//-----------------------------
-	if (visuflow) dest.mul(flow.get_norm_pointwise()).normalize(0,255);
-	if (onormalize) dest.normalize(0,255);
-	cleanup();
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::load_picture(Image &cfg)
-{
-	guchar* row = g_new (guchar, cfg.width), *row_ptr;
-
-	img = CImg<>(cfg.sel_width, cfg.sel_height, 1, 3);
-
-	for (gint y=0; y < cfg.sel_height; y++)
-	{
-		gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		row_ptr = row;
-		if (image.img_alpha) {
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				img(x, y,0) = row_ptr[0];
-				img(x, y,1) = row_ptr[1];
-				img(x, y,2) = row_ptr[2];
-				row_ptr += 4;
-			}	
-		} else {
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				img(x, y,0) = row_ptr[0];
-				img(x, y,1) = row_ptr[1];
-				img(x, y,2) = row_ptr[2];
-				row_ptr += 3;
-			}	
-		}
-	}
-	g_free (row);
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::store_picture(Image &cfg)
-{
-	guchar* row = g_new (guchar, cfg.width), *row_ptr;
-
-	if (image.img_alpha)
-	{
-		for (gint y=0; y < cfg.sel_height; y++)
-		{
-			gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-			row_ptr = row;
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
-				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
-				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
-				row_ptr += 4;
-			}
-			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		}
-	} else {
-		for (gint y=0; y < cfg.sel_height; y++)
-		{
-			row_ptr = row;
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
-				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
-				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
-				row_ptr += 3;
-			}
-			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		}
-	}
-
-	g_free (row);
-}
-
-//----------------------------------------------------------------------------

Copied: greycstoration_gimp/greycstoration.cpp (from rev 123, greystoration_gimp/greycstoration.cpp)



From haypo at berlios.de  Thu Sep  8 03:01:24 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 8 Sep 2005 03:01:24 +0200
Subject: [Happyboom-svn] r125 - / happyboom/trunk
Message-ID: <200509080101.j8811O12027814@sheep.berlios.de>

Author: haypo
Date: 2005-09-08 03:01:18 +0200 (Thu, 08 Sep 2005)
New Revision: 125

Added:
   boomboom/
   happywarry/
Removed:
   happyboom/trunk/boomboom/
   happyboom/trunk/happywarry/
Log:
Move HappyWarry and BoomBoom to root.


Copied: boomboom (from rev 123, happyboom/trunk/boomboom)

Copied: happywarry (from rev 123, happyboom/trunk/happywarry)



From dboucard at berlios.de  Thu Sep  8 03:07:25 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 8 Sep 2005 03:07:25 +0200
Subject: [Happyboom-svn] r126 - in languetudes: . trunk
Message-ID: <200509080107.j8817PIB028023@sheep.berlios.de>

Author: dboucard
Date: 2005-09-08 03:07:22 +0200 (Thu, 08 Sep 2005)
New Revision: 126

Added:
   languetudes/trunk/languetudes.conf
   languetudes/trunk/languetudes.py
   languetudes/trunk/languetudes.test.sql
   languetudes/trunk/locale/
   languetudes/trunk/src/
Removed:
   languetudes/languetudes.conf
   languetudes/languetudes.py
   languetudes/languetudes.test.sql
   languetudes/locale/
   languetudes/src/
Log:
deplacement vers trunk/


Deleted: languetudes/languetudes.conf
===================================================================
--- languetudes/languetudes.conf	2005-09-08 01:01:18 UTC (rev 125)
+++ languetudes/languetudes.conf	2005-09-08 01:07:22 UTC (rev 126)
@@ -1,15 +0,0 @@
-################################
-# CONFIGURATION DE LANGUETUDES #
-#               Version Python #
-################################
-
-# Configuration base de donnees
-# #############################
-# "type" est le nom du module python utilise
-# ce module doit respecter le standard API-DB
-[Base]
-type=MySQLdb
-hote=localhost
-utilisateur=languetudes
-#motpasse=prout
-nombase=languetudes

Deleted: languetudes/languetudes.py
===================================================================
--- languetudes/languetudes.py	2005-09-08 01:01:18 UTC (rev 125)
+++ languetudes/languetudes.py	2005-09-08 01:07:22 UTC (rev 126)
@@ -1,47 +0,0 @@
-#!/usr/bin/python
-# -*- coding: UTF-8 -*-
-import sys, getopt
-
-usage = """
-USAGE:
-    %s [--ihm <interface>]
-    %s -h | --help
-
-Les IHM disponibles sont :
- ** console : mode interactif dans un terminal texte.
- ** ncurses : interface graphique dans un terminal texte.
- ** tkinter : interface graphique utilisant la bibiotheque TK.
-""" % (sys.argv[0], sys.argv[0])
-
-ihm = ("console", "ncurse", "tkinter")
-
-def main():
-    ihmModule = "tkinter"
-    try:
-        opts, args = getopt.getopt(sys.argv[1:], "h", ["help", "ihm="])
-    except getopt.GetoptError:
-        print "ERREUR: usage incorrect."
-        print usage
-        sys.exit(1)
-    for o, a in opts:
-        if o in ("-h", "--help"):
-            print usage
-            sys.exit()
-        elif o == "--ihm":
-            if a in ihm:
-                ihmModule = a
-            else:
-                print "ERREUR: ihm incorrect."
-                print usage
-                sys.exit(2)
-    try:
-        src = __import__("src", globals(),  locals(), [ihmModule])
-        mod = getattr(src, ihmModule)
-        mod.Application()
-    except ImportError, errmsg:
-        print "Erreur : un module Python est absent alors qu'il est n?cessaire."
-        print errmsg
-        sys.exit(1)
-
-if __name__ == "__main__":
-    main()

Deleted: languetudes/languetudes.test.sql
===================================================================
--- languetudes/languetudes.test.sql	2005-09-08 01:01:18 UTC (rev 125)
+++ languetudes/languetudes.test.sql	2005-09-08 01:07:22 UTC (rev 126)
@@ -1,178 +0,0 @@
--- MySQL dump 9.11
---
--- Host: localhost    Database: languetudes
--- ------------------------------------------------------
--- Server version	4.0.23_Debian-3ubuntu2-log
-
---
--- Table structure for table `__dictionnaire`
---
-
-DROP TABLE IF EXISTS `__dictionnaire`;
-CREATE TABLE `__dictionnaire` (
-  `id` int(9) NOT NULL auto_increment,
-  `intitule` varchar(63) default NULL,
-  `langue` int(9) default NULL,
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `langue` (`langue`,`intitule`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `__dictionnaire`
---
-
-
-/*!40000 ALTER TABLE `__dictionnaire` DISABLE KEYS */;
-LOCK TABLES `__dictionnaire` WRITE;
-INSERT INTO `__dictionnaire` VALUES (13,'nombres',5),(7,'test',7),(12,'lecon no1',8),(10,'test2',7),(11,'nombres',6);
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `__dictionnaire` ENABLE KEYS */;
-
---
--- Table structure for table `__langue`
---
-
-DROP TABLE IF EXISTS `__langue`;
-CREATE TABLE `__langue` (
-  `id` int(9) NOT NULL auto_increment,
-  `intitule` varchar(31) NOT NULL default '',
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `intitule` (`intitule`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `__langue`
---
-
-
-/*!40000 ALTER TABLE `__langue` DISABLE KEYS */;
-LOCK TABLES `__langue` WRITE;
-INSERT INTO `__langue` VALUES (5,'roumain'),(6,'anglais'),(7,'esperanto'),(8,'chinois');
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `__langue` ENABLE KEYS */;
-
---
--- Table structure for table `dico10`
---
-
-DROP TABLE IF EXISTS `dico10`;
-CREATE TABLE `dico10` (
-  `id` int(9) NOT NULL auto_increment,
-  `francais` varchar(63) NOT NULL default '',
-  `etranger` varchar(63) NOT NULL default '',
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `francais` (`francais`,`etranger`),
-  KEY `etranger` (`etranger`,`francais`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `dico10`
---
-
-
-/*!40000 ALTER TABLE `dico10` DISABLE KEYS */;
-LOCK TABLES `dico10` WRITE;
-INSERT INTO `dico10` VALUES (1,'un','unu'),(2,'deux','du'),(3,'trois','tri'),(4,'quatre','kvar'),(5,'cinq','kvin'),(6,'six','ses'),(7,'sept','sep'),(8,'huit','ok'),(9,'neuf','naux'),(10,'dix','dek');
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `dico10` ENABLE KEYS */;
-
---
--- Table structure for table `dico11`
---
-
-DROP TABLE IF EXISTS `dico11`;
-CREATE TABLE `dico11` (
-  `id` int(9) NOT NULL auto_increment,
-  `francais` varchar(63) NOT NULL default '',
-  `etranger` varchar(63) NOT NULL default '',
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `francais` (`francais`,`etranger`),
-  KEY `etranger` (`etranger`,`francais`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `dico11`
---
-
-
-/*!40000 ALTER TABLE `dico11` DISABLE KEYS */;
-LOCK TABLES `dico11` WRITE;
-INSERT INTO `dico11` VALUES (1,'un','one'),(2,'deux','two'),(3,'trois','three'),(4,'quatre','four'),(5,'cinq','five'),(6,'six','six'),(7,'sept','seven'),(8,'huit','eight'),(9,'neuf','nine'),(10,'dix','ten');
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `dico11` ENABLE KEYS */;
-
---
--- Table structure for table `dico12`
---
-
-DROP TABLE IF EXISTS `dico12`;
-CREATE TABLE `dico12` (
-  `id` int(9) NOT NULL auto_increment,
-  `francais` varchar(63) NOT NULL default '',
-  `etranger` varchar(63) NOT NULL default '',
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `francais` (`francais`,`etranger`),
-  KEY `etranger` (`etranger`,`francais`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `dico12`
---
-
-
-/*!40000 ALTER TABLE `dico12` DISABLE KEYS */;
-LOCK TABLES `dico12` WRITE;
-INSERT INTO `dico12` VALUES (1,'tu','ni'),(2,'bien','hao'),(3,'vieux','lao'),(4,'roi','wang'),(5,'cheval','ma'),(6,'je','wo'),(7,'assez','hen'),(8,'petit','xiao'),(9,'il','ta'),(10,'et ... ?','ne'),(11,'elle','ta'),(12,'aussi','ye'),(13,'et','he'),(14,'demander','wen');
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `dico12` ENABLE KEYS */;
-
---
--- Table structure for table `dico13`
---
-
-DROP TABLE IF EXISTS `dico13`;
-CREATE TABLE `dico13` (
-  `id` int(9) NOT NULL auto_increment,
-  `francais` varchar(63) NOT NULL default '',
-  `etranger` varchar(63) NOT NULL default '',
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `francais` (`francais`,`etranger`),
-  KEY `etranger` (`etranger`,`francais`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `dico13`
---
-
-
-/*!40000 ALTER TABLE `dico13` DISABLE KEYS */;
-LOCK TABLES `dico13` WRITE;
-INSERT INTO `dico13` VALUES (1,'un','unu'),(2,'deux','doi'),(3,'trois','trei'),(4,'quatre','patru'),(5,'cinq','cinci'),(6,'six','sase'),(7,'sept','sapte'),(8,'huit','opt'),(9,'neuf','noua'),(10,'dix','zece');
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `dico13` ENABLE KEYS */;
-
---
--- Table structure for table `dico7`
---
-
-DROP TABLE IF EXISTS `dico7`;
-CREATE TABLE `dico7` (
-  `id` int(9) NOT NULL auto_increment,
-  `francais` varchar(63) NOT NULL default '',
-  `etranger` varchar(63) NOT NULL default '',
-  PRIMARY KEY  (`id`),
-  UNIQUE KEY `francais` (`francais`,`etranger`),
-  KEY `etranger` (`etranger`,`francais`)
-) TYPE=MyISAM;
-
---
--- Dumping data for table `dico7`
---
-
-
-/*!40000 ALTER TABLE `dico7` DISABLE KEYS */;
-LOCK TABLES `dico7` WRITE;
-INSERT INTO `dico7` VALUES (1,'eau','akvo'),(2,'tasse','taso'),(3,'cafe','kafo'),(4,'homme','viro'),(5,'fils','filo'),(6,'garcon','knabo'),(7,'the','teo'),(8,'ami','amiko'),(9,'etre','esti'),(10,'nouveau','nova'),(11,'en bonne sante','sana'),(12,'je','mi'),(13,'tu','vi'),(14,'il','li'),(15,'elle','sxi'),(16,'nous','ni'),(17,'vous','vi'),(19,'ils','ili'),(20,'elles','ili'),(21,'on','oni'),(22,'soi-meme','si');
-UNLOCK TABLES;
-/*!40000 ALTER TABLE `dico7` ENABLE KEYS */;
-

Copied: languetudes/trunk/languetudes.conf (from rev 124, languetudes/languetudes.conf)

Copied: languetudes/trunk/languetudes.py (from rev 124, languetudes/languetudes.py)

Copied: languetudes/trunk/languetudes.test.sql (from rev 124, languetudes/languetudes.test.sql)

Copied: languetudes/trunk/locale (from rev 124, languetudes/locale)

Copied: languetudes/trunk/src (from rev 124, languetudes/src)



From haypo at berlios.de  Thu Sep  8 04:55:39 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 8 Sep 2005 04:55:39 +0200
Subject: [Happyboom-svn] r127 - boomboom boomboom/client happyboom/trunk/net/io happyboom/trunk/net/io_tcp happyboom/trunk/server happywarry
Message-ID: <200509080255.j882tdRG018898@sheep.berlios.de>

Author: haypo
Date: 2005-09-08 04:55:34 +0200 (Thu, 08 Sep 2005)
New Revision: 127

Removed:
   boomboom/net
Modified:
   boomboom/boomboom_client.py
   boomboom/boomboom_server.py
   boomboom/client/bb_client.py
   boomboom/client/bb_display.py
   boomboom/client/bb_input.py
   happyboom/trunk/net/io/base_io.py
   happyboom/trunk/net/io/packet.py
   happyboom/trunk/net/io_tcp/tcp.py
   happyboom/trunk/server/base_server.py
   happywarry/happywarry-server.py
Log:
Fix BoomBoom and HappyWarry to use new directory structure. Fix TCP to
support unreachable server.


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-08 01:07:22 UTC (rev 126)
+++ boomboom/boomboom_client.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -6,82 +6,89 @@
 import time
 import socket
 import sys
-import pygame
-from client import BoomBoomClient
 
 def usage(defval):
-	print "%s version %s" % (PROGRAM, VERSION)
-	print ""
-	print "Usage: %s [options] [yourname]" % (sys.argv[0])
-	print
-	print "Options :"
-	print "\t--help            : Print this help"
-	print "\t--version         : Print the software version"
-	print "\t-h,--host HOST    : Server ip/name (default %s)" % (defval["host"])
-	print "\t--view-port PORT  : Server view port (default %u)" % (defval["view_port"])
-	print "\t--input-port PORT : Server input port (default %u)" % (defval["input_port"])
-	print "\t-d,--debug        : Enable debug mode"
-	print "\t-v,--verbose      : Enable verbose mode"
-	print "\t--max-fps MAX     : Set maximum frame par second (fps)"
+    print "%s version %s" % (PROGRAM, VERSION)
+    print ""
+    print "Usage: %s [options] [yourname]" % (sys.argv[0])
+    print
+    print "Options :"
+    print "\t--help            : Print this help"
+    print "\t--version         : Print the software version"
+    print "\t-h,--host HOST    : Server ip/name (default %s)" % (defval["host"])
+    print "\t--view-port PORT  : Server view port (default %u)" % (defval["view_port"])
+    print "\t--input-port PORT : Server input port (default %u)" % (defval["input_port"])
+    print "\t-d,--debug        : Enable debug mode"
+    print "\t-v,--verbose      : Enable verbose mode"
+    print "\t--max-fps MAX     : Set maximum frame par second (fps)"
 
 def parseArgs(val):
-	import getopt
+    import getopt
 
-	defval = val.copy()
-	try:
-		short = "h:dv"
-		long = ["debug", "help", "version", "verbose", \
-			"view-port=", "input-port=",
-			"host=", "max-fps="]
-		opts, args = getopt.getopt(sys.argv[1:], short, long)
-	except getopt.GetoptError:
-		usage(defval)
-		sys.exit(2)
+    defval = val.copy()
+    try:
+        short = "h:dv"
+        long = ["debug", "help", "version", "verbose", \
+            "view-port=", "input-port=",
+            "host=", "max-fps="]
+        opts, args = getopt.getopt(sys.argv[1:], short, long)
+    except getopt.GetoptError:
+        usage(defval)
+        sys.exit(2)
 
-	if 0<len(args): val["name"] = args[0]
-		
-	for o, a in opts:
-		if o == "--help":
-			usage(defval)
-			sys.exit()
-		if o == "--version":
-			print "%s version %s" % (PROGRAM, VERSION)
-		if o == "--input-port":
-			val["input_port"] = int(a)
-		if o == "--view-port":
-			val["view_port"] = int(a)
-		if o in ("-h", "--host",):
-			val["host"] = a
-		if o in ("-v", "--verbose",):
-			val["verbose"] = True
-		if o == "--max-fps":
-			a = int(a)
-			if a < 1: a=1
-			elif 100<a: a=100
-			val["max_fps"] = a
-		if o in ("-d", "--debug",):
-			val["debug"] = True
-	return val
+    if 0<len(args): val["name"] = args[0]
+        
+    for o, a in opts:
+        if o == "--help":
+            usage(defval)
+            sys.exit()
+        if o == "--version":
+            print "%s version %s" % (PROGRAM, VERSION)
+        if o == "--input-port":
+            val["input_port"] = int(a)
+        if o == "--view-port":
+            val["view_port"] = int(a)
+        if o in ("-h", "--host",):
+            val["host"] = a
+        if o in ("-v", "--verbose",):
+            val["verbose"] = True
+        if o == "--max-fps":
+            a = int(a)
+            if a < 1: a=1
+            elif 100<a: a=100
+            val["max_fps"] = a
+        if o in ("-d", "--debug",):
+            val["debug"] = True
+    return val
 
 def main():
-	val = {
-		"host": "127.0.0.1", \
-		"view_port": 12430, \
-		"input_port": 12431, \
-		"max_fps": 50, \
-		"verbose": False, \
-		"name": "-", \
-		"debug": False}
-	arg = parseArgs(val)
+    # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
+    import sys, os
+    file_dir = os.path.dirname(__file__)
+    happyboomdir = os.path.join(file_dir, "../happyboom/trunk")
+    sys.path.append(happyboomdir)
+ 
+    val = {
+        "host": "127.0.0.1", \
+        "view_port": 12430, \
+        "input_port": 12431, \
+        "max_fps": 50, \
+        "verbose": False, \
+        "name": "-", \
+        "debug": False}
+    arg = parseArgs(val)
 
-	client = BoomBoomClient(arg["host"], arg["view_port"], arg["input_port"],\
-							 arg["verbose"], arg["debug"], arg["max_fps"])
-	try:
-		client.start()
-	except KeyboardInterrupt:
-		print "Program interrupted (CTRL+C)."
-		pass
-	client.stop()
-	pygame.quit()
+    # Create the client
+    import pygame
+    from client import BoomBoomClient
+    client = BoomBoomClient(arg["host"], arg["view_port"], arg["input_port"],\
+                            arg["verbose"], arg["debug"], arg["max_fps"])
+    try:
+        client.start()
+    except KeyboardInterrupt:
+        print "Program interrupted (CTRL+C)."
+        pass
+    client.stop()
+    pygame.quit()
 
 if __name__=="__main__": main()

Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-08 01:07:22 UTC (rev 126)
+++ boomboom/boomboom_server.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -3,101 +3,113 @@
 VERSION="0.2.0"
 PROGRAM="BoomBoom"
 
-from server import BoomBoomServer
 import getopt
 import sys
 
 def usage(defval):
-	print "%s server version %s" % (PROGRAM, VERSION)
-	print ""
-	print "Usage: %s [-v,--verbose] [-d,--debug] [-h,--help] [--version]" % (sys.argv[0])
-	print ""
-	print "Arguments :"
-	print "\t-h,--help         : Show this help"
-	print "\t--version         : Show the program version"
-	print "\t-v,--verbose      : Activate verbose mode"
-	print "\t-d,--debug        : Activate debug mode"
-	print ""
-	print "Other arguments :"
-	print "\t--max-input NB    : Max input clients (default %u)" % (defval["max-input"])
-	print "\t--max-display NB     : Max display clients (default %u)" % (defval["max-display"])
-	print "\t--display-port PORT  : Port number for display clients (default %u)" % (defval["display-port"])
-	print "\t--input-port PORT : Port number for input clients (default %u)" % (defval["input-port"])
+    print "%s server version %s" % (PROGRAM, VERSION)
+    print ""
+    print "Usage: %s [-v,--verbose] [-d,--debug] [-h,--help] [--version]" % (sys.argv[0])
+    print ""
+    print "Arguments :"
+    print "\t-h,--help         : Show this help"
+    print "\t--version         : Show the program version"
+    print "\t-v,--verbose      : Activate verbose mode"
+    print "\t-d,--debug        : Activate debug mode"
+    print ""
+    print "Other arguments :"
+    print "\t--max-input NB    : Max input clients (default %u)" % (defval["maxInput"])
+    print "\t--max-display NB     : Max display clients (default %u)" % (defval["maxDisplay"])
+    print "\t--display-port PORT  : Port number for display clients (default %u)" % (defval["displayPort"])
+    print "\t--input-port PORT : Port number for input clients (default %u)" % (defval["inputPort"])
 
 def parseArgs(val):
-	import getopt
-	def_val = val.copy()
-	
-	try:
-		short = "hdv"
-		long = ["debug", "verbose", "help", "version", \
-			"max-input=", "max-display=", \
-			"display-port=", "input-port="]
-		opts, args = getopt.getopt(sys.argv[1:], short, long)
-	except getopt.GetoptError:
-		usage(def_val)
-		sys.exit(2)
-	
-	if 0<len(args):
-		usage(def_val)
-		sys.exit(2)
-		
-	for o, a in opts:
-		if o in ("-h", "--help"):
-			usage(def_val)
-			sys.exit()
-		if o == "--version":
-			print "%s server version %s" % (PROGRAM, VERSION)
-			sys.exit()
-		if o == "--input-port":
-			a = int(a)
-			if a == val["displayPort"]:
-				print "Sorry, input port should be different than display port!"
-			else:
-				val["inputPort"] = a 			
-		if o == "--display-port":
-			a = int(a)
-			if a == val["inputPort"]:
-				print "Sorry, display port should be different than input port!"
-			else:
-				val["displayPort"] = a 
-		if o == "--max-input":
-			a = int(a)
-			if a < 1: 
-				a=1
-			elif 100 < a:
-				a = 100
-			val["maxInput"] = a
-		if o == "--max-display":
-			a = int(a)
-			if a < 1: 
-				a=1
-			elif 100 < a:
-				a = 100
-			val["maxDisplay"] = a
-		if o in ("-v", "--verbose"):
-			val["verbose"] = True
-		if o in ("-d", "--debug"):
-			val["debug"] = True
-	return val
+    import getopt
+    def_val = val.copy()
+    
+    try:
+        short = "hdv"
+        long = ["debug", "verbose", "help", "version", \
+            "max-input=", "max-display=", \
+            "display-port=", "input-port="]
+        opts, args = getopt.getopt(sys.argv[1:], short, long)
+    except getopt.GetoptError:
+        usage(def_val)
+        sys.exit(2)
+    
+    if 0<len(args):
+        usage(def_val)
+        sys.exit(2)
+        
+    for o, a in opts:
+        if o in ("-h", "--help"):
+            usage(def_val)
+            sys.exit()
+        if o == "--version":
+            print "%s server version %s" % (PROGRAM, VERSION)
+            sys.exit()
+        if o == "--input-port":
+            a = int(a)
+            if a == val["displayPort"]:
+                print "Sorry, input port should be different than display port!"
+            else:
+                val["inputPort"] = a             
+        if o == "--display-port":
+            a = int(a)
+            if a == val["inputPort"]:
+                print "Sorry, display port should be different than input port!"
+            else:
+                val["displayPort"] = a 
+        if o == "--max-input":
+            a = int(a)
+            if a < 1: 
+                a=1
+            elif 100 < a:
+                a = 100
+            val["maxInput"] = a
+        if o == "--max-display":
+            a = int(a)
+            if a < 1: 
+                a=1
+            elif 100 < a:
+                a = 100
+            val["maxDisplay"] = a
+        if o in ("-v", "--verbose"):
+            val["verbose"] = True
+        if o in ("-d", "--debug"):
+            val["debug"] = True
+    return val
 
+def run():
+    # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
+    import sys, os
+    file_dir = os.path.dirname(__file__)
+    happyboomdir = os.path.join(file_dir, "../happyboom/trunk")
+    sys.path.append(happyboomdir)
+    
+    val = { \
+        "displayPort": 12430, \
+        "inputPort": 12431, \
+        "maxInput": 4, \
+        "maxDisplay": 4, \
+        "verbose": False,
+        "debug": False}
+    arg = parseArgs(val)
+    
+    from server import BoomBoomServer
+    server = BoomBoomServer(**arg)
+
+    try:
+        server.start()
+    except KeyboardInterrupt:
+        pass
+    server.stop()
+    print "Server quit."
+
 def main():
-	val = { \
-		"displayPort": 12430, \
-		"inputPort": 12431, \
-		"maxInput": 4, \
-		"maxDisplay": 4, \
-		"verbose": False,
-		"debug": False}
-	arg = parseArgs(val)
-	
-	server = BoomBoomServer(**arg)
+    try:
+        run()
+    except KeyboardInterrupt:
+        print "Program interrupted (CTRL+C)."
 
-	try:
-		server.start()
-	except KeyboardInterrupt:
-		print "Program interrupted (CTRL+C)."
-	server.stop()
-	print "Server quit."
-
 if __name__=="__main__": main()

Modified: boomboom/client/bb_client.py
===================================================================
--- boomboom/client/bb_client.py	2005-09-08 01:07:22 UTC (rev 126)
+++ boomboom/client/bb_client.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -64,9 +64,7 @@
         while not quit:
             # Wait for Keyboard Interrupt
             time.sleep(0.100)
-            self.__stoplock.acquire()
-            quit = self.__stopped
-            self.__stoplock.release()
+            quit = self.is_stopped
         
     def stop(self):
         """  Stops the game client."""
@@ -95,7 +93,7 @@
             self.display.start()
         except:
             traceback.print_exc()
-            self.stop()
+        self.stop()
         
     def thread_input(self):
         """ Thread handler for the "input" part."""
@@ -103,4 +101,11 @@
             self.input.start()
         except:
             traceback.print_exc()
-            self.stop()
+        self.stop()
+
+    def __isStopped(self):
+        self.__stoplock.acquire()
+        stop = self.__stopped
+        self.__stoplock.release()
+        return stop
+    is_stopped = property(__isStopped)

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-08 01:07:22 UTC (rev 126)
+++ boomboom/client/bb_display.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -76,12 +76,14 @@
         # Try to connect to server
         if self.__verbose: print "[DISPLAY] Trying to connect to server %s:%u" % (self.host, self.port)
         self.__io.on_connect = self.onConnect
+        self.__io.on_connection_fails = self.onConnectionFails
         self.__io.on_disconnect = self.onDisconnect
         self.__io.on_new_packet = self.processPacket
         self.__io.on_lost_connection = self.onLostConnection
         self.__io.connect(self.host, self.port)
+        if not self.__io.is_ready: return
         thread.start_new_thread(self.__io.run_thread, ())
-        
+    
         BoomBoomConstructor()
         print "==== BoomBoom ===="
         self.drawer.start()
@@ -108,6 +110,10 @@
     def onConnect(self):
         """ Handler called on network connection. """
         if self.__verbose: print "[DISPLAY] Connected to server"
+        
+    def onConnectionFails(self):
+        """ Handler called when network connection fails. """
+        print "[DISPLAY] Fail to connect to the server"
 
     def onDisconnect(self):
         """ Handler called on network disconnection. """
@@ -171,4 +177,4 @@
         @param event: Event with "agent_manager_AskName" type
         @type event: C{L{common.simple_event.Event}}
         """
-        self.send(self.name)
\ No newline at end of file
+        self.send(self.name)

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-08 01:07:22 UTC (rev 126)
+++ boomboom/client/bb_input.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -68,10 +68,12 @@
         # Try to connect to server
         if self.__verbose: print "[INPUT] Trying to connect to server %s:%s" % (self.host, self.port)
         self.__io.on_connect = self.onConnect
+        self.__io.on_connection_fails = self.onConnectionFails
         self.__io.on_disconnect = self.onDisconnect
         self.__io.on_lost_connection = self.onLostConnection
         self.__io.on_new_packet = self.processPacket
         self.__io.connect(self.host, self.port)
+        if not self.__io.is_ready: return
         thread.start_new_thread( self.__io.run_thread, ())
         
         stopped = False
@@ -179,7 +181,11 @@
             
     def onConnect(self):
         """ Handler called on network connection. """
-        if self.__verbose: print "[INPUT] Connected to server"
+        if self.__verbose: print "[INPUT] Connected to the server"
+        
+    def onConnectionFails(self):
+        """ Handler called when network connection fails. """
+        print "[INPUT] Fail to connect to the server"
             
     def onDisconnect(self):
         """ Handler called on network disconnection. """
@@ -220,4 +226,4 @@
     
         #character = self.client.view.getActiveCharacter()
         #if character != None: self.process_event_active(character, event)
-        self.process_event_active(event)
\ No newline at end of file
+        self.process_event_active(event)

Deleted: boomboom/net
===================================================================
--- boomboom/net	2005-09-08 01:07:22 UTC (rev 126)
+++ boomboom/net	2005-09-08 02:55:34 UTC (rev 127)
@@ -1 +0,0 @@
-link ../net
\ No newline at end of file

Modified: happyboom/trunk/net/io/base_io.py
===================================================================
--- happyboom/trunk/net/io/base_io.py	2005-09-08 01:07:22 UTC (rev 126)
+++ happyboom/trunk/net/io/base_io.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -10,97 +10,108 @@
 from io_client import IO_Client
 
 class BaseIO(object):
-	""" Base IO virtual class.
-	@ivar verbose: Is verbose ?
-	@type verbose: C{bool}
-	@ivar debug: Display debug messages ?
-	@type debug: C{bool}
-	@ivar on_connect: Event called when the IO try to connect.
-	@type on_connect: C{function()}
-	@ivar on_disconnect: Event called when the server try to disconnect.
-	@type on_disconnect: C{function()}
-	@ivar on_client_connect: Event called when a new client try to connect to the server.
-	@type on_client_connect: C{function(L{IO_Client})}
-	@ivar on_client_disconnect: Event called when a client is disconnected.
-	@type on_client_disconnect: C{function(L{IO_Client})}
-	@ivar on_new_packet: Event called when a new packet is received.
-	@type on_new_packet: C{function(L{Packet})}
-	@ivar __name: The IO name.
-	@type __name: C{str}
-	"""
-	
-	def __init__(self, is_server=False):
-		""" Constructor.
-		@type is_server: C{bool}
-		"""
-		self.debug = False
-		self.verbose = False 
+    """
+    Base IO virtual class.
 
-		# Events
-		self.on_connect = None            # No argument
-		self.on_lost_connection = None    # No argument
-		self.on_disconnect = None         # No argument
-		self.on_client_connect = None     # (client)
-		self.on_client_disconnect = None  # (client)
-		self.on_new_packet = None         # (packet) : client address
-		self.on_send = None               # (data)
-		self.on_receive = None            # (data)
+    @ivar verbose: Is verbose ?
+    @type verbose: C{bool}
+    @ivar debug: Display debug messages ?
+    @type debug: C{bool}
+    @ivar on_connect: Event called when the IO try to connect.
+    @type on_connect: C{function()}
+    @ivar on_connection_fails: Event called when the IO fails to connect to server.
+    @type on_connection_fails: C{function()}
+    @ivar on_disconnect: Event called when the server try to disconnect.
+    @type on_disconnect: C{function()}
+    @ivar on_client_connect: Event called when a new client try to connect to the server.
+    @type on_client_connect: C{function(L{IO_Client})}
+    @ivar on_client_disconnect: Event called when a client is disconnected.
+    @type on_client_disconnect: C{function(L{IO_Client})}
+    @ivar on_new_packet: Event called when a new packet is received.
+    @type on_new_packet: C{function(L{Packet})}
+    @ivar __name: The IO name.
+    @type __name: C{str}
+    """
+    
+    def __init__(self, is_server=False):
+        """
+        Constructor.
+        @type is_server: C{bool}
+        """
+        self.debug = False
+        self.verbose = False 
+        self._is_ready = False
 
-		self.__name = None
+        # Events
+        self.on_connect = None            # No argument
+        self.on_connection_fails = None   # No argument
+        self.on_lost_connection = None    # No argument
+        self.on_disconnect = None         # No argument
+        self.on_client_connect = None     # (client)
+        self.on_client_disconnect = None  # (client)
+        self.on_new_packet = None         # (packet) : client address
+        self.on_send = None               # (data)
+        self.on_receive = None            # (data)
 
-	def connect(self, host, port):
-		""" Connect to host:port.
-		@parameter host: Network hostname.
-		@type host: C{str}
-		@parameter port: Network port number.
-		@type port: C{int}
-		"""
-		if self.__name==None:
-			self.__name = "%s:%u" % (host, port)
+        self.__name = None
 
-	def disconnect(self):
-		""" Close connection. """
-		pass
+    def connect(self, host, port):
+        """ Connect to host:port.
+        @parameter host: Network hostname.
+        @type host: C{str}
+        @parameter port: Network port number.
+        @type port: C{int}
+        """
+        if self.__name==None:
+            self.__name = "%s:%u" % (host, port)
 
-	def send(self, packet, to=None):
-		""" Send a packet to the server or to all clients. """
-		pass
-	
-	def receive(self, max_size = 1024):
-		""" Read a packet from the socket. Returns None if there is not new data.
-		@parameter max_size: Maximum packet size (in bytes).
-		@type max_size: C{int}
-		@rtype: C{L{Packet}}
-		"""
-		pass
+    def disconnect(self):
+        """ Close connection. """
+        pass
 
-	def live(self):				
-		""" Keep the connection alive. """
-		pass
+    def send(self, packet, to=None):
+        """ Send a packet to the server or to all clients. """
+        pass
+    
+    def receive(self, max_size = 1024):
+        """ Read a packet from the socket. Returns None if there is not new data.
+        @parameter max_size: Maximum packet size (in bytes).
+        @type max_size: C{int}
+        @rtype: C{L{Packet}}
+        """
+        pass
 
-	def disconnectClient(self, client):
-		""" Disconnect an IO client.
-		@type client: L{IO_Client}
-		"""
-		pass
-	
-	def run_thread(self):
-		""" Run the IO thread (will call L{live()} itself). """
-		pass
-	
-	def stop(self):
-		""" Stop the IO (close connections). """
-		pass
+    def live(self):                
+        """ Keep the connection alive. """
+        pass
 
-	#--- Private functions ------------------------------------------------------
+    def disconnectClient(self, client):
+        """ Disconnect an IO client.
+        @type client: L{IO_Client}
+        """
+        pass
+    
+    def run_thread(self):
+        """ Run the IO thread (will call L{live()} itself). """
+        pass
+    
+    def stop(self):
+        """ Stop the IO (close connections). """
+        pass
 
-	def getName(self):
-		if self.__name == None: return "no name"
-		return self.__name
-	
-	def setName(self, name):
-		self.__name = name	
+    #--- Private functions ------------------------------------------------------
 
-	#--- Properties -------------------------------------------------------------
+    def __getName(self):
+        if self.__name == None: return "no name"
+        return self.__name
+    
+    def __setName(self, name):
+        self.__name = name
 
-	name = property(getName, setName, doc="The IO name")
+    def __getReady(self):
+        return self._is_ready
+
+    #--- Properties -------------------------------------------------------------
+
+    name = property(__getName, __setName, doc="The IO name.")
+    is_ready = property(__getReady, doc="Tells if the IO is ready to use.");

Modified: happyboom/trunk/net/io/packet.py
===================================================================
--- happyboom/trunk/net/io/packet.py	2005-09-08 01:07:22 UTC (rev 126)
+++ happyboom/trunk/net/io/packet.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -9,152 +9,161 @@
 import struct
 
 class Packet(object):
-	""" Network packet.
-	@ivar id: Packet identifier.
-	@type id: C{int}
-	@ivar __data: Data string.
-	@type __data: C{str}
-	@ivar type: Packet type (see types).
-	@type type: C{int}
-	@ivar recv_from: Packet shipper.
-	@type recv_from: C{L{IO_Client}}
-	@ivar timeout: Timeout before packet is resend.
-	@type timeout: C{float}
-	@ivar total_timeout: Timeout before packet is said to be "lost".
-	@type total_timeout: C{float}
-	@ivar max_resend: Maximum number of packet resend.
-	@type max_resend: C{int}
-	@ivar use_tcp : Does IO used TCP connection ?
-	@type use_tcp: C{bool}
-	"""
+    """ Network packet.
+    @ivar id: Packet identifier.
+    @type id: C{int}
+    @ivar __data: Data string.
+    @type __data: C{str}
+    @ivar type: Packet type (see types).
+    @type type: C{int}
+    @ivar recv_from: Packet shipper.
+    @type recv_from: C{L{IO_Client}}
+    @ivar timeout: Timeout before packet is resend.
+    @type timeout: C{float}
+    @ivar total_timeout: Timeout before packet is said to be "lost".
+    @type total_timeout: C{float}
+    @ivar max_resend: Maximum number of packet resend.
+    @type max_resend: C{int}
+    @ivar use_tcp : Does IO used TCP connection ?
+    @type use_tcp: C{bool}
+    """
 
-	timeout = 0.250
-	total_timeout = 5.000 
-	max_resend = int(total_timeout / timeout)
-	use_tcp = False
+    timeout = 0.250
+    total_timeout = 5.000 
+    max_resend = int(total_timeout / timeout)
+    use_tcp = False
 
-	# Packet types
-	PACKET_DATA = 1
-	PACKET_PING = 2
-	PACKET_PONG = 3
-	PACKET_ACK = 4
+    # Packet types
+    PACKET_DATA = 1
+    PACKET_PING = 2
+    PACKET_PONG = 3
+    PACKET_ACK = 4
 
-	def __init__(self, str=None, skippable=False):
-		""" Constructor.
-		@parameter str: String data.
-		@type str: C{str}
-		@parameter skippable: Is the packet skippable if link quality is bad ? See skippable attribute.
-		@type skippable: C{bool}
-		"""
-		self.sent = 0
-		self.__data = None
-		self.timeout = None
-		self.skippable = skippable
-		self.id = None
-		self.type = Packet.PACKET_DATA
-		self.recv_from = None
-		self.__valid = True
-		if str != None: self.writeStr(str)
+    def __str__(self):
+        txt = "Packet <type=%u, " % (self.type)
+        if self.__data:
+            txt = txt+"data=\"%s\"" % (self.__data)
+        else:
+            txt = txt+"no data"            
+        if self.skippable: txt = txt+", skippable"
+        return txt+">"
 
-	def isValid(self):
-		""" After unpack, say if the packet is valid or not.
-		@rtype: C{bool}
-		"""
-		if not Packet.use_tcp and self.id==None: return False
-		return self.__valid 
-		
-	def toStr(self):
-		""" For debug only, convert to string """
-		if self.type == Packet.PACKET_ACK:
-			return "ACK %u [id=%u, skippable=%u]" % (self.id, self.id, self.skippable)
-		if self.type == Packet.PACKET_PING:
-			ping = struct.unpack("!I", self.__data)
-			return "PING %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
-		if self.type == Packet.PACKET_PONG:
-			ping = struct.unpack("!I", self.__data)
-			return "PONG %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
-		else:
-			return "\"%s\" [id=%u, skippable=%u]" \
-				% (self.__data, self.id, self.skippable)
+    def __init__(self, str=None, skippable=False):
+        """ Constructor.
+        @parameter str: String data.
+        @type str: C{str}
+        @parameter skippable: Is the packet skippable if link quality is bad ? See skippable attribute.
+        @type skippable: C{bool}
+        """
+        self.sent = 0
+        self.__data = None
+        self.timeout = None
+        self.skippable = skippable
+        self.id = None
+        self.type = Packet.PACKET_DATA
+        self.recv_from = None
+        self.__valid = True
+        if str != None: self.writeStr(str)
 
-	def unpack(self, binary_data):
-		""" Fill attributes from a binary data packet
-		@parameter binary_data: Binary datas which comes from network.
-		@type C{binary}
-		"""
-		if binary_data==None: return
-		self.__valid = False
+    def isValid(self):
+        """ After unpack, say if the packet is valid or not.
+        @rtype: C{bool}
+        """
+        if not Packet.use_tcp and self.id==None: return False
+        return self.__valid 
+        
+    def toStr(self):
+        """ For debug only, convert to string """
+        if self.type == Packet.PACKET_ACK:
+            return "ACK %u [id=%u, skippable=%u]" % (self.id, self.id, self.skippable)
+        if self.type == Packet.PACKET_PING:
+            ping = struct.unpack("!I", self.__data)
+            return "PING %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
+        if self.type == Packet.PACKET_PONG:
+            ping = struct.unpack("!I", self.__data)
+            return "PONG %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
+        else:
+            return "\"%s\" [id=%u, skippable=%u]" \
+                % (self.__data, self.id, self.skippable)
 
-		if Packet.use_tcp:
-			# Read data len
-			format = "!I"
-			size = struct.calcsize(format)
-			if len(binary_data) <  size:
-				print "Taille du paquet (%s) incorrect !" % (binary_data)
-				return None
-			data = struct.unpack(format, binary_data[:size])
-			data_len = data[0]
-			binary_data = binary_data[size:]
-		else:
-			# Read skippable, id, data len
-			format = "!BBII"
-			size = struct.calcsize(format)
-			if len(binary_data) <  size:
-				print "Taille du paquet (%s) incorrect !" % (binary_data)
-				return None
-			data = struct.unpack(format, binary_data[:size])
-			self.type = data[0]
-			self.skippable = (data[1]==1)
-			self.id = data[2]
-			data_len = data[3]
-			binary_data = binary_data[size:]
+    def unpack(self, binary_data):
+        """ Fill attributes from a binary data packet
+        @parameter binary_data: Binary datas which comes from network.
+        @type C{binary}
+        """
+        if binary_data==None: return
+        self.__valid = False
 
-		# Read data
-		if 0 < data_len:
-			format = "!%us" % (data_len)
-			size = struct.calcsize(format)
-			if len(binary_data) < size:
-				print "Taille du paquet (%s) incorrect !" % (binary_data)
-				return None
-			data = struct.unpack(format, binary_data[:size]) 
-			self.__data = data[0] 
-		else:
-			self.__data = None
-		self.__valid = True
-		return binary_data[size:]
+        if Packet.use_tcp:
+            # Read data len
+            format = "!I"
+            size = struct.calcsize(format)
+            if len(binary_data) <  size:
+                print "Taille du paquet (%s) incorrect !" % (binary_data)
+                return None
+            data = struct.unpack(format, binary_data[:size])
+            data_len = data[0]
+            binary_data = binary_data[size:]
+        else:
+            # Read skippable, id, data len
+            format = "!BBII"
+            size = struct.calcsize(format)
+            if len(binary_data) <  size:
+                print "Taille du paquet (%s) incorrect !" % (binary_data)
+                return None
+            data = struct.unpack(format, binary_data[:size])
+            self.type = data[0]
+            self.skippable = (data[1]==1)
+            self.id = data[2]
+            data_len = data[3]
+            binary_data = binary_data[size:]
 
-	def pack(self):
-		""" Pack datas to a binary string (using struct module)
-		@rtype: C{str}
-		"""
-		if self.__data != None:
-			data_len = len(self.__data)
-		else:
-			data_len = 0
-		if Packet.use_tcp:
-			data = struct.pack("!I", data_len)
-		else:
-			data = struct.pack("!BBII", 
-				self.type, self.skippable+0, self.id, data_len)
-		if data_len != 0:
-			data = data + struct.pack("!%us" % data_len, self.__data)
-		return data
-		
-	def writeStr(self, str):
-		""" Write a sting into packet (still used ???) """
-		if self.__data == None:
-			self.__data = str
-		else:
-			self.__data = self.__data + str
-		
-	def prepareSend(self):
-		""" Prepare the packet before it will be send : set timeout and send counter. """
-		self.timeout = time.time()+Packet.timeout
-		self.sent = self.sent + 1
+        # Read data
+        if 0 < data_len:
+            format = "!%us" % (data_len)
+            size = struct.calcsize(format)
+            if len(binary_data) < size:
+                print "Taille du paquet (%s) incorrect !" % (binary_data)
+                return None
+            data = struct.unpack(format, binary_data[:size]) 
+            self.__data = data[0] 
+        else:
+            self.__data = None
+        self.__valid = True
+        return binary_data[size:]
 
-	#-- Properties --------------------------------------------------------------
+    def pack(self):
+        """ Pack datas to a binary string (using struct module)
+        @rtype: C{str}
+        """
+        if self.__data != None:
+            data_len = len(self.__data)
+        else:
+            data_len = 0
+        if Packet.use_tcp:
+            data = struct.pack("!I", data_len)
+        else:
+            data = struct.pack("!BBII", 
+                self.type, self.skippable+0, self.id, data_len)
+        if data_len != 0:
+            data = data + struct.pack("!%us" % data_len, self.__data)
+        return data
+        
+    def writeStr(self, str):
+        """ Write a sting into packet (still used ???) """
+        if self.__data == None:
+            self.__data = str
+        else:
+            self.__data = self.__data + str
+        
+    def prepareSend(self):
+        """ Prepare the packet before it will be send : set timeout and send counter. """
+        self.timeout = time.time()+Packet.timeout
+        self.sent = self.sent + 1
 
-	def getData(self): return self.__data
-	data = property(getData, doc="Packet data.")	
+    #-- Properties --------------------------------------------------------------
 
+    def getData(self): return self.__data
+    data = property(getData, doc="Packet data.")    
 
+

Modified: happyboom/trunk/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp.py	2005-09-08 01:07:22 UTC (rev 126)
+++ happyboom/trunk/net/io_tcp/tcp.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -12,196 +12,208 @@
 from server_waiter import NetworkServerWaiter
 
 class IO_TCP(io.BaseIO):
-	""" IO for TCP transport
-	@ivar packet_timeout: Timeout of packets (in seconds)
-	@type packet_timeout: C{float}
-	@ivar thread_sleep: Sleep time used in the thread (in seconds).
-	@type thread_sleep: C{float}
-	@ivar __is_server: ??? 
-	@type __is_server: C{bool}
-	@ivar __waiter: Class which wait for clients.
-	@type __waiter: NetworkServerWaiter
-	@ivar __addr: The IO network address (host, port).
-	@type __addr: C{(string, string,)}
-	@ivar __clients: List of clients connected to this IO.
-	@type __clients: C{list<L{IO_client<io.IO_Client>}>?}
-	@ivar __clients_sema: Semaphore used to access L{__clients}.
-	@type __clients_sema: C{threading.Semaphore}
-	@ivar __running: Is the thread running ?
-	@type __running: C{bool}
-	"""
-	
-	def __init__(self, is_server=False):
-		io.BaseIO.__init__(self)
-		self.packet_timeout = 1.000
-		self.thread_sleep = 0.010
+    """
+    IO for TCP transport.
+    @ivar packet_timeout: Timeout of packets (in seconds)
+    @type packet_timeout: C{float}
+    @ivar thread_sleep: Sleep time used in the thread (in seconds).
+    @type thread_sleep: C{float}
+    @ivar __is_server: ??? 
+    @type __is_server: C{bool}
+    @ivar __waiter: Class which wait for clients.
+    @type __waiter: NetworkServerWaiter
+    @ivar __addr: The IO network address (host, port).
+    @type __addr: C{(string, string,)}
+    @ivar __clients: List of clients connected to this IO.
+    @type __clients: C{list<L{IO_client<io.IO_Client>}>?}
+    @ivar __clients_sema: Semaphore used to access L{__clients}.
+    @type __clients_sema: C{threading.Semaphore}
+    @ivar __running: Is the thread running ?
+    @type __running: C{bool}
+    """
+    
+    def __init__(self, is_server=False):
+        io.BaseIO.__init__(self)
+        self.packet_timeout = 1.000
+        self.thread_sleep = 0.010
 
-		self.__is_server = is_server
+        self.__is_server = is_server
 
-		self.__waiter = NetworkServerWaiter(self)
-		self.__addr = None
-		self.__clients = {}
-		self.__server = None
-		self.__clients_sema = threading.Semaphore()
-		self.__running = True
-		io.Packet.use_tcp = True
+        self.__waiter = NetworkServerWaiter(self)
+        self.__addr = None
+        self.__clients = {}
+        self.__server = None
+        self.__clients_sema = threading.Semaphore()
+        self.__running = False 
+        io.Packet.use_tcp = True
 
-	def connect(self, host, port):
-		""" Connect to host:port """
-		max_connection = 50
-	
-		self.__addr = (host, port,)
-		if self.__is_server:
-			if self.verbose:
-				print "Run server at %s:%u (tcp)" % (self.host, self.port)
-			thread.start_new_thread( self.__waiter.run_thread, (port,max_connection,))
-		else:
-			if self.verbose:
-				print "Connect to server %s:%u" % (self.host, self.port)			
-			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-			s.connect(self.__addr)
+    def connect(self, host, port):
+        """ Connect to host:port """
+        max_connection = 50
+    
+        self.__addr = (host, port,)
+        if self.__is_server:
+            if self.verbose:
+                print "Run server at %s:%u (tcp)" % (self.host, self.port)
+            thread.start_new_thread( self.__waiter.run_thread, (port,max_connection,))
+        else:
+            if self.verbose:
+                print "Connect to server %s:%u" % (self.host, self.port)            
+            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            try:
+                s.connect(self.__addr)
+            except socket.error, err:
+                if err[0]==111:
+                    if self.verbose:
+                        print "Fail to connect to server %s:%u" % (self.host, self.port)            
+                    if self.on_connection_fails:
+                        self.on_connection_fails()
+                    return
+                raise
 
-			client = TCP_Client(self, self.__addr, socket=s)
-			self.__server = client
-			self.__clients_sema.acquire()
-			self.__clients[client.addr] = client
-			self.__clients_sema.release()
+            client = TCP_Client(self, self.__addr, socket=s)
+            self.__server = client
+            self.__clients_sema.acquire()
+            self.__clients[client.addr] = client
+            self.__clients_sema.release()
 
-		if self.on_connect != None: self.on_connect()
-		io.BaseIO.connect(self, host, port)
+        if self.on_connect != None: self.on_connect()
+        io.BaseIO.connect(self, host, port)
+        self._is_ready = True
+        self.__running = True
 
-	def disconnect(self):
-		""" Close connection """
-		self.__clients_sema.acquire()
-		clients = self.__clients.copy()
-		self.__clients_sema.release()
-		for client_addr, client in clients.items():
-			client.disconnect()
-		if self.on_disconnect != None: self.on_disconnect()
-		self.stop()
+    def disconnect(self):
+        """ Close connection """
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        for client_addr, client in clients.items():
+            client.disconnect()
+        if self.on_disconnect != None: self.on_disconnect()
+        self.stop()
 
-	def disconnectClient(self, client):
-		""" Disconnect a client. """
-		self.__clients_sema.acquire()
-		if  self.__clients.has_key(client.addr): del self.__clients[client.addr]
-		self.__clients_sema.release()
-		if self.verbose:
-			print "Disconnect client %s:%u" % (client.host, client.port)
-		if self.on_client_disconnect != None: self.on_client_disconnect (client)
-		if self.__server == client: self.disconnect()
-	
-	def send(self, packet, to=None):
-		""" Send a packet to the server or to all clients
-		@type packet: Packet
-		"""
-		if not self.__running: return
-		
-		# Read binary version of the packet
-		data = packet.pack()
+    def disconnectClient(self, client):
+        """ Disconnect a client. """
+        self.__clients_sema.acquire()
+        if  self.__clients.has_key(client.addr): del self.__clients[client.addr]
+        self.__clients_sema.release()
+        if self.verbose:
+            print "Disconnect client %s:%u" % (client.host, client.port)
+        if self.on_client_disconnect != None: self.on_client_disconnect (client)
+        if self.__server == client: self.disconnect()
+    
+    def send(self, packet, to=None):
+        """ Send a packet to the server or to all clients
+        @type packet: Packet
+        """
+        if not self.__running: return
+        
+        # Read binary version of the packet
+        data = packet.pack()
 
-		if self.__is_server:
-			if to==None:
-				self.__clients_sema.acquire()
-				clients = self.__clients.copy()
-				self.__clients_sema.release()	
-				for client in clients:
-					client.sendBinary(data)
-			else:
-				to.sendBinary(data)
-		else:
-			self.__server.sendBinary(data)
+        if self.__is_server:
+            if to==None:
+                self.__clients_sema.acquire()
+                clients = self.__clients.copy()
+                self.__clients_sema.release()    
+                for client in clients:
+                    client.sendBinary(data)
+            else:
+                to.sendBinary(data)
+        else:
+            self.__server.sendBinary(data)
 
-	def live(self):				
-		""" Keep the connection alive :
-		- Get clients new packets
-		- Process packets (eg. ping/pong)
-		"""
-		clients = self.clients
-		for client_addr, client in clients.items():
-			data = client.receiveNonBlocking()
-			if data != None:
-				self.__processData(client, data)
+    def live(self):                
+        """ Keep the connection alive :
+        - Get clients new packets
+        - Process packets (eg. ping/pong)
+        """
+        clients = self.clients
+        for client_addr, client in clients.items():
+            data = client.receiveNonBlocking()
+            if data != None:
+                self.__processData(client, data)
 
-	def __processData(self, client, data):
-		while data != "":
-			packet = io.Packet()
-			packet.recv_from = client
-			data = packet.unpack(data)
-			if not packet.isValid():
-				print "Bad data packet (%s) from %s !" % (data, client.name)
-				return
-			if self.debug: print "Received %s:%u => \"%s\"" % (client.host, client.port, packet.data)
-			if self.on_new_packet: self.on_new_packet(packet)
-	
-	def run_thread(self):
-		""" Function which should be called in a thread. """
-		try:
-			while self.__running:
-				self.live()				
-				time.sleep(self.thread_sleep)
-		except Exception, msg:
-			print "EXCEPTION DANS LE THREAD IO :"
-			print msg
-			traceback.print_exc()
-			self.stop()
+    def __processData(self, client, data):
+        while data != "":
+            packet = io.Packet()
+            packet.recv_from = client
+            data = packet.unpack(data)
+            if not packet.isValid():
+                print "Bad data packet (%s) from %s !" % (data, client.name)
+                return
+            if self.debug: print "Received %s:%u => \"%s\"" % (client.host, client.port, packet.data)
+            if self.on_new_packet: self.on_new_packet(packet)
+    
+    def run_thread(self):
+        """ Function which should be called in a thread. """
+        try:
+            while self.__running:
+                self.live()                
+                time.sleep(self.thread_sleep)
+        except Exception, msg:
+            print "EXCEPTION DANS LE THREAD IO :"
+            print msg
+            traceback.print_exc()
+        self.stop()
 
-	def stop(self):
-		if not self.__running: return
-		self.__running = False
-		self.disconnect()
+    def stop(self):
+        if not self.__running: return
+        self.__running = False
+        self.disconnect()
 
-	def isRunning(self): return self.__running
+    def isRunning(self): return self.__running
 
-	#--- Private functions ------------------------------------------------------
+    #--- Private functions ------------------------------------------------------
 
-	def __getPort(self):
-		return self.__addr[1]
+    def __getPort(self):
+        return self.__addr[1]
 
-	def __getHost(self):
-		if self.__addr[0]=='': return "localhost"
-		return self.__addr[0]
+    def __getHost(self):
+        if self.__addr[0]=='': return "localhost"
+        return self.__addr[0]
 
-	def __getAddr(self): return self.__addr
+    def __getAddr(self): return self.__addr
 
-	def __getName(self):
-		if self.__name != None: return self.__name
-		return self.host
-		
-	def __setName(self, name):
-		self.__name = name	
+    def __getName(self):
+        if self.__name != None: return self.__name
+        return self.host
+        
+    def __setName(self, name):
+        self.__name = name    
 
-	def __getClients(self):
-		self.__clients_sema.acquire()
-		clients = self.__clients.copy()
-		self.__clients_sema.release()
-		return clients
+    def __getClients(self):
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        return clients
 
-	def __getMaxClients(self):
-		return 0
-	
-	def clientConnect(self, client):
-		client.on_receive = self.on_receive
-		client.on_send = self.on_send
-		self.__clients_sema.acquire()
-		self.__clients[client.addr] = client
-		self.__clients_sema.release()
-		if self.on_client_connect != None: self.on_client_connect (client)
-		
-	def clientDisconnect(self, client):
-		if self.debug:
-			print "Client %s leave server %s." \
-				% (client.name, self.name)
-		self.__clients_sema.acquire()
-		self.__clients.remove(client)
-		self.__clients_sema.release()
-		self.__waiter.client_disconnect(client)
-		if self.on_client_disconnect != None: self.on_client_disconnect (client)
-		
-	#--- Properties -------------------------------------------------------------
+    def __getMaxClients(self):
+        return 0
+    
+    def clientConnect(self, client):
+        client.on_receive = self.on_receive
+        client.on_send = self.on_send
+        self.__clients_sema.acquire()
+        self.__clients[client.addr] = client
+        self.__clients_sema.release()
+        if self.on_client_connect != None: self.on_client_connect (client)
+        
+    def clientDisconnect(self, client):
+        if self.debug:
+            print "Client %s leave server %s." \
+                % (client.name, self.name)
+        self.__clients_sema.acquire()
+        self.__clients.remove(client)
+        self.__clients_sema.release()
+        self.__waiter.client_disconnect(client)
+        if self.on_client_disconnect != None: self.on_client_disconnect (client)
+        
+    #--- Properties -------------------------------------------------------------
 
-	name = property(__getName, __setName)
-	addr = property(__getAddr)
-	port = property(__getPort)
-	host = property(__getHost)
-	clients = property(__getClients)
-	max_clients = property(__getMaxClients)
+    name = property(__getName, __setName)
+    addr = property(__getAddr)
+    port = property(__getPort)
+    host = property(__getHost)
+    clients = property(__getClients)
+    max_clients = property(__getMaxClients)

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-08 01:07:22 UTC (rev 126)
+++ happyboom/trunk/server/base_server.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -1,121 +1,121 @@
-from server_agent import *
-from stat import *
-from common import mailing_list
-import string
-import time
-import thread
-import threading
-import random
-from net import net_buffer
-from net import io
-#from net import io_udp
-from net import io_tcp
-import traceback
+from bb_agent import BoomBoomAgent, BoomBoomMessage
+from agents import Character, Projectile, Weapon, World, Game
+from net import io, io_udp, io_tcp, net_buffer
+from pysma import Kernel, DummyScheduler
+import re, random, thread, traceback, time
 
-class BaseServer(object):
-	instance = None
-	
-	def __init__(self):
-		BaseServer.instance = self
-		self.agents = []
-#		self.__view_io = io_udp.IO_UDP(is_server=True)
-#		self.__input_io = io_udp.IO_UDP(is_server=True)
-		self.__view_io = io_tcp.IO_TCP(is_server=True)
-		self.__input_io = io_tcp.IO_TCP(is_server=True)
+class Gateway(BoomBoomAgent):
+    def __init__(self):
+		BoomBoomAgent.__init__(self, "gateway")
+		self.nextChar = None
+
+class BaseServer:
+	def __init__(self, maxDisplay=2, displayPort=12430, maxInput=2, inputPort=12431, verbose=False, debug=False):
+		self.__protocol_version = "0.1.4"
+		self.__debug = debug
+		self.__verbose = verbose
 		self.__inputs = []
-		self.mailing_list = mailing_list.MailingList()
-		self.net_mailing_list = {}
-		self.cmd_handler = {}
-		self.quit = False
-		self.stat = None
-		self.debug = False
-		self.verbose = False
+		self.__items = []
+		self.__stopped = False
+		self.__stoplock = thread.allocate_lock()
+		self.__supportedFeatures = {}
+
+        # Create IO
+		self.__io = io_tcp.IO_TCP(is_server=True)
+		self.__io.debug = debug
+		self.__io.verbose = verbose
+		self.__io_buffer = net_buffer.NetBuffer()
+
+		self.maxDisplay = maxDisplay
+		self.displayPort = displayPort
+		self.maxInput = maxInput
+		self.inputPort = inputPort
 		self.started = False
-		self.__input_protocol_version = "0.1.4"
-		self.__view_protocol_version = "0.1.4"
-		self.__input_buffer = net_buffer.NetBuffer()
-		self.__view_buffer = net_buffer.NetBuffer()
 		random.seed()
+		Kernel().addAgent(DummyScheduler(sleep=0.01))
+		
+	def born(self):
+		BoomBoomAgent.born(self)
+		self.requestActions("game")
+		self.requestActions("weapon")
+		self.requestActions("character")
+		self.requestActions("world")
+		self.requestActions("projectile")
+		
+	def start(self):
+		if self.__verbose: print "[*] Starting server..."
+		self.initIO()
+		self.createAgents()
+		print "[*] Server started"
+		
+		self.__stoplock.acquire()
+		running = not self.__stopped
+		self.__stoplock.release()
+		while running:
+			self.processInputs()
+			time.sleep(0.01)
+			self.__stoplock.acquire()
+			running = not self.__stopped
+			self.__stoplock.release()
 
-	# Convert a (role,type,arg) to string (to be sent throw network)
-	def createMsg(self, role, type, arg=None):
-		if arg != None:
-			return "%s:%s:%s" % (role, type, arg)
-		else:
-			return "%s:%s" % (role, type)
+	def stop(self):
+		self.__stoplock.acquire()
+		if self.__stopped:
+			self.__stoplock.release()
+			return
+		self.__stopped = True
+		self.__stoplock.release()
+		print "[*] Stopping server..."
+		Kernel.instance.stopKernel()
+		self.sendNetworkMessage("game", "Stop", skippable=True)
+		self.__display_io.stop()
+		self.__input_io.stop()
+		if self.__verbose: print "[*] Server stopped"
 
-	# A newtork client would like to receive all messages of given role
-	def registerNetMessage(self, client, role):
-		self.mailing_list.registerNet(role, client)
-
-	# A local client would like to receive all messages of given role
-	def registerMessage(self, agent, role):
-		self.mailing_list.register(role, agent)
-
-	# Create all agents
-	def createAgents(self):
-		pass
-	
-	def initIO(self, max_view, view_port, max_input, input_port):
-		self.__view_io.name = "view server"
-		self.__view_io.on_client_connect = self.openView
-		self.__view_io.on_client_disconnect = self.closeView
-#		self.__view_io.on_binding_error = self.bindingError
-		self.__view_io.on_new_packet = self.recvViewPacket
-		self.__view_io.connect('', view_port) #, max_view)
-
+	def initIO(self):
+		if self.__verbose: print "[*] Starting display server"
+		self.__display_io.name = "display server"
+		self.__display_io.on_client_connect = self.openDisplay
+		self.__display_io.on_client_disconnect = self.closeDisplay
+		self.__display_io.on_new_packet = self.recvDisplayPacket
+		self.__display_io.connect('', self.displayPort)
+		if self.__verbose: print "[*] Starting input server"
 		self.__input_io.name = "input server"
 		self.__input_io.on_client_connect = self.openInput
 		self.__input_io.on_client_disconnect = self.closeInput
-#		self.__input_io.on_binding_error = self.bindingError
 		self.__input_io.on_new_packet = self.recvInputPacket
-		self.__input_io.connect('', input_port) #, max_input)
-	
-		thread.start_new_thread( self.run_io_thread, ())
+		self.__input_io.connect('', self.inputPort)
+		thread.start_new_thread(self.run_io_thread, ())
 		
-	def recvInputPacket(self, packet):
-		self.__input_buffer.append(packet.recv_from.addr, packet)
+	def createAgents(self):
+		if self.__verbose: print "[*] Creating agents"
+		Kernel.instance.addAgent(self)
+		self.addAgent(Game(debug=self.__debug))
+		self.addAgent(World(debug=self.__debug))
+		self.addAgent(Character(100, 1, debug=self.__debug))
+		self.addAgent(Character(-150, 2, debug=self.__debug))
+		self.addAgent(Weapon(debug=self.__debug))
+		self.addAgent(Projectile(debug=self.__debug))
+		self.sendBroadcastMessage(BoomBoomMessage("start", ()), "game")
 		
-	def recvViewPacket(self, packet):
-		msg = packet.data
-		self.__view_buffer.append(packet.recv_from.addr, packet)
-	
-	# Function which should be called in a thread
-	def run_io_thread(self):
-		try:
-			while self.__input_io.isRunning() and self.__view_io.isRunning():
-				self.__input_io.live()				
-				self.__view_io.live()				
-				time.sleep(0.001)
-		except Exception, msg:
-			print "EXCEPTION IN IO THREAD :"
-			print msg
-			print "--"			
-			traceback.print_exc()
-			self.stop()
-			
-	def bindingError(self, server):
-		print "Binding error for %s (port %u) !" % (server.name, server.port)
-		self.quit = True
+	def openDisplay(self, client):
+		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openDisplay,"DISPLAY",))
 
-	def readViewAnswer(self, client):
-		return self.__readClientAnswer(self.__view_buffer, client)
-		
-	def readInputAnswer(self, client):
-		return self.__readClientAnswer(self.__input_buffer, client)
-		
-	def __readClientAnswer(self, buffer, client, timeout=3.000):
-		answer = buffer.readBlocking(client.addr, timeout)
-		if answer==None: return None
-		answer = answer.data
-		return answer
-		
-	def openView(self, client):
-		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openView,"VIEW",))
-
 	def openInput(self, client):
 		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openInput,"INPUT",))
+		
+	def closeInput(self, client):
+		if self.__verbose: print "[*] Input %s disconnected." % (client.name)
+		if not (client in self.__inputs): return
+		self.__inputs.remove (client)
+		txt = "Client %s (input) leave us." % (client.name)
+		self.sendText(txt)
 
+	def closeDisplay(self, client):
+		if self.__verbose: print "[*] Display %s disconnected." % (client.name)
+		txt = "Client %s (display) leave us." % (client.name)
+		self.sendText(txt)
+		
 	def __clientChallenge(self, client, func, client_type):
 		try:
 			func(client)
@@ -125,164 +125,140 @@
 			print "--"
 			traceback.print_exc()
 			self.stop()
-	
-	def __do_openView(self, client):
-		print "View %s try to connect ..." % (client.name)
+
+	# Function which should be called in a thread
+	def run_io_thread(self):
+		try:
+			while self.__input_io.isRunning() and self.__display_io.isRunning():
+				self.__input_io.live()				
+				self.__display_io.live()				
+				time.sleep(0.001)
+		except Exception, msg:
+			print "EXCEPTION IN IO THREAD :"
+			print msg
+			print "--"			
+			traceback.print_exc()
+			self.stop()
+
+	def __do_openDisplay(self, client):
+		if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
 		
-		self.__view_buffer.clear(client.addr)
+		self.__display_buffer.clear(client.addr)
 		
 		# Ask protocol version
 		msg = self.createMsg("agent_manager", "AskVersion")
-		client.send ( io.Packet(msg) )
-		answer = self.readViewAnswer(client)
-		if answer != self.__view_protocol_version:
+		client.send(io.Packet(msg))
+		answer = self.readDisplayAnswer(client)
+		if answer != self.__display_protocol_version:
 			txt = "Sorry, you don't have same protocol version (%s VS %s)" \
-				% (answer, self.__view_protocol_version)
+				% (answer, self.__display_protocol_version)
 			self.sendText(txt)
 			client.disconnect()
 			return
 		
 		# ask client name
 		msg = self.createMsg("agent_manager", "AskName")
-		client.send ( io.Packet(msg) )
-		name = self.readViewAnswer(client)
+		client.send(io.Packet(msg))
+		name = self.readDisplayAnswer(client)
 		if name not in ("-", ""): client.name = name
 
-		self.registerNetMessage (client, "agent_manager")
-		self.registerNetMessage (client, "game")
-		for agent in self.agents:
-			msg = self.createMsg("agent_manager", "Create", "%s:%u" % (agent.type, agent.id))
-			client.send ( io.Packet(msg) )
-			answer = self.readViewAnswer(client)
+		self.registerFeature(client, "agent_manager")
+		self.registerFeature(client, "game")
+		for type, id in self.__items:
+			msg = self.createMsg("agent_manager", "Create", "%s:%u" % (type, id))
+			client.send (io.Packet(msg))
+			answer = self.readDisplayAnswer(client)
 			if answer == "yes": 
-				role = self.readViewAnswer(client)
+				role = self.readDisplayAnswer(client)
 				while role != ".":
-					self.registerNetMessage(client, role)
-					role = self.readViewAnswer(client)
-				agent.sync(client)
+					self.registerFeature(client, role)
+					role = self.readDisplayAnswer(client)
 
 		msg = self.createMsg("game", "Start")
-		client.send ( io.Packet(msg) )
+		client.send(io.Packet(msg))
 			
-		txt = "Welcome to new (view) client : %s" % (client.name)
+		txt = "Welcome to new (display) client : %s" % (client.name)
 		self.sendText(txt)
-		print "View %s connected." % (client.name)
+		if self.__verbose: print "[*] Display %s connected" % (client.name)
+		self.sendBBMessage("sync")
 
 	def __do_openInput(self, client):
-		print "Input %s try to connect ..." % (client.name)
+		if self.__verbose: print "[*] Input %s try to connect ..." % (client.name)
 
 		self.__input_buffer.clear(client.addr)
 
-		client.send ( io.Packet("Version?") )
+		client.send(io.Packet("Version?"))
 		answer = self.readInputAnswer(client)
 		if answer == None:
-			if self.verbose: print "Client doesn't sent version"
+			if self.__verbose: print "[*] Client doesn't sent version"
 			client.disconnect()
 			return
 		if answer != self.__input_protocol_version:
 			txt = "Sorry, you don't have same protocol version (%s VS %s)" \
 				% (answer, self.__input_protocol_version)
-			self.sendText (txt, client)
+			self.sendText(txt, client)
 			client.disconnect()
 			return	
-		client.send (io.Packet("OK"))
+		client.send(io.Packet("OK"))
 		
 		# ask client name
-		client.send (io.Packet("Name?"))
+		client.send(io.Packet("Name?"))
 		name = self.readInputAnswer(client)
 		if name == None:
-			if self.verbose: print "Client doesn't sent name"
+			if self.__verbose: print "[*] Client doesn't sent name"
 			client.disconnect()
 			return
 		if name not in ("-", ""): client.name = name
-		client.send (io.Packet("OK"))
+		client.send(io.Packet("OK"))
 
 		self.__inputs.append (client)
-		print "Input %s connected." % (client.name)
+		if self.__verbose: print "Input %s connected." % (client.name)
 		txt = "Welcome to new (input) client : %s" % (client.name)
 		self.sendText(txt)
-
-	def closeInput(self, client):
-		print "Input %s disconnected." % (client.name)
-		if not (client in self.__inputs): return
-		self.__inputs.remove (client)
-		txt = "Client %s (input) leave us." % (client.name)
-		self.sendText(txt)
-
-	def closeView(self, client):
-		print "View %s disconnected." % (client.name)
-		txt = "Client %s (view) leave us." % (client.name)
-		self.sendText(txt)
-
-	def start(self, arg):
-		self.stat = ServerStat(self)
-		self.initIO(arg["max-view"], arg["view-port"], arg["max-input"], arg["input-port"])
-		self.__view_io.on_send = self.stat.onNetSend
-		self.__input_io.on_send = self.stat.onNetSend
-		self.__view_io.on_receive = self.stat.onNetReceive
-		self.__input_io.on_receive = self.stat.onNetReceive
-
-		self.createAgents()
-
-	def setDebug(self, debug):
-		self.debug = debug
-		self.__view_io.debug = debug
-		self.__input_io.debug = debug
-
-	def setVerbose(self, verbose):
-		self.verbose = verbose
-		self.__view_io.verbose = verbose
-		self.__input_io.verbose = verbose
-
-	def connectAgent(self, cmd, agent):
-		if self.cmd_handler.has_key(cmd):
-			self.cmd_handler[cmd].append (agent)
+		
+	# Convert a (role,type,arg) to string (to be sent throw network)
+	def createMsg(self, role, type, arg=None):
+		if arg != None:
+			return "%s:%s:%s" % (role, type, arg)
 		else:
-			self.cmd_handler[cmd] = [agent]
+			return "%s:%s" % (role, type)
 		
-	def registerAgent(self, agent):
-		agent.id = 1+len(self.agents)
-		agent.server = self
-		self.agents.append(agent)
-		agent.start()
+	def recvInputPacket(self, packet):
+		self.__input_buffer.append(packet.recv_from.addr, packet)
+		
+	def recvDisplayPacket(self, packet):
+		msg = packet.data
+		self.__display_buffer.append(packet.recv_from.addr, packet)
 
-	def sendMsgToClient(self, client, role, type, arg=None, skippable=False):
-		msg = self.createMsg(role, type, arg)
-		p = io.Packet(msg)
-		p.skippable = skippable
-		client.send(p)
+	def readDisplayAnswer(self, client):
+		return self.__readClientAnswer(self.__display_buffer, client)
 		
+	def readInputAnswer(self, client):
+		return self.__readClientAnswer(self.__input_buffer, client)
+
+	def __readClientAnswer(self, buffer, client, timeout=3.000):
+		answer = buffer.readBlocking(client.addr, timeout)
+		if answer==None: return None
+		answer = answer.data
+		return answer
+
 	def sendText(self, txt, client=None):
 		if client != None:
 			msg = self.createMsg("agent_manager", "Text", txt)
-			client.send( io.Packet(msg) )
+			client.send(io.Packet(msg))
 		else:
-			self.sendMsg("agent_manager", "Text", txt)
+			self.sendNetworkMessage("agent_manager", "Text", txt)
 
-	def sendMsg(self, role, type, arg=None, skippable=False):
-		msg = AgentMessage(role, type, arg)
-		locals = self.mailing_list.getLocal(role)
-		for agent in locals:
-			agent.putMessage(msg)
-		
-		msg = self.createMsg(role, type, arg)
-		clients = self.mailing_list.getNet(role)
-		for client in clients:
-			client.send ( io.Packet(msg, skippable = skippable) )
-		
-	def processCmd(self, cmd):
-		if self.debug: print "Received %s." % (cmd)
-		if self.cmd_handler.has_key(cmd):
-			for agent in self.cmd_handler[cmd]:
-				print "Send %s to agent %u." % (cmd, agent.id)
-				msg = AgentMessage(agent.id, "Command", cmd)
-				agent.putMessage(msg)
-
-	def processInputPacket(self, new_packet):
-		self.processInputCmd( new_packet.recv_from, new_packet.data )
-	
 	def processInputCmd(self, input, cmd):
-		pass
+		cmd_ok = (\
+			"move_left", "move_right", "move_up", "move_down",
+			"shoot", )
+		if self.__verbose and cmd != "Ping?":
+			print "Command from %s: %s" % (input.name, cmd)
+		if re.compile("^chat:(.*)$").match(cmd) != None:
+			print "New chat message: %s" % (r.group(1))
+			self.sendNetworkMessage("chat_server", "new", r.group(1))
+		elif cmd in cmd_ok:	self.sendBroadcastMessage(BoomBoomMessage("new_command", (cmd,)), "command_manager")
 		
 	def processInputs(self):
 		inputs = self.__inputs[:]
@@ -290,27 +266,62 @@
 			packets = self.__input_buffer.readNonBlocking(client.addr)
 
 			for packet in packets:	
-				#if len(cmd)==0: continue
-				#if max_len<len(cmd): cmd=cmd[:max_len]
 				self.processInputCmd (packet.recv_from, packet.data)
 
-	def live(self):
-		if not self.started:
-			self.started = True
-			print "Server started (waiting for clients ;-))"
-			
-		self.processInputs()
-		for agent in self.agents:
-			agent.live()
-			if self.quit==True: break
+	def registerFeature(self, client, role):
+		if role in self.__supportedFeatures:
+			if client not in self.__supportedFeatures[role]:
+				self.__supportedFeatures[role].append(client)
+		else:
+			self.__supportedFeatures[role] = [client,]
 
-	def stop(self):
-		self.__view_io.stop()
-		self.__input_io.stop()
-		self.agents = {}				
-		self.quit = True
-
-	def getNbInput(self): return len(self.__input_io.clients)
-	def getNbView(self): return len(self.__view_io.clients)
-	def getMaxNbInput(self): return self.__input_io.max_clients
-	def getMaxNbView(self): return self.__view_io.max_clients
+	def sendNetworkMessage(self, role, type, arg=None, skippable=False):
+		msg = self.createMsg(role, type, arg)
+		clients = self.__supportedFeatures.get(role, ())
+		for client in clients:
+			client.send (io.Packet(msg, skippable=skippable))
+						
+	def msg_game_next_character(self, char, team):
+		if self.__debug: print "Next character : %s,%s" %(char, team)
+		self.nextChar = char
+						
+	def msg_game_next_turn(self):
+		if self.__debug: print "Next turn : %s" %self.nextChar
+		self.sendNetworkMessage("game", "next_turn")
+		self.sendNetworkMessage("game", "active_character", self.nextChar)
+		
+	def msg_game_collision(self, x, y):
+		if self.__debug: print "Hit ground : %s,%s" %(x, y)
+		self.sendNetworkMessage("projectile", "hit_ground")
+	
+	def msg_projectile_move(self, x, y):
+		if self.__debug: print "Projectile move : %s,%s" %(x, y)
+		self.sendNetworkMessage("projectile", "move", "%i,%i" %(x,y), True)
+		
+	def msg_projectile_activate(self, flag):
+		if self.__debug: print "Projectile activate : %s" %flag
+		self.sendNetworkMessage("projectile", "activate", "%u" %(flag))
+		
+	def msg_weapon_angle(self, a):
+		if self.__debug: print "Weapon angle : %s" %a
+		self.sendNetworkMessage("weapon", "angle", a)
+		
+	def msg_weapon_strength(self, s):
+		if self.__debug: print "Weapon strength : %s" %s
+		self.sendNetworkMessage("weapon", "force", s)
+		
+	def msg_world_create(self, m):
+		if self.__debug: print "World create : %s" %m
+		self.sendNetworkMessage("world", "create", m)
+		
+	def msg_character_move(self, m):
+		if self.__debug: print "Character move : %s" %m
+		self.sendNetworkMessage("character", "move", m)
+		
+	def msg_new_item(self, type, id):
+		if self.__debug: print "New item : %s,%s" %(type, id)
+		self.__items.append((type, id))
+		
+	def msg_game_current_character(self, char, team):
+		if self.__debug: print "Current character : %s,%s" %(char, team)
+		self.sendNetworkMessage("game", "active_character", char)

Modified: happywarry/happywarry-server.py
===================================================================
--- happywarry/happywarry-server.py	2005-09-08 01:07:22 UTC (rev 126)
+++ happywarry/happywarry-server.py	2005-09-08 02:55:34 UTC (rev 127)
@@ -8,11 +8,13 @@
 import gettext
 
 def init():
-    # Add APIBoom to PYTHONPATH ("../" today, but should be improved)
+    global log
+
+    # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
     import sys, os
     file_dir = os.path.dirname(__file__)
-    apiboomdir = os.path.join(file_dir, "..")
-    sys.path.append(apiboomdir)
+    happyboomdir = os.path.join(file_dir, "../happyboom/trunk")
+    sys.path.append(happyboomdir)
 
     # Get user directory 
     from common.log import log
@@ -39,6 +41,8 @@
     gettext.install('happywarry', localedir, unicode=1)
 
 def main():
+    global log
+
     # Initialize the application
     init()
     



From haypo at berlios.de  Fri Sep  9 01:26:11 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 9 Sep 2005 01:26:11 +0200
Subject: [Happyboom-svn] r128 - poilu/trunk
Message-ID: <200509082326.j88NQBEe027084@sheep.berlios.de>

Author: haypo
Date: 2005-09-09 01:26:07 +0200 (Fri, 09 Sep 2005)
New Revision: 128

Modified:
   poilu/trunk/motcle.py
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
   poilu/trunk/wormux.sh
Log:
Corrige quelques bugs.


Modified: poilu/trunk/motcle.py
===================================================================
--- poilu/trunk/motcle.py	2005-09-08 02:55:34 UTC (rev 127)
+++ poilu/trunk/motcle.py	2005-09-08 23:26:07 UTC (rev 128)
@@ -9,14 +9,10 @@
 
 class motcle_poilu:
     def __init__(self):
-		print "init motcle."
 		self.insulte = dict()
 		self.regex = []
-		print "regex = ", self.regex
 		self.charge_regex()
-		print "regex = ", self.regex
 		self.charge()
-		print "regex = ", self.regex
 
     def echo(self, message):
         print message
@@ -51,6 +47,7 @@
 		
     def charge(self):
         f = file("insulte.txt","r")
+        self.insulte = {}
         for ligne in f:
 			ligne = unicode(ligne.strip(), "utf8")
 			regs = re.compile("^(.+):(.+)$").search(ligne)
@@ -58,30 +55,23 @@
         f.close()
 
     def charge_regex(self):
-        print "Charge les regex"
         self.regex = []
         f = file("motcle_regex.txt","r")
         for ligne in f:
             ligne = unicode(ligne.strip(), "utf8")
             regs = re.compile("^(.+):(.+)$").search(ligne)
             if regs != None: 
-                print "Ajoute ", ligne
                 regex = re.compile(regs.group(2))
                 self.regex.append( (regs.group(1), regex,) )
         f.close()
 
     def calcule_cle(self, str):
-        print "regex = ", self.regex
-        print "la"
         for item in self.regex:
-            r = regex.search(item[1])
+            r = item[1].search(str)
             if r != None: return item[0] 
         return None
 
     def reponse(self, str):
-        print "regex = ", self.regex
-        print "Self = ", self
-        print "str = ", str
         cle = self.calcule_cle(str)
         if cle==None: return None
         if not self.insulte.has_key(cle): return None

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-08 02:55:34 UTC (rev 127)
+++ poilu/trunk/pypoil.py	2005-09-08 23:26:07 UTC (rev 128)
@@ -11,6 +11,8 @@
 #   derime <mot>      : supprime un mot du dictinnaire des rimes
 #   liste rimes <mot> : liste toutes les rimes connues pour le nom donn?
 #   reload_regex      : recharge les regex pour les rimes
+#   reload_answer     : charge insultes.txt
+#   reload_keywords   : charge mot.txt
 #   join <chan>       : joindre le canal <chan> (ne pas oublier le pr?fixe #)
 #   backup            : sauve toutes les donn?es sur le disque dur
 #   utf-8             : passe en UTF-8
@@ -34,226 +36,236 @@
 from dico_poilu import unicode2term 
 
 class TestBot(SingleServerIRCBot):
-	def __init__(self, channel, utf8_channel, nickname, server, port=6667):
-		SingleServerIRCBot.__init__(self, [(server, port)], nickname, nickname)
-		self.god = "haypo"
-		self.channel = channel
-		self.enmarche = 1
-		self.utf8_chan = utf8_channel
-		self.dico = dico_poilu(self)
-		self.motcle = motcle_poilu()
-		self.taux_reponse = 20
-		self.welcome = u"Salut"
-		self.start()
+    def __init__(self, channel, utf8_channel, nickname, server, port=6667):
+        SingleServerIRCBot.__init__(self, [(server, port)], nickname, nickname)
+        self.god = "haypo"
+        self.channel = channel
+        self.enmarche = 1
+        self.utf8_chan = utf8_channel
+        self.dico = dico_poilu(self)
+        self.motcle = motcle_poilu()
+        self.taux_reponse = 20
+        self.welcome = u"Salut"
 
-	def on_nicknameinuse(self, c, e):
-		c.nick(c.get_nickname() + "_")
+    def on_nicknameinuse(self, c, e):
+        c.nick(c.get_nickname() + "_")
 
-	def on_welcome(self, c, e):
-		c.join(self.channel)
-		self.send_privmsgu(self.channel, self.welcome) 
+    def on_welcome(self, c, e):
+        c.join(self.channel)
+        self.send_privmsgu(self.channel, self.welcome) 
 
-	def get_command(self, e): 
-		cmd = e.arguments()[0]
-		if self.utf8_chan: 
-			try:
-				cmd=unicode(cmd, "utf-8")
-			except:
-				self.echo("Et?s-vous s?r d'?tre en UTF-8 ?")
-				cmd=unicode(cmd, "latin-1")
-		else:
-			cmd=unicode(cmd, "iso-8859-1")
-		return cmd.strip() 
+    def get_command(self, e): 
+        cmd = e.arguments()[0]
+        if self.utf8_chan: 
+            try:
+                cmd=unicode(cmd, "utf-8")
+            except:
+                self.echo("Et?s-vous s?r d'?tre en UTF-8 ?")
+                cmd=unicode(cmd, "latin-1")
+        else:
+            cmd=unicode(cmd, "iso-8859-1")
+        return cmd.strip() 
 
-	def on_privmsg(self, c, e):
-		cmd = self.get_command(e)
-		print "on_privmsg: \"%s\"." %(cmd)
-		self.do_priv_command(cmd) 
+    def on_privmsg(self, c, e):
+        cmd = self.get_command(e)
+        self.do_priv_command(cmd) 
 
-	def on_pubmsg(self, c, e):
-		nick = nm_to_n(e.source())
-		cmd = self.get_command(e)
-		print "on_pubmsg %s:%s" %(nick, unicode2term(cmd) )
+    def on_pubmsg(self, c, e):
+        nick = nm_to_n(e.source())
+        cmd = self.get_command(e)
 
-		# Commande pour le bot
-		regs = re.compile("^"+self.connection.get_nickname()+"[:,] *(.*)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			if nick==self.god and self.do_priv_command(regs.group(1)): return
-			self.do_pub_command(nick, regs.group(1))
-			return
+        # Commande pour le bot
+        regs = re.compile("^"+self.connection.get_nickname()+"[:,] *(.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            if nick==self.god and self.do_priv_command(regs.group(1)): return
+            self.do_pub_command(nick, regs.group(1))
+            return
 
-		# Bot d?sactiv? ? Exit !
-		if self.enmarche == 0:
-			return
-			
-		# Sinon, cherche une rime
-		cmd = cmd.lower()
-		#reponse = self.dico.reponse(cmd)
-		reponse = self.motcle.reponse(cmd)
-		if reponse==None: return
-		
-		if self.taux_reponse <= random.uniform(0,101): return
-		self.send_privmsgu(self.channel, nick+": "+reponse)
-		return
+        # Bot d?sactiv? ? Exit !
+        if self.enmarche == 0:
+            return
             
-	def send_privmsg(self, nick, message):
-		if self.utf8_chan: 
-			self.connection.privmsg(nick, message.decode("latin-1").encode("utf-8"))
-		else:
-			self.connection.privmsg(nick, message)
+        # Sinon, cherche une rime
+        cmd = cmd.lower()
+        reponse = self.dico.reponse(cmd)
+        if reponse==None: reponse = self.motcle.reponse(cmd)
+        if reponse==None: return
+        
+        if self.taux_reponse <= random.uniform(0,101): return
+        self.send_privmsgu(self.channel, nick+": "+reponse)
+        return
             
-	def send_privmsgu(self, nick, message):
-		if self.utf8_chan: 
-			self.connection.privmsg(nick, message.encode("utf-8"))
-		else:
-			self.connection.privmsg(nick, message.encode("iso-8859-1"))
+    def send_privmsg(self, nick, message):
+        if self.utf8_chan: 
+            self.connection.privmsg(nick, message.decode("latin-1").encode("utf-8"))
+        else:
+            self.connection.privmsg(nick, message)
+            
+    def send_privmsgu(self, nick, message):
+        if self.utf8_chan: 
+            self.connection.privmsg(nick, message.encode("utf-8"))
+        else:
+            self.connection.privmsg(nick, message.encode("iso-8859-1"))
 
-	def echo(self, message):
-		print "%s" %( message )
-		self.send_privmsg(self.god, message)
-	
-	def echou(self, message):
-		print "%s" %( unicode2term(message) )
-		self.send_privmsgu(self.god, message)
+    def echo(self, message):
+        print "%s" %( message )
+        self.send_privmsg(self.god, message)
+    
+    def echou(self, message):
+        print "%s" %( unicode2term(message) )
+        self.send_privmsgu(self.god, message)
 
-	def before_dying(self):
-		self.dico.sauve()
+    def before_dying(self):
+        self.dico.sauve()
 
-	def do_pub_command(self, nick, cmd):
-		c = self.connection
+    def do_pub_command(self, nick, cmd):
+        c = self.connection
 
-		if (re.compile("^ta gueule", re.IGNORECASE).search(cmd) != None):
-			if self.enmarche!=0: self.send_privmsg(self.channel, "Ok, je me tais")
-			self.enmarche = 0
-		else:
-			if self.enmarche==0: self.send_privmsg(self.channel, "re")
-			self.enmarche = 1
+        if (re.compile("^ta gueule", re.IGNORECASE).search(cmd) != None):
+            if self.enmarche!=0: self.send_privmsg(self.channel, "Ok, je me tais")
+            self.enmarche = 0
+        else:
+            if self.enmarche==0: self.send_privmsg(self.channel, "re")
+            self.enmarche = 1
 
-	def do_priv_command(self, cmd):
-		c = self.connection
+    def do_priv_command(self, cmd):
+        c = self.connection
 
-		if cmd == "disconnect":
-			self.disconnect()
-			return True
-			
-		if (re.compile("^casse toi", re.IGNORECASE).search(cmd) != None):
-			self.before_dying()
-			self.die()
-			return True
-			
-		regs = re.compile("^insulte (.+) (.+)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			if self.dico.ajoute(regs.group(1), regs.group(2)): 
-				self.echou(u"Ajoute l'insulte %s pour %s" \
-					%(regs.group(2), regs.group(1)))
-			return True
-			
-		regs = re.compile("^rime (.+)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			if self.dico.ajoute_terme(regs.group(1)): 
-				self.echou(u"Ajoute la rime %s" %(regs.group(1)))
-			return True
-			
-		if cmd == "utf8":
-			if self.utf8_chan==False: self.echo("Passe en UTF-8")
-			self.utf8_chan = True
-			return True
+        if cmd == "disconnect":
+            self.disconnect()
+            return True
+            
+        if (re.compile("^casse toi", re.IGNORECASE).search(cmd) != None):
+            self.before_dying()
+            self.die()
+            return True
+            
+        regs = re.compile("^insulte (.+) (.+)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            if self.dico.ajoute(regs.group(1), regs.group(2)): 
+                self.echou(u"Ajoute l'insulte %s pour %s" \
+                    %(regs.group(2), regs.group(1)))
+            return True
+            
+        regs = re.compile("^rime (.+)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            if self.dico.ajoute_terme(regs.group(1)): 
+                self.echou(u"Ajoute la rime %s" %(regs.group(1)))
+            return True
+            
+        if cmd == "utf8":
+            if self.utf8_chan==False: self.echo("Passe en UTF-8")
+            self.utf8_chan = True
+            return True
 
-		if cmd == "iso":
-			if self.utf8_chan==True: self.echo("Passe en ISO-XXXX-X")
-			self.utf8_chan = False 
-			return True
-			
-		regs = re.compile("^derime (.*)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			if self.dico.supprime_terme(regs.group(1)) != None:
-				self.echou(u"Supprime la rime %s" %(regs.group(1)))
-			return True
-			
-		regs = re.compile("^liste rimes (.+)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			termes = self.dico.termes(regs.group(1))
-			if termes!=None: 
-				self.echou("Rimes en %s: %s" %(regs.group(1), ", ".join(termes)))
-			return True
-			
-		regs = re.compile("^liste insultes (.+)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			termes = self.motcle.insultes(regs.group(1))
-			if termes!=None: 
-				self.echou("Insultes pour %s: %s" \
-					%(regs.group(1), ", ".join(termes)))
-			return True
-			
-		regs = re.compile("^taux_reponse (.*)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			try:
-				taux = int(regs.group(1))
-				if taux<0: taux=0
-				if 100<taux: taux=100
-				self.taux_reponse = taux
-				return True
-			except:
-				self.echou(u"%s n'est pas un taux valide" %(regs.group(1)))
-			
-		if cmd=="taux_reponse":
-			self.echo ("Taux r?ponse = %s" %(self.taux_reponse) )
-			return True
+        if cmd == "iso":
+            if self.utf8_chan==True: self.echo("Passe en ISO-XXXX-X")
+            self.utf8_chan = False 
+            return True
+            
+        regs = re.compile("^derime (.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            if self.dico.supprime_terme(regs.group(1)) != None:
+                self.echou(u"Supprime la rime %s" %(regs.group(1)))
+            return True
+            
+        regs = re.compile("^liste rimes (.+)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            termes = self.dico.termes(regs.group(1))
+            if termes!=None: 
+                self.echou("Rimes en %s: %s" %(regs.group(1), ", ".join(termes)))
+            return True
+            
+        regs = re.compile("^liste insultes (.+)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            termes = self.motcle.insultes(regs.group(1))
+            if termes!=None: 
+                self.echou("Insultes pour %s: %s" \
+                    %(regs.group(1), ", ".join(termes)))
+            return True
+            
+        regs = re.compile("^taux_reponse (.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            try:
+                taux = int(regs.group(1))
+                if taux<0: taux=0
+                if 100<taux: taux=100
+                self.taux_reponse = taux
+                return True
+            except:
+                self.echou(u"%s n'est pas un taux valide" %(regs.group(1)))
+            
+        if cmd=="taux_reponse":
+            self.echo ("Taux r?ponse = %s" %(self.taux_reponse) )
+            return True
 
-		if cmd=="muet":
-			self.echou(self.dico.muet)
-			return True
+        if cmd=="muet":
+            self.echou(self.dico.muet)
+            return True
 
-		if (cmd == "reload_regex"):
-			self.echo("(recharge les regex)")
-			self.dico.charge_regex()
-			return True
-			
-		if (cmd == "backup"):
-			self.dico.sauve()
-			self.echo("backup done.")
-			return True
-			 
-		regs = re.compile("^join (.*)$", re.IGNORECASE).search(cmd)
-		if regs != None:
-			self.channel = regs.group(1) 
-			self.connection.join(self.channel)
-			return True
-		return None
+        if (cmd == "reload_regex"):
+            self.echo("(recharge les regex)")
+            self.dico.charge_regex()
+            return True
+            
+        if (cmd == "reload_keywords"):
+            self.echo("(recharge les mot-cl?s)")
+            self.motcle.charge_regex()
+            return True
+            
+        if (cmd == "reload_answer"):
+            self.echo("(recharge les insultes)")
+            self.motcle.charge()
+            return True
+            
+        if (cmd == "backup"):
+            self.dico.sauve()
+            self.echo("backup done.")
+            return True
+             
+        regs = re.compile("^join (.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            self.channel = regs.group(1) 
+            self.connection.join(self.channel)
+            return True
+        return None
 
 def main():
-	import sys
-	if len(sys.argv) != 4:
-		print "Usage: testbot <server[:port]> <channel>[:utf8] <nickname>"
-		sys.exit(1)
+    import sys
+    if len(sys.argv) != 4:
+        print "Usage: testbot <server[:port]> <channel>[:utf8] <nickname>"
+        sys.exit(1)
 
-	s = string.split(sys.argv[1], ":", 1)
-	server = s[0]
-	if len(s) == 2:
-		try:
-			port = int(s[1])
-		except ValueError:
-			print "Error: Erroneous port."
-			sys.exit(1)
-	else:
-		port = 6667
-		
-	channel = sys.argv[2]
-	regs = re.compile("^(.*):utf8$").search(channel)
-	if regs != None:
-		utf8 = True
-		channel = regs.group(1)
-	else:
-		utf8 = False
-	
-	nickname = sys.argv[3]
+    s = string.split(sys.argv[1], ":", 1)
+    server = s[0]
+    if len(s) == 2:
+        try:
+            port = int(s[1])
+        except ValueError:
+            print "Error: Erroneous port."
+            sys.exit(1)
+    else:
+        port = 6667
+        
+    channel = sys.argv[2]
+    regs = re.compile("^(.*):utf8$").search(channel)
+    if regs != None:
+        utf8 = True
+        channel = regs.group(1)
+    else:
+        utf8 = False
+    
+    nickname = sys.argv[3]
 
-	print "Creation de TestBot ..."
-	bot = TestBot(channel, utf8, nickname, server, port)
-	print "Lance TestBot ..."
-	bot.start()
+    print "Creation de TestBot ..."
+    bot = TestBot(channel, utf8, nickname, server, port)
+    print "Lance TestBot ..."
+    try:
+        bot.start()
+    except KeyboardInterrupt:
+        print "Interrompu (CTRL+C)."
 
 if __name__ == "__main__":
-	main()
+    main()
 
 

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-08 02:55:34 UTC (rev 127)
+++ poilu/trunk/terminaison.txt	2005-09-08 23:26:07 UTC (rev 128)
@@ -1,5 +1,5 @@
 r:(er(re)?|ier)$
-or:(aur(es?)?|or[te]?)$
+or:(aur(es?)?|or[tes]?)$
 aite:(aite?|et(te)?s?|??tes?)$
 ouin:(oin[g]?|ouin)$
 oua:oi([exst]|gts?|ent)?$

Modified: poilu/trunk/wormux.sh
===================================================================
--- poilu/trunk/wormux.sh	2005-09-08 02:55:34 UTC (rev 127)
+++ poilu/trunk/wormux.sh	2005-09-08 23:26:07 UTC (rev 128)
@@ -1,3 +1,3 @@
 #!/bin/sh
 set -x
-python pypoil.py irc.eu.freenode.net:6667 '#wormux:utf8' poil_au
+python pypoil.py irc.eu.freenode.net:6667 '#poilu:utf8' poil_au



From haypo at berlios.de  Fri Sep  9 02:36:44 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 9 Sep 2005 02:36:44 +0200
Subject: [Happyboom-svn] r129 - poilu/trunk
Message-ID: <200509090036.j890aiOW032038@sheep.berlios.de>

Author: haypo
Date: 2005-09-09 02:36:43 +0200 (Fri, 09 Sep 2005)
New Revision: 129

Modified:
   poilu/trunk/dico.txt
   poilu/trunk/dico_poilu.py
   poilu/trunk/motcle_regex.txt
   poilu/trunk/muet.txt
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
Log:
Ajoute "`" aux lettres muettes. Traduit les commandes en francais.
Corrige quelques petits bugs.


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-08 23:26:07 UTC (rev 128)
+++ poilu/trunk/dico.txt	2005-09-09 00:36:43 UTC (rev 129)
@@ -14,6 +14,7 @@
 vagin
 seins
 lutins
+teigneux
 thorax
 moustiques
 comique

Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-08 23:26:07 UTC (rev 128)
+++ poilu/trunk/dico_poilu.py	2005-09-09 00:36:43 UTC (rev 129)
@@ -72,6 +72,7 @@
 
     def charge_muet(self):
         f = file("muet.txt","r")
+        self.muet = " "
         for ligne in f:
             ligne = unicode(ligne.strip(), "latin-1")
             self.muet += ligne

Modified: poilu/trunk/motcle_regex.txt
===================================================================
--- poilu/trunk/motcle_regex.txt	2005-09-08 23:26:07 UTC (rev 128)
+++ poilu/trunk/motcle_regex.txt	2005-09-09 00:36:43 UTC (rev 129)
@@ -1 +1 @@
-mdr:(mdr|lo+l|ptdr+)
+mdr:([Mm]dr|lo+l|ptdr+)

Modified: poilu/trunk/muet.txt
===================================================================
--- poilu/trunk/muet.txt	2005-09-08 23:26:07 UTC (rev 128)
+++ poilu/trunk/muet.txt	2005-09-09 00:36:43 UTC (rev 129)
@@ -1 +1 @@
- h!?;-,:./\'"[](){}
+h!?;-,:./\'"[](){}`

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-08 23:26:07 UTC (rev 128)
+++ poilu/trunk/pypoil.py	2005-09-09 00:36:43 UTC (rev 129)
@@ -7,20 +7,23 @@
 # Commandes priv?es
 # -----------------
 #
-#   rime <mot>        : ajoute un mot au dictionnaire des rimes
-#   derime <mot>      : supprime un mot du dictinnaire des rimes
-#   liste rimes <mot> : liste toutes les rimes connues pour le nom donn?
-#   reload_regex      : recharge les regex pour les rimes
-#   reload_answer     : charge insultes.txt
-#   reload_keywords   : charge mot.txt
-#   join <chan>       : joindre le canal <chan> (ne pas oublier le pr?fixe #)
-#   backup            : sauve toutes les donn?es sur le disque dur
-#   utf-8             : passe en UTF-8
-#   iso               : passe en iso-xxx
-#   muet              : liste des caract?res muets
-#   taux_reponse      : affiche le taux de r?ponse
-#   taux_reponse xx   : fixe le taux de r?ponse (en pourcent), 0% : ne r?pond
-#                       jamais, 100% r?pond chaque fois qu'il trouve une rime
+#   rime <mot>           : ajoute un mot au dictionnaire des rimes
+#   derime <mot>         : supprime un mot du dictinnaire des rimes
+#   dit #chan (...)      : fait parler le bot
+#   liste rimes <mot>    : liste toutes les rimes connues pour le nom donn?
+#   recharge_muet        : recharge muet.txt
+#   recharge_terminaison : recharge terminaison.txt
+#   recharge_insult      : charge insulte.txt
+#   recharge_motcle      : charge motcle_regex.txt
+#   join #<chan>         : joindre le canal #<chan>
+#   backup               : sauve toutes les donn?es sur le disque dur
+#   utf-8                : passe en UTF-8
+#   iso                  : passe en iso-xxx
+#   muet                 : liste des caract?res muets
+#   taux_reponse         : affiche le taux de r?ponse
+#   taux_reponse xx      : fixe le taux de r?ponse (en pourcent), 0% : ne
+#                          r?pond jamais, 100% r?pond chaque fois qu'il trouve
+#                          une rime
 #
 # Commandes publiques 
 # -------------------
@@ -71,11 +74,12 @@
         self.do_priv_command(cmd) 
 
     def on_pubmsg(self, c, e):
+        self.channel = e.target()
         nick = nm_to_n(e.source())
         cmd = self.get_command(e)
 
         # Commande pour le bot
-        regs = re.compile("^"+self.connection.get_nickname()+"[:,] *(.*)$", re.IGNORECASE).search(cmd)
+        regs = re.compile("^"+self.connection.get_nickname()+"[:,>]? *(.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
             if nick==self.god and self.do_priv_command(regs.group(1)): return
             self.do_pub_command(nick, regs.group(1))
@@ -153,6 +157,11 @@
                 self.echou(u"Ajoute la rime %s" %(regs.group(1)))
             return True
             
+        regs = re.compile("^dit (#[^ ]+) (.+)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            self.send_privmsgu(regs.group(1), regs.group(2))
+            return True
+            
         if cmd == "utf8":
             if self.utf8_chan==False: self.echo("Passe en UTF-8")
             self.utf8_chan = True
@@ -191,6 +200,7 @@
                 if taux<0: taux=0
                 if 100<taux: taux=100
                 self.taux_reponse = taux
+                self.echou(u"Taux r?ponse = %s" % self.taux_reponse)
                 return True
             except:
                 self.echou(u"%s n'est pas un taux valide" %(regs.group(1)))
@@ -203,18 +213,23 @@
             self.echou(self.dico.muet)
             return True
 
-        if (cmd == "reload_regex"):
-            self.echo("(recharge les regex)")
+        if (cmd == "recharge_muet"):
+            self.echo("(recharge muet.txt)")
+            self.dico.charge_muet()
+            return True
+            
+        if (cmd == "recharge_terminaison"):
+            self.echo("(recharge terminaison.txt)")
             self.dico.charge_regex()
             return True
             
-        if (cmd == "reload_keywords"):
-            self.echo("(recharge les mot-cl?s)")
+        if (cmd == "recharge_motcle"):
+            self.echo("(recharge motcle_regex.txt)")
             self.motcle.charge_regex()
             return True
             
-        if (cmd == "reload_answer"):
-            self.echo("(recharge les insultes)")
+        if (cmd == "recharge_insulte"):
+            self.echo("(recharge insulte.txt)")
             self.motcle.charge()
             return True
             
@@ -223,7 +238,7 @@
             self.echo("backup done.")
             return True
              
-        regs = re.compile("^join (.*)$", re.IGNORECASE).search(cmd)
+        regs = re.compile("^join (#.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
             self.channel = regs.group(1) 
             self.connection.join(self.channel)
@@ -249,9 +264,13 @@
         
     channel = sys.argv[2]
     regs = re.compile("^(.*):utf8$").search(channel)
+    regsiso = re.compile("^(.*):iso$").search(channel)
     if regs != None:
         utf8 = True
         channel = regs.group(1)
+    elif regsiso != None:
+        channel = regsiso.group(1)
+        utf8 = False
     else:
         utf8 = False
     
@@ -259,7 +278,7 @@
 
     print "Creation de TestBot ..."
     bot = TestBot(channel, utf8, nickname, server, port)
-    print "Lance TestBot ..."
+    print "Lance le bot ... (salon %s, serveur %s, port %s)" % (channel, server, port)
     try:
         bot.start()
     except KeyboardInterrupt:

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-08 23:26:07 UTC (rev 128)
+++ poilu/trunk/terminaison.txt	2005-09-09 00:36:43 UTC (rev 129)
@@ -13,6 +13,7 @@
 ou:ou[setx]?$
 on:on([st]?|ds?)$
 in:(in[ts]?|ein|ains?)$
+eu:eu[xs]?$
 u:[u??][slt]?$
 i:i([et]|ls?)?$
 el:el(le)?s?$
@@ -21,7 +22,7 @@
 oup:oupe?$
 exe:ex(es?)?$
 ax:ax$
-oul:(oules?|ool)$
+oul:(oul(e|es)?)$
 eur:eur$
 in:(aim|in)s?$
 ir:ir[e]?$



From haypo at berlios.de  Fri Sep  9 03:20:04 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 9 Sep 2005 03:20:04 +0200
Subject: [Happyboom-svn] r130 - poilu/trunk
Message-ID: <200509090120.j891K4G9017993@sheep.berlios.de>

Author: haypo
Date: 2005-09-09 03:20:01 +0200 (Fri, 09 Sep 2005)
New Revision: 130

Modified:
   poilu/trunk/dico.txt
   poilu/trunk/dico_poilu.py
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
Log:
Permet de quitter un chan. Ajoute la commande "aide".


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-09 00:36:43 UTC (rev 129)
+++ poilu/trunk/dico.txt	2005-09-09 01:20:01 UTC (rev 130)
@@ -60,6 +60,7 @@
 cakos
 blaireaux
 chalumeau
+dinosaures
 pieds
 nez
 n??n??
@@ -75,4 +76,5 @@
 toutou
 minou
 roudoudou
-dinosaures
+orteils
+oreilles

Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-09 00:36:43 UTC (rev 129)
+++ poilu/trunk/dico_poilu.py	2005-09-09 01:20:01 UTC (rev 130)
@@ -5,7 +5,8 @@
 import random
 
 def unicode2term(str): 
-	return str.encode("latin-1")
+    import sys
+    return str.encode(sys.stdout.encoding)
 
 class dico_poilu:
     def __init__(self, bot):
@@ -20,7 +21,7 @@
     def echo(self, message):
         print message
 #        self.bot.echo(message)
-		
+        
     def ajoute_terme(self, terme):
         cle = self.terminaison(terme)
         if cle==None: return None

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-09 00:36:43 UTC (rev 129)
+++ poilu/trunk/pypoil.py	2005-09-09 01:20:01 UTC (rev 130)
@@ -69,6 +69,23 @@
             cmd=unicode(cmd, "iso-8859-1")
         return cmd.strip() 
 
+    def aide(self):
+        self.echou(u"Commandes :")
+        self.echou(u"- liste rimes <mot>    : liste des rimes pour la terminaison du mot sp?cifi?")
+        self.echou(u"- rime mot / derime mot : ajoute/supprime un mot du dictinnaire")
+        self.echou(u"- dit #chan (...)      : fait parler le bot")
+        self.echou(u"- recharge_muet        : recharge muet.txt")
+        self.echou(u"- recharge_terminaison : recharge terminaison.txt")
+        self.echou(u"- recharge_insult      : charge insulte.txt")
+        self.echou(u"- recharge_motcle      : charge motcle_regex.txt")
+        self.echou(u"- join #chan / leave #chan : joint/quitte le canal #<chan>")
+        self.echou(u"- backup               : sauve toutes les donn?es sur le disque dur")
+        self.echou(u"- utf-8 / iso          : passe en UTF-8 / iso-8859-1")
+        self.echou(u"- muet                 : liste des caract?res muets")
+        self.echou(u"- taux_reponse         : affiche le taux de r?ponse")
+        self.echou(u"- taux_reponse xxx     : fixe le taux de r?ponse (en pourcent)")
+
+
     def on_privmsg(self, c, e):
         cmd = self.get_command(e)
         self.do_priv_command(cmd) 
@@ -112,11 +129,10 @@
             self.connection.privmsg(nick, message.encode("iso-8859-1"))
 
     def echo(self, message):
-        print "%s" %( message )
-        self.send_privmsg(self.god, message)
+        self.echou(message.decode("iso-8859-1"))
     
     def echou(self, message):
-        print "%s" %( unicode2term(message) )
+        print unicode2term(message)
         self.send_privmsgu(self.god, message)
 
     def before_dying(self):
@@ -135,6 +151,10 @@
     def do_priv_command(self, cmd):
         c = self.connection
 
+        if cmd == "aide":
+            self.aide()
+            return True
+            
         if cmd == "disconnect":
             self.disconnect()
             return True
@@ -237,6 +257,12 @@
             self.dico.sauve()
             self.echo("backup done.")
             return True
+            
+        regs = re.compile("^leave (#.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            self.channel = regs.group(1) 
+            self.connection.leave(self.channel)
+            return True
              
         regs = re.compile("^join (#.*)$", re.IGNORECASE).search(cmd)
         if regs != None:

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-09 00:36:43 UTC (rev 129)
+++ poilu/trunk/terminaison.txt	2005-09-09 01:20:01 UTC (rev 130)
@@ -9,12 +9,13 @@
 ??:(ied[s]?|??e?s?|ez)$
 an:(en(s|ts?)?|an([dg]|ts?)?)$
 is:is$
+ou:(oo|ou[setx]?)$
 o:(au[xt]?|o[st]?|eaux?)$
-ou:ou[setx]?$
 on:on([st]?|ds?)$
 in:(in[ts]?|ein|ains?)$
 eu:eu[xs]?$
 u:[u??][slt]?$
+eil:(eil(le)?s?|a[i??]e)$
 i:i([et]|ls?)?$
 el:el(le)?s?$
 ic:i(c|ke?|que)s?$



From haypo at berlios.de  Fri Sep  9 03:49:10 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 9 Sep 2005 03:49:10 +0200
Subject: [Happyboom-svn] r131 - poilu/trunk
Message-ID: <200509090149.j891nAaV026186@sheep.berlios.de>

Author: haypo
Date: 2005-09-09 03:49:04 +0200 (Fri, 09 Sep 2005)
New Revision: 131

Added:
   poilu/trunk/irclib.py
Modified:
   poilu/trunk/dico.txt
   poilu/trunk/dico_poilu.py
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
Log:
Fixe les terminaisons. Ajoute la version tuning (avec leave) de irclib.


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/dico.txt	2005-09-09 01:49:04 UTC (rev 131)
@@ -19,15 +19,20 @@
 moustiques
 comique
 loup
+nez
+n??n??
 meules
 poing
 coin
 babouin
 marsouin
+pierre
 chien
 croutes
+pieds
+gosier
+docteur
 pubis
-docteur
 poignet
 mollet
 superettes
@@ -61,13 +66,8 @@
 blaireaux
 chalumeau
 dinosaures
-pieds
-nez
-n??n??
-gosier
 cul
 dahu
-pointu
 poilu
 tout nu
 cr??pu

Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/dico_poilu.py	2005-09-09 01:49:04 UTC (rev 131)
@@ -57,6 +57,7 @@
 
     def charge_dico(self):
         f = file("dico.txt","r")
+        self.dico = {}
         for ligne in f:
             ligne = unicode(ligne.strip(), "utf8")
             if ligne != '': self.ajoute_terme(ligne)

Added: poilu/trunk/irclib.py
===================================================================
--- poilu/trunk/irclib.py	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/irclib.py	2005-09-09 01:49:04 UTC (rev 131)
@@ -0,0 +1,1556 @@
+# Copyright (C) 1999--2002  Joel Rosdahl
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+#
+# Joel Rosdahl <joel at rosdahl.net>
+#
+# $Id: irclib.py,v 1.30 2005/02/24 01:25:50 keltus Exp $
+
+"""irclib -- Internet Relay Chat (IRC) protocol client library.
+
+This library is intended to encapsulate the IRC protocol at a quite
+low level.  It provides an event-driven IRC client framework.  It has
+a fairly thorough support for the basic IRC protocol and CTCP, but DCC
+connection support is not yet implemented.
+
+In order to understand how to make an IRC client, I'm afraid you more
+or less must understand the IRC specifications.  They are available
+here: [IRC specifications].
+
+The main features of the IRC client framework are:
+
+  * Abstraction of the IRC protocol.
+  * Handles multiple simultaneous IRC server connections.
+  * Handles server PONGing transparently.
+  * Messages to the IRC server are done by calling methods on an IRC
+    connection object.
+  * Messages from an IRC server triggers events, which can be caught
+    by event handlers.
+  * Reading from and writing to IRC server sockets are normally done
+    by an internal select() loop, but the select()ing may be done by
+    an external main loop.
+  * Functions can be registered to execute at specified times by the
+    event-loop.
+  * Decodes CTCP tagging correctly (hopefully); I haven't seen any
+    other IRC client implementation that handles the CTCP
+    specification subtilties.
+  * A kind of simple, single-server, object-oriented IRC client class
+    that dispatches events to instance methods is included.
+
+Current limitations:
+
+  * The IRC protocol shines through the abstraction a bit too much.
+  * Data is not written asynchronously to the server, i.e. the write()
+    may block if the TCP buffers are stuffed.
+  * There are no support for DCC connections.
+  * The author haven't even read RFC 2810, 2811, 2812 and 2813.
+  * Like most projects, documentation is lacking...
+
+Since I seldom use IRC anymore, I will probably not work much on the
+library.  If you want to help or continue developing the library,
+please contact me (Joel Rosdahl <joel at rosdahl.net>).
+
+.. [IRC specifications] http://www.irchelp.org/irchelp/rfc/
+"""
+
+import bisect
+import re
+import select
+import socket
+import string
+import sys
+import time
+import types
+
+VERSION = 0, 4, 4
+DEBUG = 0
+
+# TODO
+# ----
+# (maybe) thread safety
+# (maybe) color parser convenience functions
+# documentation (including all event types)
+# (maybe) add awareness of different types of ircds
+# send data asynchronously to the server (and DCC connections)
+# (maybe) automatically close unused, passive DCC connections after a while
+
+# NOTES
+# -----
+# connection.quit() only sends QUIT to the server.
+# ERROR from the server triggers the error event and the disconnect event.
+# dropping of the connection triggers the disconnect event.
+
+class IRCError(Exception):
+    """Represents an IRC exception."""
+    pass
+
+
+class IRC:
+    """Class that handles one or several IRC server connections.
+
+    When an IRC object has been instantiated, it can be used to create
+    Connection objects that represent the IRC connections.  The
+    responsibility of the IRC object is to provide an event-driven
+    framework for the connections and to keep the connections alive.
+    It runs a select loop to poll each connection's TCP socket and
+    hands over the sockets with incoming data for processing by the
+    corresponding connection.
+
+    The methods of most interest for an IRC client writer are server,
+    add_global_handler, remove_global_handler, execute_at,
+    execute_delayed, process_once and process_forever.
+
+    Here is an example:
+
+        irc = irclib.IRC()
+        server = irc.server()
+        server.connect(\"irc.some.where\", 6667, \"my_nickname\")
+        server.privmsg(\"a_nickname\", \"Hi there!\")
+        server.process_forever()
+
+    This will connect to the IRC server irc.some.where on port 6667
+    using the nickname my_nickname and send the message \"Hi there!\"
+    to the nickname a_nickname.
+    """
+
+    def __init__(self, fn_to_add_socket=None,
+                 fn_to_remove_socket=None,
+                 fn_to_add_timeout=None):
+        """Constructor for IRC objects.
+
+        Optional arguments are fn_to_add_socket, fn_to_remove_socket
+        and fn_to_add_timeout.  The first two specify functions that
+        will be called with a socket object as argument when the IRC
+        object wants to be notified (or stop being notified) of data
+        coming on a new socket.  When new data arrives, the method
+        process_data should be called.  Similarly, fn_to_add_timeout
+        is called with a number of seconds (a floating point number)
+        as first argument when the IRC object wants to receive a
+        notification (by calling the process_timeout method).  So, if
+        e.g. the argument is 42.17, the object wants the
+        process_timeout method to be called after 42 seconds and 170
+        milliseconds.
+
+        The three arguments mainly exist to be able to use an external
+        main loop (for example Tkinter's or PyGTK's main app loop)
+        instead of calling the process_forever method.
+
+        An alternative is to just call ServerConnection.process_once()
+        once in a while.
+        """
+
+        if fn_to_add_socket and fn_to_remove_socket:
+            self.fn_to_add_socket = fn_to_add_socket
+            self.fn_to_remove_socket = fn_to_remove_socket
+        else:
+            self.fn_to_add_socket = None
+            self.fn_to_remove_socket = None
+
+        self.fn_to_add_timeout = fn_to_add_timeout
+        self.connections = []
+        self.handlers = {}
+        self.delayed_commands = [] # list of tuples in the format (time, function, arguments)
+
+        self.add_global_handler("ping", _ping_ponger, -42)
+
+    def server(self):
+        """Creates and returns a ServerConnection object."""
+
+        c = ServerConnection(self)
+        self.connections.append(c)
+        return c
+
+    def process_data(self, sockets):
+        """Called when there is more data to read on connection sockets.
+
+        Arguments:
+
+            sockets -- A list of socket objects.
+
+        See documentation for IRC.__init__.
+        """
+        for s in sockets:
+            for c in self.connections:
+                if s == c._get_socket():
+                    c.process_data()
+
+    def process_timeout(self):
+        """Called when a timeout notification is due.
+
+        See documentation for IRC.__init__.
+        """
+        t = time.time()
+        while self.delayed_commands:
+            if t >= self.delayed_commands[0][0]:
+                self.delayed_commands[0][1](*self.delayed_commands[0][2])
+                del self.delayed_commands[0]
+            else:
+                break
+
+    def process_once(self, timeout=0):
+        """Process data from connections once.
+
+        Arguments:
+
+            timeout -- How long the select() call should wait if no
+                       data is available.
+
+        This method should be called periodically to check and process
+        incoming data, if there are any.  If that seems boring, look
+        at the process_forever method.
+        """
+        sockets = map(lambda x: x._get_socket(), self.connections)
+        sockets = filter(lambda x: x != None, sockets)
+        if sockets:
+            (i, o, e) = select.select(sockets, [], [], timeout)
+            self.process_data(i)
+        else:
+            time.sleep(timeout)
+        self.process_timeout()
+
+    def process_forever(self, timeout=0.2):
+        """Run an infinite loop, processing data from connections.
+
+        This method repeatedly calls process_once.
+
+        Arguments:
+
+            timeout -- Parameter to pass to process_once.
+        """
+        while 1:
+            self.process_once(timeout)
+
+    def disconnect_all(self, message=""):
+        """Disconnects all connections."""
+        for c in self.connections:
+            c.quit(message)
+            c.disconnect(message)
+
+    def add_global_handler(self, event, handler, priority=0):
+        """Adds a global handler function for a specific event type.
+
+        Arguments:
+
+            event -- Event type (a string).  Check the values of the
+            numeric_events dictionary in irclib.py for possible event
+            types.
+
+            handler -- Callback function.
+
+            priority -- A number (the lower number, the higher priority).
+
+        The handler function is called whenever the specified event is
+        triggered in any of the connections.  See documentation for
+        the Event class.
+
+        The handler functions are called in priority order (lowest
+        number is highest priority).  If a handler function returns
+        \"NO MORE\", no more handlers will be called.
+        """
+
+        if not self.handlers.has_key(event):
+            self.handlers[event] = []
+        bisect.insort(self.handlers[event], ((priority, handler)))
+
+    def remove_global_handler(self, event, handler):
+        """Removes a global handler function.
+
+        Arguments:
+
+            event -- Event type (a string).
+
+            handler -- Callback function.
+
+        Returns 1 on success, otherwise 0.
+        """
+        if not self.handlers.has_key(event):
+            return 0
+        for h in self.handlers[event]:
+            if handler == h[1]:
+                self.handlers[event].remove(h)
+        return 1
+
+    def execute_at(self, at, function, arguments=()):
+        """Execute a function at a specified time.
+
+        Arguments:
+
+            at -- Execute at this time (standard \"time_t\" time).
+
+            function -- Function to call.
+
+            arguments -- Arguments to give the function.
+        """
+        self.execute_delayed(at-time.time(), function, arguments)
+
+    def execute_delayed(self, delay, function, arguments=()):
+        """Execute a function after a specified time.
+
+        Arguments:
+
+            delay -- How many seconds to wait.
+
+            function -- Function to call.
+
+            arguments -- Arguments to give the function.
+        """
+        bisect.insort(self.delayed_commands, (delay+time.time(), function, arguments))
+        if self.fn_to_add_timeout:
+            self.fn_to_add_timeout(delay)
+
+    def dcc(self, dcctype="chat"):
+        """Creates and returns a DCCConnection object.
+
+        Arguments:
+
+            dcctype -- "chat" for DCC CHAT connections or "raw" for
+                       DCC SEND (or other DCC types). If "chat",
+                       incoming data will be split in newline-separated
+                       chunks. If "raw", incoming data is not touched.
+        """
+        c = DCCConnection(self, dcctype)
+        self.connections.append(c)
+        return c
+
+    def _handle_event(self, connection, event):
+        """[Internal]"""
+        h = self.handlers
+        for handler in h.get("all_events", []) + h.get(event.eventtype(), []):
+            if handler[1](connection, event) == "NO MORE":
+                return
+
+    def _remove_connection(self, connection):
+        """[Internal]"""
+        self.connections.remove(connection)
+        if self.fn_to_remove_socket:
+            self.fn_to_remove_socket(connection._get_socket())
+
+_rfc_1459_command_regexp = re.compile("^(:(?P<prefix>[^ ]+) +)?(?P<command>[^ ]+)( *(?P<argument> .+))?")
+
+
+class Connection:
+    """Base class for IRC connections.
+
+    Must be overridden.
+    """
+    def __init__(self, irclibobj):
+        self.irclibobj = irclibobj
+
+    def _get_socket():
+        raise IRCError, "Not overridden"
+
+    ##############################
+    ### Convenience wrappers.
+
+    def execute_at(self, at, function, arguments=()):
+        self.irclibobj.execute_at(at, function, arguments)
+
+    def execute_delayed(self, delay, function, arguments=()):
+        self.irclibobj.execute_delayed(delay, function, arguments)
+
+
+class ServerConnectionError(IRCError):
+    pass
+
+class ServerNotConnectedError(ServerConnectionError):
+    pass
+
+
+# Huh!?  Crrrrazy EFNet doesn't follow the RFC: their ircd seems to
+# use \n as message separator!  :P
+_linesep_regexp = re.compile("\r?\n")
+
+class ServerConnection(Connection):
+    """This class represents an IRC server connection.
+
+    ServerConnection objects are instantiated by calling the server
+    method on an IRC object.
+    """
+
+    def __init__(self, irclibobj):
+        Connection.__init__(self, irclibobj)
+        self.connected = 0  # Not connected yet.
+
+    def connect(self, server, port, nickname, password=None, username=None,
+                ircname=None, localaddress="", localport=0):
+        """Connect/reconnect to a server.
+
+        Arguments:
+
+            server -- Server name.
+
+            port -- Port number.
+
+            nickname -- The nickname.
+
+            password -- Password (if any).
+
+            username -- The username.
+
+            ircname -- The IRC name ("realname").
+
+            localaddress -- Bind the connection to a specific local IP address.
+
+            localport -- Bind the connection to a specific local port.
+
+        This function can be called to reconnect a closed connection.
+
+        Returns the ServerConnection object.
+        """
+        if self.connected:
+            self.quit("Changing servers")
+
+        self.socket = None
+        self.previous_buffer = ""
+        self.handlers = {}
+        self.real_server_name = ""
+        self.real_nickname = nickname
+        self.server = server
+        self.port = port
+        self.nickname = nickname
+        self.username = username or nickname
+        self.ircname = ircname or nickname
+        self.password = password
+        self.localaddress = localaddress
+        self.localport = localport
+        self.localhost = socket.gethostname()
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        try:
+            self.socket.bind((self.localaddress, self.localport))
+            self.socket.connect((self.server, self.port))
+        except socket.error, x:
+            self.socket.close()
+            self.socket = None
+            raise ServerConnectionError, "Couldn't connect to socket: %s" % x
+        self.connected = 1
+        if self.irclibobj.fn_to_add_socket:
+            self.irclibobj.fn_to_add_socket(self.socket)
+
+        # Log on...
+        if self.password:
+            self.pass_(self.password)
+        self.nick(self.nickname)
+        self.user(self.username, self.ircname)
+        return self
+
+    def close(self):
+        """Close the connection.
+
+        This method closes the connection permanently; after it has
+        been called, the object is unusable.
+        """
+
+        self.disconnect("Closing object")
+
+    def _get_socket(self):
+        """[Internal]"""
+        return self.socket
+
+    def get_server_name(self):
+        """Get the (real) server name.
+
+        This method returns the (real) server name, or, more
+        specifically, what the server calls itself.
+        """
+
+        if self.real_server_name:
+            return self.real_server_name
+        else:
+            return ""
+
+    def get_nickname(self):
+        """Get the (real) nick name.
+
+        This method returns the (real) nickname.  The library keeps
+        track of nick changes, so it might not be the nick name that
+        was passed to the connect() method.  """
+
+        return self.real_nickname
+
+    def process_data(self):
+        """[Internal]"""
+
+        try:
+            new_data = self.socket.recv(2**14)
+        except socket.error, x:
+            # The server hung up.
+            self.disconnect("Connection reset by peer")
+            return
+        if not new_data:
+            # Read nothing: connection must be down.
+            self.disconnect("Connection reset by peer")
+            return
+
+        lines = _linesep_regexp.split(self.previous_buffer + new_data)
+
+        # Save the last, unfinished line.
+        self.previous_buffer = lines[-1]
+        lines = lines[:-1]
+
+        for line in lines:
+            if DEBUG:
+                print "FROM SERVER:", line
+
+            if not line:
+                continue
+
+            prefix = None
+            command = None
+            arguments = None
+            self._handle_event(Event("all_raw_messages",
+                                     self.get_server_name(),
+                                     None,
+                                     [line]))
+
+            m = _rfc_1459_command_regexp.match(line)
+            if m.group("prefix"):
+                prefix = m.group("prefix")
+                if not self.real_server_name:
+                    self.real_server_name = prefix
+
+            if m.group("command"):
+                command = string.lower(m.group("command"))
+
+            if m.group("argument"):
+                a = string.split(m.group("argument"), " :", 1)
+                arguments = string.split(a[0])
+                if len(a) == 2:
+                    arguments.append(a[1])
+
+            if command == "nick":
+                if nm_to_n(prefix) == self.real_nickname:
+                    self.real_nickname = arguments[0]
+            elif command == "001":
+                # Record the nickname in case the client changed nick
+                # in a nicknameinuse callback.
+                self.real_nickname = arguments[0]
+
+            if command in ["privmsg", "notice"]:
+                target, message = arguments[0], arguments[1]
+                messages = _ctcp_dequote(message)
+
+                if command == "privmsg":
+                    if is_channel(target):
+                        command = "pubmsg"
+                else:
+                    if is_channel(target):
+                        command = "pubnotice"
+                    else:
+                        command = "privnotice"
+
+                for m in messages:
+                    if type(m) is types.TupleType:
+                        if command in ["privmsg", "pubmsg"]:
+                            command = "ctcp"
+                        else:
+                            command = "ctcpreply"
+
+                        m = list(m)
+                        if DEBUG:
+                            print "command: %s, source: %s, target: %s, arguments: %s" % (
+                                command, prefix, target, m)
+                        self._handle_event(Event(command, prefix, target, m))
+                        if command == "ctcp" and m[0] == "ACTION":
+                            # Emit an action event too. We're generous today.
+                            self._handle_event(Event("action", prefix, target, m[1:]))
+                    else:
+                        if DEBUG:
+                            print "command: %s, source: %s, target: %s, arguments: %s" % (
+                                command, prefix, target, [m])
+                        self._handle_event(Event(command, prefix, target, [m]))
+            else:
+                target = None
+
+                if command == "quit":
+                    arguments = [arguments[0]]
+                elif command == "ping":
+                    target = arguments[0]
+                else:
+                    target = arguments[0]
+                    arguments = arguments[1:]
+
+                if command == "mode":
+                    if not is_channel(target):
+                        command = "umode"
+
+                # Translate numerics into more readable strings.
+                if numeric_events.has_key(command):
+                    command = numeric_events[command]
+
+                if DEBUG:
+                    print "command: %s, source: %s, target: %s, arguments: %s" % (
+                        command, prefix, target, arguments)
+                self._handle_event(Event(command, prefix, target, arguments))
+
+    def _handle_event(self, event):
+        """[Internal]"""
+        self.irclibobj._handle_event(self, event)
+        if self.handlers.has_key(event.eventtype()):
+            for fn in self.handlers[event.eventtype()]:
+                fn(self, event)
+
+    def is_connected(self):
+        """Return connection status.
+
+        Returns true if connected, otherwise false.
+        """
+        return self.connected
+
+    def add_global_handler(self, *args):
+        """Add global handler.
+
+        See documentation for IRC.add_global_handler.
+        """
+        self.irclibobj.add_global_handler(*args)
+
+    def remove_global_handler(self, *args):
+        """Remove global handler.
+
+        See documentation for IRC.remove_global_handler.
+        """
+        self.irclibobj.remove_global_handler(*args)
+
+    def action(self, target, action):
+        """Send a CTCP ACTION command."""
+        self.ctcp("ACTION", target, action)
+
+    def admin(self, server=""):
+        """Send an ADMIN command."""
+        self.send_raw(string.strip(string.join(["ADMIN", server])))
+
+    def ctcp(self, ctcptype, target, parameter=""):
+        """Send a CTCP command."""
+        ctcptype = string.upper(ctcptype)
+        self.privmsg(target, "\001%s%s\001" % (ctcptype, parameter and (" " + parameter) or ""))
+
+    def ctcp_reply(self, target, parameter):
+        """Send a CTCP REPLY command."""
+        self.notice(target, "\001%s\001" % parameter)
+
+    def disconnect(self, message=""):
+        """Hang up the connection.
+
+        Arguments:
+
+            message -- Quit message.
+        """
+        if not self.connected:
+            return
+
+        self.irclibobj._remove_connection(self)
+        self.connected = 0
+        try:
+            self.socket.close()
+        except socket.error, x:
+            pass
+        self.socket = None
+        self._handle_event(Event("disconnect", self.server, "", [message]))
+
+    def globops(self, text):
+        """Send a GLOBOPS command."""
+        self.send_raw("GLOBOPS :" + text)
+
+    def info(self, server=""):
+        """Send an INFO command."""
+        self.send_raw(string.strip(string.join(["INFO", server])))
+
+    def invite(self, nick, channel):
+        """Send an INVITE command."""
+        self.send_raw(string.strip(string.join(["INVITE", nick, channel])))
+
+    def ison(self, nicks):
+        """Send an ISON command.
+
+        Arguments:
+
+            nicks -- List of nicks.
+        """
+        self.send_raw("ISON " + string.join(nicks, " "))
+
+    def leave(self, channel, key=""):
+        """Send a LEAVE command."""
+        self.send_raw("PART %s%s" % (channel, (key and (" " + key))))
+
+    def join(self, channel, key=""):
+        """Send a JOIN command."""
+        self.send_raw("JOIN %s%s" % (channel, (key and (" " + key))))
+
+    def kick(self, channel, nick, comment=""):
+        """Send a KICK command."""
+        self.send_raw("KICK %s %s%s" % (channel, nick, (comment and (" :" + comment))))
+
+    def links(self, remote_server="", server_mask=""):
+        """Send a LINKS command."""
+        command = "LINKS"
+        if remote_server:
+            command = command + " " + remote_server
+        if server_mask:
+            command = command + " " + server_mask
+        self.send_raw(command)
+
+    def list(self, channels=None, server=""):
+        """Send a LIST command."""
+        command = "LIST"
+        if channels:
+            command = command + " " + string.join(channels, ",")
+        if server:
+            command = command + " " + server
+        self.send_raw(command)
+
+    def lusers(self, server=""):
+        """Send a LUSERS command."""
+        self.send_raw("LUSERS" + (server and (" " + server)))
+
+    def mode(self, target, command):
+        """Send a MODE command."""
+        self.send_raw("MODE %s %s" % (target, command))
+
+    def motd(self, server=""):
+        """Send an MOTD command."""
+        self.send_raw("MOTD" + (server and (" " + server)))
+
+    def names(self, channels=None):
+        """Send a NAMES command."""
+        self.send_raw("NAMES" + (channels and (" " + string.join(channels, ",")) or ""))
+
+    def nick(self, newnick):
+        """Send a NICK command."""
+        self.send_raw("NICK " + newnick)
+
+    def notice(self, target, text):
+        """Send a NOTICE command."""
+        # Should limit len(text) here!
+        self.send_raw("NOTICE %s :%s" % (target, text))
+
+    def oper(self, nick, password):
+        """Send an OPER command."""
+        self.send_raw("OPER %s %s" % (nick, password))
+
+    def part(self, channels):
+        """Send a PART command."""
+        if type(channels) == types.StringType:
+            self.send_raw("PART " + channels)
+        else:
+            self.send_raw("PART " + string.join(channels, ","))
+
+    def pass_(self, password):
+        """Send a PASS command."""
+        self.send_raw("PASS " + password)
+
+    def ping(self, target, target2=""):
+        """Send a PING command."""
+        self.send_raw("PING %s%s" % (target, target2 and (" " + target2)))
+
+    def pong(self, target, target2=""):
+        """Send a PONG command."""
+        self.send_raw("PONG %s%s" % (target, target2 and (" " + target2)))
+
+    def privmsg(self, target, text):
+        """Send a PRIVMSG command."""
+        # Should limit len(text) here!
+        self.send_raw("PRIVMSG %s :%s" % (target, text))
+
+    def privmsg_many(self, targets, text):
+        """Send a PRIVMSG command to multiple targets."""
+        # Should limit len(text) here!
+        self.send_raw("PRIVMSG %s :%s" % (string.join(targets, ","), text))
+
+    def quit(self, message=""):
+        """Send a QUIT command."""
+        # Note that many IRC servers don't use your QUIT message
+        # unless you've been connected for at least 5 minutes!
+        self.send_raw("QUIT" + (message and (" :" + message)))
+
+    def sconnect(self, target, port="", server=""):
+        """Send an SCONNECT command."""
+        self.send_raw("CONNECT %s%s%s" % (target,
+                                          port and (" " + port),
+                                          server and (" " + server)))
+
+    def send_raw(self, string):
+        """Send raw string to the server.
+
+        The string will be padded with appropriate CR LF.
+        """
+        if self.socket is None:
+            raise ServerNotConnectedError, "Not connected."
+        try:
+            self.socket.send(string + "\r\n")
+            if DEBUG:
+                print "TO SERVER:", string
+        except socket.error, x:
+            # Ouch!
+            self.disconnect("Connection reset by peer.")
+
+    def squit(self, server, comment=""):
+        """Send an SQUIT command."""
+        self.send_raw("SQUIT %s%s" % (server, comment and (" :" + comment)))
+
+    def stats(self, statstype, server=""):
+        """Send a STATS command."""
+        self.send_raw("STATS %s%s" % (statstype, server and (" " + server)))
+
+    def time(self, server=""):
+        """Send a TIME command."""
+        self.send_raw("TIME" + (server and (" " + server)))
+
+    def topic(self, channel, new_topic=None):
+        """Send a TOPIC command."""
+        if new_topic == None:
+            self.send_raw("TOPIC " + channel)
+        else:
+            self.send_raw("TOPIC %s :%s" % (channel, new_topic))
+
+    def trace(self, target=""):
+        """Send a TRACE command."""
+        self.send_raw("TRACE" + (target and (" " + target)))
+
+    def user(self, username, realname):
+        """Send a USER command."""
+        self.send_raw("USER %s 0 * :%s" % (username, realname))
+
+    def userhost(self, nicks):
+        """Send a USERHOST command."""
+        self.send_raw("USERHOST " + string.join(nicks, ","))
+
+    def users(self, server=""):
+        """Send a USERS command."""
+        self.send_raw("USERS" + (server and (" " + server)))
+
+    def version(self, server=""):
+        """Send a VERSION command."""
+        self.send_raw("VERSION" + (server and (" " + server)))
+
+    def wallops(self, text):
+        """Send a WALLOPS command."""
+        self.send_raw("WALLOPS :" + text)
+
+    def who(self, target="", op=""):
+        """Send a WHO command."""
+        self.send_raw("WHO%s%s" % (target and (" " + target), op and (" o")))
+
+    def whois(self, targets):
+        """Send a WHOIS command."""
+        self.send_raw("WHOIS " + string.join(targets, ","))
+
+    def whowas(self, nick, max="", server=""):
+        """Send a WHOWAS command."""
+        self.send_raw("WHOWAS %s%s%s" % (nick,
+                                         max and (" " + max),
+                                         server and (" " + server)))
+
+
+class DCCConnectionError(IRCError):
+    pass
+
+
+class DCCConnection(Connection):
+    """This class represents a DCC connection.
+
+    DCCConnection objects are instantiated by calling the dcc
+    method on an IRC object.
+    """
+    def __init__(self, irclibobj, dcctype):
+        Connection.__init__(self, irclibobj)
+        self.connected = 0
+        self.passive = 0
+        self.dcctype = dcctype
+        self.peeraddress = None
+        self.peerport = None
+
+    def connect(self, address, port):
+        """Connect/reconnect to a DCC peer.
+
+        Arguments:
+            address -- Host/IP address of the peer.
+
+            port -- The port number to connect to.
+
+        Returns the DCCConnection object.
+        """
+        self.peeraddress = socket.gethostbyname(address)
+        self.peerport = port
+        self.socket = None
+        self.previous_buffer = ""
+        self.handlers = {}
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.passive = 0
+        try:
+            self.socket.connect((self.peeraddress, self.peerport))
+        except socket.error, x:
+            raise DCCConnectionError, "Couldn't connect to socket: %s" % x
+        self.connected = 1
+        if self.irclibobj.fn_to_add_socket:
+            self.irclibobj.fn_to_add_socket(self.socket)
+        return self
+
+    def listen(self):
+        """Wait for a connection/reconnection from a DCC peer.
+
+        Returns the DCCConnection object.
+
+        The local IP address and port are available as
+        self.localaddress and self.localport.  After connection from a
+        peer, the peer address and port are available as
+        self.peeraddress and self.peerport.
+        """
+        self.previous_buffer = ""
+        self.handlers = {}
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.passive = 1
+        try:
+            self.socket.bind((socket.gethostbyname(socket.gethostname()), 0))
+            self.localaddress, self.localport = self.socket.getsockname()
+            self.socket.listen(10)
+        except socket.error, x:
+            raise DCCConnectionError, "Couldn't bind socket: %s" % x
+        return self
+
+    def disconnect(self, message=""):
+        """Hang up the connection and close the object.
+
+        Arguments:
+
+            message -- Quit message.
+        """
+        if not self.connected:
+            return
+
+        self.connected = 0
+        try:
+            self.socket.close()
+        except socket.error, x:
+            pass
+        self.socket = None
+        self.irclibobj._handle_event(
+            self,
+            Event("dcc_disconnect", self.peeraddress, "", [message]))
+        self.irclibobj._remove_connection(self)
+
+    def process_data(self):
+        """[Internal]"""
+
+        if self.passive and not self.connected:
+            conn, (self.peeraddress, self.peerport) = self.socket.accept()
+            self.socket.close()
+            self.socket = conn
+            self.connected = 1
+            if DEBUG:
+                print "DCC connection from %s:%d" % (
+                    self.peeraddress, self.peerport)
+            self.irclibobj._handle_event(
+                self,
+                Event("dcc_connect", self.peeraddress, None, None))
+            return
+
+        try:
+            new_data = self.socket.recv(2**14)
+        except socket.error, x:
+            # The server hung up.
+            self.disconnect("Connection reset by peer")
+            return
+        if not new_data:
+            # Read nothing: connection must be down.
+            self.disconnect("Connection reset by peer")
+            return
+
+        if self.dcctype == "chat":
+            # The specification says lines are terminated with LF, but
+            # it seems safer to handle CR LF terminations too.
+            chunks = _linesep_regexp.split(self.previous_buffer + new_data)
+
+            # Save the last, unfinished line.
+            self.previous_buffer = chunks[-1]
+            if len(self.previous_buffer) > 2**14:
+                # Bad peer! Naughty peer!
+                self.disconnect()
+                return
+            chunks = chunks[:-1]
+        else:
+            chunks = [new_data]
+
+        command = "dccmsg"
+        prefix = self.peeraddress
+        target = None
+        for chunk in chunks:
+            if DEBUG:
+                print "FROM PEER:", chunk
+            arguments = [chunk]
+            if DEBUG:
+                print "command: %s, source: %s, target: %s, arguments: %s" % (
+                    command, prefix, target, arguments)
+            self.irclibobj._handle_event(
+                self,
+                Event(command, prefix, target, arguments))
+
+    def _get_socket(self):
+        """[Internal]"""
+        return self.socket
+
+    def privmsg(self, string):
+        """Send data to DCC peer.
+
+        The string will be padded with appropriate LF if it's a DCC
+        CHAT session.
+        """
+        try:
+            self.socket.send(string)
+            if self.dcctype == "chat":
+                self.socket.send("\n")
+            if DEBUG:
+                print "TO PEER: %s\n" % string
+        except socket.error, x:
+            # Ouch!
+            self.disconnect("Connection reset by peer.")
+
+class SimpleIRCClient:
+    """A simple single-server IRC client class.
+
+    This is an example of an object-oriented wrapper of the IRC
+    framework.  A real IRC client can be made by subclassing this
+    class and adding appropriate methods.
+
+    The method on_join will be called when a "join" event is created
+    (which is done when the server sends a JOIN messsage/command),
+    on_privmsg will be called for "privmsg" events, and so on.  The
+    handler methods get two arguments: the connection object (same as
+    self.connection) and the event object.
+
+    Instance attributes that can be used by sub classes:
+
+        ircobj -- The IRC instance.
+
+        connection -- The ServerConnection instance.
+
+        dcc_connections -- A list of DCCConnection instances.
+    """
+    def __init__(self):
+        self.ircobj = IRC()
+        self.connection = self.ircobj.server()
+        self.dcc_connections = []
+        self.ircobj.add_global_handler("all_events", self._dispatcher, -10)
+        self.ircobj.add_global_handler("dcc_disconnect", self._dcc_disconnect, -10)
+
+    def _dispatcher(self, c, e):
+        """[Internal]"""
+        m = "on_" + e.eventtype()
+        if hasattr(self, m):
+            getattr(self, m)(c, e)
+
+    def _dcc_disconnect(self, c, e):
+        self.dcc_connections.remove(c)
+
+    def connect(self, server, port, nickname, password=None, username=None,
+                ircname=None, localaddress="", localport=0):
+        """Connect/reconnect to a server.
+
+        Arguments:
+
+            server -- Server name.
+
+            port -- Port number.
+
+            nickname -- The nickname.
+
+            password -- Password (if any).
+
+            username -- The username.
+
+            ircname -- The IRC name.
+
+            localaddress -- Bind the connection to a specific local IP address.
+
+            localport -- Bind the connection to a specific local port.
+
+        This function can be called to reconnect a closed connection.
+        """
+        self.connection.connect(server, port, nickname,
+                                password, username, ircname,
+                                localaddress, localport)
+
+    def dcc_connect(self, address, port, dcctype="chat"):
+        """Connect to a DCC peer.
+
+        Arguments:
+
+            address -- IP address of the peer.
+
+            port -- Port to connect to.
+
+        Returns a DCCConnection instance.
+        """
+        dcc = self.ircobj.dcc(dcctype)
+        self.dcc_connections.append(dcc)
+        dcc.connect(address, port)
+        return dcc
+
+    def dcc_listen(self, dcctype="chat"):
+        """Listen for connections from a DCC peer.
+
+        Returns a DCCConnection instance.
+        """
+        dcc = self.ircobj.dcc(dcctype)
+        self.dcc_connections.append(dcc)
+        dcc.listen()
+        return dcc
+
+    def start(self):
+        """Start the IRC client."""
+        self.ircobj.process_forever()
+
+
+class Event:
+    """Class representing an IRC event."""
+    def __init__(self, eventtype, source, target, arguments=None):
+        """Constructor of Event objects.
+
+        Arguments:
+
+            eventtype -- A string describing the event.
+
+            source -- The originator of the event (a nick mask or a server). XXX Correct?
+
+            target -- The target of the event (a nick or a channel). XXX Correct?
+
+            arguments -- Any event specific arguments.
+        """
+        self._eventtype = eventtype
+        self._source = source
+        self._target = target
+        if arguments:
+            self._arguments = arguments
+        else:
+            self._arguments = []
+
+    def eventtype(self):
+        """Get the event type."""
+        return self._eventtype
+
+    def source(self):
+        """Get the event source."""
+        return self._source
+
+    def target(self):
+        """Get the event target."""
+        return self._target
+
+    def arguments(self):
+        """Get the event arguments."""
+        return self._arguments
+
+_LOW_LEVEL_QUOTE = "\020"
+_CTCP_LEVEL_QUOTE = "\134"
+_CTCP_DELIMITER = "\001"
+
+_low_level_mapping = {
+    "0": "\000",
+    "n": "\n",
+    "r": "\r",
+    _LOW_LEVEL_QUOTE: _LOW_LEVEL_QUOTE
+}
+
+_low_level_regexp = re.compile(_LOW_LEVEL_QUOTE + "(.)")
+
+def mask_matches(nick, mask):
+    """Check if a nick matches a mask.
+
+    Returns true if the nick matches, otherwise false.
+    """
+    nick = irc_lower(nick)
+    mask = irc_lower(mask)
+    mask = string.replace(mask, "\\", "\\\\")
+    for ch in ".$|[](){}+":
+        mask = string.replace(mask, ch, "\\" + ch)
+    mask = string.replace(mask, "?", ".")
+    mask = string.replace(mask, "*", ".*")
+    r = re.compile(mask, re.IGNORECASE)
+    return r.match(nick)
+
+_alpha = "abcdefghijklmnopqrstuvwxyz"
+_special = "-[]\\`^{}"
+nick_characters = _alpha + string.upper(_alpha) + string.digits + _special
+_ircstring_translation = string.maketrans(string.upper(_alpha) + "[]\\^",
+                                          _alpha + "{}|~")
+
+def irc_lower(s):
+    """Returns a lowercased string.
+
+    The definition of lowercased comes from the IRC specification (RFC
+    1459).
+    """
+    return string.translate(s, _ircstring_translation)
+
+def _ctcp_dequote(message):
+    """[Internal] Dequote a message according to CTCP specifications.
+
+    The function returns a list where each element can be either a
+    string (normal message) or a tuple of one or two strings (tagged
+    messages).  If a tuple has only one element (ie is a singleton),
+    that element is the tag; otherwise the tuple has two elements: the
+    tag and the data.
+
+    Arguments:
+
+        message -- The message to be decoded.
+    """
+
+    def _low_level_replace(match_obj):
+        ch = match_obj.group(1)
+
+        # If low_level_mapping doesn't have the character as key, we
+        # should just return the character.
+        return _low_level_mapping.get(ch, ch)
+
+    if _LOW_LEVEL_QUOTE in message:
+        # Yup, there was a quote.  Release the dequoter, man!
+        message = _low_level_regexp.sub(_low_level_replace, message)
+
+    if _CTCP_DELIMITER not in message:
+        return [message]
+    else:
+        # Split it into parts.  (Does any IRC client actually *use*
+        # CTCP stacking like this?)
+        chunks = string.split(message, _CTCP_DELIMITER)
+
+        messages = []
+        i = 0
+        while i < len(chunks)-1:
+            # Add message if it's non-empty.
+            if len(chunks[i]) > 0:
+                messages.append(chunks[i])
+
+            if i < len(chunks)-2:
+                # Aye!  CTCP tagged data ahead!
+                messages.append(tuple(string.split(chunks[i+1], " ", 1)))
+
+            i = i + 2
+
+        if len(chunks) % 2 == 0:
+            # Hey, a lonely _CTCP_DELIMITER at the end!  This means
+            # that the last chunk, including the delimiter, is a
+            # normal message!  (This is according to the CTCP
+            # specification.)
+            messages.append(_CTCP_DELIMITER + chunks[-1])
+
+        return messages
+
+def is_channel(string):
+    """Check if a string is a channel name.
+
+    Returns true if the argument is a channel name, otherwise false.
+    """
+    return string and string[0] in "#&+!"
+
+def ip_numstr_to_quad(num):
+    """Convert an IP number as an integer given in ASCII
+    representation (e.g. '3232235521') to an IP address string
+    (e.g. '192.168.0.1')."""
+    n = long(num)
+    p = map(str, map(int, [n >> 24 & 0xFF, n >> 16 & 0xFF,
+                           n >> 8 & 0xFF, n & 0xFF]))
+    return string.join(p, ".")
+
+def ip_quad_to_numstr(quad):
+    """Convert an IP address string (e.g. '192.168.0.1') to an IP
+    number as an integer given in ASCII representation
+    (e.g. '3232235521')."""
+    p = map(long, string.split(quad, "."))
+    s = str((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3])
+    if s[-1] == "L":
+        s = s[:-1]
+    return s
+
+def nm_to_n(s):
+    """Get the nick part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    """
+    return string.split(s, "!")[0]
+
+def nm_to_uh(s):
+    """Get the userhost part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    """
+    return string.split(s, "!")[1]
+
+def nm_to_h(s):
+    """Get the host part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    """
+    return string.split(s, "@")[1]
+
+def nm_to_u(s):
+    """Get the user part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    """
+    s = string.split(s, "!")[1]
+    return string.split(s, "@")[0]
+
+def parse_nick_modes(mode_string):
+    """Parse a nick mode string.
+
+    The function returns a list of lists with three members: sign,
+    mode and argument.  The sign is \"+\" or \"-\".  The argument is
+    always None.
+
+    Example:
+
+    >>> irclib.parse_nick_modes(\"+ab-c\")
+    [['+', 'a', None], ['+', 'b', None], ['-', 'c', None]]
+    """
+
+    return _parse_modes(mode_string, "")
+
+def parse_channel_modes(mode_string):
+    """Parse a channel mode string.
+
+    The function returns a list of lists with three members: sign,
+    mode and argument.  The sign is \"+\" or \"-\".  The argument is
+    None if mode isn't one of \"b\", \"k\", \"l\", \"v\" or \"o\".
+
+    Example:
+
+    >>> irclib.parse_channel_modes(\"+ab-c foo\")
+    [['+', 'a', None], ['+', 'b', 'foo'], ['-', 'c', None]]
+    """
+
+    return _parse_modes(mode_string, "bklvo")
+
+def _parse_modes(mode_string, unary_modes=""):
+    """[Internal]"""
+    modes = []
+    arg_count = 0
+
+    # State variable.
+    sign = ""
+
+    a = string.split(mode_string)
+    if len(a) == 0:
+        return []
+    else:
+        mode_part, args = a[0], a[1:]
+
+    if mode_part[0] not in "+-":
+        return []
+    for ch in mode_part:
+        if ch in "+-":
+            sign = ch
+        elif ch == " ":
+            collecting_arguments = 1
+        elif ch in unary_modes:
+            if len(args) >= arg_count + 1:
+                modes.append([sign, ch, args[arg_count]])
+                arg_count = arg_count + 1
+            else:
+                modes.append([sign, ch, None])
+        else:
+            modes.append([sign, ch, None])
+    return modes
+
+def _ping_ponger(connection, event):
+    """[Internal]"""
+    connection.pong(event.target())
+
+# Numeric table mostly stolen from the Perl IRC module (Net::IRC).
+numeric_events = {
+    "001": "welcome",
+    "002": "yourhost",
+    "003": "created",
+    "004": "myinfo",
+    "005": "featurelist",  # XXX
+    "200": "tracelink",
+    "201": "traceconnecting",
+    "202": "tracehandshake",
+    "203": "traceunknown",
+    "204": "traceoperator",
+    "205": "traceuser",
+    "206": "traceserver",
+    "207": "traceservice",
+    "208": "tracenewtype",
+    "209": "traceclass",
+    "210": "tracereconnect",
+    "211": "statslinkinfo",
+    "212": "statscommands",
+    "213": "statscline",
+    "214": "statsnline",
+    "215": "statsiline",
+    "216": "statskline",
+    "217": "statsqline",
+    "218": "statsyline",
+    "219": "endofstats",
+    "221": "umodeis",
+    "231": "serviceinfo",
+    "232": "endofservices",
+    "233": "service",
+    "234": "servlist",
+    "235": "servlistend",
+    "241": "statslline",
+    "242": "statsuptime",
+    "243": "statsoline",
+    "244": "statshline",
+    "250": "luserconns",
+    "251": "luserclient",
+    "252": "luserop",
+    "253": "luserunknown",
+    "254": "luserchannels",
+    "255": "luserme",
+    "256": "adminme",
+    "257": "adminloc1",
+    "258": "adminloc2",
+    "259": "adminemail",
+    "261": "tracelog",
+    "262": "endoftrace",
+    "263": "tryagain",
+    "265": "n_local",
+    "266": "n_global",
+    "300": "none",
+    "301": "away",
+    "302": "userhost",
+    "303": "ison",
+    "305": "unaway",
+    "306": "nowaway",
+    "311": "whoisuser",
+    "312": "whoisserver",
+    "313": "whoisoperator",
+    "314": "whowasuser",
+    "315": "endofwho",
+    "316": "whoischanop",
+    "317": "whoisidle",
+    "318": "endofwhois",
+    "319": "whoischannels",
+    "321": "liststart",
+    "322": "list",
+    "323": "listend",
+    "324": "channelmodeis",
+    "329": "channelcreate",
+    "331": "notopic",
+    "332": "topic",
+    "333": "topicinfo",
+    "341": "inviting",
+    "342": "summoning",
+    "346": "invitelist",
+    "347": "endofinvitelist",
+    "348": "exceptlist",
+    "349": "endofexceptlist",
+    "351": "version",
+    "352": "whoreply",
+    "353": "namreply",
+    "361": "killdone",
+    "362": "closing",
+    "363": "closeend",
+    "364": "links",
+    "365": "endoflinks",
+    "366": "endofnames",
+    "367": "banlist",
+    "368": "endofbanlist",
+    "369": "endofwhowas",
+    "371": "info",
+    "372": "motd",
+    "373": "infostart",
+    "374": "endofinfo",
+    "375": "motdstart",
+    "376": "endofmotd",
+    "377": "motd2",        # 1997-10-16 -- tkil
+    "381": "youreoper",
+    "382": "rehashing",
+    "384": "myportis",
+    "391": "time",
+    "392": "usersstart",
+    "393": "users",
+    "394": "endofusers",
+    "395": "nousers",
+    "401": "nosuchnick",
+    "402": "nosuchserver",
+    "403": "nosuchchannel",
+    "404": "cannotsendtochan",
+    "405": "toomanychannels",
+    "406": "wasnosuchnick",
+    "407": "toomanytargets",
+    "409": "noorigin",
+    "411": "norecipient",
+    "412": "notexttosend",
+    "413": "notoplevel",
+    "414": "wildtoplevel",
+    "421": "unknowncommand",
+    "422": "nomotd",
+    "423": "noadmininfo",
+    "424": "fileerror",
+    "431": "nonicknamegiven",
+    "432": "erroneusnickname", # Thiss iz how its speld in thee RFC.
+    "433": "nicknameinuse",
+    "436": "nickcollision",
+    "437": "unavailresource",  # "Nick temporally unavailable"
+    "441": "usernotinchannel",
+    "442": "notonchannel",
+    "443": "useronchannel",
+    "444": "nologin",
+    "445": "summondisabled",
+    "446": "usersdisabled",
+    "451": "notregistered",
+    "461": "needmoreparams",
+    "462": "alreadyregistered",
+    "463": "nopermforhost",
+    "464": "passwdmismatch",
+    "465": "yourebannedcreep", # I love this one...
+    "466": "youwillbebanned",
+    "467": "keyset",
+    "471": "channelisfull",
+    "472": "unknownmode",
+    "473": "inviteonlychan",
+    "474": "bannedfromchan",
+    "475": "badchannelkey",
+    "476": "badchanmask",
+    "477": "nochanmodes",  # "Channel doesn't support modes"
+    "478": "banlistfull",
+    "481": "noprivileges",
+    "482": "chanoprivsneeded",
+    "483": "cantkillserver",
+    "484": "restricted",   # Connection is restricted
+    "485": "uniqopprivsneeded",
+    "491": "nooperhost",
+    "492": "noservicehost",
+    "501": "umodeunknownflag",
+    "502": "usersdontmatch",
+}
+
+generated_events = [
+    # Generated events
+    "dcc_connect",
+    "dcc_disconnect",
+    "dccmsg",
+    "disconnect",
+    "ctcp",
+    "ctcpreply",
+]
+
+protocol_events = [
+    # IRC protocol events
+    "error",
+    "join",
+    "kick",
+    "mode",
+    "part",
+    "ping",
+    "privmsg",
+    "privnotice",
+    "pubmsg",
+    "pubnotice",
+    "quit",
+]
+
+all_events = generated_events + protocol_events + numeric_events.values()

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/pypoil.py	2005-09-09 01:49:04 UTC (rev 131)
@@ -7,23 +7,7 @@
 # Commandes priv?es
 # -----------------
 #
-#   rime <mot>           : ajoute un mot au dictionnaire des rimes
-#   derime <mot>         : supprime un mot du dictinnaire des rimes
-#   dit #chan (...)      : fait parler le bot
-#   liste rimes <mot>    : liste toutes les rimes connues pour le nom donn?
-#   recharge_muet        : recharge muet.txt
-#   recharge_terminaison : recharge terminaison.txt
-#   recharge_insult      : charge insulte.txt
-#   recharge_motcle      : charge motcle_regex.txt
-#   join #<chan>         : joindre le canal #<chan>
-#   backup               : sauve toutes les donn?es sur le disque dur
-#   utf-8                : passe en UTF-8
-#   iso                  : passe en iso-xxx
-#   muet                 : liste des caract?res muets
-#   taux_reponse         : affiche le taux de r?ponse
-#   taux_reponse xx      : fixe le taux de r?ponse (en pourcent), 0% : ne
-#                          r?pond jamais, 100% r?pond chaque fois qu'il trouve
-#                          une rime
+#  Tapez "aide" pour obtenir l'aide ;-) (ou voir la fonction aide ci-dessous)
 #
 # Commandes publiques 
 # -------------------
@@ -76,13 +60,13 @@
         self.echou(u"- dit #chan (...)      : fait parler le bot")
         self.echou(u"- recharge_muet        : recharge muet.txt")
         self.echou(u"- recharge_terminaison : recharge terminaison.txt")
-        self.echou(u"- recharge_insult      : charge insulte.txt")
-        self.echou(u"- recharge_motcle      : charge motcle_regex.txt")
+        self.echou(u"- recharge_dico        : recharge dico.txt")
+        self.echou(u"- recharge_insult      : recharge insulte.txt")
+        self.echou(u"- recharge_motcle      : recharge motcle_regex.txt")
         self.echou(u"- join #chan / leave #chan : joint/quitte le canal #<chan>")
         self.echou(u"- backup               : sauve toutes les donn?es sur le disque dur")
         self.echou(u"- utf-8 / iso          : passe en UTF-8 / iso-8859-1")
         self.echou(u"- muet                 : liste des caract?res muets")
-        self.echou(u"- taux_reponse         : affiche le taux de r?ponse")
         self.echou(u"- taux_reponse xxx     : fixe le taux de r?ponse (en pourcent)")
 
 
@@ -220,15 +204,11 @@
                 if taux<0: taux=0
                 if 100<taux: taux=100
                 self.taux_reponse = taux
-                self.echou(u"Taux r?ponse = %s" % self.taux_reponse)
+                self.echou(u"Taux r?ponse = %s%%" % self.taux_reponse)
                 return True
             except:
                 self.echou(u"%s n'est pas un taux valide" %(regs.group(1)))
             
-        if cmd=="taux_reponse":
-            self.echo ("Taux r?ponse = %s" %(self.taux_reponse) )
-            return True
-
         if cmd=="muet":
             self.echou(self.dico.muet)
             return True
@@ -238,9 +218,16 @@
             self.dico.charge_muet()
             return True
             
+        if (cmd == "recharge_dico"):
+            self.echo("(recharge dico.txt)")
+            self.dico.charge_dico()
+            return True
+            
         if (cmd == "recharge_terminaison"):
-            self.echo("(recharge terminaison.txt)")
+            self.echo("(sauve dico, recharge terminaison.txt puis dico.txt)")
+            self.dico.sauve()
             self.dico.charge_regex()
+            self.dico.charge_dico()
             return True
             
         if (cmd == "recharge_motcle"):
@@ -308,6 +295,7 @@
     try:
         bot.start()
     except KeyboardInterrupt:
+        bot.dico.sauve()
         print "Interrompu (CTRL+C)."
 
 if __name__ == "__main__":

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/terminaison.txt	2005-09-09 01:49:04 UTC (rev 131)
@@ -1,4 +1,6 @@
-r:(er(re)?|ier)$
+ied:(ied[s]?|sier)$
+ier:ier(re)?s?$
+r:(er(re)?|??re)$
 or:(aur(es?)?|or[tes]?)$
 aite:(aite?|et(te)?s?|??tes?)$
 ouin:(oin[g]?|ouin)$
@@ -6,7 +8,7 @@
 ien:ien[ts]?$
 a:(a[st]?|??)$
 ??:(??[ts]?|ai([ets]|ent)?|a??)$
-??:(ied[s]?|??e?s?|ez)$
+er:(??e?s?|ez|cd)$
 an:(en(s|ts?)?|an([dg]|ts?)?)$
 is:is$
 ou:(oo|ou[setx]?)$



From haypo at berlios.de  Fri Sep  9 04:02:23 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 9 Sep 2005 04:02:23 +0200
Subject: [Happyboom-svn] r132 - poilu/trunk
Message-ID: <200509090202.j8922NO7029021@sheep.berlios.de>

Author: haypo
Date: 2005-09-09 04:02:16 +0200 (Fri, 09 Sep 2005)
New Revision: 132

Modified:
   poilu/trunk/dico.txt
   poilu/trunk/pypoil.py
Log:
Permet de changer de nick et de parler en prive a d'autre personnes.


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-09 01:49:04 UTC (rev 131)
+++ poilu/trunk/dico.txt	2005-09-09 02:02:16 UTC (rev 132)
@@ -65,7 +65,8 @@
 cakos
 blaireaux
 chalumeau
-dinosaures
+orteils
+oreilles
 cul
 dahu
 poilu
@@ -76,5 +77,4 @@
 toutou
 minou
 roudoudou
-orteils
-oreilles
+dinosaures

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-09 01:49:04 UTC (rev 131)
+++ poilu/trunk/pypoil.py	2005-09-09 02:02:16 UTC (rev 132)
@@ -31,7 +31,7 @@
         self.utf8_chan = utf8_channel
         self.dico = dico_poilu(self)
         self.motcle = motcle_poilu()
-        self.taux_reponse = 20
+        self.taux_reponse = 100
         self.welcome = u"Salut"
 
     def on_nicknameinuse(self, c, e):
@@ -64,6 +64,7 @@
         self.echou(u"- recharge_insult      : recharge insulte.txt")
         self.echou(u"- recharge_motcle      : recharge motcle_regex.txt")
         self.echou(u"- join #chan / leave #chan : joint/quitte le canal #<chan>")
+        self.echou(u"- nick xxx : change de surnom")
         self.echou(u"- backup               : sauve toutes les donn?es sur le disque dur")
         self.echou(u"- utf-8 / iso          : passe en UTF-8 / iso-8859-1")
         self.echou(u"- muet                 : liste des caract?res muets")
@@ -161,7 +162,7 @@
                 self.echou(u"Ajoute la rime %s" %(regs.group(1)))
             return True
             
-        regs = re.compile("^dit (#[^ ]+) (.+)$", re.IGNORECASE).search(cmd)
+        regs = re.compile("^dit ([^ ]+) (.+)$", re.IGNORECASE).search(cmd)
         if regs != None:
             self.send_privmsgu(regs.group(1), regs.group(2))
             return True
@@ -251,6 +252,11 @@
             self.connection.leave(self.channel)
             return True
              
+        regs = re.compile("^nick (.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            self.connection.nick(regs.group(1))
+            return True
+            
         regs = re.compile("^join (#.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
             self.channel = regs.group(1) 



From haypo at berlios.de  Fri Sep  9 04:41:00 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 9 Sep 2005 04:41:00 +0200
Subject: [Happyboom-svn] r133 - poilu/trunk
Message-ID: <200509090241.j892f0ch003683@sheep.berlios.de>

Author: haypo
Date: 2005-09-09 04:40:58 +0200 (Fri, 09 Sep 2005)
New Revision: 133

Modified:
   poilu/trunk/dico.txt
   poilu/trunk/dico_poilu.py
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
Log:
Tri alphab?\195?\169tique du dico ?\195?\160 la sauvegarde.


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-09 02:02:16 UTC (rev 132)
+++ poilu/trunk/dico.txt	2005-09-09 02:40:58 UTC (rev 133)
@@ -1,80 +1,83 @@
+abdominaux
 aisselles
-poules
+avant-bras
+babouin
+blaireaux
+bordelais
+bras
+cakos
+cale??on
+camembert
+chalumeau
+chapeau
+chaussettes
+chien
+citron
+coin
+comique
+cou
+croutes
+cr??pu
+cul
+c??lon
+dahu
+dents
+dessous de bras
+dinosaures
+divan
+docteur
 doigt
+fion
 foie
-noix
-petits pois
-dents
-sang
+front
+genou
 gland
-divan
-p??dants
-rapes
+gosier
+gros zizi
+jambon
+kiki
+loup
+lutins
 mains
-vagin
-seins
-lutins
-teigneux
-thorax
+marsouin
+menton
+meules
+minou
+mollet
+mouettes
 moustiques
-comique
-loup
 nez
+noix
 n??n??
-meules
+oreilles
+orteils
+pectoraux
+petits pois
+pieds
+pierres
+poignet
+poilu
 poing
-coin
-babouin
-marsouin
-pierre
-chien
-croutes
-pieds
-gosier
-docteur
+poireau
+porcelais
+poules
+poumon
 pubis
-poignet
-mollet
+p??dants
+rapes
+roudoudou
+sang
+seins
+sexe
 superettes
-baskets
-chaussettes
-bras
 tas de gras
+teigneux
+thorax
 tibia
-dessous de bras
-avant-bras
-citron
-fion
+touffes
+tout nu
+toutou
+trilili
 t??ton
-menton
-c??lon
-poumon
-front
-cale??on
-sexe
-kiki
+vagin
 zizi
-trilili
-gros zizi
-bordelais
-porcelais
-chapeau
-poireau
-pectoraux
-abdominaux
-cakos
-blaireaux
-chalumeau
-orteils
-oreilles
-cul
-dahu
-poilu
-tout nu
-cr??pu
-cou
-genou
-toutou
-minou
-roudoudou
-dinosaures

Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-09 02:02:16 UTC (rev 132)
+++ poilu/trunk/dico_poilu.py	2005-09-09 02:40:58 UTC (rev 133)
@@ -19,8 +19,7 @@
         self.charge_dico()
 
     def echo(self, message):
-        print message
-#        self.bot.echo(message)
+        self.bot.echo(message)
         
     def ajoute_terme(self, terme):
         cle = self.terminaison(terme)
@@ -37,7 +36,7 @@
         if fin==None: return None
         if not self.dico.has_key(fin): return None
         if not terme in self.dico[fin]: return None
-        self.echo ("Supprime le mot %s" %(terme))
+        self.echo("Supprime le mot %s" %(terme))
         self.dico[fin].remove(terme)
         return True
 
@@ -50,9 +49,13 @@
     def sauve(self):
         self.echo ("Sauve le dico.")
         f = file("dico.txt", "w")
+        dico = []
         for key in self.dico:
             for terme in self.dico[key]: 
-                f.write ("%s\n" %(terme.encode("utf-8")))
+                dico.append(terme)
+        dico.sort()
+        for item in dico:
+            f.write ("%s\n" %(item.encode("utf-8")))
         f.close()
 
     def charge_dico(self):

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-09 02:02:16 UTC (rev 132)
+++ poilu/trunk/pypoil.py	2005-09-09 02:40:58 UTC (rev 133)
@@ -55,20 +55,21 @@
 
     def aide(self):
         self.echou(u"Commandes :")
-        self.echou(u"- liste rimes <mot>    : liste des rimes pour la terminaison du mot sp?cifi?")
-        self.echou(u"- rime mot / derime mot : ajoute/supprime un mot du dictinnaire")
-        self.echou(u"- dit #chan (...)      : fait parler le bot")
-        self.echou(u"- recharge_muet        : recharge muet.txt")
-        self.echou(u"- recharge_terminaison : recharge terminaison.txt")
-        self.echou(u"- recharge_dico        : recharge dico.txt")
-        self.echou(u"- recharge_insult      : recharge insulte.txt")
-        self.echou(u"- recharge_motcle      : recharge motcle_regex.txt")
+        self.echou(u"- liste rimes <mot>        : liste des rimes pour la terminaison du mot sp?cifi?")
+        self.echou(u"- rime mot / derime mot    : ajoute/supprime un mot du dictinnaire")
+        self.echou(u"- terminaison mot          : affiche la terminaison du mot")
+        self.echou(u"- dit #chan ... / dit nick ... : fait parler le bot")
+        self.echou(u"- recharge_muet            : recharge muet.txt")
+        self.echou(u"- recharge_terminaison     : recharge terminaison.txt")
+        self.echou(u"- recharge_dico            : recharge dico.txt")
+        self.echou(u"- recharge_insult          : recharge insulte.txt")
+        self.echou(u"- recharge_motcle          : recharge motcle_regex.txt")
         self.echou(u"- join #chan / leave #chan : joint/quitte le canal #<chan>")
-        self.echou(u"- nick xxx : change de surnom")
-        self.echou(u"- backup               : sauve toutes les donn?es sur le disque dur")
-        self.echou(u"- utf-8 / iso          : passe en UTF-8 / iso-8859-1")
-        self.echou(u"- muet                 : liste des caract?res muets")
-        self.echou(u"- taux_reponse xxx     : fixe le taux de r?ponse (en pourcent)")
+        self.echou(u"- nick xxx                 : change de surnom")
+        self.echou(u"- backup                   : sauve toutes les donn?es sur le disque dur")
+        self.echou(u"- utf-8 / iso              : passe en UTF-8 / iso-8859-1")
+        self.echou(u"- muet                     : liste des caract?res muets")
+        self.echou(u"- taux_reponse xxx         : fixe le taux de r?ponse (en pourcent)")
 
 
     def on_privmsg(self, c, e):
@@ -257,6 +258,16 @@
             self.connection.nick(regs.group(1))
             return True
             
+        regs = re.compile("^terminaison (.*)$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            mot = regs.group(1) 
+            term = self.dico.terminaison(mot)
+            if term != None:
+                self.echou(u"Terminaison de %s : %s" % (mot, term))
+            else:
+                self.echou(u"Terminaison de %s : (aucune)" % mot)
+            return True
+            
         regs = re.compile("^join (#.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
             self.channel = regs.group(1) 

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-09 02:02:16 UTC (rev 132)
+++ poilu/trunk/terminaison.txt	2005-09-09 02:40:58 UTC (rev 133)
@@ -1,14 +1,14 @@
-ied:(ied[s]?|sier)$
-ier:ier(re)?s?$
-r:(er(re)?|??re)$
+ied:(ied[s]?|[ps]ier)$
+air:(ier(re)?s?|erre|??re|aire|ert)$
 or:(aur(es?)?|or[tes]?)$
-aite:(aite?|et(te)?s?|??tes?)$
+ai:(et|??)$
+aite:(aite?|ettes?|??tes?)$
 ouin:(oin[g]?|ouin)$
 oua:oi([exst]|gts?|ent)?$
 ien:ien[ts]?$
 a:(a[st]?|??)$
 ??:(??[ts]?|ai([ets]|ent)?|a??)$
-er:(??e?s?|ez|cd)$
+er:(??e?s?|ez|cd|er)$
 an:(en(s|ts?)?|an([dg]|ts?)?)$
 is:is$
 ou:(oo|ou[setx]?)$
@@ -32,3 +32,4 @@
 op:opp?(es?)?$
 ap:ap[p]?(es?)?$
 te:tes?$
+ouf:ouf(fe)?s?$



From haypo at berlios.de  Wed Sep  7 19:16:25 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 7 Sep 2005 19:16:25 +0200
Subject: [Happyboom-svn] r122 - / greystoration_gimp
Message-ID: <200509071716.j87HGPfa027561@sheep.berlios.de>

Author: haypo
Date: 2005-09-07 19:16:19 +0200 (Wed, 07 Sep 2005)
New Revision: 122

Added:
   greystoration_gimp/
   greystoration_gimp/CImg.h
   greystoration_gimp/ChangeLog
   greystoration_gimp/Makefile
   greystoration_gimp/dialog.cpp
   greystoration_gimp/dialog.h
   greystoration_gimp/greycstoration.cpp
   greystoration_gimp/greycstoration.h
   greystoration_gimp/image.cpp
   greystoration_gimp/image.h
   greystoration_gimp/main.cpp
   greystoration_gimp/plug_in.h
Log:
Add GREYCstoration gimp plugin.


Added: greystoration_gimp/CImg.h
===================================================================
--- greystoration_gimp/CImg.h	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/CImg.h	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,9655 @@
+/*------------------------------------------------------------------------------------------------------
+  
+  File        : CImg.h
+  
+  Description : The C++ Template Image Processing Library
+
+  Author      : David Tschumperl?
+   
+  This software is governed by the CeCILL  license under French law and
+  abiding by the rules of distribution of free software.  You can  use, 
+  modify and/ or redistribute the software under the terms of the CeCILL
+  license as circulated by CEA, CNRS and INRIA at the following URL
+  "http://www.cecill.info". 
+  
+  As a counterpart to the access to the source code and  rights to copy,
+  modify and redistribute granted by the license, users are provided only
+  with a limited warranty  and the software's author,  the holder of the
+  economic rights,  and the successive licensors  have only  limited
+  liability. 
+  
+  In this respect, the user's attention is drawn to the risks associated
+  with loading,  using,  modifying and/or developing or reproducing the
+  software by the user in light of its specific status of free software,
+  that may mean  that it is complicated to manipulate,  and  that  also
+  therefore means  that it is reserved for developers  and  experienced
+  professionals having in-depth computer knowledge. Users are therefore
+  encouraged to load and test the software's suitability as regards their
+  requirements in conditions enabling the security of their systems and/or 
+  data to be ensured and,  more generally, to use and operate it in the 
+  same conditions as regards security. 
+  
+  The fact that you are presently reading this means that you have had
+  knowledge of the CeCILL license and that you accept its terms.
+  
+  ----------------------------------------------------------------------------------------------------*/
+
+#ifndef cimg_version
+#define cimg_version 1.08
+#include <cstdio>
+#include <cstdlib>
+#include <cstdarg>
+#include <cmath>
+#include <cstring>
+#include <ctime>
+
+// Overcome VisualC++ 6.0 and DMC compilers namespace 'std::' bug
+#if ( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__)
+#define std
+#endif
+
+/*-------------------------------------------------------------
+  
+
+  Auto-detect and set CImg Library configuration flags.
+  
+  
+  If compilation flags are not adapted to your system,
+  you may override their values, before including
+  the header file "CImg.h" (use the #define directive).
+  
+  -------------------------------------------------------------*/
+
+#ifndef cimg_OS
+#if defined(sun) || defined(__sun)        
+// Sun/Solaris configuration
+#define cimg_OS            0
+#ifndef cimg_display_type
+#define cimg_display_type  1
+#endif
+#ifndef cimg_color_terminal
+#define cimg_color_terminal
+#endif
+#elif defined(linux) || defined(__linux) || defined(__CYGWIN__)
+// PC Linux configuration
+#define cimg_OS            1
+#ifndef cimg_display_type
+#define cimg_display_type  1
+#endif
+#ifndef cimg_color_terminal
+#define cimg_color_terminal
+#endif
+#elif defined(_WIN32) || defined(__WIN32__)
+// PC Windows configuration
+#define cimg_OS            2
+#ifndef cimg_display_type
+#define cimg_display_type  2
+#endif
+#elif defined(__MACOSX__) || defined(__APPLE__)
+// Mac OS X configuration
+#define cimg_OS            3
+#ifndef cimg_display_type
+#define cimg_display_type  1
+#endif
+#elif defined(__FreeBSD__)
+// FreeBSD configuration
+#define cimg_OS            4
+#ifndef cimg_display_type
+#define cimg_display_type  1
+#endif
+#ifndef cimg_color_terminal
+#define cimg_color_terminal
+#endif
+#else
+// Unknown configuration : minimal dependencies.
+#define cimg_OS           -1
+#ifndef cimg_display_type
+#define cimg_display_type  0
+#endif
+#endif
+#endif
+
+// Debug configuration.
+//--------------------
+// Define 'cimg_debug' to : 0 to remove dynamic debug messages (exceptions are still thrown)
+//                          1 to display dynamic debug messages (default behavior).
+//                          2 to add extra memory access controls (may slow down the code)
+#ifndef cimg_debug
+#define cimg_debug         1
+#endif
+
+// Architecture-dependent includes
+//---------------------------------
+#if cimg_OS!=2
+#include <sys/time.h>
+#include <unistd.h>
+#else
+#include <windows.h>
+// Discard annoying macro definitions in windows.h
+#ifdef min
+#undef min
+#undef max
+#undef abs
+#endif
+#endif
+#if cimg_display_type==1
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+#include <pthread.h>
+#endif
+
+/*-----------------------------------------------------------------------------------
+  
+
+
+   Define some macros. Macros of the CImg Library are prefixed by 'cimg_'
+   Documented macros below may be safely used in your own code.
+   
+   
+   ---------------------------------------------------------------------------------*/
+
+// Macros used to describe the program usage, and retrieve command line arguments
+// (See corresponding module 'Retrieving command line arguments' in the generated documentation).
+#define cimg_usage(usage) cimg_library::cimg::option((char*)NULL,(unsigned int)argc,(char**)argv,(char*)NULL,(char*)usage)
+#define cimg_option(name,defaut,usage) cimg_library::cimg::option((char*)name,(unsigned int)argc,(char**)argv,defaut,(char*)usage)
+
+// Macros used for dynamic debug messages. Shouldn't be used in your own source code.
+#define cimg_test(x,func)						\
+  if(!(x).width || !(x).height || !(x).depth || !(x).dim || !(x).data)	\
+    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is empty", \
+                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
+#define cimgl_test(x,func) \
+  if(!(x).size || !(x).data) \
+    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImgl<%s> %s = (%d,%p) is empty", \
+                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).size,(x).data)
+#define cimg_test_scalar(x,func) \
+  if(!(x).width || !(x).height || !(x).depth || (x).dim!=1 || !(x).data) \
+    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not scalar", \
+                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
+#define cimg_test_matrix(x,func) \
+  if(!(x).width || !(x).height || (x).depth!=1 || (x).dim!=1 || !(x).data) \
+    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not a matrix", \
+                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
+#define cimg_test_square(x,func) \
+  if(!(x).width || !(x).height || (x).depth!=1 || (x).dim!=1 || (x).width!=(x).height || !(x).data) \
+    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not a square matrix", \
+                                func,__FILE__,__LINE__,(x).pixel_type,#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
+#define cimg_test_display(x,func) \
+  if (!(x).width || !(x).height) \
+    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', l.%d), CImgDisplay %s = (%d,%d) is not a valid display", \
+                                func,__FILE__,__LINE__,#x,(x).width,(x).height)
+  
+// Macros used for neighborhood definitions and manipulations (see module 'Using Image Loops' in the generated documentation).
+#define CImg_2x2(I,T)     T I##cc,I##nc=0,I##cn,I##nn=0
+#define CImg_3x3(I,T)     T I##pp,I##cp,I##np=0,I##pc,I##cc,I##nc=0,I##pn,I##cn,I##nn=0
+#define CImg_4x4(I,T)     T I##pp,I##cp,I##np=0,I##ap=0, \
+                            I##pc,I##cc,I##nc=0,I##ac=0, \
+                            I##pn,I##cn,I##nn=0,I##an=0, \
+                            I##pa,I##ca,I##na=0,I##aa=0
+#define CImg_5x5(I,T)     T I##bb,I##pb,I##cb,I##nb=0,I##ab=0, \
+                            I##bp,I##pp,I##cp,I##np=0,I##ap=0, \
+                            I##bc,I##pc,I##cc,I##nc=0,I##ac=0, \
+                            I##bn,I##pn,I##cn,I##nn=0,I##an=0, \
+                            I##ba,I##pa,I##ca,I##na=0,I##aa=0
+#define CImg_2x2x2(I,T)   T I##ccc,I##ncc=0,I##cnc,I##nnc=0, \
+                            I##ccn,I##ncn=0,I##cnn,I##nnn=0
+#define CImg_3x3x3(I,T)   T I##ppp,I##cpp,I##npp=0,I##pcp,I##ccp,I##ncp=0,I##pnp,I##cnp,I##nnp=0, \
+                            I##ppc,I##cpc,I##npc=0,I##pcc,I##ccc,I##ncc=0,I##pnc,I##cnc,I##nnc=0, \
+                            I##ppn,I##cpn,I##npn=0,I##pcn,I##ccn,I##ncn=0,I##pnn,I##cnn,I##nnn=0
+
+#define CImg_2x2_ref(I,T,tab)   T &I##cc=(tab)[0],&I##nc=(tab)[1],&I##cn=(tab)[2],&I##nn=(tab)[3];
+#define CImg_3x3_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2], \
+                                  &I##pc=(tab)[3],&I##cc=(tab)[4],&I##nc=(tab)[5], \
+                                  &I##pn=(tab)[6],&I##cn=(tab)[7],&I##nn=(tab)[8]
+#define CImg_4x4_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2],&I##ap=(tab)[3], \
+                                  &I##pc=(tab)[4],&I##cc=(tab)[5],&I##nc=(tab)[6],&I##ap=(tab)[7], \
+                                  &I##pn=(tab)[8],&I##cn=(tab)[9],&I##nn=(tab)[10],&I##aa=(tab)[11], \
+                                  &I##pa=(tab)[12],&I##ca=(tab)[13],&I##na=(tab)[14],&I##aa=(tab)[15]
+#define CImg_5x5_ref(I,T,tab)   T &I##bb=(tab)[0],&I##pb=(tab)[1],&I##cb=(tab)[2],&I##nb=(tab)[3],&I##ab=(tab)[4], \
+                                  &I##bp=(tab)[5],&I##pp=(tab)[6],&I##cp=(tab)[7],&I##np=(tab)[8],&I##ap=(tab)[9], \
+                                  &I##bc=(tab)[10],&I##pc=(tab)[11],&I##cc=(tab)[12],&I##nc=(tab)[13],&I##ac=(tab)[14], \
+                                  &I##bn=(tab)[15],&I##pn=(tab)[16],&I##cn=(tab)[17],&I##nn=(tab)[18],&I##an=(tab)[19], \
+                                  &I##ba=(tab)[20],&I##pa=(tab)[21],&I##ca=(tab)[22],&I##na=(tab)[23],&I##aa=(tab)[24]
+#define CImg_2x2x2_ref(I,T,tab) T &I##ccc=(tab)[0],&I##ncc=(tab)[1],&I##cnc=(tab)[2],&I##nnc=(tab)[3], \
+                                  &I##ccn=(tab)[4],&I##ncn=(tab)[5],&I##cnn=(tab)[6],&I##nnn=(tab)[7]
+#define CImg_3x3x3_ref(I,T,tab) T &I##ppp=(tab)[0],&I##cpp=(tab)[1],&I##npp=(tab)[2], \
+                                  &I##pcp=(tab)[3],&I##ccp=(tab)[4],&I##ncp=(tab)[5], \
+                                  &I##pnp=(tab)[6],&I##cnp=(tab)[7],&I##nnp=(tab)[8], \
+                                  &I##ppc=(tab)[9],&I##cpc=(tab)[10],&I##npc=(tab)[11], \
+                                  &I##pcc=(tab)[12],&I##ccc=(tab)[13],&I##ncc=(tab)[14], \
+                                  &I##pnc=(tab)[15],&I##cnc=(tab)[16],&I##nnc=(tab)[17], \
+                                  &I##ppn=(tab)[18],&I##cpn=(tab)[19],&I##npn=(tab)[20], \
+                                  &I##pcn=(tab)[21],&I##ccn=(tab)[22],&I##ncn=(tab)[23], \
+                                  &I##pnn=(tab)[24],&I##cnn=(tab)[25],&I##nnn=(tab)[26]
+
+#define cimg_squaresum2x2(I) ( I##cc*I##cc + I##nc*I##nc + I##cn*I##cn + I##nn*I##nn )
+#define cimg_squaresum3x3(I) ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + \
+                               I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + \
+                               I##pn*I##pn + I##cn*I##cn + I##nn*I##nn )
+#define cimg_squaresum4x4(I) ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
+                               I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
+                               I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
+                               I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
+#define cimg_squaresum5x5(I) ( I##bb*I##bb + I##pb*I##pb + I##cb*I##cb + I##nb*I##nb + I##ab*I##ab + \
+                               I##bp*I##bp + I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
+                               I##bc*I##bc + I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
+                               I##bn*I##bn + I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
+                               I##ba*I##ba + I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
+#define cimg_squaresum2x2x2(I) ( I##ccc*I##ccc + I##ncc*I##ncc + I##cnc*I##cnc + I##nnc*I##nnc + \
+                                 I##ccn*I##ccn + I##ncn*I##ncn + I##cnn*I##cnn + I##nnn*I##nnn )
+#define cimg_squaresum3x3x3(I) ( I##ppp*I##ppp + I##cpp*I##cpp + I##npp*I##npp + \
+                                 I##pcp*I##pcp + I##ccp*I##ccp + I##ncp*I##ncp + \
+                                 I##pnp*I##pnp + I##cnp*I##cnp + I##nnp*I##nnp + \
+                                 I##ppc*I##ppc + I##cpc*I##cpc + I##npc*I##npc + \
+                                 I##pcc*I##pcc + I##ccc*I##ccc + I##ncc*I##ncc + \
+                                 I##pnc*I##pnc + I##cnc*I##cnc + I##nnc*I##nnc + \
+                                 I##ppn*I##ppn + I##cpn*I##cpn + I##npn*I##npn + \
+                                 I##pcn*I##pcn + I##ccn*I##ccn + I##ncn*I##ncn + \
+                                 I##pnn*I##pnn + I##cnn*I##cnn + I##nnn*I##nnn )
+
+#define cimg_corr2x2(I,m) ( I##cc*(m)(0,0)+I##nc*(m)(1,0)+I##cn*(m)(0,1)+I##nn*(m)(1,1) )
+#define cimg_corr3x3(I,m) ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0) + \
+                            I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1) + \
+                            I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2) )
+#define cimg_corr4x4(I,m) ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0)+I##ap*(m)(3,0) + \
+                            I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1)+I##ac*(m)(3,1) + \
+                            I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2)+I##an*(m)(3,2) + \
+                            I##pa*(m)(0,3)+I##ca*(m)(1,3)+I##na*(m)(2,3)+I##aa*(m)(3,3) )
+#define cimg_corr5x5(I,m) ( I##bb*(m)(0,0)+I##pb*(m)(1,0)+I##cb*(m)(2,0)+I##nb*(m)(3,0)+I##ab*(m)(4,0) + \
+                            I##bp*(m)(0,1)+I##pp*(m)(1,1)+I##cp*(m)(2,1)+I##np*(m)(3,1)+I##ap*(m)(4,1) + \
+                            I##bc*(m)(0,2)+I##pc*(m)(1,2)+I##cc*(m)(2,2)+I##nc*(m)(3,2)+I##ac*(m)(4,2) + \
+                            I##bn*(m)(0,3)+I##pn*(m)(1,3)+I##cn*(m)(2,3)+I##nn*(m)(3,3)+I##an*(m)(4,3) + \
+                            I##ba*(m)(0,4)+I##pa*(m)(1,4)+I##ca*(m)(2,4)+I##na*(m)(3,4)+I##aa*(m)(4,4) )
+#define cimg_corr2x2x2(I,m) ( I##ccc*(m)(0,0,0)+I##ncc*(m)(1,0,0)+I##cnc*(m)(0,1,0)+I##nnc*(m)(1,1,0) + \
+                              I##ccn*(m)(0,0,1)+I##ncn*(m)(1,0,1)+I##cnn*(m)(0,1,1)+I##nnn*(m)(1,1,1) )
+#define cimg_corr3x3x3(I,m) ( I##ppp*(m)(0,0,0)+I##cpp*(m)(1,0,0)+I##npp*(m)(2,0,0) + \
+                              I##pcp*(m)(0,1,0)+I##ccp*(m)(1,1,0)+I##ncp*(m)(2,1,0) + \
+                              I##pnp*(m)(0,2,0)+I##cnp*(m)(1,2,0)+I##nnp*(m)(2,2,0) + \
+                              I##ppc*(m)(0,0,1)+I##cpc*(m)(1,0,1)+I##npc*(m)(2,0,1) + \
+                              I##pcc*(m)(0,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(2,1,1) + \
+                              I##pnc*(m)(0,2,1)+I##cnc*(m)(1,2,1)+I##nnc*(m)(2,2,1) + \
+                              I##ppn*(m)(0,0,2)+I##cpn*(m)(1,0,2)+I##npn*(m)(2,0,2) + \
+                              I##pcn*(m)(0,1,2)+I##ccn*(m)(1,1,2)+I##ncn*(m)(2,1,2) + \
+                              I##pnn*(m)(0,2,2)+I##cnn*(m)(1,2,2)+I##nnn*(m)(2,2,2) )
+
+#define cimg_conv2x2(I,m) ( I##cc*(m)(1,1)+I##nc*(m)(0,1)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
+#define cimg_conv3x3(I,m) ( I##pp*(m)(2,2)+I##cp*(m)(1,2)+I##np*(m)(0,2) + \
+                            I##pc*(m)(2,1)+I##cc*(m)(1,1)+I##nc*(m)(0,1) + \
+                            I##pn*(m)(2,0)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
+#define cimg_conv4x4(I,m) ( I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
+                            I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
+                            I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
+                            I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
+#define cimg_conv5x5(I,m) ( I##bb*(m)(4,4)+I##pb*(m)(3,4)+I##cb*(m)(2,4)+I##nb*(m)(1,4)+I##ab*(m)(0,4) + \
+                            I##bp*(m)(4,3)+I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
+                            I##bc*(m)(4,2)+I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
+                            I##bn*(m)(4,1)+I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
+                            I##ba*(m)(4,0)+I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
+#define cimg_conv2x2x2(I,m) ( I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
+                              I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
+#define cimg_conv3x3x3(I,m) ( I##ppp*(m)(2,2,2)+I##cpp*(m)(1,2,2)+I##npp*(m)(0,2,2) + \
+                              I##pcp*(m)(2,1,2)+I##ccp*(m)(1,1,2)+I##ncp*(m)(0,1,2) + \
+                              I##pnp*(m)(2,0,2)+I##cnp*(m)(1,0,2)+I##nnp*(m)(0,0,2) + \
+                              I##ppc*(m)(2,2,1)+I##cpc*(m)(1,2,1)+I##npc*(m)(0,2,1) + \
+                              I##pcc*(m)(2,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1) + \
+                              I##pnc*(m)(2,0,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
+                              I##ppn*(m)(2,2,0)+I##cpn*(m)(1,2,0)+I##npn*(m)(0,2,0) + \
+                              I##pcn*(m)(2,1,0)+I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0) + \
+                              I##pnn*(m)(2,0,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
+
+#define cimg_get2x2(img,x,y,z,v,I) I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
+    I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
+#define cimg_get3x3(img,x,y,z,v,I) I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), \
+    I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
+    I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
+#define cimg_get4x4(img,x,y,z,v,I)                                      \
+  I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
+    I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
+    I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
+    I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
+#define cimg_get5x5(img,x,y,z,v,I)                                      \
+  I##bb=(img)(_b##x,_b##y,z,v), I##pb=(img)(_p##x,_b##y,z,v), I##cb=(img)(x,_b##y,z,v), I##nb=(img)(_n##x,_b##y,z,v), I##ab=(img)(_a##x,_b##y,z,v), \
+    I##bp=(img)(_b##x,_p##y,z,v), I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
+    I##bc=(img)(_b##x,    y,z,v), I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
+    I##bn=(img)(_b##x,_n##y,z,v), I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
+    I##ba=(img)(_b##x,_a##y,z,v), I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
+#define cimg_get2x2x2(img,x,y,z,v,I)                                    \
+  I##ccc=(img)(x,y,    z,v), I##ncc=(img)(_n##x,y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
+    I##ccc=(img)(x,y,_n##z,v), I##ncc=(img)(_n##x,y,_n##z,v), I##cnc=(img)(x,_n##y,_n##z,v), I##nnc=(img)(_n##x,_n##y,_n##z,v)
+#define cimg_get3x3x3(img,x,y,z,v,I)                                    \
+  I##ppp=(img)(_p##x,_p##y,_p##z,v), I##cpp=(img)(x,_p##y,_p##z,v), I##npp=(img)(_n##x,_p##y,_p##z,v), \
+    I##pcp=(img)(_p##x,    y,_p##z,v), I##ccp=(img)(x,    y,_p##z,v), I##ncp=(img)(_n##x,    y,_p##z,v), \
+    I##pnp=(img)(_p##x,_n##y,_p##z,v), I##cnp=(img)(x,_n##y,_p##z,v), I##nnp=(img)(_n##x,_n##y,_p##z,v), \
+    I##ppc=(img)(_p##x,_p##y,    z,v), I##cpc=(img)(x,_p##y,    z,v), I##npc=(img)(_n##x,_p##y,    z,v), \
+    I##pcc=(img)(_p##x,    y,    z,v), I##ccc=(img)(x,    y,    z,v), I##ncc=(img)(_n##x,    y,    z,v), \
+    I##pnc=(img)(_p##x,_n##y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
+    I##ppn=(img)(_p##x,_p##y,_n##z,v), I##cpn=(img)(x,_p##y,_n##z,v), I##npn=(img)(_n##x,_p##y,_n##z,v), \
+    I##pcn=(img)(_p##x,    y,_n##z,v), I##ccn=(img)(x,    y,_n##z,v), I##ncn=(img)(_n##x,    y,_n##z,v), \
+    I##pnn=(img)(_p##x,_n##y,_n##z,v), I##cnn=(img)(x,_n##y,_n##z,v), I##nnn=(img)(_n##x,_n##y,_n##z,v)
+
+#define cimg_3x3to5x5(I,u) u##bb=I##pp,u##cb=I##cp,u##ab=I##np,u##bc=I##pc,u##cc=I##cc,u##ac=I##nc,u##ba=I##pn,u##ca=I##cn,u##aa=I##nn, \
+    u##pb=0.5*(u##bb+u##cb),u##nb=0.5*(u##cb+u##ab),u##pc=0.5*(u##bc+u##cc),u##nc=0.5*(u##cc+u##ac),u##pa=0.5*(u##ba+u##ca),u##na=0.5*(u##ca+u##aa), \
+    u##bp=0.5*(u##bb+u##bc),u##bn=0.5*(u##bc+u##ba),u##cp=0.5*(u##cb+u##cc),u##cn=0.5*(u##cc+u##ca),u##ap=0.5*(u##ab+u##ac),u##an=0.5*(u##ac+u##aa), \
+    u##pp=0.5*(u##bp+u##cp),u##np=0.5*(u##cp+u##ap),u##pn=0.5*(u##bn+u##cn),u##nn=0.5*(u##cn+u##an)
+
+// Macros used to define special image loops (see module 'Using Image Loops' in the generated documentation).
+#define cimg_map(img,ptr,T_ptr)   for (T_ptr *ptr=(img).data+(img).size()-1; ptr>=(img).data; ptr--)
+#define cimgl_map(list,l)         for (unsigned int l=0; l<(list).size; l++)
+#define cimg_mapoff(img,off)      for (unsigned int off=0; off<(img).size(); off++)
+#define cimg_mapX(img,x)          for (int x=0; x<(int)((img).width); x++)
+#define cimg_mapY(img,y)          for (int y=0; y<(int)((img).height);y++)
+#define cimg_mapZ(img,z)          for (int z=0; z<(int)((img).depth); z++)
+#define cimg_mapV(img,v)          for (int v=0; v<(int)((img).dim);   v++)
+#define cimg_mapXY(img,x,y)       cimg_mapY(img,y) cimg_mapX(img,x)
+#define cimg_mapXZ(img,x,z)       cimg_mapZ(img,z) cimg_mapX(img,x)
+#define cimg_mapYZ(img,y,z)       cimg_mapZ(img,z) cimg_mapY(img,y)
+#define cimg_mapXV(img,x,v)       cimg_mapV(img,v) cimg_mapX(img,x)
+#define cimg_mapYV(img,y,v)       cimg_mapV(img,v) cimg_mapY(img,y)
+#define cimg_mapZV(img,z,v)       cimg_mapV(img,v) cimg_mapZ(img,z)
+#define cimg_mapXYZ(img,x,y,z)    cimg_mapZ(img,z) cimg_mapXY(img,x,y)
+#define cimg_mapXYV(img,x,y,v)    cimg_mapV(img,v) cimg_mapXY(img,x,y)
+#define cimg_mapXZV(img,x,z,v)    cimg_mapV(img,v) cimg_mapXZ(img,x,z)
+#define cimg_mapYZV(img,y,z,v)    cimg_mapV(img,v) cimg_mapYZ(img,y,z)
+#define cimg_mapXYZV(img,x,y,z,v) cimg_mapV(img,v) cimg_mapXYZ(img,x,y,z)
+#define cimg_imapX(img,x,n)       for (int x=n; x<(int)((img).width-n); x++)
+#define cimg_imapY(img,y,n)       for (int y=n; y<(int)((img).height-n); y++)
+#define cimg_imapZ(img,z,n)       for (int z=n; z<(int)((img).depth-n); z++)
+#define cimg_imapV(img,v,n)       for (int v=n; v<(int)((img).dim-n); v++)
+#define cimg_imapXY(img,x,y,n)    cimg_imapY(img,y,n) cimg_imapX(img,x,n)
+#define cimg_imapXYZ(img,x,y,z,n) cimg_imapZ(img,z,n) cimg_imapXY(img,x,y,n)
+#define cimg_bmapX(img,x,n)       for (int x=0; x<(int)((img).width);  x==(n)-1?(x=(img).width-(n)): x++)
+#define cimg_bmapY(img,y,n)       for (int y=0; y<(int)((img).height); y==(n)-1?(x=(img).height-(n)):y++)
+#define cimg_bmapZ(img,z,n)       for (int z=0; z<(int)((img).depth);  z==(n)-1?(x=(img).depth-(n)): z++)
+#define cimg_bmapV(img,v,n)       for (int v=0; v<(int)((img).dim);    v==(n)-1?(x=(img).dim-(n)):   v++)
+#define cimg_bmapXY(img,x,y,n)    cimg_mapY(img,y) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n))?x++: \
+                                                          ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
+#define cimg_bmapXYZ(img,x,y,z,n) cimg_mapYZ(img,y,z) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n) || z<(n) || z>=(int)((img).depth)-(n))?x++: \
+                                                             ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
+#define cimg_2mapX(img,x)         for (int x=0,_n##x=1; _n##x<(int)((img).width)   || x==--_n##x; x++, _n##x++)
+#define cimg_2mapY(img,y)         for (int y=0,_n##y=1; _n##y<(int)((img).height)  || y==--_n##y; y++, _n##y++)
+#define cimg_2mapZ(img,z)         for (int z=0,_n##z=1; _n##z<(int)((img).depth)   || z==--_n##z; z++, _n##z++)
+#define cimg_2mapXY(img,x,y)      cimg_2mapY(img,y) cimg_2mapX(img,x)
+#define cimg_2mapXZ(img,x,z)      cimg_2mapZ(img,z) cimg_2mapX(img,x)
+#define cimg_2mapYZ(img,y,z)      cimg_2mapZ(img,z) cimg_2mapY(img,y)
+#define cimg_2mapXYZ(img,x,y,z)   cimg_2mapZ(img,z) cimg_2mapXY(img,x,y)
+#define cimg_3mapX(img,x)         for (int x=0,_p##x=0,_n##x=1; _n##x<(int)((img).width)  || x==--_n##x;  _p##x=x++,_n##x++)
+#define cimg_3mapY(img,y)         for (int y=0,_p##y=0,_n##y=1; _n##y<(int)((img).height) || y==--_n##y;  _p##y=y++,_n##y++)
+#define cimg_3mapZ(img,z)         for (int z=0,_p##z=0,_n##z=1; _n##z<(int)((img).depth)  || z==--_n##z;  _p##z=z++,_n##z++)
+#define cimg_3mapXY(img,x,y)      cimg_3mapY(img,y) cimg_3mapX(img,x)
+#define cimg_3mapXZ(img,x,z)      cimg_3mapZ(img,z) cimg_3mapX(img,x)
+#define cimg_3mapYZ(img,y,z)      cimg_3mapZ(img,z) cimg_3mapY(img,y)
+#define cimg_3mapXYZ(img,x,y,z)   cimg_3mapZ(img,z) cimg_3mapXY(img,x,y)
+#define cimg_4mapX(img,x)         for (int _p##x=0,x=0,_n##x=1,_a##x=2; \
+                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
+                                       _p##x=x++,_n##x++,_a##x++)
+#define cimg_4mapY(img,y)         for (int _p##y=0,y=0,_n##y=1,_a##y=2; \
+                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
+                                       _p##y=y++,_n##y++,_a##y++)
+#define cimg_4mapZ(img,z)         for (int _p##z=0,z=0,_n##z=1,_a##z=2; \
+                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
+                                       _p##z=z++,_n##z++,_a##z++)
+#define cimg_4mapXY(img,x,y)      cimg_4mapY(img,y) cimg_4mapX(img,x)
+#define cimg_4mapXZ(img,x,z)      cimg_4mapZ(img,z) cimg_4mapX(img,x)
+#define cimg_4mapYZ(img,y,z)      cimg_4mapZ(img,z) cimg_4mapY(img,y)
+#define cimg_4mapXYZ(img,x,y,z)   cimg_4mapZ(img,z) cimg_4mapXY(img,x,y)
+#define cimg_5mapX(img,x)         for (int _b##x=0,_p##x=0,x=0,_n##x=1,_a##x=2; \
+                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
+                                       _b##x=_p##x,_p##x=x++,_n##x++,_a##x++)
+#define cimg_5mapY(img,y)         for (int _b##y=0,_p##y=0,y=0,_n##y=1,_a##y=2; \
+                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
+                                       _b##y=_p##y,_p##y=y++,_n##y++,_a##y++)
+#define cimg_5mapZ(img,z)         for (int _b##z=0,_p##z=0,z=0,_n##z=1,_a##z=2; \
+                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
+                                       _b##z=_p##z,_p##z=z++,_n##z++,_a##z++)
+#define cimg_5mapXY(img,x,y)      cimg_5mapY(img,y) cimg_5mapX(img,x)
+#define cimg_5mapXZ(img,x,z)      cimg_5mapZ(img,z) cimg_5mapX(img,x)
+#define cimg_5mapYZ(img,y,z)      cimg_5mapZ(img,z) cimg_5mapY(img,y)
+#define cimg_5mapXYZ(img,x,y,z)   cimg_5mapZ(img,z) cimg_5mapXY(img,x,y)
+
+#define cimg_map2x2(img,x,y,z,v,I) cimg_2mapY(img,y)                    \
+       for (int _n##x=1, x=((int)(I##cc=(img)(0,  y,z,v),               \
+                                  I##cn=(img)(0,_n##y,z,v)),0);         \
+            (_n##x<(int)((img).width) && (                              \
+                                          I##nc=(img)(_n##x,    y,z,v), \
+                                          I##nn=(img)(_n##x,_n##y,z,v), \
+                                          1)) || x==--_n##x;            \
+            I##cc=I##nc, I##cn=I##nn,                                   \
+              x++,_n##x++ )
+
+#define cimg_map3x3(img,x,y,z,v,I) cimg_3mapY(img,y)                    \
+       for (int _n##x=1, _p##x=(int)(I##cp=I##pp=(img)(0,_p##y,z,v),    \
+                                     I##cc=I##pc=(img)(0,  y,z,v),      \
+                                     I##cn=I##pn=(img)(0,_n##y,z,v)     \
+                                     ), x=_p##x=0;                      \
+            (_n##x<(int)((img).width) && (                              \
+                                          I##np=(img)(_n##x,_p##y,z,v), \
+                                          I##nc=(img)(_n##x,    y,z,v), \
+                                          I##nn=(img)(_n##x,_n##y,z,v), \
+                                          1)) || x==--_n##x;            \
+            I##pp=I##cp, I##pc=I##cc, I##pn=I##cn,                      \
+              I##cp=I##np, I##cc=I##nc, I##cn=I##nn,                    \
+              _p##x=x++,_n##x++ )
+
+#define cimg_map4x4(img,x,y,z,v,I) cimg_4mapY(img,y)                    \
+       for (int _a##x=2, _n##x=1, x=((int)(I##cp=I##pp=(img)(0,_p##y,z,v), \
+                                           I##cc=I##pc=(img)(0,    y,z,v), \
+                                           I##cn=I##pn=(img)(0,_n##y,z,v), \
+                                           I##ca=I##pa=(img)(0,_a##y,z,v), \
+                                           I##np=(img)(_n##x,_p##y,z,v), \
+                                           I##nc=(img)(_n##x,    y,z,v), \
+                                           I##nn=(img)(_n##x,_n##y,z,v), \
+                                           I##na=(img)(_n##x,_a##y,z,v)),0), \
+              _p##x=0;                                                  \
+            (_a##x<(int)((img).width) && (                              \
+                                          I##ap=(img)(_a##x,_p##y,z,v), \
+                                          I##ac=(img)(_a##x,    y,z,v), \
+                                          I##an=(img)(_a##x,_n##y,z,v), \
+                                          I##aa=(img)(_a##x,_a##y,z,v), \
+                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
+            I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca,         \
+              I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na,       \
+              I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa,       \
+              _p##x=x++, _n##x++, _a##x++ )
+
+#define cimg_map5x5(img,x,y,z,v,I) cimg_5mapY(img,y)                    \
+       for (int _a##x=2, _n##x=1, _b##x=(int)(I##cb=I##pb=I##bb=(img)(0,_b##y,z,v), \
+                                              I##cp=I##pp=I##bp=(img)(0,_p##y,z,v), \
+                                              I##cc=I##pc=I##bc=(img)(0,    y,z,v), \
+                                              I##cn=I##pn=I##bn=(img)(0,_n##y,z,v), \
+                                              I##ca=I##pa=I##ba=(img)(0,_a##y,z,v), \
+                                              I##nb=(img)(_n##x,_b##y,z,v), \
+                                              I##np=(img)(_n##x,_p##y,z,v), \
+                                              I##nc=(img)(_n##x,   y,z,v), \
+                                              I##nn=(img)(_n##x,_n##y,z,v), \
+                                              I##na=(img)(_n##x,_a##y,z,v)), \
+              x=0, _p##x=_b##x=0;                                       \
+            (_a##x<(int)((img).width) && (                              \
+                                          I##ab=(img)(_a##x,_b##y,z,v), \
+                                          I##ap=(img)(_a##x,_p##y,z,v), \
+                                          I##ac=(img)(_a##x,    y,z,v), \
+                                          I##an=(img)(_a##x,_n##y,z,v), \
+                                          I##aa=(img)(_a##x,_a##y,z,v), \
+                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
+            I##bb=I##pb, I##bp=I##pp, I##bc=I##pc, I##bn=I##pn, I##ba=I##pa, \
+              I##pb=I##cb, I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca, \
+              I##cb=I##nb, I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na, \
+              I##nb=I##ab, I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa, \
+              _b##x=_p##x, _p##x=x++, _n##x++, _a##x++ )
+
+#define cimg_map2x2x2(img,x,y,z,v,I) cimg_2mapYZ(img,y,z)               \
+       for (int _n##x=1, x=((int)(I##ccc=(img)(0,    y,    z,v),        \
+                                  I##cnc=(img)(0,_n##y,    z,v),        \
+                                  I##ccn=(img)(0,    y,_n##z,v),        \
+                                  I##cnn=(img)(0,_n##y,_n##z,v)),0);    \
+            (_n##x<(int)((img).width) && (                              \
+                                          I##ncc=(img)(_n##x,    y,    z,v), \
+                                          I##nnc=(img)(_n##x,_n##y,    z,v), \
+                                          I##ncn=(img)(_n##x,    y,_n##z,v), \
+                                          I##nnn=(img)(_n##x,_n##y,_n##z,v), \
+                                          1)) || x==--_n##x;            \
+            I##ccc=I##ncc, I##cnc=I##nnc,                               \
+              I##ccn=I##ncn, I##cnn=I##nnn,                             \
+              x++, _n##x++ )
+
+#define cimg_map3x3x3(img,x,y,z,v,I) cimg_3mapYZ(img,y,z)               \
+       for (int _n##x=1, _p##x=(int)(I##cpp=I##ppp=(img)(0,_p##y,_p##z,v), \
+                                     I##ccp=I##pcp=(img)(0,    y,_p##z,v), \
+                                     I##cnp=I##pnp=(img)(0,_n##y,_p##z,v), \
+                                     I##cpc=I##ppc=(img)(0,_p##y,    z,v), \
+                                     I##ccc=I##pcc=(img)(0,    y,    z,v), \
+                                     I##cnc=I##pnc=(img)(0,_n##y,    z,v), \
+                                     I##cpn=I##ppn=(img)(0,_p##y,_n##z,v), \
+                                     I##ccn=I##pcn=(img)(0,    y,_n##z,v), \
+                                     I##cnn=I##pnn=(img)(0,_n##y,_n##z,v)),\
+              x=_p##x=0;                                                \
+            (_n##x<(int)((img).width) && (                              \
+                                          I##npp=(img)(_n##x,_p##y,_p##z,v), \
+                                          I##ncp=(img)(_n##x,    y,_p##z,v), \
+                                          I##nnp=(img)(_n##x,_n##y,_p##z,v), \
+                                          I##npc=(img)(_n##x,_p##y,    z,v), \
+                                          I##ncc=(img)(_n##x,    y,    z,v), \
+                                          I##nnc=(img)(_n##x,_n##y,    z,v), \
+                                          I##npn=(img)(_n##x,_p##y,_n##z,v), \
+                                          I##ncn=(img)(_n##x,    y,_n##z,v), \
+                                          I##nnn=(img)(_n##x,_n##y,_n##z,v), \
+                                          1)) || x==--_n##x;            \
+            I##ppp=I##cpp, I##pcp=I##ccp, I##pnp=I##cnp,                \
+              I##cpp=I##npp, I##ccp=I##ncp, I##cnp=I##nnp,              \
+              I##ppc=I##cpc, I##pcc=I##ccc, I##pnc=I##cnc,              \
+              I##cpc=I##npc, I##ccc=I##ncc, I##cnc=I##nnc,              \
+              I##ppn=I##cpn, I##pcn=I##ccn, I##pnn=I##cnn,              \
+              I##cpn=I##npn, I##ccn=I##ncn, I##cnn=I##nnn,              \
+              _p##x=x++, _n##x++ )
+
+/*-------------------------------------------------
+  -------------------------------------------------
+  
+
+
+    Definition of the cimg_library:: namespace
+  
+ 
+  -------------------------------------------------
+  -------------------------------------------------*/
+
+//! The <tt>\ref cimg_library::</tt> namespace encompasses all classes and functions of the CImg library.
+/**
+   This namespace is defined to avoid class names collisions that could happen
+   with the include of other C++ header files. Anyway, it shouldn't happen
+   very often and you may start most of your programs with
+   \code
+   #include "CImg.h"
+   using namespace cimg_library;
+   \endcode
+   to simplify the declaration of CImg class variables afterward.
+**/
+namespace cimg_library {
+  struct CImgStats;
+  struct CImgDisplay;
+  struct CImgException;
+  template<typename T=float> struct CImg;
+  template<typename T=float> struct CImgl;
+  template<typename T=float> struct CImgROI;
+   
+  /*----------------------------------------------------
+    
+  
+  
+  Definition of the CImgException structures
+  
+  
+  
+  -------------------------------------------------*/
+  
+#if cimg_debug>=1
+#if cimg_display_type!=2
+#define cimg_exception_print(str) std::fprintf(stderr,"<CImg Error> %s",str);
+#else
+#define cimg_exception_print(str) MessageBox(NULL,(LPCTSTR)str,"<CImg Error>",MB_OK);
+#endif
+#else
+#define cimg_exception_print(str)
+#endif
+#define cimg_exception_err(etype)                                 \
+  char tmp[1024];                                                 \
+  va_list ap;                                                     \
+  va_start(ap,format);                                            \
+  std::vsprintf(message,format,ap);                               \
+  va_end(ap);                                                     \
+  std::sprintf(tmp,"==> %s \n\nGeneral : %s\n\n", message,etype); \
+  cimg_exception_print(tmp)
+  
+  //! The \ref CImgException class is used to throw general exceptions when an error occurs in a library call.
+  /** 
+      The \ref CImgException class is the base class of all CImg exceptions.
+      Exceptions are thrown by the CImg Library when an error occurs during the execution of a CImg function.
+      The CImgException is seldom thrown itself, children classes (that specify the type of error)
+      are generally used instead.
+      It may be thrown anyway for non-specialized exception types.
+
+      \see CImgInstanceException, CImgArgumentException, CImgIOException and CImgDisplayException.
+
+      By default, when an error occurs, the CImg Library displays an error message on the standart error output \e stderr
+      (on Unix), or opens a pop-up window displaying the error message (on Windows).
+      Then, it throws an instance of an exception class, generally leading the program to stop (this is the
+      default behavior of the C++ exception mechanism).
+      You can always bypass this behavior by handling the exceptions by yourself (using a code block <tt>try { ... } catch() { ... }</tt>).
+      Then, if you don't want the CImg Library to display error messages, you can define the environment variable
+      <tt>cimg_debug</tt> to 0 before including the header file <tt>CImg.h</tt> (see \ref cimg_environment).
+      
+      The <tt>CImgException</tt> class owns a member variable <tt>char* message</tt> that contains the exception message
+      describing precisely the error that occured.
+
+      The example above shows how to manually handle CImg Library errors properly :
+      \code
+      #define cimg_debug 0    // Disable error message display by CImg.
+      #define "CImg.h"
+      int main() {  
+        try {
+          ...; // Here, do what you want.
+        }
+        catch (CImgException &e) {
+          std::fprintf(stderr,"CImg Library Error : %s",e.message);  // Display error message
+          ...                                                        // Do what you want to save the ship !
+        }
+      }
+      \endcode      
+  **/
+  struct CImgException {
+    char message[1024]; //!< Error message
+    CImgException() { message[0]='\0'; }
+    CImgException(const char *format,...) {
+      cimg_exception_err("This error has been generated by a 'CImgException' throw,"
+			 "corresponding to a general exception problem."); 
+    }
+  };
+
+  //! The \ref CImgInstanceException class is used to throw an exception related
+  //! to a non suitable instance encountered in a library function call.  
+  /**
+     This class will be thrown when trying to call a class function from an
+     instance which is \e empty, or \e badly \e defined.
+     Typically, this exception occurs when using empty images :
+     \code
+     CImg<float> img; // define an empty image
+     img.blur(10);    // trying to blur an empty image will generate a CImgInstanceException.
+     \endcode
+     
+     \see CImgException, CImgArgumentException, CImgIOException and CImgDisplayException.
+  **/
+  struct CImgInstanceException : CImgException { 
+    CImgInstanceException(const char *format,...) {
+      cimg_exception_err("This error has been generated by a 'CImgInstanceException' throw.\n"
+			 "The instance passed through the function above has a bad structure"
+			 "(perhaps an empty image, list or display object ?)");
+    }};
+
+  //! The \ref CImgArgumentException class is used to throw an exception related
+  //! to invalid arguments encountered in a library function call.
+  /**
+     This class will be thrown when one passes one or several invalid arguments to
+     a library function. This may happen for instance in the following case :
+     \code
+     CImg<float> img(100,100); // define a 100x100 scalar image with float pixels
+     img.get_channel(1);       // trying to retrieve the vector channel v=1, will generate a CImgArgumentException.
+     \endcode
+     As the image <tt>img</tt> is scalar, it has only one vector channel (<tt>img.dim=1</tt>), and one cannot
+     retrieve the channel 1, (only the channel 0).
+     \see CImgException, CImgInstanceException, CImgIOException and CImgDisplayException.
+  **/
+  struct CImgArgumentException : CImgException { 
+    CImgArgumentException(const char *format,...) { 
+      cimg_exception_err("This error has been generated by a 'CImgArgumentException' throw.\n"
+			 "At least one argument passed to the function above has been considered as not valid.");
+    }};
+
+  //! The \ref CImgIOException class is used to throw an exception related 
+  //! to Input/Output file problems encountered in a library function call.
+  /**
+     This class will be thrown when one Input/Output problem has been encountered
+     during the execution of a library function. This may particularly happen when using <tt>load()</tt> and <tt>save()</tt>
+     functions, with invalid files :
+     \code
+     CImg<float> img("not_here.jpg");
+     \endcode
+     This code will throw a \c CImgIOException instance if the file <tt>not_here.jpg</tt> is not in the current directory.
+     \see CImgException, CImgInstanceException, CImgArgumentException and CImgDisplayException.
+  **/
+  struct CImgIOException : CImgException { 
+    CImgIOException(const char *format,...) {
+      cimg_exception_err("This error has been generated by a 'CImgIOException' throw.\n"
+			 "When trying to load or save a file, the function above has encountered a problem.");
+    }};
+
+  //! The CImgDisplayException class is used to throw an exception related to display problems
+  //! encountered in a library function call.
+  /**
+     This class will be thrown when a library function encounters a problem
+     when trying to open or close a display window. This shouldn't happen very much if your display is 
+     detected properly. This happens for instance when trying to open a display window on a 8bits screen
+     depth, under Unix/X11.
+
+     \see CImgException, CImgInstanceException, CImgArgumentException and CImgIOException.
+  **/
+  struct CImgDisplayException : CImgException {
+    CImgDisplayException(const char *format,...) {
+      cimg_exception_err("This error has been generated by a 'CImgDisplayException' throw.\n"
+			 "When trying to operate on a CImgDisplay instance, the function above encountered a problem."); 
+    }};
+  
+
+  /*-------------------------------------------------------------------------
+
+    Add LAPACK support to the library.
+  
+    Define the macro 'cimg_lapack' before including 'CImg.h' 
+    will activate the support of LAPACK. You'll have then to link
+    your code with the Lapack library to get it working.
+  
+    -----------------------------------------------------------------------*/
+#ifdef cimg_lapack
+  extern "C" {
+    extern void dgeev_(char*,char*, int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*);
+    extern void dsyev_(char*,char*,int*,double*,int*,double*,double*,int*,int*);
+    extern void dgetrf_(int*,int*,double*,int*,int*,int*);
+    extern void dgetri_(int*,double*,int*,int*,double*,int*,int*);
+  }
+#else
+  inline void cimg_nolapack() { 
+    throw CImgException("a LAPACK call : A LAPACK function has been required, but the LAPACK library"
+			"hasn't been linked.\nPlease define the compilation flag '#define cimg_lapack'"
+			"before including 'CImg.h' and link your code with LAPACK.");
+  }
+  inline void dgeev_ (char*,char*, int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*) { cimg_nolapack(); }
+  inline void dsyev_ (char*, char*, int*, double*, int*, double*, double*, int*, int*) { cimg_nolapack(); }
+  inline void dgetrf_(int*,int*,double*,int*,int*,int*) { cimg_nolapack(); }
+  inline void dgetri_(int*,double*,int*,int*,double*,int*,int*) { cimg_nolapack(); }
+#endif
+  
+
+  /*----------------------------------------
+    
+  
+  
+    Definition of the namespace 'cimg'
+  
+  
+  
+  --------------------------------------*/
+  
+  //! The <tt>\ref cimg::</tt> namespace encompasses \e low-level functions and variables of the CImg Library.
+  /**
+     Most of the functions and variables within this namespace are used by the library for low-level purposes.
+     Nevertheless, documented variables and functions below may be used by the user in its own source code.
+     \warning Never write <tt>"using namespace cimg_library::cimg;"</tt> in your source, since a lot of functions of the
+     \ref cimg:: namespace have the same name than standart C functions defined in the global namespace <tt>::</tt>.
+     
+     \see CImg, CImgl, CImgDisplay, CImgStats and CImgException.
+  **/
+  namespace cimg {
+
+    // Define internal library variables.
+    const unsigned int lblock=1024;
+#if cimg_display_type==1
+    static pthread_mutex_t*      X11_mutex = NULL;
+    static pthread_t*            X11_event_thread = NULL;
+    static CImgDisplay*          X11_wins[1024];
+    static Display*              X11_display = NULL;
+    static volatile unsigned int X11_nb_wins = 0;
+    static volatile bool         X11_thread_finished = false;
+    static unsigned int          X11_nb_bits = 0;
+    static GC*                   X11_gc = NULL;
+    static bool                  X11_colors_endian = false;
+#endif
+#ifdef cimg_color_terminal
+    const char t_normal[9]  = {0x1b,'[','0',';','0',';','0','m','\0'};
+    const char t_red[11]    = {0x1b,'[','4',';','3','1',';','5','9','m','\0'};
+    const char t_bold[5]    = {0x1b,'[','1','m','\0'};
+    const char t_purple[11] = {0x1b,'[','0',';','3','5',';','5','9','m','\0'};
+#else
+    const char t_normal[1]  = {'\0'};
+    static const char *t_red = t_normal, *t_bold = t_normal, *t_purple = t_normal;
+#endif
+    
+#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3
+    // Keycodes for X11-based graphical systems
+    const unsigned int keyESC        = XK_Escape;
+    const unsigned int keyF1         = XK_F1;
+    const unsigned int keyF2         = XK_F2;
+    const unsigned int keyF3         = XK_F3;
+    const unsigned int keyF4         = XK_F4;
+    const unsigned int keyF5         = XK_F5;
+    const unsigned int keyF6         = XK_F6;
+    const unsigned int keyF7         = XK_F7;
+    const unsigned int keyF8         = XK_F8;
+    const unsigned int keyF9         = XK_F9;
+    const unsigned int keyF10        = XK_F10;
+    const unsigned int keyF11        = XK_F11;
+    const unsigned int keyF12        = XK_F12;
+    const unsigned int keyPAUSE      = XK_Pause;
+    const unsigned int key1          = XK_1;
+    const unsigned int key2          = XK_2;
+    const unsigned int key3          = XK_3;
+    const unsigned int key4          = XK_4;
+    const unsigned int key5          = XK_5;
+    const unsigned int key6          = XK_6;
+    const unsigned int key7          = XK_7;
+    const unsigned int key8          = XK_8;
+    const unsigned int key9          = XK_9;
+    const unsigned int key0          = XK_0;
+    const unsigned int keyBACKSPACE  = XK_BackSpace;
+    const unsigned int keyINSERT     = XK_Insert;
+    const unsigned int keyHOME       = XK_Home;
+    const unsigned int keyPAGEUP     = XK_Page_Up;
+    const unsigned int keyTAB        = XK_Tab;
+    const unsigned int keyQ          = XK_q;
+    const unsigned int keyW          = XK_w;
+    const unsigned int keyE          = XK_e;
+    const unsigned int keyR          = XK_r;
+    const unsigned int keyT          = XK_t;
+    const unsigned int keyY          = XK_y;
+    const unsigned int keyU          = XK_u;
+    const unsigned int keyI          = XK_i;
+    const unsigned int keyO          = XK_o;
+    const unsigned int keyP          = XK_p;
+    const unsigned int keyDELETE     = XK_Delete;
+    const unsigned int keyEND        = XK_End;
+    const unsigned int keyPAGEDOWN   = XK_Page_Down;
+    const unsigned int keyCAPSLOCK   = XK_Caps_Lock;
+    const unsigned int keyA          = XK_a;
+    const unsigned int keyS          = XK_s;
+    const unsigned int keyD          = XK_d;
+    const unsigned int keyF          = XK_f;
+    const unsigned int keyG          = XK_g;
+    const unsigned int keyH          = XK_h;
+    const unsigned int keyJ          = XK_j;
+    const unsigned int keyK          = XK_k;
+    const unsigned int keyL          = XK_l;
+    const unsigned int keyENTER      = XK_Return;
+    const unsigned int keySHIFTLEFT  = XK_Shift_L;
+    const unsigned int keyZ          = XK_z;
+    const unsigned int keyX          = XK_x;
+    const unsigned int keyC          = XK_c;
+    const unsigned int keyV          = XK_v;
+    const unsigned int keyB          = XK_b;
+    const unsigned int keyN          = XK_n;
+    const unsigned int keyM          = XK_m;
+    const unsigned int keySHIFTRIGHT = XK_Shift_R;
+    const unsigned int keyARROWUP    = XK_Up;
+    const unsigned int keyCTRLLEFT   = XK_Control_L;
+    const unsigned int keyAPPLEFT    = XK_Super_L;
+    const unsigned int keySPACE      = XK_space;
+    const unsigned int keyALTGR      = XK_Alt_R;
+    const unsigned int keyAPPRIGHT   = XK_Super_R;
+    const unsigned int keyMENU       = XK_Menu;
+    const unsigned int keyCTRLRIGHT  = XK_Control_R;
+    const unsigned int keyARROWLEFT  = XK_Left;
+    const unsigned int keyARROWDOWN  = XK_Down;
+    const unsigned int keyARROWRIGHT = XK_Right;  
+#else
+    // Keycodes for Windows-OS
+    //@{
+    //!\name Keycodes.
+    /** 
+	Keycodes are used to detect keyboard events occuring on display windows \c CImgDisplay.
+	The field \c key of the \c CImgDisplay structure is updated at real-time with the corresponding keycode
+	of the pressed key (or 0 if no keys have been pressed). The keycodes values are given by the variables
+	whose names are of the form <tt>cimg::key*</tt>. Above is the keycode for the 'ESC' key, but
+	almost all keycodes are thus defined.
+        Using CImg-defined keycodes ensures a better portability of your program for other architectures.
+    **/
+    const unsigned int keyESC        = 27;
+    const unsigned int keyF1         = 112;
+    const unsigned int keyF2         = 113;
+    const unsigned int keyF3         = 114;
+    const unsigned int keyF4         = 115;
+    const unsigned int keyF5         = 116;
+    const unsigned int keyF6         = 117;
+    const unsigned int keyF7         = 118;
+    const unsigned int keyF8         = 119;
+    const unsigned int keyF9         = 120;
+    const unsigned int keyF10        = 121;
+    const unsigned int keyF11        = 122;
+    const unsigned int keyF12        = 123;
+    const unsigned int keyPAUSE      = 19;
+    const unsigned int key1          = 49;
+    const unsigned int key2          = 50;
+    const unsigned int key3          = 51;
+    const unsigned int key4          = 52;
+    const unsigned int key5          = 53;
+    const unsigned int key6          = 54;
+    const unsigned int key7          = 55;
+    const unsigned int key8          = 56;
+    const unsigned int key9          = 57;
+    const unsigned int key0          = 48;
+    const unsigned int keyBACKSPACE  = 8;
+    const unsigned int keyINSERT     = 45;
+    const unsigned int keyHOME       = 36;
+    const unsigned int keyPAGEUP     = 33;
+    const unsigned int keyTAB        = 9;
+    const unsigned int keyQ          = 81;
+    const unsigned int keyW          = 87;
+    const unsigned int keyE          = 69;
+    const unsigned int keyR          = 82;
+    const unsigned int keyT          = 84;
+    const unsigned int keyY          = 89;
+    const unsigned int keyU          = 85;
+    const unsigned int keyI          = 73;
+    const unsigned int keyO          = 79;
+    const unsigned int keyP          = 80;
+    const unsigned int keyDELETE     = 8;
+    const unsigned int keyEND        = 35;
+    const unsigned int keyPAGEDOWN   = 34;
+    const unsigned int keyCAPSLOCK   = 20;
+    const unsigned int keyA          = 65;
+    const unsigned int keyS          = 83;
+    const unsigned int keyD          = 68;
+    const unsigned int keyF          = 70;
+    const unsigned int keyG          = 71;
+    const unsigned int keyH          = 72;
+    const unsigned int keyJ          = 74;
+    const unsigned int keyK          = 75;
+    const unsigned int keyL          = 76;
+    const unsigned int keyENTER      = 13;
+    const unsigned int keySHIFTLEFT  = 16;
+    const unsigned int keyZ          = 90;
+    const unsigned int keyX          = 88;
+    const unsigned int keyC          = 67;
+    const unsigned int keyV          = 86;
+    const unsigned int keyB          = 66;
+    const unsigned int keyN          = 78;
+    const unsigned int keyM          = 77;
+    const unsigned int keySHIFTRIGHT = 16;
+    const unsigned int keyARROWUP    = 38;
+    const unsigned int keyCTRLLEFT   = 17;
+    const unsigned int keyAPPLEFT    = 91;
+    const unsigned int keySPACE      = 32;
+    const unsigned int keyALTGR      = 17;
+    const unsigned int keyAPPRIGHT   = 92;
+    const unsigned int keyMENU       = 93;
+    const unsigned int keyCTRLRIGHT  = 17;
+    const unsigned int keyARROWLEFT  = 37;
+    const unsigned int keyARROWDOWN  = 40;
+    const unsigned int keyARROWRIGHT = 39;
+#endif
+    //@}
+
+#ifdef PI
+#undef PI
+#endif
+    const double PI = 3.14159265358979323846;   //!< Definition of the mathematical constant PI
+
+    // Definition of a 7x11x1x3 font, used to return a default font for drawing text.
+    const unsigned int font7x11[7*11*256/8] = 
+      {0x00000000,
+       0x00000000,0x00000000,0x00000002,0x04081020,0x00800000,0x24489000,0x00000000,0x000000a1,
+       0x4f8a7e50,0xa0000002,0x0f287030,0x50a78200,0x00008695,0x454552c2,0x00000002,0x0a143193,
+       0x19f00000,0x04081000,0x00000000,0x00001841,0x02040810,0x20203006,0x02020408,0x1020410c,
+       0x000010d8,0xc1400000,0x00000000,0x01021f08,0x10200000,0x00000000,0x00018302,0x08000000,
+       0x0007c000,0x00000000,0x00000000,0x0060c000,0x0000820c,0x1040820c,0x10400000,0xe2244891,
+       0x22380000,0x00061408,0x102043e0,0x00000070,0x10208208,0x1e000000,0x03c0810c,0x0408e000,
+       0x0000020c,0x2891f040,0x80000000,0xf1020701,0x02380000,0x0001c410,0x2c6488e0,0x0000003e,
+       0x08104102,0x08000000,0x00e22487,0x11223800,0x00000711,0x223c0823,0x80000000,0x0060c000,
+       0x060c0000,0x00000306,0x00003060,0x41000000,0x0218c180,0xc0400000,0x000007f0,0x1fc00000,
+       0x00000010,0x180c18c2,0x00000000,0x3c440820,0x80020000,0x0000f229,0xd4afa038,0x00000002,
+       0x0a1444f9,0x14100000,0x00788913,0xc4489e00,0x000001e4,0x10204040,0x78000000,0x1e224489,
+       0x12278000,0x0000f902,0x0788103e,0x00000007,0xc8103c40,0x81000000,0x001e4102,0x34244780,
+       0x00000112,0x244f9122,0x44000000,0x0f840810,0x2043e000,0x00003810,0x2040811c,0x00000002,
+       0x248a1828,0x48880000,0x00102040,0x810207c0,0x0000019b,0x36ab56a9,0x42000000,0x044c9d2a,
+       0x4c991000,0x00003c85,0x0a14284f,0x00000001,0xe2244f10,0x20400000,0x000f2142,0x850a13c0,
+       0xc0c000f1,0x12278911,0x21000000,0x01e4080e,0x0204f000,0x00003f88,0x10204081,0x00000000,
+       0x89122448,0x911c0000,0x00082891,0x22285040,0x00000041,0x9325ab64,0xc8800000,0x020a2282,
+       0x0a228200,0x00001051,0x14102040,0x80000000,0xfc082082,0x083f0000,0x00e10204,0x08102040,
+       0x81c01010,0x20202040,0x40808080,0x70204081,0x02040810,0xe0008105,0x1b228200,0x00000000,
+       0x00000000,0x00003f80,0x20200000,0x00000000,0x00000000,0x0e023c89,0x11f00000,0x2040b192,
+       0x24489e00,0x00000003,0xc8102040,0x78000000,0x811e4489,0x1223c000,0x000000e2,0x27c8101e,
+       0x00000071,0x0fc40810,0x20400000,0x00003c89,0x12244781,0x1c008102,0xe6489122,0x44000001,
+       0x001c0810,0x20408000,0x00040070,0x20408102,0x04700102,0x04491c28,0x48880000,0x0e040810,
+       0x20408100,0x00000002,0xded93264,0xc9000000,0x000b9922,0x44891000,0x00000038,0x89122447,
+       0x00000000,0x02c64891,0x22788100,0x00000f22,0x448911e0,0x40800000,0xb9920408,0x10000000,
+       0x00078818,0x0c08e000,0x0000083e,0x20408101,0xc0000000,0x01122448,0x933a0000,0x00001051,
+       0x22285040,0x00000000,0x8326ad56,0xc8800000,0x00042486,0x0c248400,0x00000020,0xa24450a0,
+       0x831c0000,0x00f81041,0x041f0000,0x00308102,0x0c081020,0x40600204,0x08102040,0x81020400,
+       0x60204081,0x82040810,0xe0000000,0x00399c00,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x04001020,
+       0x40810000,0x00107142,0x85070400,0x000000c2,0x041c1020,0xf0000000,0x213c4891,0xe4200000,
+       0x00010511,0x47c21f08,0x00000081,0x02000000,0x00408100,0x001c40c1,0x62428302,0x38480000,
+       0x00000000,0x00000000,0x0f215aa5,0x6a13c000,0x00007871,0x23e00000,0x00000000,0x00028a28,
+       0x28280000,0x00000001,0xf8102000,0x00000000,0x0007c000,0x00000000,0x07113a44,0x70000000,
+       0x1fc00000,0x00000000,0x00000000,0x41410000,0x00000000,0x00000408,0x7c2043e0,0x0000003c,
+       0x30f00000,0x00000000,0x01c10700,0x00000000,0x00820000,0x00000000,0x00000000,0x01122448,
+       0x933a4080,0x0007ce9d,0x1a142850,0xa1400000,0x0000c180,0x00000000,0x00000000,0x00000010,
+       0x60000604,0x08000000,0x00000000,0x30912180,0x00000000,0x0000000a,0x0a0a28a0,0x00000032,
+       0x28505952,0xf8400000,0x01914282,0xe8514700,0x00000e38,0xba0e34be,0x10000000,0x00100040,
+       0x8208111e,0x40404142,0x889f2282,0x00004102,0x0a1444f9,0x1410000c,0x241050a2,0x27c8a080,
+       0x0028a082,0x85113e45,0x04000480,0x04142889,0xf2282000,0x082820a1,0x444f9141,0x00000001,
+       0xc60c2c50,0xe2700000,0x001e4102,0x04040782,0x0c2021f2,0x040f1020,0x7c000020,0x8f902078,
+       0x8103e000,0x0c247c81,0x03c4081f,0x00009003,0xe4081e20,0x40f80002,0x021f0810,0x204087c0,
+       0x000410f8,0x40810204,0x3e0000c2,0x47c20408,0x1021f000,0x09003e10,0x2040810f,0x80000001,
+       0xe2245c91,0x22780000,0xa288993a,0x54993220,0x00080879,0x0a142850,0x9e000010,0x43c850a1,
+       0x4284f000,0x03091e42,0x850a1427,0x80000a28,0xf2142850,0xa13c0001,0x200790a1,0x428509e0,
+       0x00000000,0x8490c184,0x90800000,0x01f66954,0xa966f800,0x01010891,0x22448911,0xc0000104,
+       0x44891224,0x488e0000,0x61222448,0x91224470,0x00048011,0x22448912,0x23800002,0x09051141,
+       0x02040800,0x0000040f,0x112244f1,0x0000000e,0x2448a142,0x444b8000,0x202001c0,0x4791223e,
+       0x00004100,0x0e023c89,0x11f0000c,0x24007011,0xe4488f80,0x0028a003,0x808f2244,0x7c000005,
+       0x001c0479,0x1223e000,0x082820e0,0x23c8911f,0x00000000,0x1d853e91,0x21b00000,0x00003c81,
+       0x02040782,0x0c202001,0xc44f9020,0x3c000041,0x000e227c,0x8101e000,0x0c240071,0x13e4080f,
+       0x000000a0,0x03889f20,0x40780002,0x02003810,0x20408100,0x00041001,0xc0810204,0x080000c2,
+       0x400e0408,0x10204000,0x000a0070,0x20408102,0x000000e1,0x21c44891,0x22380000,0xa2801732,
+       0x44891220,0x00080800,0x71122448,0x8e000020,0x80038891,0x22447000,0x0309001c,0x44891223,
+       0x80000a28,0x00e22448,0x911c0000,0x01400711,0x224488e0,0x00000000,0x2003f000,0x04000000,
+       0x0001e4ca,0x99327800,0x01010011,0x22448933,0xa0000410,0x00891224,0x499d0000,0x61200448,
+       0x91224ce8,0x00000500,0x22448912,0x67400004,0x10020a24,0x450a0831,0xc002040b,0x19224489,
+       0xe204000a,0x00828911,0x42820c70,0x00000000,0x00000000,0x00000002,0x04081020,0x00800000,
+       0x24489000,0x00000000,0x000000a1,0x4f8a7e50,0xa0000002,0x0f287030,0x50a78200,0x00008695,
+       0x454552c2,0x00000002,0x0a143193,0x19f00000,0x04081000,0x00000000,0x00001841,0x02040810,
+       0x20203006,0x02020408,0x1020410c,0x000010d8,0xc1400000,0x00000000,0x01021f08,0x10200000,
+       0x00000000,0x00018302,0x08000000,0x0007c000,0x00000000,0x00000000,0x0060c000,0x0000820c,
+       0x1040820c,0x10400000,0xe2244891,0x22380000,0x00061408,0x102043e0,0x00000070,0x10208208,
+       0x1e000000,0x03c0810c,0x0408e000,0x0000020c,0x2891f040,0x80000000,0xf1020701,0x02380000,
+       0x0001c410,0x2c6488e0,0x0000003e,0x08104102,0x08000000,0x00e22487,0x11223800,0x00000711,
+       0x223c0823,0x80000000,0x0060c000,0x060c0000,0x00000306,0x00003060,0x41000000,0x0218c180,
+       0xc0400000,0x000007f0,0x1fc00000,0x00000010,0x180c18c2,0x00000000,0x3c440820,0x80020000,
+       0x0000f229,0xd4afa038,0x00000002,0x0a1444f9,0x14100000,0x00788913,0xc4489e00,0x000001e4,
+       0x10204040,0x78000000,0x1e224489,0x12278000,0x0000f902,0x0788103e,0x00000007,0xc8103c40,
+       0x81000000,0x001e4102,0x34244780,0x00000112,0x244f9122,0x44000000,0x0f840810,0x2043e000,
+       0x00003810,0x2040811c,0x00000002,0x248a1828,0x48880000,0x00102040,0x810207c0,0x0000019b,
+       0x36ab56a9,0x42000000,0x044c9d2a,0x4c991000,0x00003c85,0x0a14284f,0x00000001,0xe2244f10,
+       0x20400000,0x000f2142,0x850a13c0,0xc0c000f1,0x12278911,0x21000000,0x01e4080e,0x0204f000,
+       0x00003f88,0x10204081,0x00000000,0x89122448,0x911c0000,0x00082891,0x22285040,0x00000041,
+       0x9325ab64,0xc8800000,0x020a2282,0x0a228200,0x00001051,0x14102040,0x80000000,0xfc082082,
+       0x083f0000,0x00e10204,0x08102040,0x81c01010,0x20202040,0x40808080,0x70204081,0x02040810,
+       0xe0008105,0x1b228200,0x00000000,0x00000000,0x00003f80,0x20200000,0x00000000,0x00000000,
+       0x0e023c89,0x11f00000,0x2040b192,0x24489e00,0x00000003,0xc8102040,0x78000000,0x811e4489,
+       0x1223c000,0x000000e2,0x27c8101e,0x00000071,0x0fc40810,0x20400000,0x00003c89,0x12244781,
+       0x1c008102,0xe6489122,0x44000001,0x001c0810,0x20408000,0x00040070,0x20408102,0x04700102,
+       0x04491c28,0x48880000,0x0e040810,0x20408100,0x00000002,0xded93264,0xc9000000,0x000b9922,
+       0x44891000,0x00000038,0x89122447,0x00000000,0x02c64891,0x22788100,0x00000f22,0x448911e0,
+       0x40800000,0xb9920408,0x10000000,0x00078818,0x0c08e000,0x0000083e,0x20408101,0xc0000000,
+       0x01122448,0x933a0000,0x00001051,0x22285040,0x00000000,0x8326ad56,0xc8800000,0x00042486,
+       0x0c248400,0x00000020,0xa24450a0,0x831c0000,0x00f81041,0x041f0000,0x00308102,0x0c081020,
+       0x40600204,0x08102040,0x81020400,0x60204081,0x82040810,0xe0000000,0x00399c00,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x04001020,0x40810000,0x00107142,0x85070400,0x000000c2,0x041c1020,
+       0xf0000000,0x213c4891,0xe4200000,0x00010511,0x47c21f08,0x00000081,0x02000000,0x00408100,
+       0x001c40c1,0x62428302,0x38480000,0x00000000,0x00000000,0x0f215aa5,0x6a13c000,0x00007871,
+       0x23e00000,0x00000000,0x00028a28,0x28280000,0x00000001,0xf8102000,0x00000000,0x0007c000,
+       0x00000000,0x07113a44,0x70000000,0x1fc00000,0x00000000,0x00000000,0x41410000,0x00000000,
+       0x00000408,0x7c2043e0,0x0000003c,0x30f00000,0x00000000,0x01c10700,0x00000000,0x00820000,
+       0x00000000,0x00000000,0x01122448,0x933a4080,0x0007ce9d,0x1a142850,0xa1400000,0x0000c180,
+       0x00000000,0x00000000,0x00000010,0x60000604,0x08000000,0x00000000,0x30912180,0x00000000,
+       0x0000000a,0x0a0a28a0,0x00000032,0x28505952,0xf8400000,0x01914282,0xe8514700,0x00000e38,
+       0xba0e34be,0x10000000,0x00100040,0x8208111e,0x40404142,0x889f2282,0x00004102,0x0a1444f9,
+       0x1410000c,0x241050a2,0x27c8a080,0x0028a082,0x85113e45,0x04000480,0x04142889,0xf2282000,
+       0x082820a1,0x444f9141,0x00000001,0xc60c2c50,0xe2700000,0x001e4102,0x04040782,0x0c2021f2,
+       0x040f1020,0x7c000020,0x8f902078,0x8103e000,0x0c247c81,0x03c4081f,0x00009003,0xe4081e20,
+       0x40f80002,0x021f0810,0x204087c0,0x000410f8,0x40810204,0x3e0000c2,0x47c20408,0x1021f000,
+       0x09003e10,0x2040810f,0x80000001,0xe2245c91,0x22780000,0xa288993a,0x54993220,0x00080879,
+       0x0a142850,0x9e000010,0x43c850a1,0x4284f000,0x03091e42,0x850a1427,0x80000a28,0xf2142850,
+       0xa13c0001,0x200790a1,0x428509e0,0x00000000,0x8490c184,0x90800000,0x01f66954,0xa966f800,
+       0x01010891,0x22448911,0xc0000104,0x44891224,0x488e0000,0x61222448,0x91224470,0x00048011,
+       0x22448912,0x23800002,0x09051141,0x02040800,0x0000040f,0x112244f1,0x0000000e,0x2448a142,
+       0x444b8000,0x202001c0,0x4791223e,0x00004100,0x0e023c89,0x11f0000c,0x24007011,0xe4488f80,
+       0x0028a003,0x808f2244,0x7c000005,0x001c0479,0x1223e000,0x082820e0,0x23c8911f,0x00000000,
+       0x1d853e91,0x21b00000,0x00003c81,0x02040782,0x0c202001,0xc44f9020,0x3c000041,0x000e227c,
+       0x8101e000,0x0c240071,0x13e4080f,0x000000a0,0x03889f20,0x40780002,0x02003810,0x20408100,
+       0x00041001,0xc0810204,0x080000c2,0x400e0408,0x10204000,0x000a0070,0x20408102,0x000000e1,
+       0x21c44891,0x22380000,0xa2801732,0x44891220,0x00080800,0x71122448,0x8e000020,0x80038891,
+       0x22447000,0x0309001c,0x44891223,0x80000a28,0x00e22448,0x911c0000,0x01400711,0x224488e0,
+       0x00000000,0x2003f000,0x04000000,0x0001e4ca,0x99327800,0x01010011,0x22448933,0xa0000410,
+       0x00891224,0x499d0000,0x61200448,0x91224ce8,0x00000500,0x22448912,0x67400004,0x10020a24,
+       0x450a0831,0xc002040b,0x19224489,0xe204000a,0x00828911,0x42820c70,0x00000000,0x00000000,
+       0x00000002,0x04081020,0x00800000,0x24489000,0x00000000,0x000000a1,0x4f8a7e50,0xa0000002,
+       0x0f287030,0x50a78200,0x00008695,0x454552c2,0x00000002,0x0a143193,0x19f00000,0x04081000,
+       0x00000000,0x00001841,0x02040810,0x20203006,0x02020408,0x1020410c,0x000010d8,0xc1400000,
+       0x00000000,0x01021f08,0x10200000,0x00000000,0x00018302,0x08000000,0x0007c000,0x00000000,
+       0x00000000,0x0060c000,0x0000820c,0x1040820c,0x10400000,0xe2244891,0x22380000,0x00061408,
+       0x102043e0,0x00000070,0x10208208,0x1e000000,0x03c0810c,0x0408e000,0x0000020c,0x2891f040,
+       0x80000000,0xf1020701,0x02380000,0x0001c410,0x2c6488e0,0x0000003e,0x08104102,0x08000000,
+       0x00e22487,0x11223800,0x00000711,0x223c0823,0x80000000,0x0060c000,0x060c0000,0x00000306,
+       0x00003060,0x41000000,0x0218c180,0xc0400000,0x000007f0,0x1fc00000,0x00000010,0x180c18c2,
+       0x00000000,0x3c440820,0x80020000,0x0000f229,0xd4afa038,0x00000002,0x0a1444f9,0x14100000,
+       0x00788913,0xc4489e00,0x000001e4,0x10204040,0x78000000,0x1e224489,0x12278000,0x0000f902,
+       0x0788103e,0x00000007,0xc8103c40,0x81000000,0x001e4102,0x34244780,0x00000112,0x244f9122,
+       0x44000000,0x0f840810,0x2043e000,0x00003810,0x2040811c,0x00000002,0x248a1828,0x48880000,
+       0x00102040,0x810207c0,0x0000019b,0x36ab56a9,0x42000000,0x044c9d2a,0x4c991000,0x00003c85,
+       0x0a14284f,0x00000001,0xe2244f10,0x20400000,0x000f2142,0x850a13c0,0xc0c000f1,0x12278911,
+       0x21000000,0x01e4080e,0x0204f000,0x00003f88,0x10204081,0x00000000,0x89122448,0x911c0000,
+       0x00082891,0x22285040,0x00000041,0x9325ab64,0xc8800000,0x020a2282,0x0a228200,0x00001051,
+       0x14102040,0x80000000,0xfc082082,0x083f0000,0x00e10204,0x08102040,0x81c01010,0x20202040,
+       0x40808080,0x70204081,0x02040810,0xe0008105,0x1b228200,0x00000000,0x00000000,0x00003f80,
+       0x20200000,0x00000000,0x00000000,0x0e023c89,0x11f00000,0x2040b192,0x24489e00,0x00000003,
+       0xc8102040,0x78000000,0x811e4489,0x1223c000,0x000000e2,0x27c8101e,0x00000071,0x0fc40810,
+       0x20400000,0x00003c89,0x12244781,0x1c008102,0xe6489122,0x44000001,0x001c0810,0x20408000,
+       0x00040070,0x20408102,0x04700102,0x04491c28,0x48880000,0x0e040810,0x20408100,0x00000002,
+       0xded93264,0xc9000000,0x000b9922,0x44891000,0x00000038,0x89122447,0x00000000,0x02c64891,
+       0x22788100,0x00000f22,0x448911e0,0x40800000,0xb9920408,0x10000000,0x00078818,0x0c08e000,
+       0x0000083e,0x20408101,0xc0000000,0x01122448,0x933a0000,0x00001051,0x22285040,0x00000000,
+       0x8326ad56,0xc8800000,0x00042486,0x0c248400,0x00000020,0xa24450a0,0x831c0000,0x00f81041,
+       0x041f0000,0x00308102,0x0c081020,0x40600204,0x08102040,0x81020400,0x60204081,0x82040810,
+       0xe0000000,0x00399c00,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x04001020,0x40810000,0x00107142,
+       0x85070400,0x000000c2,0x041c1020,0xf0000000,0x213c4891,0xe4200000,0x00010511,0x47c21f08,
+       0x00000081,0x02000000,0x00408100,0x001c40c1,0x62428302,0x38480000,0x00000000,0x00000000,
+       0x0f215aa5,0x6a13c000,0x00007871,0x23e00000,0x00000000,0x00028a28,0x28280000,0x00000001,
+       0xf8102000,0x00000000,0x0007c000,0x00000000,0x07113a44,0x70000000,0x1fc00000,0x00000000,
+       0x00000000,0x41410000,0x00000000,0x00000408,0x7c2043e0,0x0000003c,0x30f00000,0x00000000,
+       0x01c10700,0x00000000,0x00820000,0x00000000,0x00000000,0x01122448,0x933a4080,0x0007ce9d,
+       0x1a142850,0xa1400000,0x0000c180,0x00000000,0x00000000,0x00000010,0x60000604,0x08000000,
+       0x00000000,0x30912180,0x00000000,0x0000000a,0x0a0a28a0,0x00000032,0x28505952,0xf8400000,
+       0x01914282,0xe8514700,0x00000e38,0xba0e34be,0x10000000,0x00100040,0x8208111e,0x40404142,
+       0x889f2282,0x00004102,0x0a1444f9,0x1410000c,0x241050a2,0x27c8a080,0x0028a082,0x85113e45,
+       0x04000480,0x04142889,0xf2282000,0x082820a1,0x444f9141,0x00000001,0xc60c2c50,0xe2700000,
+       0x001e4102,0x04040782,0x0c2021f2,0x040f1020,0x7c000020,0x8f902078,0x8103e000,0x0c247c81,
+       0x03c4081f,0x00009003,0xe4081e20,0x40f80002,0x021f0810,0x204087c0,0x000410f8,0x40810204,
+       0x3e0000c2,0x47c20408,0x1021f000,0x09003e10,0x2040810f,0x80000001,0xe2245c91,0x22780000,
+       0xa288993a,0x54993220,0x00080879,0x0a142850,0x9e000010,0x43c850a1,0x4284f000,0x03091e42,
+       0x850a1427,0x80000a28,0xf2142850,0xa13c0001,0x200790a1,0x428509e0,0x00000000,0x8490c184,
+       0x90800000,0x01f66954,0xa966f800,0x01010891,0x22448911,0xc0000104,0x44891224,0x488e0000,
+       0x61222448,0x91224470,0x00048011,0x22448912,0x23800002,0x09051141,0x02040800,0x0000040f,
+       0x112244f1,0x0000000e,0x2448a142,0x444b8000,0x202001c0,0x4791223e,0x00004100,0x0e023c89,
+       0x11f0000c,0x24007011,0xe4488f80,0x0028a003,0x808f2244,0x7c000005,0x001c0479,0x1223e000,
+       0x082820e0,0x23c8911f,0x00000000,0x1d853e91,0x21b00000,0x00003c81,0x02040782,0x0c202001,
+       0xc44f9020,0x3c000041,0x000e227c,0x8101e000,0x0c240071,0x13e4080f,0x000000a0,0x03889f20,
+       0x40780002,0x02003810,0x20408100,0x00041001,0xc0810204,0x080000c2,0x400e0408,0x10204000,
+       0x000a0070,0x20408102,0x000000e1,0x21c44891,0x22380000,0xa2801732,0x44891220,0x00080800,
+       0x71122448,0x8e000020,0x80038891,0x22447000,0x0309001c,0x44891223,0x80000a28,0x00e22448,
+       0x911c0000,0x01400711,0x224488e0,0x00000000,0x2003f000,0x04000000,0x0001e4ca,0x99327800,
+       0x01010011,0x22448933,0xa0000410,0x00891224,0x499d0000,0x61200448,0x91224ce8,0x00000500,
+       0x22448912,0x67400004,0x10020a24,0x450a0831,0xc002040b,0x19224489,0xe204000a,0x00828911,
+       0x42820c70};
+
+    // Return a 'stringification' of standart integral types.
+    const char* const bool_st    = "bool";
+    const char* const uchar_st   = "unsigned char";
+    const char* const char_st    = "char";
+    const char* const ushort_st  = "unsigned short";
+    const char* const short_st   = "short";
+    const char* const uint_st    = "unsigned int";
+    const char* const int_st     = "int";
+    const char* const ulong_st   = "unsigned long";
+    const char* const long_st    = "long";
+    const char* const float_st   = "float";
+    const char* const double_st  = "double";
+    const char* const unknown_st = "unknown";
+    template<typename t> inline const char* get_type(const t&) { return unknown_st; }
+    inline const char* get_type(const bool&          ) { return bool_st;   }
+    inline const char* get_type(const unsigned char& ) { return uchar_st;  }
+    inline const char* get_type(const char&          ) { return char_st;   }
+    inline const char* get_type(const unsigned short&) { return ushort_st; }
+    inline const char* get_type(const short&         ) { return short_st;  }
+    inline const char* get_type(const unsigned int&  ) { return uint_st;   }
+    inline const char* get_type(const int&           ) { return int_st;    }
+    inline const char* get_type(const unsigned long& ) { return ulong_st;  }
+    inline const char* get_type(const long&          ) { return long_st;   }
+    inline const char* get_type(const float&         ) { return float_st;  }
+    inline const char* get_type(const double&        ) { return double_st; }
+    
+    // Display a warning message
+#if cimg_debug>=1    
+    static void warn(const bool cond,const char *format,...) {
+      if (cond) {
+        va_list ap;
+        va_start(ap,format);
+        std::fprintf(stderr,"<CImg Warning> ");
+        std::vfprintf(stderr,format,ap);
+        std::fputc('\n',stderr);
+        va_end(ap);
+      }
+    }
+#else
+    inline void warn(const bool cond,const char *format,...) {}
+#endif
+
+    inline int xln(const int x) { return x>0?(int)(1+std::log10((double)x)):1; }
+    inline char uncase(const char x) { return (char)((x<'A'||x>'Z')?x:x-'A'+'a'); }
+    inline float atof(const char *str) {
+      float x=0,y=1;
+      if (!str) return 0; else { std::sscanf(str,"%g/%g",&x,&y); return x/y; }
+    }
+    inline int strlen(const char *s) { if (s) { int k; for (k=0; s[k]; k++) ; return k; } return -1; }
+    inline int strncmp(const char *s1,const char *s2,const int l) {
+      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=abs(s1[k] - s2[k]); return n; }
+      return 0;
+    }
+    inline int strncasecmp(const char *s1,const char *s2,const int l) {
+      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=abs(uncase(s1[k])-uncase(s2[k])); return n; }
+      return 0;
+    }
+    inline int strcmp(const char *s1,const char *s2)     { 
+      const int l1 = strlen(s1), l2 = strlen(s2);
+      return strncmp(s1,s2,1+(l1<l2?l1:l2));
+    }
+    inline int strcasecmp(const char *s1,const char *s2) { 
+      const int l1 = strlen(s1), l2 = strlen(s2);
+      return strncasecmp(s1,s2,1+(l1<l2?l1:l2));
+    }
+    inline int strfind(const char *s,const char c) {
+      if (s) { 
+        int l; for (l=strlen(s); l>=0 && s[l]!=c; l--) ;
+        return l; 
+      }
+      return -1; 
+    }
+    inline const char* basename(const char *s)  {
+      return (cimg_OS!=2)?(s?s+1+strfind(s,'/'):NULL):(s?s+1+strfind(s,'\\'):NULL); 
+    }
+
+    inline void system(const char *command) {
+#if cimg_OS==2
+      PROCESS_INFORMATION pi;
+      STARTUPINFO si;
+      GetStartupInfo(&si);
+      si.wShowWindow = SW_HIDE;
+      si.dwFlags |= SW_HIDE;
+      BOOL res = CreateProcess(NULL,(LPTSTR)command,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi);
+      if (res) {
+        WaitForSingleObject(pi.hProcess, INFINITE);
+        CloseHandle(pi.hThread);
+        CloseHandle(pi.hProcess);
+      }
+#else
+      ::system(command);
+#endif
+    }
+    
+    //! Return the path of the ImageMagick <tt>convert</tt> tool.
+    /**
+       If you have installed the <a href="http://www.imagemagick.org">ImageMagick package</a>
+       in a standart directory, this function returns the correct path of the \c convert tool
+       used to load and save compressed image formats.
+       Conversely, if the \c convert executable is not auto-detected by the function,
+       you can define the macro \c cimg_convert_path with the correct path
+       of the \c convert executable, before including <tt>"CImg.h"</tt> in your program :
+       \code
+       #define cimg_convert_path "/users/thatsme/local/bin/convert"
+       #include "CImg.h"
+       
+       int main() {
+         CImg<> img("my_image.jpg");
+	 return 0;
+       }
+       \endcode
+       \note \c convert is needed to read and write compressed image formats. Other formats do not need \c convert.
+       \see temporary_path, CImg::load_convert, CImg::save_convert.
+    **/
+    inline const char* convert_path() {
+      static char *convert_path = NULL;
+      if (!convert_path) {
+#if cimg_OS==2 || defined(cimg_convert_path)
+        bool stopflag = false;
+        std::FILE *file;
+#endif
+        convert_path = new char[1024];
+#ifdef cimg_convert_path
+        std::strcpy(convert_path,cimg_convert_path);
+        if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
+#endif
+#if cimg_OS==2
+        for (unsigned int k=0; k<=9 && !stopflag; k++) {
+          std::sprintf(convert_path,"C:\\PROGRA~1\\IMAGEM~1.%u-Q\\convert.exe",k);
+          if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
+        }
+        if (!stopflag) for (unsigned int k=0; k<=9 && !stopflag; k++) {
+          std::sprintf(convert_path,"C:\\PROGRA~1\\IMAGEM~1.%u\\convert.exe",k);
+          if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
+        }
+        if (!stopflag) std::strcpy(convert_path,"convert.exe");
+#else
+        std::strcpy(convert_path,"convert");
+#endif
+      }
+      return convert_path;
+    }
+    
+    //! Return a path to store temporary files.
+    /**
+       If you are running on a standart Unix or Windows system, this function should return a correct path
+       where temporary files can be stored.
+       If the path is not auto-detected, you need to define the macro \c cimg_temporary_path,
+       before including <tt>"CImg.h"</tt> in your program :
+       \code
+       #define cimg_temporary_path "/users/toto/tmp"
+       #include "CImg.h"
+
+       int main() {
+         CImg<> img("my_image.jpg");
+	 return 0;
+       }
+       \endcode
+       \note A temporary path is necessary to load and save compressed image formats, using \c convert.
+       \see convert_path, CImg::load_convert, CImg::save_convert.
+    **/
+    inline const char* temporary_path() {
+      static char *temporary_path = NULL;
+      if (!temporary_path) {
+        temporary_path = new char[1024];
+#ifdef cimg_temporary_path
+        std::strcpy(temporary_path,cimg_temporary_path);
+        const char* testing_path[7] = { temporary_path, "/tmp","C:\\WINNT\\Temp", "C:\\WINDOWS\\Temp","","C:",NULL };
+#else
+        const char* testing_path[6] = { "/tmp","C:\\WINNT\\Temp", "C:\\WINDOWS\\Temp","","C:",NULL };
+#endif
+        char filetmp[1024];
+        std::FILE *file=NULL;
+        int i=-1;
+        while (!file && testing_path[++i]) {
+          std::sprintf(filetmp,"%s/CImg%.4d.ppm",testing_path[i],std::rand()%10000);
+          if ((file=std::fopen(filetmp,"w"))!=NULL) { std::fclose(file); std::remove(filetmp); }
+        }
+        if (!file) 
+	  throw CImgIOException("cimg::temporary_path() : Unable to find a temporary path accessible for writing\n"
+				"you have to set the macro 'cimg_temporary_path' to a valid path where you have writing access :\n"
+				"#define cimg_temporary_path \"path\" (before including 'CImg.h')");
+        std::strcpy(temporary_path,testing_path[i]);
+      }
+      return temporary_path;
+    }
+    
+    inline const char *filename_split(const char *const filename, char *const body=NULL) {
+      if (!filename) throw CImgArgumentException("cimg::filename_split() : Can't split the (null) filename");
+      int l=strfind(filename,'.');
+      if (l>=0) { if (body) { std::strncpy(body,filename,l); body[l]='\0'; }}
+      else { if (body) std::strcpy(body,filename); l=(int)std::strlen(filename)-1; }
+      return filename+l+1;
+    }
+    
+    inline char* file_number(const char *filename,const int number,const unsigned int n,char *const string) {
+      char format[1024],body[1024];
+      const char *ext = filename_split(filename,body);
+      if (n>0) std::sprintf(format,"%s_%%.%ud.%s",body,n,ext);
+      else std::sprintf(format,"%s_%%d.%s",body,ext);
+      std::sprintf(string,format,number);
+      return string;
+    }
+    inline std::FILE *fopen(const char *const path,const char *const mode) {
+      if(!path || !mode) throw CImgArgumentException("cimg::fopen() : Can't open file '%s' with mode '%s'",path,mode);
+      if (path[0]=='-') return (mode[0]=='r')?stdin:stdout; else {
+        std::FILE *dest=std::fopen(path,mode);
+        if(!dest) throw CImgIOException("cimg::fopen() : File '%s' cannot be opened %s",
+                                        path,mode[0]=='r'?"for reading":(mode[0]=='w'?"for writing":""),path);
+        return dest;
+      }
+    }
+    inline int fclose(std::FILE *file) {
+      warn(!file,"cimg::fclose() : Can't close (null) file");
+      if (!file || file==stdin || file==stdout) return 0;
+      const int errn=std::fclose(file);
+      warn(errn!=0,"cimg::fclose() : Error %d during file closing",errn);
+      return errn;
+    }
+    template<typename T> inline int fread(T *ptr,const unsigned int size,const unsigned int nmemb,std::FILE *stream) {
+      if (!ptr || size<=0 || nmemb<=0 || !stream)
+        throw CImgArgumentException("cimg::fread() : Can't read %u x %u bytes of file pointer '%p' in buffer '%p'",
+				    nmemb,size,stream,ptr);
+      const unsigned int errn = (unsigned int)std::fread((void*)ptr,size,nmemb,stream);
+      warn(errn!=nmemb,"cimg::fread() : File reading problems, only %u/%u elements read",errn,nmemb);
+      return errn;
+    }
+    inline int fwrite(const void *ptr,const unsigned int size,const unsigned int nmemb,std::FILE *stream) {
+      if (!ptr || size<=0 || nmemb<=0 || !stream)
+        throw CImgArgumentException("cimg::fwrite() : Can't write %u x %u bytes of file pointer '%p' from buffer '%p'",
+				    nmemb,size,stream,ptr);
+      const unsigned int errn = (unsigned int)std::fwrite(ptr,size,nmemb,stream);
+      if(errn!=nmemb)
+        throw CImgIOException("cimg::fwrite() : File writing problems, only %u/%u elements written",errn,nmemb);
+      return errn;
+    }
+    
+    // Exchange the values of variables \p a and \p b
+    template<typename T> inline void swap(T& a,T& b) { T t=a; a=b; b=t; }
+    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2) { swap(a1,b1); swap(a2,b2); }
+    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3) { swap(a1,b1,a2,b2); swap(a3,b3); }
+    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4) { swap(a1,b1,a2,b2,a3,b3); swap(a4,b4); }
+    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4,T& a5,T& b5) {
+      swap(a1,b1,a2,b2,a3,b3,a4,b4); swap(a5,b5); 
+    }
+    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4,T& a5,T& b5,T& a6,T& b6) {
+      swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5); swap(a6,b6);
+    }
+    
+    template<typename T> inline T& endian_swap(T& a) {  
+      if (sizeof(a)!=1) {
+	unsigned char *pb=(unsigned char*)&a, *pe=pb+sizeof(a);
+	for (int i=0; i<(int)sizeof(a)/2; i++) swap(*(pb++),*(--pe));
+      }
+      return a;
+    }
+
+    template<typename T> inline void endian_swap(T *const buffer,const unsigned int size) {
+      T *ptr = buffer;
+      for (unsigned int i=0; i<size; i++) endian_swap(*(ptr++));
+    }
+
+    inline const char* option(const char *const name,const unsigned int argc,char **argv,const char *const defaut,
+                              const char *const usage=NULL) {
+      static bool first=true, visu=false;
+      const char *res = NULL;
+      if (first) { first=false; visu = option("-h",argc,argv,(const char*)NULL)!=NULL; }
+      if (!name && visu) {
+        std::fprintf(stderr,"\n %s%s%s",t_red,basename(argv[0]),t_normal);
+        if (usage) std::fprintf(stderr," : %s",usage);
+        std::fprintf(stderr," (%s, %s)\n\n",__DATE__,__TIME__);
+      }
+      if (name) {
+        if (argc>0) {
+          unsigned int k=0,i;
+          while (k<argc && strcmp(argv[k],name)) k++;
+          i=k;
+          res=(k++==argc?defaut:(k==argc?argv[--k]:argv[k]));
+        } else res = defaut;
+        if (visu && usage) std::fprintf(stderr,"    %s%-8s%s = %-12s : %s%s%s\n",
+                                        t_bold,name,t_normal,res?res:"NULL",t_purple,usage,t_normal);
+      }
+      return res;
+    }
+    inline bool option(const char *const name,const unsigned int argc,char **argv,
+                       const bool defaut,const char *const usage=NULL) {
+      const char *s = option(name,argc,argv,(const char*)NULL);
+      const bool res = s?(strcasecmp(s,"false") && strcasecmp(s,"off") && strcasecmp(s,"0")):defaut;
+      option(name,0,NULL,res?"true":"false",usage);
+      return res;
+    }
+    inline int option(const char *const name,const unsigned int argc,char **argv,
+                      const int defaut,const char *const usage=NULL) {
+      const char *s = option(name,argc,argv,(const char*)NULL);
+      const int res = s?atoi(s):defaut;
+      char tmp[256];
+      std::sprintf(tmp,"%d",res);
+      option(name,0,NULL,tmp,usage);
+      return res;
+    }
+    inline char option(const char *const name,const unsigned int argc,char **argv,
+		       const char defaut,const char *const usage=NULL) {
+      const char *s = option(name,argc,argv,(const char*)NULL);
+      const char res = s?s[0]:defaut;
+      char tmp[8];
+      tmp[0] = res;
+      tmp[1] ='\0';
+      option(name,0,NULL,tmp,usage);
+      return res;
+    }
+    inline double option(const char *const name,const unsigned int argc,char **argv,
+                         const double defaut,const char *const usage=NULL) {
+      const char *s = option(name,argc,argv,(const char*)NULL);
+      const double res = s?atof(s):defaut;
+      char tmp[256];
+      std::sprintf(tmp,"%g",res);
+      option(name,0,NULL,tmp,usage);
+      return res;
+    }
+    
+    //! Return \c false for little endian CPUs, \c true for big endian CPUs.
+    inline const bool endian() { const int x=1; return ((unsigned char*)&x)[0]?false:true; }
+
+    //! Display informations about CImg compilation variables, on the standart error output \e stderr.
+    inline void info() {
+      std::fprintf(stderr,"\n %sCImg Library %g%s, compiled %s ( %s ) with the following flags :\n\n",
+                   t_red,cimg_version,t_normal,__DATE__,__TIME__);
+      std::fprintf(stderr,"  > Architecture   : %s%-12s%s %s(cimg_OS=%d)\n%s",
+                   t_bold,
+                   cimg_OS==0?"Solaris":(cimg_OS==1?"Linux":(cimg_OS==2?"Windows":(cimg_OS==3?"Mac OS X":(cimg_OS==4?"FreeBSD":"Unknown")))),
+                   t_normal,t_purple,cimg_OS,t_normal);
+      std::fprintf(stderr,"  > Display type   : %s%-12s%s %s(cimg_display_type=%d)%s\n",
+                   t_bold,cimg_display_type==0?"No":(cimg_display_type==1?"X11":(cimg_display_type==2?"WindowsGDI":"Unknown")),t_normal,t_purple,cimg_display_type,t_normal);
+#ifdef cimg_color_terminal
+      std::fprintf(stderr,"  > Color terminal : %s%-12s%s %s(cimg_color_terminal defined)%s\n",t_bold,"Yes",t_normal,t_purple,t_normal);
+#else
+      std::fprintf(stderr,"  > Color terminal : %-12s (cimg_color_terminal undefined)\n","No");
+#endif
+#ifdef cimg_lapack
+      std::fprintf(stderr,"  > Using LAPACK   : %s%-12s%s %s(cimg_lapack defined)%s\n",t_bold,"Yes",t_normal,t_purple,t_normal);
+#else
+      std::fprintf(stderr,"  > Using LAPACK   : %s%-12s%s %s(cimg_lapack undefined)%s\n",t_bold,"No",t_normal,t_purple,t_normal);
+#endif
+      std::fprintf(stderr,"  > Debug messages : %s%-12s%s %s(cimg_debug=%d)%s\n",t_bold,cimg_debug==2?"High":(cimg_debug==1?"Yes":"No"),
+                   t_normal,t_purple,cimg_debug,t_normal);
+      std::fprintf(stderr,"\n");
+    }
+    
+    //! Get the value of a system timer with a millisecond precision.
+    inline long int time() {
+#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3 || cimg_OS==4
+      struct timeval st_time;
+      gettimeofday(&st_time,NULL);
+      return (long int)(st_time.tv_usec/1000 + st_time.tv_sec*1000);
+#elif cimg_OS==2
+      static SYSTEMTIME st_time;
+      GetSystemTime(&st_time);
+      return (long int)(st_time.wMilliseconds + 1000*(st_time.wSecond + 60*(st_time.wMinute + 60*st_time.wHour)));
+#else 
+      return 0;
+#endif
+    }
+
+    //! Sleep for a certain numbers of milliseconds.
+    /**
+       This function frees the CPU ressources during the sleeping time.
+       May be used to temporize your program properly.
+       \see wait, time.
+    **/
+    inline void sleep(const int milliseconds) {
+#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3 || cimg_OS==4
+      struct timespec tv;
+      tv.tv_sec = milliseconds/1000;
+      tv.tv_nsec = (milliseconds%1000)*1000000;
+      nanosleep(&tv,NULL);
+#elif cimg_OS==2
+      Sleep(milliseconds);
+#endif
+    }
+    //! Wait for a certain number of milliseconds since the last call of \ref wait().
+    /**
+       If the desired delay has expired, this function returns immediately else it sleeps till the correct time.
+       May be used to temporize your program properly.
+       \see sleep, time.
+    **/
+    inline long int wait(const int milliseconds=20,long int reference_time=-1) {
+      static long int latest_time = time();
+      if (reference_time>=0) latest_time = reference_time;
+      const long int current_time = time(), time_diff = milliseconds + latest_time - current_time;
+      if (time_diff>0) { sleep(time_diff); return (latest_time = current_time + time_diff); }
+      else return (latest_time = current_time);
+    }
+    //! Bitwise rotation on the left
+    template<typename T> inline const T rol(const T& a,const unsigned int n=1) { return (a<<n)|(a>>((sizeof(T)<<3)-n)); }
+    //! Bitwise rotation on the right
+    template<typename T> inline const T ror(const T& a,const unsigned int n=1) { return (a>>n)|(a<<((sizeof(T)<<3)-n)); }
+
+#if ( !defined(_MSC_VER) || _MSC_VER>1200 )
+    //! Return the absolute value of \p a
+    template<typename T> inline const T abs(const T& a) { return a>=0?a:-a; }
+    //! Return the minimum between \p a and \p b.
+    template<typename T> inline const T& min(const T& a,const T& b) { return a<=b?a:b; }
+    //! Return the minimum between \p a,\p b and \a c.
+    template<typename T> inline const T& min(const T& a,const T& b,const T& c) { return min(min(a,b),c); }
+    //! Return the minimum between \p a,\p b,\p c and \p d.
+    template<typename T> inline const T& min(const T& a,const T& b,const T& c,const T& d) { return min(min(min(a,b),c),d); }
+    //! Return the maximum between \p a and \p b.
+    template<typename T> inline const T& max(const T& a,const T& b) { return a>=b?a:b; }
+    //! Return the maximum between \p a,\p b and \p c.
+    template<typename T> inline const T& max(const T& a,const T& b,const T& c) { return max(max(a,b),c); }
+    //! Return the maximum between \p a,\p b,\p c and \p d.
+    template<typename T> inline const T& max(const T& a,const T& b,const T& c,const T& d) { return max(max(a,b,c),d); }
+    //! Return the sign of \p x.
+    template<typename T> inline char sign(const T& x) { return (x<0)?-1:(x==0?0:1); }
+#else
+    // Special versions due to object reference bug in VisualC++ 6.0.
+    template<typename T> inline const T abs(const T a) { return a>=0?a:-a; }
+    template<typename T> inline const T min(const T a,const T b) { return a<=b?a:b; }
+    template<typename T> inline const T min(const T a,const T b,const T c) { return min(min(a,b),c); }
+    template<typename T> inline const T min(const T a,const T b,const T c,const T& d) { return min(min(min(a,b),c),d); }
+    template<typename T> inline const T max(const T a,const T b) { return a>=b?a:b; }
+    template<typename T> inline const T max(const T a,const T b,const T c) { return max(max(a,b),c); }
+    template<typename T> inline const T max(const T a,const T b,const T c,const T& d) { return max(max(max(a,b),c),d); }
+    template<typename T> inline char sign(const T x) { return (x<0)?-1:(x==0?0:1); }
+#endif
+
+    //! Return \p x modulo \p m (generic modulo).
+    /**
+       This modulo function accepts negative and floating-points modulo numbers \p m.
+    **/
+    inline double mod(const double& x,const double& m) { return x-m*std::floor(x/m); }
+	inline float  mod(const float& x,const float& m)   { return (float)(x-m*std::floor((double)x/m)); }
+    inline int    mod(const int x,const int m)         { return x>=0?x%m:(x%m?m+x%m:0); }
+
+    //! Return minmod(\p a,\p b).
+    /**
+       The operator minmod(\p a,\p b) is defined to be :
+       - minmod(\p a,\p b) = min(\p a,\p b), if (\p a * \p b)>0.
+       - minmod(\p a,\p b) = 0,              if (\p a * \p b)<=0
+    **/
+    template<typename T> inline T minmod(const T& a,const T& b) { return a*b<=0?0:(a>0?(a<b?a:b):(a<b?b:a)); }
+    //! Return a random variable between [0,1] (uniform distribution).
+    inline double rand() { return (double)std::rand()/RAND_MAX; }
+    //! Return a random variable between [-1,1] (uniform distribution).
+    inline double crand() { return 1-2*rand(); }
+    //! Return a random variable using a gaussian distribution and a variance of 1.
+    inline double grand() { return std::sqrt(-2*std::log((double)(1e-10 + (1-2e-10)*rand())))*std::cos((double)(2*PI*rand())); }
+  }
+
+  /*-------------------------------------------------------
+    
+  
+  
+  
+    Definition of the CImgStats structure
+  
+  
+  
+    
+    ------------------------------------------------------*/
+  //! This class is used to compute basics statistics of a <tt>CImg<T></tt> image.
+  /** 
+      Constructing a CImgStats instance by passing an image CImg<T> or an image list CImgl<T> as a parameter,
+      will compute the minimum, the maximum and the average pixel values of the given object, and optionally
+      the variance of the pixel values. Use it to retrieve basic statistics of an image, or an image list,
+      like this :
+      \code 
+      const CImg<float> img("my_image.jpg");
+      const CImgStats stats(img);
+      stats.print("My statistics");
+      std::printf("Max-Min = %lf",stats.max-stats.min);
+      \endcode
+      Note that statistics are computed for all scalar values of a CImg<T> or a CImgl<T>. No vector-valued
+      statistics are performed.
+  **/
+  struct CImgStats {
+    double min;                 //!< Minimum of the pixel values after statistics computation.
+    double max;                 //!< Maximum of the pixel values after statistics computation.
+    double mean;                //!< Mean of the pixel values after statistics computation.
+    double variance;            //!< Variance of the pixel values after statistics computation.
+
+    //! Default constructor.
+    CImgStats():min(0),max(0),mean(0),variance(0) {}
+    //! Copy constructor.
+    CImgStats(const CImgStats& stats):min(stats.min),max(stats.max),mean(stats.mean),variance(stats.variance) {};
+
+    //! Constructor that compute statistics of an image \p img.
+    /** 
+        If \p compute_variance = true, the variance field of the CImgStats structure is computed, else it is set to 0.
+    **/
+    template<typename T> CImgStats(const CImg<T>& img,const bool compute_variance=true):mean(0),variance(0) {
+      cimg_test(img,"CImgStats::CImgStats");
+      T pmin=img[0], pmax=pmin;
+      cimg_map(img,ptr,T) { const T& a=*ptr; mean+=(double)a; if (a<pmin) pmin=a; if (a>pmax) pmax=a; }
+      mean/=img.size();
+      min=(double)pmin;
+      max=(double)pmax;
+      if (compute_variance) {
+        cimg_map(img,ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
+        variance = std::sqrt(variance/img.size());
+      }
+    }
+    //! Constructor that compute statistics of an image list \p list.
+    /**
+       Statistics are computed for all pixels of all images of the list.
+       If \p compute_variance = true, the variance field of the CImgStats structure is computed, else it is undefined.
+    **/
+    template<typename T> CImgStats(const CImgl<T>& list,const bool compute_variance=true):mean(0),variance(0) {
+      cimgl_test(list,"CImgStats::CImgStats");
+      T pmin=list[0][0], pmax=pmin;
+      int psize=0;
+      cimgl_map(list,l) {
+        cimg_map(list[l],ptr,T) {
+          const T& a=*ptr;
+          mean+=(double)a;
+          if (a<pmin) pmin=a;
+          if (a>pmax) pmax=a;
+        }
+        psize+=list[l].size();
+      }
+      mean/=psize;
+      min=(double)pmin;
+      max=(double)pmax;
+      if (compute_variance) {
+        cimgl_map(list,l) cimg_map(list[l],ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
+        variance = std::sqrt(variance/psize);
+      }
+    }
+    //! Assignement operator.
+    CImgStats& operator=(const CImgStats stats) {
+      min = stats.min;
+      max = stats.max;
+      mean = stats.mean;
+      variance = stats.variance;
+      return *this;
+    }
+    //! Print the current statistics on the standart error output.
+    const CImgStats& print(const char* title=NULL) const {
+      std::fprintf(stderr,"%-8s = { %g, %g [%g], %g }\n",title?title:"CImgStats",min,mean,variance,max);
+      return *this;
+    }
+
+#ifdef cimgstats_plugin
+#include cimgstats_plugin
+#endif
+
+  };
+
+  /*-------------------------------------------------------
+  
+
+
+
+    Definition of the CImgDisplay structure
+
+
+
+
+  ------------------------------------------------------*/
+  //! This class is used to create a display window, draw images into it and handle mouse and keyboard events.
+  /**
+     Creating a \c CImgDisplay instance opens a window that can be used to display a \c CImg<T> image
+     of a \c CImgl<T> image list inside. When a display is created, associated window events
+     (such as mouse motion, keyboard and window size changes) are handled and can be easily
+     detected by testing specific \c CImgDisplay data fields.
+     See \ref cimg_displays for a complete tutorial on using the \c CImgDisplay class.
+  **/
+
+  struct CImgDisplay {
+
+    //------------------------
+    //
+    // CImgDisplay variables
+    //
+    //------------------------
+
+    //! Variable representing the width of the display.
+    /**
+       Prefer using CImgDisplay::dimx() to get the width of the display.
+       
+       \note Using CImgDisplay::dimx() instead of \p width is more safe when doing arithmetics
+       involving the value of \p width, since it returns a \e signed int. Arithmetics with
+       \e unsigned types needs a lot of attention.
+
+       \note The variable \c width should be considered as read-only.
+       Setting a new value for \p CImgDisplay::width is done through CImgDisplay::resize().
+       Modifying directly \p width would probably result in a crash.
+
+       \see CImgDisplay::height, CImgDisplay::resize()
+    **/
+    unsigned int width;
+
+    //! Variable representing the height of the display.
+    /**
+       Prefer using CImgDisplay::dimy() to get the height of the display.
+ 
+       \note Using CImgDisplay::dimy() instead of \p height is more safe when doing arithmetics
+       involving the value of \p height, since it returns a \e signed int. Artihmetics with
+       \e unsigned types needs a lot of attention.
+
+       \note The variable \c height should be considered as read-only.
+       Setting a new value for \p CImgDisplay::height is done through CImgDisplay::resize().
+       Modifying directly \p height would probably result in a crash.
+       
+       \see CImgDisplay::width, CImgDisplay::resize()
+    **/
+    unsigned int height;
+
+    //! Variable representing the width of the window associated to
+    //! the current display (should be considered as read-only)
+    /**
+       \note This is not the width of the display, but the width of the underlying system window.
+       This variable is updated when an user resized the window associated to the display.
+       When it occurs, \c width and \c window_width will be probably different.       
+       \see CImgDisplay::window_height, CImgDisplay::resized, CImgDisplay::resize().
+    **/
+    volatile unsigned int window_width;
+
+    //! Variable representing the height of the window associated to
+    //! the current display (should be considered as read-only)
+    /**
+       \note This is not the height of the display, but the height of the underlying system window.
+       This variable is updated when an user resized the window associated to the display.
+       When it occurs, \c height and \c window_height will be probably different.
+       \see CImgDisplay::window_width, CImgDisplay::resized, CImgDisplay::resize().
+    **/
+    volatile unsigned int window_height;
+
+    //! Variable defining the pixel normalization behavior of the display window (can be modified on the fly).
+    /**
+       It represents the way the pixel values are normalized for display purposes.
+       Its value can be set to :
+       - \c 0 : No pixel value normalization are performed (fastest). Be sure your image data are bounded in [0,255].
+       - \c 1 : Pixel value renormalization between [0,255] is done at each display request (default).
+       - \c 2 : Pixel value renormalization between [0,255] is done at the first display request. Then the
+       normalization parameters are kept and used for the next image display requests.
+       \note \c normalization is preferably set by invoking constructors CImgDisplay::CImgDisplay().
+       \see CImgDisplay::CImgDisplay(), CImgDisplay::display().
+    **/
+    unsigned int normalization;
+
+    //! Variable representing the type of events handled by the display window (should be considered as read-only).
+    /**
+       It represents what events are handled by the display. Its value can be set to :
+       - \c 0 : No events are handled by the display.
+       - \c 1 : Display closing and resizing are handled by the display.
+       - \c 2 : Display closing, resizing, mouse motion and buttons press, as well as key press are handled by the display.
+       - \c 3 : Display closing, resizing, mouse motion and buttons press/release, as well as key press/release
+       are handled by the display.
+       \note \c events if preferably set by invoking constructors CImgDisplay::CImgDisplay().
+       \see CImgDisplay::CImgDisplay(), CImgDisplay::mousex, CImgDisplay::mousey, CImgDisplay::key,
+       CImgDisplay::button, CImgDisplay::resized, CImgDisplay::closed.
+    **/
+    unsigned int events;
+
+    //! Variable indicating if the display is fullscreen (should be considered as read-only).
+    /**
+       If the display has been specified to be fullscreen at the construction, this variable is set to \c true.
+       \note This is only useful for Windows-based OS. Fullscreen is not yet supported on X11-based systems
+       and \c fullscreen will always be equal to \e false in this case.
+    **/
+    const bool fullscreen;
+
+    //! Variable representing the current x-coordinate of the mouse pointer over the display window
+    //! (should be considered as read-only).
+    /**
+       If CImgDisplay::events>=2, \p mousex represents the current x-coordinate of the mouse pointer.
+       - If the mouse pointer is outside the display window, \p mousex is equal to \p -1.
+       - If the mouse pointer is over the display window, \p mousex falls in the range [0,CImgDisplay::width-1],
+       where \p 0 corresponds to the far left coordinate and \p CImgDisplay::width-1 to the far right coordinate.
+       \note \p mousex is updated every 25 milliseconds, through an internal thread.
+       \see CImgDisplay::mousey, CImgDisplay::button
+    **/
+    volatile int mousex;
+
+    //! Variable representing the current y-coordinate of the mouse pointer over the display window.
+    //! (should be considered as read only).
+    /**
+       If CImgDisplay::events>=2, \p mousey represents the current y-coordinate of the mouse pointer.
+       - If the mouse pointer is outside the display window, \p mousey is equal to \p -1.
+       - If the mouse pointer is over the display window, \p mousey falls in the range [0,CImgDisplay::height-1],
+       where \p 0 corresponds to the far top coordinate and \p CImgDisplay::height-1 to the far bottom coordinate.
+       \note \p mousey is updated every 25 milliseconds, through an internal thread.
+       \see CImgDisplay::mousex, CImgDisplay::button
+    **/
+    volatile int mousey;
+
+    //! Variable representing the state of the mouse buttons when the mouse pointer is over the display window.
+    //! (should be considered as read only)
+    /**
+       If CImgDisplay::events>=2, \c button represents the current state of the mouse buttons.
+       - If the mouse pointer is outside the display window, \c button is equal to \c 0.
+       - If the mouse pointer is over the display window, \c button is a combination of the following bits :
+       - bit 0 : State of the left mouse button.
+       - bit 1 : State of the right mouse button.
+       - bit 2 : State of the middle mouse button.
+       - Other bits are unused.
+       \note
+       - \c button is updated every 25 milliseconds, through an internal thread.
+       - If CImgDisplay::events==2, you should re-init \p button to \p 0 after catching the
+       mouse button events, since it will NOT be done automatically (\p Mouse \p button \p Release event is
+       not handled in this case).
+       \see CImgDisplay::mousex, CImgDisplay::mousey
+    **/
+    volatile unsigned int button;
+
+    //! Variable representing the key pressed when mouse pointer is over the display window.
+    /**
+       If CImgDisplay::events>=2, \c key represents a raw integer value corresponding 
+       to the current pressed key.
+       - If no keys are pressed, \c key is equal to \p 0.
+       - If a key is pressed, \p key is a value representing the key. This raw value is \e OS-dependent.
+       Testing the \p key value directly with a raw integer will mostly result in incompabilities
+       between different plateforms. 
+       To bypass this problem, \b OS-independent \b keycodes are defined in the \p cimg:: namespace.
+       They are named as \p cimg::key*, where * stands for the key name :
+       \p cimg::keyESC, \p cimg::keyF1, \p cimg::key0, \p cimg::keyA, \p cimg::keySPACE, \p cimg::keySHIFTLEFT, etc...
+       \code
+       CImgDisplay disp(320,200,"Display");        // Create a display window with full events handling
+       ...
+       if (disp.key==cimg::keyESC) exit(0);        // Exit when pressing the ESC key.
+       ...
+       \endcode
+
+       \note 
+       - \p key is updated every 25 milliseconds, through an internal thread.
+       - If CImgDisplay::events==2, You should re-init the \c key variable to \c 0 after catching
+       the \p Key \p Pressed event, since it will NOT be done automatically (Key Release event is handled
+       only when \c CImgDisplay::events>=3).
+ 
+       \see CImgDisplay::button, CImgDisplay::mousex, CImgDisplay::mousey
+    **/
+    volatile unsigned int key;
+
+    //! Variable representing the visibility state of the display window (should be read only).
+    /**
+       \p closed can be either true or false :
+       - \p false : The window is visible.
+       - \p true  : The window is hidden.
+     
+       If CImgDisplay::events>=1, \p closed is set to \p true when the user try to close the display window.
+       The way to set a value for \p closed is to use the functions :
+       - CImgDisplay::show(), to set \p closed to \p false.
+       - CImgDisplay::close(), to set \p closed to \p true.
+
+       Closing a display window DO NOT destroy the instance object. It simply \e hides the display window
+       and set the variable \p closed to true. You are then free to decide what to do
+       when this event occurs. For instance, the following code will re-open the window indefinitely 
+       when the user tries to close it :
+       \code
+       CImgDisplay disp(320,200,"Try to close me !");
+       for (;; disp.wait()) if (disp.closed) disp.show();
+       \endcode
+
+       \note - \p closed is updated every 25 milliseconds, through an internal thread.
+
+       \see CImgDisplay::show(), CImgDisplay::close().
+    **/
+    volatile bool closed;
+
+    //! Event-variable
+    volatile bool resized;
+
+    // Not documented, internal use only.
+    double min,max;
+
+    //------------------------
+    //
+    // CImgDisplay functions
+    //
+    //------------------------
+
+    //! Return the width of the display window, as a signed integer.
+    /** \note When working with resizing window, \p dimx() does not necessarily return the width of the resized window,
+        but the width of the internal data structure that can be used to display image.
+        Resizing a display window can be done with the function CImgDisplay::resize().
+      
+        \see CImgDisplay::width, CImgDisplay::dimy(), CImgDisplay::resize()     
+    **/
+    const int dimx() const { return (int)width; }
+
+    //! Return the height of the display window, as a signed integer.
+    /** \note When working with resizing window, \p dimy() does not necessarily return the height of the resized window,
+        but the height of the internal data structure that can be used to display image.
+        Resizing a display window can be done with the function CImgDisplay::resize().
+      
+        \see CImgDisplay::height, CImgDisplay::dimx(), CImgDisplay::resize()     
+    **/
+    const int dimy() const { return (int)height; }
+
+    // operator=(). It is actually defined to avoid its use, and throw a CImgDisplay exception.
+    CImgDisplay& operator=(const CImgDisplay&) {
+      throw CImgDisplayException("CImgDisplay()::operator=() : Assignement of CImgDisplay is not allowed. Use pointers instead !");
+      return *this;
+    }
+    
+    //! Synchronized waiting function. Same as cimg::wait().
+    /** \see cimg::wait()
+     **/
+      const CImgDisplay& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this; }
+
+    //! Display an image list CImgl<T> into a display window.
+    /** First, all images of the list are appended into a single image used for visualization,
+        then this image is displayed in the current display window.
+        \param list     : The list of images to display.
+        \param axe      : The axe used to append the image for visualization. Can be 'x' (default),'y','z' or 'v'.
+        \param align : Defines the relative alignment of images when displaying images of different sizes.
+        Can be '\p c' (centered, which is the default), '\p p' (top alignment) and '\p n' (bottom aligment).
+
+        \see CImg::append()
+    **/
+    template<typename T> CImgDisplay& display(const CImgl<T>& list,const char axe='x',const char align='c') { 
+      return display(list.get_append(axe,align)); 
+    } 
+
+    //! Resize a display window with the size of an image.
+    /** \param img    : Input image. \p image.width and \p image.height give the new dimensions of the display window.
+        \param redraw : If \p true (default), the current displayed image in the display window will
+        be bloc-interpolated to fit the new dimensions. If \p false, a black image will be drawn in the resized window.
+        \param force  : If \p true, the window size is effectively set to the specified dimensions (default).
+        If \p false, only internal data buffer to display images is resized, not the window itself.
+      
+        \see CImgDisplay::resized, CImgDisplay::resizedimx(), CImgDisplay::resizedimy()
+    **/
+    template<typename T> CImgDisplay& resize(const CImg<T>& img,const bool redraw=false,const bool force=true) { 
+      return resize(img.width,img.height,redraw,force); 
+    }
+
+    CImgDisplay& resize(const CImgDisplay& disp,const bool redraw=false,const bool force=true) {
+      return resize(disp.width,disp.height,redraw,force);
+    }
+
+    CImgDisplay& resize(const bool redraw=false,const bool force=false) {
+      resize(window_width,window_height,redraw,force);
+      return *this;
+    }
+
+    // When no display available
+    //---------------------------
+#if cimg_display_type==0
+    void nodisplay_available() {
+      static bool first = true;
+      if (first) {
+        cimg::warn(true,"CImgDisplay() : Display has been required but is not available (cimg_display_type=0)");
+        first = false;
+      }    
+    }  
+    //! Create a display window with a specified size \p pwidth x \p height.
+    /** \param width      : Width of the display window.
+        \param height     : Height of the display window.
+        \param title      : Title of the display window.
+        \param normalization_type  : Normalization type of the display window (see CImgDisplay::normalize).
+        \param attributes : Attributes of the display window (see CImgDisplay::attributes).
+      
+        A black image will be initially displayed in the display window.
+    **/
+    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
+      nodisplay_available(); 
+    }
+
+    //! Create a display window from an image.
+    /** \param img        : Image that will be used to create the display window.
+        \param title      : Title of the display window
+        \param normalize  : Normalization type of the display window (see CImgDisplay::normalize).
+        \param attributes : Attributes of the display window (see CImgDisplay::attributes).    
+    **/
+    template<typename T> 
+    CImgDisplay(const CImg<T>& img,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
+      nodisplay_available(); 
+    }
+
+    //! Create a display window from an image list.
+    /** \param list       : The list of images to display.
+        \param title      : Title of the display window
+        \param normalize  : Normalization type of the display window (see CImgDisplay::normalize).
+        \param attributes : Attributes of the display window (see CImgDisplay::attributes).     
+    **/
+    template<typename T> 
+    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
+      nodisplay_available(); 
+    }
+  
+    //! Create a display window by copying another one.
+    /** \param win   : Display window to copy.
+        \param title : Title of the new display window.
+    **/
+    CImgDisplay(const CImgDisplay& win, char *title=NULL):fullscreen(false) { nodisplay_available(); }
+
+    //! Resize a display window with new dimensions \p width and \p height.
+    CImgDisplay& resize(const int width, const int height,const bool redraw=false,const bool force=true) {
+      return *this; 
+    }
+    //! Destructor. Close and destroy a display.
+    ~CImgDisplay() {}
+    //! Fill the pixel data of the window buffer according to the image \p pimg.
+    template<typename T> void render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {}
+    //! Display an image in a window.
+    template<typename T> CImgDisplay& display(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=-1) { return *this; }
+    //! Wait for a window event
+    CImgDisplay& wait()  { return *this; }
+    //! Show a closed display
+    CImgDisplay& show()  { return *this; }
+    //! Close a visible display
+    CImgDisplay& close() { return *this; }
+  
+    // X11-based display
+    //------------------
+#elif cimg_display_type==1
+    unsigned long *data;
+    XImage *image;
+    Window window;
+  
+    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):
+      width(dimw),height(dimh),window_width(dimw),window_height(dimh),
+      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
+      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
+      new_lowlevel(title);
+      std::memset(data,0,sizeof(unsigned long)*width*height);
+      pthread_mutex_lock(cimg::X11_mutex);
+      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
+      XFlush(cimg::X11_display);
+      pthread_mutex_unlock(cimg::X11_mutex);
+    }
+
+    template<typename T> 
+    CImgDisplay(const CImg<T>& img,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):
+      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
+      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
+      cimg_test(img,"CImgDisplay::CImgDisplay");
+      CImg<T> tmp;
+      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_3dplanes(img.width/2,img.height/2,img.depth/2));
+      window_width  = width  = nimg.width;
+      window_height = height = nimg.height;
+      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
+      new_lowlevel(title);
+      display(nimg);
+    }
+
+    template<typename T> 
+    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):
+      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
+      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
+      cimgl_test(list,"CImgDisplay::CImgDisplay");
+      CImg<T> tmp;
+      const CImg<T> img0 = list.get_append('x'), 
+        &img = (img0.depth==1)?img0:(tmp=img0.get_3dplanes(img0.width/2,img0.height/2,img0.depth/2));
+      window_width  = width  = img.width; 
+      window_height = height = img.height;
+      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
+      new_lowlevel(title);
+      display(img);
+    }
+
+    CImgDisplay(const CImgDisplay& win, char *title="[Copy]"):
+      width(win.width),height(win.height),window_width(width),window_height(height),
+      normalization(win.normalization),events(win.events),fullscreen(win.fullscreen),
+      mousex(-1),mousey(-1),button(0),key(0),closed(win.closed),resized(false),min(win.min),max(win.max) {
+      new_lowlevel(title);
+      std::memcpy(data,win.data,sizeof(unsigned long)*width*height);
+      pthread_mutex_lock(cimg::X11_mutex);
+      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
+      XFlush(cimg::X11_display);
+      pthread_mutex_unlock(cimg::X11_mutex);
+    }
+
+    CImgDisplay& resize(const int nwidth, const int nheight,const bool redraw=false,const bool force=true) {
+      const unsigned int
+        dimx=nwidth>0?nwidth:-width*nwidth/100,
+        dimy=nheight>0?nheight:-height*nheight/100;
+      if (!dimx || !dimy) return *this;
+      pthread_mutex_lock(cimg::X11_mutex);
+      if (dimx!=width || dimy!=height) {
+        unsigned long *ndata = new unsigned long[dimx*dimy];
+        if (redraw)
+          for (unsigned int y=0; y<dimy; y++) for (unsigned int x=0; x<dimx; x++) ndata[x+y*dimx] = data[x*width/dimx + width*(y*height/dimy)];
+        else std::memset(ndata,0,sizeof(unsigned long)*dimx*dimy);
+        data = ndata;
+        XDestroyImage(image);
+        image = XCreateImage(cimg::X11_display,DefaultVisual(cimg::X11_display,DefaultScreen(cimg::X11_display)),
+                             cimg::X11_nb_bits,ZPixmap,0,(char*)data,dimx,dimy,8,0);
+      }
+      width  = dimx;
+      height = dimy;
+      if (force && (window_width!=width || window_height!=height)) {
+        XResizeWindow(cimg::X11_display,window,width,height);
+        window_width  = width;
+        window_height = height;
+      }
+      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
+      XFlush(cimg::X11_display);
+      resized = false;
+      pthread_mutex_unlock(cimg::X11_mutex);
+      return *this;
+    }
+  
+    ~CImgDisplay() {
+      unsigned int i;
+      pthread_mutex_lock(cimg::X11_mutex);
+      for (i=0; i<cimg::X11_nb_wins && cimg::X11_wins[i]!=this; i++) i++;
+      for (; i<cimg::X11_nb_wins-1; i++) cimg::X11_wins[i]=cimg::X11_wins[i+1];
+      cimg::X11_nb_wins--;
+      XDestroyWindow(cimg::X11_display,window);
+      XDestroyImage(image);
+      if (!cimg::X11_nb_wins) {
+        pthread_cancel(*cimg::X11_event_thread);
+        pthread_join(*cimg::X11_event_thread,NULL);
+        XCloseDisplay(cimg::X11_display);
+        cimg::X11_display=NULL;
+        pthread_mutex_unlock(cimg::X11_mutex);
+        pthread_mutex_destroy(cimg::X11_mutex);
+        delete cimg::X11_event_thread;
+        delete cimg::X11_mutex;
+        delete cimg::X11_gc;
+      } else pthread_mutex_unlock(cimg::X11_mutex);
+    }
+  
+    void new_lowlevel(const char *title=NULL) {
+      cimg::warn(fullscreen,"CImgDisplay::new_lowlevel() : Fullscreen mode requested, but not supported on X11 Displays");
+      if (!cimg::X11_display) {
+        cimg::X11_nb_wins = 0;
+        cimg::X11_thread_finished = false;
+        cimg::X11_mutex = new pthread_mutex_t;
+        pthread_mutex_init(cimg::X11_mutex,NULL);
+        pthread_mutex_lock(cimg::X11_mutex);
+        cimg::X11_display = XOpenDisplay((getenv("DISPLAY") ? getenv("DISPLAY") : ":0.0"));
+        if (!cimg::X11_display) throw CImgDisplayException("CImgDisplay::new_lowlevel() : Can't open X11 display");
+        cimg::X11_nb_bits = DefaultDepth(cimg::X11_display, DefaultScreen(cimg::X11_display));
+        if (cimg::X11_nb_bits!=16 && cimg::X11_nb_bits!=24)
+          throw CImgDisplayException("CImgDisplay::new_lowlevel() : %u bits mode is not supported (only 16 and 24 bits are supported)",
+                                     cimg::X11_nb_bits);
+        cimg::X11_gc = new GC;
+        *cimg::X11_gc = DefaultGC(cimg::X11_display,DefaultScreen(cimg::X11_display));
+        Visual *visual = DefaultVisual(cimg::X11_display,0);
+	XVisualInfo vtemplate;
+	vtemplate.visualid = XVisualIDFromVisual(visual);
+	int nb_visuals;
+	XVisualInfo *vinfo = XGetVisualInfo(cimg::X11_display,VisualIDMask,&vtemplate,&nb_visuals);
+	if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11_colors_endian = true;
+        cimg::X11_event_thread = new pthread_t;
+        pthread_create(cimg::X11_event_thread,NULL,thread_lowlevel,NULL);
+      } else pthread_mutex_lock(cimg::X11_mutex);
+      window = XCreateSimpleWindow(cimg::X11_display,RootWindow(cimg::X11_display,DefaultScreen(cimg::X11_display)),0,0,width,height,2,0,0x0L);
+      data   = new unsigned long[width*height];
+      image  = XCreateImage(cimg::X11_display,DefaultVisual(cimg::X11_display,DefaultScreen(cimg::X11_display)),cimg::X11_nb_bits,ZPixmap,0,(char*)data,width,height,8,0);
+      XStoreName(cimg::X11_display,window,title?title:"");
+      if (!closed) {
+        XEvent event;
+        XSelectInput(cimg::X11_display,window,StructureNotifyMask);
+        XMapWindow(cimg::X11_display,window);
+        do XWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event); while (event.type!=MapNotify);
+      }
+      if (events) { 
+        Atom atom = XInternAtom(cimg::X11_display, "WM_DELETE_WINDOW", False); 
+        XSetWMProtocols(cimg::X11_display, window, &atom, 1); 
+      }
+      cimg::X11_wins[cimg::X11_nb_wins++]=this;
+      pthread_mutex_unlock(cimg::X11_mutex);
+    }
+  
+    void proc_lowlevel(XEvent *pevent) {
+      const unsigned int buttoncode[3] = { 1,4,2 };
+      XEvent event=*pevent;
+      switch (event.type) {
+      case ClientMessage:
+        XUnmapWindow(cimg::X11_display,window);
+        mousex=mousey=-1; 
+	button=key=0;
+	closed=true; 
+        break;
+     case ConfigureNotify: {
+        while (XCheckWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event));
+        const unsigned int nw = event.xconfigure.width, nh = event.xconfigure.height;
+        if (nw && nh && (nw!=window_width || nh!=window_height)) { 
+          window_width = nw; 
+          window_height = nh; 
+	  mousex = mousey = -1;
+	  //button = key=0;
+          XResizeWindow(cimg::X11_display,window,window_width,window_height);
+          resized = true;
+        }
+      } break;
+      case Expose:
+        while (XCheckWindowEvent(cimg::X11_display,window,ExposureMask,&event));
+        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
+        break;
+      case ButtonPress:
+        while (XCheckWindowEvent(cimg::X11_display,window,ButtonPressMask,&event));
+        button |= buttoncode[event.xbutton.button-1];
+        break;
+      case ButtonRelease:
+        while (XCheckWindowEvent(cimg::X11_display,window,ButtonReleaseMask,&event));
+        button &= ~buttoncode[event.xbutton.button-1];
+        break;
+      case KeyPress: {
+        while (XCheckWindowEvent(cimg::X11_display,window,KeyPressMask,&event));
+	char tmp;
+	KeySym ksym;
+	XLookupString(&event.xkey,&tmp,1,&ksym,NULL);
+	key = (unsigned int)ksym;
+      }
+        break;
+      case KeyRelease:
+        while (XCheckWindowEvent(cimg::X11_display,window,KeyReleaseMask,&event));
+        key = 0;
+        break;
+      case LeaveNotify:
+        while (XCheckWindowEvent(cimg::X11_display,window,LeaveWindowMask,&event));
+        mousex = mousey =-1; 
+        break;
+      case MotionNotify:
+        while (XCheckWindowEvent(cimg::X11_display,window,PointerMotionMask,&event));
+        mousex = event.xmotion.x; 
+        mousey = event.xmotion.y;
+        if (mousex<0 || mousey<0 || mousex>=dimx() || mousey>=dimy()) mousex=mousey=-1; 
+        break;
+      }
+    }
+  
+    static void* thread_lowlevel(void *arg) {
+      XEvent event;
+      pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL);
+      for (;;) {
+        pthread_mutex_lock(cimg::X11_mutex);
+        for (unsigned int i=0; i<cimg::X11_nb_wins; i++) {
+          const unsigned int xevent_type = (cimg::X11_wins[i]->events)&3;
+          const unsigned int emask =
+            ((xevent_type>=1)?ExposureMask|StructureNotifyMask:0)|
+            ((xevent_type>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
+            ((xevent_type>=3)?ButtonReleaseMask|KeyReleaseMask:0);
+          XSelectInput(cimg::X11_display,cimg::X11_wins[i]->window,emask);
+        }
+        bool event_flag = XCheckTypedEvent(cimg::X11_display, ClientMessage, &event);
+        if (!event_flag) event_flag = XCheckMaskEvent(cimg::X11_display,
+                                                      ExposureMask|StructureNotifyMask|ButtonPressMask|
+                                                      KeyPressMask|PointerMotionMask|LeaveWindowMask|ButtonReleaseMask|
+                                                      KeyReleaseMask,&event);
+        if (event_flag) {
+          for (unsigned int i=0; i<cimg::X11_nb_wins; i++)
+            if (!cimg::X11_wins[i]->closed && event.xany.window==cimg::X11_wins[i]->window) cimg::X11_wins[i]->proc_lowlevel(&event);
+          cimg::X11_thread_finished = true;
+        }
+        pthread_mutex_unlock(cimg::X11_mutex);
+        cimg::wait(25);
+      }
+      return NULL;
+    }
+
+    template<typename T> XImage* render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {
+      cimg_test(img,"CImgDisplay::render");
+      if (img.depth!=1) return render(img.get_3dplanes(img.width/2,img.height/2,img.depth/2),0,~0);
+      if (img.width!=width || img.height!=height) return render(img.get_resize(width,height,1,-100,1),0,~0);
+      const bool by=(ymin<=ymax);
+      const unsigned int nymin = by?ymin:ymax, nymax = by?(ymax>=height?height-1:ymax):(ymin>=height?height-1:ymin), w=width;
+      const T 
+        *data1 = img.ptr(0,nymin,0,0),
+        *data2 = (img.dim>=2)?img.ptr(0,nymin,0,1):data1,
+        *data3 = (img.dim>=3)?img.ptr(0,nymin,0,2):data1;
+      if (cimg::X11_colors_endian) cimg::swap(data1,data3);
+      pthread_mutex_lock(cimg::X11_mutex);
+      XImage *ximg = image;
+      if (!normalization) {
+        switch (cimg::X11_nb_bits) {
+        case 16: 
+          for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
+            XPutPixel(ximg,x,y,(((unsigned char)*(data1++)>>3)<<11) | (((unsigned char)*(data2++)>>2)<<5) | ((unsigned char)*(data3++)>>3)); 
+          }
+          break;
+        case 24: 
+          for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
+            XPutPixel(ximg,x,y,((unsigned char)*(data1++)<<16)      | ((unsigned char)*(data2++)<<8)      | (unsigned char)*(data3++)     ); 
+          }
+          break;
+        };
+      } else {
+        if (normalization==1) { CImgStats st(img,false); min=st.min; max=st.max; }
+        const T nmin = (T)min, delta = (T)max-nmin, mm=delta?delta:(T)1;
+        switch (cimg::X11_nb_bits) {
+        case 16: for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
+            const unsigned char
+              val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
+              val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
+              val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
+            XPutPixel(ximg,x,y,((val1>>3)<<11) | ((val2>>2)<<5) | (val3>>3));
+          }
+          break;
+        case 24: for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
+            const unsigned char
+              val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
+              val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
+              val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
+            XPutPixel(ximg,x,y,(val1<<16) | (val2<<8) | val3);
+          }
+          break;
+        } 
+      }
+      pthread_mutex_unlock(cimg::X11_mutex);
+      return image;
+    }
+
+    template<typename T> CImgDisplay& display(const CImg<T>& pimg,const unsigned int pymin=0,const unsigned int pymax=~0) {
+      const unsigned int
+        ymin = pymin<pymax?pymin:pymax,
+        ymax = pymin<pymax?(pymax>=height?height-1:pymax):(pymin>=height?height-1:pymin);
+      render(pimg,ymin,ymax);
+      if (!closed) {      
+        pthread_mutex_lock(cimg::X11_mutex);
+        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,ymin,0,ymin,width,ymax-ymin+1);
+        XFlush(cimg::X11_display);
+        pthread_mutex_unlock(cimg::X11_mutex);
+      }
+      return *this;
+    }
+  
+    CImgDisplay& wait() {
+      if (!closed && events) {
+        XEvent event;
+        do {
+          pthread_mutex_lock(cimg::X11_mutex);
+          const unsigned int 
+            emask = ExposureMask|StructureNotifyMask|
+            ((events>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
+            ((events>=3)?ButtonReleaseMask|KeyReleaseMask:0);
+          XSelectInput(cimg::X11_display,window,emask);
+          XPeekEvent(cimg::X11_display,&event);
+          cimg::X11_thread_finished = false;
+          pthread_mutex_unlock(cimg::X11_mutex);
+        } while (event.xany.window!=window);
+        while (!cimg::X11_thread_finished) cimg::wait(25);
+      }
+      return *this;
+    }
+
+    CImgDisplay& show() {
+      if (closed) {
+        pthread_mutex_lock(cimg::X11_mutex);
+        XEvent event;
+        XSelectInput(cimg::X11_display,window,StructureNotifyMask);
+        XMapWindow(cimg::X11_display,window);
+        do XWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event);
+        while (event.type!=MapNotify);
+        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
+        XFlush(cimg::X11_display);
+        closed = false;
+        pthread_mutex_unlock(cimg::X11_mutex);
+      }
+      return *this;
+    }
+    CImgDisplay& close() {
+      if (!closed) {
+        pthread_mutex_lock(cimg::X11_mutex);
+        XUnmapWindow(cimg::X11_display,window);
+        XFlush(cimg::X11_display);
+        closed = true;
+        pthread_mutex_unlock(cimg::X11_mutex);
+      }
+      return *this;
+    }
+  
+    // Windows-based display
+    //-----------------------
+#elif cimg_display_type==2
+    CLIENTCREATESTRUCT ccs;
+    BITMAPINFO bmi;
+    unsigned int *data;
+    DEVMODE curr_mode;
+    HWND window;
+    HDC hdc;
+    HANDLE thread;
+    HANDLE wait_disp;
+    HANDLE created;
+    HANDLE mutex;
+
+    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):
+      width(dimw),height(dimh),window_width(dimw),window_height(dimh),
+      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
+      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
+      new_lowlevel(title);
+      std::memset(data,0,sizeof(unsigned int)*width*height);
+      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
+    }
+
+    template<typename T>
+    CImgDisplay(const CImg<T>& img,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):
+      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
+      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
+      cimg_test(img,"CImgDisplay::CImgDisplay");
+      CImg<T> tmp;
+      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_3dplanes(img.width/2,img.height/2,img.depth/2));
+      window_width  = width  = nimg.width;
+      window_height = height = nimg.height;
+      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
+      new_lowlevel(title);
+      display(nimg);
+    }
+
+    template<typename T>
+    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
+                const unsigned int normalization_type=1,const unsigned int events_type=3,
+                const bool fullscreen_flag=false,const bool closed_flag=false):
+      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
+      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
+      cimgl_test(list,"CImgDisplay::CImgDisplay");
+      CImg<T> tmp;
+      const CImg<T> img0 = list.get_append('x'),
+        &img = (img0.depth==1)?img0:(tmp=img0.get_3dplanes(img0.width/2,img0.height/2,img0.depth/2));
+      window_width  = width  = img.width;
+      window_height = height = img.height;
+      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
+      new_lowlevel(title);
+      display(img);
+    }
+
+    CImgDisplay(const CImgDisplay& win, char *title="[Copy]"):
+      width(win.width),height(win.height),window_width(win.width),window_height(win.height),
+      normalization(win.normalization),events(win.events),fullscreen(win.fullscreen),
+      mousex(-1),mousey(-1),button(0),key(0),closed(win.closed),resized(false),min(win.min),max(win.max) {
+      new_lowlevel(title);
+      std::memcpy(data,win.data,sizeof(unsigned int)*width*height);
+      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
+    }
+
+    CImgDisplay& resize(const int nwidth, const int nheight,const bool redraw=false,const bool force=true) {
+      const unsigned int
+        dimx=nwidth>0?nwidth:(-nwidth)*width/100,
+        dimy=nheight>0?nheight:(-nheight)*height/100;
+      if (!dimx || !dimy) return *this;
+      if (dimx!=width || dimy!=height) {
+        unsigned int *ndata = new unsigned int[dimx*dimy];
+        if (redraw) 
+          for (unsigned int y=0; y<dimy; y++) for (unsigned int x=0; x<dimx; x++) ndata[x+y*dimx] = data[x*width/dimx + width*(y*height/dimy)];
+        else std::memset(ndata,0x80,sizeof(unsigned int)*dimx*dimy);
+        delete[] data;
+        data = ndata;
+        bmi.bmiHeader.biWidth=dimx;
+        bmi.bmiHeader.biHeight=-(int)dimy;
+      }
+      width  = dimx;
+      height = dimy;
+      if (force && (window_width!=width || window_height!=height)) {
+        int cwidth,cheight;
+        RECT rect;
+        rect.left=rect.top=0; rect.right=width-1; rect.bottom=height-1;
+        if (AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false)) {
+          cwidth = rect.right-rect.left+1; cheight = rect.bottom-rect.top+1;
+        } else { cwidth = width+9; cheight = height+28; }
+        SetWindowPos(window,0,0,0,cwidth,cheight,SWP_NOMOVE | SWP_NOZORDER | SWP_NOCOPYBITS);
+        window_width  = dimx;
+        window_height = dimy;
+      }
+      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
+      resized = false;
+      return *this;
+    }
+
+    ~CImgDisplay() {
+      DestroyWindow(window);
+      if (events) TerminateThread(thread,0);
+      delete[] data;
+      if (curr_mode.dmSize) ChangeDisplaySettings(&curr_mode,0);
+    }
+  
+    void new_lowlevel(const char *title=NULL) {
+      unsigned long ThreadID;
+      DEVMODE mode;
+      unsigned int imode=0,ibest=0,bestbpp=0;
+      void *arg = (void*)(new void*[2]);
+      ((void**)arg)[0]=(void*)this;
+      ((void**)arg)[1]=(void*)title;
+      if (fullscreen) {
+        for (mode.dmSize = sizeof(DEVMODE), mode.dmDriverExtra = 0; EnumDisplaySettings(NULL,imode,&mode); imode++)
+          if (mode.dmPelsWidth==width && mode.dmPelsHeight==height && mode.dmBitsPerPel>bestbpp) {
+            bestbpp = mode.dmBitsPerPel;
+            ibest=imode; 
+          }
+        cimg::warn(!bestbpp,"CImgDisplay::new_lowlevel() : Could not initialize fullscreen mode %ux%u\n",width,height);
+        if (bestbpp) {
+          curr_mode.dmSize = sizeof(DEVMODE); curr_mode.dmDriverExtra = 0;
+          EnumDisplaySettings(NULL,ENUM_CURRENT_SETTINGS,&curr_mode);
+          EnumDisplaySettings(NULL,ibest,&mode);
+          ChangeDisplaySettings(&mode,0);
+        }
+        else curr_mode.dmSize = 0;
+      }
+      else curr_mode.dmSize = 0;
+      if (events) {
+        mutex     = CreateMutex(NULL,FALSE,NULL);
+        created   = CreateEvent(NULL,FALSE,FALSE,NULL);
+        wait_disp = CreateEvent(NULL,FALSE,FALSE,NULL);
+        thread    = CreateThread(NULL,0,thread_lowlevel,arg,0,&ThreadID);
+        WaitForSingleObject(created,INFINITE);
+      } else thread_lowlevel(arg);
+    }
+  
+    static LRESULT APIENTRY proc_lowlevel(HWND window,UINT msg,WPARAM wParam,LPARAM lParam) {
+      CImgDisplay* disp = (CImgDisplay*)GetWindowLong(window,GWL_USERDATA);
+      MSG st_msg;
+
+      switch(msg) {
+      case WM_CLOSE:
+	disp->mousex=disp->mousey=-1;
+	disp->key=disp->button=0;
+        disp->closed=true;
+        ReleaseMutex(disp->mutex);
+        ShowWindow(disp->window,SW_HIDE);
+        return 0;
+      case WM_SIZE: {
+        while (PeekMessage(&st_msg,window,WM_SIZE,WM_SIZE,PM_REMOVE));
+        WaitForSingleObject(disp->mutex,INFINITE);
+        const unsigned int nw = LOWORD(lParam), nh = HIWORD(lParam);
+        if (nw && nh && (nw!=disp->width || nh!=disp->height)) { 
+          disp->window_width  = nw; 
+          disp->window_height = nh;
+	  disp->mousex = disp->mousey = -1;
+          disp->resized = true;
+        }
+        ReleaseMutex(disp->mutex);
+      }
+        break;
+      case WM_PAINT:
+        WaitForSingleObject(disp->mutex,INFINITE);
+        SetDIBitsToDevice(disp->hdc,0,0,disp->width,disp->height,0,0,0,disp->height,disp->data,&(disp->bmi),DIB_RGB_COLORS);
+        ReleaseMutex(disp->mutex);
+        break;
+      }
+      if (disp->events>=2) switch(msg) {
+      case WM_KEYDOWN:
+        while (PeekMessage(&st_msg,window,WM_KEYDOWN,WM_KEYDOWN,PM_REMOVE)); 
+        disp->key=(int)wParam;
+        break;
+      case WM_MOUSEMOVE: {
+        while (PeekMessage(&st_msg,window,WM_MOUSEMOVE,WM_MOUSEMOVE,PM_REMOVE));
+        disp->mousex = LOWORD(lParam);
+        disp->mousey = HIWORD(lParam);
+        if (disp->mousex<0 || disp->mousey<0 ||	disp->mousex>=disp->dimx() || disp->mousey>=disp->dimy())
+	  disp->mousex=disp->mousey=-1;
+      }
+        break;
+      case WM_LBUTTONDOWN: 
+        while (PeekMessage(&st_msg,window,WM_LBUTTONDOWN,WM_LBUTTONDOWN,PM_REMOVE));
+        disp->button |= 1; 
+        break;
+      case WM_RBUTTONDOWN: 
+        while (PeekMessage(&st_msg,window,WM_RBUTTONDOWN,WM_RBUTTONDOWN,PM_REMOVE));
+        disp->button |= 2; 
+        break;
+      case WM_MBUTTONDOWN: 
+        while (PeekMessage(&st_msg,window,WM_MBUTTONDOWN,WM_MBUTTONDOWN,PM_REMOVE));
+        disp->button |= 4; 
+        break;
+      }
+      if (disp->events>=3) switch(msg) {
+      case WM_KEYUP:
+        while (PeekMessage(&st_msg,window,WM_KEYUP,WM_KEYUP,PM_REMOVE));
+        disp->key=0;
+        break;
+      case WM_LBUTTONUP:
+        while (PeekMessage(&st_msg,window,WM_LBUTTONUP,WM_LBUTTONUP,PM_REMOVE));
+        disp->button &= ~1; 
+        break;
+      case WM_RBUTTONUP:
+        while (PeekMessage(&st_msg,window,WM_RBUTTONUP,WM_RBUTTONUP,PM_REMOVE)); 
+        disp->button &= ~2;
+        break;
+      case WM_MBUTTONUP:
+        while (PeekMessage(&st_msg,window,WM_MBUTTONUP,WM_MBUTTONUP,PM_REMOVE)); 
+        disp->button &= ~4;
+        break;
+      }
+      return DefWindowProc(window,msg,wParam,lParam);
+    }
+  
+    static DWORD WINAPI thread_lowlevel(void* arg) {
+      CImgDisplay *disp  = (CImgDisplay*)(((void**)arg)[0]);
+      const char *title = (const char*)(((void**)arg)[1]);
+      MSG msg;
+      delete[] (void**)arg;
+      disp->bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
+      disp->bmi.bmiHeader.biWidth=disp->width;
+      disp->bmi.bmiHeader.biHeight=-(int)disp->height;
+      disp->bmi.bmiHeader.biPlanes=1;
+      disp->bmi.bmiHeader.biBitCount=32;
+      disp->bmi.bmiHeader.biCompression=BI_RGB;
+      disp->bmi.bmiHeader.biSizeImage=0;
+      disp->bmi.bmiHeader.biXPelsPerMeter=1;
+      disp->bmi.bmiHeader.biYPelsPerMeter=1;
+      disp->bmi.bmiHeader.biClrUsed=0;
+      disp->bmi.bmiHeader.biClrImportant=0;
+      disp->data = new unsigned int[disp->width*disp->height];
+      if (!disp->curr_mode.dmSize) {
+        int cwidth,cheight;
+        RECT rect;
+        rect.left=rect.top=0; rect.right=disp->width-1; rect.bottom=disp->height-1;
+        if (AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false)) {
+          cwidth = rect.right-rect.left+1; cheight = rect.bottom-rect.top+1;
+        } else { cwidth = disp->width+9; cheight = disp->height+28; }
+        disp->window = CreateWindow("MDICLIENT",title?title:"",
+                                    WS_OVERLAPPEDWINDOW | WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,
+                                    cwidth,cheight,NULL,NULL,NULL,&(disp->ccs));
+      }
+      else disp->window = CreateWindow("MDICLIENT",title?title:"",
+                                       WS_POPUP | WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,
+                                       disp->width,disp->height,NULL,NULL,NULL,&(disp->ccs));
+      SetForegroundWindow(disp->window);
+      disp->hdc = GetDC(disp->window);
+      if (disp->events) {
+        SetWindowLong(disp->window,GWL_USERDATA,(LONG)disp);
+        SetWindowLong(disp->window,GWL_WNDPROC,(LONG)proc_lowlevel);
+        SetEvent(disp->created);
+        while( GetMessage( &msg, NULL, 0, 0 ) ) { DispatchMessage( &msg ); SetEvent(disp->wait_disp); }
+      }
+      return 0;
+    }
+
+    template<typename T> BITMAPINFO* render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {
+      cimg_test(img,"CImgDisplay::render");
+      if (img.depth!=1) return render(img.get_3dplanes(img.width/2,img.height/2,img.depth/2),(unsigned int)0,~(unsigned int)0);
+      if (img.width!=width || img.height!=height) return render(img.get_resize(width,height,1,-100,1),(unsigned int)0,~(unsigned int)0);
+      const bool by=(ymin<=ymax);
+      const unsigned int nymin = by?ymin:ymax, nymax = by?(ymax>=height?height-1:ymax):(ymin>=height?height-1:ymin), w=width;
+      const T 
+        *data1 = img.ptr(0,nymin,0,0),
+        *data2 = (img.dim>=2)?img.ptr(0,nymin,0,1):data1,
+        *data3 = (img.dim>=3)?img.ptr(0,nymin,0,2):data1;
+      unsigned int *ximg = data + nymin*width;
+      WaitForSingleObject(mutex,INFINITE);
+      if (!normalization)
+        for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++)
+          *(ximg++) = ((unsigned char)*(data1++)<<16) | ((unsigned char)*(data2++)<<8) | (unsigned char)*(data3++);
+      else {
+        if (normalization==1) { CImgStats st(img,false); min=st.min; max=st.max; }
+        const T nmin = (T)min, delta = (T)(max-nmin), mm = delta?delta:(T)1;
+        for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
+          const unsigned char
+            val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
+            val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
+            val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
+          *(ximg++) = (val1<<16) | (val2<<8) | (val3);
+        }
+      }
+      ReleaseMutex(mutex);
+      return &bmi;
+    }
+
+    template<typename T> CImgDisplay& display(const CImg<T>& img,const unsigned int pymin=0,const unsigned int pymax=~0) {
+      cimg_test(img,"CImgDisplay::display");
+      const unsigned int 
+        ymin = pymin<pymax?pymin:pymax,
+        ymax = pymin<pymax?(pymax>=height?height-1:pymax):(pymin>=height?height-1:pymin);
+      render(img,ymin,ymax);
+      if (!closed) {
+        WaitForSingleObject(mutex,INFINITE);
+        SetDIBitsToDevice(hdc,0,ymin,width,ymax-ymin+1,0,0,0,ymax-ymin+1,data+ymin*width,&bmi,DIB_RGB_COLORS);
+        ReleaseMutex(mutex);
+      }
+      return *this;
+    }
+  
+    CImgDisplay& wait() {
+      if (!closed && events) WaitForSingleObject(wait_disp,INFINITE);
+      return *this;
+    }
+
+    CImgDisplay& show() {
+      if (closed) {
+        ShowWindow(window,SW_SHOW);
+        SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
+        closed = false;
+      }
+      return *this;
+    }
+
+    CImgDisplay& close() {
+      if (!closed) {
+        ShowWindow(window,SW_HIDE);
+        closed = true;
+      }
+      return *this;
+    }
+#endif
+
+#ifdef cimgdisplay_plugin
+#include cimgdisplay_plugin
+#endif
+ 
+  };
+
+
+  /*-------------------------------------------------------
+
+
+
+  
+    Definition of the CImg<T> structure
+	
+	
+	
+	
+  ------------------------------------------------------*/
+
+  //! This structure represents an image (up to 4 dimensions wide), with pixels of type \c T.
+  /**
+     This is the main structure of the CImg Library. It allows to define an image,
+     access its pixel values, and perform various operations on it.
+
+     <b>* Image structure</b>
+
+     A \ref CImg<\c T> structure contains only five fields :
+     - \ref width defines the number of columns of the image.
+     - \ref height defines the number of rows of the image.
+     - \ref depth defines the number of slices of the image.
+     - \ref dim defines the number of channels of the image.
+     - \ref data defines a pointer to the pixel data (of type \c T).
+     
+     You can access these fields publicly although it is recommended to use dedicated functions
+     dimx(), dimy(), dimz(), dimv() and ptr() to do so.     
+     Image dimensions are not limited to a specific range (as long as you got enough RAM).
+     A value of \e 1 usually means that the corresponding dimension is 'flat'.
+     If one dimension is \e 0, the image is considered as an \e empty image.
+     Empty images do not contain pixel data and thus, are not processed by most of CImg member functions.
+     Most of the CImg<T> member functions are designed to work on images with general dimensions.     
+
+     <b>* Image declaration</b>
+
+     Declaration of an image uses one of the several available constructors. Below is a list of
+     the most used :
+     - Construct images from dimensions :
+         - <tt>CImg<char> img;</tt> constructs an empty image.
+         - <tt>CImg<unsigned char> img(128,128);</tt> constructs a 128x128 greyscale image with \c unsigned \c char pixel values.
+         - <tt>CImg<double> img(3,3);</tt> constructs  a 3x3 matrix with \c double coefficients.
+         - <tt>CImg<unsigned char> img(256,256,1,3);</tt> for a 256x256x1x3 (color) image (colors are stored as three channels).
+         - <tt>CImg<double> img(128,128,128);</tt> for a 128x128x128 volumetric (greyscale) image (with \c double pixel values).
+         - <tT>CImg<> img(128,128,128,3);</tt> for a 128x128x128 volumetric color image (with \c float pixels, which is
+	 the default value of the template parameter \c T).
+	 - \b Note : images pixels are <b>not automatically initialized to 0</b>. You may use the function \ref fill() to
+	 do it.
+     - Construct images from filenames :
+         - <tt>CImg<unsigned char> img("image.jpg");</tt> reads a color image from the disk.
+	 - <tt>CImg<float> img("analyze.hdr");</tt> reads a volumetric image with float pixel (ANALYZE7.5 format).
+	 - \b Note : You will need to install ImageMagick to be able to read compressed image formats (JPG,PNG,...)
+     - Construct images from C-arrays :
+         - <tt>CImg<int> img(data_buffer,256,256);</tt> convert a \c int buffer \c data_buffer to a 256x256 greyscale image.     
+
+     More constructors are available (copy constructor,...). Please look at the constructor list for more
+     informations.
+
+  
+  A CImg image is defined as a template class CImg<T> containing a pixel data field with a maximum of 4 dimensions :
+  the 3 first dimensions are usually used to describe the spatial coordinates <tt>(x,y,z)</tt> in the image, while the last one
+  is often used as a vector-valued pixel dimension (color channel for instance). Then, this class can handle the case of 3D volumes
+  of vector-valued pixels, and all images that requires less dimensions (gray-valued or color 2D images for instance). 
+  It also means that (almost) all member functions of the class CImg<T> are designed to handle the maximum case of these (3+1) dimensions.
+
+  Moreover, the pixel type is given by the template parameter T, which means that you can define images with different pixel types T.
+  Fully supported template types are the basic C++ types : <tt>unsigned char, char, short, unsigned int, int, float, double, ... </tt>
+  Using your own template types is possible however, but you will have to redefine the complete set of arithmetic and logical operators.
+  Typically, fast image display would be done using <tt>CImg<unsigned char></tt> images, while complex image processing algorithms would be coded
+  using <tt>CImg<float></tt> or <tt>CImg<double></tt> images which have floating-point pixel values. Only two others classes are defined
+  in the <tt>CImg.h</tt> file : <tt>CImgStats</tt> that is used to represent image statistics, and <tt>CImgDisplay</tt> used to open 
+  windows where images are displayed, and handle keyboard and mouse events.
+
+  CImg has been designed to be 'user-friendly', meaning that the underlying structure of the classes is always quite basic to understand.
+  For instance, the <tt>CImg<T></tt> class members (which are defined as public) are only the dimensions
+  <tt>width, height, depth, dim</tt>, and the pixel data <tt>data</tt>. Very useful when you want to access the raw pixel buffer
+  for calling with functions of other libraries, or when you want to convert your raw data buffer into a <tt>CImg</tt>,
+  in order to visualize it for instance. Moreover, most of the classical arithmetic and logical operators have been redefined
+  in the <tt>CImg<T> class</tt>, which means that accessing a pixel is as simple as <tt>image(x,y)</tt> or <tt>image(x,y,z,v)</tt> (in 4D),
+  and beautiful things are possible such as <tt>(img1+3*img2).display();</tt>
+
+
+     \see \ref cimg_structure
+  **/
+  template<typename T> struct CImg {
+    
+    //! Number of columns in the instance image (size along the X-axis).
+    /**
+       \note
+       - Prefer using CImg<T>::dimx() to get the width of the instance image.
+       - Should be considered as \e read-only. Modifying directly \c CImg<T>::width would probably
+       result in a crash.
+       - This value can be modified through the CImg<T>::resize() function.
+       - If CImg<T>::width==0, the image is empty and contains no pixel data.
+    **/
+    unsigned int width;       
+    
+    //! Number of rows in the instance image (size along the Y-axis).
+    /**
+       \note 
+       - Prefer using CImg<T>::dimy() to get the height of the instance image.
+       - Should be considered as \e read-only. Modifying directly \c CImg<T>::height would probably
+       result in a crash.
+       - This value can be modified through the CImg<T>::resize() function.
+       - If CImg<T>::height==0, the image is empty and contains no pixel data.
+    **/
+    unsigned int height;
+    
+    //! Number of slices in the instance image (size along the Z-axis).
+    /**
+       \note 
+       - Prefer using CImg<T>::dimz() to get the depth of the instance image.
+       - Should be considered as \e read-only. Modifying directly \c CImg<T>::depth would probably
+       result in a crash.
+       - This value can be modified through the CImg<T>::resize() function.
+       - If CImg<T>::depth==0, the image is empty and contains no pixel data.
+    **/
+    unsigned int depth;
+    
+    //! Number of vector channels in the instance image (size along the V-axis).
+    /**
+       \note 
+       - Prefer using CImg<T>::dimv() to get the depth of the instance image.
+       - Should be considered as \e read-only. Modifying directly \c CImg<T>::dim would probably
+       result in a crash.
+       - This value can be modified through the CImg<T>::resize() function.
+       - If CImg<T>::dim==0, the image is empty and contains no pixel data.
+    **/
+    unsigned int dim;
+    
+    //! Pointer to pixel values (array of elements \c T).
+    /**
+       \note
+       - Prefer using CImg<T>::ptr() to get a pointer to the pixel buffer.
+       - Should be considered as \e read-only. Modifying directly \c CImg<T>::data would probably
+       result in a crash.
+       - If CImg<T>::data==NULL, the image is empty and contains no pixel data.
+       \see \ref cimg_storage
+    **/
+    T *data;
+
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Constructors - Destructor - Copy
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+  
+    //! Create an image of size (\c dx,\c dy,\c dz,\c dv) with pixels of type \c T.
+    /**
+       \param dx = number of columns of the created image (size along the X-axis).
+       \param dy = number of rows of the created image (size along the Y-axis).
+       \param dz = number of slices of the created image (size along the Z-axis).
+       \param dv = number of vector channels of the created image (size along the V-axis).
+       \note 
+       - Pixel values are \e not \e initialized by this constructor.
+       - If invoked without parameters, this constructor creates an \e empty image (default constructor).
+    **/
+    explicit CImg(const unsigned int dx=0,const unsigned int dy=1,const unsigned int dz=1,const unsigned int dv=1):
+      width(dx),height(dy),depth(dz),dim(dv) {
+      const unsigned int siz = size();
+      if (siz) data = new T[siz]; else { data=NULL; width=height=depth=dim=0; }
+    }
+
+    //! Create an image of size (\c dx,\c dy,\c dz,\c dv) with pixels of type \c T,
+    //! and set the image pixels to the value \c val.
+    /**
+       \param dx = number of columns of the created image (size along the X-axis).
+       \param dy = number of rows of the created image (size along the Y-axis).
+       \param dz = number of slices of the created image (size along the Z-axis).
+       \param dv = number of vector channels of the created image (size along the V-axis).
+    **/    
+    explicit CImg(const unsigned int dx,const unsigned int dy,const unsigned int dz,const unsigned int dv,const T& val):
+      width(dx),height(dy),depth(dz),dim(dv) {
+      const unsigned int siz = size();
+      if (siz) { data = new T[siz]; fill(val); } else { data=NULL; width=height=depth=dim=0; }
+    }
+
+    //! Copy constructor.
+    /**
+       \param img = the image to copy.
+    **/
+    template<typename t> CImg(const CImg<t>& img):width(img.width),height(img.height),depth(img.depth),dim(img.dim) {
+      const unsigned int siz = size();
+      if (siz) {
+        data = new T[siz];
+        const t *ptrs = img.data + siz;
+        cimg_map(*this,ptrd,T) (*ptrd)=(T)*(--ptrs);
+      } else data = NULL;
+    }
+    CImg(const CImg<T>& img):width(img.width),height(img.height),depth(img.depth),dim(img.dim) {
+      const unsigned siz = size();
+      if (siz) {
+	data = new T[width*height*depth*dim];
+	std::memcpy(data,img.data,siz*sizeof(T));
+      } else data = NULL;
+    }
+
+
+    //! Copy constructor.
+    /**
+       \param img = the image to copy.
+       \param pixel_copy = tells the constructor if the pixel data of the original image are copied into the created image.
+       This may be useful when one wants to create an image with same size than other image, but without same pixel data :
+       \code
+       CImg<float> source("image.jpg");
+       CImg<unsigned char> destination(source,false);
+       \endcode
+       is equivalent to
+       \code
+       CImg<float> source("image.jpg");
+       CImg<unsigned char> destination(source.dimx(),source.dimy(),source.dimz(),source.dimv());
+       \endcode
+    **/
+    template<typename t> CImg(const CImg<t>& img,const bool pixel_copy):width(0),height(0),depth(0),dim(0),data(NULL) {
+      if (pixel_copy) CImg<T>(img).swap(*this);
+      CImg<T>(img.width,img.height,img.depth,img.dim).swap(*this);
+    }
+
+    //! Create an image by loading a file.
+    /**
+       \param filename = the filename of the image file. filename extension is used to guess the image type.
+       \see CImg<T>::load().
+    **/
+    CImg(const char *filename):width(0),height(0),depth(0),dim(0),data(NULL) { load(filename).swap(*this); }
+
+    //! Create an image from a data buffer.
+    /**
+       \param data_buffer = pointer \c T* to a buffer of pixel values T.
+       \param dx = number of columns of the created image (size along the X-axis).
+       \param dy = number of rows of the created image (size along the Y-axis).
+       \param dz = number of slices of the created image (size along the Z-axis).
+       \param dv = number of vector channels of the created image (size along the V-axis).
+       \see \ref cimg_storage
+    **/
+    CImg(const T *const data_buffer,unsigned int dx,unsigned int dy=1,unsigned int dz=1,unsigned int dv=1):
+      width(dx),height(dy),depth(dz),dim(dv) {
+      const unsigned int siz = size();
+      if (data_buffer && siz) {
+        data = new T[siz];
+        std::memcpy(data,data_buffer,siz*sizeof(T));
+      } else { width=height=depth=dim=0; data = NULL; }
+    }
+
+    //! Destructor.
+    /**
+       \note The destructor frees the memory eventually used by the image pixels.
+    **/
+    ~CImg() { if (data) delete[] data; }
+
+    //! Empty image
+    CImg& empty() { return CImg<T>().swap(*this); }
+
+    //@}
+    //-----------------------------------------------------
+    //-----------------------------------------------------
+    //
+    //! \name Access to image dimensions and pixel values
+    //@{
+    //-----------------------------------------------------
+    //-----------------------------------------------------
+  
+    //! Return the type of the pixel values
+    /**
+       \return a string describing the type of the image pixels (template parameter \p T).
+    **/
+    static const char* pixel_type() { T val; return cimg::get_type(val); }
+
+    //! Return the number of pixels of an image.
+    /**
+       \return dimx()*dimy()*dimz()*dimv()
+       \see dimx(), dimy(), dimz(), dimv()
+    **/
+    const unsigned int size() const { return width*height*depth*dim; }  
+
+    //! Return the number of columns of the instance image (size along the X-axis).
+    /**
+       \return this->width
+       \see dimy(),dimz(),dimv(),size()
+    **/
+    const int dimx() const { return (int)width; }  
+
+    //! Return the number of rows of the instance image (size along the Y-axis).
+    /**
+       \return this->height
+       \see dimx(),dimz(),dimv(),size()
+    **/
+    const int dimy() const { return (int)height; }
+  
+    //! Return the number of slices of the instance image (size along the Z-axis).
+    /**
+       \return this->depth
+       \see dimx(),dimy(),dimv(),size()
+    **/
+    const int dimz() const { return (int)depth; }
+  
+    //! Return the number of vector channels of the instance image (size along the V-axis).
+    /**
+       \return this->dim
+       \see dimx(),dimy(),dimz(),size()
+    **/
+    const int dimv() const { return (int)dim; }
+  
+    //! Return the offset corresponding to the location of the pixel value located at (\p x,\p y,\p z,\p v)
+    // with respect to the pixel data pointer \ref data.
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+    **/
+    const int offset(const int x=0, const int y=0, const int z=0, const int v=0) const { return x+width*(y+height*(z+depth*v)); }
+  
+    //! Return a pointer to the pixel value located at (\p x,\p y,\p z,\p v).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+    **/
+    T* ptr(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) const {
+#if cimg_debug>1
+      const int off = offset(x,y,z,v);
+      if (off<0 || off>=(int)size()) {
+        cimg::warn(true,"CImg<%s>::ptr() : Trying to get a pointer at (%u,%u,%u,%u) (offset=%d) which is outside the data of the image (%u,%u,%u,%u) (size=%u)",
+                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
+        return data;
+      }
+#endif
+      return data+offset(x,y,z,v);
+    }
+
+    //! Access to pixel value for reading or writing, without boundary checking.
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel       
+       \note if \c cimg_debug==2, a boundary checking is performed (also slow down the code considerably).
+    **/
+    T& operator()(const unsigned int x,const unsigned int y=0,const unsigned int z=0,const unsigned int v=0) const {
+      const int off = offset(x,y,z,v);
+#if cimg_debug>1
+      if (!data || off>=(int)size()) {
+        cimg::warn(true,
+                   "CImg<%s>::operator() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) outside the image range (%u,%u,%u,%u) (size=%u)",
+                   pixel_type(),x,y,z,v,offset(x,y,z,v),width,height,depth,dim,data,size());			
+        return *data;
+      }
+#endif
+      return data[off];
+    }
+    
+    //! Access to pixel buffer value for reading or writing.
+    /**
+       \param off = offset in the pixel buffer
+       \note if \c cimg_debug==2, a out-of-buffer checking is performed (also slow down the code considerably).
+    **/    
+    T& operator[](const unsigned int off) const {
+#if cimg_debug>1
+      if (!data || off>=(int)size()) {
+        cimg::warn(true,
+                   "CImg<%s>::operator[] : Trying to get a pixel at offset=%d, outside the range of the image (%u,%u,%u,%u) (size=%u)",
+                   pixel_type(),off,width,height,depth,dim,data,size());			
+        return *data;
+      }
+#endif
+      return data[off];
+    }
+
+    //! Pixel access with Dirichlet boundary conditions for all coordinates (x,y,z,v).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+       \param out_val = returned value if pixel coordinates is out of the image range.
+    **/
+    T dirichlet_pix4d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
+      return (x<0 || y<0 || z<0 || v<0 || x>=dimx() || y>=dimy() || z>=dimz() || v>=dimv())?out_val:(*this)(x,y,z,v);
+    }
+
+    //! Pixel access with Dirichlet boundary conditions for the three first coordinates (x,y,z).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+       \param out_val = returned value if pixel coordinates is out of the image range.
+    **/
+    T dirichlet_pix3d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
+      return (x<0 || y<0 || z<0 || x>=dimx() || y>=dimy() || z>=dimz())?out_val:(*this)(x,y,z,v);
+    }
+    //! Pixel access with Dirichlet boundary conditions for the two first coordinates (x,y).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+       \param out_val = returned value if pixel coordinates is out of the image range.
+    **/
+    T dirichlet_pix2d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
+      return (x<0 || y<0 || x>=dimx() || y>=dimy())?out_val:(*this)(x,y,z,v);
+    }
+
+    //! Pixel access with Dirichlet boundary conditions for the first coordinate x.
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+       \param out_val = returned value if pixel coordinates is out of the image range.
+    **/
+    T dirichlet_pix1d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
+      return (x<0 || x>=dimx())?out_val:(*this)(x,y,z,v);
+    }
+
+    //! Pixel access with Neumann boundary conditions for all coordinates (x,y,z,v).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+    **/
+    const T& neumann_pix4d(const int x,const int y=0,const int z=0,const int v=0) const {
+      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
+                     y<0?0:(y>=dimy()?dimy()-1:y),
+                     z<0?0:(z>=dimz()?dimz()-1:z),
+                     v<0?0:(v>=dimv()?dimv()-1:v));
+    }
+    //! Pixel access with Neumann boundary conditions for the three first coordinates (x,y,z).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+    **/
+    const T& neumann_pix3d(const int x,const int y=0,const int z=0,const int v=0) const {
+      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
+                     y<0?0:(y>=dimy()?dimy()-1:y),
+                     z<0?0:(z>=dimz()?dimz()-1:z),v);
+    }
+
+    //! Pixel access with Neumann boundary conditions for the two first coordinates (x,y).
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+    **/
+    const T& neumann_pix2d(const int x,const int y=0,const int z=0,const int v=0) const {
+      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
+                     y<0?0:(y>=dimy()?dimy()-1:y),z,v);
+    }
+    //! Pixel access with Neumann boundary conditions for the first coordinate x.
+    /**
+       \param x = x-coordinate of the pixel
+       \param y = y-coordinate of the pixel
+       \param z = z-coordinate of the pixel
+       \param v = v-coordinate of the pixel
+    **/
+    const T& neumann_pix1d(const int x,const int y=0,const int z=0,const int v=0) const {
+      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),y,z,v);
+    }
+    
+    //! Pixel access with Neumann boundary conditions and linear interpolation for all coordinates (x,y,z,v).
+    /**
+       \param x = x-coordinate of the pixel (float value)
+       \param y = y-coordinate of the pixel (float value)
+       \param z = z-coordinate of the pixel (float value)
+       \param v = v-coordinate of the pixel (float value)
+    **/
+    double linear_pix4d(const float ffx,const float ffy=0,const float ffz=0,const float ffv=0) const {
+      double valx0,valx1,valy0,valy1,valz0,valz1;
+      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy),
+        fz = ffz<0?0:(ffz>depth-1?depth-1:ffz), fv = ffv<0?0:(ffv>dim-1?dim-1:ffv);
+      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy,  z = (unsigned int)fz, v = (unsigned int)fv;
+      const float dx = fx-x, dy = fy-y, dz = fz-z, dv = fv-v;
+      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y,  nz = dz>0?z+1:z, nv = dv>0?v+1:v;
+      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
+      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
+      valy0 = (1-dy)*valx0 + (dy)*valx1;
+      valx0 = (1-dx)*(*this)(x,y,nz,v)  + (dx)*(*this)(nx,y,nz,v);
+      valx1 = (1-dx)*(*this)(x,ny,nz,v) + (dx)*(*this)(nx,ny,nz,v);
+      valy1 = (1-dy)*valx0 + (dy)*valx1;
+      valz0 = (1-dz)*valy0 + (dz)*valy1;
+      valx0 = (1-dx)*(*this)(x,y,z,nv)  + (dx)*(*this)(nx,y,z,nv);
+      valx1 = (1-dx)*(*this)(x,ny,z,nv) + (dx)*(*this)(nx,ny,z,nv);
+      valy0 = (1-dy)*valx0 + (dy)*valx1;
+      valx0 = (1-dx)*(*this)(x,y,nz,nv)  + (dx)*(*this)(nx,y,nz,nv);
+      valx1 = (1-dx)*(*this)(x,ny,nz,nv) + (dx)*(*this)(nx,ny,nz,nv);
+      valy1 = (1-dy)*valx0 + (dy)*valx1;
+      valz1 = (1-dz)*valy0 + (dz)*valy1;
+      return (1-dv)*valz0 + (dv)*valz1;
+    }
+
+    //! Pixel access with Neumann boundary conditions and linear interpolation for the three first coordinates (x,y,z).
+    /**
+       \param x = x-coordinate of the pixel (float value)
+       \param y = y-coordinate of the pixel (float value)
+       \param z = z-coordinate of the pixel (float value)
+       \param v = v-coordinate of the pixel (integer value)
+    **/
+    double linear_pix3d(const float ffx,const float ffy=0,const float ffz=0,const int v=0) const {
+      double valx0,valx1,valy0,valy1;
+      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy), fz = ffz<0?0:(ffz>depth-1?depth-1:ffz);
+      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy, z = (unsigned int)fz;
+      const float dx = fx-x, dy = fy-y, dz = fz-z;
+      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y, nz = dz>0?z+1:z;
+      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
+      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
+      valy0 = (1-dy)*valx0 + (dy)*valx1;
+      valx0 = (1-dx)*(*this)(x,y,nz,v)  + (dx)*(*this)(nx,y,nz,v);
+      valx1 = (1-dx)*(*this)(x,ny,nz,v) + (dx)*(*this)(nx,ny,nz,v);
+      valy1 = (1-dy)*valx0 + (dy)*valx1;
+      return (1-dz)*valy0 + (dz)*valy1;
+    }
+
+    //! Pixel access with Neumann boundary conditions and linear interpolation for the two first coordinates (x,y).
+    /**
+       \param x = x-coordinate of the pixel (float value)
+       \param y = y-coordinate of the pixel (float value)
+       \param z = z-coordinate of the pixel (integer value)
+       \param v = v-coordinate of the pixel (integer value)
+    **/
+    double linear_pix2d(const float ffx,const float ffy=0,const int z=0,int v=0) const {
+      double valx0,valx1;
+      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy);
+      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy;
+      const float dx = fx-x, dy = fy-y;
+      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y;
+      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
+      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
+      return (1-dy)*valx0 + (dy)*valx1;
+    }
+
+    //! Pixel access with Neumann boundary conditions and linear interpolation for the first coordinate x.
+    /**
+       \param x = x-coordinate of the pixel (float value)
+       \param y = y-coordinate of the pixel (integer value)
+       \param z = z-coordinate of the pixel (integer value)
+       \param v = v-coordinate of the pixel (integer value)
+    **/
+    double linear_pix1d(const float ffx,const int y=0,const int z=0,int v=0) const {
+      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx);
+      const unsigned int x = (unsigned int)fx;
+      const float dx = fx-x;
+      const unsigned int nx = dx>0?x+1:x;
+      return (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
+    }
+
+    //! Pixel access with Neumann boundary conditions and cubic interpolation for the two first coordinates (x,y).
+    /**
+       \param x = x-coordinate of the pixel (float value)
+       \param y = y-coordinate of the pixel (float value)
+       \param z = z-coordinate of the pixel (integer value)
+       \param v = v-coordinate of the pixel (integer value)
+    **/
+    double cubic_pix2d(const float pfx,const float pfy=0,const int z=0,int v=0) const {
+      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx), fy = pfy<0?0:(pfy>height-1?height-1:pfy);
+      const unsigned int 
+        x = (unsigned int)fx,  px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1,
+        y = (unsigned int)fy,  py = (int)y-1>=0?y-1:0, ny = y+1<height?y+1:height-1, ay = ny+1<height?ny+1:height-1;
+      const float dx = fx-x, dy = fy-y;
+      const T& 
+        a = (*this)(px,py,z,v), b = (*this)(x,py,z,v), c = (*this)(nx,py,z,v), d = (*this)(ax,py,z,v),
+        e = (*this)(px, y,z,v), f = (*this)(x, y,z,v), g = (*this)(nx, y,z,v), h = (*this)(ax, y,z,v),
+        i = (*this)(px,ny,z,v), j = (*this)(x,ny,z,v), k = (*this)(nx,ny,z,v), l = (*this)(ax,ny,z,v),
+        m = (*this)(px,ay,z,v), n = (*this)(x,ay,z,v), o = (*this)(nx,ay,z,v), p = (*this)(ax,ay,z,v);
+      const double 
+        A = dx*dx*dx*(2*(b-c)+0.5*(c-a+d-b)) + dx*dx*(2*c-2.5*b+a-0.5*d) + dx*0.5*(c-a) + b,
+        B = dx*dx*dx*(2*(f-g)+0.5*(g-e+h-f)) + dx*dx*(2*g-2.5*f+e-0.5*h) + dx*0.5*(g-e) + f,
+        C = dx*dx*dx*(2*(j-k)+0.5*(k-i+l-j)) + dx*dx*(2*k-2.5*j+i-0.5*l) + dx*0.5*(k-i) + j,
+        D = dx*dx*dx*(2*(n-o)+0.5*(o-m+p-n)) + dx*dx*(2*o-2.5*n+m-0.5*p) + dx*0.5*(o-m) + n;
+      return dy*dy*dy*(2*(B-C)+0.5*(C-A+D-B)) + dy*dy*(2*C-2.5*B+A-0.5*D) + dy*0.5*(C-A) + B;
+    }
+
+    //! Pixel access with Neumann boundary conditions and cubic interpolation for all coordinates x.
+    /**
+       \param x = x-coordinate of the pixel (float value)
+       \param y = y-coordinate of the pixel (integer value)
+       \param z = z-coordinate of the pixel (integer value)
+       \param v = v-coordinate of the pixel (integer value)
+    **/
+    double cubic_pix1d(const float pfx,const int y=0,const int z=0,int v=0) const {
+      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx);
+      const unsigned int x = (unsigned int)fx, px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1;
+      const float dx = fx-x;
+      const T& a = (*this)(px,y,z,v), b = (*this)(x,y,z,v), c = (*this)(nx,y,z,v), d = (*this)(ax,y,z,v);
+      return dx*dx*dx*(2*(b-c)+0.5*(c-a+d-b)) + dx*dx*(2*c-2.5*b+a-0.5*d) + dx*0.5*(c-a) + b;
+    }
+  
+    //! Compute and return statistics on the image.
+    /**
+       \param compute_variance = - \true : compute complete statistics, including the variance of the pixel values.
+                                 - \false : compute only minimum, maximum and average value of the pixel values (faster).
+       \return a CImgStats instance representing statistics of the instance image.
+    **/
+    CImgStats get_stats(const bool compute_variance=true) const { return CImgStats(*this,compute_variance); }
+  
+    //! Print image information on the standart error output
+    /**
+       \param title = name of your printed variable.
+       \param print_flag = - 0 : print only informations about image size and pixel buffer.
+                           - 1 : print also statistics on the image pixels.
+			   - 2 : print also the pixel buffer content, in a matlab-style.
+    **/
+    const CImg& print(const char *title=NULL,const unsigned int print_flag=1) const {
+      std::fprintf(stderr,"%-8s(%p) : '%s'(%u,%u,%u,%u,%p) : ",title?title:"CImg",(void*)this,
+		   pixel_type(),width,height,depth,dim,(void*)data);
+      if (size()==0 || !data) { std::fprintf(stderr,"Undefined pixel data\n"); return *this; }
+      if (print_flag>=1) { 
+        CImgStats st(*this);
+        std::fprintf(stderr,"stats = { %g, %g [%g], %g } : ",st.min,st.mean,st.variance,st.max); 
+      }
+      if (print_flag>=2 || size()<=16) {
+        std::fprintf(stderr,"%s = [ ",title?title:"data");
+        cimg_mapXYZV(*this,x,y,z,k) std::fprintf(stderr,"%g%s",(double)(*this)(x,y,z,k),((x+1)*(y+1)*(z+1)*(k+1)==(int)size()?" ]":(((x+1)%width==0)?" ; ":" ")));
+      }
+      std::fputc('\n',stderr);
+      return *this;
+    }
+    //! Print image information on the standart error output
+    /**
+      \param print_flag = - 0 : print only informations about image size and pixel buffer.
+                           - 1 : print also statistics on the image pixels.
+			   - 2 : print also the pixel buffer content, in a matlab-style.       
+    **/
+    const CImg& print(const unsigned int print_flag) const { return print(NULL,print_flag); }
+  
+    //@}
+    //--------------------------------------------------
+    //--------------------------------------------------
+    //
+    //! \name Common arithmetics and boolean operators
+    //@{
+    //--------------------------------------------------
+    //--------------------------------------------------
+  
+    //! Copy an image to the instance image.
+    /**
+       \param img = image to copy.
+       \note If pixel types are different, a type cast is performed.
+    **/
+    template<typename t> CImg<T>& operator=(const CImg<t>& img) { return CImg<T>(img).swap(*this); }
+    CImg& operator=(const CImg& img) { if (&img==this) return *this; return CImg<T>(img).swap(*this); }
+      
+    //! Assign a scalar value to all pixels of the instance image
+    /**
+       \param val = the value to assign.
+    **/
+    CImg& operator=(const T& val) { return fill(val); }
+
+    //! Copy the content of a C-array to the pixel buffer of the instance image
+    /**
+       \param buf = pointer to a C-array, with a size of (at least) this->size().
+    **/
+    CImg& operator=(const T *buf) {
+      if (buf) std::memcpy(data,buf,size()*sizeof(T));
+      else throw CImgArgumentException("CImg<T>::operator=() : Given array pointer 'ptr' is NULL");
+      return *this; 
+    }
+       
+    //! Operator+=
+    /**
+       \param val = value to add to each pixel value of the instance image.
+    **/
+    CImg& operator+=(const T& val) { cimg_map(*this,ptr,T) (*ptr)+=val; return *this; }
+
+    //! Operator-=
+    /**
+       \param val = value to sub to each pixel value of the instance image.
+    **/
+    CImg& operator-=(const T& val) { cimg_map(*this,ptr,T) (*ptr)-=val; return *this; }
+
+    //! Operator%=
+    /**
+       \param val = value of the modulo applied to each pixel value of the instance image.
+    **/
+    CImg& operator%=(const T& val) { cimg_map(*this,ptr,T) (*ptr)%=val; return *this; }
+
+    //! Operator&=
+    /**
+       \param val = value of the bitwise AND applied to each pixel value of the instance image.
+     **/
+    CImg& operator&=(const T& val) { cimg_map(*this,ptr,T) (*ptr)&=val; return *this; }
+
+    //! Operator|=
+    /**
+       \param 
+    **/
+    CImg& operator|=(const T& val) { cimg_map(*this,ptr,T) (*ptr)|=val; return *this; }
+
+    //! Operator^=
+    CImg& operator^=(const T& val) { cimg_map(*this,ptr,T) (*ptr)^=val; return *this; }
+
+    //! Operator+
+    CImg operator+(const T& val) const { return CImg<T>(*this)+=val; }
+
+    //! Operator-
+    CImg operator-(const T& val) const { return CImg<T>(*this)-=val; }
+
+    //! Operator%
+    CImg operator%(const T& val) const { return CImg<T>(*this)%=val; }  
+
+    //! Operator&
+    CImg operator&(const T& val) const { return CImg<T>(*this)&=val; }
+
+    //! Operator|
+    CImg operator|(const T& val) const { return CImg<T>(*this)|=val; }
+
+    //! Operator^
+    CImg operator^(const T& val) const { return CImg<T>(*this)^=val; }
+
+    //! Operator!
+    CImg operator!() const {
+      CImg<T> res(*this,false);
+      const T *ptrs = ptr() + size();
+      cimg_map(res,ptrd,T) *ptrd=!(*(--ptrs));
+      return res;
+    }
+
+    //! Operator~
+    CImg operator~() const {
+      CImg<T> res(*this,false);
+      const T *ptrs = ptr() + size();
+      cimg_map(res,ptrd,T) *ptrd=~(*(--ptrs));
+      return res;
+    }
+    
+    //! Operator+=
+    template<typename t> CImg& operator+=(const CImg<t>& img) {
+      const unsigned int smin = cimg::min(size(),img.size());
+      t *ptrs = img.data+smin;
+      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)+(*(--ptrs))));
+      return *this;
+    }
+    //! Operator-=
+    template<typename t> CImg& operator-=(const CImg<t>& img) {
+      const unsigned int smin = cimg::min(size(),img.size());
+      t *ptrs = img.data+smin;
+      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)-(*(--ptrs))));
+      return *this;
+    }
+    //! Operator%=
+    CImg& operator%=(const CImg& img) {
+      const unsigned int smin = cimg::min(size(),img.size());
+      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)%=*(--ptrs));
+      return *this;
+    }
+    //! Operator&=
+    CImg& operator&=(const CImg& img) {
+      const unsigned int smin = cimg::min(size(),img.size());
+      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)&=*(--ptrs));
+      return *this;
+    }
+    //! Operator|=
+    CImg& operator|=(const CImg& img) {
+      const unsigned int smin = cimg::min(size(),img.size());
+      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)|=*(--ptrs));
+      return *this;
+    }
+    //! Operator^=
+    CImg& operator^=(const CImg& img) {
+      const unsigned int smin = cimg::min(size(),img.size());
+      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)^=*(--ptrs));
+      return *this;
+    }
+
+    //! Operator+
+    template<typename t> CImg operator+(const CImg<t>& img)  const { return CImg<T>(*this)+=img; }
+
+    //! Operator-
+    template<typename t> CImg operator-(const CImg<t>& img)  const { return CImg<T>(*this)-=img; }
+
+    //! Operator%
+    CImg operator%(const CImg& img) const { return CImg<T>(*this)%=img; }
+
+    //! Operator&
+    CImg operator&(const CImg& img) const { return CImg<T>(*this)&=img; } 
+
+    //! Operator|
+    CImg operator|(const CImg& img) const { return CImg<T>(*this)|=img; }
+
+    //! Operator^
+    CImg operator^(const CImg& img) const { return CImg<T>(*this)^=img; }  
+
+    //! Operator*=
+    CImg& operator*=(const double val) { cimg_map(*this,ptr,T) (*ptr)=(T)((*ptr)*val); return *this; }
+
+    //! Operator/=
+    CImg& operator/=(const double val) { cimg_map(*this,ptr,T) (*ptr)=(T)((*ptr)/val); return *this; }
+
+    //! Operator*
+    CImg operator*(const double val) const { return CImg<T>(*this)*=val; }
+
+    //! Operator/
+    CImg operator/(const double val) const { return CImg<T>(*this)/=val; }
+
+    //! Operator+
+    friend CImg operator+(const T& val, const CImg& img) { return CImg<T>(img)+=val; }
+
+    //! Operator*
+    friend CImg operator*(const double val,const CImg &img) { return CImg<T>(img)*=val; }
+
+    //! Operator-
+    friend CImg operator-(const T& val, const CImg& img) { return CImg<T>(img.width,img.height,img.depth,img.dim,val)-=img; }
+
+    //! Operator==
+    template<typename t> const bool operator==(const CImg<t>& img) const {
+      const unsigned int siz = size();
+      bool vequal = true;
+      if (siz!=img.size()) return false;
+      t *ptrs=img.data+siz;
+      for (T *ptrd=data+siz; vequal && ptrd>data; vequal=vequal&&((*(--ptrd))==(*(--ptrs))));
+      return vequal;
+    }
+    //! Operator!=
+    template<typename t> const bool operator!=(const CImg<t>& img) const { return !((*this)==img); }
+
+    //@}
+    //--------------------------------------------------
+    //--------------------------------------------------
+    //
+    //! \name Usual mathematical operations
+    //@{
+    //--------------------------------------------------
+    //--------------------------------------------------
+     
+    //! Replace the image by the pointwise multiplication between \p *this and \p img.
+    /**
+       \param img = argument of the multiplication.
+       \note if \c *this and \c img have different size, the multiplication is applied
+       only on possible values.
+       \see div(),get_mul(),get_div().
+    **/
+    template<typename t> CImg& mul(const CImg<t>& img) {
+      t *ptrs = img.data;
+      T *ptrf = data + cimg::min(size(),img.size());
+      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd*(*(ptrs++)));
+      return *this;
+    }
+
+    //! Return the image corresponding to the pointwise multiplication between \p *this and \p img.
+    /**
+       \param img = argument of the multiplication.
+       \note if \c *this and \c img have different size, the multiplication is applied
+       only on possible values.
+       \see get_div(),mul(),div()
+    **/
+    template<typename t> CImg get_mul(const CImg<t>& img) const { return CImg<T>(*this).mul(img); }
+  
+    //! Replace the image by the pointwise division between \p *this and \p img.
+    /**
+       \param img = argument of the division.
+       \note if \c *this and \c img have different size, the division is applied
+       only on possible values.
+       \see mul(),get_mul(),get_div().
+    **/
+    template<typename t> CImg& div(const CImg<t>& img) {
+      t *ptrs = img.data;
+      T *ptrf = data + cimg::min(size(),img.size());
+      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd/(*(ptrs++)));
+      return *this;
+    }
+
+    //! Return an image from a pointwise division between \p *this and \p img.
+    /**
+       \param img = argument of the division.
+       \note if \c *this and \c img have different size, the division is applied
+       only on possible values.
+       \see get_mul(),mul(),div()
+    **/
+    template<typename t> CImg get_div(const CImg<t>& img) const { return CImg<T>(*this).div(img); }
+  
+    //! Replace the image by the pointwise max operator between \p *this and \p img
+    /**
+       \param img = second argument of the max operator (the first one is *this).
+       \see get_max(), min(), get_min()
+    **/
+    template<typename t> CImg& max(const CImg<t>& img) {
+      t *ptrs = img.data;
+      T *ptrf = data + cimg::min(size(),img.size());
+      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::max((T)(*(ptrs++)),*ptrd);
+      return *this;
+    }
+    //! Return the image corresponding to the max value for each pixel.
+    /**
+       \param img = second argument of the max operator (the first one is *this).
+       \see max(), min(), get_min()
+    **/
+    template<typename t> CImg get_max(const CImg<t>& img) const { return CImg<T>(*this).max(img); }
+  
+    //! Replace the image by the pointwise min operator between \p *this and \p img
+    /**
+       \param img = second argument of the min operator (the first one is *this).
+       \see get_min(), max(), get_max()
+    **/
+    template<typename t> CImg& min(const CImg<t>& img) {
+      t *ptrs = img.data;
+      T *ptrf = data + cimg::min(size(),img.size());
+      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::min((T)(*(ptrs++)),*ptrd);
+      return *this;
+    }
+    //! Return the image corresponding to the min value for each pixel.
+    /**
+       \param img = second argument of the min operator (the first one is *this).
+       \see min(), max(), get_max()
+    **/
+    template<typename t> CImg get_min(const CImg<t>& img) const { return CImg<T>(*this).min(img); }
+
+    //! Replace each image pixel by its square root.
+    /**
+       \see get_sqrt()
+    **/
+    CImg& sqrt() {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::sqrt((double)(*ptr));
+      return *this;
+    }
+
+    //! Return the image of the square root of the pixel values.
+    /**
+       \see sqrt()
+    **/
+    CImg get_sqrt() const { return CImg<T>(*this).sqrt(); }
+  
+    //! Replace each image pixel by its log.
+    /**
+       \see get_log(), log10(), get_log10()
+    **/
+    CImg& log() {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::log((double)(*ptr));
+      return *this;
+    }
+
+    //! Return the image of the log of the pixel values.
+    /**
+       \see log(), log10(), get_log10()
+    **/
+    CImg get_log() const { return CImg<T>(*this).log(); }
+
+    //! Replace each image pixel by its log10.
+    /**
+       \see get_log10(), log(), get_log()
+    **/
+    CImg& log10() {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::log10((double)(*ptr));
+      return *this;
+    }
+
+    //! Return the image of the log10 of the pixel values.
+    /**
+       \see log10(), log(), get_log()
+    **/
+    CImg get_log10() const { return CImg<T>(*this).log10(); }
+
+    //! Replace each image pixel by its power by \p p.
+    /**
+       \param p = power
+       \see get_pow(), sqrt(), get_sqrt()
+    **/
+    CImg& pow(const double p) {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::pow((double)(*ptr),p);
+      return *this;
+    }
+
+    //! Return the image of the square root of the pixel values.
+    /**
+       \param p = power
+       \see pow(), sqrt(), get_sqrt()
+    **/
+    CImg get_pow(const double p) const { return CImg<T>(*this).pow(p); }
+  
+    //! Replace each pixel value by its absolute value.
+    /**
+       \see get_abs()
+    **/
+    CImg& abs() {
+      cimg_map(*this,ptr,T) (*ptr)=cimg::abs(*ptr);
+      return *this;
+    }
+
+    //! Return the image of the absolute value of the pixel values.
+    /**
+       \see abs()
+    **/
+    CImg get_abs() const { return CImg<T>(*this).abs(); }
+  
+    //! Replace each image pixel by its cosinus.
+    /**
+       \see get_cos(), sin(), get_sin(), tan(), get_tan()
+    **/
+    CImg& cos() {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::cos((double)(*ptr));
+      return *this;
+    }
+
+    //! Return the image of the cosinus of the pixel values.
+    /**
+       \see cos(), sin(), get_sin(), tan(), get_tan()
+    **/
+    CImg get_cos() const { return CImg<T>(*this).cos(); }
+ 
+    //! Replace each image pixel by its sinus.
+    /**
+       \see get_sin(), cos(), get_cos(), tan(), get_tan()
+    **/
+    CImg& sin() {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::sin((double)(*ptr));
+      return *this;
+    }
+
+    //! Return the image of the sinus of the pixel values.
+    /**
+       \see sin(), cos(), get_cos(), tan(), get_tan()
+    **/
+    CImg get_sin() const { return CImg<T>(*this).sin(); }
+  
+    //! Replace each image pixel by its tangent.
+    /**
+       \see get_tan(), cos(), get_cos(), sin(), get_sin()
+    **/
+    CImg& tan() {
+      cimg_map(*this,ptr,T) (*ptr)=(T)std::tan((double)(*ptr));
+      return *this;
+    }
+
+    //! Return the image of the tangent of the pixel values.
+    /**
+       \see tan(), cos(), get_cos(), sin(), get_sin()
+    **/
+    CImg get_tan() const { return CImg<T>(*this).tan(); }
+  
+
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Usual image transformation
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+    
+    //! Fill all pixel values with value \a val.
+    /**
+       \param val = fill value
+       \see operator=()
+    **/
+    CImg& fill(const T& val) {
+      cimg_test(*this,"CImg<T>::fill");      
+      if (val!=0 && sizeof(T)!=1) cimg_map(*this,ptr,T) *ptr=val; 
+      else std::memset(data,(int)val,size()*sizeof(T));
+      return *this;
+    }
+
+    //! Fill sequentially all pixel values with values \a val0 and \a val1
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+    **/
+    CImg& fill(const T& val0,const T& val1) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-1; ) { *(ptr++)=val0; *(ptr++)=val1; }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      return *this;
+    }
+    
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-2; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; }     
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      return *this;
+    }
+    
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-3; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      return *this;
+    }
+
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-4; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      return *this;
+    }
+    
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4 and \a val5
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+       \param val5 = fill value 6
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size(); 
+      for (ptr=data; ptr<ptr_end-5; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      if (ptr!=ptr_end) *(ptr++)=val4;
+      return *this;
+    }
+
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val7.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+       \param val5 = fill value 6
+       \param val6 = fill value 7
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,const T& val7) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-7; ) {
+	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
+	*(ptr++)=val6; *(ptr++)=val7;
+      }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      if (ptr!=ptr_end) *(ptr++)=val4;
+      if (ptr!=ptr_end) *(ptr++)=val5;
+      if (ptr!=ptr_end) *(ptr++)=val6;
+      return *this;
+    }
+
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val8.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+       \param val5 = fill value 6
+       \param val6 = fill value 7
+       \param val7 = fill value 8
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,const T& val7,const T& val8) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-8; ) {
+	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
+	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8;
+      }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      if (ptr!=ptr_end) *(ptr++)=val4;
+      if (ptr!=ptr_end) *(ptr++)=val5;
+      if (ptr!=ptr_end) *(ptr++)=val6;
+      if (ptr!=ptr_end) *(ptr++)=val7;
+      return *this;
+    }
+
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val9.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+       \param val5 = fill value 6
+       \param val6 = fill value 7
+       \param val7 = fill value 8
+       \param val8 = fill value 9
+       \param val9 = fill value 10
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,
+	       const T& val5,const T& val6,const T& val7,const T& val8,const T& val9) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-9; ) {
+	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
+	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9;
+      }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      if (ptr!=ptr_end) *(ptr++)=val4;
+      if (ptr!=ptr_end) *(ptr++)=val5;
+      if (ptr!=ptr_end) *(ptr++)=val6;
+      if (ptr!=ptr_end) *(ptr++)=val7;
+      if (ptr!=ptr_end) *(ptr++)=val8;
+      return *this;
+    }
+
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val11.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+       \param val5 = fill value 6
+       \param val6 = fill value 7
+       \param val7 = fill value 8
+       \param val8 = fill value 9
+       \param val9 = fill value 10
+       \param val10 = fill value 11
+       \param val11 = fill value 12
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,
+               const T& val7,const T& val8,const T& val9,const T& val10,const T& val11) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-11; ) {
+	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
+	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
+      }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      if (ptr!=ptr_end) *(ptr++)=val4;
+      if (ptr!=ptr_end) *(ptr++)=val5;
+      if (ptr!=ptr_end) *(ptr++)=val6;
+      if (ptr!=ptr_end) *(ptr++)=val7;
+      if (ptr!=ptr_end) *(ptr++)=val8;
+      if (ptr!=ptr_end) *(ptr++)=val9;
+      if (ptr!=ptr_end) *(ptr++)=val10;
+      return *this;
+    }
+    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val15.
+    /**
+       \param val0 = fill value 1
+       \param val1 = fill value 2
+       \param val2 = fill value 3
+       \param val3 = fill value 4
+       \param val4 = fill value 5
+       \param val5 = fill value 6
+       \param val6 = fill value 7
+       \param val7 = fill value 8
+       \param val8 = fill value 9
+       \param val9 = fill value 10
+       \param val10 = fill value 11
+       \param val11 = fill value 12
+       \param val12 = fill value 13
+       \param val13 = fill value 14
+       \param val14 = fill value 15
+       \param val15 = fill value 16
+    **/
+    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
+	       const T& val4,const T& val5,const T& val6,const T& val7,
+               const T& val8,const T& val9,const T& val10,const T& val11,
+	       const T& val12,const T& val13,const T& val14,const T& val15) {
+      cimg_test(*this,"CImg<T>::fill");
+      T *ptr, *ptr_end = data+size();
+      for (ptr=data; ptr<ptr_end-15; ) {
+	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
+	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
+	*(ptr++)=val12; *(ptr++)=val13; *(ptr++)=val14; *(ptr++)=val15;
+      }
+      if (ptr!=ptr_end) *(ptr++)=val0;
+      if (ptr!=ptr_end) *(ptr++)=val1;
+      if (ptr!=ptr_end) *(ptr++)=val2;
+      if (ptr!=ptr_end) *(ptr++)=val3;
+      if (ptr!=ptr_end) *(ptr++)=val4;
+      if (ptr!=ptr_end) *(ptr++)=val5;
+      if (ptr!=ptr_end) *(ptr++)=val6;
+      if (ptr!=ptr_end) *(ptr++)=val7;
+      if (ptr!=ptr_end) *(ptr++)=val8;
+      if (ptr!=ptr_end) *(ptr++)=val9;
+      if (ptr!=ptr_end) *(ptr++)=val10;
+      if (ptr!=ptr_end) *(ptr++)=val11;
+      if (ptr!=ptr_end) *(ptr++)=val12;
+      if (ptr!=ptr_end) *(ptr++)=val13;
+      if (ptr!=ptr_end) *(ptr++)=val14;
+      return *this;
+    }
+  
+    //! Linear normalization of the pixel values between \a a and \a b.
+    /**
+       \param a = minimum pixel value after normalization.
+       \param b = maximum pixel value after normalization.
+       \see get_normalize(), cut(), get_cut().
+    **/
+    CImg& normalize(const T& a,const T& b) {
+      cimg_test(*this,"CImg<T>::normalize");
+      const CImgStats st(*this,false);
+      if (st.min==st.max) fill(0);
+      else cimg_map(*this,ptr,T) *ptr=(T)((*ptr-st.min)/(st.max-st.min)*(b-a)+a);
+      return *this;
+    }
+
+    //! Return the image of normalized values.
+    /**
+       \param a = minimum pixel value after normalization.
+       \param b = maximum pixel value after normalization.
+       \see normalize(), cut(), get_cut().
+    **/
+    CImg get_normalize(const T& a,const T& b) const { return CImg<T>(*this).normalize(a,b); }
+  
+    //! Cut pixel values between \a a and \a b.
+    /**
+       \param a = minimum pixel value after cut.
+       \param b = maximum pixel value after cut.
+       \see get_cut(), normalize(), get_normalize().
+    **/
+    CImg& cut(const T& a, const T& b) {
+      cimg_test(*this,"CImg<T>::cut");
+      cimg_map(*this,ptr,T) *ptr = (*ptr<a)?a:((*ptr>b)?b:*ptr);
+      return *this;
+    }
+
+    //! Return the image of cutted values.
+    /**
+       \param a = minimum pixel value after cut.
+       \param b = maximum pixel value after cut.
+       \see cut(), normalize(), get_normalize().
+    **/
+    CImg get_cut(const T& a, const T& b) const { return CImg<T>(*this).cut(a,b); }
+
+    //! Quantify pixel values into \n levels.
+    /**
+       \param n = number of quantification levels
+       \see get_quantify().
+    **/
+    CImg& quantify(const unsigned int n=256) {
+      cimg_test(*this,"CImg<T>::quantify");
+      const CImgStats st(*this,false);
+      const double range = st.max-st.min;
+      cimg_map(*this,ptr,T) *ptr = (T)(st.min + range*(int)((*ptr-st.min)*(int)n/range)/n);
+      return *this;
+    }
+
+    //! Return a quantified image, with \n levels.
+    /**
+       \param n = number of quantification levels
+       \see quantify().
+    **/
+    CImg get_quantify(const unsigned int n=256) const { return CImg<T>(*this).quantify(n); }
+
+    //! Threshold the image.
+    /**
+       \param thres = threshold
+       \see get_threshold().
+    **/	
+    CImg& threshold(const T& thres) {
+      cimg_test(*this,"CImg<T>::threshold");
+      cimg_map(*this,ptr,T) *ptr = *ptr<=thres?(T)0:(T)1;
+      return *this;
+    }
+
+    //! Return a thresholded image.
+    /**
+       \param thres = threshold.
+       \see threshold().
+    **/
+    CImg get_threshold(const T& thres) const { return CImg<T>(*this).threshold(thres); }
+  
+    //! Return a rotated image.
+    /**
+       \param angle = rotation angle (in degrees).
+       \param cond = rotation type. can be :
+       - 0 = zero-value at borders
+       - 1 = repeat image at borders
+       - 2 = zero-value at borders and linear interpolation
+       \note Returned image will probably have a different size than the instance image *this.
+       \see rotate()
+    **/
+    CImg get_rotate(const float angle,const unsigned int cond=2) const {
+      cimg_test(*this,"CImg<T>::get_rotate");
+      CImg dest;
+      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
+        ca=(float)std::cos(rad), sa=(float)std::sin(rad);
+    
+      if (cond!=1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
+        const int iangle = (int)nangle/90;
+        switch (iangle) {
+        case 1: {
+          dest = CImg<T>(height,width,depth,dim); 
+          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(y,height-1-x,z,v); 
+        } break; 
+        case 2: {
+          dest = CImg<T>(width,height,depth,dim);
+          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v); 
+        } break;
+        case 3: {
+          dest = CImg<T>(height,width,depth,dim); 
+          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-y,x,z,v); 
+        } break;
+        default: 
+          return *this;        
+        }
+      } else { // generic version
+        const float 
+          ux  = (float)(std::fabs(width*ca)),  uy  = (float)(std::fabs(width*sa)),
+          vx  = (float)(std::fabs(height*sa)), vy  = (float)(std::fabs(height*ca)),
+          w2  = 0.5f*width,           h2  = 0.5f*height,
+          dw2 = 0.5f*(ux+vx),         dh2 = 0.5f*(uy+vy);
+        dest = CImg<T>((int)(ux+vx), (int)(uy+vy),depth,dim);
+
+        switch (cond) {
+        case 0: { 
+          cimg_mapXY(dest,x,y)
+            cimg_mapZV(*this,z,v) 
+            dest(x,y,z,v) = dirichlet_pix2d((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),(int)(h2 - (x-dw2)*sa + (y-dh2)*ca),z,v);
+        } break;
+        case 1: {
+          cimg_mapXY(dest,x,y)
+            cimg_mapZV(*this,z,v) 
+            dest(x,y,z,v) = (*this)(cimg::mod((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),width),
+                                    cimg::mod((int)(h2 - (x-dw2)*sa + (y-dh2)*ca),height),z,v);
+        } break;
+        default: {
+          cimg_mapXY(dest,x,y) {
+            const float X = w2 + (x-dw2)*ca + (y-dh2)*sa, Y = h2 - (x-dw2)*sa + (y-dh2)*ca;
+            const int ix = (int)X, iy = (int)Y;
+            if (ix<0 || ix>=dimx() || iy<0 || iy>=dimy()) cimg_mapZV(*this,z,v) dest(x,y,z,v) = 0;
+            else cimg_mapZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v);
+          }
+        } break; 
+        }
+      }
+      return dest;
+    }
+  
+    //! Rotate the image 
+    /**
+       \param angle = rotation angle (in degrees).
+       \param cond = rotation type. can be :
+       - 0 = zero-value at borders
+       - 1 = repeat image at borders
+       - 2 = zero-value at borders and linear interpolation
+       \see get_rotate()
+    **/
+    CImg& rotate(const float angle,const unsigned int cond=2) { return get_rotate(angle,cond).swap(*this); }
+  
+    //! Return a rotated image around the point (\c cx,\c cy).
+    /**
+       \param angle = rotation angle (in degrees).
+       \param cx = X-coordinate of the rotation center.
+       \param cy = Y-coordinate of the rotation center.
+       \param cond = rotation type. can be :
+       - 0 = zero-value at borders
+       - 1 = repeat image at borders
+       - 2 = zero-value at borders and linear interpolation
+       \see rotate()
+    **/
+    CImg get_rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=2) const {
+      cimg_test(*this,"CImg<T>::get_rotate");
+      CImg dest(*this,false);
+      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
+        ca=(float)std::cos(rad)/zoom, sa=(float)std::sin(rad)/zoom;
+    
+      if (cond!=1 && zoom==1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
+        const int iangle = (int)nangle/90;
+        switch (iangle) {
+        case 1: {
+          dest.fill(0);
+          const unsigned int
+            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
+            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
+            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
+            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
+          cimg_mapZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
+            dest(x,y,z,v) = (*this)(y-yoff,height-1-x+xoff,z,v);
+        } break;
+        case 2: {
+          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v); 
+        } break;
+        case 3: {
+          dest.fill(0);
+          const unsigned int
+            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
+            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
+            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
+            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
+          cimg_mapZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
+            dest(x,y,z,v) = (*this)(width-1-y+yoff,x-xoff,z,v);
+        } break;
+        default: 
+          return *this;        
+        }
+      } else 
+        switch (cond) { // generic version
+        case 0: { 
+          cimg_mapXY(dest,x,y)
+            cimg_mapZV(*this,z,v) 
+            dest(x,y,z,v) = dirichlet_pix2d((int)(cx + (x-cx)*ca + (y-cy)*sa),(int)(cy - (x-cx)*sa + (y-cy)*ca),z,v);
+        } break;
+        case 1: {
+          cimg_mapXY(dest,x,y)
+            cimg_mapZV(*this,z,v) 
+            dest(x,y,z,v) = (*this)(cimg::mod((int)(cx + (x-cx)*ca + (y-cy)*sa),width),
+                                    cimg::mod((int)(cy - (x-cx)*sa + (y-cy)*ca),height),z,v);
+        } break;
+        default: {
+          cimg_mapXY(dest,x,y) {
+            const float X = cx + (x-cx)*ca + (y-cy)*sa, Y = cy - (x-cx)*sa + (y-cy)*ca;
+            const int ix = (int)X, iy = (int)Y;
+            if (ix<0 || ix>=dimx() || iy<0 || iy>=dimy()) cimg_mapZV(*this,z,v) dest(x,y,z,v) = 0;
+            else cimg_mapZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v);
+          }
+        } break; 
+        }
+      return dest;
+    }
+  
+    //! Rotate the image around the point (\c cx,\c cy).
+    /**
+       \param angle = rotation angle (in degrees).
+       \param cx = X-coordinate of the rotation center.
+       \param cy = Y-coordinate of the rotation center.
+       \param cond = rotation type. can be :
+       - 0 = zero-value at borders
+       - 1 = repeat image at borders
+       - 2 = zero-value at borders and linear interpolation
+       \note Rotation does not change the image size. If you want to get an image with a new size, use get_rotate() instead.
+       \see get_rotate()
+    **/
+    CImg& rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=2) {
+      return get_rotate(angle,cx,cy,zoom,cond).swap(*this);
+    }
+ 
+    //! Return a resized image.
+    /**
+       \param pdx = Number of columns (new size along the X-axis).
+       \param pdy = Number of rows (new size along the Y-axis).
+       \param pdz = Number of slices (new size along the Z-axis).
+       \param pdv = Number of vector-channels (new size along the V-axis).
+       \param interp = Resizing type :
+       - 0 = no interpolation : additionnal space is filled with 0.
+       - 1 = bloc interpolation (nearest point).
+       - 2 = mosaic : image is repeated if necessary.
+       - 3 = linear interpolation.
+       - 4 = grid interpolation.
+       - 5 = bi-cubic interpolation.
+       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
+    **/
+    CImg get_resize(const int pdx=-100,const int pdy=-100,const int pdz=-100,const int pdv=-100,const unsigned int interp=1) const {
+      cimg_test(*this,"CImg<T>::get_resize");
+      const unsigned int 
+	dx = pdx<0?-pdx*width/100:pdx,
+	dy = pdy<0?-pdy*height/100:pdy,
+	dz = pdz<0?-pdz*depth/100:pdz, 
+	dv = pdv<0?-pdv*dim/100:pdv;
+      CImg res(dx?dx:1,dy?dy:1,dz?dz:1,dv?dv:1);
+      if (width==res.width && height==res.height && depth==res.depth && dim==res.dim) return *this;
+      switch (interp) {
+      case 0:                 // 0 filling
+        {
+          unsigned int w = cimg::min(dx,width), h = cimg::min(dy,height), d = cimg::min(dz,depth), v = cimg::min(dv,dim);
+          T *ptr = data;
+          w*=sizeof(T);
+          res.fill(0);
+          for (unsigned int k=0; k<v; k++) for (unsigned int z=0; z<d; z++) for (unsigned int y=0; y<h; y++) {
+            std::memcpy(res.ptr(0,y,z,k),ptr,w); ptr+=width; 
+          }
+        }
+        break;
+      case 1:               // bloc interpolation
+        {
+          const float sx = (float)width/res.width, sy = (float)height/res.height, sz = (float)depth/res.depth, sk = (float)dim/res.dim;
+          float cx,cy,cz,ck=0;
+          cimg_mapV(res,k) { cz = 0; 
+            cimg_mapZ(res,z) { cy = 0; 
+              cimg_mapY(res,y) { cx = 0; 
+                cimg_mapX(res,x) { res(x,y,z,k) = (*this)((unsigned int)cx,(unsigned int)cy,(unsigned int)cz,(unsigned int)ck); cx+=sx;
+                } cy+=sy;
+              } cz+=sz;
+            } ck+=sk;
+          }
+        }
+        break;
+      case 2:               // mosaic filling
+        {
+          cimg_mapXYZV(res,x,y,z,k) res(x,y,z,k) = (*this)(x%width,y%height,z%depth,k%dim);
+        }
+        break;
+      case 3:               // linear interpolation
+        {
+          const float
+            sx = res.width>1?(float)(width-1)/(res.width-1):0,
+            sy = res.height>1?(float)(height-1)/(res.height-1):0,
+            sz = res.depth>1?(float)(depth-1)/(res.depth-1):0,
+            sk = res.dim>1?(float)(dim-1)/(res.dim-1):0;
+          float cx,cy,cz,ck = 0;
+          cimg_mapV(res,k) { cz = 0; 
+            cimg_mapZ(res,z) { cy = 0;
+              cimg_mapY(res,y) { cx = 0; 
+                cimg_mapX(res,x) { res(x,y,z,k) = (T)linear_pix4d(cx,cy,cz,ck); cx+=sx;
+                } cy+=sy;
+              } cz+=sz;
+            } ck+=sk;
+          }
+        }
+        break;
+      case 4:              // grid filling
+        {
+          const float sx = (float)width/res.width, sy = (float)height/res.height, sz = (float)depth/res.depth, sk = (float)dim/res.dim;
+          res.fill(0);
+          cimg_mapXYZV(*this,x,y,z,k) res((int)(x/sx),(int)(y/sy),(int)(z/sz),(int)(k/sk)) = (*this)(x,y,z,k);
+        }
+        break;
+      case 5:             // cubic interpolation
+        {
+          const float
+            sx = res.width>1?(float)(width-1)/(res.width-1):0,
+            sy = res.height>1?(float)(height-1)/(res.height-1):0,
+            sz = res.depth>1?(float)(depth-1)/(res.depth-1):0,
+            sk = res.dim>1?(float)(dim-1)/(res.dim-1):0;
+          float cx,cy,cz,ck = 0;
+          cimg_mapV(res,k) { cz = 0;
+            cimg_mapZ(res,z) { cy = 0;
+              cimg_mapY(res,y) { cx = 0;
+                cimg_mapX(res,x) { res(x,y,z,k) = (T)cubic_pix2d(cx,cy,(int)cz,(int)ck); cx+=sx;
+                } cy+=sy;
+              } cz+=sz;
+            } ck+=sk;
+          }
+        }
+        break;      
+      }
+      return res;
+    }
+    //! Return a resized image.
+    /**
+       \param src = Image giving the geometry of the resize.
+       \param interp = Resizing type :
+       - 0 = no interpolation : additionnal space is filled with 0.
+       - 1 = bloc interpolation (nearest point).
+       - 2 = mosaic : image is repeated if necessary.
+       - 3 = linear interpolation.
+       - 4 = grid interpolation.
+       - 5 = bi-cubic interpolation.
+       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
+    **/
+    template<typename t> CImg get_resize(const CImg<t>& src,const unsigned int interp=1) const {
+      return get_resize(src.width,src.height,src.depth,src.dim,interp); 
+    }  
+
+    //! Return a resized image.
+    /**
+       \param disp = Display giving the geometry of the resize.
+       \param interp = Resizing type :
+       - 0 = no interpolation : additionnal space is filled with 0.
+       - 1 = bloc interpolation (nearest point).
+       - 2 = mosaic : image is repeated if necessary.
+       - 3 = linear interpolation.
+       - 4 = grid interpolation.
+       - 5 = bi-cubic interpolation.
+       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
+    **/
+    CImg get_resize(const CImgDisplay& disp,const unsigned int interp=1) const {
+      return get_resize(disp.width,disp.height,depth,dim,interp);
+    }
+
+    //! Resize the image.
+    /**
+       \param pdx = Number of columns (new size along the X-axis).
+       \param pdy = Number of rows (new size along the Y-axis).
+       \param pdz = Number of slices (new size along the Z-axis).
+       \param pdv = Number of vector-channels (new size along the V-axis).
+       \param interp = Resizing type :
+       - 0 = no interpolation : additionnal space is filled with 0.
+       - 1 = bloc interpolation (nearest point).
+       - 2 = mosaic : image is repeated if necessary.
+       - 3 = linear interpolation.
+       - 4 = grid interpolation.
+       - 5 = bi-cubic interpolation.
+       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).       
+    **/
+    CImg& resize(const int pdx=-100,const int pdy=-100,const int pdz=-100,const int pdv=-100,const unsigned int interp=1) {
+      const unsigned int
+        dx = pdx<0?-pdx*width/100 :(pdx==0?1:pdx),
+        dy = pdy<0?-pdy*height/100:(pdy==0?1:pdy),
+        dz = pdz<0?-pdz*depth/100 :(pdz==0?1:pdz),
+        dv = pdv<0?-pdv*dim/100   :(pdv==0?1:pdv);
+      if (width==dx && height==dy && depth==dz && dim==dv) return *this;
+      else return get_resize(dx,dy,dz,dv,interp).swap(*this);
+    }
+
+    //! Resize the image.
+    /**
+       \param src = Image giving the geometry of the resize.
+       \param interp = Resizing type :
+       - 0 = no interpolation : additionnal space is filled with 0.
+       - 1 = bloc interpolation (nearest point).
+       - 2 = mosaic : image is repeated if necessary.
+       - 3 = linear interpolation.
+       - 4 = grid interpolation.
+       - 5 = bi-cubic interpolation.
+       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
+    **/
+    template<typename t> CImg& resize(const CImg<t>& src,const unsigned int interp=1) { 
+      return resize(src.width,src.height,src.depth,src.dim,interp); 
+    }
+
+    //! Resize the image
+    /**
+       \param disp = Display giving the geometry of the resize.
+       \param interp = Resizing type :
+       - 0 = no interpolation : additionnal space is filled with 0.
+       - 1 = bloc interpolation (nearest point).
+       - 2 = mosaic : image is repeated if necessary.
+       - 3 = linear interpolation.
+       - 4 = grid interpolation.
+       - 5 = bi-cubic interpolation.
+       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
+    **/
+    CImg& resize(const CImgDisplay& disp,const unsigned int interp=1) {
+      return resize(disp.width,disp.height,depth,dim,interp);
+    }
+
+    //! Return an half-resized image, using a special filter.
+    /**
+       \see resize_halfXY(), resize(), get_resize().
+    **/
+    CImg get_resize_halfXY() const {
+      cimg_test(*this,"CImg<T>::get_resize_halfXY");
+      const CImg<float> mask(3,3);
+      mask.fill(0.07842776544f, 0.1231940459f, 0.07842776544f,
+                0.1231940459f,  0.1935127547f, 0.1231940459f,
+                0.07842776544f, 0.1231940459f, 0.07842776544f);
+      CImg_3x3(I,float);
+      CImg dest(width/2,height/2,depth,dim);
+      cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) dest(x/2,y/2,z,k) = (T)cimg_conv3x3(I,mask);
+      return dest;
+    }
+
+    //! Half-resize the image, using a special filter
+    /**
+       \see get_resize_halfXY(), resize(), get_resize().
+    **/
+    CImg& resize_halfXY() {	return get_resize_halfXY().swap(*this); }
+
+    //! Return a square region of the image, as a new image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
+       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
+       \param v0 = V-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
+       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
+       \param v1 = V-coordinate of the lower-right crop rectangle corner.
+       \see crop()
+    **/
+    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
+		  const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1) const {
+      cimg_test(*this,"CImg<T>::get_crop");
+      if (x0>=width || x1>=width || y0>=height || y1>=height || z0>=depth || z1>=depth || v0>=dim || v1>=dim || x1<x0 || y1<y0 || z1<z0 || v1<v0)
+        throw CImgArgumentException("CImg<%s>::get_crop() : Bad crop coordinates (%u,%u,%u,%u)-(%u,%u,%u,%u) in image (%u,%u,%u,%u)",
+                                    pixel_type(),x0,y0,z0,v0,x1,y1,z1,v1,width,height,depth,dim);
+      const unsigned int dx=x1-x0+1, dy=y1-y0+1, dz=z1-z0+1, dv=v1-v0+1;
+      CImg dest(dx,dy,dz,dv);
+      T *psrc = ptr(x0,y0,z0,v0), *pdest = dest.ptr(0,0,0,0);
+      if (dx!=width)
+        for (unsigned int k=0; k<dv; k++) {
+          for (unsigned int z=0; z<dz; z++) {
+            for (unsigned int y=0; y<dy; y++) {
+              std::memcpy(pdest,psrc,dx*sizeof(T));
+              pdest+=dx;
+              psrc+=width;
+            }
+            psrc+=width*(height-dy);
+          }
+          psrc+=width*height*(depth-dz);
+        }
+      else {
+        if (dy!=height)         
+          for (unsigned int k=0; k<dv; k++) {
+            for (unsigned int z=0; z<dz; z++) {
+              std::memcpy(pdest,psrc,dx*dy*sizeof(T));
+              pdest+=dx*dy;
+              psrc+=width*height;
+            }
+            psrc+=width*height*(depth-dz);
+          }
+        else {
+          if (dz!=depth)
+            for (unsigned int k=0; k<dv; k++) {
+              std::memcpy(pdest,psrc,dx*dy*dz*sizeof(T));
+              pdest+=dx*dy*dz;
+              psrc+=width*height*depth;
+            }
+          else std::memcpy(pdest,psrc,dx*dy*dz*dv*sizeof(T));
+        }
+      }
+      return dest;
+    }
+
+    //! Return a square region of the image, as a new image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
+       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
+       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
+       \see crop()   
+    **/
+    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
+		  const unsigned int x1,const unsigned int y1,const unsigned int z1) const {
+      return get_crop(x0,y0,z0,0,x1,y1,z1,dim-1);
+    }
+
+    //! Return a square region of the image, as a new image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
+       \see crop()   
+    **/
+    CImg get_crop(const unsigned int x0,const unsigned int y0,
+		  const unsigned int x1,const unsigned int y1) const {
+      return get_crop(x0,y0,0,0,x1,y1,depth-1,dim-1);
+    }
+
+    //! Return a square region of the image, as a new image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \see crop()   
+    **/
+    CImg get_crop(const unsigned int x0,const unsigned int x1) const { return get_crop(x0,0,0,0,x1,height-1,depth-1,dim-1); }
+
+    //! Replace the image by a square region of the image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
+       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
+       \param v0 = V-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
+       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
+       \param v1 = V-coordinate of the lower-right crop rectangle corner.
+       \see get_crop()
+    **/
+    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
+	       const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1) {
+      return get_crop(x0,y0,z0,v0,x1,y1,z1,v1).swap(*this);
+    }
+
+    //! Replace the image by a square region of the image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
+       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
+       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
+       \see get_crop()
+    **/
+    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
+	       const unsigned int x1,const unsigned int y1,const unsigned int z1) {
+      return crop(x0,y0,z0,0,x1,y1,z1,dim-1);
+    }
+
+    //! Replace the image by a square region of the image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
+       \see get_crop()
+    **/
+    CImg& crop(const unsigned int x0,const unsigned int y0,
+	       const unsigned int x1,const unsigned int y1) { return crop(x0,y0,0,0,x1,y1,depth-1,dim-1); }
+
+    //! Replace the image by a square region of the image
+    /**
+       \param x0 = X-coordinate of the upper-left crop rectangle corner.
+       \param x1 = X-coordinate of the lower-right crop rectangle corner.
+       \see get_crop()
+    **/
+    CImg& crop(const unsigned int x0,const unsigned int x1) { return crop(x0,0,0,0,x1,height-1,depth-1,dim-1); }
+
+    //! Get the channel \a v of the current image, as a new image.
+    /**
+       \param v0 = vector-channel to return.
+       \see channel(), get_slice(), slice(), get_plane(), plane().
+    **/
+    CImg get_channel(const unsigned int v0=0) const { return get_crop(0,0,0,v0,width-1,height-1,depth-1,v0); }
+
+    //! Get the z-slice \a z of *this, as a new image.
+    /**
+       \param z0 = Z-slice to return.
+       \see slice(), get_channel(), channel(), get_plane(), plane().
+    **/
+    CImg get_slice(const unsigned int z0=0) const { return get_crop(0,0,z0,0,width-1,height-1,z0,dim-1); }
+
+    //! Get the z-slice \a z of the channel \a v of the current image, as a new image.
+    /**
+       \param z0 = Z-slice of the plane to return.
+       \param v0 = V-channel of the plane to return.
+       \see plane(), get_channel(), channel(), get_slice(), slice().
+    **/
+    CImg get_plane(const unsigned int z0=0,const unsigned int v0=0) const { return get_crop(0,0,z0,v0,width-1,height-1,z0,v0); }
+
+    //! Return a reference to a set of points (x0->x1,y0,z0,v0) of the image. Use it carefully !
+    CImgROI<T> ref_pointset(const unsigned int xmin,const unsigned int xmax,const unsigned int y0=0,const unsigned int z0=0,const unsigned int v0=0) const {
+      cimg_test(*this,"CImg<T>::ref_pointset");
+      if (xmax<xmin || xmax>=width || y0>=height || z0>=depth || v0>=dim)
+        throw CImgArgumentException("CImg<%s>::ref_pointset() : Cannot return a reference (%u->%u,%u,%u,%u) from a (%u,%u,%u,%u) image",
+                                    pixel_type(),xmin,xmax,y0,z0,v0,width,height,depth,dim);
+      return CImgROI<T>(1+xmax-xmin,1,1,1,ptr(xmin,y0,z0,v0));
+    }
+
+    //! Return a reference to a set of lines (y0->y1,z0,v0) of the image. Use it carefully !
+    CImgROI<T> ref_lineset(const unsigned int ymin,const unsigned int ymax,const unsigned int z0=0,const unsigned int v0=0) const {
+      cimg_test(*this,"CImg<T>::ref_lineset");
+      if (ymax<ymin || ymax>=height || z0>=depth || v0>=dim)
+        throw CImgArgumentException("CImg<%s>::ref_lineset() : Cannot return a reference (0->%u,%u->%u,%u,%u) from a (%u,%u,%u,%u) image",
+                                    pixel_type(),width-1,ymin,ymax,z0,v0,width,height,depth,dim);
+      return CImgROI<T>(width,1+ymax-ymin,1,1,ptr(0,ymin,z0,v0));
+    }
+  
+    //! Return a reference to a set of planes (z0->z1,v0) of the image. Use it carefully !
+    CImgROI<T> ref_planeset(const unsigned int zmin,const unsigned int zmax,const unsigned int v0=0) const {
+      cimg_test(*this,"CImg<T>::ref_planeset");
+      if(zmax<zmin || zmax>=depth || v0>=dim)
+        throw CImgArgumentException("CImg<%s>::ref_planeset() : Cannot return a reference (0->%u,0->%u,%u->%u,%u) from a (%u,%u,%u,%u) image",
+                                    pixel_type(),width-1,height-1,zmin,zmax,v0,width,height,depth,dim);
+      return CImgROI<T>(width,height,1+zmax-zmin,1,ptr(0,0,zmin,v0));
+    }
+
+    //! Return a reference to a set of channels (v0->v1) of the image. Use it carefully !
+    CImgROI<T> ref_channelset(const unsigned int vmin,const unsigned int vmax) const {
+      cimg_test(*this,"CImg<T>::ref_channelset");
+      if (vmax<vmin || vmax>=dim)
+        throw CImgArgumentException("CImg<%s>::ref_channelset() : Cannot return a reference (0->%u,0->%u,0->%u,%u->%u) from a (%u,%u,%u,%u) image",
+                                    pixel_type(),width-1,height-1,depth-1,vmin,vmax,width,height,depth,dim);
+      return CImgROI<T>(width,height,depth,1+vmax-vmin,ptr(0,0,0,vmin));
+    }
+  
+    //! Return a reference to a line (y0,z0,v0) of the image. Use it carefully !
+    CImgROI<T> ref_line(const unsigned int y0,const unsigned int z0=0,const unsigned int v0=0) const { return ref_pointset(0,width-1,y0,z0,v0); }
+
+    //! Return a reference to a plane (z0,v0) of the image. Use it carefully !
+    CImgROI<T> ref_plane(const unsigned int z0,const unsigned int v0=0) const { return ref_lineset(0,height-1,z0,v0); }
+
+    //! Return a reference to a channel (v0) of the image. Use it carefully !
+    CImgROI<T> ref_channel(const unsigned int v0) const { return ref_planeset(0,depth-1,v0); }
+
+    //! Replace the image by one of its channel
+    CImg& channel(const unsigned int v0=0) { return get_channel(v0).swap(*this); }
+
+    //! Replace the image by one of its z-slice
+    CImg& slice(const unsigned int z0=0) { return get_slice(z0).swap(*this); }
+
+    //! Replace the image by one of its plane
+    CImg& plane(const unsigned int z0=0, const unsigned int v0=0) { return get_plane(z0,v0).swap(*this); }
+  
+    //! Flip an image along the specified axis
+    CImg& flip(const char axe='x') {
+      cimg_test(*this,"CImg<T>::flip");
+      T *pf,*pb,*buf=NULL;
+      switch (axe) {
+      case 'x':
+        {
+          pf = ptr(); pb = ptr(width-1);
+          for (unsigned int yzv=0; yzv<height*depth*dim; yzv++) { 
+            for (unsigned int x=0; x<width/2; x++) { const T val = *pf; *(pf++)=*pb; *(pb--)=val; }
+            pf+=width-width/2;
+            pb+=width+width/2;
+          }
+        }
+        break;
+      case 'y':
+        {
+          buf = new T[width];
+          pf = ptr(); pb = ptr(0,height-1);
+          for (unsigned int zv=0; zv<depth*dim; zv++) {
+            for (unsigned int y=0; y<height/2; y++) {
+              std::memcpy(buf,pf,width*sizeof(T));
+              std::memcpy(pf,pb,width*sizeof(T));
+              std::memcpy(pb,buf,width*sizeof(T));
+              pf+=width;
+              pb-=width;
+            }
+            pf+=width*(height-height/2);
+            pb+=width*(height+height/2);
+          }
+        }
+        break;
+      case 'z':
+        {
+          buf = new T[width*height];
+          pf = ptr(); pb = ptr(0,0,depth-1);
+          cimg_mapV(*this,v) {
+            for (unsigned int z=0; z<depth/2; z++) {
+              std::memcpy(buf,pf,width*height*sizeof(T));
+              std::memcpy(pf,pb,width*height*sizeof(T));
+              std::memcpy(pb,buf,width*height*sizeof(T));
+              pf+=width*height;
+              pb-=width*height;
+            }
+            pf+=width*height*(depth-depth/2);
+            pb+=width*height*(depth+depth/2);
+          }
+        }
+        break;
+      case 'v':
+        {
+          buf = new T[width*height*depth];
+          pf = ptr(); pb = ptr(0,0,0,dim-1);
+          for (unsigned int v=0; v<dim/2; v++) {
+            std::memcpy(buf,pf,width*height*depth*sizeof(T));
+            std::memcpy(pf,pb,width*height*depth*sizeof(T));
+            std::memcpy(pb,buf,width*height*depth*sizeof(T));
+            pf+=width*height*depth;
+            pb-=width*height*depth;
+          }
+        }
+        break;
+      default: cimg::warn(true,"CImg<%s>::flip() : unknow axe '%c', should be 'x','y','z' or 'v'",pixel_type(),axe);
+      }
+      if (buf) delete[] buf;
+      return *this;
+    }
+    //! Get a flipped version of the image, along the specified axis
+    CImg get_flip(const char axe='x') { return CImg<T>(*this).flip(axe); }
+    
+    //! Return a 2D representation of a 3D image, with three slices.
+    CImg get_3dplanes(const unsigned int px0,const unsigned int py0,const unsigned int pz0) const {
+      cimg_test(*this,"CImg<T>::get_3dplanes");
+      const unsigned int
+        x0=(px0>=width)?width-1:px0,
+        y0=(py0>=height)?height-1:py0,
+        z0=(pz0>=depth)?depth-1:pz0;
+      CImg res(width+depth,height+depth,1,dim);
+      res.fill((*this)[0]);
+      { cimg_mapXYV(*this,x,y,k) res(x,y,0,k)        = (*this)(x,y,z0,k); }
+      { cimg_mapYZV(*this,y,z,k) res(width+z,y,0,k)  = (*this)(x0,y,z,k); }
+      { cimg_mapXZV(*this,x,z,k) res(x,height+z,0,k) = (*this)(x,y0,z,k); }
+      return res;
+    }
+
+    //! Return the histogram of the image
+    CImg<float> get_histogram(const unsigned int nblevels=256,const T val_min=(T)0,const T val_max=(T)0) const {
+      cimg_test(*this,"CImg<T>::get_histogram");
+      if (nblevels<1) {
+        throw CImgArgumentException("CImg<%s>::get_histogram() : Can't compute an histogram with %u levels",
+                                    pixel_type(),nblevels);
+      }
+      T vmin=val_min,vmax=val_max;
+      CImg<float> res(nblevels,1,1,1,0);
+      if (vmin==vmax && vmin==0) { CImgStats st(*this,false); vmin = (T)st.min; vmax = (T)st.max; }
+      cimg_map(*this,ptr,T) { const int pos = (int)((*ptr-vmin)*(nblevels-1)/(vmax-vmin)); if (pos>=0 && pos<(int)nblevels) res[pos]++; }
+      return res;
+    }
+
+    //! Equalize the image histogram
+    CImg& equalize_histogram(const unsigned int nblevels=256) {
+      cimg_test(*this,"CImg<T>::equalize_histogram");
+      CImgStats st(*this,false);
+      CImg<float> hist = get_histogram(nblevels,(T)st.min,(T)st.max);
+      float cumul=0;
+      cimg_mapX(hist,pos) { cumul+=hist[pos]; hist[pos]=cumul; }
+      cimg_map(*this,ptr,T) {
+        unsigned int pos = (unsigned int)((*ptr-st.min)*nblevels/(1+st.max-st.min));
+        *ptr = (T)(st.min + (st.max-st.min)*hist[pos]/size());
+      }
+      return *this;
+    }
+    //! Return the histogram-equalized version of the current image.
+    CImg get_equalize_histogram(const unsigned int nblevels=256) const { return CImg<T>(*this).equalize_histogram(nblevels); }
+
+    //! Return the image of the vector norms of the current image.
+    CImg<float> get_norm_pointwise(int ntype=2) const {
+      cimg_test(*this,"CImg<T>::get_norm_pointwise");
+      CImg<float> res(width,height,depth);
+      switch(ntype) {
+      case -1:                // Linf norm
+        {
+          cimg_mapXYZ(*this,x,y,z) {
+            float n=0; cimg_mapV(*this,v) if (std::fabs((double)((*this)(x,y,z,v)))>n) n=(float)(*this)(x,y,z,v); res(x,y,z) = n;
+          }
+        } break;
+      case 1:               // L1 norm
+        {
+          cimg_mapXYZ(*this,x,y,z) {
+            float n=0; cimg_mapV(*this,v) n+=(float)std::fabs((double)((*this)(x,y,z,v))); res(x,y,z) = n;
+          }
+        } break;
+      default:              // L2 norm
+        {
+          cimg_mapXYZ(*this,x,y,z) {
+            float n=0; cimg_mapV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v)); res(x,y,z) = (float)std::sqrt((double)n);
+          }
+        } break;
+      }
+      return res;
+    }
+
+    //! Replace each pixel value with its vector norm
+    CImg& norm_pointwise() { return CImg<T>(get_norm_pointwise()).swap(*this); }
+
+    //! Return an image of the normalized vectors
+    CImg get_orientation_pointwise() const {
+      cimg_test(*this,"CImg<T>::get_orientation_pointwise");
+      CImg dest(width,height,depth,dim);
+      cimg_mapXYZ(dest,x,y,z) {
+        float n = 0;
+        cimg_mapV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v));
+        n = (float)std::sqrt((double)n);
+        if (n>0) cimg_mapV(dest,v) dest(x,y,z,v)=(T)((*this)(x,y,z,v)/n); else cimg_mapV(dest,v) dest(x,y,z,v)=0;
+      }
+      return dest;
+    }
+
+    //! Replace each pixel value with its normalized vector component
+    CImg& orientation_pointwise() { return get_orientation_pointwise().swap(*this); }
+
+    //! Split current image into a list.
+    /**
+       - Splitting process is done along the specified dimension \c Axe.
+    **/
+    CImgl<T> get_split(const char axe='v',const unsigned int nb=0) const {
+      cimg_test(*this,"CImg<T>::get_split");
+      const char naxe = cimg::uncase(axe);
+      if (naxe!='x' && naxe!='y' && naxe!='z' && naxe!='v')
+	throw CImgArgumentException("CImg<%s>::get_split() : Unknow axe '%c', use rather 'x','y','z' or 'v'",pixel_type(),axe);
+      CImgl<T> res;
+      switch (naxe) {
+      case 'x':
+	res = CImgl<T>(nb?nb:width);
+	cimgl_map(res,l) res[l] = get_crop(l*width/res.size,0,0,0,(l+1)*width/res.size-1,height-1,depth-1,dim-1);
+	break;
+      case 'y':
+	res = CImgl<T>(nb?nb:height);
+	cimgl_map(res,l) res[l] = get_crop(0,l*height/res.size,0,0,width-1,(l+1)*height/res.size-1,depth-1,dim-1);
+	break;
+      case 'z':
+	res = CImgl<T>(nb?nb:depth);
+	cimgl_map(res,l) res[l] = get_crop(0,0,l*depth/res.size,0,width-1,height-1,(l+1)*depth/res.size-1,dim-1);
+	break;
+      case 'v':
+	res = CImgl<T>(nb?nb:dim);
+	cimgl_map(res,l) res[l] = get_crop(0,0,0,l*dim/res.size,width-1,height-1,depth-1,(l+1)*dim/res.size-1);
+	break;
+      }
+      return res;
+    }
+
+    //! Return a list of images, corresponding to the XY-gradients of an image.
+    CImgl<T> get_gradientXY(const int scheme=0) const {
+      cimg_test(*this,"CImg<T>::get_gradientXY");
+      CImgl<T> res(2,width,height,depth,dim);
+      CImg_3x3(I,T);
+      switch(scheme) {
+      case -1: { // backward finite differences
+        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) { res[0](x,y,z,k) = Icc-Ipc; res[1](x,y,z,k) = Icc-Icp; } 
+      } break;
+      case 1: { // forward finite differences
+        cimg_mapZV(*this,z,k) cimg_map2x2(*this,x,y,z,k,I) { res[0](x,y,0,k) = Inc-Icc; res[1](x,y,z,k) = Icn-Icc; }
+      } break;
+      case 2: { // using Sobel mask
+        const float a = 1, b = 2;
+        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) {
+          res[0](x,y,z,k) = (T)(-a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn);
+          res[1](x,y,z,k) = (T)(-a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn);
+        }
+      } break;
+      case 3: { // using rotation invariant mask
+        const float a = (float)(0.25*(2-std::sqrt(2.0))), b = (float)(0.5f*(std::sqrt(2.0)-1));
+        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) {
+          res[0](x,y,z,k) = (T)(-a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn);
+          res[1](x,y,z,k) = (T)(-a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn);
+        }
+      } break;
+      case 0:   
+      default: { // central finite differences
+        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) { 
+          res[0](x,y,z,k) = (T)(0.5*(Inc-Ipc));
+          res[1](x,y,z,k) = (T)(0.5*(Icn-Icp)); 
+        } 
+      } break;
+      }
+      return res;
+    }
+
+    //! Return a list of images, corresponding to the XYZ-gradients of an image.
+    CImgl<T> get_gradientXYZ(const int scheme=0) const {
+      cimg_test(*this,"CImg<T>::get_gradientXYZ");
+      CImgl<T> res(3,width,height,depth,dim);
+      CImg_3x3x3(I,T);
+      switch(scheme) {
+      case -1: { // backward finite differences
+        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) { 
+          res[0](x,y,z,k) = Iccc-Ipcc;
+          res[1](x,y,z,k) = Iccc-Icpc;
+          res[2](x,y,z,k) = Iccc-Iccp; 
+        }
+      } break;
+      case 1: { // forward finite differences
+        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) {
+          res[0](x,y,z,k) = Incc-Iccc; 
+          res[1](x,y,z,k) = Icnc-Iccc;
+          res[2](x,y,z,k) = Iccn-Iccc; 
+        } 
+      } break;
+      case 0: 
+      default: { // central finite differences
+        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) {
+          res[0](x,y,z,k) = (T)(0.5*(Incc-Ipcc));
+          res[1](x,y,z,k) = (T)(0.5*(Icnc-Icpc)); 
+          res[2](x,y,z,k) = (T)(0.5*(Iccn-Iccp)); 
+        } 
+      } break;
+      }
+      return res;
+    }
+
+    //@}
+    //--------------------------------------
+    //--------------------------------------
+    //
+    //! \name Color conversion functions
+    //@{
+    //--------------------------------------
+    //--------------------------------------
+  
+    //! Convert color pixels from (R,G,B) to (X,Y,Z)_709.
+    CImg& RGBtoXYZ() {
+      cimg_test(*this,"CImg<T>::RGBtoXYZ");
+      if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoXYZ() : Input image dimension is dim=%u, should be a (R,G,B) image (dim=3)",
+                                              pixel_type(),dim);
+      cimg_mapXYZ(*this,x,y,z) {
+        const T R = (*this)(x,y,z,0), G = (*this)(x,y,z,1), B = (*this)(x,y,z,2);
+        (*this)(x,y,z,0) = (T)(0.412453*R + 0.357580*G + 0.180423*B);
+        (*this)(x,y,z,1) = (T)(0.212671*R + 0.715160*G + 0.072169*B);
+        (*this)(x,y,z,2) = (T)(0.019334*R + 0.119193*G + 0.950227*B);
+      }
+      return *this;
+    }
+    //! Get a new image with (X,Y,Z) color-based pixels from a (R,G,B) image.
+    CImg get_RGBtoXYZ() const { return CImg<T>(*this).RGBtoXYZ(); }
+
+    //! Convert (X,Y,Z)_709 pixels of a color image into the (R,G,B) color space.
+    CImg& XYZtoRGB() {
+      cimg_test(*this,"CImg<T>::XYZtoRGB");
+      if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoRGB() : Input image dimension is dim=%u, should be a (X,Y,Z) image (dim=3)",
+                                              pixel_type(),dim);
+      cimg_mapXYZ(*this,x,y,z) {
+        const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
+        (*this)(x,y,z,0) = (T)(3.240479*X  - 1.537150*Y - 0.498535*Z);
+        (*this)(x,y,z,1) = (T)(-0.969256*X + 1.875992*Y + 0.041556*Z);
+        (*this)(x,y,z,2) = (T)(0.055648*X  - 0.204043*Y + 1.057311*Z);
+      }
+      return *this;
+    }
+    //! Get a new image with (R,G,B) color-based pixels from a (X,Y,Z) image.
+    CImg get_XYZtoRGB() const { return CImg<T>(*this).XYZtoRGB(); }
+
+    //! Convert (X,Y,Z)_709 pixels of a color image into the (L*,a*,b*) color space.
+    CImg& XYZtoLab() {
+      cimg_test(*this,"CImg<T>::XYZtoLab");
+      if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoLab() : Input image dimension is dim=%u, should be a (X,Y,Z) image (dim=3)",
+                                              pixel_type(),dim);
+      CImg<double> white = CImg<double>(1,1,1,3).fill(1,1,1).RGBtoXYZ();
+      const double Xn = white(0), Yn = white(1), Zn = white(2);
+    
+      cimg_mapXYZ(*this,x,y,z) {
+        const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
+        const double L = (T)(116*std::pow(Y/Yn,1/3.0)-16);
+        (*this)(x,y,z,0) = (T)(L>=0?L:0);
+        (*this)(x,y,z,1) = (T)(500*(std::pow(X/Xn,1/3.0)-std::pow(Y/Yn,1/3.0)));
+        (*this)(x,y,z,2) = (T)(200*(std::pow(Y/Yn,1/3.0)-std::pow(Z/Zn,1/3.0)));
+      }
+      return *this;
+    }
+    //! Get a new image with (L,a,b) color-based pixels from a (X,Y,Z) image.
+    CImg get_XYZtoLab() const { return CImg<T>(*this).XYZtoLab(); }
+
+    //@}
+    //--------------------------------------
+    //--------------------------------------
+    //
+    //! \name Drawing functions
+    //@{
+    //--------------------------------------
+    //--------------------------------------
+  
+    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0,\c z0).
+    /**
+       \param x0 = X-coordinate of the vector-valued pixel to plot.
+       \param y0 = Y-coordinate of the vector-valued pixel to plot.
+       \param z0 = Z-coordinate of the vector-valued pixel to plot.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_point(const int x0,const int y0,const int z0,
+                     const T *const color,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_point");
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_point() : specified color is (null)",pixel_type());
+      if (x0>=0 && y0>=0 && z0>=0 && x0<dimx() && y0<dimy() && z0<dimz()) {
+        const T *col=color;
+        const unsigned int whz = width*height*depth;
+        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+        T *ptrd = ptr(x0,y0,z0,0);
+        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = *(col++); ptrd+=whz; }
+        else cimg_mapV(*this,k) { *ptrd=(T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whz; }
+      }
+      return *this;
+    }
+
+    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0).
+    /**
+       \param x0 = X-coordinate of the vector-valued pixel to plot.
+       \param y0 = Y-coordinate of the vector-valued pixel to plot.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_point(const int x0,const int y0,const T *const color,const float opacity=1) { 
+      return draw_point(x0,y0,0,color,opacity); 
+    }
+
+    //! Draw a 2D colored line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
+    /**
+       \param x0 = X-coordinate of the starting point of the line.
+       \param y0 = Y-coordinate of the starting point of the line.
+       \param x1 = X-coordinate of the ending point of the line.
+       \param y1 = Y-coordinate of the ending point of the line.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param pattern = A long integer whose bits describes the line pattern.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
+                    const T *const color,const unsigned long pattern=~0L,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_line"); 
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : specified color is (null)",pixel_type());
+      const T* col=color;
+      unsigned long hatch=1;     
+      int nx0=x0, nx1=x1, ny0=y0, ny1=y1;
+      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1);
+      if (nx1<0 || nx0>=dimx()) return *this;
+      if (nx0<0) { ny0-=nx0*(ny1-ny0)/(nx1-nx0); nx0=0; }
+      if (nx1>=dimx()) { ny1+=(nx1-dimx())*(ny0-ny1)/(nx1-nx0); nx1=dimx()-1;}
+      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
+      if (ny1<0 || ny0>=dimy()) return *this;
+      if (ny0<0) { nx0-=ny0*(nx1-nx0)/(ny1-ny0); ny0=0; }
+      if (ny1>=dimy()) { nx1+=(ny1-dimy())*(nx0-nx1)/(ny1-ny0); ny1=dimy()-1;}
+      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),ny1-ny0), whz = width*height*depth;
+      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0;
+      float x = (float)nx0, y = (float)ny0;
+      if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) {
+        if (!(~pattern) || (~pattern && pattern&hatch)) {
+          T* ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);      
+          cimg_mapV(*this,k) { *ptrd=*(col++); ptrd+=whz; }
+          col-=dim;
+        }
+        x+=px; y+=py; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
+      } else {
+        const float nopacity = cimg::abs(opacity), copacity=1-cimg::max(opacity,0.0f);
+        for (unsigned int t=0; t<=dmax; t++) {
+          if (!(~pattern) || (~pattern && pattern&hatch)) {
+            T* ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
+            cimg_mapV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
+            col-=dim;
+          }
+          x+=px; y+=py; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
+        }
+      }
+      return *this;
+    }
+  
+    //! Draw a 3D colored line in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
+    /**
+       \param x0 = X-coordinate of the starting point of the line.
+       \param y0 = Y-coordinate of the starting point of the line.
+       \param z0 = Z-coordinate of the starting point of the line.
+       \param x1 = X-coordinate of the ending point of the line.
+       \param y1 = Y-coordinate of the ending point of the line.
+       \param Z1 = Z-coordinate of the ending point of the line.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param pattern = A long integer whose bits describes the line pattern.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_line(const int x0,const int y0,const int z0,const int x1,const int y1,const int z1,
+                    const T *const color,const unsigned long pattern=~0L,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_line"); 
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : specified color is (null)",pixel_type());
+      const T* col=color;
+      unsigned long hatch=1;
+      int nx0=x0, ny0=y0, nz0=z0, nx1=x1, ny1=y1, nz1=z1;
+      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
+      if (nx1<0 || nx0>=dimx()) return *this;
+      if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; nz0-=nx0*(nz1-nz0)/D; nx0=0; }
+      if (nx1>=dimx()) { const int d=nx1-dimx(), D=nx1-nx0; ny1+=d*(ny0-ny1)/D; nz1+=d*(nz0-nz1)/D; nx1=dimx()-1;}
+      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
+      if (ny1<0 || ny0>=dimy()) return *this;
+      if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; nz0-=ny0*(nz1-nz0)/D; ny0=0; }
+      if (ny1>=dimy()) { const int d=ny1-dimy(), D=ny1-ny0; nx1+=d*(nx0-nx1)/D; nz1+=d*(nz0-nz1)/D; ny1=dimy()-1;}
+      if (nz0>nz1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
+      if (nz1<0 || nz0>=dimz()) return *this;
+      if (nz0<0) { const int D=nz1-nz0; nx0-=nz0*(nx1-nx0)/D; ny0-=nz0*(ny1-ny0)/D; nz0=0; }
+      if (nz1>=dimz()) { const int d=nz1-dimz(), D=nz1-nz0; nx1+=d*(nx0-nx1)/D; ny1+=d*(ny0-ny1)/D; nz1=dimz()-1;}
+      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),std::abs(ny1-ny0),nz1-nz0), whz = width*height*depth;
+      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0, pz = dmax?(nz1-nz0)/(float)dmax:0;
+      float x = (float)nx0, y = (float)ny0, z = (float)nz0;
+      if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) { 
+        if (!(~pattern) || (~pattern && pattern&hatch)) {
+          T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
+          cimg_mapV(*this,k) { *ptrd=*(col++); ptrd+=whz; }        
+          col-=dim; 
+        }
+        x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
+      } else {
+        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+        for (unsigned int t=0; t<=dmax; t++) { 
+          if (!(~pattern) || (~pattern && pattern&hatch)) {
+            T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
+            cimg_mapV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
+            col-=dim; 
+          }
+          x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));        
+        }
+      }
+      return *this;
+    }
+
+    //! Draw a 2D textured line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
+    /**
+       \param x0 = X-coordinate of the starting point of the line.
+       \param y0 = Y-coordinate of the starting point of the line.
+       \param x1 = X-coordinate of the ending point of the line.
+       \param y1 = Y-coordinate of the ending point of the line.
+       \param texture = a colored texture image used to draw the line color.
+       \param tx0 = X-coordinate of the starting point of the texture.
+       \param ty0 = Y-coordinate of the starting point of the texture.
+       \param tx1 = X-coordinate of the ending point of the texture.
+       \param ty1 = Y-coordinate of the ending point of the texture.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param pattern = a long integer whose bits describes the line pattern.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported, but texture coordinates do not support clipping.
+    **/
+    template<typename t> CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
+                                         const CImg<t>& texture,
+                                         const int tx0,const int ty0,const int tx1,const int ty1,
+                                         const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_line"); cimg_test(texture,"CImg<T>::draw_line");
+      if (texture.dim<dim)
+        throw CImgArgumentException("CImg<%s>::draw_line() : texture has %u channel while image has %u channels",texture.dim,dim);
+      int nx0=x0, ny0=y0, nx1=x1, ny1=y1, ntx0=tx0, nty0=ty0, ntx1=tx1, nty1=ty1;
+      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
+      if (nx1<0 || nx0>=dimx()) return *this;
+      if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; ntx0-=nx0*(ntx1-ntx0)/D; nty0-=nx0*(nty1-nty0)/D; nx0=0; }
+      if (nx1>=dimx()) { const int d=nx1-dimx(),D=nx1-nx0; ny1+=d*(ny0-ny1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; nx1=dimx()-1; }
+      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
+      if (ny1<0 || ny0>=dimy()) return *this;
+      if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; ntx0-=ny0*(ntx1-ntx0)/D; nty0-=ny0*(nty1-nty0)/D; ny0=0; }
+      if (ny1>=dimy()) { const int d=ny1-dimy(),D=ny1-ny0; nx1+=d*(nx0-nx1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; ny1=dimy()-1; }
+      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),ny1-ny0), 
+        whz = width*height*depth, twhz = texture.width*texture.height*texture.depth;
+      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0,
+        tpx = dmax?(ntx1-ntx0)/(float)dmax:0, tpy = dmax?(nty1-nty0)/(float)dmax:0;
+      float x = (float)nx0, y = (float)ny0, tx = (float)ntx0, ty = (float)nty0;
+      if (opacity>=1) for (unsigned int tt=0; tt<=dmax; tt++) { 
+        T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
+        t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
+        cimg_mapV(*this,k) { *ptrd = (T)(*ptrs); ptrd+=whz; ptrs+=twhz; }
+        x+=px; y+=py; tx+=tpx; ty+=tpy;
+      } else {
+        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+        for (unsigned int tt=0; tt<=dmax; tt++) { 
+          T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
+          t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
+          cimg_mapV(*this,k) { *ptrd = (T)(nopacity*(*ptrs) + copacity*(*ptrd)); ptrd+=whz; ptrs+=twhz; }
+          x+=px; y+=py; tx+=tpx; ty+=tpy;
+        }
+      }
+      return *this;
+    }
+
+    //! Draw a 2D colored arrow in the instance image, at coordinates (\c x0,\c y0)->(\c x1,\c y1).
+    /**
+       \param x0 = X-coordinate of the starting point of the arrow (tail).
+       \param y0 = Y-coordinate of the starting point of the arrow (tail).
+       \param x1 = X-coordinate of the ending point of the arrow (head).
+       \param y1 = Y-coordinate of the ending point of the arrow (head).
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param angle = aperture angle of the arrow head
+       \param length = length of the arrow head. If <0, described as a percentage of the arrow length.
+       \param pattern = a long integer whose bits describes the line pattern.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_arrow(const int x0,const int y0,const int x1,const int y1,
+                     const T *const color,
+                     const float angle=30,const float length=-10,const unsigned long pattern=~0L,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_arrow");
+      const float u = (float)(x0-x1), v = (float)(y0-y1), sq = u*u+v*v,
+        deg = (float)(angle*cimg::PI/180), ang = (sq>0)?(float)std::atan2(v,u):0.0f,
+        l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
+      if (sq>0) {
+        const double cl = std::cos(ang-deg), sl = std::sin(ang-deg), cr = std::cos(ang+deg), sr = std::sin(ang+deg);        
+        const int 
+          xl = x1+(int)(l*cl), yl = y1+(int)(l*sl),
+          xr = x1+(int)(l*cr), yr = y1+(int)(l*sr),
+          xc = x1+(int)((l+1)*(cl+cr))/2, yc = y1+(int)((l+1)*(sl+sr))/2;
+        draw_line(x0,y0,xc,yc,color,pattern,opacity).draw_triangle(x1,y1,xl,yl,xr,yr,color,opacity);
+      } else draw_point(x0,y0,color,opacity);
+      return *this;
+    }
+
+    //! Draw a sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
+    /**
+       \param sprite = sprite image.
+       \param x0 = X-coordinate of the sprite position in the instance image.
+       \param y0 = Y-coordinate of the sprite position in the instance image.
+       \param z0 = Z-coordinate of the sprite position in the instance image.
+       \param v0 = V-coordinate of the sprite position in the instance image.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    template<typename t> CImg& draw_image(const CImg<t>& sprite,
+                                          const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image");
+      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
+      const int 
+        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
+        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
+        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
+        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
+      const t *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
+        (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
+      const unsigned int
+        offX = width-lX, soffX = sprite.width-lX,
+        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
+        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
+      if (lX>0 && lY>0 && lZ>0 && lV>0)
+        for (int v=0; v<lV; v++) {
+          for (int z=0; z<lZ; z++) {
+            for (int y=0; y<lY; y++) {
+              if (opacity>=1) for (int x=0; x<lX; x++) *(ptrd++) = (T)(*(ptrs++));
+              else for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
+              ptrd+=offX; ptrs+=soffX;
+            }
+            ptrd+=offY; ptrs+=soffY;
+          }
+          ptrd+=offZ; ptrs+=soffZ;
+        }
+      return *this;
+    }
+
+#if ( !defined(_MSC_VER) || _MSC_VER>1200 )
+    CImg& draw_image(const CImg<T>& sprite,const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image");
+      if (this==&sprite) return draw_image(CImg<T>(sprite),x0,y0,z0,v0,opacity);
+      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
+      const int 
+        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
+        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
+        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
+        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
+      const T *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
+        (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
+      const unsigned int
+        offX = width-lX, soffX = sprite.width-lX,
+        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
+        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ),
+        slX = lX*sizeof(T);    
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
+      if (lX>0 && lY>0 && lZ>0 && lV>0)
+        for (int v=0; v<lV; v++) {
+          for (int z=0; z<lZ; z++) {
+            if (opacity>=1) for (int y=0; y<lY; y++) { std::memcpy(ptrd,ptrs,slX); ptrd+=width; ptrs+=sprite.width; }
+            else for (int y=0; y<lY; y++) {
+              for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
+              ptrd+=offX; ptrs+=soffX;
+            }
+            ptrd+=offY; ptrs+=soffY;
+          }
+          ptrd+=offZ; ptrs+=soffZ;
+        }
+      return *this;
+    }
+#endif
+
+    //! Draw a masked sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
+    /**
+       \param sprite = sprite image.
+       \param mask = mask image.
+       \param x0 = X-coordinate of the sprite position in the instance image.
+       \param y0 = Y-coordinate of the sprite position in the instance image.
+       \param z0 = Z-coordinate of the sprite position in the instance image.
+       \param v0 = V-coordinate of the sprite position in the instance image.
+       \param mask_valmax = Maximum pixel value of the mask image \c mask.
+       \param opacity = opacity of the drawing.
+       \note Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
+       \note Clipping is supported.
+       \note Dimensions along x,y and z of \c sprite and \c mask must be the same.
+    **/
+    template<typename ti,typename tm> CImg& draw_image(const CImg<ti>& sprite,const CImg<tm>& mask,
+                                                       const int x0=0,const int y0=0,const int z0=0,const int v0=0,
+                                                       const tm mask_valmax=1,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image"); cimg_test(mask,"CImg<T>::draw_image");
+      if ((void*)this==(void*)&sprite) return draw_image(CImg<T>(sprite),mask,x0,y0,z0,v0);
+      if(mask.width!=sprite.width || mask.height!=sprite.height || mask.depth!=sprite.depth)
+        throw CImgArgumentException("CImg<%s>::draw_image() : mask dimension is (%u,%u,%u,%u), while sprite is (%u,%u,%u,%u)",
+                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,sprite.width,sprite.height,sprite.depth,sprite.dim);
+      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
+      const int
+        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
+        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
+        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),      
+        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);    
+      const int coff = -(bx?x0:0)-(by?y0*mask.dimx():0)-(bz?z0*mask.dimx()*mask.dimy():0)-
+        (bv?v0*mask.dimx()*mask.dimy()*mask.dimz():0),
+        ssize = mask.dimx()*mask.dimy()*mask.dimz();
+      const ti *ptrs = sprite.ptr() + coff;
+      const tm *ptrm = mask.ptr() + coff;
+      const unsigned int
+        offX = width-lX, soffX = sprite.width-lX,
+        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
+        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
+      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
+      if (lX>0 && lY>0 && lZ>0 && lV>0)
+        for (int v=0; v<lV; v++) {
+          ptrm = mask.data + (ptrm - mask.data)%ssize;
+          for (int z=0; z<lZ; z++) {
+            for (int y=0; y<lY; y++) {
+              for (int x=0; x<lX; x++) {
+                const float mopacity = *(ptrm++)*opacity,
+                  nopacity = cimg::abs(mopacity), copacity = mask_valmax-cimg::max(mopacity,0.0f);
+                *(ptrd++) = (T)((nopacity*(*(ptrs++))+copacity*(*ptrd))/mask_valmax);
+              }
+              ptrd+=offX; ptrs+=soffX; ptrm+=soffX;
+            }
+            ptrd+=offY; ptrs+=soffY; ptrm+=soffY;
+          }
+          ptrd+=offZ; ptrs+=soffZ; ptrm+=soffZ;
+        }
+      return *this;
+    }
+
+    //! Draw a 4D filled rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0)-(\c x1,\c y1,\c z1,\c v1).
+    /**
+       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
+       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
+       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
+       \param v0 = V-coordinate of the upper-left rectangle corner in the instance image.
+       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
+       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
+       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
+       \param v1 = V-coordinate of the lower-right rectangle corner in the instance image.
+       \param val = scalar value used to fill the rectangle area.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_rectangle(const int x0,const int y0,const int z0,const int v0,
+                         const int x1,const int y1,const int z1,const int v1,
+                         const T& val,float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_rectangle");
+      const bool bx=(x0<x1), by=(y0<y1), bz=(z0<z1), bv=(v0<v1);
+      const int nx0=bx?x0:x1, nx1=bx?x1:x0, ny0=by?y0:y1, ny1=by?y1:y0, nz0=bz?z0:z1, nz1=bz?z1:z0, nv0=bv?v0:v1, nv1=bv?v1:v0;
+      const int 
+        lX = (1+nx1-nx0) + (nx1>=dimx()?dimx()-1-nx1:0) + (nx0<0?nx0:0),
+        lY = (1+ny1-ny0) + (ny1>=dimy()?dimy()-1-ny1:0) + (ny0<0?ny0:0),
+        lZ = (1+nz1-nz0) + (nz1>=dimz()?dimz()-1-nz1:0) + (nz0<0?nz0:0),
+        lV = (1+nv1-nv0) + (nv1>=dimv()?dimv()-1-nv1:0) + (nv0<0?nv0:0);
+      const unsigned int offX = width-lX, offY = width*(height-lY), offZ = width*height*(depth-lZ);
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      T *ptrd = ptr(nx0<0?0:nx0,ny0<0?0:ny0,nz0<0?0:nz0,nv0<0?0:nv0);
+      if (lX>0 && lY>0 && lZ>0 && lV>0)
+        for (int v=0; v<lV; v++) {
+          for (int z=0; z<lZ; z++) {
+            for (int y=0; y<lY; y++) {
+              if (opacity>=1) {
+                if (sizeof(T)!=1) { for (int x=0; x<lX; x++) *(ptrd++) = val; ptrd+=offX; }
+                else { std::memset(ptrd,(int)val,lX); ptrd+=width; }
+              } else { for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*val+copacity*(*ptrd)); ptrd++; } ptrd+=offX; }
+            }
+            ptrd+=offY;
+          }
+          ptrd+=offZ;
+        }  
+      return *this;
+    }
+
+    //! Draw a 3D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
+    /**
+       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
+       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
+       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
+       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
+       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
+       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_rectangle(const int x0,const int y0,const int z0,
+                         const int x1,const int y1,const int z1,
+                         const T *const color,const float opacity=1) {
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_rectangle : specified color is (null)",pixel_type());
+      cimg_mapV(*this,k) draw_rectangle(x0,y0,z0,k,x1,y1,z1,k,color[k],opacity);
+      return *this;
+    }
+
+    //! Draw a 2D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
+    /**
+       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
+       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
+       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
+       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_rectangle(const int x0,const int y0,const int x1,const int y1,
+                         const T *const color,const float opacity=1) {
+      draw_rectangle(x0,y0,0,x1,y1,depth-1,color,opacity);
+      return *this;
+    }
+  
+    //! Draw a 2D filled colored triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
+    /**
+       \param x0 = X-coordinate of the first corner in the instance image.
+       \param y0 = Y-coordinate of the first corner in the instance image.
+       \param x1 = X-coordinate of the second corner in the instance image.
+       \param y1 = Y-coordinate of the second corner in the instance image.
+       \param x2 = X-coordinate of the third corner in the instance image.
+       \param y2 = Y-coordinate of the third corner in the instance image.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    CImg& draw_triangle(const int x0,const int y0,
+                        const int x1,const int y1,
+                        const int x2,const int y2,
+                        const T *const color, const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_triangle"); 
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_triangle : specified color is (null).");
+      const T* col = color;
+      int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,whz=width*height*depth;
+      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
+      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2);
+      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2);
+      if (ny0>=dimy() || ny2<0) return *this;
+      const float 
+        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
+        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
+        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1);
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      float xleft = (float)nx0, xright = xleft, pleft = (p1<p2)?p1:p2, pright = (p1<p2)?p2:p1;
+      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; }
+
+      const int ya = ny1>dimy()?height:ny1;
+      for (int y=ny0<0?0:ny0; y<ya; y++) {
+        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<width)?(int)xright:(width-1);
+        if (xmin<=xmax) {
+          const int offx = whz-xmax+xmin-1;
+          T *ptrd = ptr(xmin,y,0,0);
+          if (opacity>=1) cimg_mapV(*this,k) { 
+            if (sizeof(T)!=1) { const T& cval=*(col++); for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval; ptrd+=offx; }
+            else { std::memset(ptrd,(int)*(col++),xmax-xmin+1); ptrd+=whz; }
+          } else cimg_mapV(*this,k) {
+            const T& cval=*(col++); 
+            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity + copacity*(*ptrd)); ptrd++; } 
+            ptrd+=offx;
+          }
+          col-=dim;
+        }
+        xleft+=pleft; xright+=pright;
+      }    
+
+      if (p1<p2) { xleft=(float)nx1;  pleft=p3;  if (ny1<0) xleft-=ny1*pleft; } 
+      else       { xright=(float)nx1; pright=p3; if (ny1<0) xright-=ny1*pright; }
+
+      const int yb = ny2>=dimy()?height-1:ny2;
+      for (int yy=ny1<0?0:ny1; yy<=yb; yy++) {
+        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<width)?(int)xright:(width-1);
+        if (xmin<=xmax) {
+          const int offx=whz-xmax+xmin-1;
+          T *ptrd = ptr(xmin,yy,0,0);
+          if (opacity>=1) cimg_mapV(*this,k) { 
+            if (sizeof(T)!=1) { const T& cval=*(col++); for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval; ptrd+=offx; }
+            else { std::memset(ptrd,(int)*(col++),xmax-xmin+1); ptrd+=whz; }
+          } else cimg_mapV(*this,k) { 
+            const T& cval=*(col++);
+            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity + copacity*(*ptrd)); ptrd++; }
+            ptrd+=offx; 
+          }
+          col-=dim;
+        }
+        xleft+=pleft; xright+=pright;
+      }    
+      return *this;
+    }
+  
+    //! Draw a 2D textured triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
+    /**
+       \param x0 = X-coordinate of the first corner in the instance image.
+       \param y0 = Y-coordinate of the first corner in the instance image.
+       \param x1 = X-coordinate of the second corner in the instance image.
+       \param y1 = Y-coordinate of the second corner in the instance image.
+       \param x2 = X-coordinate of the third corner in the instance image.
+       \param y2 = Y-coordinate of the third corner in the instance image.
+       \param texture = texture image used to fill the triangle.
+       \param tx0 = X-coordinate of the first corner in the texture image.
+       \param ty0 = Y-coordinate of the first corner in the texture image.
+       \param tx1 = X-coordinate of the second corner in the texture image.
+       \param ty1 = Y-coordinate of the second corner in the texture image.
+       \param tx2 = X-coordinate of the third corner in the texture image.
+       \param ty2 = Y-coordinate of the third corner in the texture image.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported, but texture coordinates do not support clipping.
+    **/
+    template<typename t> CImg& draw_triangle(const int x0,const int y0,
+                                             const int x1,const int y1,
+                                             const int x2,const int y2,
+                                             const CImg<t>& texture,
+                                             const int tx0,const int ty0,
+                                             const int tx1,const int ty1,
+                                             const int tx2,const int ty2,
+                                             const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_triangle"); cimg_test(texture,"CImg<T>::draw_triangle");
+      int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,ntx0=tx0,nty0=ty0,ntx1=tx1,nty1=ty1,ntx2=tx2,nty2=ty2,whz=width*height*depth;
+      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
+      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2);
+      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2);
+      if (ny0>=dimy() || ny2<0) return *this;
+      const float 
+        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
+        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
+        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
+        tpx1 = (ny1-ny0)?(ntx1-ntx0)/(float)(ny1-ny0):0,
+        tpy1 = (ny1-ny0)?(nty1-nty0)/(float)(ny1-ny0):0,
+        tpx2 = (ny2-ny0)?(ntx2-ntx0)/(float)(ny2-ny0):0,
+        tpy2 = (ny2-ny0)?(nty2-nty0)/(float)(ny2-ny0):0,
+        tpx3 = (ny2-ny1)?(ntx2-ntx1)/(float)(ny2-ny1):0,
+        tpy3 = (ny2-ny1)?(nty2-nty1)/(float)(ny2-ny1):0;
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      float pleft,pright,tpxleft,tpyleft,tpxright,tpyright,
+        xleft=(float)nx0,xright=xleft,txleft=(float)ntx0,tyleft=(float)nty0,txright=txleft,tyright=tyleft;
+      if (p1<p2) { pleft=p1; pright=p2; tpxleft=tpx1; tpyleft=tpy1; tpxright=tpx2; tpyright=tpy2; } 
+      else       { pleft=p2; pright=p1; tpxleft=tpx2; tpyleft=tpy2; tpxright=tpx1; tpyright=tpy1; }
+      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; txleft-=ny0*tpxleft; tyleft-=ny0*tpyleft;
+        txright-=ny0*tpxright; tyright-=ny0*tpyright; }
+      const int ya = ny1<dimy()?ny1:height;
+      for (int y=(ny0<0?0:ny0); y<ya; y++) {
+        const int dx = (int)xright-(int)xleft;
+        const float
+          tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
+          tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,        
+          txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
+          tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
+        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
+        if (xmin<=xmax) {
+          const int offx=whz-xmax+xmin-1;
+          T* ptrd = ptr(xmin,y,0,0);
+          if (opacity>=1) cimg_mapV(*this,k) {
+            float tx=txi, ty=tyi;
+            for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)texture((unsigned int)tx,(unsigned int)ty,0,k); tx+=tpx; ty+=tpy; }
+            ptrd+=offx;
+          } else cimg_mapV(*this,k) {
+            float tx=txi, ty=tyi;
+            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
+            ptrd+=offx;
+          }
+        }
+        xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
+      }
+
+      if (p1<p2) {
+        xleft=(float)nx1; pleft=p3; txleft=(float)ntx1; tyleft=(float)nty1; tpxleft=tpx3; tpyleft=tpy3;
+        if (ny1<0) { xleft-=ny1*pleft; txleft-=ny1*tpxleft; tyleft-=ny1*tpyleft; }
+      } else { 
+        xright=(float)nx1; pright=p3; txright=(float)ntx1; tyright=(float)nty1; tpxright=tpx3; tpyright=tpy3;
+        if (ny1<0) { xright-=ny1*pright; txright-=ny1*tpxright; tyright-=ny1*tpyright; }
+      }    
+      const int yb = ny2>=dimy()?(height-1):ny2;
+      for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
+        const int dx = (int)xright-(int)xleft;
+        const float
+          tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
+          tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,        
+          txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
+          tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
+        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
+        if (xmin<=xmax) {
+          const int offx=whz-xmax+xmin-1;
+          T* ptrd = ptr(xmin,yy,0,0);
+          if (opacity>=1) cimg_mapV(*this,k) { 
+            float tx=txi, ty=tyi;
+            for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)texture((unsigned int)tx,(unsigned int)ty,0,k); tx+=tpx; ty+=tpy; }
+            ptrd+=offx;
+          } else cimg_mapV(*this,k) { 
+            float tx=txi, ty=tyi;
+            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
+            ptrd+=offx;
+          }
+        }
+        xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
+      }
+      return *this;
+    }
+
+    //! Draw a filled ellipse on the instance image
+    /**
+       \param x0 = X-coordinate of the ellipse center.
+       \param y0 = Y-coordinate of the ellipse center.
+       \param r1 = First radius of the ellipse.
+       \param r2 = Second radius of the ellipse.
+       \param ru = X-coordinate of the orientation vector related to the first radius.
+       \param rv = Y-coordinate of the orientation vector related to the first radius.
+       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+    **/
+    CImg& draw_ellipse(const int x0,const int y0,const float r1,const float r2,const float ru,const float rv,
+                       const T *const color,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_ellipse");
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_ellipse : specified color is (null).",pixel_type());
+      const T* col = color;
+      const float
+        norm = (float)std::sqrt(ru*ru+rv*rv),
+        u = norm>0?ru/norm:1,
+        v = norm>0?rv/norm:0,
+        rmax = cimg::max(r1,r2),
+        l1 = (float)std::pow(rmax/(r1>0?r1:1e-6),2),
+        l2 = (float)std::pow(rmax/(r2>0?r2:1e-6),2),
+        a = l1*u*u + l2*v*v,
+        b = u*v*(l1-l2),
+        c = l1*v*v + l2*u*u,
+        nopacity = cimg::abs(opacity),
+        copacity = 1-cimg::max(opacity,0.0f);
+      const int
+        yb = (int)std::sqrt(a*rmax*rmax/(a*c-b*b)),
+        ymin = (y0-yb<0)?0:(y0-yb),
+        ymax = (1+y0+yb>=dimy())?height-1:(1+y0+yb),
+        whz = width*height*depth;
+      for (int y=ymin; y<=ymax; y++) {
+        const float
+          Y = (float)(y-y0),
+          delta = b*b*Y*Y-a*(c*Y*Y-rmax*rmax);
+        if (delta>=0) {
+          int xmin = (int)(x0-(b*Y+std::sqrt(delta))/a), xmax = (int)(x0-(b*Y-std::sqrt(delta))/a);
+          if (xmin<0) xmin=0;
+          if (xmax>=dimx()) xmax=dimx()-1;
+          if (xmin<=xmax) {
+            const int offx = whz-xmax+xmin-1;
+            T *ptrd = ptr(xmin,y,0,0);
+            if (opacity>=1) {
+              if (sizeof(T)!=1) cimg_mapV(*this,k) {
+                const T& cval=*(col++); 
+                for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval;
+                ptrd+=offx;
+              } else cimg_mapV(*this,k) {
+                std::memset(ptrd,(int)*(col++),xmax-xmin+1);
+                ptrd+=whz; 
+              }
+            } else cimg_mapV(*this,k) {
+              const T& cval=*(col++);
+              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity+copacity*(*ptrd)); ptrd++; }
+              ptrd+=offx;
+            }
+            col-=dim;
+          }
+        }
+      }
+      return *this;
+    }
+
+    //! Draw a filled circle on the instance image
+    /**
+       \param x0 = X-coordinate of the circle center.
+       \param y0 = Y-coordinate of the circle center.
+       \param r = radius of the circle.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param opacity = opacity of the drawing.
+    **/
+    CImg& draw_circle(const int x0,const int y0,float r,const T *const color,const float opacity=1) {
+      return draw_ellipse(x0,y0,r,r,1,0,color,opacity);
+    }
+  
+    // Create an auto-cropped font (along the X axis) from a input font \p font.
+    static CImgl<T> get_cropfont(const CImgl<T>& font,const unsigned int padding=2) {
+      CImgl<T> res;
+      cimgl_map(font,l) {
+        int xmin=font[l].width, xmax = 0;
+        cimg_mapXY(font[l],x,y) if (font[l](x,y)) { if (x<xmin) xmin=x; if (x>xmax) xmax=x; }
+        if (xmin>xmax) res.insert(font[l]);
+        else {
+          res.insert(CImg<T>(xmax-xmin+1+padding,font[l].height,1,font[l].dim,0));
+          cimg_mapYV(res[l],y,k) for (int x=xmin; x<=xmax; x++) res[l](x-xmin,y,0,k) = font[l](x,y,0,k);
+        }
+      }
+      return res;
+    }
+  
+    //! Return a copy of the default 7x11 CImg font as a list of images and masks.
+    /**
+       \param fixed_size = compute fixed or variable character size
+    **/
+    static CImgl<T> get_font7x11(const bool fixed_size = false) {
+      CImgl<T> font(32,1,1,1,3);
+      font.insert(CImgl<T>(224,7,11,1,3)).insert(CImgl<T>(32,1,1,1,1)).insert(CImgl<T>(224,7,11,1,1));
+      for (unsigned int i=0, off=0, boff=(unsigned int)(1<<31); i<256; i++) for (unsigned int j=0; j<font[i].width*font[i].height; j++) {
+        font[256+i](j) = font[i](j,0,0) = font[i](j,0,1) = font[i](j,0,2) = (cimg::font7x11[off]&boff)?(T)1:(T)0;
+        if (!(boff>>=1)) { boff=(unsigned int)(1<<31); off++; }
+      }
+      if (!fixed_size) return get_cropfont(font,2);
+      return font;
+    }
+
+    //! Draw a text into the instance image.
+    /**
+       \param text = a C-string containing the text to display.
+       \param x0 = X-coordinate of the text in the instance image.
+       \param y0 = Y-coordinate of the text in the instance image.
+       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
+       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
+       \param font = List of font characters used for the drawing.
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+       \see get_font7x11().
+    **/
+    template<typename t> CImg& draw_text(const char *const text,
+                                         const int x0,const int y0,
+                                         const T *const fgcolor,const T *const bgcolor,
+                                         const CImgl<t>& font,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_text");
+      int x=x0, y=y0;
+      CImg letter;
+      for (int i=0; i<cimg::strlen(text); i++) {
+        const unsigned char c = text[i];
+        switch (c) {
+        case '\n': y+=font[' '].height; x=x0; break;
+        case '\t': x+=4*font[' '].width; break;
+        default: if (c<font.size) {
+            letter = font[c];
+            const CImg& mask = (c+256)<(int)font.size?font[c+256]:font[c];
+            if (fgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++) if (mask(p)) cimg_mapV(*this,k) letter(p,0,0,k)=(T)(letter(p,0,0,k)*fgcolor[k]);
+            if (bgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++) if (!mask(p)) cimg_mapV(*this,k) letter(p,0,0,k)=bgcolor[k];
+            if (!bgcolor && font.size>=512) draw_image(letter,mask,x,y,0,0,(T)1,opacity); else draw_image(letter,x,y,0,0,opacity);
+            x+=letter.width;
+          }
+          break;
+        }
+      }
+      return *this;
+    }
+
+
+    //! Draw a text into the instance image.
+    /**
+       \param text = a C-string containing the text to display.
+       \param x0 = X-coordinate of the text in the instance image.
+       \param y0 = Y-coordinate of the text in the instance image.
+       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
+       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+       \see get_font7x11().
+    **/
+    CImg& draw_text(const char *const text,
+                    const int x0,const int y0,
+                    const T *const fgcolor=NULL,const T *const bgcolor=NULL,
+                    const float opacity=1) {
+      static bool first = true;
+      static CImgl<T> default_font;
+      if (first) { default_font = get_font7x11(); first = false; }
+      return draw_text(text,x0,y0,fgcolor,bgcolor,default_font,opacity);
+    }
+  
+    //! Draw a text into the instance image.
+    /**
+       \param x0 = X-coordinate of the text in the instance image.
+       \param y0 = Y-coordinate of the text in the instance image.
+       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
+       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
+       \param opacity = opacity of the drawing.
+       \param format = a 'printf'-style format, followed by arguments.
+       \note Clipping is supported.
+       \see get_font7x11().
+    **/
+    CImg& draw_text(const int x0,const int y0,
+                    const T *const fgcolor,const T *const bgcolor,
+                    const float opacity,const char *format,...) {
+      char tmp[2048]; 
+      va_list ap;
+      va_start(ap,format);
+      std::vsprintf(tmp,format,ap);
+      va_end(ap);
+      return draw_text(tmp,x0,y0,fgcolor,bgcolor,opacity);
+    }
+    template<typename t> CImg& draw_text(const int x0,const int y0,
+                                         const T *const fgcolor,const T *const bgcolor,
+                                         const CImgl<t>& font, const float opacity, const char *format,...) {
+      char tmp[2048]; va_list ap; va_start(ap,format); std::vsprintf(tmp,format,ap); va_end(ap);
+      return draw_text(tmp,x0,y0,fgcolor,bgcolor,font);
+    }
+  
+    //! Draw a vector field in the instance image.
+    /**
+       \param flow = a 2d image of 2d vectors used as input data.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param sampling = length (in pixels) between each arrow.
+       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
+       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    template<typename t> 
+    CImg& draw_quiver(const CImg<t>& flow,const T *const color,const unsigned int sampling=25,const float factor=-20,
+                      const int quiver_type=0,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_quiver"); cimg_test(flow,"CImg<T>::draw_quiver");
+      if (!color) 
+        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified color is (null)",pixel_type());
+      if (sampling<=0)
+        throw CImgArgumentException("CImg<%s>::draw_quiver() : incorrect sampling value = %g",pixel_type(),sampling);
+      if (flow.dim!=2)
+        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified flow has invalid dimensions (%u,%u,%u,%u)",
+                                    pixel_type(),flow.width,flow.height,flow.depth,flow.dim);
+      float vmax,fact;
+      if (factor<=0) {
+        CImgStats st(flow.get_norm_pointwise(2),false);
+        vmax = (float)cimg::max(std::fabs(st.min),std::fabs(st.max));
+        fact = -factor;
+      } else { fact = factor; vmax = 1; }
+
+      for (unsigned int y=sampling/2; y<height; y+=sampling)
+        for (unsigned int x=sampling/2; x<width; x+=sampling) {
+          const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
+          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
+          if (!quiver_type) {
+            const int xx = x+(int)u, yy = y+(int)v;
+            draw_arrow(x,y,xx,yy,color,45.0f,sampling/5.0f,~0L,opacity);
+          } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color,~0L,opacity);
+        }
+      return *this; 
+    }
+
+    //! Draw a vector field in the instance image, using a colormap.
+    /**
+       \param flow = a 2d image of 2d vectors used as input data.
+       \param color = a 2d image of dimv()-D vectors corresponding to the color of each arrow.
+       \param sampling = length (in pixels) between each arrow.
+       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
+       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
+       \param opacity = opacity of the drawing.
+       \note Clipping is supported.
+    **/
+    template<typename t1,typename t2>
+      CImg& draw_quiver(const CImg<t1>& flow,const CImg<t2>& color,const unsigned int sampling=25,const float factor=-20,
+                        const int quiver_type=0,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_quiver"); cimg_test(flow,"CImg<T>::draw_quiver"); cimg_test(color,"CImg<T>::draw_quiver");
+      if (sampling<=0)
+        throw CImgArgumentException("CImg<%s>::draw_quiver() : incorrect sampling value = %g",pixel_type(),sampling);
+      if (flow.dim!=2)
+        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified flow has invalid dimensions (%u,%u,%u,%u)",
+                                    pixel_type(),flow.width,flow.height,flow.depth,flow.dim);
+      if (color.width!=flow.width || color.height!=flow.height)
+        throw CImgArgumentException("CImg<%s>::draw_quiver() : input color data map=(%u,%u,%u,%u)\
+ and data flow=(%u,%u,%u,%u) must have same dimension.",
+                                    color.width,color.height,color.depth,color.data,
+                                    flow.width,flow.height,flow.depth,flow.data);
+      float vmax,fact;
+      if (factor<=0) {
+        CImgStats st(flow.get_norm_pointwise(2),false);
+        vmax = (float)cimg::max(std::fabs(st.min),std::fabs(st.max));
+        fact = -factor;
+      } else { fact = factor; vmax = 1; }
+
+      for (unsigned int y=sampling/2; y<height; y+=sampling)
+        for (unsigned int x=sampling/2; x<width; x+=sampling) {
+          const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
+          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
+          if (!quiver_type) {
+            const int xx = x+(int)u, yy = y+(int)v;
+            draw_arrow(x,y,xx,yy,color.get_vector(X,Y).data,45,sampling/5,~0L,opacity);
+          } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color(X,Y),~0L,opacity);
+        }
+      return *this; 
+    }
+
+    //! Draw a 1D graph on the instance image.
+    /**
+       \param data = an image containing the graph values I = f(x).
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param gtype = define the type of the plot :
+                      - 0 = Plot using linear interpolation (segments).
+		      - 1 = Plot with bars.
+		      - 2 = Plot using cubic interpolation (3-polynomials).
+       \param ymin = lower bound of the y-range.
+       \param ymax = upper bound of the y-range.
+       \param opacity = opacity of the drawing.
+       \note
+         - if \c ymin==ymax==0, the y-range is computed automatically from the input sample.
+       \see draw_axeX(), draw_axeY(), draw_axeXY().
+    **/
+    template<typename t>
+    CImg& draw_graph(const CImg<t>& data,const T *const color,const unsigned int gtype=0,
+                     const double ymin=0,const double ymax=0,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_graph");
+      if (!color) throw CImgArgumentException("CImg<%s>::draw_graph() : specified color is (null)",pixel_type());
+      T *color1 = new T[dim], *color2 = new T[dim];
+      cimg_mapV(*this,k) { color1[k]=(T)(color[k]*0.6f); color2[k]=(T)(color[k]*0.3f); }
+      CImgStats st;
+      if (ymin==ymax) { st = CImgStats(data,false); cimg::swap(st.min,st.max); } else { st.min = ymin; st.max = ymax; }
+      if (st.min==st.max) { st.min--; st.max++; }
+      const float ca = height>1?(st.max-st.min)/(height-1):0, cb = st.min;
+      const int Y0 = (int)(-cb/ca);
+      int pY=0;
+      cimg_mapoff(data,off) {     
+        const int Y = (int)((data[off]-cb)/ca);
+        switch (gtype) {
+        case 0: // plot with segments
+          if (off>0) draw_line((int)((off-1)*width/data.size()),pY,(int)(off*width/data.size()),Y,color,~0L,opacity);
+          break;
+        case 1: { // plot with bars
+          const unsigned int X = off*width/data.size(), nX = (off+1)*width/data.size()-1;
+          draw_rectangle(X,(int)Y0,nX,Y,color1,opacity);
+	  draw_line(X,Y,X,(int)Y0,color2,~0L,opacity);
+	  draw_line(X,(int)Y0,nX,(int)Y0,Y<=Y0?color2:color,~0L,opacity);
+	  draw_line(nX,Y,nX,(int)Y0,color,~0L,opacity);
+	  draw_line(X,Y,nX,Y,Y<=Y0?color:color2,~0L,opacity);
+        } break;
+        }        
+        pY=Y;
+      }
+      if (gtype==2) { // plot with cubic interpolation
+	const CImgROI<t> ndata(data.size(),1,1,1,data.ptr());
+        cimg_mapX(*this,x) {
+          const int Y = (int)((ndata.cubic_pix1d((float)x*ndata.width/width)-cb)/ca);
+          if (x>0) draw_line(x,pY,x+1,Y,color,~0L,opacity);
+          pY=Y;
+        }
+      }
+      delete[] color1; delete[] color2;
+      return *this;     
+    }
+
+    //! Draw a labelled horizontal axis on the instance image.
+    /** 
+       \param x0 = lower bound of the x-range.
+       \param x1 = upper bound of the x-range.
+       \param y = Y-coordinate of the horizontal axis in the instance image.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param precision = precision of the labels.
+       \param opacity = opacity of the drawing.
+       \note if \c precision==0, precision of the labels is automatically computed.
+       \see draw_graph(), draw_axeY(), draw_axeXY().
+    **/
+    CImg& draw_axeX(const double x0,const double x1,const int y,const T *const color,
+		    const double precision=0,const float opacity=1) {
+      if (x0==x1) return *this;
+      if (x0<x1) draw_arrow(0,y,width-1,y,color,30,5,~0L,opacity);
+      else draw_arrow(width-1,y,0,y,color,30,5,~0L,opacity);
+      const int yt = (y+14)<dimy()?(y+3):(y-14);
+      double nprecision=precision;
+      if (precision<=0) { 
+	const double nb_pow = std::floor(std::log10(std::fabs(x1-x0)))-1;
+	nprecision = std::pow(10.0,nb_pow);
+	while ((std::fabs(x1-x0)/nprecision)>(dimx()/40)) nprecision*=2;
+      }
+      const double xmin=x0<x1?x0:x1, xmax=x0<x1?x1:x0,
+	tx0 = cimg::mod(xmin,nprecision)==0?xmin:((xmin+nprecision)-cimg::mod(xmin+nprecision,nprecision)),
+	tx1 = cimg::mod(xmax,nprecision)==0?xmax:((xmax+nprecision)-cimg::mod(xmax+nprecision,nprecision));
+      char txt[32];
+      for (double x=tx0; x<=tx1; x+=nprecision) {
+	std::sprintf(txt,"%g",x);       	
+	const int xi=(int)((x-x0)*(width-1)/(x1-x0)), xt = xi-(int)std::strlen(txt)*3;
+	draw_point(xi,y-1,color,opacity).draw_point(xi,y+1,color,opacity).
+	  draw_text(txt,xt<0?0:xt,yt,color,NULL,opacity);
+      }
+      return *this;
+    }
+
+    //! Draw a labelled vertical axis on the instance image.
+    /** 
+       \param x = X-coordinate of the vertical axis in the instance image.
+       \param y0 = lower bound of the y-range.
+       \param y1 = upper bound of the y-range.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param precision = precision of the labels.
+       \param opacity = opacity of the drawing.
+       \note if \c precision==0, precision of the labels is automatically computed.
+       \see draw_graph(), draw_axeX(), draw_axeXY().
+    **/
+    CImg& draw_axeY(const int x,const double y0,const double y1,const T *const color,
+		    const double precision=0,const float opacity=1) {
+      if (y0==y1) return *this;
+      if (y0<y1) draw_arrow(x,0,x,height-1,color,30,5,~0L,opacity);
+      else draw_arrow(x,height-1,x,0,color,30,5,~0L,opacity);
+      double nprecision=precision;
+      if (precision<=0) {
+	const double nb_pow = std::floor(std::log10(std::fabs(y1-y0)))-1;
+	nprecision = std::pow(10.0,nb_pow);
+	while ((std::fabs(y1-y0)/nprecision)>(dimy()/40)) nprecision*=2;
+      }
+      const double ymin=y0<y1?y0:y1, ymax=y0<y1?y1:y0,
+	ty0 = cimg::mod(ymin,nprecision)==0?ymin:((ymin+nprecision)-cimg::mod(ymin+nprecision,nprecision)),
+	ty1 = cimg::mod(ymax,nprecision)==0?ymax:((ymax+nprecision)-cimg::mod(ymax+nprecision,nprecision));
+      char txt[32];
+      for (double y=ty0; y<=ty1; y+=nprecision) {
+	std::sprintf(txt,"%g",y);
+	const int yi = (int)((y-y0)*(height-1)/(y1-y0)), xt = x-(int)std::strlen(txt)*7;
+	draw_point(x-1,yi,color,opacity).draw_point(x+1,yi,color,opacity);
+	if (xt>0) draw_text(txt,xt,yi-5,color,NULL,opacity);
+	else draw_text(txt,x+3,yi-5,color,NULL,opacity);
+      }
+      return *this;
+    }
+
+    //! Draw a labelled coordinate system (X,Y) on the instance image.
+    /** 
+       \param x0 = lower bound of the x-range.
+       \param x1 = upper bound of the x-range.
+       \param y0 = lower bound of the y-range.
+       \param y1 = upper bound of the y-range.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param precisionx = precision of the labels along the X-axis.
+       \param precisiony = precision of the labels along the Y-axis.
+       \param opacity = opacity of the drawing.
+       \note if precision==0, precision of the labels along the specified axix is automatically computed.
+       \see draw_graph(), draw_axeX(), draw_axeY().
+    **/
+    CImg& draw_axeXY(const double x0,const double x1,const double y0,const double y1,const T *const color,
+		     const double precisionx=0,const double precisiony=0,const float opacity=1) {
+      if (x0*x1<=0) {
+        const int xz = (int)(-x0*(width-1)/(x1-x0));
+        if (xz>=0 && xz<dimx()) draw_axeY(xz,y0,y1,color,precisiony,opacity);
+      }
+      if (y0*y1<=0) {
+        const int yz = (int)(-y0*(height-1)/(y1-y0));
+        if (yz>=0 && yz<dimy()) draw_axeX(x0,x1,yz,color,precisionx,opacity);
+      }
+      return *this;
+    }
+  
+    // Local class used by function CImg<>::draw_fill()
+    template<typename T1,typename T2> struct _draw_fill {
+      const T1 *const color;
+      const float sigma,opacity;
+      const CImg<T1> value;
+      CImg<T2> region;
+
+      _draw_fill(const CImg<T1>& img,const int x,const int y,const int z,
+                 const T *const pcolor,const float psigma,const float popacity):
+        color(pcolor),sigma(psigma),opacity(popacity),
+        value(img.get_vector(x,y,z)), region(CImg<T2>(img.width,img.height,img.depth).fill((T2)false)) {
+        cimg_test(img,"CImg<T>::draw_fill");
+        if (!color) throw CImgArgumentException("CImg<%s>::draw_fill() : specified color is (null)",img.pixel_type());
+      }
+
+	   _draw_fill& operator=(const _draw_fill& d) {
+			color = d.color;
+			sigma = d.sigma;
+			opacity = d.opacity;
+			value = d.value;
+			region = d.region;
+		}
+
+      bool comp(const CImg<T1>& A,const CImg<T1>& B) const {
+        bool res=true;
+        const T *pA=A.data+A.size();
+        for (const T *pB=B.data+B.size(); res && pA>A.data; res=(cimg::abs(*(--pA)-(*(--pB)))<=sigma) );
+        return res;
+      }
+
+      void fill(CImg<T1>& img,const int x,const int y,const int z) {
+        if (x<0 || x>=img.dimx() || y<0 || y>=img.dimy() || z<0 || z>=img.dimz()) return;
+        if (!region(x,y,z) && comp(value,img.get_vector(x,y,z))) {
+          const T *col=color;
+          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+          int xmin,xmax;
+          if (opacity>=1) cimg_mapV(img,k) img(x,y,z,k)=*(col++);
+          else cimg_mapV(img,k) img(x,y,z,k)=(T1)(*(col++)*opacity+copacity*img(x,y,z,k));
+          col-=img.dim;
+          region(x,y,z) = (T2)true;
+          for (xmin=x-1; xmin>=0 && comp(value,img.get_vector(xmin,y,z)); xmin--) {
+            if (opacity>=1) cimg_mapV(img,k) img(xmin,y,z,k) = *(col++);
+            else cimg_mapV(img,k) img(xmin,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmin,y,z,k)); 
+            col-=img.dim;
+            region(xmin,y,z)=(T2)true;
+          }
+          for (xmax=x+1; xmax<img.dimx() && comp(value,img.get_vector(xmax,y,z)); xmax++) {
+            if (opacity>=1) cimg_mapV(img,k) img(xmax,y,z,k) = *(col++);
+            else cimg_mapV(img,k) img(xmax,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmax,y,z,k));
+            col-=img.dim;
+            region(xmax,y,z)=(T2)true; 
+          }
+          xmin++; xmax--;
+          for (; xmin<=xmax; xmin++) { 
+            fill(img,xmin,y-1,z); 
+            fill(img,xmin,y+1,z);
+            fill(img,xmin,y,z-1); 
+            fill(img,xmin,y,z+1);
+          }
+        }
+      }        
+    };
+
+    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
+    /**
+       \param x = X-coordinate of the starting point of the region to fill.
+       \param y = Y-coordinate of the starting point of the region to fill.
+       \param z = Z-coordinate of the starting point of the region to fill.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param region = image that will contain the mask of the filled region mask, as an output.
+       \param sigma = tolerance concerning neighborhood values.
+       \param opacity = opacity of the drawing.
+    **/
+    template<typename t> CImg& draw_fill(const int x,const int y,const int z,
+                                         const T *const color,CImg<t>& region,const float sigma=0,
+                                         const float opacity=1) {
+      _draw_fill<T,t> F(*this,x,y,z,color,sigma,opacity);
+      F.fill(*this,x,y,z);
+      region = F.region;
+      return *this;
+    }
+
+    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
+    /**
+       \param x = X-coordinate of the starting point of the region to fill.
+       \param y = Y-coordinate of the starting point of the region to fill.
+       \param z = Z-coordinate of the starting point of the region to fill.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param sigma = tolerance concerning neighborhood values.
+       \param opacity = opacity of the drawing.
+    **/
+    CImg& draw_fill(const int x,const int y,const int z,const T *const color,const float sigma=0,const float opacity=1) {
+      CImg<bool> tmp;
+      return draw_fill(x,y,z,color,tmp,sigma,opacity);
+    }
+
+    //! Draw a 2D filled region starting from a point (\c x,\c y) in the instance image.
+    /**
+       \param x = X-coordinate of the starting point of the region to fill.
+       \param y = Y-coordinate of the starting point of the region to fill.
+       \param color = an array of dimv() values of type \c T, defining the drawing color.
+       \param sigma = tolerance concerning neighborhood values.
+       \param opacity = opacity of the drawing.
+    **/
+    CImg& draw_fill(const int x,const int y,const T *const color,const float sigma=0,const float opacity=1) {
+      CImg<bool> tmp;
+      return draw_fill(x,y,0,color,tmp,sigma,opacity);
+    }
+
+    //! Draw a plasma square in the instance image.
+    /**
+       \param x0 = X-coordinate of the upper-left corner of the plasma.
+       \param y0 = Y-coordinate of the upper-left corner of the plasma.
+       \param x1 = X-coordinate of the lower-right corner of the plasma.
+       \param y1 = Y-coordinate of the lower-right corner of the plasma.
+       \param alpha = Alpha-parameter of the plasma.
+       \param beta = Beta-parameter of the plasma.
+       \param opacity = opacity of the drawing.
+    **/
+    CImg& draw_plasma(const int x0,const int y0,const int x1,const int y1,
+                      const double alpha=1.0,const double beta=1.0,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_plasma");
+      int nx0=x0,nx1=x1,ny0=y0,ny1=y1;
+      if (nx1<nx0) cimg::swap(nx0,nx1);
+      if (ny1<ny0) cimg::swap(ny0,ny1);
+      if (nx0<0) nx0=0;
+      if (nx1>=dimx()) nx1=width-1;
+      if (ny0<0) ny0=0;
+      if (ny1>=dimy()) ny1=height-1;
+      const int xc = (nx0+nx1)/2, yc = (ny0+ny1)/2, dx=(xc-nx0), dy=(yc-ny0);
+      const double dc = std::sqrt((double)(dx*dx+dy*dy))*alpha + beta;
+      cimg_mapV(*this,k) {
+        if (opacity>=1) {
+          (*this)(xc,ny0,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k)));
+          (*this)(xc,ny1,0,k) = (T)(0.5*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k)));
+          (*this)(nx0,yc,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k)));
+          (*this)(nx1,yc,0,k) = (T)(0.5*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k)));
+          (*this)(xc,yc,0,k)  = (T)(0.25*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
+                                          (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand());
+        } else {
+          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+          (*this)(xc,ny0,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k))*nopacity + copacity*(*this)(xc,ny0,0,k));
+          (*this)(xc,ny1,0,k) = (T)(0.5*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(xc,ny1,0,k));
+          (*this)(nx0,yc,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k))*nopacity + copacity*(*this)(nx0,yc,0,k));
+          (*this)(nx1,yc,0,k) = (T)(0.5*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(nx1,yc,0,k));
+          (*this)(xc,yc,0,k)  = (T)(0.25*(((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
+                                           (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand())*nopacity
+                                    + copacity*(*this)(xc,yc,0,k));
+        }
+      }
+      if (xc!=nx0 || yc!=ny0) { 
+        draw_plasma(nx0,ny0,xc,yc,alpha,beta,opacity);
+        draw_plasma(xc,ny0,nx1,yc,alpha,beta,opacity);
+        draw_plasma(nx0,yc,xc,ny1,alpha,beta,opacity);
+        draw_plasma(xc,yc,nx1,ny1,alpha,beta,opacity); 
+      }
+      return *this;
+    }
+
+    //! Draw a plasma in the instance image.
+    /**
+       \param alpha = Alpha-parameter of the plasma.
+       \param beta = Beta-parameter of the plasma.
+       \param opacity = opacity of the drawing.
+    **/
+    CImg& draw_plasma(const double alpha=1.0,const double beta=1.0,const float opacity=1) {
+      return draw_plasma(0,0,width-1,height-1,alpha,beta,opacity);
+    }
+  
+    //! Draw a 1D gaussian kernel in the instance image.
+    template<typename t> CImg& draw_gaussian(const float xc,const double sigma,const T *const color,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_gaussian");
+      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
+      const double sigma2 = -2*sigma*sigma;
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      const T *col = color;
+      const unsigned int whz = width*height*depth;
+      cimg_mapX(*this,x) {
+        const float dx = (x-xc);
+        const double val = std::exp( dx*dx/sigma2 );
+        T *ptrd = ptr(x,0,0,0);
+        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
+        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; } 
+        col-=dim;
+      }
+      return *this;
+    }
+
+    //! Draw a gaussian in a 2d image.
+    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const double sigma,
+                                             const CImg<t> tensor,const T *const color,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_gaussian"); cimg_test_square(tensor,"CImg<T>::draw_gaussian");
+      if (tensor.width!=2) throw CImgArgumentException("CImg<%s>::draw_gaussian() : gaussian tensor must be a 2x2 matrix, given is (%u,%u,%u,%u)",
+                                                       pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim);
+      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
+      const CImg<t> invT = tensor.get_inverse();
+      const t a=invT(0,0), b=2*invT(1,0), c=invT(1,1);
+      const double sigma2 = -2*sigma*sigma;
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      const T *col = color;
+      const unsigned int whz = width*height*depth;
+      cimg_mapXY(*this,x,y) {
+        const float dx = (x-xc), dy = (y-yc);
+        const double val = std::exp( ( a*dx*dx + b*dx*dy + c*dy*dy )/sigma2 );
+        T *ptrd = ptr(x,y,0,0);
+        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
+        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
+        col-=dim;
+      }
+      return *this;
+    }
+
+    CImg& draw_gaussian(const float xc,const float yc,const double sigma,const T *const color,const float opacity=1) {
+      return draw_gaussian(xc,yc,sigma,CImg<float>::get_identity_matrix(2),color,opacity);
+    }
+
+    //! Draw a gaussian in a 3d image
+    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const float zc,const double sigma,
+                                             const CImg<t> tensor,const T *const color,const float opacity=1) {
+      cimg_test(*this,"CImg<T>::draw_gaussian"); cimg_test_square(tensor,"CImg<T>::draw_gaussian");
+      if (tensor.width!=3) throw CImgArgumentException("CImg<%s>::draw_gaussian() : gaussian tensor must be a 3x3 matrix, given is (%u,%u,%u,%u)",
+                                                       pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim);
+      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
+      const CImg<t> invT = tensor.get_inverse();
+      const t a=invT(0,0), b=2*invT(1,0), c=2*invT(2,0), d=invT(1,1), e=2*invT(2,1), f=invT(2,2);
+      const double sigma2 = -2*sigma*sigma;
+      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
+      const T *col = color;
+      const unsigned int whz = width*height*depth;    
+      cimg_mapXYZ(*this,x,y,z) {
+        const float dx = (x-xc), dy = (y-yc), dz = (z-zc);
+        const double val = std::exp( ( a*dx*dx + b*dx*dy + c*dx*dz + d*dy*dy + e*dy*dz + f*dz*dz )/sigma2 );
+        T *ptrd = ptr(x,y,z,0);
+        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
+        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
+        col-=dim;
+      }
+      return *this;
+    }
+
+    CImg& draw_gaussian(const float xc,const float yc,const float zc,const double sigma,const T *const color,const float opacity=1) {
+      return draw_gaussian(xc,yc,zc,sigma,CImg<float>::get_identity_matrix(3),color,opacity);
+    }
+
+    //@}
+    //---------------------------------------
+    //---------------------------------------
+    //
+    //! \name Filtering functions
+    //@{
+    //---------------------------------------
+    //---------------------------------------
+  
+    //! Return the correlation of the image by a mask.
+    template<typename t> CImg get_correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) const {
+      cimg_test_scalar(mask,"CImg<T>::get_correlate");
+      CImg dest(*this,false);
+      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) {
+        // A special optimization is done for 2x2,3x3,4x4,5x5,2x2x2 and 3x3x3 mask (with cond=1)
+        switch (mask.depth) {
+        case 3: {
+          CImg_3x3x3(I,T);
+          if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr3x3x3(I,mask);
+          else cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) {
+            const double norm = (double)cimg_squaresum3x3x3(I);
+            dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr3x3x3(I,mask)/std::sqrt(norm)):0;
+          }
+        } break;
+        case 2: {
+          CImg_2x2x2(I,T);
+          if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr2x2x2(I,mask);
+          else cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) {
+            const double norm = (double)cimg_squaresum2x2x2(I);
+            dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr2x2x2(I,mask)/std::sqrt(norm)):0;
+          }
+        } break;
+        default:
+        case 1:
+          switch (mask.width) {
+          case 5: {
+            CImg_5x5(I,T);
+            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr5x5(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum5x5(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr5x5(I,mask)/std::sqrt(norm)):0;
+            }            
+          } break;          
+          case 4: {
+            CImg_4x4(I,T);
+            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr4x4(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum4x4(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr4x4(I,mask)/std::sqrt(norm)):0;
+            }            
+          } break;              
+          case 3: {
+            CImg_3x3(I,T);
+            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr3x3(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum3x3(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr3x3(I,mask)/std::sqrt(norm)):0;
+            }            
+          } break;   
+          case 2: {
+            CImg_2x2(I,T);
+            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr2x2(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum2x2(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr2x2(I,mask)/std::sqrt(norm)):0;
+            }            
+          } break;  
+          case 1: dest = mask(0)*(*this); break;
+          }
+        }
+      } else { 
+        // Generic version for other masks      
+        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
+        cimg_mapV(*this,v) 
+          if (!weighted_correl) {	// Classical correlation
+            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
+              double val = 0;
+              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
+                val+= (*this)(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
+              dest(x,y,z,v)=(T)val;
+            }
+            if (cond) cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
+                  val+= neumann_pix3d(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
+                dest(x,y,z,v)=(T)val;
+              }
+            else cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
+                  val+= dirichlet_pix3d(x+xm,y+ym,z+zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
+                dest(x,y,z,v)=(T)val;
+              }
+          } else {	// Weighted correlation
+            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
+              double val = 0, norm = 0;
+              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
+                const T cval = (*this)(x+xm,y+ym,z+zm,v);
+                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
+                norm+= cval*cval;
+              }
+              dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
+            }
+            if (cond) cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0, norm = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
+                  const T cval = neumann_pix3d(x+xm,y+ym,z+zm,v);
+                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
+                  norm+=cval*cval;
+                }
+                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
+              }
+            else cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0, norm = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
+                  const T cval = dirichlet_pix3d(x+xm,y+ym,z+zm,v,0);
+                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
+                  norm+= cval*cval;
+                }
+                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
+              }
+          }
+      }
+      return dest;
+    }
+    //! Correlate the image by a mask
+    template<typename t> CImg& correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) { 
+      return get_correlate(mask,cond,weighted_correl).swap(*this); 
+    }
+  
+    //! Return the convolution of the image by a mask
+    template<typename t> CImg get_convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) const {
+      cimg_test_scalar(mask,"CImg<T>::get_convolve");
+      CImg dest(*this,false);
+      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) { // optimized version
+        switch (mask.depth) {
+        case 3: {
+          CImg_3x3x3(I,T);
+          if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3x3(I,mask);
+          else cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) {
+            const double norm = (double)cimg_squaresum3x3x3(I);
+            dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv3x3x3(I,mask)/std::sqrt(norm)):(T)0;
+          }
+        } break;
+        case 2: {
+          CImg_2x2x2(I,T);
+          if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2x2(I,mask);
+          else cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) {
+            const double norm = (double)cimg_squaresum2x2x2(I);
+            dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv2x2x2(I,mask)/std::sqrt(norm)):(T)0;
+          }
+        } break;
+        default:
+        case 1:
+          switch (mask.width) {
+          case 5: {
+            CImg_5x5(I,T);
+            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv5x5(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum5x5(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv5x5(I,mask)/std::sqrt(norm)):(T)0;
+            }            
+          } break;          
+          case 4: {
+            CImg_4x4(I,T);
+            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv4x4(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum4x4(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv4x4(I,mask)/std::sqrt(norm)):(T)0;
+            }
+          } break;              
+          case 3: {
+            CImg_3x3(I,T);
+            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum3x3(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv3x3(I,mask)/std::sqrt(norm)):(T)0;
+            }            
+          } break;   
+          case 2: {
+            CImg_2x2(I,T);
+            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2(I,mask);
+            else cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) {
+              const double norm = (double)cimg_squaresum2x2(I);
+              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv2x2(I,mask)/std::sqrt(norm)):(T)0;
+            } 
+          } break;  
+          case 1: dest = mask(0)*(*this); break;
+          }
+        }
+      } else { // generic version
+          
+        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
+        cimg_mapV(*this,v) 
+          if (!weighted_convol) {	// Classical convolution
+            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
+              double val = 0;
+              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
+                val+= (*this)(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
+              dest(x,y,z,v)=(T)val;
+            }
+            if (cond) cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
+                  val+= neumann_pix3d(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
+                dest(x,y,z,v)=(T)val;
+              }
+            else cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
+                  val+= dirichlet_pix3d(x-xm,y-ym,z-zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
+                dest(x,y,z,v)=(T)val;
+              }
+          } else {	// Weighted convolution
+            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
+              double val = 0, norm = 0;
+              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
+                const T cval = (*this)(x-xm,y-ym,z-zm,v);
+                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
+                norm+= cval*cval;
+              }
+              dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
+            }
+            if (cond) cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0, norm = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
+                  const T cval = neumann_pix3d(x-xm,y-ym,z-zm,v);
+                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
+                  norm+=cval*cval;
+                }
+                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
+              }
+            else cimg_mapYZV(*this,y,z,v)
+              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
+                double val = 0, norm = 0;
+                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++) {
+                  const T cval = dirichlet_pix3d(x-xm,y-ym,z-zm,v,0);
+                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
+                  norm+= cval*cval;
+                }
+                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
+              }
+          }
+      }
+      return dest;
+    }
+  
+    //! Convolve the image by a mask
+    template<typename t> CImg& convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) {
+      return get_convolve(mask,cond,weighted_convol).swap(*this); 
+    }
+
+    //! Add noise to the image
+    CImg& noise(const double psigma=-20,const unsigned int ntype=0) {
+      cimg_test(*this,"CImg<T>::noise");
+      double sigma = psigma;
+      static bool first_time = true;
+      if (first_time) { std::srand((unsigned int)::time(NULL)); first_time = false; }
+      CImgStats st;
+      if (sigma==0) return *this;
+      if (sigma<0 || ntype==2) st = CImgStats(*this,false);
+      if (sigma<0) sigma = -sigma*(st.max-st.min)/100.0;
+      switch (ntype) {
+      case 0: { cimg_map(*this,ptr,T) *ptr=(T)(*ptr+sigma*cimg::grand()); } break;    // Gaussian noise
+      case 1: { cimg_map(*this,ptr,T) *ptr=(T)(*ptr+sigma*cimg::crand()); } break;    // Uniform noise
+      case 2: {                                                                       // Salt & Pepper
+        if (st.max==st.min) { st.min=0; st.max=255; }
+        cimg_map(*this,ptr,T) if (cimg::rand()*100<sigma) *ptr=(T)(cimg::rand()<0.5?st.max:st.min);
+      } break;
+      }
+      return *this;
+    }
+    //! Return a noisy image
+    CImg get_noise(const double sigma=-20,const unsigned int ntype=0) const { return CImg<T>(*this).noise(sigma,ntype); }
+
+    //! Apply a deriche filter on the image
+#define cimg_deriche_map(x0,y0,z0,k0,nb,offset,T) {                           \
+    ima = ptr(x0,y0,z0,k0);                                                   \
+    I2 = *ima; ima+=offset; I1 = *ima; ima+=offset;                           \
+    Y2 = *(Y++) = sumg0*I2; Y1 = *(Y++) = g0*I1 + sumg1*I2;                   \
+    for (i=2; i<(nb); i++) { I1 = *ima; ima+=offset;                          \
+        Y0 = *(Y++) = a1*I1 + a2*I2 + b1*Y1 + b2*Y2;                          \
+        I2=I1; Y2=Y1; Y1=Y0; }                                                \
+    ima-=offset; I2 = *ima; Y2 = Y1 = parity*sumg1*I2; *ima = (T)(*(--Y)+Y2); \
+    ima-=offset; I1 = *ima; *ima = (T)(*(--Y)+Y1);                            \
+    for (i=(nb)-3; i>=0; i--) { Y0=a3*I1+a4*I2+b1*Y1+b2*Y2; ima-=offset;      \
+      I2=I1; I1=*ima; *ima=(T)(*(--Y)+Y0); Y2=Y1; Y1=Y0; }                    \
+  }
+
+    CImg& deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) {
+      cimg_test(*this,"CImg<T>::deriche");
+      if (sigma<0 || order<0 || order>2) throw CImgArgumentException("CImg<%s>::deriche() : Bad arguments (sigma=%g, order=%d)",pixel_type(),sigma,order);
+      if (sigma<0.01f) return *this;
+      const float alpha=sigma>0?1.695f/sigma:0,ea=(float)std::exp(alpha),ema=(float)std::exp(-alpha),em2a=ema*ema,b1=2*ema,b2=-em2a;
+      float ek,ekn,parity,a1,a2,a3,a4,g0,sumg1,sumg0;
+      double *Y,Y0,Y1,Y2;
+      int i,offset,nb;
+      T *ima,I1,I2;
+      switch(order) {
+      case 1:                 // first derivative
+        ek = -(1-ema)*(1-ema)*(1-ema)/(2*(ema+1)*ema); a1 = a4 = 0;  a2 = ek*ema; a3 = -ek*ema; parity =-1;\
+        if (cond) { sumg1 = (ek*ea) / ((ea-1)*(ea-1)); g0 = 0; sumg0 = g0+sumg1; } \
+        else g0 = sumg0 = sumg1 = 0;
+        break;
+      case 2:               // second derivative
+        ekn = ( -2*(-1+3*ea-3*ea*ea+ea*ea*ea)/(3*ea+1+3*ea*ea+ea*ea*ea) );
+        ek = -(em2a-1)/(2*alpha*ema); a1 = ekn;  a2 = -ekn*(1+ek*alpha)*ema; a3 = ekn*(1-ek*alpha)*ema; a4 = -ekn*em2a; parity =1;
+        if (cond) { sumg1 = ekn/2; g0 = ekn; sumg0 = g0+sumg1; }
+        else g0=sumg0=sumg1=0;
+        break;
+      default:              // smoothing
+        ek = (1-ema)*(1-ema) / (1+2*alpha*ema - em2a); a1 = ek;  a2 = ek*ema*(alpha-1); a3 = ek*ema*(alpha+1); a4 = -ek*em2a; parity = 1;
+        if (cond) { sumg1 = ek*(alpha*ea+ea-1) / ((ea-1)*(ea-1)); g0 = ek; sumg0 = g0+sumg1; }
+        else  g0=sumg0=sumg1=0;
+        break;
+      }
+      // filter init
+      Y = new double[cimg::max(width,height,depth)];
+      switch(cimg::uncase(axe)) {
+      case 'x': if (width>1)  { offset = 1;            nb = width;  cimg_mapYZV(*this,y,z,k) cimg_deriche_map(0,y,z,k,nb,offset,T); }	break;
+      case 'y': if (height>1) { offset = width;        nb = height; cimg_mapXZV(*this,x,z,k) cimg_deriche_map(x,0,z,k,nb,offset,T); }	break;
+      case 'z': if (depth>1)  { offset = width*height; nb = depth;  cimg_mapXYV(*this,x,y,k) cimg_deriche_map(x,y,0,k,nb,offset,T); }	break;
+      default : cimg::warn(true,"CImg<%s>::deriche() : Unknown axe '%c'",pixel_type(),axe); break;
+      }
+      delete[] Y;
+      return *this;
+    }
+    //! Return the result of the Deriche filter
+    CImg get_deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) const {
+      return CImg<T>(*this).deriche(sigma,order,axe,cond);
+    }
+    //! Blur the image with a Deriche filter (quasi-gaussian filter)
+    CImg& blur(const float sigma=1,const unsigned int cond=1) {
+      cimg_test(*this,"CImg<T>::blur");
+      if (width>1)  deriche(sigma,0,'x',cond);
+      if (height>1) deriche(sigma,0,'y',cond);
+      if (depth>1)  deriche(sigma,0,'z',cond);
+      return *this;
+    }
+    //! Return a blurred version of the image, using a Deriche filter (quasi gaussian filter)
+    CImg get_blur(const float sigma=1,const unsigned int cond=1) const { return CImg<T>(*this).blur(sigma,cond); }
+
+    //! Return a eroded image (\p times erosion).
+    CImg get_erode(const unsigned int n=1) {
+      CImg_3x3x3(I,T);
+      if (n==1) {
+        CImg dest(*this);
+        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) 
+	  if (Iccc && (!Incc || !Ipcc || !Icnc || !Icpc || !Iccn || !Iccp)) dest(x,y,z,k) = 0;
+        return dest;
+      }
+      CImg img1(*this),img2(*this,false);
+      CImg *src = &img1, *dest = &img2, *tmp = NULL;
+      for (unsigned int iter=0; iter<n; iter++) {
+        *dest = *src;
+        cimg_mapV(*src,k) cimg_map3x3x3(*src,x,y,z,k,I) 
+	  if (Iccc && (!Incc || !Ipcc || !Icnc || !Icpc || !Iccn || !Iccp)) (*dest)(x,y,z,k) = 0;
+        tmp = src;
+        src = dest;
+        dest = tmp;
+      }
+      return *src;      
+    }
+    //! Erode the image \p n times.
+    CImg& erode(const unsigned int n=1) { return get_erode(n).swap(*this); }
+
+    //! Return an dilated image (\p times dilatation).
+    CImg get_dilate(const unsigned int n=1) {
+      CImgStats stats(*this);
+      const T tmax = stats.max!=0?(T)stats.max:(T)1;
+      CImg_3x3x3(I,T);
+      if (n==1) {
+        CImg dest(*this);
+        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) 
+	  if (!Iccc && (Incc || Ipcc || Icnc || Icpc || Iccn || Iccp)) dest(x,y,z,k) = tmax;
+        return dest;
+      }
+      CImg img1(*this),img2(*this,false);
+      CImg *src = &img1, *dest = &img2, *tmp = NULL;
+      for (unsigned int iter=0; iter<n; iter++) {
+        *dest = *src;
+        cimg_mapV(*src,k) cimg_map3x3x3(*src,x,y,z,k,I) 
+	  if (!Iccc && (Incc || Ipcc || Icnc || Icpc || Iccn || Iccp)) (*dest)(x,y,z,k) = tmax;
+        tmp = src;
+        src = dest;
+        dest = tmp;
+      }
+      return *src;      
+    }
+    //! Dilate the image \p n times.
+    CImg& dilate(const unsigned int n=1) { return get_dilate(n).swap(*this); }
+
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Matrix and vector computation
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+
+    //! Return a vector with specified coefficients
+    static CImg vector(const T& a1) { return CImg<T>(1,1).fill(a1); }
+    static CImg vector(const T& a1,const T& a2) { return CImg<T>(1,2).fill(a1,a2); }
+    static CImg vector(const T& a1,const T& a2,const T& a3) { return CImg<T>(1,3).fill(a1,a2,a3); }
+    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4) { return CImg<T>(1,4).fill(a1,a2,a3,a4); }
+    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5) { return CImg<T>(1,5).fill(a1,a2,a3,a4,a5); }
+    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) { return CImg<T>(1,6).fill(a1,a2,a3,a4,a5,a6); }
+    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
+		       const T& a5,const T& a6,const T& a7) { return CImg<T>(1,7).fill(a1,a2,a3,a4,a5,a6,a7); }
+    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
+		       const T& a5,const T& a6,const T& a7,const T& a8) { return CImg<T>(1,8).fill(a1,a2,a3,a4,a5,a6,a7,a8); }
+    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
+		       const T& a5,const T& a6,const T& a7,const T& a8,const T& a9) { return CImg<T>(1,9).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9); }
+
+    //! Return a square matrix with specified coefficients
+    static CImg matrix(const T& a1) { return vector(a1); }
+    static CImg matrix(const T& a1,const T& a2,
+		       const T& a3,const T& a4) { return CImg<T>(2,2).fill(a1,a2,a3,a4); }
+    static CImg matrix(const T& a1,const T& a2,const T& a3,
+		       const T& a4,const T& a5,const T& a6,
+		       const T& a7,const T& a8,const T& a9) { return CImg<T>(3,3).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9); }
+    static CImg matrix(const T& a1,const T& a2,const T& a3,const T& a4,
+		       const T& a5,const T& a6,const T& a7,const T& a8,
+		       const T& a9,const T& a10,const T& a11,const T& a12,
+		       const T& a13,const T& a14,const T& a15,const T& a16) {
+      return CImg<T>(4,4).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);
+    }
+
+    //! Return a diffusion tensor with specified coefficients
+    static CImg tensor(const T& a1) { return matrix(a1); }
+    static CImg tensor(const T& a1,const T& a2,const T& a3) { return matrix(a1,a2,a2,a3); }
+    static CImg tensor(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) {
+      return matrix(a1,a2,a3,a2,a4,a5,a3,a5,a6);
+    }
+
+    //! Return a diagonal matrix with specified coefficients
+    static CImg diagonal(const T& a1) { return matrix(a1); }
+    static CImg diagonal(const T& a1,const T& a2) { return matrix(a1,0,0,a2); }
+    static CImg diagonal(const T& a1,const T& a2,const T& a3) { return matrix(a1,0,0,0,a2,0,0,0,a3); }
+    static CImg diagonal(const T& a1,const T& a2,const T& a3,const T& a4) { return matrix(a1,0,0,0,0,a2,0,0,0,0,a3,0,0,0,0,a4); }
+
+    //! Operator* (matrix product)
+    template<typename t> CImg operator*(const CImg<t>& img) const {
+      cimg_test_matrix(*this,"CImg<T>::operator*");
+      cimg_test_matrix(img,"CImg<T>::operator*");
+      if (width!=img.height) 
+        throw CImgArgumentException("CImg<%s>::operator*() : can't multiply a matrix *this = (%ux%u) by a matrix (%ux%u)",
+                                    pixel_type(),width,height,img.width,img.height);
+      CImg res(img.width,height);
+      double val;
+      cimg_mapXY(res,i,j) { val=0; cimg_mapX(*this,k) val+=(*this)(k,j)*img(i,k); res(i,j) = (T)val; }
+      return res;
+    }
+    //! Operator*= (matrix product)
+    template<typename t> CImg& operator*=(const CImg<t>& img) { return ((*this)*img).swap(*this); }
+  
+    //! Return a new image corresponding to the vector located at (\p x,\p y,\p z) of the current vector-valued image.
+    CImg get_vector(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
+      CImg dest(dim);
+      cimg_mapV(*this,k) dest[k]=(*this)(x,y,z,k);
+      return dest;
+    }
+  
+    //! Return a new image corresponding to the \a square \a matrix located at (\p x,\p y,\p z) of the current vector-valued image.
+    CImg get_matrix(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
+      const int n = (int)std::sqrt((double)dim);
+      CImg dest(n,n);
+      cimg_mapV(*this,k) dest[k]=(*this)(x,y,z,k);
+      return dest;
+    }
+  
+    //! Return a new image corresponding to the \a diffusion \a tensor located at (\p x,\p y,\p z) of the current vector-valued image.
+    CImg get_tensor(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {      
+      if (dim==6) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2),
+				(*this)(x,y,z,3),(*this)(x,y,z,4),(*this)(x,y,z,5));
+      if (dim==3) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2));
+      return tensor((*this)(x,y,z,0));
+    }
+
+    //! Set the image \p vec as the \a vector \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
+    CImg& set_vector(const CImg& vec,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
+      return draw_point(x,y,z,vec.data,1);
+    }
+    //! Set the image \p vec as the \a square \a matrix-valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
+    CImg& set_matrix(const CImg& mat,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
+      return set_vector(mat,x,y,z);
+    }
+    //! Set the image \p vec as the \a tensor \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
+    CImg& set_tensor(const CImg& ten,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
+      if (ten.height==2) {
+        (*this)(x,y,z,0)=ten[0];
+        (*this)(x,y,z,1)=ten[1];
+        (*this)(x,y,z,2)=ten[3];
+      }
+      else {
+        (*this)(x,y,z,0)=ten[0];
+        (*this)(x,y,z,1)=ten[1];
+        (*this)(x,y,z,2)=ten[2];
+        (*this)(x,y,z,3)=ten[4];
+        (*this)(x,y,z,4)=ten[5];
+        (*this)(x,y,z,5)=ten[8];
+      }
+      return *this;
+    }
+    //! Set the current matrix to be the identity matrix.
+    CImg& identity_matrix() {    
+      cimg_test_square(*this,"CImg<T>::identity_matrix");
+      fill(0);
+      cimg_mapX(*this,x) (*this)(x,x) = (T)1;
+      return *this;
+    }
+    //! Return a matrix \p dim * \p dim equal to \p factor * \a Identity.
+    static CImg get_identity_matrix(const unsigned int dim) {
+      return CImg<T>(dim,dim).identity_matrix();
+    }
+  
+    //! Return the transpose version of the current matrix.
+    CImg get_transpose() const {
+      cimg_test_matrix(*this,"CImg<T>::get_transpose");
+      CImg res(height,width);
+      cimg_mapXY(res,x,y) res(x,y) = (*this)(y,x);
+      return res;
+    }
+    //! Replace the current matrix by its transpose.
+    CImg& transpose() { return get_transpose().swap(*this); }
+
+    //! Get a diagonal matrix, whose diagonal coefficients are the coefficients of the input image
+    CImg get_diagonal() const {
+      cimg_test(*this,"CImg<T>::get_diagonal");
+      CImg res(size(),size(),1,1,0);
+      cimg_mapoff(*this,off) res(off,off)=(*this)(off);
+      return res;
+    }
+    //! Replace a vector by a diagonal matrix containing the original vector coefficients.
+    CImg& diagonal() { return get_diagonal().swap(*this); }
+
+    //! Inverse the current matrix.
+    CImg& inverse() {
+      cimg_test_square(*this,"CImg<T>::inverse");
+      switch (width) {
+      case 2:
+        {
+          const double 
+            a = data[0], c = data[1],
+            b = data[2], d = data[3],
+            dete = det();
+          if (dete) { 
+            data[0] = (T)(d/dete);  data[1] = (T)(-c/dete);
+            data[2] = (T)(-b/dete), data[3] = (T)(a/dete); 
+          } else {
+            cimg::warn(true,"CImg<%s>::inverse() : Matrix determinant is 0, can't invert matrix",pixel_type());
+            fill(0);
+          }
+        }
+        break;
+      case 3:
+        {
+          const double
+            a = data[0], d = data[1], g = data[2],
+            b = data[3], e = data[4], h = data[5],
+            c = data[6], f = data[7], i = data[8],
+            dete = det();
+          if (dete) {
+            data[0] = (T)((i*e-f*h)/dete), data[1] = (T)((g*f-i*d)/dete), data[2] = (T)((d*h-g*e)/dete);
+            data[3] = (T)((h*c-i*b)/dete), data[4] = (T)((i*a-c*g)/dete), data[5] = (T)((g*b-a*h)/dete);
+            data[6] = (T)((b*f-e*c)/dete), data[7] = (T)((d*c-a*f)/dete), data[8] = (T)((a*e-d*b)/dete);
+          } else {
+            cimg::warn(true,"CImg<%s>::inverse() : Matrix determinant is 0, can't invert matrix",pixel_type());
+            fill(0);
+          }
+        }
+        break;
+      default:
+        {        
+          int N = width, LWORK = 4*N, *IPIV = new int[N], INFO;
+          double *A = new double[N*N], *WORK = new double[LWORK];
+          for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) A[k*N+l] = (*this)(k,l);
+          dgetrf_(&N,&N,A,&N,IPIV,&INFO);
+          cimg::warn(INFO!=0,"CImg<%s>::inverse() : LAPACK Error code = %d, from dgetrf_()",pixel_type(),INFO);
+          if (!INFO) {
+            dgetri_(&N,A,&N,IPIV,WORK,&LWORK,&INFO);
+            cimg::warn(INFO!=0,"CImg<%s>::inverse() : LAPACK Error code = %d, from dgetri_()",pixel_type(),INFO);
+          }
+          if (!INFO) for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) (*this)(k,l) = (T)(A[k*N+l]);
+          else fill(0);
+          delete[] IPIV; delete[] A; delete[] WORK;        
+        }
+      }
+      return *this;
+    }
+    //! Return the inverse of the current matrix.
+    CImg get_inverse() const { return CImg<T>(*this).inverse(); }
+
+    //! Return the trace of the current matrix.
+    double trace() const {
+      cimg_test_square(*this,"CImg<T>::trace");
+      double res=0;
+      cimg_mapX(*this,k) res+=(*this)(k,k);
+      return res;
+    }
+    //! Return the dot product of the current vector/matrix with the vector/matrix \p img.
+    double dot(const CImg& img) const {
+      cimg_test(*this,"CImg<T>::dot"); cimg_test(img,"CImg<T>::dot");
+      const unsigned int nb = cimg::min(size(),img.size());
+      double res=0;
+      for (unsigned int off=0; off<nb; off++) res+=data[off]*img[off];
+      return res;
+    }
+	
+    //! Return the cross product between two 3d vectors
+    CImg& cross(const CImg& img) {
+      if (width!=1 || height<3 || img.width!=1 || img.height<3)
+        throw CImgInstanceException("CImg<%s>::cross() : cannot get cross product between two matrices (%u,%u) and (%u,%u)",
+                                    pixel_type(),width,height,img.width,img.height);
+      const T x = (*this)[0], y = (*this)[1], z = (*this)[2];
+      (*this)[0] = y*img[2]-z*img[1];
+      (*this)[1] = z*img[0]-x*img[2];
+      (*this)[2] = x*img[1]-y*img[0];
+      return *this;
+    }
+    //! Return the cross product between two 3d vectors
+    CImg get_cross(const CImg& img) const { return CImg<T>(*this).cross(img); }
+
+    //! Return the determinant of the current matrix.
+    double det() const {
+      cimg_test_square(*this,"CImg<T>::det");
+      switch (width) {
+      case 1: return (*this)(0,0);
+      case 2: return (*this)(0,0)*(*this)(1,1)-(*this)(0,1)*(*this)(1,0);
+      case 3: 
+        {
+          const double
+            a = data[0], d = data[1], g = data[2],
+            b = data[3], e = data[4], h = data[5],
+            c = data[6], f = data[7], i = data[8];
+          return i*a*e-a*h*f-i*b*d+b*g*f+c*d*h-c*g*e;
+        }
+      }
+      return 0;
+    }
+    //! Return the norm of the current vector/matrix. \p ntype = norm type (0=L2, 1=L1, -1=Linf).
+    double norm(const int ntype=2) const {
+      cimg_test(*this,"CImg<T>::norm");
+      double res = 0;
+      switch (ntype) {
+      case -1: { cimg_mapoff(*this,off) if (std::fabs((double)data[off])>res) res = std::fabs((double)data[off]); return res; }
+      case 1 : { cimg_mapoff(*this,off) res+=std::fabs((double)data[off]); return res; }
+      default: { return std::sqrt(dot(*this)); }
+      }
+      return 0;
+    }
+    //! Return the sum of all the pixel values in an image.
+    double sum() const {
+      cimg_test(*this,"CImg<T>::sum");		
+      double res=0;
+      cimg_map(*this,ptr,T) res+=*ptr;
+      return res;
+    }
+    //! Compute the eigenvalues and eigenvectors of a general matrix.
+    template<typename t> const CImg<T>& eigen(CImg<t>& val, CImg<t> &vec) const {
+      cimg_test_square(*this,"CImg<T>::eigen");
+      if (val.size()<width) 
+        throw CImgArgumentException("CImg<%s>::eigen() : Argument 'val' is not large enough to be filled with eigenvalues (size=%u, needed is %u)",
+                                    pixel_type(),val.size(),width);
+      if (vec.data && vec.size()<width*width) 
+        throw CImgArgumentException("CImg<%s>::eigen() : Argument 'vec' is not large enough to be filled with eigenvectors (size=%u, needed is %u)",
+                                    pixel_type(),val.size(),width*width);
+      switch(width) {
+      case 1:
+        val[0]=(t)(*this)[0]; 
+        if (vec.data) vec[0]=(t)1;
+        break;
+      case 2:
+        {
+          const double
+            a = (*this)[0], b = (*this)[1],
+            c = (*this)[2], d = (*this)[3],
+            e = a+d;
+          double f = e*e-4*(a*d-b*c);
+          cimg::warn(f<0,"CImg<%s>::eigen() : Complex eigenvalues",pixel_type());
+          f = std::sqrt(f);
+          const double l1 = 0.5*(e-f), l2 = 0.5*(e+f);
+          val[0]=(t)l1; val[1]=(t)l2;
+          if (vec.data) {
+            double u,v,n;
+            if (std::fabs(b)>std::fabs(a-l1)) { u = 1; v = (l1-a)/b; }
+            else { if (a-l1!=0) { u = -b/(a-l1); v = 1; } else { u = 1; v = 0; } }
+            n = std::sqrt(u*u+v*v); u/=n; v/=n; vec[0] = (t)u; vec[1] = (t)v;
+            if (std::fabs(b)>std::fabs(a-l2)) { u = 1; v = (l2-a)/b; }
+            else { if (a-l2!=0) { u = -b/(a-l2); v = 1; } else { u = 0; v = 1; } }
+            n = std::sqrt(u*u+v*v); u/=n; v/=n; vec[2] = (t)u; vec[3] = (t)v;
+          }
+        }
+        break;
+      default: 
+        throw CImgInstanceException("CImg<%s>::eigen() : Eigenvalues computation of general matrices is limited to 2x2 matrices (given is %ux%u)",
+                                    pixel_type(),width,height);
+      }
+      return *this;
+    }
+
+    //! Compute the eigenvalues of a general matrix.
+    template<typename t> const CImg<T>& eigen(CImg<t>& val) const { CImg foo; return eigen(val,foo); }
+    CImgl<T> get_eigen(const bool compute_vectors=true) const {
+      cimg_test_square(*this,"CImg<T>::get_eigen");
+      CImgl<T> res(1,1,width);
+      if (compute_vectors) res.insert(CImg<T>(width,width));
+      eigen(res[0],res[1]);
+      return res;
+    }
+
+    //! Compute the eigenvalues and eigenvectors of a symmetric matrix.
+    template<typename t> const CImg<T>& symeigen(CImg<t>& val, CImg<t>& vec) const {
+      cimg_test_square(*this,"CImg<T>::symeigen");
+      if (val.size()<width) 
+        throw CImgArgumentException("CImg<%s>::symeigen() : Argument 'val' is not large enough to be filled with eigenvalues (size=%u, needed is %u)",
+                                    pixel_type(),val.size(),width);
+      if (vec.data && vec.size()<width*width) 
+        throw CImgArgumentException("CImg<%s>::symeigen() : Argument 'vec' is not large enough to be filled with eigenvectors (size=%u, needed is %u)",
+                                    pixel_type(),val.size(),width*width);
+      char JOBZ=vec.data?'V':'N', UPLO='U';
+      int N,INFO=0,LWORK;
+      double *WORK,*A,*VAL;
+      if (width<3) return eigen(val,vec);
+      N = width;
+      LWORK = 5*N;
+      A    = new double[N*N];
+      WORK = new double[LWORK];
+      VAL  = new double[width];
+      for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) A[k*N+l] = (*this)(k,l);
+      dsyev_(&JOBZ,&UPLO,&N,A,&N,VAL,WORK,&LWORK,&INFO);
+      cimg::warn(INFO!=0,"CImg<%s>::symeigen() : LAPACK Error code = %d, from ssyev_()",pixel_type(),INFO);
+      cimg_mapX(*this,x) val(x) = (t)VAL[x];
+      if (vec.data) cimg_mapXY(*this,x,y) vec(x,y) = (t)A[x+y*N];
+      delete[] A; 
+      delete[] WORK;
+      delete[] VAL;
+      return *this;
+    }
+    //! Compute the eigenvalues of a symmetric matrix.
+    template<typename t> const CImg<T>& symeigen(CImg<t>& val) const { CImg foo; return symeigen(val,foo); }
+    CImgl<T> get_symeigen(const bool compute_vectors=true) const {
+      cimg_test_square(*this,"CImg<T>::symeigen");
+      CImgl<T> res(1,1,width);
+      if (compute_vectors) res.insert(CImg<T>(width,width));
+      symeigen(res[0],res[1]);
+      return res;
+    }
+
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Display functions
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+  
+    //! Display an image into a CImgDisplay window.
+    const CImg& display(CImgDisplay& disp,const unsigned int ymin=0,const unsigned int ymax=~0) const { disp.display(*this,ymin,ymax); return *this; }
+
+    //! Same as \ref cimg::wait()
+    const CImg& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this;  }
+  
+    //! Display an image in a window with a title \p title, and wait a 'closed' or 'keyboard' event.\n
+    //! Parameters \p min_size and \p max_size set the minimum and maximum dimensions of the display window.
+    //! If negative, they corresponds to a percentage of the original image size.
+    const CImg& display(const char* title,const int min_size=128,const int max_size=1024) const {
+      cimg_test(*this,"CImg<T>::display");
+      CImgDisplay *disp;
+      unsigned int w = width+(depth>1?depth:0), h = height+(depth>1?depth:0), XYZ[3];
+      print(title);
+      const unsigned int dmin = cimg::min(w,h), minsiz = min_size>=0?min_size:(-min_size)*dmin/100;
+      if (dmin<minsiz) { w=w*minsiz/dmin; w+=(w==0); h=h*minsiz/dmin; h+=(h==0); }
+      const unsigned int dmax = cimg::max(w,h), maxsiz = max_size>=0?max_size:(-max_size)*dmax/100;
+      if (dmax>maxsiz) { w=w*maxsiz/dmax; w+=(w==0); h=h*maxsiz/dmax; h+=(h==0); }
+      disp = new CImgDisplay(CImg<unsigned char>(w,h,1,1,0),title,0,3);
+      XYZ[0] = width/2; XYZ[1] = height/2; XYZ[2] = depth/2;
+      while (!disp->closed && !disp->key) feature_selection(NULL,1,*disp,XYZ);
+      delete disp;
+      return *this;
+    }
+
+    //! Display an image in a window, with a default title. See also \see display() for details on parameters.
+    const CImg& display(const int min_size=128,const int max_size=1024) const { return display("",min_size,max_size); }
+  
+    //! High-level interface to select features from images
+    const CImg& feature_selection(int *const selection, const int feature_type,CImgDisplay &disp,
+                                  unsigned int *const XYZ=NULL,const unsigned char *const color=NULL) const {
+      cimg_test(*this,"CImg<T>::feature_selection");
+      if (disp.events<3) 
+        throw CImgArgumentException("CImg<%s>::feature_selection() : Input display must be able to catch keyboard and mouse events (events>=3). Given display has 'events = %s'.",pixel_type(),disp.events);
+      unsigned char fgcolor[3]={255,255,105},bgcolor[3]={0,0,0};
+      if (color) std::memcpy(fgcolor,color,sizeof(unsigned char)*cimg::min(3,dimv()));
+      int carea=0,area=0,phase=0,
+        X0=(XYZ?XYZ[0]:width/2)%width, Y0=(XYZ?XYZ[1]:height/2)%height, Z0=(XYZ?XYZ[2]:depth/2)%depth, 
+        X=-1,Y=-1,Z=-1,oX=-1,oY=-1,oZ=-1,X1=-1,Y1=-1,Z1=-1;
+      unsigned long hatch=feature_type?0xF0F0F0F0:~0L;
+      bool feature_selected = false, ytext = false;
+      CImg<unsigned char> visu, visu0;
+      char text[1024];
+    
+      while (!disp.key && !disp.closed && !feature_selected) {
+
+        // Init visu0 if necessary
+        if (disp.resized || !visu0.data) { 
+          if (disp.resized) disp.resize();
+          if (depth==1) visu0=get_normalize(0,(T)255); else visu0=get_3dplanes(X0,Y0,Z0).get_normalize(0,(T)255);
+          visu0.resize(disp.width,disp.height,1,cimg::min(3,dimv()));
+        }
+        visu = visu0;      
+      
+        // Handle motion and selection
+        const int mx = disp.mousex, my = disp.mousey, b = disp.button;
+        if (mx>=0 && my>=0) {
+          const int mX = mx*(width+(depth>1?depth:0))/disp.width, mY = my*(height+(depth>1?depth:0))/disp.height;
+          if (mX<dimx() && mY<dimy())   { area=1; X=mX; Y=mY; Z=phase?Z1:Z0; }
+          if (mX<dimx() && mY>=dimy())  { area=2; X=mX; Y=phase?Y1:Y0; Z=mY-height; }
+          if (mX>=dimx() && mY<dimy())  { area=3; X=phase?X1:X0; Y=mY; Z=mX-width;  }
+          if (mX>=dimx() && mY>=dimy()) { X=X0; Y=Y0; Z=Z0; }
+          if ((!(phase%2) && (b&1)) || (phase%2 && !(b&1))) { 
+            if (!carea) carea=area;
+            if (!(phase++)) { X0=X; Y0=Y; Z0=Z; }
+          }
+          if (b&2) { if (!phase) { X0=X; Y0=Y; Z0=Z; } else { X1=Y1=Z1=-1; phase=carea=0; }}
+          if ((b&2 || phase) && depth>1) 
+            visu0 = get_3dplanes(X,Y,Z).normalize(0,(T)255).resize(disp.width,disp.height,1,cimg::min(3,dimv()));
+          if (phase) {
+            if (!feature_type) feature_selected = phase?true:false;
+            else {
+              if (depth>1) feature_selected = (phase==3)?true:false;
+              else feature_selected = (phase==2)?true:false;
+            }   
+            if (!feature_selected) {
+              if (phase<2) { X1=X; Y1=Y; Z1=Z; }
+              else switch(carea) {
+              case 1: Z1=Z; break;
+              case 2: Y1=Y; break;
+              case 3: X1=X; break;
+              }
+            }
+          }
+          if (!phase || !feature_type) {
+            if (depth>1) std::sprintf(text,"Coords (%d,%d,%d)={ ",X,Y,Z); else std::sprintf(text,"Coords (%d,%d)={ ",X,Y);
+            cimg_mapV(*this,k) std::sprintf(text+cimg::strlen(text),"%g ",(double)(*this)(X,Y,Z,k));
+            std::sprintf(text+cimg::strlen(text),"}");
+            if (!feature_type) { X1=X0; Y1=Y0; Z1=Z0; }
+          } else
+            switch (feature_type) {
+            case 1:
+              {
+                const double dX=(double)(X0-X1), dY=(double)(Y0-Y1), dZ=(double)(Z0-Z1), norm = std::sqrt(dX*dX+dY*dY+dZ*dZ);
+                if (depth>1) std::sprintf(text,"Vect (%d,%d,%d)-(%d,%d,%d), norm=%g",X0,Y0,Z0,X1,Y1,Z1,norm);
+                else std::sprintf(text,"Vect (%d,%d)-(%d,%d), norm=%g",X0,Y0,X1,Y1,norm);
+              }
+              break;
+            case 2:
+              if (depth>1) std::sprintf(text,"Box (%d,%d,%d)-(%d,%d,%d), Size=(%d,%d,%d)",
+                                        X0<X1?X0:X1,Y0<Y1?Y0:Y1,Z0<Z1?Z0:Z1,
+                                        X0<X1?X1:X0,Y0<Y1?Y1:Y0,Z0<Z1?Z1:Z0,
+                                        1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
+              else  std::sprintf(text,"Box (%d,%d)-(%d,%d), Size=(%d,%d)",
+                                 X0<X1?X0:X1,Y0<Y1?Y0:Y1,X0<X1?X1:X0,Y0<Y1?Y1:Y0,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
+              break;
+            }
+          if (my<12) ytext=true;
+          if (my>=visu.dimy()-11) ytext=false;
+          visu.draw_text(text,0,ytext?visu.dimy()-11:0,fgcolor,bgcolor,0.7f);
+        } else { X=Y=Z=-1; if (phase) disp.button=phase%2; }
+      
+        // Draw image + selection on display window
+        if (X>=0 && Y>=0 && Z>=0) {
+          hatch=cimg::ror(hatch);
+          if (feature_type==1 && phase) {
+            const int d=(depth>1)?depth:0,
+              x0=(int)((X0+0.5f)*disp.width/(width+d)), y0=(int)((Y0+0.5f)*disp.height/(height+d)),
+              x1=(int)((X1+0.5f)*disp.width/(width+d)), y1=(int)((Y1+0.5f)*disp.height/(height+d));
+            visu.draw_arrow(x0,y0,x1,y1,fgcolor,30.0f,5.0f,hatch);
+            if (d) {
+              const int zx0=(int)((width+Z0+0.5f)*disp.width/(width+d)), zx1=(int)((width+Z1+0.5f)*disp.width/(width+d)),
+                zy0=(int)((height+Z0+0.5f)*disp.height/(height+d)), zy1=(int)((height+Z1+0.5f)*disp.height/(height+d));
+              visu.draw_arrow(zx0,y0,zx1,y1,fgcolor,30.0f,5.0f,hatch).draw_arrow(x0,zy0,x1,zy1,fgcolor,30.0f,5.0f,hatch);
+            }
+          } else {
+            const bool cond=(phase&&feature_type);
+            const int d=(depth>1)?depth:0,
+              nX0=cond?X0:X, nY0=cond?Y0:Y, nZ0=cond?Z0:Z,
+              nX1=cond?X1:X, nY1=cond?Y1:Y, nZ1=cond?Z1:Z,
+              x0=(nX0<nX1?nX0:nX1)*disp.width/(width+d),
+              y0=(nY0<nY1?nY0:nY1)*disp.height/(height+d),
+              x1=((nX0<nX1?nX1:nX0)+1)*disp.width/(width+d)-1,
+              y1=((nY0<nY1?nY1:nY0)+1)*disp.height/(height+d)-1;
+            const unsigned long nhatch=phase?hatch:~0L;
+            visu.draw_rectangle(x0,y0,x1,y1,fgcolor,0.2f).draw_line(x0,y0,x1,y0,fgcolor,nhatch).
+              draw_line(x1,y0,x1,y1,fgcolor,nhatch).draw_line(x1,y1,x0,y1,fgcolor,nhatch).draw_line(x0,y1,x0,y0,fgcolor,nhatch);
+            if (d) {
+              const int
+                zx0=(int)((width+(nZ0<nZ1?nZ0:nZ1))*disp.width/(width+d)),
+                zy0=(int)((height+(nZ0<nZ1?nZ0:nZ1))*disp.height/(height+d)),
+                zx1=(int)((width+(nZ0<nZ1?nZ1:nZ0)+1)*disp.width/(width+d))-1,
+                zy1=(int)((height+(nZ0<nZ1?nZ1:nZ0)+1)*disp.height/(height+d))-1;
+              visu.draw_rectangle(zx0,y0,zx1,y1,fgcolor,0.2f).draw_line(zx0,y0,zx1,y0,fgcolor,nhatch).
+                draw_line(zx1,y0,zx1,y1,fgcolor,nhatch).draw_line(zx1,y1,zx0,y1,fgcolor,nhatch).draw_line(zx0,y1,zx0,y0,fgcolor,nhatch);
+              visu.draw_rectangle(x0,zy0,x1,zy1,fgcolor,0.2f).draw_line(x0,zy0,x1,zy0,fgcolor,nhatch).
+                draw_line(x1,zy0,x1,zy1,fgcolor,nhatch).draw_line(x1,zy1,x0,zy1,fgcolor,nhatch).draw_line(x0,zy1,x0,zy0,fgcolor,nhatch);
+            }
+          }
+        }
+        visu.display(disp).wait(32);
+        if (!feature_selected && (!phase && oX==X && oY==Y && oZ==Z) || (X<0 || Y<0 || Z<0)) disp.wait();
+        oX=X; oY=Y; oZ=Z;
+      }
+
+      // Return result
+      if (XYZ) { XYZ[0] = X; XYZ[1] = Y; XYZ[2] = Z; }
+      if (feature_selected) {
+        if (feature_type==2) {
+          if (X0>X1) cimg::swap(X0,X1);
+          if (Y0>Y1) cimg::swap(Y0,Y1);
+          if (Z0>Z1) cimg::swap(Z0,Z1);
+        }
+        if (selection) {
+          if (X1<0 || Y1<0 || Z1<0) X0=Y0=Z0=X1=Y1=Z1=-1;
+          switch(feature_type) {
+          case 1:
+          case 2:  selection[3] = X1; selection[4] = Y1; selection[5] = Z1;
+          default: selection[0] = X0; selection[1] = Y0; selection[2] = Z0;
+          }
+        }
+      } else if (selection) selection[0]=selection[1]=selection[2]=selection[3]=selection[4]=selection[5]=-1;
+      disp.button=0;
+      return *this;
+    }
+
+    //! High-level interface to select features in images
+    const CImg& feature_selection(int *const selection, const int feature_type,
+                                  unsigned int *const XYZ=NULL,const unsigned char *const color=NULL) const {
+      unsigned int w = width + (depth>1?depth:0), h = height + (depth>1?depth:0);
+      const unsigned int dmin = cimg::min(w,h), minsiz = 256;
+      if (dmin<minsiz) { w=w*minsiz/dmin; h=h*minsiz/dmin; }
+      const unsigned int dmax = cimg::max(w,h), maxsiz = 1024;
+      if (dmax>maxsiz) { w=w*maxsiz/dmax; h=h*maxsiz/dmax; }
+      CImgDisplay disp(w,h,"",0,3);
+      return feature_selection(selection,feature_type,disp,XYZ,color);
+    }
+  
+ 
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Input-Output functions
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+
+    //! Load an image from a file.
+    /**
+       \note The extension of \c filename defines the file format.
+    **/
+    static CImg load(const char *filename) {
+      const char *ext = cimg::filename_split(filename);
+      if (!filename) throw CImgArgumentException("CImg<%s>::load() : Can't load (null) filename",pixel_type());
+      if (!cimg::strcasecmp(ext,"asc")) return load_ascii(filename);
+      if (!cimg::strcasecmp(ext,"dlm")) return load_dlm(filename);
+      if (!cimg::strcasecmp(ext,"inr")) return load_inr(filename);
+      if (!cimg::strcasecmp(ext,"hdr")) return load_analyze(filename);
+      if (!cimg::strcasecmp(ext,"pan")) return load_pandore(filename);
+      if (!cimg::strcasecmp(ext,"bmp")) return load_bmp(filename);
+      if (!cimg::strcasecmp(ext,"ppm") || 
+	  !cimg::strcasecmp(ext,"pgm") ||
+	  !cimg::strcasecmp(ext,"pnm")) return load_pnm(filename);
+      if (!cimg::strcasecmp(ext,"raw") || ext[0]=='\0') return load_raw(filename);      
+      return load_convert(filename);
+    }
+
+    //! Load an image from an ASCII file
+    static CImg load_ascii(const char *filename) {
+      std::FILE *file = cimg::fopen(filename,"rb");
+      char line[256] = {0};
+      std::fscanf(file,"%255[^\n]",line);
+      unsigned int off;
+	  int err=1, dx=0, dy=1, dz=1, dv=1;
+      std::sscanf(line,"%d %d %d %d",&dx,&dy,&dz,&dv);
+      if (!dx || !dy || !dz || !dv)
+	throw CImgIOException("CImg<%s>::load_ascii() : File '%s' does not appear to be a valid ASC file.\n"
+			      "Specified image dimensions are (%d,%d,%d,%d)",pixel_type(),filename,dx,dy,dz,dv);
+      CImg dest(dx,dy,dz,dv);
+      double val;
+      T *ptr = dest.data;
+      for (off=0; off<dest.size() && err==1; off++) {
+	err = fscanf(file,"%lf%*[^0-9.eE+-]",&val); 
+	*(ptr++)=(T)val; 
+      }
+      cimg::warn(off<dest.size(),"CImg<%s>::load_ascii() : File '%s', only %u values read, instead of %u",
+		 pixel_type(),filename,off,dest.size());
+      cimg::fclose(file);
+      return dest;
+    }
+
+    //! Load an image from a DLM file
+    static CImg load_dlm(const char *filename) {
+      std::FILE *file = cimg::fopen(filename,"rb");
+      unsigned int cdx=0,dx=0,dy=0;
+      double val;
+      char c, delimiter[256]={0};
+      int err;
+      while ((err = std::fscanf(file,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
+	if (err>0) cdx++;
+	if (std::sscanf(delimiter,"%*[^\n]%c",&c)>0 && c=='\n') { dx = cimg::max(cdx,dx); dy++; cdx=0; }
+      }
+      if (!dx || !dy) throw CImgIOException("CImg<%s>::load_dlm() : File '%s' does not appear to be a "
+					    "valid DLM file.\n",pixel_type(),filename);
+      std::rewind(file);
+      CImg<T> dest(dx,dy,1,1,0);
+      unsigned int x = 0, y = 0;
+      while ((err = std::fscanf(file,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
+	if (err>0) dest(x++,y) = (T)val;
+	if (std::sscanf(delimiter,"%*[^\n]%c",&c)>0 && c=='\n') { x=0; y++; }
+      }
+      cimg::fclose(file);
+      return dest;
+    }
+
+    //! Load an image from a PNM file
+    static CImg load_pnm(const char *filename) {
+      std::FILE *file=cimg::fopen(filename,"rb");
+      char item[1024]={0};
+      unsigned int ppm_type,width,height,colormax=255;
+      int err;
+      
+      while ((err=std::fscanf(file,"%1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
+      if(std::sscanf(item," P%u",&ppm_type)!=1) 
+        throw CImgIOException("CImg<%s>::load_pnm() : file '%s',PPM header 'P?' not found",pixel_type(),filename);
+      while ((err=std::fscanf(file," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
+      if (std::sscanf(item," %u %u",&width,&height)!=2)
+        throw CImgIOException("CImg<%s>::load_pnm() : file '%s',WIDTH and HEIGHT not defined",pixel_type(),filename);
+      while ((err=std::fscanf(file," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
+      std::fgetc(file);
+      cimg::warn(std::sscanf(item,"%u",&colormax)!=1,"CImg<%s>::load_pnm() : file '%s',COLORMAX not defined",pixel_type(),filename);
+      cimg::warn(colormax!=255,"CImg<%s>::load_pnm() : file '%s', COLORMAX=%u mode is not supported",pixel_type(),filename,colormax);
+
+      CImg dest;
+      int rval,gval,bval;
+
+      switch (ppm_type) {
+      case 2: { // Grey Ascii
+	dest = CImg<T>(width,height,1,1);
+	T* rdata = dest.ptr();
+	cimg_mapoff(dest,off) { std::fscanf(file,"%d",&rval); *(rdata++)=(T)rval; }
+      } break;
+      case 3: { // Color Ascii
+	dest = CImg<T>(width,height,1,3);
+	T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
+	cimg_mapXY(dest,x,y) { 
+	  std::fscanf(file,"%d %d %d",&rval,&gval,&bval);
+	  *(rdata++)=(T)rval; 
+	  *(gdata++)=(T)gval; 
+	  *(bdata++)=(T)bval; }
+      } break;
+      case 5: { // Grey Binary
+	unsigned char *raw = new unsigned char[width*height], *raw2 = raw;
+	cimg::fread(raw,sizeof(unsigned char),width*height,file);
+	dest = CImg<T>(width,height,1,1);
+	T *rdata = dest.ptr();
+	cimg_mapoff(dest,off) *(rdata++)=(T)*(raw2++);
+	delete[] raw;
+      } break;
+      case 6: { // Color Binary
+	unsigned char *raw = new unsigned char[width*height*3], *raw2 = raw;
+	cimg::fread(raw,sizeof(unsigned char),width*height*3,file);
+	dest = CImg<T>(width,height,1,3);
+	T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
+	cimg_mapXY(dest,x,y) {
+	  *(rdata++)=(T)*(raw2++);
+	  *(gdata++)=(T)*(raw2++);
+	  *(bdata++)=(T)*(raw2++); 
+	}
+	delete[] raw;
+      } break;
+      default:
+	cimg::fclose(file);
+	throw CImgIOException("CImg<%s>::load_pnm() : file '%s', PPM type 'P%d' not supported",pixel_type(),filename,ppm_type);
+      }
+      cimg::fclose(file);
+      return dest;
+    }
+
+    //! Load an image from a BMP file.
+    static CImg load_bmp(const char *filename) {
+      unsigned char header[64];
+      std::FILE *file = cimg::fopen(filename,"rb");
+      cimg::fread(header,sizeof(unsigned char),54,file);
+      if (header[0]!='B' || header[1]!='M')
+	throw CImgIOException("CImg<%s>::load_bmp() : filename '%s' does not appear to be a valid BMP file",
+			      pixel_type(),filename);
+      
+      // Read header and pixel buffer
+      int
+	file_size   = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24),
+	offset      = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24),
+	dx          = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24),
+	dy          = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24),
+	compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24),
+	nb_colors   = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24),
+	bpp         = header[0x1C] + (header[0x1D]<<8),
+	*palette    = NULL;
+      const int 
+	dx_bytes   = (bpp==1)?(dx/8+(dx%8?1:0)):((bpp==4)?(dx/2+(dx%2?1:0)):(dx*bpp/8)),
+	align      = (4-dx_bytes%4)%4,
+	buf_size   = cimg::min(cimg::abs(dy)*(dx_bytes+align),file_size-offset);
+
+      if (bpp<16) { if (!nb_colors) nb_colors=1<<bpp; } else nb_colors=0;
+      if (nb_colors) { palette = new int[nb_colors]; cimg::fread(palette,sizeof(int),nb_colors,file); }
+      const int	xoffset = offset-54-4*nb_colors;      
+      if (xoffset>0) std::fseek(file,xoffset,SEEK_CUR);
+      const unsigned char *buffer  = new unsigned char[buf_size], *ptrs = buffer;
+      cimg::fread(buffer,sizeof(unsigned char),buf_size,file);
+      cimg::fclose(file);
+
+      // Decompress buffer (if necessary)
+      if (compression) return load_convert(filename);
+      
+      // Read pixel data
+      CImg res(dx,cimg::abs(dy),1,3);
+      switch (bpp) {
+      case 1: { // Monochrome
+	for (int y=res.height-1; y>=0; y--) { 
+	  unsigned char mask = 0x80, val = 0;
+	  cimg_mapX(res,x) {
+	    if (mask==0x80) val = *(ptrs++);
+	    const unsigned char *col = (unsigned char*)(palette+(val&mask?1:0));
+	    res(x,y,2) = (T)*(col++);
+	    res(x,y,1) = (T)*(col++);
+	    res(x,y,0) = (T)*(col++);
+	    mask = cimg::ror(mask);
+	  } ptrs+=align; }
+      } break;
+      case 4: { // 16 colors
+	for (int y=res.height-1; y>=0; y--) { 
+	  unsigned char mask = 0xF0, val = 0;
+	  cimg_mapX(res,x) {
+	    if (mask==0xF0) val = *(ptrs++);
+	    const unsigned char color = (mask<16)?(val&mask):((val&mask)>>4);
+	    unsigned char *col = (unsigned char*)(palette+color);
+	    res(x,y,2) = (T)*(col++);
+	    res(x,y,1) = (T)*(col++);
+	    res(x,y,0) = (T)*(col++);
+	    mask = cimg::ror(mask,4);
+	  } ptrs+=align; }
+      } break;
+      case 8: { //  256 colors
+	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
+	  const unsigned char *col = (unsigned char*)(palette+*(ptrs++));
+	  res(x,y,2) = (T)*(col++);
+	  res(x,y,1) = (T)*(col++);
+	  res(x,y,0) = (T)*(col++);
+	} ptrs+=align; }
+      } break;
+      case 16: { // 16 bits colors
+	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
+	  const unsigned char c1 = *(ptrs++), c2 = *(ptrs++);
+	  const unsigned short col = c1+(c2<<8);
+	  res(x,y,2) = (T)(col&0x1F);
+	  res(x,y,1) = (T)((col>>5)&0x1F);
+	  res(x,y,0) = (T)((col>>10)&0x1F);
+	} ptrs+=align; }
+      } break;	
+      case 24: { // 24 bits colors
+	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
+	  res(x,y,2) = (T)*(ptrs++);
+	  res(x,y,1) = (T)*(ptrs++);
+	  res(x,y,0) = (T)*(ptrs++);
+	} ptrs+=align; }
+      } break;
+      case 32: { // 32 bits colors
+	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
+	  res(x,y,2) = (T)*(ptrs++);
+	  res(x,y,1) = (T)*(ptrs++);
+	  res(x,y,0) = (T)*(ptrs++);
+	  ptrs++;
+	} ptrs+=align; }
+      } break;
+      }
+
+      if (palette) delete[] palette;
+      if (dy<0) res.flip('y');
+      return res;
+    }
+
+
+    //! Load an image from an INRIMAGE-4 file.
+#define cimg_load_inr_case(Tf,sign,pixsize,Ts)                            \
+  if (!loaded && fopt[6]==pixsize && fopt[4]==Tf && fopt[5]==sign) {      \
+      Ts *xval, *val = new Ts[fopt[0]*fopt[3]];                           \
+      cimg_mapYZ(dest,y,z) {                                              \
+          cimg::fread(val,pixsize/8,fopt[0]*fopt[3],file);                \
+          if (fopt[7]!=endian) cimg::endian_swap(val,fopt[0]*fopt[3]);    \
+          xval = val; cimg_mapX(dest,x) cimg_mapV(dest,k)                 \
+                          dest(x,y,z,k) = (T)*(xval++);                   \
+        }                                                                 \
+      delete[] val;                                                       \
+      loaded = true;                                                      \
+    }
+    
+    static void _load_inr(std::FILE *file,int out[8],float *voxsize=NULL) {
+      char item[1024],tmp1[64],tmp2[64];
+      out[0]=out[1]=out[2]=out[3]=out[5]=1; out[4]=out[6]=out[7]=-1;
+      std::fscanf(file,"%63s",item);
+      if(cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0) 
+	throw CImgIOException("CImg<%s>::load_inr() : File does not appear to be a valid INR file.\n"
+			      "(INRIMAGE-4 identifier not found)",pixel_type());
+      while (std::fscanf(file," %63[^\n]%*c",item)!=EOF && cimg::strncmp(item,"##}",3)) {
+        std::sscanf(item," XDIM%*[^0-9]%d",out);
+        std::sscanf(item," YDIM%*[^0-9]%d",out+1);
+        std::sscanf(item," ZDIM%*[^0-9]%d",out+2);
+        std::sscanf(item," VDIM%*[^0-9]%d",out+3);
+        std::sscanf(item," PIXSIZE%*[^0-9]%d",out+6);
+        if (voxsize) {
+          std::sscanf(item," VX%*[^0-9.eE+-]%f",voxsize);
+          std::sscanf(item," VY%*[^0-9.eE+-]%f",voxsize+1);
+          std::sscanf(item," VZ%*[^0-9.eE+-]%f",voxsize+2);
+        }
+        if (std::sscanf(item," CPU%*[ =]%s",tmp1)) out[7]=cimg::strncasecmp(tmp1,"sun",3)?0:1;
+        switch(std::sscanf(item," TYPE%*[ =]%s %s",tmp1,tmp2)) {
+        case 0: break;
+        case 2: out[5] = cimg::strncasecmp(tmp1,"unsigned",8)?1:0; std::strcpy(tmp1,tmp2);
+        case 1:
+          if (!cimg::strncasecmp(tmp1,"int",3)   || !cimg::strncasecmp(tmp1,"fixed",5))  out[4]=0;
+          if (!cimg::strncasecmp(tmp1,"float",5) || !cimg::strncasecmp(tmp1,"double",6)) out[4]=1;
+          if (!cimg::strncasecmp(tmp1,"packed",6))                                       out[4]=2;
+          if (out[4]>=0) break;
+        default: throw CImgIOException("cimg::inr_header_read() : Invalid TYPE '%s'",tmp2);
+        }
+      }
+      if(out[0]<0 || out[1]<0 || out[2]<0 || out[3]<0)
+        throw CImgIOException("CImg<%s>::load_inr() : Bad dimensions in .inr file = ( %d , %d , %d , %d )",
+                              pixel_type(),out[0],out[1],out[2],out[3]);
+      if(out[4]<0 || out[5]<0) throw CImgIOException("CImg<%s>::load_inr() : TYPE is not fully defined",pixel_type());
+      if(out[6]<0) throw CImgIOException("CImg<%s>::load_inr() : PIXSIZE is not fully defined",pixel_type());
+      if(out[7]<0) throw CImgIOException("CImg<%s>::load_inr() : Big/Little Endian coding type is not defined",pixel_type());
+    }
+    
+    static CImg load_inr(const char *filename, float *voxsize = NULL) {
+      std::FILE *file = cimg::fopen(filename,"rb");
+	  int fopt[8], endian=cimg::endian()?1:0;
+      bool loaded = false;
+      if (voxsize) voxsize[0]=voxsize[1]=voxsize[2]=1;
+      _load_inr(file,fopt,voxsize);
+      CImg<T> dest = CImg<T>(fopt[0],fopt[1],fopt[2],fopt[3]);
+      cimg_load_inr_case(0,0,8, unsigned char);
+      cimg_load_inr_case(0,1,8, char);
+      cimg_load_inr_case(0,0,16,unsigned short);
+      cimg_load_inr_case(0,1,16,short);
+      cimg_load_inr_case(0,0,32,unsigned int);
+      cimg_load_inr_case(0,1,32,int);
+      cimg_load_inr_case(1,0,32,float);
+      cimg_load_inr_case(1,1,32,float);
+      cimg_load_inr_case(1,0,64,double);
+      cimg_load_inr_case(1,1,64,double);
+      if (!loaded) throw CImgIOException("CImg<%s>::load_inr() : File '%s', can't read images of the type specified in the file",
+					 pixel_type(),filename);
+      cimg::fclose(file);
+      return dest;
+    }
+   
+    //! Load an image from a PANDORE file
+
+#define cimg_load_pandore_case(nid,nbdim,nwidth,nheight,ndepth,ndim,stype)  \
+  case nid: {                                                         \
+    cimg::fread(dims,sizeof(unsigned int),nbdim,file);                \
+    if (endian) cimg::endian_swap(dims,nbdim);                        \
+    dest = CImg<T>(nwidth,nheight,ndepth,ndim);                       \
+    stype *buffer = new stype[dest.size()];                           \
+    cimg::fread(buffer,sizeof(stype),dest.size(),file);               \
+    if (endian) cimg::endian_swap(buffer,dest.size());                \
+    T *ptrd = dest.ptr();                                             \
+    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));               \
+    buffer-=dest.size();                                              \
+    delete[] buffer;                                                  \
+   }                                                                  \
+   break;
+    
+    static CImg load_pandore(const char *filename) {
+      std::FILE *file = cimg::fopen(filename,"rb");
+      typedef unsigned char uchar;
+      typedef unsigned short ushort;
+      typedef unsigned int uint;  
+      typedef unsigned long ulong; 
+      CImg dest;
+      char tmp[16];
+      cimg::fread(tmp,sizeof(char),12,file);
+      if (cimg::strncasecmp("PANDORE",tmp,7)) 
+	throw CImgIOException("CImg<%s>::load_pandore() : File '%s' does not appear to be a valid PANDORE file.\n"
+			      "(PANDORE identifier not found)",pixel_type(),filename);
+      unsigned int id,dims[8];
+      long ptbuf[4];
+      cimg::fread(&id,sizeof(int),1,file);
+      const bool endian = (id>255);
+      if (endian) cimg::endian_swap(id);
+      cimg::fread(tmp,sizeof(char),20,file);
+      switch (id) {
+	cimg_load_pandore_case(2,2,dims[1],1,1,1,uchar);
+	cimg_load_pandore_case(3,2,dims[1],1,1,1,long);
+	cimg_load_pandore_case(4,2,dims[1],1,1,1,float);
+	cimg_load_pandore_case(5,3,dims[2],dims[1],1,1,uchar);
+	cimg_load_pandore_case(6,3,dims[2],dims[1],1,1,long);
+	cimg_load_pandore_case(7,3,dims[2],dims[1],1,1,float);
+	cimg_load_pandore_case(8,4,dims[3],dims[2],dims[1],1,uchar);
+	cimg_load_pandore_case(9,4,dims[3],dims[2],dims[1],1,long);
+	cimg_load_pandore_case(10,4,dims[3],dims[2],dims[1],1,float);
+      case 11: { // Region 1D
+	cimg::fread(dims,sizeof(unsigned int),3,file);
+	if (endian) cimg::endian_swap(dims,3);
+	dest = CImg<T>(dims[1],1,1,1);
+	if (dims[2]<256) {
+	  unsigned char *buffer = new unsigned char[dest.size()];
+	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
+	  T *ptrd = dest.ptr();
+	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	  buffer-=dest.size();
+	  delete[] buffer;
+	} else {
+	  if (dims[2]<65536) {
+	    unsigned short *buffer = new unsigned short[dest.size()];
+	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
+	    if (endian) cimg::endian_swap(buffer,dest.size());
+	    T *ptrd = dest.ptr();
+	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	    buffer-=dest.size();
+	    delete[] buffer;
+	  } else {
+	    unsigned long *buffer = new unsigned long[dest.size()];
+	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
+	    if (endian) cimg::endian_swap(buffer,dest.size());
+	    T *ptrd = dest.ptr();
+	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	    buffer-=dest.size();
+	    delete[] buffer;
+	  }
+	}	
+      }
+	break;
+      case 12: { // Region 2D
+	cimg::fread(dims,sizeof(unsigned int),4,file);
+	if (endian) cimg::endian_swap(dims,4);
+	dest = CImg<T>(dims[2],dims[1],1,1);
+	if (dims[3]<256) {
+	  unsigned char *buffer = new unsigned char[dest.size()];
+	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
+	  T *ptrd = dest.ptr();
+	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	  buffer-=dest.size();
+	  delete[] buffer;
+	} else {
+	  if (dims[3]<65536) {
+	    unsigned short *buffer = new unsigned short[dest.size()];
+	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
+	    if (endian) cimg::endian_swap(buffer,dest.size());
+	    T *ptrd = dest.ptr();
+	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	    buffer-=dest.size();
+	    delete[] buffer;
+	  } else {
+	    unsigned long *buffer = new unsigned long[dest.size()];
+	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
+	    if (endian) cimg::endian_swap(buffer,dest.size());
+	    T *ptrd = dest.ptr();
+	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	    buffer-=dest.size();
+	    delete[] buffer;
+	  }
+	}	
+      }
+	break;
+      case 13: { // Region 3D
+	cimg::fread(dims,sizeof(unsigned int),5,file);
+	if (endian) cimg::endian_swap(dims,5);
+	dest = CImg<T>(dims[3],dims[2],dims[1],1);
+	if (dims[4]<256) {
+	  unsigned char *buffer = new unsigned char[dest.size()];
+	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
+	  T *ptrd = dest.ptr();
+	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	  buffer-=dest.size();
+	  delete[] buffer;
+	} else {
+	  if (dims[4]<65536) {
+	    unsigned short *buffer = new unsigned short[dest.size()];
+	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
+	    if (endian) cimg::endian_swap(buffer,dest.size());
+	    T *ptrd = dest.ptr();
+	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	    buffer-=dest.size();
+	    delete[] buffer;
+	  } else {
+	    unsigned long *buffer = new unsigned long[dest.size()];
+	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
+	    if (endian) cimg::endian_swap(buffer,dest.size());
+	    T *ptrd = dest.ptr();
+	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
+	    buffer-=dest.size();
+	    delete[] buffer;
+	  }
+	}	
+      }
+	break;
+	cimg_load_pandore_case(16,4,dims[2],dims[1],1,3,uchar);
+	cimg_load_pandore_case(17,4,dims[2],dims[1],1,3,long);
+	cimg_load_pandore_case(18,4,dims[2],dims[1],1,3,float);
+	cimg_load_pandore_case(19,5,dims[3],dims[2],dims[1],3,uchar);
+	cimg_load_pandore_case(20,5,dims[3],dims[2],dims[1],3,long);
+	cimg_load_pandore_case(21,5,dims[3],dims[2],dims[1],3,float);
+	cimg_load_pandore_case(22,2,dims[1],1,1,dims[0],uchar);
+	cimg_load_pandore_case(23,2,dims[1],1,1,dims[0],long);
+	cimg_load_pandore_case(24,2,dims[1],1,1,dims[0],ulong);
+	cimg_load_pandore_case(25,2,dims[1],1,1,dims[0],float);
+	cimg_load_pandore_case(26,3,dims[2],dims[1],1,dims[0],uchar);
+	cimg_load_pandore_case(27,3,dims[2],dims[1],1,dims[0],long);
+	cimg_load_pandore_case(28,3,dims[2],dims[1],1,dims[0],ulong);
+	cimg_load_pandore_case(29,3,dims[2],dims[1],1,dims[0],float);
+	cimg_load_pandore_case(30,4,dims[3],dims[2],dims[1],dims[0],uchar);
+	cimg_load_pandore_case(31,4,dims[3],dims[2],dims[1],dims[0],long);
+	cimg_load_pandore_case(32,4,dims[3],dims[2],dims[1],dims[0],ulong);
+	cimg_load_pandore_case(33,4,dims[3],dims[2],dims[1],dims[0],float);	
+      case 34: // Points 1D	
+	cimg::fread(ptbuf,sizeof(long),1,file);
+	if (endian) cimg::endian_swap(ptbuf,1);
+	dest = CImg<T>(1); dest[0]=(T)ptbuf[0];
+	break;
+      case 35: // Points 2D
+	cimg::fread(ptbuf,sizeof(long),2,file);
+	if (endian) cimg::endian_swap(ptbuf,2);
+	dest = CImg<T>(2); dest[0]=(T)ptbuf[1]; dest[1]=(T)ptbuf[0];
+	break;
+      case 36: // Points 3D
+	cimg::fread(ptbuf,sizeof(long),3,file);
+	if (endian) cimg::endian_swap(ptbuf,3);
+	dest = CImg<T>(3); dest[0]=(T)ptbuf[2]; dest[1]=(T)ptbuf[1]; dest[2]=(T)ptbuf[0];
+	break;
+      default:
+	throw CImgIOException("CImg<%s>::load_pandore() : File '%s', can't read images with ID_type=%d",pixel_type(),filename,id);
+      }
+      return dest;
+    }
+
+
+    //! Load an image from an ANALYZE7.5 file
+    static CImg load_analyze(const char *filename, float *voxsize = NULL) {
+      
+      // Open header and data files
+      std::FILE *file_header=NULL, *file=NULL;
+      char body[1024];
+      const char *ext = cimg::filename_split(filename,body);
+      if (!cimg::strcasecmp(ext,"hdr") || !cimg::strcasecmp(ext,"img")) {
+	std::sprintf(body+cimg::strlen(body),".hdr");
+	file_header = cimg::fopen(body,"rb");
+	std::sprintf(body+cimg::strlen(body)-3,"img");
+	file = cimg::fopen(body,"rb");
+      } else throw CImgIOException("CImg<%s>::load_analyze() : Cannot load filename '%s' as an analyze format",pixel_type(),filename);
+
+      // Read header
+      bool endian = false;
+      unsigned int header_size;
+      cimg::fread(&header_size,sizeof(int),1,file_header);
+      if (header_size>=4096) { endian = true; cimg::endian_swap(header_size); }
+      unsigned char *header = new unsigned char[header_size];
+      cimg::fread(header+sizeof(int),sizeof(char),header_size-sizeof(int),file_header);
+      cimg::fclose(file_header);
+      if (endian) {
+	cimg::endian_swap((short*)(header+40),5);
+        cimg::endian_swap((short*)(header+70),1);
+        cimg::endian_swap((short*)(header+72),1);
+        cimg::endian_swap((float*)(header+76),4);
+        cimg::endian_swap((float*)(header+112),1);
+      }
+      unsigned short *dim = (unsigned short*)(header+40), dimx=1, dimy=1, dimz=1, dimv=1;
+      cimg::warn(!dim[0],"CImg<%s>::load_analyze() : Specified image has zero dimensions.",pixel_type());
+      cimg::warn(dim[0]>4,"CImg<%s>::load_analyze() : Number of image dimension is %d, reading only the 4 first dimensions",
+		 pixel_type(),dim[0]);
+      if (dim[0]>=1) dimx = dim[1];
+      if (dim[0]>=2) dimy = dim[2];
+      if (dim[0]>=3) dimz = dim[3];
+      if (dim[0]>=4) dimv = dim[4];
+      
+      float scalefactor = *(float*)(header+112); if (scalefactor==0) scalefactor=1;
+      const unsigned short datatype = *(short*)(header+70);
+      if (voxsize) { const float *vsize = (float*)(header+76); voxsize[0] = vsize[1]; voxsize[1] = vsize[2]; voxsize[2] = vsize[3]; }
+      delete[] header;
+
+      // Read pixel data
+      CImg dest(dimx,dimy,dimz,dimv);
+      switch (datatype) {
+      case 2: {
+	unsigned char *buffer = new unsigned char[dimx*dimy*dimz*dimv];
+	cimg::fread(buffer,sizeof(unsigned char),dimx*dimy*dimz*dimv,file);
+	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
+	delete[] buffer;
+      } break;
+      case 4: {
+	short *buffer = new short[dimx*dimy*dimz*dimv];
+	cimg::fread(buffer,sizeof(short),dimx*dimy*dimz*dimv,file);
+	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
+	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
+	delete[] buffer;
+      } break;
+      case 8: {
+	int *buffer = new int[dimx*dimy*dimz*dimv];
+	cimg::fread(buffer,sizeof(int),dimx*dimy*dimz*dimv,file);
+	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
+	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
+	delete[] buffer;
+      } break;
+      case 16: {
+	float *buffer = new float[dimx*dimy*dimz*dimv];
+	cimg::fread(buffer,sizeof(float),dimx*dimy*dimz*dimv,file);
+	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
+	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
+	delete[] buffer;
+      } break;
+      case 64: {
+	double *buffer = new double[dimx*dimy*dimz*dimv];
+	cimg::fread(buffer,sizeof(double),dimx*dimy*dimz*dimv,file);
+	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
+	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
+	delete[] buffer;
+      } break;
+      default: throw CImgIOException("CImg<%s>::load_analyze() : Cannot read images width 'datatype = %d'",pixel_type(),datatype);
+      }
+      cimg::fclose(file);
+      return dest;
+    }
+
+    //! Load an image from a RAW file
+    static CImg load_raw(const char *filename,const char axe='v',const char align='p') { 
+      return CImgl<T>(filename).get_append(axe,align); 
+    }
+
+    //! Function that loads the image for other file formats that are not natively handled by CImg, using the tool 'convert' from the ImageMagick package.\n
+    //! This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install the ImageMagick package in order to get
+    //! this function working properly (see http://www.imagemagick.org ).
+    static CImg load_convert(const char *filename) {
+      srand((unsigned int)::time(NULL));
+      char command[512], filetmp[512];
+      std::sprintf(filetmp,"%s/CImg%.4d.ppm",cimg::temporary_path(),::rand()%10000);
+      std::sprintf(command,"\"%s\" \"%s\" %s",cimg::convert_path(),filename,filetmp);
+      cimg::system(command);
+      std::FILE *file = std::fopen(filetmp,"rb");
+      if (!file) {
+        std::fclose(cimg::fopen(filename,"r"));
+        throw CImgIOException("CImg<%s>::load_convert() : Failed to open image '%s' with 'convert'.\n"
+			      "Check that you have installed the ImageMagick package in a standart directory.",
+			      pixel_type(),filename);
+      } else cimg::fclose(file);
+      const CImg dest(filetmp);
+      std::remove(filetmp);
+      return dest;
+    }
+
+
+    //! Save the image as a file. 
+    /**
+       The used file format is defined by the file extension in the filename \p filename.\n
+       Parameter \p number can be used to add a 6-digit number to the filename before saving.\n
+       If \p normalize is true, a normalized version of the image (between [0,255]) is saved.
+    **/
+    const CImg& save(const char *filename,const int number=-1) const {
+      cimg_test(*this,"CImg<T>::save");
+      const char *ext = cimg::filename_split(filename);
+      char nfilename[1024];
+      if (number>=0) filename = cimg::file_number(filename,number,6,nfilename);
+      if (!cimg::strcasecmp(ext,"asc")) return save_ascii(filename);
+      if (!cimg::strcasecmp(ext,"dlm")) return save_dlm(filename);
+      if (!cimg::strcasecmp(ext,"inr")) return save_inr(filename);
+      if (!cimg::strcasecmp(ext,"hdr")) return save_analyze(filename);
+      if (!cimg::strcasecmp(ext,"pan")) return save_pandore(filename);
+      if (!cimg::strcasecmp(ext,"bmp")) return save_bmp(filename);
+      if (!cimg::strcasecmp(ext,"raw") || ext[0]=='\0') return save_raw(filename);
+      if (!cimg::strcasecmp(ext,"pgm") || 
+	  !cimg::strcasecmp(ext,"ppm") || 
+	  !cimg::strcasecmp(ext,"pnm")) return save_pnm(filename);
+      return save_convert(filename);
+    }
+  
+    //! Save the image as an ASCII file.
+    const CImg& save_ascii(const char *filename) const {
+      cimg_test(*this,"CImg<T>::save_ascii");
+      std::FILE *file = cimg::fopen(filename,"w");
+      std::fprintf(file,"%u %u %u %u\n",width,height,depth,dim);
+      const T* ptrs = data;
+      cimg_mapYZV(*this,y,z,v) {
+	cimg_mapX(*this,x) std::fprintf(file,"%g ",(double)*(ptrs++));
+	std::fputc('\n',file);
+      }
+      cimg::fclose(file);
+      return *this;
+    }
+
+    //! Save the image as a DLM file.
+    const CImg& save_dlm(const char *filename) const {
+      cimg_test(*this,"CImg<T>::save_dlm");
+      std::FILE *file = cimg::fopen(filename,"w");
+      const T* ptrs = data;
+      cimg_mapYZV(*this,y,z,v) {
+	cimg_mapX(*this,x) std::fprintf(file,"%g%s",(double)*(ptrs++),(x==(int)width-1)?"":",");
+	std::fputc('\n',file);
+      }
+      cimg::fclose(file);
+      return *this;
+    }
+
+    //! Save the image as a PNM file.
+    const CImg& save_pnm(const char *filename) const {
+      cimg_test(*this,"CImg<T>::save_pnm");
+      const char *ext = cimg::filename_split(filename);
+      if (dim>1 && !cimg::strcasecmp(ext,"pgm")) { get_norm_pointwise().normalize(0,255).save_pnm(filename); return *this; }
+      std::FILE *file = cimg::fopen(filename,"wb");
+      const T 
+	*ptrR = ptr(0,0,0,0),
+	*ptrG = (dim>=2)?ptr(0,0,0,1):ptrR,
+	*ptrB = (dim>=3)?ptr(0,0,0,2):ptrR;
+      const unsigned int buf_size = width*height*(dim==1?1:3);
+      unsigned char *ptrd = new unsigned char[buf_size], *xptrd = ptrd;
+      switch(dim) {
+      case 1: { // Binary PGM
+	std::fprintf(file,"P5\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n255\n",width,height,depth,dim,width,height);
+	cimg_mapXY(*this,x,y) *(xptrd++) = (unsigned char)*(ptrR++);
+      } break;
+      default: { // Binary PPM
+	std::fprintf(file,"P6\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n255\n",width,height,depth,dim,width,height);
+	cimg_mapXY(*this,x,y) {
+	  *(xptrd++) = (unsigned char)*(ptrR++);
+	  *(xptrd++) = (unsigned char)*(ptrG++);
+	  *(xptrd++) = (unsigned char)*(ptrB++);
+	}
+      } break;
+      }
+      cimg::fwrite(ptrd,sizeof(unsigned char),buf_size,file);
+      cimg::fclose(file);
+      delete[] ptrd;
+      return *this;
+    }
+
+    //! Save the image as an ANALYZE7.5 file.
+    const CImg& save_analyze(const char *filename,const float *const voxsize=NULL) const {
+      cimg_test(*this,"CImg<T>::save_analyze");
+      std::FILE *file;
+      char header[348],hname[1024],iname[1024];
+      const char *ext = cimg::filename_split(filename);
+      short datatype=-1;
+      std::memset(header,0,348);
+      if (!ext[0]) { std::sprintf(hname,"%s.hdr",filename); std::sprintf(iname,"%s.img",filename); }
+      if (!cimg::strncasecmp(ext,"hdr",3)) { 
+	std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(iname+cimg::strlen(iname)-3,"img"); 
+      }
+      if (!cimg::strncasecmp(ext,"img",3)) {
+	std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(hname+cimg::strlen(iname)-3,"hdr"); 
+      }
+      ((int*)(header))[0] = 348;
+      std::sprintf(header+4,"CImg");
+      std::sprintf(header+14," ");
+      ((short*)(header+36))[0] = 4096;
+      ((char*)(header+38))[0] = 114;
+      ((short*)(header+40))[0] = 4;
+      ((short*)(header+40))[1] = width;
+      ((short*)(header+40))[2] = height;
+      ((short*)(header+40))[3] = depth;
+      ((short*)(header+40))[4] = dim;
+      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  datatype = 2;
+      if (!cimg::strcasecmp(pixel_type(),"short"))          datatype = 4;
+      if (!cimg::strcasecmp(pixel_type(),"int"))            datatype = 8;
+      if (!cimg::strcasecmp(pixel_type(),"float"))          datatype = 16;
+      if (!cimg::strcasecmp(pixel_type(),"double"))         datatype = 64;
+      ((short*)(header+70))[0] = datatype;
+      ((short*)(header+72))[0] = sizeof(T);
+      ((float*)(header+112))[0] = 1;
+      ((float*)(header+76))[0] = 0;
+      if (voxsize) {
+        ((float*)(header+76))[1] = voxsize[0];
+        ((float*)(header+76))[2] = voxsize[1];
+        ((float*)(header+76))[3] = voxsize[2];
+      } else ((float*)(header+76))[1] = ((float*)(header+76))[2] = ((float*)(header+76))[3] = 1;
+      file = cimg::fopen(hname,"wb");
+      cimg::fwrite(header,sizeof(char),348,file);
+      cimg::fclose(file);
+      file = cimg::fopen(iname,"wb");
+      cimg::fwrite(data,sizeof(T),size(),file);
+      cimg::fclose(file);
+      return *this;
+    }
+
+    //! Save the image as a RAW file
+    const CImg& save_raw(const char *filename) const {
+      cimg_test(*this,"CImg<T>::save_raw");      
+      CImgl<T> shared(1);
+      shared[0].width = width;
+      shared[0].height = height;
+      shared[0].depth = depth;
+      shared[0].dim = dim;
+      shared[0].data = data;
+      shared.save_raw(filename);
+      shared[0].width = shared[0].height = shared[0].depth = shared[0].dim = 0;
+      shared[0].data = NULL;
+      return *this;
+    }
+ 
+    //! Save the image using ImageMagick's convert.    
+    /** Function that saves the image for other file formats that are not natively handled by CImg,
+	using the tool 'convert' from the ImageMagick package.\n
+	This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install 
+	the ImageMagick package in order to get
+	this function working properly (see http://www.imagemagick.org ).
+    **/
+    const CImg& save_convert(const char *filename) const {
+      cimg_test(*this,"CImg<T>::save_convert");
+      srand((unsigned int)::time(NULL));
+      char command[512],filetmp[512];
+      std::sprintf(filetmp,"%s/CImg%.4d.ppm",cimg::temporary_path(),::rand()%10000);
+      save_pnm(filetmp);
+      std::sprintf(command,"\"%s\" -quality 100%% \"%s\" %s",cimg::convert_path(),filetmp,filename);
+      cimg::system(command);
+      std::FILE *file = std::fopen(filename,"rb");
+      if (!file) throw CImgIOException("CImg<%s>::save_convert() : Failed to save image '%s' with 'convert'.\n"
+				       "Check that you have installed the ImageMagick package in a standart directory.",
+				       pixel_type(),filename);
+      if (file) cimg::fclose(file);
+      std::remove(filetmp);
+      return *this;
+    }
+  
+    //! Save the image as an INRIMAGE-4 file.
+    const CImg& save_inr(const char *filename,const float *const voxsize = NULL) const {
+      cimg_test(*this,"CImg<T>::save_inr");
+      int inrpixsize=-1;
+      const char *inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0";
+      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  { inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
+      if (!cimg::strcasecmp(pixel_type(),"char"))           { inrtype = "fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
+      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) { inrtype = "unsigned fixed\nPIXSIZE=16 bits\nSCALE=2**0";inrpixsize = 2; }
+      if (!cimg::strcasecmp(pixel_type(),"short"))          { inrtype = "fixed\nPIXSIZE=16 bits\nSCALE=2**0"; inrpixsize = 2; }
+      if (!cimg::strcasecmp(pixel_type(),"unsigned int"))   { inrtype = "unsigned fixed\nPIXSIZE=32 bits\nSCALE=2**0";inrpixsize = 4; }
+      if (!cimg::strcasecmp(pixel_type(),"int"))            { inrtype = "fixed\nPIXSIZE=32 bits\nSCALE=2**0"; inrpixsize = 4; }
+      if (!cimg::strcasecmp(pixel_type(),"float"))          { inrtype = "float\nPIXSIZE=32 bits"; inrpixsize = 4; }
+      if (!cimg::strcasecmp(pixel_type(),"double"))         { inrtype = "float\nPIXSIZE=64 bits"; inrpixsize = 8; }
+      if (inrpixsize<=0) throw CImgIOException("CImg<%s>::save_inr() : Don't know how to save images of '%s'",pixel_type(),pixel_type());
+      std::FILE *file = cimg::fopen(filename,"wb");
+      char header[257];      
+      int err = std::sprintf(header,"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",width,height,depth,dim);
+      if (voxsize) err += std::sprintf(header+err,"VX=%g\nVY=%g\nVZ=%g\n",voxsize[0],voxsize[1],voxsize[2]);
+      err += std::sprintf(header+err,"TYPE=%s\nCPU=%s\n",inrtype,cimg::endian()?"sun":"decm");
+      std::memset(header+err,'\n',252-err);
+      std::memcpy(header+252,"##}\n",4);
+      cimg::fwrite(header,sizeof(char),256,file);
+      cimg_mapXYZ(*this,x,y,z) cimg_mapV(*this,k) cimg::fwrite(&((*this)(x,y,z,k)),inrpixsize,1,file);
+      cimg::fclose(file);
+      return *this;
+    }
+
+    //! Save the image as a PANDORE-5 file
+
+#define cimg_save_pandore_case(sy,sz,sv,stype,id)                           \
+   if (!saved && (sy?(sy==height):true) && (sz?(sz==depth):true) && (sv?(sv==dim):true) && !strcmp(stype,pixel_type())) { \
+      unsigned int *iheader = (unsigned int*)(header+12);                   \
+      nbdims = _save_pandore_header_length((*iheader=id),dims);             \
+      cimg::fwrite(header,sizeof(unsigned char),36,file);                   \
+      cimg::fwrite(dims,sizeof(unsigned int),nbdims,file);                  \
+      if (id==2 || id==5 || id==8 || id==16 || id==19 || id==22 || id==26 || id==30) { \
+	unsigned char *buffer = new unsigned char[size()];                  \
+	T *ptrs = ptr();                                                    \
+	cimg_mapoff(*this,off) *(buffer++)=(unsigned char)(*(ptrs++));      \
+	buffer-=size();                                                     \
+	cimg::fwrite(buffer,sizeof(unsigned char),size(),file);             \
+	delete[] buffer;                                                    \
+      }                                                                     \
+      if (id==3 || id==6 || id==9 || id==17 || id==20 || id==23 || id==27 || id==31) { \
+	unsigned long *buffer = new unsigned long[size()];                  \
+	T *ptrs = ptr();                                                    \
+	cimg_mapoff(*this,off) *(buffer++)=(long)(*(ptrs++));               \
+	buffer-=size();                                                     \
+	cimg::fwrite(buffer,sizeof(long),size(),file);                      \
+	delete[] buffer;                                                    \
+      }                                                                     \
+      if (id==4 || id==7 || id==10 || id==18 || id==21 || id==25 || id==29 || id==33) { \
+	float *buffer = new float[size()];                                  \
+	T *ptrs = ptr();                                                    \
+	cimg_mapoff(*this,off) *(buffer++)=(float)(*(ptrs++));              \
+	buffer-=size();                                                     \
+	cimg::fwrite(buffer,sizeof(float),size(),file);                     \
+	delete[] buffer;                                                    \
+      }                                                                     \
+      saved = true;                                                         \
+    }
+
+    unsigned int _save_pandore_header_length(unsigned int id,unsigned int *dims) const {
+      unsigned int nbdims=0;
+      if (id==2 || id==3 || id==4)    { dims[0]=1; dims[1]=width; nbdims=2; }
+      if (id==5 || id==6 || id==7)    { dims[0]=1; dims[1]=height; dims[2]=width; nbdims=3; }
+      if (id==8 || id==9 || id==10)   { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
+      if (id==16 || id==17 || id==18) { dims[0]=3; dims[1]=height; dims[2]=width; dims[3]=1; nbdims=4; }
+      if (id==19 || id==20 || id==21) { dims[0]=3; dims[1]=depth; dims[2]=height; dims[3]=width; dims[4]=0; nbdims=5; }
+      if (id==22 || id==23 || id==25) { dims[0]=dim; dims[1]=width; nbdims=2; }
+      if (id==26 || id==27 || id==29) { dims[0]=dim; dims[1]=height; dims[2]=width; nbdims=3; }
+      if (id==30 || id==31 || id==33) { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
+      return nbdims;
+    }    
+
+    const CImg& save_pandore(const char* filename) const {
+      cimg_test(*this,"CImg<T>::save_pandore");
+      std::FILE *file = cimg::fopen(filename,"wb");
+      unsigned char header[36] = { 'P','A','N','D','O','R','E','0','4',0,0,0,
+				   0,0,0,0,'C','I','m','g',0,0,0,0,0,
+				   '2','0','0','0','/','0','1','/','0','1',
+				   0 };
+      unsigned int nbdims,dims[5];
+      bool saved=false;
+      cimg_save_pandore_case(1,1,1,"unsigned char",2);
+      cimg_save_pandore_case(1,1,1,"char",3);
+      cimg_save_pandore_case(1,1,1,"short",3);
+      cimg_save_pandore_case(1,1,1,"unsigned short",3);
+      cimg_save_pandore_case(1,1,1,"unsigned int",3);
+      cimg_save_pandore_case(1,1,1,"int",3);
+      cimg_save_pandore_case(1,1,1,"unsigned long",4);
+      cimg_save_pandore_case(1,1,1,"long",3);
+      cimg_save_pandore_case(1,1,1,"float",4);
+      cimg_save_pandore_case(1,1,1,"double",4);
+ 
+      cimg_save_pandore_case(0,1,1,"unsigned char",5);
+      cimg_save_pandore_case(0,1,1,"char",6);
+      cimg_save_pandore_case(0,1,1,"short",6);
+      cimg_save_pandore_case(0,1,1,"unsigned short",6);
+      cimg_save_pandore_case(0,1,1,"unsigned int",6);
+      cimg_save_pandore_case(0,1,1,"int",6);
+      cimg_save_pandore_case(0,1,1,"unsigned long",7);
+      cimg_save_pandore_case(0,1,1,"long",6);
+      cimg_save_pandore_case(0,1,1,"float",7);
+      cimg_save_pandore_case(0,1,1,"double",7);
+
+      cimg_save_pandore_case(0,0,1,"unsigned char",8);
+      cimg_save_pandore_case(0,0,1,"char",9);
+      cimg_save_pandore_case(0,0,1,"short",9);
+      cimg_save_pandore_case(0,0,1,"unsigned short",9);
+      cimg_save_pandore_case(0,0,1,"unsigned int",9);
+      cimg_save_pandore_case(0,0,1,"int",9);
+      cimg_save_pandore_case(0,0,1,"unsigned long",10);
+      cimg_save_pandore_case(0,0,1,"long",9);
+      cimg_save_pandore_case(0,0,1,"float",10);
+      cimg_save_pandore_case(0,0,1,"double",10);
+      
+      cimg_save_pandore_case(0,1,3,"unsigned char",16);
+      cimg_save_pandore_case(0,1,3,"char",17);
+      cimg_save_pandore_case(0,1,3,"short",17);
+      cimg_save_pandore_case(0,1,3,"unsigned short",17);
+      cimg_save_pandore_case(0,1,3,"unsigned int",17);
+      cimg_save_pandore_case(0,1,3,"int",17);
+      cimg_save_pandore_case(0,1,3,"unsigned long",18);
+      cimg_save_pandore_case(0,1,3,"long",17);
+      cimg_save_pandore_case(0,1,3,"float",18);
+      cimg_save_pandore_case(0,1,3,"double",18);
+
+      cimg_save_pandore_case(0,0,3,"unsigned char",19);
+      cimg_save_pandore_case(0,0,3,"char",20);
+      cimg_save_pandore_case(0,0,3,"short",20);
+      cimg_save_pandore_case(0,0,3,"unsigned short",20);
+      cimg_save_pandore_case(0,0,3,"unsigned int",20);
+      cimg_save_pandore_case(0,0,3,"int",20);
+      cimg_save_pandore_case(0,0,3,"unsigned long",21);
+      cimg_save_pandore_case(0,0,3,"long",20);
+      cimg_save_pandore_case(0,0,3,"float",21);
+      cimg_save_pandore_case(0,0,3,"double",21);
+     
+      cimg_save_pandore_case(1,1,0,"unsigned char",22);
+      cimg_save_pandore_case(1,1,0,"char",23);
+      cimg_save_pandore_case(1,1,0,"short",23);
+      cimg_save_pandore_case(1,1,0,"unsigned short",23);
+      cimg_save_pandore_case(1,1,0,"unsigned int",23);
+      cimg_save_pandore_case(1,1,0,"int",23);
+      cimg_save_pandore_case(1,1,0,"unsigned long",25);
+      cimg_save_pandore_case(1,1,0,"long",23);
+      cimg_save_pandore_case(1,1,0,"float",25);
+      cimg_save_pandore_case(1,1,0,"double",25);
+ 
+      cimg_save_pandore_case(0,1,0,"unsigned char",26);
+      cimg_save_pandore_case(0,1,0,"char",27);
+      cimg_save_pandore_case(0,1,0,"short",27);
+      cimg_save_pandore_case(0,1,0,"unsigned short",27);
+      cimg_save_pandore_case(0,1,0,"unsigned int",27);
+      cimg_save_pandore_case(0,1,0,"int",27);
+      cimg_save_pandore_case(0,1,0,"unsigned long",29);
+      cimg_save_pandore_case(0,1,0,"long",27);
+      cimg_save_pandore_case(0,1,0,"float",29);
+      cimg_save_pandore_case(0,1,0,"double",29);
+
+      cimg_save_pandore_case(0,0,0,"unsigned char",30);
+      cimg_save_pandore_case(0,0,0,"char",31);
+      cimg_save_pandore_case(0,0,0,"short",31);
+      cimg_save_pandore_case(0,0,0,"unsigned short",31);
+      cimg_save_pandore_case(0,0,0,"unsigned int",31);
+      cimg_save_pandore_case(0,0,0,"int",31);
+      cimg_save_pandore_case(0,0,0,"unsigned long",33);
+      cimg_save_pandore_case(0,0,0,"long",31);
+      cimg_save_pandore_case(0,0,0,"float",33);
+      cimg_save_pandore_case(0,0,0,"double",33);
+
+      cimg::fclose(file);
+      return *this;
+    }
+
+    //! Save the image as a BMP file
+    const CImg& save_bmp(const char* filename) const {
+      cimg_test(*this,"CImg<T>::save_bmp");
+      std::FILE *file = cimg::fopen(filename,"wb");
+
+      unsigned char header[54]={0}, align_buf[4]={0};
+      const unsigned int 
+	align     = (4-(3*width)%4)%4,
+	buf_size  = (3*width+align)*dimy(),
+	file_size = 54+buf_size;
+      header[0] = 'B'; header[1] = 'M';
+      header[0x02]=file_size&0xFF; header[0x03]=(file_size>>8)&0xFF;
+      header[0x04]=(file_size>>16)&0xFF; header[0x05]=(file_size>>24)&0xFF;
+      header[0x0A]=0x36;
+      header[0x0E]=0x28;
+      header[0x12]=width&0xFF; header[0x13]=(width>>8)&0xFF;
+      header[0x14]=(width>>16)&0xFF; header[0x15]=(width>>24)&0xFF;
+      header[0x16]=height&0xFF; header[0x17]=(height>>8)&0xFF;
+      header[0x18]=(height>>16)&0xFF; header[0x19]=(height>>24)&0xFF;
+      header[0x1A]=1;  header[0x1B]=0;
+      header[0x1C]=24; header[0x1D]=0;
+      header[0x22]=buf_size&0xFF; header[0x23]=(buf_size>>8)&0xFF;
+      header[0x24]=(buf_size>>16)&0xFF; header[0x25]=(buf_size>>24)&0xFF;
+      header[0x27]=0x1; header[0x2B]=0x1;
+      cimg::fwrite(header,sizeof(unsigned char),54,file);
+
+      const T
+	*pR = ptr(0,height-1,0,0),
+	*pG = (dim>=2)?ptr(0,height-1,0,1):pR, 
+	*pB = (dim>=3)?ptr(0,height-1,0,2):pR;
+
+      cimg_mapY(*this,y) {
+	cimg_mapX(*this,x) {
+	  std::fputc((unsigned char)(*(pB++)),file);
+	  std::fputc((unsigned char)(*(pG++)),file);
+	  std::fputc((unsigned char)(*(pR++)),file);
+	}
+	std::fwrite(align_buf,sizeof(unsigned char),align,file);
+	pR-=2*width; pG-=2*width; pB-=2*width;	
+      }      
+      cimg::fclose(file);
+      return *this;
+    }
+
+    
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Other functions
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+    CImg& swap(CImg& img) {
+      cimg::swap(width,img.width);
+      cimg::swap(height,img.height);
+      cimg::swap(depth,img.depth);
+      cimg::swap(dim,img.dim);
+      cimg::swap(data,img.data);
+      return img;
+    }
+
+#ifdef cimg_plugin
+#include cimg_plugin
+#endif
+    
+    //@}
+  };
+
+
+  /*-------------------------------------------------------
+    
+
+
+
+  Definition of the CImgl<> structure
+
+
+
+
+  ------------------------------------------------------*/
+
+  //! This class represents list of images CImg<T>.
+  template<typename T> struct CImgl {       
+    //! This variable represents the number of images in the image list.
+    /**
+       \note if \c size==0, the image list is empty.
+    **/
+    unsigned int size;
+    
+    //! This variable represents a pointer to the first \c CImg<T> image of the list.
+    /**
+       \note the images are stored continuously in memory.
+       \note If the list is empty, \c data=NULL.
+    **/
+    CImg<T> *data;                      //!< Pointer to the first image of the image list.
+    
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Constructors - Destructor - Copy
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+    
+    //! Return a string describing the type of the image pixels in the list (template parameter \p T).
+    static const char* pixel_type() { T val; return cimg::get_type(val); }
+    
+    //! Create a list of \p n new images, each having size (\p width,\p height,\p depth,\p dim).
+    CImgl(const unsigned int n=0,const unsigned int width=0,const unsigned int height=1,
+	  const unsigned int depth=1, const unsigned int dim=1):size(n) {
+      if (n) {
+	data = new CImg<T>[(n/cimg::lblock+1)*cimg::lblock];
+	cimgl_map(*this,l) data[l]=CImg<T>(width,height,depth,dim);
+      } else data = NULL;
+    }
+    
+    // ! Create a list of \p n copy of the input image.
+    template<typename t> CImgl(const unsigned int n, const CImg<t>& img):size(n) {
+      if (n) {
+	data = new CImg<T>[(n/cimg::lblock+1)*cimg::lblock];
+	cimgl_map(*this,l) data[l]=img;
+      } else data = NULL;
+    }
+    
+    //! Copy constructor.
+    template<typename t> CImgl(const CImgl<t>& list):size(list.size) {
+      if (size) {
+	data = new CImg<T>[(size/cimg::lblock+1)*cimg::lblock];
+	cimgl_map(*this,l) data[l] = list[l];
+      } else data = NULL;
+    }
+    CImgl(const CImgl<T>& list):size(list.size) {
+      if (size>0) {
+	data = new CImg<T>[(size/cimg::lblock+1)*cimg::lblock];
+	cimgl_map(*this,l) data[l] = list[l];
+      } else data = NULL;
+    }
+
+    //! Create a list by loading a file.
+    CImgl(const char* filename):size(0),data(NULL) { load(filename).swap(*this); }
+    
+    //! Create a list from a single image \p img.
+    CImgl(const CImg<T>& img):size(0),data(NULL) { CImgl<T>(1,img).swap(*this); }
+
+    //! Create a list from two images \p img1 and \p img2 (images are copied).
+    CImgl(const CImg<T>& img1,const CImg<T>& img2):size(2) {
+      data = new CImg<T>[cimg::lblock];
+      data[0] = img1;
+      data[1] = img2;
+    }
+
+    //! Create a list from three images \p img1,\p img2 and \p img3 (images are copied).
+    CImgl(const CImg<T>& img1,const CImg<T>& img2,const CImg<T>& img3):size(3) {
+      data = new CImg<T>[cimg::lblock];
+      data[0] = img1;
+      data[1] = img2;
+      data[2] = img3;
+    }
+
+    //! Create a list from four images \p img1,\p img2,\p img3 and \p img4 (images are copied).
+    CImgl(const CImg<T>& img1,const CImg<T>& img2,const CImg<T>& img3,const CImg<T>& img4):size(4) {
+      data = new CImg<T>[cimg::lblock];
+      data[0] = img1;
+      data[1] = img2;
+      data[2] = img3;
+      data[3] = img4;
+    }
+    
+    //! Copy a list into another one.
+    template<typename t> CImgl& operator=(const CImgl<t>& list) { return CImgl<T>(list).swap(*this); }
+    CImgl& operator=(const CImgl<T>& list) { if (&list==this) return *this; return CImgl<T>(list).swap(*this); }
+    
+    //! Destructor
+    ~CImgl() { if (data) delete[] data; }
+    
+    //! Empty list
+    CImgl& empty() { return CImgl<T>().swap(*this); }
+    
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name Arithmetics operators
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+    
+    //! Add each image of the current list with the corresponding image in the list \p list.
+    template<typename t> CImgl& operator+=(const CImgl<t>& list) {
+      const unsigned int sizemax = min(size,list.size);
+      for (unsigned int l=0; l<sizemax; l++) (*this)[l]+=list[l];
+      return *this;
+    }
+    
+    //! Subtract each image of the current list with the corresponding image in the list \p list.
+    template<typename t> CImgl& operator-=(const CImgl<t>& list) {
+      const unsigned int sizemax = min(size,list.size);
+      for (unsigned int l=0; l<sizemax; l++) (*this)[l]-=list[l];
+      return *this;
+    }
+    
+    //! Add each image of the current list with a value \p val.
+    CImgl& operator+=(const T& val) { cimgl_map(*this,l) (*this)[l]+=val; return *this; }
+    
+    //! Substract each image of the current list with a value \p val.
+    CImgl& operator-=(const T& val) { cimgl_map(*this,l) (*this)[l]-=val; return *this; }
+    
+    //! Multiply each image of the current list by a value \p val.
+    CImgl& operator*=(const double val) { cimgl_map(*this,l) (*this)[l]*=val; return *this; }
+    
+    //! Divide each image of the current list by a value \p val.
+    CImgl& operator/=(const double val) { cimgl_map(*this,l) (*this)[l]/=val; return *this; }
+    
+    //! Return a new image list corresponding to the addition of each image of the current list with a value \p val.
+    CImgl operator+(const T& val) const { return CImgl<T>(*this)+=val;  }
+    
+    //! Return a new image list corresponding to the multiplication of each image of the current list by a value \p val.
+    CImgl operator*(const double val) const { return CImgl<T>(*this)*=val;  }
+    
+    //! Return a new image list corresponding to the substraction of each image of the current list with a value \p val.
+    CImgl operator-(const T& val) const { return CImgl<T>(*this)-=val;  }
+    
+    //! Return a new image list corresponding to the division of each image of the current list by a value \p val.
+    CImgl operator/(const double val) const { return CImgl<T>(*this)/=val;  }
+    
+    //! Return a new image list corresponding to the addition of each image of the current list with the corresponding image in the list \p list.
+    CImgl operator+(const CImgl& list) const { return CImgl<T>(*this)+=list; }
+
+    //! Return a new image list corresponding to the substraction of each image of the current list with the corresponding image in the list \p list.
+    CImgl operator-(const CImgl& list) const { return CImgl<T>(*this)-=list; }
+    
+    //! Return a new image list corresponding to the addition of each image of the current list with a value \p val;
+    friend CImgl operator+(const T& val, const CImgl& list) { return CImgl<T>(list)+=val; }
+    
+    //! Return a new image list corresponding to the scalar multiplication of each image of the current list by a value \p val.
+    friend CImgl operator*(const double val, const CImgl& list) { return CImgl<T>(list)*=val; }
+  
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name List operations
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+    
+    //! Return a reference to the i-th element of the image list.
+    CImg<T>& operator[](const unsigned int pos) const {
+#if cimg_debug>1
+      if (pos>=size) {
+	cimg::warn(true,"CImgl<%s>::operator[] : bad list position %u, in a list of %u images",pixel_type(),pos,size);
+	return *data;
+      }
+#endif
+      return data[pos];
+    }
+    
+    //! Equivalent to CImgl<T>::operator[]
+    CImg<T>& operator()(const unsigned int pos) const { return (*this)[pos]; }
+    
+    //! Insert a copy of the image \p img into the current image list, at position \p pos.
+    CImgl& insert(const CImg<T>& img,const unsigned int pos) {
+      if (pos>size) throw CImgArgumentException("CImgl<%s>::insert() : Can't insert at position %u into a list with %u elements",pixel_type(),pos,size);
+      CImg<T> *new_data = (!((++size)%cimg::lblock) || !data)?new CImg<T>[(size/cimg::lblock+1)*cimg::lblock]:NULL;
+      if (!data) { data=new_data; *data=img; }
+      else {
+	if (new_data) {
+	  std::memcpy(new_data,data,sizeof(CImg<T>)*pos);
+	  if (pos!=size-1) std::memcpy(new_data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
+	  std::memset(data,0,sizeof(CImg<T>)*(size-1));
+	  delete[] data;
+	  data = new_data;
+	}
+	else if (pos!=size-1) memmove(data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
+	data[pos].data = NULL;
+	data[pos] = img;
+      }
+      return *this;
+    }
+    
+    //! Append a copy of the image \p img at the current image list.
+    CImgl& insert(const CImg<T>& img) { return insert(img,size); }
+    
+    //! Insert a copy of the image list \p list into the current image list, starting from position \p pos.
+    CImgl& insert(const CImgl<T>& list,const unsigned int pos) { cimgl_map(list,l) insert(list[l],pos+l); return *this; }
+    
+    //! Append a copy of the image list \p list at the current image list.
+    CImgl& insert(const CImgl<T>& list) { return insert(list,size); }
+    
+    //! Remove the image at position \p pos from the image list.
+    CImgl& remove(const unsigned int pos) {
+      if (pos>=size) { 
+	cimg::warn(true,"CImgl<%s>::remove() : Can't remove an image from a list (%p,%u), at position %u",pixel_type(),data,size,pos);
+	return *this;
+      }
+      CImg<T> tmp; tmp.swap(data[pos]); // the image to remove will be freed
+      size--;
+      if (pos!=size) { 
+	memmove(data+pos,data+pos+1,sizeof(CImg<T>)*(size-pos));
+	CImg<T> &tmp = data[size];
+	tmp.width = tmp.height = tmp.depth = tmp.dim = 0;
+	tmp.data = NULL;
+      }
+      return *this;
+    }
+
+    //! Remove the last image from the image list.
+    CImgl& remove() { return remove(size); }  
+
+    //! Reverse list order
+    CImgl& reverse() {
+      for (unsigned int l=0; l<size/2; l++) (*this)[l].swap((*this)[size-1-l]);
+      return *this;
+    }
+    
+    CImgl& get_reverse() { return CImgl<T>(*this).reverse(); }
+    
+    //@}
+    //------------------------------------------
+    //------------------------------------------
+    //
+    //! \name IO and display functions
+    //@{
+    //------------------------------------------
+    //------------------------------------------
+    
+    //! Print informations about the list on the standart error stream.
+    const CImgl& print(const char* title=NULL,const int print_flag=1) const { 
+      char tmp[1024];
+      std::fprintf(stderr,"%-8s(%p) : (%u,%p)\n",title?title:"CImgl",(void*)this,size,(void*)data);
+      if (print_flag>0)	cimgl_map(*this,l) {
+	std::sprintf(tmp,"%s[%d]",title?title:"CImgl",l);
+	data[l].print(tmp,print_flag);
+      }
+      return *this;
+    }
+    //! Load an image list from a file (.raw format).
+
+#define cimg_load_raw_case(Ts,Tss)					 	 \
+  if (!loaded && !cimg::strcasecmp(Ts,tmp2)) for (unsigned int l=0; l<n; l++) {  \
+      Tss *buf;                                                         \
+      const bool endian = cimg::endian();                               \
+      j=0; while((i=fgetc(file))!='\n') tmp[j++]=(char)i; tmp[j]='\0';  \
+      std::sscanf(tmp,"%u %u %u %u",&w,&h,&z,&k);                       \
+      buf = new Tss[w*h*z*k]; cimg::fread(buf,sizeof(Tss),w*h*z*k,file);\
+      if (endian) cimg::endian_swap(buf,w*h*z*k);	   	        \
+      CImg<T> idest(w,h,z,k); cimg_mapoff(idest,off)                    \
+                        idest[off] = (T)(buf[off]); idest.swap(res[l]); \
+      delete[] buf;                                                     \
+      loaded = true;                                                    \
+    }
+
+    static CImgl load_raw(const char *filename) {
+      typedef unsigned char uchar;
+      typedef unsigned short ushort;
+      typedef unsigned int uint;  
+      typedef unsigned long ulong; 
+      std::FILE *file = cimg::fopen(filename,"rb");
+      char tmp[256],tmp2[256];
+      int i;
+      bool loaded = false;
+      unsigned int n,j,w,h,z,k,err;
+      j=0; while((i=fgetc(file))!='\n' && i!=EOF) tmp[j++]=i; tmp[j]='\0';
+      err=std::sscanf(tmp,"%u#%255[A-Za-z ]",&n,tmp2);
+      if (err!=2) throw CImgIOException("CImgl<%s>::load_raw() : file '%s', Unknow .raw header",pixel_type(),filename);
+      CImgl<T> res(n);
+      cimg_load_raw_case("unsigned char",uchar);
+      cimg_load_raw_case("uchar",uchar);
+      cimg_load_raw_case("char",char);
+      cimg_load_raw_case("unsigned short",ushort);
+      cimg_load_raw_case("ushort",ushort);
+      cimg_load_raw_case("short",short);
+      cimg_load_raw_case("unsigned int",uint);
+      cimg_load_raw_case("uint",uint);
+      cimg_load_raw_case("int",int);
+      cimg_load_raw_case("unsigned long",ulong);
+      cimg_load_raw_case("ulong",ulong);
+      cimg_load_raw_case("long",long);
+      cimg_load_raw_case("float",float);
+      cimg_load_raw_case("double",double);
+      if (!loaded) throw CImgIOException("CImgl<%s>::load_raw() : file '%s', can't read images of %s",pixel_type(),filename,tmp2);
+      cimg::fclose(file);
+      return res;
+    }
+
+    //! Load an image list from a file. The file should be a '.raw' format, else only one image will be loaded into the list.
+    static CImgl load(const char *filename) {
+      CImgl res;
+      const char *ext = cimg::filename_split(filename);
+      if (!cimg::strcasecmp(ext,"raw") || !ext[0]) return load_raw(filename); else return CImg<T>(filename);
+    }
+
+
+    //! Save an image list into a file.
+    /**
+       Depending on the extension of the given filename, a file format is chosen for the output file.       
+    **/    
+    const CImgl& save(const char *filename) const {
+      cimgl_test(*this,"CImgl<T>::save");
+      const char *ext = cimg::filename_split(filename);
+      if (!cimg::strcasecmp(ext,"raw") || !ext[0]) return save_raw(filename);
+      else {
+	if (size==1) data[0].save(filename,-1);
+	else cimgl_map(*this,l) data[l].save(filename,l);
+      }
+      return *this;
+    }
+
+    //! Save an image list into a RAW file.
+    /**
+       A RAW file is a simple uncompressed binary file that may be used to save list of CImg<T> images.
+       \param filename : name of the output file.
+       \return A reference to the current CImgl instance is returned.
+    **/
+    const CImgl& save_raw(const char *filename) const {
+      cimgl_test(*this,"CImgl<T>::save_raw");
+      std::FILE *file = cimg::fopen(filename,"wb");
+      std::fprintf(file,"%u#%s\n",size,pixel_type());
+      cimgl_map(*this,l) {
+	const CImg<T>& img = data[l];
+	std::fprintf(file,"%u %u %u %u\n",img.width,img.height,img.depth,img.dim);
+	if (cimg::endian()) {
+	  CImg<T> tmp(img);
+	  cimg::endian_swap(tmp.data,tmp.size());
+	  cimg::fwrite(tmp.data,sizeof(T),img.width*img.height*img.depth*img.dim,file);
+	} else cimg::fwrite(img.data,sizeof(T),img.width*img.height*img.depth*img.dim,file);
+      }
+      cimg::fclose(file);
+      return *this;
+    }    
+
+    //! Return a single image which is the concatenation of all images of the current CImgl instance.
+    /**
+       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
+       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
+       \return A CImg<T> image corresponding to the concatenation is returned.
+    **/
+    CImg<T> get_append(const char axe='x',const char align='c') const {
+      cimgl_test(*this,"CImgl<T>::get_append");
+      unsigned int dx=0,dy=0,dz=0,dv=0,pos=0;
+      CImg<T> res;
+      switch(cimg::uncase(axe)) {
+      case 'x': {
+	cimgl_map(*this,l) {
+	  const CImg<T>& img = (*this)[l];
+	  dx += img.width;
+	  dy = cimg::max(dy,img.height);
+	  dz = cimg::max(dz,img.depth);
+	  dv = cimg::max(dv,img.dim);
+	}
+	res = CImg<T>(dx,dy,dz,dv,0);
+	switch (cimg::uncase(align)) {
+	case 'p' : { cimgl_map(*this,ll) { res.draw_image((*this)[ll],pos,0,0,0); pos+=(*this)[ll].width; }} break;
+	case 'n' : { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],pos,dy-(*this)[ll].height,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].width;
+	    }} break;
+	default  : { cimgl_map(*this,ll) {
+	      res.draw_image((*this)[ll],pos,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
+	      pos+=(*this)[ll].width; 
+	    }} break;
+	}
+      }	break;
+      case 'y': {
+	cimgl_map(*this,l) {
+	  const CImg<T>& img = (*this)[l];
+	  dx = cimg::max(dx,img.width);
+	  dy += img.height;
+	  dz = cimg::max(dz,img.depth);
+	  dv = cimg::max(dv,img.dim);
+	}
+	res = CImg<T>(dx,dy,dz,dv,0);
+	switch (cimg::uncase(align)) {
+	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,pos,0,0); pos+=(*this)[ll].height; }} break;
+	case 'n': { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],dx-(*this)[ll].width,pos,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].height;
+	    }} break;
+	default : { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,pos,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
+	      pos+=(*this)[ll].height; 
+	    }} break;
+	}
+      }	break;
+      case 'z': {
+	cimgl_map(*this,l) {
+	  const CImg<T>& img = (*this)[l];
+	  dx = cimg::max(dx,img.width);
+	  dy = cimg::max(dy,img.height);
+	  dz += img.depth;
+	  dv = cimg::max(dv,img.dim);
+	}
+	res = CImg<T>(dx,dy,dz,dv,0);
+	switch (cimg::uncase(align)) {
+	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,0,pos,0); pos+=(*this)[ll].depth; }} break;
+	case 'n': { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,pos,dv-(*this)[ll].dim); pos+=(*this)[ll].depth;
+	    }} break;
+	case 'c': { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,pos,(dv-(*this)[ll].dim)/2);
+	      pos+=(*this)[ll].depth; 
+	    }} break;
+	}
+      }	break;
+      case 'v': {
+	cimgl_map(*this,l) {
+	  const CImg<T>& img = (*this)[l];
+	  dx = cimg::max(dx,img.width);
+	  dy = cimg::max(dy,img.height);
+	  dz = cimg::max(dz,img.depth);
+	  dv += img.dim;
+	}
+	res = CImg<T>(dx,dy,dz,dv,0);
+	switch (cimg::uncase(align)) {
+	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,0,0,pos); pos+=(*this)[ll].dim; }} break;
+	case 'n': { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,dz-(*this)[ll].depth,pos); pos+=(*this)[ll].dim;
+	    }} break;
+	case 'c': { cimgl_map(*this,ll) { 
+	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,pos);
+	      pos+=(*this)[ll].dim; 
+	    }} break;
+	}
+      } break;
+      }
+      return res;
+    }
+    
+    //! Display the current CImgl instance in an existing CImgDisplay window (by reference).
+    /**
+       This function displays the list images of the current CImgl instance into an existing CImgDisplay window.
+       Images of the list are concatenated in a single temporarly image for visualization purposes.
+       The function returns immediately.
+       \param disp : reference to an existing CImgDisplay instance, where the current image list will be displayed.
+       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
+       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
+       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
+       size will be upscaled.
+       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
+       size will be downscaled.
+       \return A reference to the current CImgl instance is returned.
+    **/
+    const CImgl& display(CImgDisplay& disp,const char axe='x',const char align='c') const { 
+      get_append(axe,align).display(disp); return *this; 
+    }
+
+    //! Display the current CImgl instance in an existing CImgDisplay window (by pointer).
+    /**
+       This function displays the list images of the current CImgl instance into an existing CImgDisplay window.
+       Images of the list are concatenated in a single temporarly image for visualization purposes.
+       The function returns immediately.
+       \param disp : pointer to an existing CImgDisplay instance, where the current image list will be displayed.
+       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
+       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
+       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
+       size will be upscaled.
+       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
+       size will be downscaled.
+       \return A reference to the current CImgl instance is returned.
+    **/
+    const CImgl& display(CImgDisplay* disp,const char axe='x',const char align='c') const { 
+      if (!disp) throw CImgArgumentException("CImgl<%s>::display() : given display pointer is (null)",pixel_type());
+      else display(*disp,axe,align);
+      return *this;
+    }
+
+    //! Display the current CImgl instance in a new display window.
+    /**
+       This function opens a new window with a specific title and displays the list images of the current CImgl instance into it.
+       Images of the list are concatenated in a single temporarly image for visualization purposes.
+       The function returns when a key is pressed or the display window is closed by the user.
+       \param title : specify the title of the opening display window.
+       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
+       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
+       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
+       size will be upscaled.
+       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
+       size will be downscaled.
+       \return A reference to the current CImgl instance is returned.
+    **/
+    const CImgl& display(const char* title,const char axe='x',const char align='c',
+			 const int min_size=128,const int max_size=1024) const {
+      get_append(axe,align).display(title,min_size,max_size);
+      return *this;
+    }
+
+    //! Display the current CImgl instance in a new display window.
+    /**
+       This function opens a new window and displays the list images of the current CImgl instance into it.
+       Images of the list are concatenated in a single temporarly image for visualization purposes.
+       The function returns when a key is pressed or the display window is closed by the user.
+       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
+       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
+       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
+       size will be upscaled.
+       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
+       size will be downscaled.
+       \return A reference to the current CImgl instance is returned.
+    **/
+    const CImgl& display(const char axe='x',const char align='c',
+			 const int min_size=128,const int max_size=1024) const {
+      return display("",axe,align,min_size,max_size); 
+    }
+
+    //! Same as \ref cimg::wait()
+    /**
+       \see cimg::wait().
+    **/
+    const CImgl& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this;  }
+    
+    // Swap fields of two CImgl instances.
+    CImgl& swap(CImgl& list) {
+      cimg::swap(size,list.size);
+      cimg::swap(data,list.data);
+      return list;
+    }
+
+#ifdef cimgl_plugin
+#include cimgl_plugin
+#endif
+   
+    //@}
+  };
+
+
+  //! This class represents a region of interest of a CImg<T> image.
+  /**
+     When using the functions CImg<T>::ref_*(), an instance of a CImgROI<T> is returned, corresponding
+     to a sub-image of the original image. Acting on the CImgROI<T> instance allows to modify only a
+     part of the original image.
+     CImgROI<T> instances should be handled with care.  
+  **/
+  template<typename T> struct CImgROI : public CImg<T> {
+    CImgROI(const unsigned int dx,const unsigned int dy,const unsigned int dz,const unsigned int dv,T *const pdata) {
+      CImg<T>::width = dx; CImg<T>::height = dy; CImg<T>::depth = dz; CImg<T>::dim = dv; CImg<T>::data = pdata;
+    }
+    CImgROI(const CImgROI& roi) {
+      CImg<T>::width = roi.width; CImg<T>::height = roi.height; CImg<T>::depth = roi.depth; CImg<T>::dim = roi.dim; 
+      CImg<T>::data = roi.data;
+    }
+    ~CImgROI() { CImg<T>::width=CImg<T>::height=CImg<T>::depth=CImg<T>::dim=0; CImg<T>::data=NULL;}
+  };
+  
+}
+
+// Overcome VisualC++ 6.0 and DMC compilers namespace bug
+#if ( defined(_MSC_VER) || defined(__DMC__) ) && defined(std)
+#undef std
+#endif
+
+/*--------------------------------------------------------------------------------------
+
+
+
+  Additional documentation for the generation of the reference page (using doxygen)
+
+
+
+  -------------------------------------------------------------------------------------*/
+/**
+   \mainpage
+   
+   This is the reference documentation of <a href="http://cimg.sourceforge.net">the CImg Library</a>.
+   This documentation has been automatically generated from the header file CImg.h, using the tool
+   <a href="http://www.doxygen.org">doxygen</a>.
+   It contains a detailed description of all classes and functions of <a href="http://cimg.sourceforge.net">the CImg Library</a>.
+   If you don't know what the CImg Library is, you should go to <a href="http://cimg.sourceforge.net">the project web page</a>
+   first.
+   
+   You can easily navigate through the documentation pages, using the menu above.
+
+   To get started, you may first check the list of <a href="modules.html">available modules</a>.
+
+*/
+
+//---------------------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_structure Introduction to the CImg Library */
+/*@{
+  \page foo2
+
+  The CImg Library consists in a \b single \b header \b file \ref CImg.h providing a set of C++ classes that
+  can be used in your own sources, to load/save, process and display images. Very portable 
+  (Unix/X11,Windows, MacOS X, FreeBSD,..), efficient, simple to use, it's a pleasant toolkit
+  for coding image processing stuffs in C++.
+
+  \section s1 Library structure
+
+  The file \ref CImg.h contains all the classes and functions that compose the library itself.
+  It is organized as follows :
+  
+  - All library classes and functions are defined in the namespace cimg_library. This namespace
+  encapsulates all library functionalities and avoid any class name collision that could happen with
+  other includes. Generally, one uses this namespace as a default namespace :
+  \code
+  #include "CImg.h"
+  using namespace cimg_library;
+  \endcode
+
+  - The namespace cimg_library::cimg defines a set of \e low-level functions and variables used by the library.
+  Documented functions in this namespace can be safely used in your own program. But, \b never use the
+  cimg_library::cimg namespace as a default namespace, since it contains functions whose names are already
+  used in the standart C library.
+
+  - The class \ref cimg_library::CImg represents images up to 4-dimensions wide, containing pixels of type \c T.
+  This is actually the main class of the library.
+
+  - The class cimg_library::CImgl represents lists of cimg_library::CImg images. It can be used for instance
+  to store different frames of an image sequence.
+
+  - The class cimg_library::CImgDisplay is able to display images or image lists into graphical windows.
+  As you may guess, the code of this class is highly system-dependant (see \c cimg_display_type in \ref cimg_environment ).
+
+  - The class cimg_library::CImgStats represents simple image statistics. Use it to compute the
+  minimum, maximum, mean and variance of pixel values of images.
+
+  - The class cimg_library::CImgException (and its subclasses) are used by the library to throw exceptions
+  when errors occur. Those exceptions can be catched with a bloc <tt>try { ..} catch (CImgException) { .. }</tt>.
+  Subclasses define more precisely the type of the encountered error.
+
+  Knowing these five classes is enough to get benefit of most of the CImg Library functionalities.
+
+  As you can see, all the library functions and classes are defined in a single header file CImg.h.
+  This may sound strange, but it is actually one major advantage of the CImg library :
+
+  - The compilation is done on the fly : Only functions \e really \e used in your program are compiled and appear in the final
+  program. This leads to very compact executables, without any unused functions code.
+  - Class members and functions are inlined, leading to better performance during execution.
+  - No complex dependancies have to be handled : Just include the CImg.h file, and you get a working toolkit that processes images.
+
+  \section s2 CImg version of "Hello world".
+
+  Below is a very simple code that creates a "Hello World" image. This shows you basically how a CImg program looks like.
+
+  \code
+  #include "CImg.h"
+  using namespace cimg_library;
+
+  int main() {
+    CImg<unsigned char> img(640,400,1,3);        // Define a 640x400 color image
+    img.fill(0);                                 // Set pixel values to 0 (color : black)
+    unsigned char purple[3]={255,0,255};         // Define a purple color
+    img.draw_text("Hello World",100,100,purple); // Draw a purple "Hello world" at coordinates (100,100).
+    img.display("Hello World");                  // Display the image
+    return 0;
+  }
+  \endcode
+
+  Which can be also written in a more compact way as :
+
+  \code
+  #include "CImg.h"
+  using namespace cimg_library;
+
+  int main() {
+    const unsigned char purple[3]={255,0,255};
+    CImg<unsigned char>(640,400,1,3,0).draw_text("Hello World",100,100,purple).display("Hello World");
+    return 0;
+  }
+  \endcode
+
+  Generally, you can write very small code that performs complex image tasks. The CImg Library is very simple
+  to use but provide a lot of interesting algorithms for image manipulation.
+  
+  \section s3 How to compile ?
+
+  The CImg library is a very light and user-friendly library : only standart system libraries are used.
+  this avoid to handle complex dependancies and problems with library compatibility.
+  The only thing you need is a (quite modern) C++ compiler. Before each release, the CImg library
+  is successfully compiled with the following compilers :
+  
+  - <b>Microsoft Visual C++ 6.0 and Visual Studio.NET</b> : Use project files and solution files provided in the 
+  CImg Library package to see how it works.
+  - <b>Intel ICL compiler</b> : Use the following command to compile a CImg-based program with ICL :
+  \code
+  icl /Ox hello_world.cpp user32.lib gdi32.lib
+  \endcode
+  - <b>Digital Mars Compiler</b> : Use the following command to compile a CImg-based program with DMC :
+  \code
+  dmc -Ae hello_world.cpp gdi32.lib
+  \endcode
+  - <b>g++ (MingW windows version)</b> : Use the following command to compile a CImg-based program with g++, on Windows :
+  \code
+  g++ -o hello_word.exe hello_word.cpp -O2 -lgdi32
+  \endcode
+  - <b>g++ (Linux version)</b> : Use the following command to compile a CImg-based program with g++, on Linux :
+  \code
+  g++ -o hello_word.exe hello_world.cpp -O2 -Wl,-rpath /usr/X11R6/lib -lm -lpthread -lX11
+  \endcode
+  - <b>g++ (Solaris version)</b> : Use the following command to compile a CImg-based program with g++, on Solaris :
+  \code
+  g++ -o hello_word.exe hello_world.cpp -O2 -lm -lpthread -R/usr/X11R6/lib -lrt -lnsl -lsocket
+  \endcode
+  - <b>g++ (Mac OS X version)</b> : Use the following command to compile a CImg-based program with g++, on Mac OS X :
+  \code
+  g++ -o hello_word.exe hello_world.cpp -O2 -lm -lpthread -L/usr/X11R6/lib -lm -lpthread -lX11
+  \endcode
+  - <b>Dev-Cpp</b> : Use the project file provided in the CImg library package to see how it works.
+
+  If you are using another compilers and encounter problems, please
+  <a href="http://www.greyc.ensicaen.fr/~dtschump">write me</a> since maintaining compatibility is one
+  of my priority.
+
+  \section s4 What's next ?
+
+  If you are ready to get more, and to start writing more serious programs
+  with CImg, you are invited to go to the \ref cimg_tutorial section.
+
+**/
+/*@}*/
+
+//--------------------------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_environment Setting Environment Variables */
+/*@{
+  \page foo1
+  
+  The CImg library is a multiplatform library, working on a wide variety of systems.
+  This implies the existence of some \e environment \e variables that must be correctly defined
+  depending on your current system.
+  Most of the time, the CImg Library defines these variables automatically
+  (for popular systems). Anyway, if your system is not recognized, you will have to set the environment
+  variables by hand. Here is a quick explanations of environment variables.\n
+  
+  Setting the environment variables is done with the <tt>#define</tt> keyword.
+  This setting must be done <i>before including the file CImg.h</i> in your source code.
+  For instance,
+  defining the environment variable \c cimg_display_type would be done like this :
+  \code
+  #define cimg_display_type 0
+  #include "CImg.h"
+  ...
+  \endcode
+
+  Here are the different environment variables used by the CImg Library :
+  
+  - \b \c cimg_OS : This variable defines the type of your Operating System. It can be set to \b 0 (\e Solaris),
+  \b 1 (\e Linux),
+  \b 2 (\e Windows), \b 3 (\e Mac \ OS X), \b 4 (\e FreeBSD) or \b -1 (\e Other \e configuration).
+  It should be actually auto-detected by the CImg library. If this is not the case (<tt>cimg_OS=-1</tt>), you
+  will probably have to tune the environment variables described below.
+
+  - \b \c cimg_display_type : This variable defines the type of graphical library used to
+  display images in windows. It can be set to 0 (no display library available), \b 1 (X11-based display) or
+  \b 2 (Windows-GDI display).
+  If you are running on a system without X11 or Windows-GDI ability, please set this variable to \c 0.
+  This will disable the display support, since the CImg Library doesn't contain the necessary code to display
+  images on systems other than X11 or Windows GDI.
+
+  - \b \c cimg_color_terminal : This variable tells the library if the system terminal has VT100 color capabilities.
+  It can be \e defined or \e not \e defined. Define this variable to get colored output on your terminal, 
+  when using the CImg Library.
+  
+  - \b \c cimg_debug : This variable defines the level of run-time debug messages that will be displayed by
+  the CImg Library. It can be set to 0 (no debug messages), 1 (normal debug messages, which is
+  the default value), or 2 (high debug messages). Note that setting this value to 2 may slow down your
+  program since more debug tests are made by the library (particularly to check if pixel access is made outside
+  image boundaries). See also \ref CImgException to better understand how debug messages are working.
+  
+  - \b \c cimg_lapack : This variable tells the library to use the LAPACK library.
+  It can be \e defined or \e not \e defined (default). Define this variable if you want to use CImg-specific functions
+  based on the LAPACK library. You will have to link your code with the LAPACK library to be able to run
+  your program.
+
+  - \b \c cimg_convert_path : This variables tells the library where the ImageMagick's \e convert tool is located.
+  Setting this variable should not be necessary if ImageMagick is installed on a standart directory, or
+  if \e convert is in your system PATH variable. This macro should be defined only if the ImageMagick's 
+  \e convert tool is not found automatically, when trying to read compressed image format (GIF,PNG,...). 
+  See also cimg_library::CImg::load_convert() and cimg_library::CImg::save_convert() for more informations.
+
+  - \b \c cimg_temporary_path : This variable tells the library where it can find a directory to store
+  temporary files. Setting this variable should not be necessary if you are running on a standart system.
+  This macro should be defined only when troubles are encountered when trying to read
+  compressed image format (GIF,PNG,...).
+  See also cimg_library::CImg::load_convert() and cimg_library::CImg::save_convert() for more informations.
+
+  - \b \c cimg_plugin : This variable tells the library to use a plugin file to add features to the CImg<T> class.
+  Define it with the path of your plugin file, if you want to add member functions to the CImg<T> class,
+  without having to modify directly the \c "CImg.h" file. An include of the plugin file is performed in the CImg<T>
+  class. If \c cimg_plugin if not specified (default), no include is done.
+  
+  - \b \c cimgl_plugin : Same as \c cimg_plugin, but to add features to the CImgl<T> class.
+  
+  - \b \c cimgdisplay_plugin : Same as \c cimg_plugin, but to add features to the CImgDisplay<T> class.
+
+  - \b \c cimgstats_plugin : Same as \c cimg_plugin, but to add features to the CImgStats<T> class.
+
+  All these compilation variables can be checked, using the function cimg_library::cimg::info(), which
+  displays a list of the different configuration variables and their values on the standart error output.
+**/
+/*@}*/
+
+//--------------------------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_tutorial Tutorial : Getting Started. */
+/*@{
+  \page foo3
+  
+  Let's start to write our first program to get the idea. This will demonstrate how to load and create images, as well as handle image 
+  display and mouse events.
+  Assume we want to load a color image <tt>lena.jpg</tt>, smooth it, display it in a windows, and enter an event loop so that clicking a
+  point in the image with the mouse will draw the intensity profiles of (R,G,B) of the corresponding image line (in another window).
+  Yes, that sounds quite complex for a first code, but don't worry, it will be very simple using the CImg library ! Well, just look
+  at the code below, it does the task :
+
+  \code
+  #include "CImg.h"
+  using namespace cimg_library;
+
+  int main() {
+    CImg<unsigned char> image("lena.jpg"), visu(500,400,1,3,0);
+    const unsigned char red[3]={255,0,0}, green[3]={0,255,0}, blue[3]={0,0,255};
+    image.blur(2.5);
+    CImgDisplay main_disp(image,"Click a point"), draw_disp(visu,"Intensity profile");
+    while (!main_disp.closed && !draw_disp.closed) {
+      main_disp.wait();
+      if (main_disp.button && main_disp.mousey>=0) {
+        const int y = main_disp.mousey;
+	visu.fill(0).draw_graph(image.get_crop(0,y,0,0,image.dimx()-1,y,0,0),red,0,256,0);
+	visu.draw_graph(image.get_crop(0,y,0,1,image.dimx()-1,y,0,1),green,0,256,0);
+	visu.draw_graph(image.get_crop(0,y,0,2,image.dimx()-1,y,0,2),blue,0,256,0).display(draw_disp);
+	}
+      }
+    return 0;
+  }
+  \endcode
+  
+  Here is a screenshot of the resulting program :
+
+  <img SRC="../img/tutorial.jpg">
+
+  And here is the detailled explanation of the source, line by line :
+
+  \code #include "CImg.h" \endcode
+  Include the main and only header file of the CImg library.
+  \code using namespace cimg_library; \endcode
+  Use the library namespace to ease the declarations afterward.
+  \code int main() { \endcode
+  Definition of the main function.
+  \code CImg<unsigned char> image("lena.jpg"), visu(500,400,1,3,0); \endcode
+  Creation of two instances of images of \c unsigned \c char pixels.
+  The first image \c image is initialized by reading an image file from the disk. 
+  Here, <tt>lena.jpg</tt> must be in the same directory than the current program.
+  Note that you must also have installed the \e ImageMagick package in order to be able to read JPG images.
+  The second image \c visu is initialized as a black color image with dimension <tt>dx=500</tt>, <tt>dy=400</tt>, 
+  <tt>dz=1</tt> (here, it is a 2D image, not a 3D one), and <tt>dv=3</tt> (each pixel has 3 'vector' channels R,G,B).
+  The last argument in the constructor defines the default value of the pixel values
+  (here \c 0, which means that \c visu will be initially black).
+  \code const unsigned char red[3]={255,0,0}, green[3]={0,255,0}, blue[3]={0,0,255}; \endcode
+  Definition of three different colors as array of unsigned char. This will be used to draw plots with different colors.
+  \code image.blur(2.5); \endcode
+  Blur the image, with a gaussian blur and a variance of 2.5. Note that most of the CImg functions have two versions :
+  one that acts in-place (which is the case of blur), and one that returns the result as a new image (the name of the function 
+  begins then with <tt>get_</tt>&nbsp;). In this case, one could have also written <tt>image = image.get_blur(2.5);</tt>
+  (more expensive, since it needs an additional copy operation).
+  \code CImgDisplay main_disp(image,"Click a point"), draw_disp(visu,"Intensity profile"); \endcode
+  Creation of two display windows, one for the input image image, and one for the image visu which will be display intensity profiles.
+  By default, CImg displays handles events (mouse,keyboard,..). On Windows, there is a way to create fullscreen displays.
+  \code while (!main_disp.closed && !draw_disp.closed) { \endcode
+  Enter the event loop, the code will exit when one of the two display windows is closed.
+  \code main_disp.wait(); \endcode
+  Wait for an event (mouse, keyboard,..) in the display window \c main_disp.
+  \code if (main_disp.button && main_disp.mousey>=0) { \endcode
+  Test if the mouse button has been clicked on the image area.
+  One may distinguish between the 3 different mouse buttons,
+  but in this case it is not necessary
+  \code const int y = main_disp.mousey; \endcode
+  Get the image line y-coordinate that has been clicked.
+  \code visu.fill(0).draw_graph(image.get_crop(0,y,0,0,image.dimx()-1,y,0,0),red,0,256,0); \endcode
+  This line illustrates the pipeline property of most of the CImg class functions. The first function <tt>fill(0)</tt> simply sets
+  all pixel values with 0 (i.e. clear the image \c visu). The interesting thing is that it returns a reference to
+  \c visu and then, can be pipelined with the function \c draw_graph() which draws a plot in the image \c visu.
+  The plot data are given by another image (the first argument of \c draw_graph()). In this case, the given image is 
+  the red-component of the line y of the original image, retrieved by the function \c get_crop() which returns a
+  sub-image of the image \c image. Remember that images coordinates are 4D (x,y,z,v) and for color images,
+  the R,G,B channels are respectively given by <tt>v=0, v=1</tt> and <tt>v=2</tt>.
+  \code visu.draw_graph(image.get_crop(0,y,0,1,image.dimx()-1,y,0,1),green,0,256,0); \endcode
+  Plot the intensity profile for the green channel of the clicked line.
+  \code visu.draw_graph(image.get_crop(0,y,0,2,image.dimx()-1,y,0,2),blue,0,256,0).display(draw_disp); \endcode
+  Same thing for the blue channel. Note how the function (which return a reference to \c visu) is pipelined with the function
+  \c display() that just paints the image visu in the corresponding display window.
+  \code ...till the end \endcode
+  I don't think you need more explanations !
+
+  As you have noticed, the CImg library allows to write very small and intuitive code. Note also that this source will perfectly 
+  work on Unix and Windows systems. Take also a look to the examples provided in the CImg package (
+  directory \c examples/ ). It will show you how CImg-based code can be surprisingly small. 
+  Moreover, there is surely one example close to what you want to do.
+  A good start will be to look at the file <tt>CImg_test.cpp</tt> which contains small and various examples of what you can do
+  with the CImg Library. All CImg classes are used in this source, and the code can be easily modified to see what happens. 
+
+**/
+/*@}*/
+
+//----------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_drawing Using Drawing Functions. */
+/*@{
+  \page foo5
+
+  \section s5 Using Drawing Functions.
+
+  This section tells more about drawing features in CImg images.
+  Drawing functions list can be found in <a href="structCImg.html">the CImg functions list</a>
+  (section \b Drawing Functions),
+  and are all defined on a common basis. Here are the important points to understand before using
+  drawing functions :
+  
+  - Drawing is performed on the instance image. Drawing functions parameters
+  are defined as \e const variables and return a reference to the current instance <tt>(*this)</tt>,
+  so that drawing functions can be pipelined (see examples below).
+  Drawing is usually done in 2D color images but can be performed in 3D images with any vector-valued dimension,
+  and with any possible pixel type.
+
+  - A color parameter is always needed to draw features in an image. The color must be defined as a C-style array
+  whose dimension is at least
+
+*/
+/*@}*/
+
+//----------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_loops Using Image Loops. */
+/*@{
+  \page foo_lo
+  The CImg Library provides different macros that define useful iterative loops over an image.
+  Basically, it can be used to replace one or several <tt>for(..)</tt> instructions, but it also proposes
+  interesting extensions to classical loops.
+  Below is a list of all existing loop macros, classified in four different categories :
+  - \ref lo1
+  - \ref lo4
+  - \ref lo5
+  - \ref lo6
+
+  \section lo1 Loops over the pixel buffer
+
+  Loops over the pixel buffer are really basic loops that iterate a pointer on the pixel data buffer
+  of a \c cimg_library::CImg image. Two macros are defined for this purpose :
+  
+  - \b cimg_map(img,ptr,T) :
+  This macro loops over the pixel data buffer of the image \c img, using a pointer <tt>T* ptr</tt>,
+  starting from the end of the buffer (last pixel) till the beginning of the buffer (first pixel).
+      - \c img must be a (non empty) \c cimg_library::CImg image of pixels \c T.
+      - \c ptr is a pointer of type \c T*.
+  This kind of loop should not appear a lot in your own source code, since this is a low-level loop
+  and many functions of the CImg class may be used instead. Here is an example of use :
+  \code
+  CImg<float> img(320,200);
+  cimg_map(img,ptr,float) { *ptr=0; }      // Equivalent to 'img.fill(0);'
+  \endcode
+
+  - \b cimg_mapoff(img,off) :
+  This macro loops over the pixel data buffer of the image \c img, using an offset \c ,
+  starting from the beginning of the buffer (first pixel, \c off=0)
+  till the end of the buffer (last pixel value, <tt>off = img.size()-1</tt>).
+      - \c img must be a (non empty) cimg_library::CImg<T> image of pixels \c T.
+      - \c off is an inner-loop variable, only defined inside the scope of the loop.
+
+  Here is an example of use :
+  \code
+  CImg<float> img(320,200);
+  cimg_mapoff(img,off) { img[off]=0; }  // Equivalent to 'img.fill(0);'
+  \endcode
+
+  \section lo4 Loops over image dimensions
+
+  The following loops are probably the most used loops in image processing programs.
+  They allow to loop over the image along one or several dimensions, along a raster scan course.
+  Here is the list of such loop macros for a single dimension :
+  - \b cimg_mapX(img,x) : equivalent to : <tt>for (int x=0; x<img.dimx(); x++)</tt>.
+  - \b cimg_mapY(img,y) : equivalent to : <tt>for (int y=0; y<img.dimy(); y++)</tt>.
+  - \b cimg_mapZ(img,z) : equivalent to : <tt>for (int z=0; z<img.dimz(); z++)</tt>.
+  - \b cimg_mapV(img,v) : equivalent to : <tt>for (int v=0; v<img.dimv(); v++)</tt>.
+
+  Combinations of these macros are also defined as other loop macros, allowing to loop directly over 2D, 3D or 4D images :
+  - \b cimg_mapXY(img,x,y) : equivalent to : \c cimg_mapY(img,y) \c cimg_mapX(img,x).
+  - \b cimg_mapXZ(img,x,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapX(img,x).
+  - \b cimg_mapYZ(img,y,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapY(img,y).
+  - \b cimg_mapXV(img,x,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapX(img,x).
+  - \b cimg_mapYV(img,y,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapY(img,y).
+  - \b cimg_mapZV(img,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapZ(img,z).
+  - \b cimg_mapXYZ(img,x,y,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapXY(img,x,y).
+  - \b cimg_mapXYV(img,x,y,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXY(img,x,y).
+  - \b cimg_mapXZV(img,x,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXZ(img,x,z).
+  - \b cimg_mapYZV(img,y,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapYZ(img,y,z).
+  - \b cimg_mapXYZV(img,x,y,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXYZ(img,x,y,z).
+
+  - For all these loops, \c x,\c y,\c z and \c v are inner-defined variables only visible inside the scope of the loop.
+  They don't have to be defined before the call of the macro.
+  - \c img must be a (non empty) cimg_library::CImg image.
+
+  Here is an example of use that creates an image with a smooth color gradient :
+  \code
+  CImg<unsigned char> img(256,256,1,3);       // Define a 256x256 color image
+  cimg_mapXYV(img,x,y,v) { img(x,y,v) = (x+y)*(v+1)/6; }
+  img.display("Color gradient");
+  \endcode
+
+  \section lo5 Loops over interior regions and borders.
+
+  Similar macros are also defined to loop only on the border of an image, or inside the image (excluding the border).
+  The border may be several pixel wide :
+
+  - \b cimg_imapX(img,x,n) : Loop along the x-axis, except for pixels inside a border of \p n pixels wide.
+  - \b cimg_imapY(img,y,n) : Loop along the y-axis, except for pixels inside a border of \p n pixels wide.
+  - \b cimg_imapZ(img,z,n) : Loop along the z-axis, except for pixels inside a border of \p n pixels wide.
+  - \b cimg_imapV(img,v,n) : Loop along the v-axis, except for pixels inside a border of \p n pixels wide.
+  - \b cimg_imapXY(img,x,y,n) : Loop along the (x,y)-axes, excepted for pixels inside a border of \p n pixels wide.
+  - \b cimg_imapXYZ(img,x,y,z,n) : Loop along the (x,y,z)-axes, excepted for pixels inside a border of \p n pixels wide.
+
+  And also :
+
+  - \b cimg_bmapX(img,x,n) : Loop along the x-axis, only for pixels inside a border of \p n pixels wide.
+  - \b cimg_bmapY(img,y,n) : Loop along the y-axis, only for pixels inside a border of \p n pixels wide.
+  - \b cimg_bmapZ(img,z,n) : Loop along the z-axis, only for pixels inside a border of \p n pixels wide.
+  - \b cimg_bmapV(img,v,n) : Loop along the z-axis, only for pixels inside a border of \p n pixels wide.
+  - \b cimg_bmapXY(img,x,y,n) : Loop along the (x,y)-axes, only for pixels inside a border of \p n pixels wide.
+  - \b cimg_bmapXYZ(img,x,y,z,n) : Loop along the (x,y,z)-axes, only for pixels inside a border of \p n pixels wide.
+
+  - For all these loops, \c x,\c y,\c z and \c v are inner-defined variables only visible inside the scope of the loop.
+  They don't have to be defined before the call of the macro.
+  - \c img must be a (non empty) cimg_library::CImg image.
+  - The constant \c n stands for the size of the border.
+
+  Here is an example of use, to create a 2d grayscale image with two different intensity gradients :
+  \code
+  CImg<> img(256,256);
+  cimg_imapXY(img,x,y,50) img(x,y) = x+y;
+  cimg_bmapXY(img,x,y,50) img(x,y) = x-y;
+  img.display();
+  \endcode
+
+  \section lo6 Loops using neighborhoods.
+  
+  Inside an image loop, it is often useful to get values of neighborhood pixels of the
+  current pixel at the loop location.
+  The CImg Library provides a very smart and fast mechanism for this purpose, with the definition
+  of several loop macros that remember the neighborhood values of the pixels.
+  The use of these macros can highly optimize your code, and also simplify your program.
+
+  \subsection lo7 Neighborhood-based loops for 2D images
+
+  For 2D images, the neighborhood-based loop macros are : 
+
+  - \b cimg_map2x2(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 2x2 neighborhood.
+  - \b cimg_map3x3(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 3x3 neighborhood.
+  - \b cimg_map4x4(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 4x4 neighborhood.
+  - \b cimg_map5x5(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 5x5 neighborhood.
+
+  For all these loops, \c x and \c y are inner-defined variables only visible inside the scope of the loop.
+  They don't have to be defined before the call of the macro.
+  \c img is a non empty CImg<T> image. \c z and \c v are constants that define on which image slice and
+  vector channel the loop must apply (usually both 0 for grayscale 2D images).
+  Finally, \c I is the 2x2, 3x3, 4x4 or 5x5 neighborhood that will be updated with the correct pixel values
+  during the loop (see \ref lo9).
+
+  \subsection lo8 Neighborhood-based loops for 3D images
+
+  For 3D images, the neighborhood-based loop macros are : 
+
+  - \b cimg_map2x2x2(img,x,y,z,v,I) : Loop along the (x,y,z)-axes using a centered 2x2x2 neighborhood.
+  - \b cimg_map3x3x3(img,x,y,z,v,I) : Loop along the (x,y,z)-axes using a centered 3x3x3 neighborhood.
+
+  For all these loops, \c x, \c y and \c z are inner-defined variables only visible inside the scope of the loop.
+  They don't have to be defined before the call of the macro.
+  \c img is a non empty CImg<T> image. \c v is a constant that defines on which image channel
+  the loop must apply (usually 0 for grayscale 3D images).
+  Finally, \c I is the 2x2x2 or 3x3x3 neighborhood that will be updated with the correct pixel values
+  during the loop (see \ref lo9).
+
+  \subsection lo9 Defining neighborhoods
+
+  The CImg library defines a neighborhood as a set of named \e variables or \e references, declared
+  using specific CImg macros :
+
+  - \b CImg_2x2(I,type) : Define a 2x2 neighborhood named \c I, of type \c type.
+  - \b CImg_3x3(I,type) : Define a 3x3 neighborhood named \c I, of type \c type.
+  - \b CImg_4x4(I,type) : Define a 4x4 neighborhood named \c I, of type \c type.
+  - \b CImg_5x5(I,type) : Define a 5x5 neighborhood named \c I, of type \c type.
+  - \b CImg_2x2x2(I,type) : Define a 2x2x2 neighborhood named \c I, of type \c type.
+  - \b CImg_3x3x3(I,type) : Define a 3x3x3 neighborhood named \c I, of type \c type.
+
+  Actually, \c I is a \e generic \e name for the neighborhood. In fact, these macros declare
+  a \e set of new variables.
+  For instance, defining a 3x3 neighborhood \c CImg_3x3(I,float) declares 9 different float variables
+  \c Ipp,\c Icp,\c Inp,\c Ipc,\c Icc,\c Inc,\c Ipn,\c Icn,\c Inn which correspond to each pixel value of
+  a 3x3 neighborhood.
+  Variable indices are \c p,\c c or \c n, and stand respectively for \e 'previous', \e 'current' and \e 'next'.
+  First indice denotes the \c x-axis, second indice denotes the \c y-axis.
+  Then, the names of the variables are directly related to the position of the corresponding pixels
+  in the neighborhood. For 3D neighborhoods, a third indice denotes the \c z-axis.
+  Then, inside a neighborhood loop, you will have the following equivalence :
+  - <tt>Ipp = img(x-1,y-1)</tt>
+  - <tt>Icn = img(x,y+1)</tt>
+  - <tt>Inp = img(x+1,y-1)</tt>
+  - <tt>Inpc = img(x+1,y-1,z)</tt>
+  - <tt>Ippn = img(x-1,y-1,z+1)</tt>
+  - and so on...
+
+  For bigger neighborhoods, such as 4x4 or 5x5 neighborhoods, two additionnal indices are introduced :
+  \c a (stands for \e 'after') and \c b (stands for \e 'before'), so that :
+  - <tt>Ibb = img(x-2,y-2)</tt>
+  - <tt>Ina = img(x+1,y+2)</tt>
+  - and so on...
+
+  The value of a neighborhood pixel outside the image range (image border problem) is automatically set to the same
+  values than the nearest valid pixel in the image (this is also called the \e Neumann \e border \e condition).
+
+  \subsection lo10 Neighborhood as a reference
+  It is also possible to define neighborhood variables as references to classical C-arrays or CImg<T> images, instead of
+  allocating new variables. This is done by adding \c _ref to the macro names used for the neighborhood definition :
+
+  - \b CImg_2x2_ref(I,type,tab) : Define a 2x2 neighborhood named \c I, of type \c type, as a reference to \c tab.
+  - \b CImg_3x3_ref(I,type,tab) : Define a 3x3 neighborhood named \c I, of type \c type, as a reference to \c tab.
+  - \b CImg_4x4_ref(I,type,tab) : Define a 4x4 neighborhood named \c I, of type \c type, as a reference to \c tab.
+  - \b CImg_5x5_ref(I,type,tab) : Define a 5x5 neighborhood named \c I, of type \c type, as a reference to \c tab.
+  - \b CImg_2x2x2_ref(I,type,tab) : Define a 2x2x2 neighborhood named \c I, of type \c type, as a reference to \c tab.
+  - \b CImg_3x3x3_ref(I,type,tab) : Define a 3x3x3 neighborhood named \c I, of type \c type, as a reference to \c tab.
+
+  \c tab can be a one-dimensionnal C-style array, or a non empty \c CImg<T> image. Both objects must have
+  same sizes as the considered neighborhoods.
+
+  \subsection lo11 Example codes
+  More than a long discussion, the above example will demonstrate how to compute the gradient norm of a 3D volume
+  using the \c cimg_map3x3x3() loop macro :
+
+  \code
+  CImg<float> volume("IRM.hdr");        // Load an IRM volume from an Analyze7.5 file
+  CImg_3x3x3(I,float);                  // Define a 3x3x3 neighborhood
+  CImg<float> gradnorm(volume,false);   // Create an image with same size as 'volume'
+  cimg_map3x3x3(volume,x,y,z,0,I) {     // Loop over the volume, using the neighborhood I
+    const float ix = 0.5f*(Incc-Ipcc);  // Compute the derivative along the x-axis.
+    const float iy = 0.5f*(Icnc-Icpc);  // Compute the derivative along the y-axis.
+    const float iz = 0.5f*(Iccn-Iccp);  // Compute the derivative along the z-axis.
+    gradnorm(x,y,z) = std::sqrt(ix*ix+iy*iy+iz*iz);  // Set the gradient norm in the destination image
+  }
+  gradnorm.display("Gradient norm");
+  \endcode
+  
+  And the following example shows how to deal with neighborhood references to blur a color image by averaging
+  pixel values on a 5x5 neighborhood.
+
+  \code
+  CImg<unsigned char> src("image_color.jpg"), dest(src,false), neighbor(5,5);  // Image definitions.
+  typedef unsigned char uchar;             // Avoid space in the second parameter of the macro CImg_5x5 below.
+  CImg_5x5_ref(N,uchar,neighbor);          // Define a 5x5 neighborhood as a reference to the 5x5 image neighbor.
+  cimg_mapV(src,k)                         // Standart loop on color channels
+     cimg_map5x5(src,x,y,0,k,N)            // 5x5 neighborhood loop.
+       dest(x,y,k) = neighbor.sum()/(5*5); // Averaging pixels to filter the color image.
+  CImgl<unsigned char> visu(src,dest);
+  visu.display("Original + Filtered");     // Display both original and filtered image.
+  \endcode
+  
+  Note that in this example, we didn't use directly the variables Nbb,Nbp,..,Ncc,... since
+  there are only references to the neighborhood image \c neighbor. We rather used a member function of \c neighbor.
+
+  As you can see, explaining the use of the CImg neighborhood macros is actually more difficult than using them !
+*/
+/*@}*/
+//----------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_displays Using Display Windows. */
+/*@{
+  \page foo_di
+
+  When opening a display window, you can choose the way the pixel values will be normalized
+  before being displayed on the screen. Screen displays only support color values between [0,255],
+  and some
+  
+  When displaying an image into the display window using CImgDisplay::display(), values of
+  the image pixels can be eventually linearly normalized between [0,255] for visualization purposes.
+  This may be useful for instance when displaying \p CImg<double> images with pixel values
+  between [0,1].
+  The normalization behavior depends on the value of \p normalize which can be either \p 0,\p 1 or \p 2 :
+  - \p 0 : No pixel normalization is performed when displaying an image. This is the fastest
+  process, but you must be sure your displayed image have pixel values inside the range [0,255].
+  - \p 1 : Pixel value normalization is done for each new image display. Image pixels are
+  not modified themselves, only displayed pixels are normalized.
+  - \p 2 : Pixel value normalization is done for the first image display, then the
+  normalization parameters are kept and used for all the next image displays.
+  
+*/
+/*@}*/
+
+//----------------------------------------------------------------------------------------------------
+/** \addtogroup cimg_options Retrieving Command Line Arguments. */
+/*@{
+  \page foo_so
+
+   The CImg library offers facilities to retrieve command line arguments in a console-based
+   program, as it is a commonly needed operation.
+   Two macros \c cimg_usage() and \c cimg_option() are defined for this purpose.
+   Using these macros allows to easily retrieve options values from the command line.
+   Moreover, invoking the corresponding executable with the option \c -h or \c --help will
+   automatically display the program usage, followed by the list of requested options.
+
+   \section so1 The cimg_usage() macro
+
+   The macro \c cimg_usage(usage) may be used to describe the program goal and usage.
+   It is generally inserted one time after the <tt>int main(int argc,char **argv)</tt> definition.
+  
+   \param usage : A string describing the program goal and usage.
+   \pre The function where \c cimg_usage() is used must have correctly defined \c argc and \c argv variables.
+
+   \section so2 The cimg_option() macro
+
+   The macro \c cimg_option(name,default,usage) may be used to retrieve an option value from the command line.
+
+   \param name    : The name of the option to be retrieved from the command line.
+   \param default : The default value returned by the macro if no options \p name has been specified when running the program.
+   \param usage   : A brief explanation of the option. If \c usage==NULL, the option won't appear on the option list
+                    when invoking the executable with options \c -h or \c --help (hidden option).
+                  
+   \return \c cimg_option() returns an object that has the \e same \e type than the default value \c default.
+   The return value is equal to the one specified on the command line. If no such option have been specified,
+   the return value is equal to the default value \c default.
+   Warning, this can be confusing in some situations (look at the end of the next section).
+   \pre The function where \c cimg_option() is used must have correctly defined \c argc and \c argv variables.
+
+   \section so3 Example of use
+
+   The code below uses the macros \c cimg_usage() and \c cimg_option().
+   It loads an image, smoothes it an quantifies it with a specified number of values.
+   \code
+   #include "CImg.h"
+   using namespace cimg_library;
+   int main(int argc,char **argv) {
+     cimg_usage("Retrieve command line arguments");
+     const char* filename = cimg_option("-i","image.gif","Input image file");
+     const char* output   = cimg_option("-o",(const char*)NULL,"Output image file");
+     const double sigma   = cimg_option("-s",1.0,"Variance of the gaussian smoothing");
+     const  int nblevels  = cimg_option("-n",16,"Number of quantification levels");
+     const bool hidden    = cimg_option("-hidden",false,NULL);      // This is a hidden option
+
+     CImg<unsigned char> img(filename);
+     img.blur(sigma).quantify(nblevels);
+     if (output) img.save(output); else img.display("Output image");
+     if (hidden) std::fprintf(stderr,"You found me !\n");
+     return 0;
+   }
+   \endcode
+
+   Invoking the corresponding executable with <tt>test -h -hidden -n 20 -i foo.jpg</tt> will display :
+   \verbatim
+$ ./test -h -hidden -n 20 -i foo.jpg
+
+ test : Retrieve command line arguments (Oct 16 2004, 12:34:26)
+
+    -i       = foo.jpg      : Input image file
+    -o       = NULL         : Output image file
+    -s       = 1            : Variance of the gaussian smoothing
+    -n       = 20           : Number of quantification levels
+
+   You found me !
+\endverbatim
+
+   \warning As the type of object returned by the macro \c cimg_option(option,default,usage) 
+   is defined by the type of \c default, undesired casts may appear when writting code such as :
+   \code
+   const double sigma = cimg_option("-val",0,"A floating point value");
+   \endcode
+   In this case, \c sigma will always be equal to an integer (since the default value \c 0 is an integer).
+   When passing a float value on the command line, a \e float \e to \e integer cast is then done,
+   truncating the given parameter to an integer value (this is surely not a desired behavior).
+   You must specify <tt>0.0</tt> as the default value in this case.
+
+   \section so4 How to learn more about command line options ?
+   You should take a look at the examples <tt>examples/inrcast.cpp</tt> provided in the CImg Library package.
+   This is a command line based image converter which intensively uses the \c cimg_option() and \c cimg_usage()
+   macros to retrieve command line parameters.
+*/
+/*@}*/
+//----------------------------------------------------------------------------------------------------
+#endif

Added: greystoration_gimp/ChangeLog
===================================================================
--- greystoration_gimp/ChangeLog	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/ChangeLog	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,20 @@
+2005-03-18  Victor STINNER  <victor.stinner at haypocalc.com>
+
+        * Version 0.1.2
+        * Use table and notebook for dialog
+
+2005-03-12  Victor STINNER  <victor.stinner at haypocalc.com>
+
+        * Version 0.1.1
+        * Dialog reorganized with better parameters names.
+        * Fix plugin entry in Gimp menu (Greycstoration -> GREYCstoration).
+        * Don't use CImg interface (keyboard/mouse) which remove X11 and
+          pthread dependencies (or Win32 dependencies)
+        * Change default values (p1=0.1 and sigma=1.4)
+
+2005-03-11  Victor STINNER  <victor.stinner at haypocalc.com>
+
+        * Version 0.1, first public release.
+        * Support image restoration.
+        * Plug-in dialog have all parameters needed and a preview view.
+

Added: greystoration_gimp/Makefile
===================================================================
--- greystoration_gimp/Makefile	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/Makefile	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,36 @@
+# Common arguments
+CXXFLAGS=-Wall -O3 -ffast-math
+SRC=image.cpp greycstoration.cpp dialog.cpp main.cpp
+
+# C++ compiler
+CXX=g++
+
+# pkg-config modules needed
+MODULES=gimp-2.0 gimpui-2.0 gtk+-2.0
+CXXFLAGS+=$(shell pkg-config $(MODULES) --cflags)
+LIBS=$(shell pkg-config $(MODULES) --libs)
+
+# Don't use CImg interface (keyboard/mouse interaction)
+CXXFLAGS+=-Dcimg_OS=-1 -Dcimg_display_type=0 
+
+# And others variables ...
+PROG=greycstoration
+OBJECTS=$(patsubst %.cpp,%.o,$(SRC))
+GIMPTOOL=gimptool-2.0
+
+$(PROG): $(OBJECTS)
+	@echo "Linking ..."
+	@$(CXX) -o $(PROG) $(OBJECTS) $(CXXFLAGS) $(LIBS)
+	
+%.o: %.cpp
+	@echo "Compile $@"
+	@$(CXX) -c -o $@ $< $(CXXFLAGS)
+	
+install: $(PROG)
+	$(GIMPTOOL) --install-bin $(PROG)
+	
+uninstall:
+	$(GIMPTOOL) --uninstall-bin $(PROG)
+
+clean:
+	rm -f $(PROG) $(OBJECTS)

Added: greystoration_gimp/dialog.cpp
===================================================================
--- greystoration_gimp/dialog.cpp	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/dialog.cpp	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,275 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+
+#include "dialog.h"
+//----------------------------------------------------------------------------
+
+// Future gettext use
+#define _(X) X
+
+#include "image.h"
+#include "greycstoration.h"
+#include "plug_in.h"
+#include <libgimp/gimp.h>
+#include <libgimp/gimpui.h>
+#include <gtk/gtk.h>
+//----------------------------------------------------------------------------
+#define SCALE_WIDTH 125
+#define SCALE_DIGITS 3
+#define BOX_SPACING 6
+//----------------------------------------------------------------------------
+
+#define TABLE_SCALE(ROW, LABEL,TYPE,VALUE,MIN,MAX,DELTA1,DELTA2,DIGITS) \
+    { GtkObject *scale = gimp_scale_entry_new ( \
+			GTK_TABLE (table), 0, ROW, \
+			LABEL, SCALE_WIDTH, 0, \
+			VALUE, MIN, MAX, DELTA1, DELTA2, DIGITS, \
+			TRUE, 0, 0, \
+			NULL, NULL); \
+	g_signal_connect (scale, "value_changed", \
+			G_CALLBACK(gimp_##TYPE##_adjustment_update), &VALUE); \
+	g_signal_connect_swapped (scale, "value_changed", \
+			G_CALLBACK(gimp_preview_invalidate), preview); }
+
+//----------------------------------------------------------------------------
+
+GREYCstoration_params::GREYCstoration_params()
+{
+	nb_iter        = 1;
+	dt             = 20.0f;
+	sigma          = 1.4f;
+	dlength        = 0.8;
+	dtheta         = 45.0;
+	onormalize     = false;
+	power1         = 0.1;
+	power2         = 0.9;
+	gauss_prec     = 3.0f;
+	linear         = true;
+	onormalize     = false;
+	preview        = true;
+}
+
+//----------------------------------------------------------------------------
+
+GtkWidget* ajoute_param(
+		GtkObject *spinbutton_adj, 
+		GtkWidget *dst_box, 
+		const char *label_string,
+		int digits=0)
+{
+	GtkWidget *main_hbox;
+	GtkWidget *param_label;
+	GtkWidget *spinbutton;
+
+	/* Bo?te horizontale */
+	main_hbox = gtk_hbox_new (FALSE, BOX_SPACING);
+	gtk_widget_show (main_hbox);
+	gtk_container_add (GTK_CONTAINER(dst_box), main_hbox);
+
+	/* Param?tre : Texte */
+	param_label = gtk_label_new_with_mnemonic(label_string);
+	gtk_widget_show (param_label);
+	gtk_box_pack_start(GTK_BOX(main_hbox), param_label, FALSE, FALSE, 6);
+	gtk_label_set_justify (GTK_LABEL(param_label), GTK_JUSTIFY_RIGHT);
+
+	/* Param?tre : SpinButton */	
+	if (0 <= digits)
+	{
+		spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT(spinbutton_adj), 1, digits);
+		gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(spinbutton), TRUE);
+	} else {
+		spinbutton = gtk_check_button_new();
+	}
+	gtk_widget_show (spinbutton);
+	gtk_box_pack_start (GTK_BOX(main_hbox), spinbutton, FALSE, FALSE, 6);
+	if (digits < 0) return spinbutton; else return NULL;
+}
+
+//----------------------------------------------------------------------------
+
+void dialog_page1 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
+{
+	GtkWidget *page_label;   
+	GtkWidget *table;
+
+	// Create the table
+	table = gtk_table_new (5, 3, FALSE);
+	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
+	gtk_table_set_row_spacings (GTK_TABLE (table), 6);
+	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
+	gtk_widget_show (table);
+
+	// Insert table in a new notebook page
+	page_label = gtk_label_new (_("Restore"));
+	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), table, page_label);
+	gtk_widget_show (table);
+	
+	// Power1
+	TABLE_SCALE(0, _("_Detail factor (p1):"), float, params.power1, 0, 2, 0.1, 0.3, SCALE_DIGITS);
+	TABLE_SCALE(1, _("_Gradient factor (p2):"), float, params.power2, 0, 100, 0.1, 1, SCALE_DIGITS);
+	TABLE_SCALE(2, _("_Time step (dt):"), float, params.dt, 1, 300, 10, 25, SCALE_DIGITS);
+	TABLE_SCALE(3, _("_Blur (sigma):"), float, params.sigma, 0, 10, 0.2, 1, SCALE_DIGITS);
+	TABLE_SCALE(4, _("_Blur iterations (iter) :"), int, params.nb_iter, 1, 5, 1, 2, 0);
+}
+
+void dialog_page2 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
+{
+	GtkWidget *page_label;   
+	GtkWidget *vbox;
+	GtkWidget *table;
+
+	// New vbox
+	page_label = gtk_label_new (_("Quality"));
+	vbox = gtk_vbox_new (FALSE, BOX_SPACING);
+	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), vbox, page_label);
+	gtk_widget_show (vbox);
+
+	// linear checkbox
+	GtkWidget* check = ajoute_param(NULL, vbox, _("Use linear interpolation:"), -1);
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), params.linear);
+	g_signal_connect (check, "toggled",
+			G_CALLBACK(gimp_toggle_button_update), &params.linear);
+
+	// normalize checkbox
+	check = ajoute_param(NULL, vbox, _("Normalize picture to [0-255]:"), -1);
+	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), params.onormalize);
+	g_signal_connect (check, "toggled",
+			G_CALLBACK(gimp_toggle_button_update), &params.onormalize);	
+
+	// Create the table
+	table = gtk_table_new (3, 3, FALSE);
+	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
+	gtk_table_set_row_spacings (GTK_TABLE (table), 6);
+	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
+	gtk_widget_show (table);
+
+	// Insert table in the container
+	gtk_container_add (GTK_CONTAINER(vbox), table);
+	gtk_widget_show (table);
+
+	// Insert parameters into the table
+	TABLE_SCALE(0, _("_Angular step (da):"), float, params.dtheta, 5, 90, 5, 15, SCALE_DIGITS);
+	TABLE_SCALE(1, _("_Integral step (dt):"), float, params.dlength, 0.1, 10, 0.1, 0.5, SCALE_DIGITS);
+	TABLE_SCALE(2, _("_Gaussian precision (gauss):"), float, params.gauss_prec, 0.1, 10, 0.1, 0.5, SCALE_DIGITS);	
+}
+
+
+//----------------------------------------------------------------------------
+
+bool dialog(GREYCstoration_params &params, GimpDrawable *preview_src)
+{
+	GtkWidget *dialog;
+	GtkWidget *notebook;
+	GtkWidget *preview;
+	GtkWidget *main_vbox;
+
+	// New dialog
+	gimp_ui_init (PLUG_IN_NAME, false);
+	dialog = gimp_dialog_new(
+			_("GREYCstoration"), 
+			PLUG_IN_NAME,
+			NULL, (GtkDialogFlags)0,
+			gimp_standard_help_func, "plug-in-" PLUG_IN_NAME,
+			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+			GTK_STOCK_OK,     GTK_RESPONSE_OK,
+			NULL);
+
+	// Main vbox	
+	main_vbox = gtk_vbox_new (false, BOX_SPACING);
+	gtk_container_add (GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), main_vbox);
+	gtk_widget_show (main_vbox);
+
+	// Add preview 
+	preview = gimp_drawable_preview_new(preview_src, &params.preview);
+	gtk_container_add (GTK_CONTAINER(main_vbox), preview);
+	gtk_widget_show (preview);
+	g_signal_connect (preview, "invalidated",
+			G_CALLBACK(DoGREYCstoration), preview_src);
+
+	// Create notebook
+	notebook = gtk_notebook_new ();
+	gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook), GTK_POS_TOP);
+	gtk_container_add (GTK_CONTAINER (main_vbox), notebook);
+	gtk_widget_show (notebook);
+
+	// Create differents notebook pages
+	dialog_page1(params, notebook, preview);
+	dialog_page2(params, notebook, preview);
+
+	// Display dialog 
+	gtk_widget_show(dialog);
+	gboolean run = gimp_dialog_run(GIMP_DIALOG(dialog)) == GTK_RESPONSE_OK;
+	gtk_widget_destroy(dialog);
+	return run;
+}
+
+//----------------------------------------------------------------------------
+
+void process_flush()
+{
+	if (image.is_preview) {
+		gimp_drawable_preview_draw_region(
+				GIMP_DRAWABLE_PREVIEW(image.preview), 
+				&image.dst_rgn);
+	} else {
+		gimp_drawable_flush (image.drawable);
+		gimp_drawable_merge_shadow (image.drawable->drawable_id, TRUE);
+		gimp_drawable_update (image.drawable->drawable_id,
+				image.sel_x1, image.sel_y1, image.sel_width, image.sel_height);
+		if (image.run_mode != GIMP_RUN_NONINTERACTIVE) gimp_displays_flush ();
+	}
+}
+
+//----------------------------------------------------------------------------
+
+void set_params()
+{
+#define SET(X) greyc.X = greyc_params.X
+	SET(sigma);
+	SET(nb_iter);
+	SET(dt);
+	SET(dlength);
+	SET(power1);
+	SET(power2);
+	SET(onormalize);
+	SET(gauss_prec);
+	SET(linear);
+#undef SET
+}
+
+//----------------------------------------------------------------------------
+
+bool DoGREYCstoration(GimpPreview *preview, GimpDrawable *drawable)
+{
+	if (!gimp_drawable_is_rgb (drawable->drawable_id)) return false;
+	if (image.run_mode != GIMP_RUN_NONINTERACTIVE) 
+		gimp_progress_update (0);
+	image.init(drawable, preview);
+	set_params();
+	greyc.load_picture(image);
+	if (!greyc.process()) return false;
+	greyc.store_picture(image);
+	process_flush();	
+	return true;
+}
+
+//----------------------------------------------------------------------------
+

Added: greystoration_gimp/dialog.h
===================================================================
--- greystoration_gimp/dialog.h	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/dialog.h	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,51 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GREYCSTORATION_DIALOG_H
+#define GREYCSTORATION_DIALOG_H
+//----------------------------------------------------------------------------
+#include <libgimp/gimp.h>
+#include <libgimp/gimpui.h>
+//----------------------------------------------------------------------------
+
+typedef struct GREYCstoration_params
+{
+	gint nb_iter; // Number of smoothing iterations
+	gfloat dt;       // Time step
+	gfloat dlength; // Integration step
+	gfloat dtheta; // Angular step (in degrees)
+	gfloat sigma;  // Structure tensor blurring
+	gfloat power1; // Diffusion limiter along isophote
+	gfloat power2; // Diffusion limiter along gradient
+	gfloat gauss_prec; //  Precision of the gaussian function
+	gboolean onormalize; // Output image normalization (in [0,255])
+	gboolean linear; // Use linear interpolation for integration ?
+	gboolean preview; // Use preview ?
+	GREYCstoration_params();
+} GREYCstoration_params;
+
+extern GREYCstoration_params greyc_params;
+
+//----------------------------------------------------------------------------
+
+bool dialog(GREYCstoration_params &params, GimpDrawable *drawable);
+
+bool DoGREYCstoration(GimpPreview *preview, GimpDrawable *drawable);
+//----------------------------------------------------------------------------
+#endif

Added: greystoration_gimp/greycstoration.cpp
===================================================================
--- greystoration_gimp/greycstoration.cpp	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/greycstoration.cpp	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,592 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "greycstoration.h"
+//----------------------------------------------------------------------------
+using namespace cimg_library;
+typedef unsigned char uchar;
+
+// The line below is necessary for compilation with non-standart C++ compilers.
+#if (( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__))
+#  define std
+#endif
+//----------------------------------------------------------------------------
+
+void get_geom(const char *geom, int &geom_w, int &geom_h) 
+{
+	char tmp[16];
+	std::sscanf(geom,"%d%7[^0-9]%d%7[^0-9]",&geom_w,tmp,&geom_h,tmp+1);
+	if (tmp[0]=='%') geom_w=-geom_w;
+	if (tmp[1]=='%') geom_h=-geom_h;
+}
+
+//----------------------------------------------------------------------------
+
+GREYCstoration::GREYCstoration() : eigen(CImg<>(2,1), CImg<>(2,2))
+{
+	restore = true;
+	inpaint = false;
+	resize = false;
+	visuflow = NULL;
+
+	/* restore */
+	nb_iter        = 1;
+	dt             = 20.0f;
+	sigma          = 0.8f;
+	dlength        = 0.8;
+	dtheta         = 45.0;
+	onormalize     = false;
+	power1         = 0.5;
+	power2         = 0.9;
+
+	/* inpainting *
+	nb_iter                    = 100;
+	dt                         = 50.0f;
+	sigma                      = 2.0;
+	power1                     = 0.1;
+	power2                     = 100;
+	dlength                    = 0.8;
+	dtheta                     = 45.0;
+	 */
+
+	/* resize *
+	nb_iter           = 1;
+	dt                = 30.0f;
+	sigma             = 2.0;
+	dlength           = 0.8;
+	dtheta            = 45.0;
+	power1            = 0.01;
+	power2            = 100.0;
+	 */
+
+	/* visualflow *
+	nb_iter              = 1;
+	dt                   = 30.0f;
+	dlength              = 0.5;
+	dtheta               = 20.0;
+	onormalize = false;
+	*/
+	
+	gauss_prec  = 3.0f;
+	linear = true;
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::cleanup()
+{
+	img0 = flow = G = dest = sum= W = CImg<>();	
+	mask = CImg<uchar> ();
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::prepare()
+{
+	if (!restore && !inpaint && !resize && !visuflow) 
+	{
+		g_message ("You must specify one of the restore, inpaint, resize or flow mode !");
+		return false;
+	}
+
+	// Init algorithm parameters
+	//---------------------------
+	if (restore) if (!prepare_restore()) return false;
+	if (inpaint) if (!prepare_inpaint()) return false;
+	if (resize) if (!prepare_resize()) return false;
+	if (visuflow) if (!prepare_visuflow()) return false;
+
+	if (!check_args()) return false;
+
+	// Init images
+	//------------
+	dest = CImg<>(img.width,img.height,1,img.dim);
+	sum = CImg<>(img.width,img.height,1);
+	W = CImg<>(img.width,img.height,1,2);
+	
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::check_args()
+{
+	if (power2 < power1)
+	{
+		g_message ("Error : p2<p1 !");
+		return false;
+	}
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::prepare_restore()
+{
+	CImgStats stats(img,false);
+	img.normalize((float)stats.min, (float)stats.max);
+	img0=img;
+	G = CImg<>(img.width,img.height,1,3);
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::prepare_inpaint()
+{
+	const char *file_m         = NULL; //cimg_option("-m",(const char*)NULL,"Input inpainting mask");
+	if (!file_m) 
+	{
+		g_message ("You need to specify an inpainting mask (option '-m') !");
+		return false;
+	}
+
+	const unsigned int dilate  = 0; //cimg_option("-dilate",0,"Inpainting mask dilatation");
+	const unsigned int ip_init = 3; //cimg_option("-init",3,"Inpainting init (0=black, 1=white, 2=noise, 3=unchanged, 4=interpol)");
+	if (cimg::strncasecmp("block",file_m,5)) mask = CImg<uchar>(file_m);
+	else {
+		int l=16; std::sscanf(file_m,"block%d",&l);
+		mask = CImg<uchar>(img.width/l,img.height/l);
+		cimg_mapXY(mask,x,y) mask(x,y)=(x+y)%2;
+	}
+	mask.resize(img.width,img.height,1,1);
+	if (dilate) mask.dilate(dilate);
+	switch (ip_init) {
+		case 0 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 0; } break;
+		case 1 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 255; } break;
+		case 2 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = (float)(255*cimg::rand()); } break;
+		case 3 : break;
+		case 4 : {
+					 CImg<uchar> tmask(mask),ntmask(tmask);
+					 CImg_3x3(M,uchar);
+					 CImg_3x3(I,float);
+					 while (CImgStats(ntmask,false).max>0) {
+						 cimg_map3x3(tmask,x,y,0,0,M) if (Mcc && (!Mpc || !Mnc || !Mcp || !Mcn)) {
+							 const float ccp = Mcp?0.0f:1.0f, cpc = Mpc?0.0f:1.0f,
+								   cnc = Mnc?0.0f:1.0f, ccn = Mcn?0.0f:1.0f, csum = ccp + cpc + cnc + ccn;
+							 cimg_mapV(img,k) {
+								 cimg_get3x3(img,x,y,0,k,I);
+								 img(x,y,k) = (ccp*Icp + cpc*Ipc + cnc*Inc + ccn*Icn)/csum;
+							 }
+							 ntmask(x,y) = 0;
+						 }
+						 tmask = ntmask;
+					 }
+				 } break;    
+		default: break;
+	}
+	img0=img;
+	G = CImg<>(img.width,img.height,1,3,0);
+	CImg_3x3(g,uchar);
+	CImg_3x3(I,float);
+	cimg_map3x3(mask,x,y,0,0,g) if (!gcc && !(gnc-gcc) && !(gcc-gpc) && !(gcn-gcc) && !(gcc-gcp)) cimg_mapV(img,k) {
+		cimg_get3x3(img,x,y,0,k,I);
+		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
+		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
+	}
+	G.blur(sigma);
+	{ cimg_mapXY(G,x,y) 
+		{
+			G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
+			const float
+				l1 = eigen(0)[0],
+				   l2 = eigen(0)[1],
+				   u = eigen(1)[0],
+				   v = eigen(1)[1],      
+				   ng = (float)std::sqrt(l1+l2),
+				   n1 = (float)(1.0/std::pow(1+ng,power1)),
+				   n2 = (float)(1.0/std::pow(1+ng,power2)),
+				   sr1 = (float)std::sqrt(n1),
+				   sr2 = (float)std::sqrt(n2);
+			G(x,y,0) = sr1*u*u + sr2*v*v;
+			G(x,y,1) = u*v*(sr1-sr2);
+			G(x,y,2) = sr1*v*v + sr2*u*u;
+		}    
+	}
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::prepare_resize()
+{
+	const char *geom  = NULL; //cimg_option("-g",(const char*)NULL,"Output image geometry");
+	const bool anchor = true; //cimg_option("-anchor",true,"Anchor original pixels");
+	if (!geom) throw CImgArgumentException("You need to specify an output geomety (option -g)");
+	int w,h; get_geom(geom,w,h);
+	mask = CImg<uchar>(img.width,img.height,1,1,255);
+	if (!anchor) mask.resize(w,h,1,1,1); else mask = ~mask.resize(w,h,1,1,4);
+	img0 = img.get_resize(w,h,1,-100,1);
+	img.resize(w,h,1,-100,3);
+	G = CImg<>(img.width,img.height,1,3);
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::prepare_visuflow()
+{
+	const char *geom     = "100%x100%"; //cimg_option("-g","100%x100%","Output geometry");
+	//const char *file_i   = (const char *)NULL; //cimg_option("-i",(const char*)NULL,"Input init image");
+	const bool normalize = false; //cimg_option("-norm",false,"Normalize input flow");
+
+	int w,h; get_geom(geom,w,h);
+	if (!cimg::strcasecmp(visuflow,"circle")) { // Create a circular vector flow
+		flow = CImg<>(400,400,1,2);
+		cimg_mapXY(flow,x,y) {
+			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
+			flow(x,y,0) = -(float)std::sin(ang);
+			flow(x,y,1) = (float)std::cos(ang);
+		}
+	}
+	if (!cimg::strcasecmp(visuflow,"radial")) { // Create a radial vector flow
+		flow = CImg<>(400,400,1,2);
+		cimg_mapXY(flow,x,y) {
+			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
+			flow(x,y,0) = (float)std::cos(ang);
+			flow(x,y,1) = (float)std::sin(ang);
+		}
+	}
+	if (!flow.data) flow = CImg<>(visuflow);
+	flow.resize(w,h,1,2,3);
+	if (normalize) flow.orientation_pointwise();
+	/*    if (file_i) img = CImg<>(file_i);
+		  else img = CImg<>(flow.width,flow.height,1,1,0).noise(100,2); */
+	img0=img;
+	img0.fill(0);
+	float color[3]={255,255,255};
+	img0.draw_quiver(flow,color,15,-10);
+	G = CImg<>(img.width,img.height,1,3);
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::compute_smoothed_tensor()
+{
+	if (visuflow || inpaint) return;
+	CImg_3x3(I,float);
+	G.fill(0);
+	cimg_mapV(img,k) cimg_map3x3(img,x,y,0,k,I) {
+		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
+		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
+	}
+	G.blur(sigma);
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::compute_normalized_tensor()
+{
+	if (restore || resize) cimg_mapXY(G,x,y) {
+		G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
+		const float
+			l1 = eigen(0)[0],
+			   l2 = eigen(0)[1],
+			   u = eigen(1)[0],
+			   v = eigen(1)[1],      
+			   n1 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power1)),
+			   n2 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power2));
+		G(x,y,0) = n1*u*u + n2*v*v;
+		G(x,y,1) = u*v*(n1-n2);
+		G(x,y,2) = n1*v*v + n2*u*u;
+	}    
+	if (visuflow) cimg_mapXY(G,x,y) {
+		const float 
+			u = flow(x,y,0),
+			  v = flow(x,y,1),
+			  n = (float)std::pow(u*u+v*v,0.25f),
+			  nn = n<1e-5?1:nn;
+		G(x,y,0) = u*u/nn;
+		G(x,y,1) = u*v/nn;
+		G(x,y,2) = v*v/nn;
+	}
+
+	const CImgStats stats(G,false);
+	G /= cimg::max(std::fabs(stats.max), std::fabs(stats.min));
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::compute_W(float cost, float sint)
+{
+	cimg_mapXY(W,x,y) {
+		const float 
+			a = G(x,y,0),
+			  b = G(x,y,1),
+			  c = G(x,y,2),
+			  u = a*cost + b*sint,
+			  v = b*cost + c*sint;
+		W(x,y,0) = u;
+		W(x,y,1) = v;
+	}
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::compute_LIC_back_forward(int x, int y)
+{
+	float l, X,Y, cu, cv, lsum=0;
+	const float fsigma2 = 2*dt*(W(x,y,0)*W(x,y,0) + W(x,y,1)*W(x,y,1));
+	const float length = gauss_prec*(float)std::sqrt(fsigma2);
+
+	if (linear) {
+
+		// Integrate with linear interpolation
+		cu = W(x,y,0); 
+		cv = W(x,y,1); 
+		X  = (float)x; 
+		Y  = (float)y;
+		for (l=0; l<length; l+=dlength) 
+		{
+			float u = (float)W.linear_pix2d(X,Y,0);
+			float v = (float)W.linear_pix2d(X,Y,1);
+			const float coef = (float)std::exp(-l*l/fsigma2);
+			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
+			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
+			lsum+=coef;
+			X+=dlength*u;
+			if ((X<0) || ((W.dimx()-1) < X)) break;
+			Y+=dlength*v; 
+			if ((Y<0) || ((W.dimy()-1) < Y)) break;
+			cu=u; 
+			cv=v; 
+		}
+		
+		cu = W(x,y,0); 
+		cv = W(x,y,1); 
+		X  = x-dlength*cu; 
+		Y  = y-dlength*cv;
+		for (l=dlength; l<length; l+=dlength) 
+		{
+			float u = (float)W.linear_pix2d(X,Y,0);
+			float v = (float)W.linear_pix2d(X,Y,1);
+			const float coef = (float)std::exp(-l*l/fsigma2);
+			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
+			cimg_mapV(dest,k) dest(x,y,k)+=(float)(coef*img.linear_pix2d(X,Y,k));
+			lsum+=coef;
+			X-=dlength*u;
+			if ((X<0) || ((W.dimx()-1) < X)) break;
+			Y-=dlength*v;
+			if ((Y<0) || ((W.dimy()-1) < Y)) break;
+			cu=u;
+			cv=v;
+		}
+
+	} else {
+
+		// Integrate with non linear interpolation
+		cu = W(x,y,0); 
+		cv = W(x,y,1); 
+		X  = (float)x; 
+		Y  = (float)y; 
+		for (l=0; l<length; l+=dlength) 
+		{
+			float u = W((int)X,(int)Y,0);
+			float v = W((int)X,(int)Y,1);
+			const float coef = (float)std::exp(-l*l/fsigma2);
+			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
+			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
+			lsum+=coef;
+			X+=dlength*u; 
+			if ((X<0) || ((W.dimx()-1) < X)) break;
+			Y+=dlength*v; 
+			if ((Y<0) || ((W.dimy()-1) < Y)) break;
+			cu=u; 
+			cv=v; 
+		}
+		
+		cu = W(x,y,0); 
+		cv = W(x,y,1); 
+		X  = x-dlength*cu; 
+		Y  = y-dlength*cv;
+		for (l=dlength; l<length && X>=0 && Y>=0 && X<=W.dimx()-1 && Y<=W.dimy()-1; l+=dlength) 
+		{
+			float u = W((int)X,(int)Y,0);
+			float v = W((int)X,(int)Y,1);
+			const float coef = (float)std::exp(-l*l/fsigma2);
+			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
+			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
+			lsum+=coef;
+			X-=dlength*u; 
+			if ((X<0) || ((W.dimx()-1) < X)) break;
+			Y-=dlength*v;
+			if ((Y<0) || ((W.dimy()-1) < Y)) break;
+			cu=u; 
+			cv=v; 
+		}
+	}
+	sum(x,y)+=lsum;
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::compute_LIC(int &counter)
+{
+	dest.fill(0);
+	sum.fill(0);
+	for (float theta=(180%(int)dtheta)/2.0f; theta<180; theta+=dtheta) 
+	{
+		const float
+			rad = (float)(theta*cimg::PI/180.0),
+				cost = (float)std::cos(rad),
+				sint = (float)std::sin(rad);
+
+		// Compute vector field w = sqrt(T)*a_alpha
+		compute_W(cost, sint);
+
+		// Compute the LIC along w in backward and forward directions
+		cimg_mapXY(dest,x,y) 
+		{
+			counter++;
+			if (image.use_progress && !((counter)%150)) 
+			{
+				gdouble progress = counter;
+				progress /= (gdouble)dest.width*dest.height*nb_iter*(180/dtheta);
+				gimp_progress_update (progress);
+			}
+			
+			if (!mask.data || mask(x,y)) compute_LIC_back_forward(x,y);
+		}
+	}
+
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::compute_average_LIC()
+{
+	cimg_mapXY(dest,x,y) 
+	{
+		if (sum(x,y)>0) 
+			cimg_mapV(dest,k) dest(x,y,k) /= sum(x,y); 
+		else 
+			cimg_mapV(dest,k) dest(x,y,k) = img(x,y,k);
+	}
+}
+
+//----------------------------------------------------------------------------
+
+bool GREYCstoration::process()
+{
+	if (!prepare()) return false;
+
+	//-------------------------------------
+	// Begin regularization PDE iterations
+	//-------------------------------------
+	int counter = 0;
+	for (unsigned int iter=0; iter<nb_iter; iter++) 
+	{
+		// Compute smoothed structure tensor field G
+		compute_smoothed_tensor();
+
+		// Compute normalized tensor field sqrt(T) in G
+		compute_normalized_tensor();
+
+		// Compute LIC's along different angle projections a_\alpha
+		compute_LIC(counter);
+
+		// Average all the LIC's
+		compute_average_LIC();
+
+		// Next step
+		img = dest;
+	}
+
+	// Save result and end program
+	//-----------------------------
+	if (visuflow) dest.mul(flow.get_norm_pointwise()).normalize(0,255);
+	if (onormalize) dest.normalize(0,255);
+	cleanup();
+	return true;
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::load_picture(Image &cfg)
+{
+	guchar* row = g_new (guchar, cfg.width), *row_ptr;
+
+	img = CImg<>(cfg.sel_width, cfg.sel_height, 1, 3);
+
+	for (gint y=0; y < cfg.sel_height; y++)
+	{
+		gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
+		row_ptr = row;
+		if (image.img_alpha) {
+			for (gint x=0; x<cfg.sel_width; x++) 
+			{
+				img(x, y,0) = row_ptr[0];
+				img(x, y,1) = row_ptr[1];
+				img(x, y,2) = row_ptr[2];
+				row_ptr += 4;
+			}	
+		} else {
+			for (gint x=0; x<cfg.sel_width; x++) 
+			{
+				img(x, y,0) = row_ptr[0];
+				img(x, y,1) = row_ptr[1];
+				img(x, y,2) = row_ptr[2];
+				row_ptr += 3;
+			}	
+		}
+	}
+	g_free (row);
+}
+
+//----------------------------------------------------------------------------
+
+void GREYCstoration::store_picture(Image &cfg)
+{
+	guchar* row = g_new (guchar, cfg.width), *row_ptr;
+
+	if (image.img_alpha)
+	{
+		for (gint y=0; y < cfg.sel_height; y++)
+		{
+			gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
+			row_ptr = row;
+			for (gint x=0; x<cfg.sel_width; x++) 
+			{
+				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
+				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
+				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
+				row_ptr += 4;
+			}
+			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
+		}
+	} else {
+		for (gint y=0; y < cfg.sel_height; y++)
+		{
+			row_ptr = row;
+			for (gint x=0; x<cfg.sel_width; x++) 
+			{
+				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
+				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
+				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
+				row_ptr += 3;
+			}
+			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
+		}
+	}
+
+	g_free (row);
+}
+
+//----------------------------------------------------------------------------

Added: greystoration_gimp/greycstoration.h
===================================================================
--- greystoration_gimp/greycstoration.h	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/greycstoration.h	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,90 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GREYCSTORATION_CLASS_H
+#define GREYCSTORATION_CLASS_H
+//----------------------------------------------------------------------------
+#include "CImg.h"
+#include "image.h"
+//----------------------------------------------------------------------------
+
+class GREYCstoration
+{
+public:
+	// parameters
+	unsigned int nb_iter; // Number of smoothing iterations
+	float dt;       // Time step
+	float dlength; // Integration step
+	float dtheta; // Angular step (in degrees)
+	float sigma;  // Structure tensor blurring
+	float power1; // Diffusion limiter along isophote
+	float power2; // Diffusion limiter along gradient
+	float gauss_prec; //  Precision of the gaussian function
+	bool onormalize; // Output image normalization (in [0,255])
+	bool linear; // Use linear interpolation for integration
+
+private:
+	// internal use
+	bool restore;
+	bool inpaint;
+	bool resize;
+	const char* visuflow;
+	cimg_library::CImg<> dest, sum, W;
+	cimg_library::CImg<> img, img0, flow,G;
+	cimg_library::CImgl<> eigen;
+	cimg_library::CImg<unsigned char> mask;
+
+public:
+	GREYCstoration();
+	void load_picture(Image& image);
+	void store_picture(Image& image);
+	bool process();
+
+private:
+	// Compute smoothed structure tensor field G
+	void compute_smoothed_tensor();
+	
+	// Compute normalized tensor field sqrt(T) in G
+	void compute_normalized_tensor();
+	
+	// Compute LIC's along different angle projections a_\alpha
+	void compute_LIC(int &counter);
+	void compute_LIC_back_forward(int x, int y);
+	void compute_W(float cost, float sint);
+	
+	// Average all the LIC's
+	void compute_average_LIC();
+
+	// Prepare datas
+	bool prepare();
+	bool prepare_restore();
+	bool prepare_inpaint();
+	bool prepare_resize();
+	bool prepare_visuflow();
+
+	// Check arguments
+	bool check_args();
+
+	// Clean up memory (CImg datas) to save memory
+	void cleanup();
+};
+
+extern GREYCstoration greyc;
+//----------------------------------------------------------------------------
+#endif

Added: greystoration_gimp/image.cpp
===================================================================
--- greystoration_gimp/image.cpp	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/image.cpp	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,58 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "image.h"
+//----------------------------------------------------------------------------
+
+Image::Image()
+{
+	drawable = NULL;
+	run_mode = GIMP_RUN_NONINTERACTIVE;
+}
+
+//----------------------------------------------------------------------------
+
+void Image::init(GimpDrawable *pdrawable, GimpPreview *ppreview)
+{
+	drawable = pdrawable;
+	preview = ppreview;
+	if (ppreview) {
+		is_preview = true;
+		gimp_preview_get_position(preview, &sel_x1, &sel_y1);
+		gimp_preview_get_size(preview, &sel_width, &sel_height);
+		sel_x2 = sel_x1 + sel_width;	
+		sel_y2 = sel_y1 + sel_height;	
+	} else {
+		is_preview = false;
+		gimp_drawable_mask_bounds (drawable->drawable_id,
+				&sel_x1, &sel_y1, &sel_x2, &sel_y2);
+		sel_width  = sel_x2 - sel_x1;
+		sel_height = sel_y2 - sel_y1;
+	}
+	img_bpp   = gimp_drawable_bpp (drawable->drawable_id);
+	img_alpha = gimp_drawable_has_alpha (drawable->drawable_id);
+	gimp_pixel_rgn_init (&src_rgn, drawable,
+			sel_x1, sel_y1, sel_width, sel_height, FALSE, FALSE);
+	gimp_pixel_rgn_init (&dst_rgn, drawable,
+			sel_x1, sel_y1, sel_width, sel_height, !is_preview, TRUE);
+	width = sel_width * img_bpp;
+	use_progress = (run_mode != GIMP_RUN_NONINTERACTIVE) && !is_preview;
+}
+
+//----------------------------------------------------------------------------

Added: greystoration_gimp/image.h
===================================================================
--- greystoration_gimp/image.h	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/image.h	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,52 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GREYCSTORATION_IMAGE_H
+#define GREYCSTORATION_IMAGE_H
+//----------------------------------------------------------------------------
+#include <libgimp/gimp.h>
+#include <libgimp/gimpui.h>
+//----------------------------------------------------------------------------
+
+class Image
+{
+public:
+	GimpDrawable *drawable;   /* Current image */
+	GimpPixelRgn src_rgn, dst_rgn;
+	gint       sel_x1;               /* Selection bounds */
+	gint       sel_y1;
+	gint       sel_x2;
+	gint       sel_y2;
+	gint       sel_width;            /* Selection width */
+	gint       sel_height;           /* Selection height */
+	gint       img_bpp;              /* Bytes-per-pixel in image */
+	bool		img_alpha;
+	guint		width;
+	bool		is_preview;
+	GimpPreview*	preview;
+	bool 		use_progress;
+	GimpRunMode run_mode;
+public:
+	Image();
+	void init(GimpDrawable *drawable, GimpPreview *preview);
+};
+
+extern Image image;
+//----------------------------------------------------------------------------
+#endif

Added: greystoration_gimp/main.cpp
===================================================================
--- greystoration_gimp/main.cpp	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/main.cpp	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,135 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <libgimp/gimp.h>
+#include "plug_in.h"
+#include "dialog.h"
+#include "greycstoration.h"
+//----------------------------------------------------------------------------
+GREYCstoration greyc;
+GREYCstoration_params greyc_params;
+Image image;
+//----------------------------------------------------------------------------
+
+static void query(void);
+static void run (const gchar* name,
+		gint nparams,
+		const GimpParam* param,
+		gint* nreturn_vals,
+		GimpParam** return_vals);
+
+//----------------------------------------------------------------------------
+
+GimpPlugInInfo PLUG_IN_INFO = 
+{
+	NULL,
+	NULL,
+	query,
+	run
+};
+
+//----------------------------------------------------------------------------
+
+MAIN()
+
+//----------------------------------------------------------------------------
+
+static void query(void)
+{
+	static GimpParamDef args[] =
+	{
+		{
+			GIMP_PDB_INT32,
+			"run_mode",
+			"Run mode"
+		},{
+			GIMP_PDB_IMAGE,
+			"image",
+			"Input image"
+		},{
+			GIMP_PDB_DRAWABLE,
+			"drawable",
+			"Input drawable"
+		}
+	};
+	gimp_install_procedure (
+			"plug_in_hello",
+			PLUG_IN_NAME,
+			"Filtre Greystoration",
+			"Victor STINNER",
+			"Copyright Victor STINNER",
+			"2005",
+			"<Image>/Filters/Misc/_GREYCstoration",
+			"RGB*", //GRAY*
+			GIMP_PLUGIN,
+			G_N_ELEMENTS(args), 0,
+			args, NULL);
+}
+
+//----------------------------------------------------------------------------
+
+static void run (const gchar* name,
+		gint nparams,
+		const GimpParam* param,
+		gint* nreturn_vals,
+		GimpParam** return_vals)
+{
+	static GimpParam values[1];
+	GimpPDBStatusType status = GIMP_PDB_SUCCESS;
+
+	/* Mise en place d'une valeur obligatoire de retour */
+	*nreturn_vals = 1;
+	*return_vals = values;
+
+	values[0].type = GIMP_PDB_STATUS;
+	values[0].data.d_status = status;
+
+	image.run_mode = static_cast<GimpRunMode> (param[0].data.d_int32);
+	GimpDrawable *drawable = gimp_drawable_get (param[2].data.d_drawable);
+	
+	switch (image.run_mode)
+	{
+		case GIMP_RUN_INTERACTIVE:
+			gimp_get_data("plug_in_" PLUG_IN_NAME, &greyc_params);
+			if (!dialog(greyc_params, drawable)) return;
+			gimp_set_data("plug_in_" PLUG_IN_NAME, &greyc_params, sizeof(greyc_params));
+			break;
+			
+		case GIMP_RUN_NONINTERACTIVE:
+return;
+			break;
+
+		case GIMP_RUN_WITH_LAST_VALS:
+			gimp_get_data("plug_in_" PLUG_IN_NAME, &greyc_params);
+			break;
+		default: return;
+	}
+
+	if (!DoGREYCstoration(NULL, drawable)) 
+	{
+		if (image.run_mode != GIMP_RUN_NONINTERACTIVE)
+			g_message ("Erreur !?");
+		status = GIMP_PDB_EXECUTION_ERROR;
+		values[0].data.d_status = status;
+	}
+	gimp_drawable_detach (drawable);
+}
+
+//----------------------------------------------------------------------------
+

Added: greystoration_gimp/plug_in.h
===================================================================
--- greystoration_gimp/plug_in.h	2005-09-07 17:13:52 UTC (rev 121)
+++ greystoration_gimp/plug_in.h	2005-09-07 17:16:19 UTC (rev 122)
@@ -0,0 +1,25 @@
+/* GREYCstoration Gimp plugin
+ * Copyright (C) 2005 Victor Stinner and David Tschumperl?
+ *
+ * This plug-in is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GREYCSTORATION_PLUGIN_H
+#define GREYCSTORATION_PLUGIN_H
+//----------------------------------------------------------------------------
+#define PLUG_IN_NAME "greycstoration"
+//----------------------------------------------------------------------------
+#endif



From haypo at berlios.de  Sat Sep 10 02:19:08 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 10 Sep 2005 02:19:08 +0200
Subject: [Happyboom-svn] r134 - poilu/trunk
Message-ID: <200509100019.j8A0J8Ig021001@sheep.berlios.de>

Author: haypo
Date: 2005-09-10 02:19:03 +0200 (Sat, 10 Sep 2005)
New Revision: 134

Modified:
   poilu/trunk/dico.txt
   poilu/trunk/dico_poilu.py
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
Log:
Automaticly detect charset, fix stupid bugs.


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-09 02:40:58 UTC (rev 133)
+++ poilu/trunk/dico.txt	2005-09-10 00:19:03 UTC (rev 134)
@@ -74,6 +74,7 @@
 teigneux
 thorax
 tibia
+tongues
 touffes
 tout nu
 toutou

Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-09 02:40:58 UTC (rev 133)
+++ poilu/trunk/dico_poilu.py	2005-09-10 00:19:03 UTC (rev 134)
@@ -18,6 +18,9 @@
         self.charge_muet()
         self.charge_dico()
 
+    def echou(self, message):
+        self.bot.echou(message)
+        
     def echo(self, message):
         self.bot.echo(message)
         
@@ -36,7 +39,7 @@
         if fin==None: return None
         if not self.dico.has_key(fin): return None
         if not terme in self.dico[fin]: return None
-        self.echo("Supprime le mot %s" %(terme))
+        self.echou(u"Supprime le mot %s" %(terme))
         self.dico[fin].remove(terme)
         return True
 
@@ -89,7 +92,7 @@
             fin = item[0]
             expr = item[1]
             if re.compile(expr).search(str) != None: return fin
-        self.echo ("Je n'ai pas trouv? la terminaison de \"%s\" !" %( unicode2term(str) ))
+        self.echou(u"Je n'ai pas trouv? la terminaison de \"%s\" !" %( str ))
         return None 
 
     def reponse(self, str):

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-09 02:40:58 UTC (rev 133)
+++ poilu/trunk/pypoil.py	2005-09-10 00:19:03 UTC (rev 134)
@@ -43,13 +43,9 @@
 
     def get_command(self, e): 
         cmd = e.arguments()[0]
-        if self.utf8_chan: 
-            try:
-                cmd=unicode(cmd, "utf-8")
-            except:
-                self.echo("Et?s-vous s?r d'?tre en UTF-8 ?")
-                cmd=unicode(cmd, "latin-1")
-        else:
+        try:
+            cmd=unicode(cmd, "utf-8")
+        except:
             cmd=unicode(cmd, "iso-8859-1")
         return cmd.strip() 
 
@@ -67,7 +63,7 @@
         self.echou(u"- join #chan / leave #chan : joint/quitte le canal #<chan>")
         self.echou(u"- nick xxx                 : change de surnom")
         self.echou(u"- backup                   : sauve toutes les donn?es sur le disque dur")
-        self.echou(u"- utf-8 / iso              : passe en UTF-8 / iso-8859-1")
+        self.echou(u"- utf-8 / iso              : parle en UTF-8 / iso-8859-1")
         self.echou(u"- muet                     : liste des caract?res muets")
         self.echou(u"- taux_reponse xxx         : fixe le taux de r?ponse (en pourcent)")
 
@@ -174,7 +170,7 @@
             return True
 
         if cmd == "iso":
-            if self.utf8_chan==True: self.echo("Passe en ISO-XXXX-X")
+            if self.utf8_chan==True: self.echo("Passe en ISO-8859-1")
             self.utf8_chan = False 
             return True
             

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-09 02:40:58 UTC (rev 133)
+++ poilu/trunk/terminaison.txt	2005-09-10 00:19:03 UTC (rev 134)
@@ -1,3 +1,4 @@
+gue:gues?$
 ied:(ied[s]?|[ps]ier)$
 air:(ier(re)?s?|erre|??re|aire|ert)$
 or:(aur(es?)?|or[tes]?)$



From haypo at berlios.de  Tue Sep 13 15:00:09 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 13 Sep 2005 15:00:09 +0200
Subject: [Happyboom-svn] r135 - boomboom boomboom/server happyboom/trunk/server poilu/trunk
Message-ID: <200509131300.j8DD09PX003349@sheep.berlios.de>

Author: haypo
Date: 2005-09-13 15:00:06 +0200 (Tue, 13 Sep 2005)
New Revision: 135

Modified:
   boomboom/boomboom_server.py
   boomboom/server/bb_server.py
   happyboom/trunk/server/base_server.py
   poilu/trunk/dico.txt
Log:
Le code du serveur BoomBoom est deplace dans HappyBoom. Le serveur HappyBoom
est decoupe est trois parties : Gateway, ClientManager, Server. Debut
d'implementation du nouveau protocole.


Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-10 00:19:03 UTC (rev 134)
+++ boomboom/boomboom_server.py	2005-09-13 13:00:06 UTC (rev 135)
@@ -30,8 +30,8 @@
     try:
         short = "hdv"
         long = ["debug", "verbose", "help", "version", \
-            "max-input=", "max-display=", \
-            "display-port=", "input-port="]
+            "max-clients=",
+            "client-port="]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage(def_val)
@@ -48,32 +48,15 @@
         if o == "--version":
             print "%s server version %s" % (PROGRAM, VERSION)
             sys.exit()
-        if o == "--input-port":
+        if o == "--client-port":
+            val["client_port"] = int(a)
+        if o == "--max-clients":
             a = int(a)
-            if a == val["displayPort"]:
-                print "Sorry, input port should be different than display port!"
-            else:
-                val["inputPort"] = a             
-        if o == "--display-port":
-            a = int(a)
-            if a == val["inputPort"]:
-                print "Sorry, display port should be different than input port!"
-            else:
-                val["displayPort"] = a 
-        if o == "--max-input":
-            a = int(a)
             if a < 1: 
-                a=1
+                a = 1
             elif 100 < a:
                 a = 100
-            val["maxInput"] = a
-        if o == "--max-display":
-            a = int(a)
-            if a < 1: 
-                a=1
-            elif 100 < a:
-                a = 100
-            val["maxDisplay"] = a
+            val["max_clients"] = a
         if o in ("-v", "--verbose"):
             val["verbose"] = True
         if o in ("-d", "--debug"):
@@ -81,23 +64,25 @@
     return val
 
 def run():
-    # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
+    # Add HappyBoom to PYTHONPATH
     import sys, os
     file_dir = os.path.dirname(__file__)
-    happyboomdir = os.path.join(file_dir, "../happyboom/trunk")
+    happyboomdir = os.path.join(file_dir, "..", "happyboom", "trunk")
     sys.path.append(happyboomdir)
     
+    # Add HappyBoom/server to PYTHONPATH
+    happyboomserverdir = os.path.join(happyboomdir, "server")
+    sys.path.append(happyboomserverdir)
+    
     val = { \
-        "displayPort": 12430, \
-        "inputPort": 12431, \
-        "maxInput": 4, \
-        "maxDisplay": 4, \
+        "input_port": 12430,
+        "max_clients": 4,
         "verbose": False,
         "debug": False}
     arg = parseArgs(val)
     
     from server import BoomBoomServer
-    server = BoomBoomServer(**arg)
+    server = BoomBoomServer(arg)
 
     try:
         server.start()

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-10 00:19:03 UTC (rev 134)
+++ boomboom/server/bb_server.py	2005-09-13 13:00:06 UTC (rev 135)
@@ -1,326 +1,75 @@
-from bb_agent import BoomBoomAgent, BoomBoomMessage
 from agents import Character, Projectile, Weapon, World, Game
-from net import io, io_udp, io_tcp, net_buffer
-from pysma import Kernel, DummyScheduler
-import re, random, thread, traceback, time
+from base_server import HappyBoomServer, HappyBoomGateway, HappyBoomMessage
+from pysma import Kernel
 
-class BoomBoomServer(BoomBoomAgent):
-	def __init__(self, maxDisplay=2, displayPort=12430, maxInput=2, inputPort=12431, verbose=False, debug=False):
-		BoomBoomAgent.__init__(self, "network")
-		self.__display_io = io_tcp.IO_TCP(is_server=True)
-		self.__input_io = io_tcp.IO_TCP(is_server=True)
-		self.__input_buffer = net_buffer.NetBuffer()
-		self.__display_buffer = net_buffer.NetBuffer()
-		self.__input_protocol_version = "0.1.4"
-		self.__display_protocol_version = "0.1.4"
-		self.__debug = debug
-		self.__display_io.debug = debug
-		self.__input_io.debug = debug
-		self.__verbose = verbose
-		self.__display_io.verbose = verbose
-		self.__input_io.verbose = verbose
-		self.__inputs = []
-		self.__items = []
-		self.__stopped = False
-		self.__stoplock = thread.allocate_lock()
-		self.__supportedFeatures = {}
-		self.maxDisplay = maxDisplay
-		self.displayPort = displayPort
-		self.maxInput = maxInput
-		self.inputPort = inputPort
-		self.started = False
-		self.nextChar = None
-		random.seed()
-		Kernel().addAgent(DummyScheduler(sleep=0.01))
-		
-	def born(self):
-		BoomBoomAgent.born(self)
-		self.requestActions("game")
-		self.requestActions("weapon")
-		self.requestActions("character")
-		self.requestActions("world")
-		self.requestActions("projectile")
-		
-	def start(self):
-		if self.__verbose: print "[*] Starting server..."
-		self.initIO()
-		self.createAgents()
-		print "[*] Server started"
-		
-		self.__stoplock.acquire()
-		running = not self.__stopped
-		self.__stoplock.release()
-		while running:
-			self.processInputs()
-			time.sleep(0.01)
-			self.__stoplock.acquire()
-			running = not self.__stopped
-			self.__stoplock.release()
+class BoomBoomGateway(HappyBoomGateway):
+    def __init__(self, server, arg):
+        HappyBoomGateway.__init__(self, server, arg)
 
-	def stop(self):
-		self.__stoplock.acquire()
-		if self.__stopped:
-			self.__stoplock.release()
-			return
-		self.__stopped = True
-		self.__stoplock.release()
-		print "[*] Stopping server..."
-		Kernel.instance.stopKernel()
-		self.sendNetworkMessage("game", "Stop", skippable=True)
-		self.__display_io.stop()
-		self.__input_io.stop()
-		if self.__verbose: print "[*] Server stopped"
+    def born(self):
+        HappyBoomGateway.born(self)
+        self.requestActions("game")
+        self.requestActions("weapon")
+        self.requestActions("character")
+        self.requestActions("world")
+        self.requestActions("projectile")
 
-	def initIO(self):
-		if self.__verbose: print "[*] Starting display server"
-		self.__display_io.name = "display server"
-		self.__display_io.on_client_connect = self.openDisplay
-		self.__display_io.on_client_disconnect = self.closeDisplay
-		self.__display_io.on_new_packet = self.recvDisplayPacket
-		self.__display_io.connect('', self.displayPort)
-		if self.__verbose: print "[*] Starting input server"
-		self.__input_io.name = "input server"
-		self.__input_io.on_client_connect = self.openInput
-		self.__input_io.on_client_disconnect = self.closeInput
-		self.__input_io.on_new_packet = self.recvInputPacket
-		self.__input_io.connect('', self.inputPort)
-		thread.start_new_thread(self.run_io_thread, ())
-		
-	def createAgents(self):
-		if self.__verbose: print "[*] Creating agents"
-		Kernel.instance.addAgent(self)
-		self.addAgent(Game(debug=self.__debug))
-		self.addAgent(World(debug=self.__debug))
-		self.addAgent(Character(100, 1, debug=self.__debug))
-		self.addAgent(Character(-150, 2, debug=self.__debug))
-		self.addAgent(Weapon(debug=self.__debug))
-		self.addAgent(Projectile(debug=self.__debug))
-		self.sendBroadcastMessage(BoomBoomMessage("start", ()), "game")
-		
-	def openDisplay(self, client):
-		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openDisplay,"DISPLAY",))
+    def start(self):
+        if self._verbose: print "[*] Creating agents"
+        self.addAgent(Game(debug=self._debug))
+        self.addAgent(World(debug=self._debug))
+        self.addAgent(Character(100, 1, debug=self._debug))
+        self.addAgent(Character(-150, 2, debug=self._debug))
+        self.addAgent(Weapon(debug=self._debug))
+        self.addAgent(Projectile(debug=self._debug))
+        self.sendBroadcastMessage(HappyBoomMessage("start", ()), "game")
+                        
+    def msg_game_next_character(self, char, team):
+        if self._debug: print "Next character : %s,%s" %(char, team)
+        self.nextChar = char
+                        
+    def msg_game_next_turn(self):
+        if self._debug: print "Next turn : %s" %self.nextChar
+        self.sendNetworkMessage("game", "next_turn")
+        self.sendNetworkMessage("game", "active_character", self.nextChar)
+        
+    def msg_game_collision(self, x, y):
+        if self._debug: print "Hit ground : %s,%s" %(x, y)
+        self.sendNetworkMessage("projectile", "hit_ground")
+    
+    def msg_projectile_move(self, x, y):
+        if self._debug: print "Projectile move : %s,%s" %(x, y)
+        self.sendNetworkMessage("projectile", "move", "%i,%i" %(x,y), True)
+        
+    def msg_projectile_activate(self, flag):
+        if self._debug: print "Projectile activate : %s" %flag
+        self.sendNetworkMessage("projectile", "activate", "%u" %(flag))
+        
+    def msg_weapon_angle(self, a):
+        if self._debug: print "Weapon angle : %s" %a
+        self.sendNetworkMessage("weapon", "angle", a)
+        
+    def msg_weapon_strength(self, s):
+        if self._debug: print "Weapon strength : %s" %s
+        self.sendNetworkMessage("weapon", "force", s)
+        
+    def msg_world_create(self, m):
+        if self._debug: print "World create : %s" %m
+        self.sendNetworkMessage("world", "create", m)
+        
+    def msg_character_move(self, m):
+        if self._debug: print "Character move : %s" %m
+        self.sendNetworkMessage("character", "move", m)
+        
+    def msg_new_item(self, type, id):
+        if self._debug: print "New item : %s,%s" %(type, id)
+        self.__items.append((type, id))
+        
+    def msg_game_current_character(self, char, team):
+        if self._debug: print "Current character : %s,%s" %(char, team)
+        self.sendNetworkMessage("game", "active_character", char)
 
-	def openInput(self, client):
-		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openInput,"INPUT",))
-		
-	def closeInput(self, client):
-		if self.__verbose: print "[*] Input %s disconnected." % (client.name)
-		if not (client in self.__inputs): return
-		self.__inputs.remove (client)
-		txt = "Client %s (input) leave us." % (client.name)
-		self.sendText(txt)
-
-	def closeDisplay(self, client):
-		if self.__verbose: print "[*] Display %s disconnected." % (client.name)
-		txt = "Client %s (display) leave us." % (client.name)
-		self.sendText(txt)
-		
-	def __clientChallenge(self, client, func, client_type):
-		try:
-			func(client)
-		except Exception, msg:
-			print "EXCEPTION WHEN %s TRY TO CONNECT :" % (client_type)
-			print msg
-			print "--"
-			traceback.print_exc()
-			self.stop()
-
-	# Function which should be called in a thread
-	def run_io_thread(self):
-		try:
-			while self.__input_io.isRunning() and self.__display_io.isRunning():
-				self.__input_io.live()				
-				self.__display_io.live()				
-				time.sleep(0.001)
-		except Exception, msg:
-			print "EXCEPTION IN IO THREAD :"
-			print msg
-			print "--"			
-			traceback.print_exc()
-			self.stop()
-
-	def __do_openDisplay(self, client):
-		if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
-		
-		self.__display_buffer.clear(client.addr)
-		
-		# Ask protocol version
-		msg = self.createMsg("agent_manager", "AskVersion")
-		client.send(io.Packet(msg))
-		answer = self.readDisplayAnswer(client)
-		if answer != self.__display_protocol_version:
-			txt = "Sorry, you don't have same protocol version (%s VS %s)" \
-				% (answer, self.__display_protocol_version)
-			self.sendText(txt)
-			client.disconnect()
-			return
-		
-		# ask client name
-		msg = self.createMsg("agent_manager", "AskName")
-		client.send(io.Packet(msg))
-		name = self.readDisplayAnswer(client)
-		if name not in ("-", ""): client.name = name
-
-		self.registerFeature(client, "agent_manager")
-		self.registerFeature(client, "game")
-		for type, id in self.__items:
-			msg = self.createMsg("agent_manager", "Create", "%s:%u" % (type, id))
-			client.send (io.Packet(msg))
-			answer = self.readDisplayAnswer(client)
-			if answer == "yes": 
-				role = self.readDisplayAnswer(client)
-				while role != ".":
-					self.registerFeature(client, role)
-					role = self.readDisplayAnswer(client)
-
-		msg = self.createMsg("game", "Start")
-		client.send(io.Packet(msg))
-			
-		txt = "Welcome to new (display) client : %s" % (client.name)
-		self.sendText(txt)
-		if self.__verbose: print "[*] Display %s connected" % (client.name)
-		self.sendBBMessage("sync")
-
-	def __do_openInput(self, client):
-		if self.__verbose: print "[*] Input %s try to connect ..." % (client.name)
-
-		self.__input_buffer.clear(client.addr)
-
-		client.send(io.Packet("Version?"))
-		answer = self.readInputAnswer(client)
-		if answer == None:
-			if self.__verbose: print "[*] Client doesn't sent version"
-			client.disconnect()
-			return
-		if answer != self.__input_protocol_version:
-			txt = "Sorry, you don't have same protocol version (%s VS %s)" \
-				% (answer, self.__input_protocol_version)
-			self.sendText(txt, client)
-			client.disconnect()
-			return	
-		client.send(io.Packet("OK"))
-		
-		# ask client name
-		client.send(io.Packet("Name?"))
-		name = self.readInputAnswer(client)
-		if name == None:
-			if self.__verbose: print "[*] Client doesn't sent name"
-			client.disconnect()
-			return
-		if name not in ("-", ""): client.name = name
-		client.send(io.Packet("OK"))
-
-		self.__inputs.append (client)
-		if self.__verbose: print "Input %s connected." % (client.name)
-		txt = "Welcome to new (input) client : %s" % (client.name)
-		self.sendText(txt)
-		
-	# Convert a (role,type,arg) to string (to be sent throw network)
-	def createMsg(self, role, type, arg=None):
-		if arg != None:
-			return "%s:%s:%s" % (role, type, arg)
-		else:
-			return "%s:%s" % (role, type)
-		
-	def recvInputPacket(self, packet):
-		self.__input_buffer.append(packet.recv_from.addr, packet)
-		
-	def recvDisplayPacket(self, packet):
-		msg = packet.data
-		self.__display_buffer.append(packet.recv_from.addr, packet)
-
-	def readDisplayAnswer(self, client):
-		return self.__readClientAnswer(self.__display_buffer, client)
-		
-	def readInputAnswer(self, client):
-		return self.__readClientAnswer(self.__input_buffer, client)
-
-	def __readClientAnswer(self, buffer, client, timeout=3.000):
-		answer = buffer.readBlocking(client.addr, timeout)
-		if answer==None: return None
-		answer = answer.data
-		return answer
-
-	def sendText(self, txt, client=None):
-		if client != None:
-			msg = self.createMsg("agent_manager", "Text", txt)
-			client.send(io.Packet(msg))
-		else:
-			self.sendNetworkMessage("agent_manager", "Text", txt)
-
-	def processInputCmd(self, input, cmd):
-		cmd_ok = (\
-			"move_left", "move_right", "move_up", "move_down",
-			"shoot", )
-		if self.__verbose and cmd != "Ping?":
-			print "Command from %s: %s" % (input.name, cmd)
-		if re.compile("^chat:(.*)$").match(cmd) != None:
-			print "New chat message: %s" % (r.group(1))
-			self.sendNetworkMessage("chat_server", "new", r.group(1))
-		elif cmd in cmd_ok:	self.sendBroadcastMessage(BoomBoomMessage("new_command", (cmd,)), "command_manager")
-		
-	def processInputs(self):
-		inputs = self.__inputs[:]
-		for client in inputs:
-			packets = self.__input_buffer.readNonBlocking(client.addr)
-
-			for packet in packets:	
-				self.processInputCmd (packet.recv_from, packet.data)
-
-	def registerFeature(self, client, role):
-		if role in self.__supportedFeatures:
-			if client not in self.__supportedFeatures[role]:
-				self.__supportedFeatures[role].append(client)
-		else:
-			self.__supportedFeatures[role] = [client,]
-
-	def sendNetworkMessage(self, role, type, arg=None, skippable=False):
-		msg = self.createMsg(role, type, arg)
-		clients = self.__supportedFeatures.get(role, ())
-		for client in clients:
-			client.send (io.Packet(msg, skippable=skippable))
-						
-	def msg_game_next_character(self, char, team):
-		if self.__debug: print "Next character : %s,%s" %(char, team)
-		self.nextChar = char
-						
-	def msg_game_next_turn(self):
-		if self.__debug: print "Next turn : %s" %self.nextChar
-		self.sendNetworkMessage("game", "next_turn")
-		self.sendNetworkMessage("game", "active_character", self.nextChar)
-		
-	def msg_game_collision(self, x, y):
-		if self.__debug: print "Hit ground : %s,%s" %(x, y)
-		self.sendNetworkMessage("projectile", "hit_ground")
-	
-	def msg_projectile_move(self, x, y):
-		if self.__debug: print "Projectile move : %s,%s" %(x, y)
-		self.sendNetworkMessage("projectile", "move", "%i,%i" %(x,y), True)
-		
-	def msg_projectile_activate(self, flag):
-		if self.__debug: print "Projectile activate : %s" %flag
-		self.sendNetworkMessage("projectile", "activate", "%u" %(flag))
-		
-	def msg_weapon_angle(self, a):
-		if self.__debug: print "Weapon angle : %s" %a
-		self.sendNetworkMessage("weapon", "angle", a)
-		
-	def msg_weapon_strength(self, s):
-		if self.__debug: print "Weapon strength : %s" %s
-		self.sendNetworkMessage("weapon", "force", s)
-		
-	def msg_world_create(self, m):
-		if self.__debug: print "World create : %s" %m
-		self.sendNetworkMessage("world", "create", m)
-		
-	def msg_character_move(self, m):
-		if self.__debug: print "Character move : %s" %m
-		self.sendNetworkMessage("character", "move", m)
-		
-	def msg_new_item(self, type, id):
-		if self.__debug: print "New item : %s,%s" %(type, id)
-		self.__items.append((type, id))
-		
-	def msg_game_current_character(self, char, team):
-		if self.__debug: print "Current character : %s,%s" %(char, team)
-		self.sendNetworkMessage("game", "active_character", char)
+class BoomBoomServer(HappyBoomServer):
+    def __init__(self, arg):
+        arg["gateway"] = BoomBoomGateway(self, arg)
+        HappyBoomServer.__init__(self, arg)

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-10 00:19:03 UTC (rev 134)
+++ happyboom/trunk/server/base_server.py	2005-09-13 13:00:06 UTC (rev 135)
@@ -1,327 +1,277 @@
-from bb_agent import BoomBoomAgent, BoomBoomMessage
-from agents import Character, Projectile, Weapon, World, Game
 from net import io, io_udp, io_tcp, net_buffer
-from pysma import Kernel, DummyScheduler
+from pysma import Kernel, DummyScheduler, ActionAgent, ActionMessage
 import re, random, thread, traceback, time
 
-class Gateway(BoomBoomAgent):
+class HappyBoomAgent(ActionAgent):
+	def __init__(self, type, **args):
+		ActionAgent.__init__(self, prefix="msg_")
+		self.type = type
+		self.__debug = args.get("debug", False)
+
+	def born(self):
+		self.requestRole(self.type)
+
+	def requestActions(self, type):
+		self.requestRole("%s_listener" %type)
+		
+	def sendBBMessage(self, action, *arg, **kw):
+		message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
+		self.sendBroadcastMessage(message, "%s_listener" %self.type)
+
+	def messageReceived(self, msg):
+		if self.__debug:
+			print "Unhandled message : %s -- %s" %(type(self), msg)
+
+class HappyBoomMessage(ActionMessage):
+	def __init__(self, action, arg, kw={}):
+		ActionMessage.__init__(self, action, arg, kw)
+
+# TODO: Use better name :-)
+class HappyBoomPackerException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+class HappyBoomPacker:
+    """
+    Pack arguments to binary string.
+    """
     def __init__(self):
-		BoomBoomAgent.__init__(self, "gateway")
-		self.nextChar = None
+        pass
 
-class BaseServer:
-	def __init__(self, maxDisplay=2, displayPort=12430, maxInput=2, inputPort=12431, verbose=False, debug=False):
-		self.__protocol_version = "0.1.4"
-		self.__debug = debug
-		self.__verbose = verbose
-		self.__inputs = []
-		self.__items = []
-		self.__stopped = False
-		self.__stoplock = thread.allocate_lock()
-		self.__supportedFeatures = {}
+    def packUtf8(self, data):
+        return data.encode("utf-8")
 
-        # Create IO
-		self.__io = io_tcp.IO_TCP(is_server=True)
-		self.__io.debug = debug
-		self.__io.verbose = verbose
-		self.__io_buffer = net_buffer.NetBuffer()
+    def packBin(self, data):
+        return data
 
-		self.maxDisplay = maxDisplay
-		self.displayPort = displayPort
-		self.maxInput = maxInput
-		self.inputPort = inputPort
-		self.started = False
-		random.seed()
-		Kernel().addAgent(DummyScheduler(sleep=0.01))
-		
-	def born(self):
-		BoomBoomAgent.born(self)
-		self.requestActions("game")
-		self.requestActions("weapon")
-		self.requestActions("character")
-		self.requestActions("world")
-		self.requestActions("projectile")
-		
-	def start(self):
-		if self.__verbose: print "[*] Starting server..."
-		self.initIO()
-		self.createAgents()
-		print "[*] Server started"
-		
-		self.__stoplock.acquire()
-		running = not self.__stopped
-		self.__stoplock.release()
-		while running:
-			self.processInputs()
-			time.sleep(0.01)
-			self.__stoplock.acquire()
-			running = not self.__stopped
-			self.__stoplock.release()
+    def pack(self, datalist):
+        out = ""
+        for type,data in datalist:
+            # TODO: Use dict instead of long if list
+            if type=="bin":
+                data = self.packBin(data)
+            elif type=="utf8":
+                data = self.packUtf8(data)
+            else:
+                raise HappyBoomPackerException("Wrong argument type: %s" % type)
+            out = out + data
+        return out        
 
-	def stop(self):
-		self.__stoplock.acquire()
-		if self.__stopped:
-			self.__stoplock.release()
-			return
-		self.__stopped = True
-		self.__stoplock.release()
-		print "[*] Stopping server..."
-		Kernel.instance.stopKernel()
-		self.sendNetworkMessage("game", "Stop", skippable=True)
-		self.__display_io.stop()
-		self.__input_io.stop()
-		if self.__verbose: print "[*] Server stopped"
+class HappyBoomGateway(HappyBoomAgent):
+    def __init__(self, server, arg):
+        self.__server = server
+        HappyBoomAgent.__init__(self, "gateway")
+        self.nextChar = None
+        self._debug = arg.get("debug", False)
+        self._verbose = arg.get("verbose", False)
+        Kernel().addAgent(DummyScheduler(sleep=0.01))
+        self.packer = HappyBoomPacker()
 
-	def initIO(self):
-		if self.__verbose: print "[*] Starting display server"
-		self.__display_io.name = "display server"
-		self.__display_io.on_client_connect = self.openDisplay
-		self.__display_io.on_client_disconnect = self.closeDisplay
-		self.__display_io.on_new_packet = self.recvDisplayPacket
-		self.__display_io.connect('', self.displayPort)
-		if self.__verbose: print "[*] Starting input server"
-		self.__input_io.name = "input server"
-		self.__input_io.on_client_connect = self.openInput
-		self.__input_io.on_client_disconnect = self.closeInput
-		self.__input_io.on_new_packet = self.recvInputPacket
-		self.__input_io.connect('', self.inputPort)
-		thread.start_new_thread(self.run_io_thread, ())
-		
-	def createAgents(self):
-		if self.__verbose: print "[*] Creating agents"
-		Kernel.instance.addAgent(self)
-		self.addAgent(Game(debug=self.__debug))
-		self.addAgent(World(debug=self.__debug))
-		self.addAgent(Character(100, 1, debug=self.__debug))
-		self.addAgent(Character(-150, 2, debug=self.__debug))
-		self.addAgent(Weapon(debug=self.__debug))
-		self.addAgent(Projectile(debug=self.__debug))
-		self.sendBroadcastMessage(BoomBoomMessage("start", ()), "game")
-		
-	def openDisplay(self, client):
-		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openDisplay,"DISPLAY",))
+    # Convert a (role,type,arg) to string (to be sent throw network)
+    def createMsg(self, role, function, args=None):
+        if args != None:
+            return "%s:%s:%s" % (role, type, args)
+        else:
+            return "%s:%s" % (role, type)
 
-	def openInput(self, client):
-		thread.start_new_thread( self.__clientChallenge, (client,self.__do_openInput,"INPUT",))
-		
-	def closeInput(self, client):
-		if self.__verbose: print "[*] Input %s disconnected." % (client.name)
-		if not (client in self.__inputs): return
-		self.__inputs.remove (client)
-		txt = "Client %s (input) leave us." % (client.name)
-		self.sendText(txt)
+    def pack(self, datalist):
+        return self.packer.pack(datalist)
 
-	def closeDisplay(self, client):
-		if self.__verbose: print "[*] Display %s disconnected." % (client.name)
-		txt = "Client %s (display) leave us." % (client.name)
-		self.sendText(txt)
-		
-	def __clientChallenge(self, client, func, client_type):
-		try:
-			func(client)
-		except Exception, msg:
-			print "EXCEPTION WHEN %s TRY TO CONNECT :" % (client_type)
-			print msg
-			print "--"
-			traceback.print_exc()
-			self.stop()
+    def sendMsgToClient(self, msg, client):
+        client.send(io.Packet(msg))
 
-	# Function which should be called in a thread
-	def run_io_thread(self):
-		try:
-			while self.__input_io.isRunning() and self.__display_io.isRunning():
-				self.__input_io.live()				
-				self.__display_io.live()				
-				time.sleep(0.001)
-		except Exception, msg:
-			print "EXCEPTION IN IO THREAD :"
-			print msg
-			print "--"			
-			traceback.print_exc()
-			self.stop()
+    def start(self):
+        Kernel.instance.addAgent(self)
+        
+    def stop(self):
+        Kernel.instance.stopKernel()
 
-	def __do_openDisplay(self, client):
-		if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
-		
-		self.__display_buffer.clear(client.addr)
-		
-		# Ask protocol version
-		msg = self.createMsg("agent_manager", "AskVersion")
-		client.send(io.Packet(msg))
-		answer = self.readDisplayAnswer(client)
-		if answer != self.__display_protocol_version:
-			txt = "Sorry, you don't have same protocol version (%s VS %s)" \
-				% (answer, self.__display_protocol_version)
-			self.sendText(txt)
-			client.disconnect()
-			return
-		
-		# ask client name
-		msg = self.createMsg("agent_manager", "AskName")
-		client.send(io.Packet(msg))
-		name = self.readDisplayAnswer(client)
-		if name not in ("-", ""): client.name = name
+    def sendText(self, txt, client=None):
+        if client != None:
+            msg = self.createMsg("agent_manager", "Text", txt)
+            client.send(io.Packet(msg))
+        else:
+            self.sendNetworkMessage("agent_manager", "Text", txt)
 
-		self.registerFeature(client, "agent_manager")
-		self.registerFeature(client, "game")
-		for type, id in self.__items:
-			msg = self.createMsg("agent_manager", "Create", "%s:%u" % (type, id))
-			client.send (io.Packet(msg))
-			answer = self.readDisplayAnswer(client)
-			if answer == "yes": 
-				role = self.readDisplayAnswer(client)
-				while role != ".":
-					self.registerFeature(client, role)
-					role = self.readDisplayAnswer(client)
+    def sendNetworkMessage(self, role, type, arg=None, skippable=False):
+        msg = self.createMsg(role, type, arg)
+        clients = self.__server.client_manager.supported_features.get(role, ())
+        for client in clients:
+            client.send (io.Packet(msg, skippable=skippable))
 
-		msg = self.createMsg("game", "Start")
-		client.send(io.Packet(msg))
-			
-		txt = "Welcome to new (display) client : %s" % (client.name)
-		self.sendText(txt)
-		if self.__verbose: print "[*] Display %s connected" % (client.name)
-		self.sendBBMessage("sync")
+class HappyBoomClientManager(object):
+    def __init__(self, server, gateway, arg): 
+        self.__server = server
+        self.__gateway = gateway
+        self.__io = io_tcp.IO_TCP(is_server=True)
+        self.__io.debug = arg.get("debug", False)
+        self.__io.verbose = arg.get("verbose", False)
+        self.__buffer = net_buffer.NetBuffer()
+        self.__debug = arg.get("debug", False)
+        self.__verbose = arg.get("verbose", False)
+        self.max_clients = arg.get("max_clients", 2)
+        self.client_port = arg.get("client_port", 12430)
+        self.__protocol_version = "0.1.4"
+        self.__supported_features = {}
+        
+    def recvClientPacket(self, packet):
+        self.__buffer.append(packet.recv_from.addr, packet)
 
-	def __do_openInput(self, client):
-		if self.__verbose: print "[*] Input %s try to connect ..." % (client.name)
+    def stop(self):
+        self.__gateway.sendNetworkMessage("game", "Stop", skippable=True)
+        self.__io.stop()
 
-		self.__input_buffer.clear(client.addr)
+    def process(self):
+        pass
+#        processInputs()
 
-		client.send(io.Packet("Version?"))
-		answer = self.readInputAnswer(client)
-		if answer == None:
-			if self.__verbose: print "[*] Client doesn't sent version"
-			client.disconnect()
-			return
-		if answer != self.__input_protocol_version:
-			txt = "Sorry, you don't have same protocol version (%s VS %s)" \
-				% (answer, self.__input_protocol_version)
-			self.sendText(txt, client)
-			client.disconnect()
-			return	
-		client.send(io.Packet("OK"))
-		
-		# ask client name
-		client.send(io.Packet("Name?"))
-		name = self.readInputAnswer(client)
-		if name == None:
-			if self.__verbose: print "[*] Client doesn't sent name"
-			client.disconnect()
-			return
-		if name not in ("-", ""): client.name = name
-		client.send(io.Packet("OK"))
+    def start(self):
+        if self.__verbose: print "[*] Starting server"
+        self.__io.name = "server"
+        self.__io.on_client_connect = self.openClient
+        self.__io.on_client_disconnect = self.closeClient
+        self.__io.on_new_packet = self.recvClientPacket
+        self.__io.connect('', self.client_port)
+        thread.start_new_thread(self.run_io_thread, ())
 
-		self.__inputs.append (client)
-		if self.__verbose: print "Input %s connected." % (client.name)
-		txt = "Welcome to new (input) client : %s" % (client.name)
-		self.sendText(txt)
-		
-	# Convert a (role,type,arg) to string (to be sent throw network)
-	def createMsg(self, role, type, arg=None):
-		if arg != None:
-			return "%s:%s:%s" % (role, type, arg)
-		else:
-			return "%s:%s" % (role, type)
-		
-	def recvInputPacket(self, packet):
-		self.__input_buffer.append(packet.recv_from.addr, packet)
-		
-	def recvDisplayPacket(self, packet):
-		msg = packet.data
-		self.__display_buffer.append(packet.recv_from.addr, packet)
+    def readClientAnswer(self, client, timeout=1.000):
+        answer = self.__buffer.readBlocking(client.addr, timeout)
+        if answer==None: return None
+        return answer.data
 
-	def readDisplayAnswer(self, client):
-		return self.__readClientAnswer(self.__display_buffer, client)
-		
-	def readInputAnswer(self, client):
-		return self.__readClientAnswer(self.__input_buffer, client)
+    def registerFeature(self, client, role):
+        if role in self.__supported_features:
+            if client not in self.__supported_features[role]:
+                self.__supported_features[role].append(client)
+        else:
+            self.__supported_features[role] = [client,]
+        
+    def openClient(self, client):
+        # TODO: Ne pas utiliser de thread ?!
+        thread.start_new_thread( self.__clientChallenge, (client,self.__do_openClient))
 
-	def __readClientAnswer(self, buffer, client, timeout=3.000):
-		answer = buffer.readBlocking(client.addr, timeout)
-		if answer==None: return None
-		answer = answer.data
-		return answer
+    def closeClient(self, client):
+        if self.__verbose:
+            log.info("Client %s disconnected." % client.name)
+        
+        txt = "Client %s (display) leave us." % (client.name)
+        self.__gateway.sendText(txt)
+        
+        arg = self.__gateway.pack((("utf8", u"Lost connection"),))
+        msg = self.__gateway.createMsg("presentation", "bye", arg)
+        self.__gateway.sendMsgToClient(msg, client)
+        
+    def __clientChallenge(self, client, func):
+        try:
+            func(client)
+        except Exception, msg:
+            print "EXCEPTION WHEN A CLIENT TRY TO CONNECT :"
+            print msg
+            print "--"
+            traceback.print_exc()
+            self.stop()
 
-	def sendText(self, txt, client=None):
-		if client != None:
-			msg = self.createMsg("agent_manager", "Text", txt)
-			client.send(io.Packet(msg))
-		else:
-			self.sendNetworkMessage("agent_manager", "Text", txt)
+    # Function which should be called in a thread
+    # TODO: Pourquoi c'est utilis? ?a ?
+    def run_io_thread(self):
+        try:
+            while self.__io.isRunning():
+                self.__io.live()                
+                time.sleep(0.001)
+        except Exception, msg:
+            print "EXCEPTION IN IO THREAD :"
+            print msg
+            print "--"            
+            traceback.print_exc()
+            self.stop()
 
-	def processInputCmd(self, input, cmd):
-		cmd_ok = (\
-			"move_left", "move_right", "move_up", "move_down",
-			"shoot", )
-		if self.__verbose and cmd != "Ping?":
-			print "Command from %s: %s" % (input.name, cmd)
-		if re.compile("^chat:(.*)$").match(cmd) != None:
-			print "New chat message: %s" % (r.group(1))
-			self.sendNetworkMessage("chat_server", "new", r.group(1))
-		elif cmd in cmd_ok:	self.sendBroadcastMessage(BoomBoomMessage("new_command", (cmd,)), "command_manager")
-		
-	def processInputs(self):
-		inputs = self.__inputs[:]
-		for client in inputs:
-			packets = self.__input_buffer.readNonBlocking(client.addr)
+    def generateSignature(self, client):
+        import random
+        r = random.randint(0,1000000)
+        return r
 
-			for packet in packets:	
-				self.processInputCmd (packet.recv_from, packet.data)
+    def __do_openClient(self, client):
+        if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
+        
+#        self.__buffer.clear(client.addr)
+       
+        # Check protocol version (max: wait 200ms)
+        answer = self.readClientAnswer(client, 0.200)
+        if answer != self.__protocol_version:
+            # If it isn't the right version, send presention.bye(...)
+            txt = u"Sorry, you don't have same protocol version (%s VS %s)" \
+                % (answer, self.__protocol_version)
+            msg = self.__gateway.createMsg("presentation", "bye", txt.encode("UTF-8"))
+            self.__gateway.sendMsgToClient(msg, client)
 
-	def registerFeature(self, client, role):
-		if role in self.__supportedFeatures:
-			if client not in self.__supportedFeatures[role]:
-				self.__supportedFeatures[role].append(client)
-		else:
-			self.__supportedFeatures[role] = [client,]
+            # Wait 0.5s and then disconnect the client
+            time.sleep(0.500)
+            client.disconnect()
+            return
+            
+        # Send protocol version with "hello()"
+        signature = self.generateSignature()
+        arg = self.__gateway.pack("bin", self.__protocol_version,"bin", signature)
+        msg = self.__gateway.createMsg("presentation", "hello", arg)
+        self.__gateway.sendMsgToClient(msg, client)
+         
+        # Read features (max: wait 1sec)
+        answer = self.readClientAnswer(client, 1.0)
+        #TODO: do something with answer :-)
 
-	def sendNetworkMessage(self, role, type, arg=None, skippable=False):
-		msg = self.createMsg(role, type, arg)
-		clients = self.__supportedFeatures.get(role, ())
-		for client in clients:
-			client.send (io.Packet(msg, skippable=skippable))
-						
-	def msg_game_next_character(self, char, team):
-		if self.__debug: print "Next character : %s,%s" %(char, team)
-		self.nextChar = char
-						
-	def msg_game_next_turn(self):
-		if self.__debug: print "Next turn : %s" %self.nextChar
-		self.sendNetworkMessage("game", "next_turn")
-		self.sendNetworkMessage("game", "active_character", self.nextChar)
-		
-	def msg_game_collision(self, x, y):
-		if self.__debug: print "Hit ground : %s,%s" %(x, y)
-		self.sendNetworkMessage("projectile", "hit_ground")
-	
-	def msg_projectile_move(self, x, y):
-		if self.__debug: print "Projectile move : %s,%s" %(x, y)
-		self.sendNetworkMessage("projectile", "move", "%i,%i" %(x,y), True)
-		
-	def msg_projectile_activate(self, flag):
-		if self.__debug: print "Projectile activate : %s" %flag
-		self.sendNetworkMessage("projectile", "activate", "%u" %(flag))
-		
-	def msg_weapon_angle(self, a):
-		if self.__debug: print "Weapon angle : %s" %a
-		self.sendNetworkMessage("weapon", "angle", a)
-		
-	def msg_weapon_strength(self, s):
-		if self.__debug: print "Weapon strength : %s" %s
-		self.sendNetworkMessage("weapon", "force", s)
-		
-	def msg_world_create(self, m):
-		if self.__debug: print "World create : %s" %m
-		self.sendNetworkMessage("world", "create", m)
-		
-	def msg_character_move(self, m):
-		if self.__debug: print "Character move : %s" %m
-		self.sendNetworkMessage("character", "move", m)
-		
-	def msg_new_item(self, type, id):
-		if self.__debug: print "New item : %s,%s" %(type, id)
-		self.__items.append((type, id))
-		
-	def msg_game_current_character(self, char, team):
-		if self.__debug: print "Current character : %s,%s" %(char, team)
-		self.sendNetworkMessage("game", "active_character", char)
+        txt = "Welcome to new (display) client : %s" % (client.name)
+        self.__gateway.sendText(txt)
+        if self.__verbose: print "[*] Display %s connected" % (client.name)
+        self.sendBBMessage("sync")
+
+    def __getSupportedFeatures(self): return self.__supported_features
+    supported_features = property(__getSupportedFeatures)
+
+class HappyBoomServer(object):
+    def __init__(self, arg): #verbose=False, debug=False):
+        self.started = False
+        self.__debug = arg.get('debug', False)
+        self.__verbose = arg.get('verbose', False)
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        if arg.has_key("gateway"):
+            self.__gateway = arg["gateway"]
+        else:
+            self.__gateway = HappyBoomGateway(self, arg)
+        self.__client_manager = HappyBoomClientManager(self, self.__gateway, arg)
+        random.seed()
+        self.__items = []
+        
+    def born(self):
+        self.gateway.born()
+        
+    def start(self):
+        if self.__verbose: print "[*] Starting server..."
+        self.__client_manager.start()
+        self.__gateway.start()
+        print "[*] Server started"
+        
+        self.__stoplock.acquire()
+        running = not self.__stopped
+        self.__stoplock.release()
+        while running:
+            self.__client_manager.process()
+            time.sleep(0.01)
+            self.__stoplock.acquire()
+            running = not self.__stopped
+            self.__stoplock.release()
+
+    def stop(self):
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return
+        self.__stopped = True
+        self.__stoplock.release()
+        print "[*] Stopping server..."
+        self.__gateway.stop()
+        self.__client_manager.stop()
+        if self.__verbose: print "[*] Server stopped"
+
+    def __getClientManager(self): return self.__client_manager
+    client_manager = property(__getClientManager)

Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-10 00:19:03 UTC (rev 134)
+++ poilu/trunk/dico.txt	2005-09-13 13:00:06 UTC (rev 135)
@@ -33,7 +33,6 @@
 genou
 gland
 gosier
-gros zizi
 jambon
 kiki
 loup



From dboucard at berlios.de  Tue Sep 13 18:10:49 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Tue, 13 Sep 2005 18:10:49 +0200
Subject: [Happyboom-svn] r136 - languetudes/trunk
Message-ID: <200509131610.j8DGAn0t031032@sheep.berlios.de>

Author: dboucard
Date: 2005-09-13 18:10:49 +0200 (Tue, 13 Sep 2005)
New Revision: 136

Added:
   languetudes/trunk/i18n/
Removed:
   languetudes/trunk/locale/
Log:
renommage du rep locale --> i18n


Copied: languetudes/trunk/i18n (from rev 135, languetudes/trunk/locale)



From haypo at berlios.de  Tue Sep 13 22:28:42 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 13 Sep 2005 22:28:42 +0200
Subject: [Happyboom-svn] r137 - poilu/trunk
Message-ID: <200509132028.j8DKSgT1032597@sheep.berlios.de>

Author: haypo
Date: 2005-09-13 22:28:41 +0200 (Tue, 13 Sep 2005)
New Revision: 137

Modified:
   poilu/trunk/pypoil.py
   poilu/trunk/wormux.sh
Log:
Corrige un bug dans l'envoi de message prive.


Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-13 16:10:49 UTC (rev 136)
+++ poilu/trunk/pypoil.py	2005-09-13 20:28:41 UTC (rev 137)
@@ -15,6 +15,7 @@
 #   casse toi        : Le bot se d?connecte
 #
 
+import types
 import string, random, re
 from ircbot import SingleServerIRCBot
 from irclib import nm_to_n, nm_to_h, ip_numstr_to_quad, ip_quad_to_numstr
@@ -99,14 +100,18 @@
         return
             
     def send_privmsg(self, nick, message):
+        if type(nick)==types.UnicodeType:
+            nick = nick.encode("ascii")
         if self.utf8_chan: 
             self.connection.privmsg(nick, message.decode("latin-1").encode("utf-8"))
         else:
             self.connection.privmsg(nick, message)
             
     def send_privmsgu(self, nick, message):
+        if type(nick)==types.UnicodeType:
+            nick = nick.encode("ascii")
         if self.utf8_chan: 
-            self.connection.privmsg(nick, message.encode("utf-8"))
+            self.connection.privmsg(nick, message.encode("UTF-8"))
         else:
             self.connection.privmsg(nick, message.encode("iso-8859-1"))
 
@@ -161,6 +166,7 @@
             
         regs = re.compile("^dit ([^ ]+) (.+)$", re.IGNORECASE).search(cmd)
         if regs != None:
+            dit=regs.group(2)
             self.send_privmsgu(regs.group(1), regs.group(2))
             return True
             

Modified: poilu/trunk/wormux.sh
===================================================================
--- poilu/trunk/wormux.sh	2005-09-13 16:10:49 UTC (rev 136)
+++ poilu/trunk/wormux.sh	2005-09-13 20:28:41 UTC (rev 137)
@@ -1,3 +1,3 @@
 #!/bin/sh
 set -x
-python pypoil.py irc.eu.freenode.net:6667 '#poilu:utf8' poil_au
+python pypoil.py irc.eu.freenode.net:6667 '#poilu:utf8' geekouz 



From dboucard at berlios.de  Wed Sep 14 00:57:25 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 00:57:25 +0200
Subject: [Happyboom-svn] r138 - happyboom/trunk/common languetudes/trunk
Message-ID: <200509132257.j8DMvPXA010106@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 00:57:23 +0200 (Wed, 14 Sep 2005)
New Revision: 138

Added:
   languetudes/trunk/glade/
Removed:
   happyboom/trunk/common/mailing_list.py
Log:


Deleted: happyboom/trunk/common/mailing_list.py
===================================================================
--- happyboom/trunk/common/mailing_list.py	2005-09-13 20:28:41 UTC (rev 137)
+++ happyboom/trunk/common/mailing_list.py	2005-09-13 22:57:23 UTC (rev 138)
@@ -1,31 +0,0 @@
-class MailingList:
-	def __init__(self):
-		self.local_list = {}
-		self.net_list = {}
-		
-	def _register(self, list, role, value):
-		if list.has_key(role):
-			if value in list[role]: return
-			list[role].append (value)
-		else:
-			list[role] = [value]
-
-	def register(self, role, agent):
-		self._register(self.local_list, role, agent)
-		
-	def registerNet(self, role, client):
-		self._register(self.net_list, role, client)
-
-	def __get(self, list, role):
-#		if role == "*":
-#			big = []
-#			for key in list: big = big + list[key]
-#			return big		
-		if not list.has_key(role): return []
-		return list[role]
-
-	def getLocal(self, role):
-		return self.__get(self.local_list, role)
-		
-	def getNet(self, role):
-		return self.__get(self.net_list, role)



From dboucard at berlios.de  Wed Sep 14 01:10:41 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 01:10:41 +0200
Subject: [Happyboom-svn] r139 - happyboom/trunk
Message-ID: <200509132310.j8DNAfjf018399@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 01:10:32 +0200 (Wed, 14 Sep 2005)
New Revision: 139

Removed:
   happyboom/trunk/server.py
Log:


Deleted: happyboom/trunk/server.py
===================================================================
--- happyboom/trunk/server.py	2005-09-13 22:57:23 UTC (rev 138)
+++ happyboom/trunk/server.py	2005-09-13 23:10:32 UTC (rev 139)
@@ -1,104 +0,0 @@
-#!/usr/bin/python
-# -*- coding: ISO-8859-1 -*-
-VERSION="0.1.4"
-import time
-from console_server import *
-import getopt
-import sys
-
-def usage(defval):
-	print "HappyBoom server version %s" % (VERSION)
-	print ""
-	print "Usage: %s [-v,--verbose] [-d,--debug] [-h,--help]" % (sys.argv[0])
-	print ""
-	print "Arguments :"
-	print "\t-h,--help         : Show this help"
-	print "\t-v,--verbose      : Activate verbose mode"
-	print "\t-d,--debug        : Activate debug mode"
-	print ""
-	print "Other arguments :"
-	print "\t--max-input NB    : Max input clients (default %u)" % (defval["max-input"])
-	print "\t--max-view NB     : Max view clients (default %u)" % (defval["max-view"])
-	print "\t--view-port PORT  : Port number for view clients (default %u)" % (defval["view-port"])
-	print "\t--input-port PORT : Port number for input clients (default %u)" % (defval["input-port"])
-
-def parseArgs(val):
-	import getopt
-	def_val = val.copy()
-	
-	try:
-		short = "hdv"
-		long = ["debug", "verbose", "help", \
-			"max-input=", "max-view=", \
-			"view-port=", "input-port="]
-		opts, args = getopt.getopt(sys.argv[1:], short, long)
-	except getopt.GetoptError:
-		usage(def_val)
-		sys.exit(2)
-		
-	if 0<len(args):
-		usage(def_val)
-		sys.exit(2)
-	
-	for o, a in opts:
-		if o == "--help":
-			usage(def_val)
-			sys.exit()
-		if o == "--input-port":
-			a = int(a)
-			if a == val["view-port"]:
-				print "Sorry, input port should be different than view port!"
-			else:
-				val["input-port"] = a 			
-		if o == "--view-port":
-			a = int(a)
-			if a == val["input-port"]:
-				print "Sorry, view port should be different than input port!"
-			else:
-				val["view-port"] = a 
-		if o == "--max-input":
-			a = int(a)
-			if a < 1: 
-				a=1
-			elif 100 < a:
-				a = 100
-			val["max-input"] = a
-		if o == "--max-view":
-			a = int(a)
-			if a < 1: 
-				a=1
-			elif 100 < a:
-				a = 100
-			val["max-view"] = a
-		if o in ("-v", "--verbose"):
-			val["verbose"] = True
-		if o in ("-d", "--debug"):
-			val["debug"] = True
-	return val
-
-def main():
-	val = { \
-		"view-port": 12430, \
-		"input-port": 12431, \
-		"max-input": 4, \
-		"max-view": 4, \
-		"verbose": False,
-		"debug": False}
-	arg = parseArgs(val)
-	
-	server = ConsoleServer()
-	server.setVerbose(arg["verbose"])
-	server.setDebug(arg["debug"])
-
-	server.start(arg)
-	try:
-		while server.quit==False:
-			server.live()
-			time.sleep(0.010)
-	except KeyboardInterrupt:
-		print "Program interrupted (CTRL+C)."
-		pass
-	server.stop()
-	print "Server quit."
-
-if __name__=="__main__": main()



From haypo at berlios.de  Wed Sep 14 02:03:58 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 02:03:58 +0200
Subject: [Happyboom-svn] r140 - in happyboom/trunk: common net server
Message-ID: <200509140003.j8E03wtM011566@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 02:03:32 +0200 (Wed, 14 Sep 2005)
New Revision: 140

Added:
   happyboom/trunk/common/packer.py
Modified:
   happyboom/trunk/net/net_buffer.py
   happyboom/trunk/server/base_server.py
Log:
Net buffer use binary lock. Add HappyBoom packer. Commit last HappyBoom evolution.


Added: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-13 23:10:32 UTC (rev 139)
+++ happyboom/trunk/common/packer.py	2005-09-14 00:03:32 UTC (rev 140)
@@ -0,0 +1,38 @@
+class HappyBoomPacker:
+    """
+    Pack arguments to binary string. Types :
+    - "bin": Binary string
+    - "utf8": Unicode string which will be encoded into UTF-8
+    """
+
+    def __init__(self):
+        pass
+
+    def packUtf8(self, data):
+        data = 10
+        assert type(data)==types.unicode, "packUtf8 argument have to be Unicode"
+        return data.encode("utf-8")
+
+    def packBin(self, data):
+        return data
+
+    def pack(self, func, event, args):
+        assert (len(args) % 2) == 0, "Arguments length have to be even"
+        out = "%s:%s" % (func, event)
+
+        #TODO: Fix this :-)
+        for i in range(1,len(args), 2):
+            type = args[i]
+            data = args[i+1]
+            
+            # TODO: Use dict instead of long if list
+            if type=="bin":
+                data = self.packBin(data)
+            elif type=="utf8":
+                data = self.packUtf8(data)
+            else:
+                raise HappyBoomPackerException("Wrong argument type: %s" % type)
+            out = out + data
+        return out        
+
+

Modified: happyboom/trunk/net/net_buffer.py
===================================================================
--- happyboom/trunk/net/net_buffer.py	2005-09-13 23:10:32 UTC (rev 139)
+++ happyboom/trunk/net/net_buffer.py	2005-09-14 00:03:32 UTC (rev 140)
@@ -1,5 +1,4 @@
-
-import threading
+import thread
 import time
 
 class NetBuffer:
@@ -14,7 +13,7 @@
 		""" Constructor. """
 		self.blocking_read_sleep = 0.010
 		self.__buffer = {} 
-		self.__sema = threading.Semaphore()
+		self.__sema = thread.allocate_lock()
 
 	def clear(self, key):
 		""" Clear buffer. """

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-13 23:10:32 UTC (rev 139)
+++ happyboom/trunk/server/base_server.py	2005-09-14 00:03:32 UTC (rev 140)
@@ -1,62 +1,70 @@
+# TODO: Check if it's always possible to send skippable packets
+
 from net import io, io_udp, io_tcp, net_buffer
 from pysma import Kernel, DummyScheduler, ActionAgent, ActionMessage
 import re, random, thread, traceback, time
+import types # maybe only used for assertions
 
+class HappyBoomClient:
+    """
+    High-level class for a client in the server.
+    """
+
+    def __init__(self, io_client, client_manager):
+        self.__io = io_client
+        self.__client_manager = client_manager
+        self.signature = None
+
+    # Stop client: close socket.
+    def stop(self):
+        self.__io.stop()
+
+    # Read a message from network stack
+    # Blocking function, returns None after timeout seconds (no data)
+    def read(self, timeout):
+        return self.__client_manager.readClientAnswer(self.__io, timeout)
+
+    # Send a network packet the the client socket
+    def sendPacket(self, packet):
+        self.__io.send(packet)
+
+    # Send a HappyBoom message to the client (see L{sendPacket})
+    def sendNetMsg(self, func, event, *args):
+        packet = self.__gateway.createMsgTuple(func, event, args)
+        self.__io.send(packet)
+
 class HappyBoomAgent(ActionAgent):
-	def __init__(self, type, **args):
-		ActionAgent.__init__(self, prefix="msg_")
-		self.type = type
-		self.__debug = args.get("debug", False)
+    """
+    SMA agent in HappyBoom.
+    """
+    def __init__(self, type, **args):
+        ActionAgent.__init__(self, prefix="msg_")
+        self.type = type
+        self.__debug = args.get("debug", False)
 
-	def born(self):
-		self.requestRole(self.type)
+    def born(self):
+        self.requestRole(self.type)
 
-	def requestActions(self, type):
-		self.requestRole("%s_listener" %type)
-		
-	def sendBBMessage(self, action, *arg, **kw):
-		message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
-		self.sendBroadcastMessage(message, "%s_listener" %self.type)
+    def requestActions(self, type):
+        self.requestRole("%s_listener" %type)
+        
+    def sendBBMessage(self, action, *arg, **kw):
+        message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
+        self.sendBroadcastMessage(message, "%s_listener" %self.type)
 
-	def messageReceived(self, msg):
-		if self.__debug:
-			print "Unhandled message : %s -- %s" %(type(self), msg)
+    def messageReceived(self, msg):
+        if self.__debug:
+            print "Unhandled message : %s -- %s" %(type(self), msg)
 
 class HappyBoomMessage(ActionMessage):
-	def __init__(self, action, arg, kw={}):
-		ActionMessage.__init__(self, action, arg, kw)
+    def __init__(self, action, arg, kw={}):
+        ActionMessage.__init__(self, action, arg, kw)
 
 # TODO: Use better name :-)
 class HappyBoomPackerException(Exception):
     def __init__(self, msg):
         Exception.__init__(self, msg)
 
-class HappyBoomPacker:
-    """
-    Pack arguments to binary string.
-    """
-    def __init__(self):
-        pass
-
-    def packUtf8(self, data):
-        return data.encode("utf-8")
-
-    def packBin(self, data):
-        return data
-
-    def pack(self, datalist):
-        out = ""
-        for type,data in datalist:
-            # TODO: Use dict instead of long if list
-            if type=="bin":
-                data = self.packBin(data)
-            elif type=="utf8":
-                data = self.packUtf8(data)
-            else:
-                raise HappyBoomPackerException("Wrong argument type: %s" % type)
-            out = out + data
-        return out        
-
 class HappyBoomGateway(HappyBoomAgent):
     def __init__(self, server, arg):
         self.__server = server
@@ -67,19 +75,17 @@
         Kernel().addAgent(DummyScheduler(sleep=0.01))
         self.packer = HappyBoomPacker()
 
-    # Convert a (role,type,arg) to string (to be sent throw network)
-    def createMsg(self, role, function, args=None):
-        if args != None:
-            return "%s:%s:%s" % (role, type, args)
-        else:
-            return "%s:%s" % (role, type)
+    # Create a network packet for the event func.event(args) where
+    # args is a tuple
+    def createMsgTuple(self, func, event, args):
+        data = self.packer.pack(func, event, args)
+        return io.Packet(data)
+            
+    # Create a network packet for the event func.event(args), see
+    # L{self.createMsgTuple}
+    def createMsg(self, func, event, *args):
+        return self.createMsgTuple(func, event, args)
 
-    def pack(self, datalist):
-        return self.packer.pack(datalist)
-
-    def sendMsgToClient(self, msg, client):
-        client.send(io.Packet(msg))
-
     def start(self):
         Kernel.instance.addAgent(self)
         
@@ -88,16 +94,15 @@
 
     def sendText(self, txt, client=None):
         if client != None:
-            msg = self.createMsg("agent_manager", "Text", txt)
-            client.send(io.Packet(msg))
+            client.sendMsg("agent_manager", "Text", txt)
         else:
-            self.sendNetworkMessage("agent_manager", "Text", txt)
+            self.sendNetMsg("agent_manager", "Text", txt)
 
-    def sendNetworkMessage(self, role, type, arg=None, skippable=False):
-        msg = self.createMsg(role, type, arg)
+    def sendMsg(self, func, event, *args):
+        packet = self.createMsgTuple(role, type, args, func)
         clients = self.__server.client_manager.supported_features.get(role, ())
         for client in clients:
-            client.send (io.Packet(msg, skippable=skippable))
+            client.sendPacket(packet)
 
 class HappyBoomClientManager(object):
     def __init__(self, server, gateway, arg): 
@@ -113,13 +118,16 @@
         self.client_port = arg.get("client_port", 12430)
         self.__protocol_version = "0.1.4"
         self.__supported_features = {}
+        self.__clients = []
+        self.__clients_sema = thread.allocate_lock()
         
     def recvClientPacket(self, packet):
         self.__buffer.append(packet.recv_from.addr, packet)
 
     def stop(self):
-        self.__gateway.sendNetworkMessage("game", "Stop", skippable=True)
-        self.__io.stop()
+        self.__gateway.sendNetMsg("game", "stop")
+        for client in self.__clients:
+            client.stop()
 
     def process(self):
         pass
@@ -157,9 +165,7 @@
         txt = "Client %s (display) leave us." % (client.name)
         self.__gateway.sendText(txt)
         
-        arg = self.__gateway.pack((("utf8", u"Lost connection"),))
-        msg = self.__gateway.createMsg("presentation", "bye", arg)
-        self.__gateway.sendMsgToClient(msg, client)
+        client.sendMsg("presentation", "bye", "utf8", u"Lost connection")
         
     def __clientChallenge(self, client, func):
         try:
@@ -190,8 +196,9 @@
         r = random.randint(0,1000000)
         return r
 
-    def __do_openClient(self, client):
+    def __do_openClient(self, io_client):
         if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
+        client = HappyBoomClientSocket(io_client, self)
         
 #        self.__buffer.clear(client.addr)
        
@@ -201,8 +208,7 @@
             # If it isn't the right version, send presention.bye(...)
             txt = u"Sorry, you don't have same protocol version (%s VS %s)" \
                 % (answer, self.__protocol_version)
-            msg = self.__gateway.createMsg("presentation", "bye", txt.encode("UTF-8"))
-            self.__gateway.sendMsgToClient(msg, client)
+            client.sendMsg("presentation", "bye", "utf8", txt)
 
             # Wait 0.5s and then disconnect the client
             time.sleep(0.500)
@@ -210,15 +216,19 @@
             return
             
         # Send protocol version with "hello()"
-        signature = self.generateSignature()
-        arg = self.__gateway.pack("bin", self.__protocol_version,"bin", signature)
-        msg = self.__gateway.createMsg("presentation", "hello", arg)
-        self.__gateway.sendMsgToClient(msg, client)
+        client.signature = self.generateSignature()        
+        client.send("presentation", "hello", \
+            "bin", self.__protocol_version, \
+            "bin", signature)
          
         # Read features (max: wait 1sec)
-        answer = self.readClientAnswer(client, 1.0)
+        answer = client.read(1.0)
         #TODO: do something with answer :-)
 
+        self.__clients_sema.acquire() 
+        self.__clients.append(client)
+        self.__clients_sema.release() 
+
         txt = "Welcome to new (display) client : %s" % (client.name)
         self.__gateway.sendText(txt)
         if self.__verbose: print "[*] Display %s connected" % (client.name)



From haypo at berlios.de  Wed Sep 14 02:32:43 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 02:32:43 +0200
Subject: [Happyboom-svn] r141 - in happyboom/trunk: agent input net net/io net/io_tcp net/io_udp server
Message-ID: <200509140032.j8E0WhYV026053@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 02:32:33 +0200 (Wed, 14 Sep 2005)
New Revision: 141

Modified:
   happyboom/trunk/agent/agent.py
   happyboom/trunk/input/base_input.py
   happyboom/trunk/net/io/io_client.py
   happyboom/trunk/net/io_tcp/server_waiter.py
   happyboom/trunk/net/io_tcp/tcp.py
   happyboom/trunk/net/io_tcp/tcp_client.py
   happyboom/trunk/net/io_udp/udp.py
   happyboom/trunk/net/io_udp/udp_client.py
   happyboom/trunk/net/io_udp/udp_ping.py
   happyboom/trunk/net/net_buffer.py
   happyboom/trunk/server/base_server.py
   happyboom/trunk/server/server_agent.py
   happyboom/trunk/server/stat.py
Log:
Replace threading.Semaphore() by thread.allocate_lock(), use happyboom package for imports, and replace tab by four spaces.


Modified: happyboom/trunk/agent/agent.py
===================================================================
--- happyboom/trunk/agent/agent.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/agent/agent.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,46 +1,46 @@
 class AgentMessage:
-	def __init__(self, role, type, arg):
-		self.role = role
-		self.type = type
-		self.arg  = arg
-		self.id = -1
-		self.msg_handler = {}
+    def __init__(self, role, type, arg):
+        self.role = role
+        self.type = type
+        self.arg  = arg
+        self.id = -1
+        self.msg_handler = {}
 
-	def str(self):
-		if self.arg != None:
-			return "Message(role=%s, type=%s, arg=%s)" % (self.role, self.type, self.arg)
-		else:
-			return "Message(role=%s, type=%s)" % (self.role, self.type)
+    def str(self):
+        if self.arg != None:
+            return "Message(role=%s, type=%s, arg=%s)" % (self.role, self.type, self.arg)
+        else:
+            return "Message(role=%s, type=%s)" % (self.role, self.type)
 
 class Agent(object):
-	def __init__(self):
-		self.mailbox = []
-		self.msg_handler = {}
+    def __init__(self):
+        self.mailbox = []
+        self.msg_handler = {}
 
-	def hasMessage(self):
-		return len(self.mailbox) != 0
-		
-	def putMessage(self, msg):
-		self.mailbox.append(msg)
-		
-	def getMessage(self):
-		if not self.hasMessage(): return None
-		msg = self.mailbox[0]
-		del self.mailbox[0]
-		return msg
+    def hasMessage(self):
+        return len(self.mailbox) != 0
+        
+    def putMessage(self, msg):
+        self.mailbox.append(msg)
+        
+    def getMessage(self):
+        if not self.hasMessage(): return None
+        msg = self.mailbox[0]
+        del self.mailbox[0]
+        return msg
 
-	def processMessages(self):
-		while self.hasMessage():
-			msg = self.getMessage()
-			if self.msg_handler.has_key(msg.role):
-				handlers = self.msg_handler[msg.role]
-				if handlers.has_key(msg.type):
-					hdl = handlers[msg.type]	
-					hdl(msg.arg)
-		
-	def start(self):
-		for key in self.msg_handler:
-			self.server.registerMessage(self, key)
+    def processMessages(self):
+        while self.hasMessage():
+            msg = self.getMessage()
+            if self.msg_handler.has_key(msg.role):
+                handlers = self.msg_handler[msg.role]
+                if handlers.has_key(msg.type):
+                    hdl = handlers[msg.type]    
+                    hdl(msg.arg)
+        
+    def start(self):
+        for key in self.msg_handler:
+            self.server.registerMessage(self, key)
 
-	def live(self):
-		self.processMessages()
+    def live(self):
+        self.processMessages()

Modified: happyboom/trunk/input/base_input.py
===================================================================
--- happyboom/trunk/input/base_input.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/input/base_input.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -9,123 +9,123 @@
 import thread
 
 class BaseInput(object):
-	def __init__(self):
-		self.__io = io_udp.IO_UDP() 
-		#self.__io = io_tcp.IO_TCP() 
-		self.pid = os.getpid()
-		self.quit = False
-		self.active = True
-		self.debug = False
-		self.verbose = False
-		self.cmds = None
-		self.use_readline = False
-		self.__protocol_version = "0.1.4"
-		self.name = "-"
-		self.__recv_buffer = net_buffer.NetBuffer()
+    def __init__(self):
+        self.__io = io_udp.IO_UDP() 
+        #self.__io = io_tcp.IO_TCP() 
+        self.pid = os.getpid()
+        self.quit = False
+        self.active = True
+        self.debug = False
+        self.verbose = False
+        self.cmds = None
+        self.use_readline = False
+        self.__protocol_version = "0.1.4"
+        self.name = "-"
+        self.__recv_buffer = net_buffer.NetBuffer()
 
-	def processPacket(self, new_packet):
-		self.__recv_buffer.append(0,new_packet.data)
-	
-	def readCmd(self, timeout=1.000):
-		return self.__recv_buffer.readBlocking(0,timeout)
-	
-	def serverChallenge(self):
-		if self.verbose: 
-			print "Start server challenge (send version, send name, ...)."
+    def processPacket(self, new_packet):
+        self.__recv_buffer.append(0,new_packet.data)
+    
+    def readCmd(self, timeout=1.000):
+        return self.__recv_buffer.readBlocking(0,timeout)
+    
+    def serverChallenge(self):
+        if self.verbose: 
+            print "Start server challenge (send version, send name, ...)."
 
-		cmd = self.readCmd()
-		if cmd==None: return False
-		if cmd != "Version?": 
-			if self.debug: print "Server answer: %s instead of Version?" % (cmd)
-			return False
-		self.sendCmd(self.__protocol_version)
-		
-		cmd = self.readCmd()
-		if cmd==None: return False
-		if cmd != "OK":
-			if self.debug: print "Server answer: %s instead of OK" % (cmd)
-			return False
-		
-		cmd = self.readCmd()
-		if cmd==None: return False
-		if cmd != "Name?":
-			if self.debug: print "Server answer: %s instead of Name?" % (cmd)
-			return False
-		self.sendCmd(self.name)
+        cmd = self.readCmd()
+        if cmd==None: return False
+        if cmd != "Version?": 
+            if self.debug: print "Server answer: %s instead of Version?" % (cmd)
+            return False
+        self.sendCmd(self.__protocol_version)
+        
+        cmd = self.readCmd()
+        if cmd==None: return False
+        if cmd != "OK":
+            if self.debug: print "Server answer: %s instead of OK" % (cmd)
+            return False
+        
+        cmd = self.readCmd()
+        if cmd==None: return False
+        if cmd != "Name?":
+            if self.debug: print "Server answer: %s instead of Name?" % (cmd)
+            return False
+        self.sendCmd(self.name)
 
-		if self.debug: print "Challenge: Wait Name OK"
-		cmd = self.readCmd()
-		if cmd==None: return False
-		if cmd != "OK":
-			if self.debug: print "Server answer: %s instead of OK" % (cmd)
-			return False
-		if self.verbose: print "Server challenge done."
-		return True
+        if self.debug: print "Challenge: Wait Name OK"
+        cmd = self.readCmd()
+        if cmd==None: return False
+        if cmd != "OK":
+            if self.debug: print "Server answer: %s instead of OK" % (cmd)
+            return False
+        if self.verbose: print "Server challenge done."
+        return True
 
-	def start(self, host, port):
-		# Try to connect to server
-		if self.verbose: 
-			print "Try to connect to server %s:%s" % (host, port)
-		self.__io.on_disconnect = self.onDisconnect
-		self.__io.on_lost_connection = self.onLostConnection
-		self.__io.on_new_packet = self.processPacket
-		self.__io.connect(host, port)
+    def start(self, host, port):
+        # Try to connect to server
+        if self.verbose: 
+            print "Try to connect to server %s:%s" % (host, port)
+        self.__io.on_disconnect = self.onDisconnect
+        self.__io.on_lost_connection = self.onLostConnection
+        self.__io.on_new_packet = self.processPacket
+        self.__io.connect(host, port)
 
-		thread.start_new_thread( self.__io.run_thread, ())
+        thread.start_new_thread( self.__io.run_thread, ())
 
-		# Server "challenge" (version, name, ...)
-		if self.serverChallenge() != True:
-			if not self.quit:
-				print "Server communication mistake !?"
-			self.stop()
-			return
+        # Server "challenge" (version, name, ...)
+        if self.serverChallenge() != True:
+            if not self.quit:
+                print "Server communication mistake !?"
+            self.stop()
+            return
 
-		thread.start_new_thread( self.runIo, ())
+        thread.start_new_thread( self.runIo, ())
 
-	def setDebugMode(self, debug):
-		self.debug = debug
-		self.__io.debug = debug
+    def setDebugMode(self, debug):
+        self.debug = debug
+        self.__io.debug = debug
 
-	def setVerbose(self, verbose):
-		self.verbose = verbose
-		self.__io.verbose = verbose
+    def setVerbose(self, verbose):
+        self.verbose = verbose
+        self.__io.verbose = verbose
 
-	def sendCmd(self, cmd):
-		self.__io.send( io.Packet(cmd))
+    def sendCmd(self, cmd):
+        self.__io.send( io.Packet(cmd))
 
-	def processCmd(self, cmd):
-		if cmd != "": self.sendCmd(cmd)
+    def processCmd(self, cmd):
+        if cmd != "": self.sendCmd(cmd)
 
-	def runIo(self):
-		while 1:
-			cmd = self.__recv_buffer.readNonBlocking(0)
-			while cmd != None:
-				if cmd == "quit":
-					self.stop()
-					break
-				cmd = self.__recv_buffer.readNonBlocking(0)
-			time.sleep(0.250)
-	
-	def live(self):
-		if self.use_readline: import readline
-		while self.quit == False:
-			cmd = raw_input("cmd ? ")
-			if cmd != "":
-				self.processCmd(cmd)
-			if (cmd == "quit") or (cmd == "close"):
-				self.quit = True
+    def runIo(self):
+        while 1:
+            cmd = self.__recv_buffer.readNonBlocking(0)
+            while cmd != None:
+                if cmd == "quit":
+                    self.stop()
+                    break
+                cmd = self.__recv_buffer.readNonBlocking(0)
+            time.sleep(0.250)
+    
+    def live(self):
+        if self.use_readline: import readline
+        while self.quit == False:
+            cmd = raw_input("cmd ? ")
+            if cmd != "":
+                self.processCmd(cmd)
+            if (cmd == "quit") or (cmd == "close"):
+                self.quit = True
 
-	def onDisconnect(self):
-		print "Disconnect from server."
-		self.stop()
+    def onDisconnect(self):
+        print "Disconnect from server."
+        self.stop()
 
-	def onLostConnection(self):
-		print "Lost connection with server."
-		self.stop()
+    def onLostConnection(self):
+        print "Lost connection with server."
+        self.stop()
 
-	def stop(self):
-		if not self.active: return
-		self.active = False
-		self.quit = True
-		self.__io.stop()
-		print "Input closed."
+    def stop(self):
+        if not self.active: return
+        self.active = False
+        self.quit = True
+        self.__io.stop()
+        print "Input closed."

Modified: happyboom/trunk/net/io/io_client.py
===================================================================
--- happyboom/trunk/net/io/io_client.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io/io_client.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,52 +1,52 @@
 import socket
 
 class IO_Client(object):
-	""" IO Client.
-	@ivar __addr: Client address (host, port).
-	@type __addr: C{(str,int)}
-	@ivar connected: Is client connected ?
-	@type connected: C{bool}
-	@ivar io: Main IO used by client.
-	@type io: C{L{BaseIO}}
-	@ivar name: Client name.
-	@type name: C{str}
-	"""
-	
-	def __init__(self, io, addr, name=None):
-		""" Constructor.
-		@parameter io: Main IO used by client.
-		@type io: C{L{BaseIO}}
-		@parameter addr: Client address (host, port).
-		@type addr: C{(str,int)}
-		@parameter name: Client name.
-		@type name: C{str}
-		"""
-		self.__addr = addr
-		self.name = name
-		self.connected = True 
-		self.io = io
-		if self.name == None:
-			self.name = "%s:%u" % (self.host, self.port)
+    """ IO Client.
+    @ivar __addr: Client address (host, port).
+    @type __addr: C{(str,int)}
+    @ivar connected: Is client connected ?
+    @type connected: C{bool}
+    @ivar io: Main IO used by client.
+    @type io: C{L{BaseIO}}
+    @ivar name: Client name.
+    @type name: C{str}
+    """
+    
+    def __init__(self, io, addr, name=None):
+        """ Constructor.
+        @parameter io: Main IO used by client.
+        @type io: C{L{BaseIO}}
+        @parameter addr: Client address (host, port).
+        @type addr: C{(str,int)}
+        @parameter name: Client name.
+        @type name: C{str}
+        """
+        self.__addr = addr
+        self.name = name
+        self.connected = True 
+        self.io = io
+        if self.name == None:
+            self.name = "%s:%u" % (self.host, self.port)
 
-	def send(self, packet):
-		""" Send a packet to the client.
-		@type packet: C{L{Packet}}
-		"""
-		pass
+    def send(self, packet):
+        """ Send a packet to the client.
+        @type packet: C{L{Packet}}
+        """
+        pass
 
-	def disconnect(self):	
-		""" Disconnect the client. """
-		self.connected = False
-		self.io.disconnectClient(self)
+    def disconnect(self):    
+        """ Disconnect the client. """
+        self.connected = False
+        self.io.disconnectClient(self)
 
-	def __getAddr(self):
-		return self.__addr
-	def __getHost(self):
-		if self.__addr[0]=='': return 'localhost'
-		return self.__addr[0]
-	def __getPort(self):
-		return self.__addr[1]
+    def __getAddr(self):
+        return self.__addr
+    def __getHost(self):
+        if self.__addr[0]=='': return 'localhost'
+        return self.__addr[0]
+    def __getPort(self):
+        return self.__addr[1]
 
-	addr = property(__getAddr, doc="Client address (host, port)")
-	host = property(__getHost, doc="Client network hostname.")
-	port = property(__getPort, doc="Client network port.")
+    addr = property(__getAddr, doc="Client address (host, port)")
+    host = property(__getHost, doc="Client network hostname.")
+    port = property(__getPort, doc="Client network port.")

Modified: happyboom/trunk/net/io_tcp/server_waiter.py
===================================================================
--- happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,124 +1,124 @@
 import socket
-import threading
+import thread
 import traceback
 from tcp_client import TCP_Client
 
 class NetworkServerWaiter(object):
-	def __init__(self, server):
-		self.__server = server
-		self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-		self.__port = None
-		self.__host = ''
-		self.__max_clients = None
-		self.__nb_clients = 0
-		self.__nb_clients_sema = threading.Semaphore()
-		self.__listening = False
-		self.__listening_sema = threading.Semaphore()
-		self.__running = False
+    def __init__(self, server):
+        self.__server = server
+        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.__port = None
+        self.__host = ''
+        self.__max_clients = None
+        self.__nb_clients = 0
+        self.__nb_clients_sema = thread.allocate_lock()
+        self.__listening = False
+        self.__listening_sema = thread.allocate_lock()
+        self.__running = False
 
-	def isRunning(self):
-		return self.__running
+    def isRunning(self):
+        return self.__running
 
-	def run_thread(self, port, max_connection):
-		try:
-			self.__running = True
-			self.start(port, max_connection)
-		except Exception, msg:
-			print "NETWORK SERVER EXCEPTION!"
-			print "ERROR MSG: %s" % (msg)
-		traceback.print_exc()
-		self.__running = False 
-		
-	def clientConnect(self, client):
-		if self.__server.debug:
-			print "Client %s enter server %s." \
-				% (client.name, self.__server.name)
-		self.__nb_clients_sema.acquire()
-		self.__nb_clients = self.__nb_clients + 1
-		self.__nb_clients_sema.release()
-		self.__server.clientConnect (client)
+    def run_thread(self, port, max_connection):
+        try:
+            self.__running = True
+            self.start(port, max_connection)
+        except Exception, msg:
+            print "NETWORK SERVER EXCEPTION!"
+            print "ERROR MSG: %s" % (msg)
+            traceback.print_exc()
+        self.__running = False 
+        
+    def clientConnect(self, client):
+        if self.__server.debug:
+            print "Client %s enter server %s." \
+                % (client.name, self.__server.name)
+        self.__nb_clients_sema.acquire()
+        self.__nb_clients = self.__nb_clients + 1
+        self.__nb_clients_sema.release()
+        self.__server.clientConnect (client)
 
-	def clientDisconnect(self, client):
-		if self.__server.debug: print "New client : %s" % (client.getName())
-		self.__nb_clients_sema.acquire()
-		self.__nb_clients = self.__nb_clients - 1
-		self.__nb_clients_sema.release()
+    def clientDisconnect(self, client):
+        if self.__server.debug: print "New client : %s" % (client.getName())
+        self.__nb_clients_sema.acquire()
+        self.__nb_clients = self.__nb_clients - 1
+        self.__nb_clients_sema.release()
 
-	def waitClient(self):
-		try:
-			(conn, addr) = self.__socket.accept()
-		except socket.error, err:
-			if err[0] == 11: # Resource temporarily unavailable
-				return None
-			raise
-		if self.__max_clients <= self.getNbClients():
-			if self.__server.debug:
-				print "Client %s refused on server %s (too many connection, %u/%u)." \
-					% (addr, self.__server.name, \
-					   self.getNbClients(), self.__max_clients)
-			conn.close()
-			return None
-		return TCP_Client(self.__server, addr, socket=conn)
+    def waitClient(self):
+        try:
+            (conn, addr) = self.__socket.accept()
+        except socket.error, err:
+            if err[0] == 11: # Resource temporarily unavailable
+                return None
+            raise
+        if self.__max_clients <= self.getNbClients():
+            if self.__server.debug:
+                print "Client %s refused on server %s (too many connection, %u/%u)." \
+                    % (addr, self.__server.name, \
+                       self.getNbClients(), self.__max_clients)
+            conn.close()
+            return None
+        return TCP_Client(self.__server, addr, socket=conn)
 
-	def start(self, port, max_connection):
-		self.__max_clients = max_connection
-		self.__port = port
-		if self.__server.debug: 
-			print "Start %s on port %u." \
-				% (self.__server.name, port)
-		self.__socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-		try:
-			self.__socket.bind((self.__host, self.__port))
-			self.__socket.listen(max_connection)
-		except socket.error, err:
-			if self.__server.debug:
-				print "Binding error for %s." % (self.__server.name)
-			if self.__server.on_binding_error != None:
-				self.__server.on_binding_error (self.__server)
-			return
-		if self.__server.debug: 
-			print "Server %s is listening (max=%u clients)." \
-				% (self.__server.name, max_connection)
-		self.__listening_sema.acquire()
-		self.__listening = True 
-		self.__listening_sema.release()
+    def start(self, port, max_connection):
+        self.__max_clients = max_connection
+        self.__port = port
+        if self.__server.debug: 
+            print "Start %s on port %u." \
+                % (self.__server.name, port)
+        self.__socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        try:
+            self.__socket.bind((self.__host, self.__port))
+            self.__socket.listen(max_connection)
+        except socket.error, err:
+            if self.__server.debug:
+                print "Binding error for %s." % (self.__server.name)
+            if self.__server.on_binding_error != None:
+                self.__server.on_binding_error (self.__server)
+            return
+        if self.__server.debug: 
+            print "Server %s is listening (max=%u clients)." \
+                % (self.__server.name, max_connection)
+        self.__listening_sema.acquire()
+        self.__listening = True 
+        self.__listening_sema.release()
 
-		while 1:
-			try:
-				client = self.waitClient()
-				if client != None: self.clientConnect (client)
-				client = None
+        while 1:
+            try:
+                client = self.waitClient()
+                if client != None: self.clientConnect (client)
+                client = None
 
-			except socket.error, error:
-				# Connection reset by peer.
-				if error[0] == 104:
-					if client != None: client.disconnect()
-				else:
-					raise
+            except socket.error, error:
+                # Connection reset by peer.
+                if error[0] == 104:
+                    if client != None: client.disconnect()
+                else:
+                    raise
 
-	def getNbClients(self):
-		self.__nb_clients_sema.acquire()
-		val = self.__nb_clients
-		self.__nb_clients_sema.release()
-		return val
-	nb_clients = property(getNbClients)
-	
-	def getMaxClients(self):
-		return self.__max_clients
-	max_clients = property(getMaxClients)
-		
-	def getListening(self):
-		self.__listening_sema.acquire()
-		listening = self.__listening
-		self.__listening_sema.release()
-		return listening
-	listening = property(getListening)
+    def getNbClients(self):
+        self.__nb_clients_sema.acquire()
+        val = self.__nb_clients
+        self.__nb_clients_sema.release()
+        return val
+    nb_clients = property(getNbClients)
+    
+    def getMaxClients(self):
+        return self.__max_clients
+    max_clients = property(getMaxClients)
+        
+    def getListening(self):
+        self.__listening_sema.acquire()
+        listening = self.__listening
+        self.__listening_sema.release()
+        return listening
+    listening = property(getListening)
 
-	def getPort(self):
-		return self.__port
-	port = property(getPort)
-	
-	def getHost(self):
-		if self.__host == '': return 'localhost'
-		return self.__host
-	host = property(getHost)
+    def getPort(self):
+        return self.__port
+    port = property(getPort)
+    
+    def getHost(self):
+        if self.__host == '': return 'localhost'
+        return self.__host
+    host = property(getHost)

Modified: happyboom/trunk/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io_tcp/tcp.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -3,7 +3,6 @@
 
 import time
 import thread
-import threading
 import socket
 import traceback
 import struct
@@ -27,7 +26,7 @@
     @ivar __clients: List of clients connected to this IO.
     @type __clients: C{list<L{IO_client<io.IO_Client>}>?}
     @ivar __clients_sema: Semaphore used to access L{__clients}.
-    @type __clients_sema: C{threading.Semaphore}
+    @type __clients_sema: C{thread.lock}
     @ivar __running: Is the thread running ?
     @type __running: C{bool}
     """
@@ -43,7 +42,7 @@
         self.__addr = None
         self.__clients = {}
         self.__server = None
-        self.__clients_sema = threading.Semaphore()
+        self.__clients_sema = thread.allocate_lock()
         self.__running = False 
         io.Packet.use_tcp = True
 

Modified: happyboom/trunk/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -2,79 +2,79 @@
 import socket
 
 class TCP_Client(io.IO_Client):
-	""" An TCP client.
-	@ivar __socket: The TCP socket
-	@type __socket: C{socket}
-	@ivar on_send: Event called when a packet is sent to the client.
-	@type on_send: C{function}
-	@ivar on_receive: Event called when a new packet is received.
-	@type on_receive: C{function}
-	"""
-	def __init__(self, io_tcp, addr, name=None, socket=None):
-		io.IO_Client.__init__(self, io_tcp, addr, name)
-		self.__socket = socket 
-		self.on_send = None
-		self.on_receive = None
+    """ An TCP client.
+    @ivar __socket: The TCP socket
+    @type __socket: C{socket}
+    @ivar on_send: Event called when a packet is sent to the client.
+    @type on_send: C{function}
+    @ivar on_receive: Event called when a new packet is received.
+    @type on_receive: C{function}
+    """
+    def __init__(self, io_tcp, addr, name=None, socket=None):
+        io.IO_Client.__init__(self, io_tcp, addr, name)
+        self.__socket = socket 
+        self.on_send = None
+        self.on_receive = None
 
-	def send(self, packet):
-		""" Send a packet to the client.
-		@type packet: Packet
-		"""
-		self.sendBinary( packet.pack() )
-	
-	def sendBinary(self, data):
-		""" Send binary datas to the client.
-		@type data: str
-		"""
-		if not self.connected: return
-		self.__socket.send(data)
+    def send(self, packet):
+        """ Send a packet to the client.
+        @type packet: Packet
+        """
+        self.sendBinary( packet.pack() )
+    
+    def sendBinary(self, data):
+        """ Send binary datas to the client.
+        @type data: str
+        """
+        if not self.connected: return
+        self.__socket.send(data)
 
-		# Call user event if needed
-		if self.on_send != None: self.on_send(data)
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
 
-	def receiveNonBlocking(self, max_size=1024):
-		""" Non blocking read on the socket. """
-		if not self.connected: return
-		try:
-			self.__socket.setblocking(0)
-			data = self.__socket.recv(max_size)
-		except socket.error, err:
-			if err[0] == 11: return None
-			# Broken pipe (32) or Connection reset by peer (104)
-			if err[0] in (32, 104,):
-				self.disconnect()
-				return None
-			raise
-		return self.__processRecvData(data)
+    def receiveNonBlocking(self, max_size=1024):
+        """ Non blocking read on the socket. """
+        if not self.connected: return
+        try:
+            self.__socket.setblocking(0)
+            data = self.__socket.recv(max_size)
+        except socket.error, err:
+            if err[0] == 11: return None
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+        return self.__processRecvData(data)
 
-	def receiveBlocking(self, max_size=1024):
-		""" Blocking read on the socket. """
-		if not self.connected: return
-		try:
-			self.__socket.setblocking(1)
-			data = self.__socket.recv(max_size)
-		except socket.error, err:
-			# Broken pipe (32) or Connection reset by peer (104)
-			if err[0] in (32, 104,):
-				self.disconnect()
-				return None
-			print err
-			raise
-		return self.__processRecvData(data)
+    def receiveBlocking(self, max_size=1024):
+        """ Blocking read on the socket. """
+        if not self.connected: return
+        try:
+            self.__socket.setblocking(1)
+            data = self.__socket.recv(max_size)
+        except socket.error, err:
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            print err
+            raise
+        return self.__processRecvData(data)
 
-	def disconnect(self):
-		""" Disconned the client : close the socket. """
-		self.__socket.close()
-		io.IO_Client.disconnect(self)
+    def disconnect(self):
+        """ Disconned the client : close the socket. """
+        self.__socket.close()
+        io.IO_Client.disconnect(self)
 
-	def __processRecvData(self, data):
-		# If no data, connection is lost
-		if len(data)==0:
-			if self.io.verbose:
-				print "Client %s lost connection with server!" % (self.name)
-			self.disconnect()
-			return None
+    def __processRecvData(self, data):
+        # If no data, connection is lost
+        if len(data)==0:
+            if self.io.verbose:
+                print "Client %s lost connection with server!" % (self.name)
+            self.disconnect()
+            return None
 
-		# Call user event if needed
-		if self.on_receive != None: self.on_receive(data)
-		return data
+        # Call user event if needed
+        if self.on_receive != None: self.on_receive(data)
+        return data

Modified: happyboom/trunk/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/net/io_udp/udp.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io_udp/udp.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,7 +1,7 @@
 # -*- coding: ISO-8859-1 -*-
 
 import time
-import threading
+import thread
 import socket
 import traceback
 import struct
@@ -9,353 +9,353 @@
 from udp_client import UDP_Client
 
 class IO_UDP(io.BaseIO):
-	""" IO for UDP transport.
-	@ivar packet_timeout: Try to send a packet until this timeout.
-	@type packet_timeout: C{float}
-	@ivar thread_sleep: Sleep time used in the thread.
-	@type thread_sleep: C{float}
-	@ivar __is_server: ??? 
-	@type __is_server: C{bool}
-	@ivar __server: The server (only used by clients, None else).
-	@type __server: ?
-	@ivar __running: Is the thread running ?
-	@type __running: C{bool}
-	@ivar __socket: The network socket.
-	@type __socket: C{socket}
-	@ivar __socket_open: Is the network socket L{__socket} opened ?
-	@type __socket_open: C{bool}
-	@ivar __addr: The IO network address (host, port).
-	@type __addr: C{(string, string,)}
-	@ivar __packet_id: ???
-	@type __packet_id: C{int}
-	@ivar __clients: List of clients connected to this IO.
-	@type __clients: C{list<L{IO_client<io.IO_Client>}>?}
-	@ivar __clients_sema: Semaphore used to access L{__clients}.
-	@type __clients_sema: C{threading.Semaphore}
-	"""
-	
-	def __init__(self, is_server=False):
-		""" Constructor. """
-		io.BaseIO.__init__(self)
-		self.packet_timeout = 1.000
-		self.thread_sleep = 0.010
+    """ IO for UDP transport.
+    @ivar packet_timeout: Try to send a packet until this timeout.
+    @type packet_timeout: C{float}
+    @ivar thread_sleep: Sleep time used in the thread.
+    @type thread_sleep: C{float}
+    @ivar __is_server: ??? 
+    @type __is_server: C{bool}
+    @ivar __server: The server (only used by clients, None else).
+    @type __server: ?
+    @ivar __running: Is the thread running ?
+    @type __running: C{bool}
+    @ivar __socket: The network socket.
+    @type __socket: C{socket}
+    @ivar __socket_open: Is the network socket L{__socket} opened ?
+    @type __socket_open: C{bool}
+    @ivar __addr: The IO network address (host, port).
+    @type __addr: C{(string, string,)}
+    @ivar __packet_id: ???
+    @type __packet_id: C{int}
+    @ivar __clients: List of clients connected to this IO.
+    @type __clients: C{list<L{IO_client<io.IO_Client>}>?}
+    @ivar __clients_sema: Lock used to access L{__clients}.
+    @type __clients_sema: C{thread.lock}
+    """
+    
+    def __init__(self, is_server=False):
+        """ Constructor. """
+        io.BaseIO.__init__(self)
+        self.packet_timeout = 1.000
+        self.thread_sleep = 0.010
 
-		self.__is_server = is_server
-		self.__server = None # only used in client mode
-		self.__running = True
+        self.__is_server = is_server
+        self.__server = None # only used in client mode
+        self.__running = True
 
-		self.__socket = None
-		self.__socket_open = False		
-		self.__addr = None
-		self.__packet_id = 0
-		self.__clients = {}
-		self.__clients_sema = threading.Semaphore()
+        self.__socket = None
+        self.__socket_open = False        
+        self.__addr = None
+        self.__packet_id = 0
+        self.__clients = {}
+        self.__clients_sema = thread.allocate_lock()
 
-	def connect(self, host, port):
-		""" Connect to host:port 
-		@type host: C{str}
-		@type port: C{int}
-		"""
-		if host != "":
-			host = socket.gethostbyname(host)
-		else:
-			host = "127.0.0.1"
-		self.__addr = (host, port,)
-		self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
-		if self.__is_server:
-			if self.verbose:
-				print "Run server at %s:%u (udp)" % ("", self.port)
-			self.__socket.bind(("",port,))
-		else:
-			if self.verbose:
-				print "Connect to server %s:%u" % (self.host, self.port)
-			self.__server = UDP_Client(self, self.__addr)
-			self.__server.name = "server"
-			self.__server.send_ping = True
-			self.__clients_sema.acquire()
-			self.__clients[self.__addr] = self.__server
-			self.__clients_sema.release()
+    def connect(self, host, port):
+        """ Connect to host:port 
+        @type host: C{str}
+        @type port: C{int}
+        """
+        if host != "":
+            host = socket.gethostbyname(host)
+        else:
+            host = "127.0.0.1"
+        self.__addr = (host, port,)
+        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        if self.__is_server:
+            if self.verbose:
+                print "Run server at %s:%u (udp)" % ("", self.port)
+            self.__socket.bind(("",port,))
+        else:
+            if self.verbose:
+                print "Connect to server %s:%u" % (self.host, self.port)
+            self.__server = UDP_Client(self, self.__addr)
+            self.__server.name = "server"
+            self.__server.send_ping = True
+            self.__clients_sema.acquire()
+            self.__clients[self.__addr] = self.__server
+            self.__clients_sema.release()
 
-		self.__socket_open = True
-		self.__socket.setblocking(0)
+        self.__socket_open = True
+        self.__socket.setblocking(0)
 
-		if not self.__is_server:
-			self.send( io.Packet("I'm here") )
-		
-		io.BaseIO.connect(self, host, port)
+        if not self.__is_server:
+            self.send( io.Packet("I'm here") )
+        
+        io.BaseIO.connect(self, host, port)
 
-		# Call user event if needed
-		if self.on_connect != None: self.on_connect()
+        # Call user event if needed
+        if self.on_connect != None: self.on_connect()
 
-	def disconnect(self):
-		""" Close connection. """
-		if not self.__socket_open: return
-		self.__socket.close()
-		self.__socket_open = False
-		if self.on_disconnect != None: self.on_disconnect()
-		self.stop()
+    def disconnect(self):
+        """ Close connection. """
+        if not self.__socket_open: return
+        self.__socket.close()
+        self.__socket_open = False
+        if self.on_disconnect != None: self.on_disconnect()
+        self.stop()
 
-	def disconnectClient(self, client):
-		""" Disconnect a client.
-		@type client: C{L{IO_Client<io.IO_Client>}}
-		"""
-		self.__clients_sema.acquire()
-		if self.__clients.has_key(client.addr): del self.__clients[client.addr]
-		self.__clients_sema.release()
-		if self.verbose:
-			print "Disconnect client %s" % (client.name)
-		if self.on_client_disconnect != None: self.on_client_disconnect(client)
-	
-	def send(self, packet, to=None):
-		""" Send a packet to the server or to all clients.
-		@type packet: C{L{Packet<io.Packet>}}
-		@type to: C{L{IO_Client<io.IO_Client>}}
-		"""
-		if not self.__socket_open: return
-		first_send = (packet.sent == 0)
-		
-		# No client, exit !
-		if self.__is_server:
-			self.__clients_sema.acquire()
-			nb_clients = len(self.__clients)
-			self.__clients_sema.release()
-			if nb_clients==0: return None
+    def disconnectClient(self, client):
+        """ Disconnect a client.
+        @type client: C{L{IO_Client<io.IO_Client>}}
+        """
+        self.__clients_sema.acquire()
+        if self.__clients.has_key(client.addr): del self.__clients[client.addr]
+        self.__clients_sema.release()
+        if self.verbose:
+            print "Disconnect client %s" % (client.name)
+        if self.on_client_disconnect != None: self.on_client_disconnect(client)
+    
+    def send(self, packet, to=None):
+        """ Send a packet to the server or to all clients.
+        @type packet: C{L{Packet<io.Packet>}}
+        @type to: C{L{IO_Client<io.IO_Client>}}
+        """
+        if not self.__socket_open: return
+        first_send = (packet.sent == 0)
+        
+        # No client, exit !
+        if self.__is_server:
+            self.__clients_sema.acquire()
+            nb_clients = len(self.__clients)
+            self.__clients_sema.release()
+            if nb_clients==0: return None
 
-		# Prepare the packet
-		packet.prepareSend()
-		if first_send:
-			# First send : give an ID to the packet
-			self.__packet_id = self.__packet_id + 1
-			packet.id = self.__packet_id
-			if self.debug: packet.creation = time.time()
-		need_ack = first_send and not packet.skippable
-		
-		# Read binary version of the packet
-		data = packet.pack()
+        # Prepare the packet
+        packet.prepareSend()
+        if first_send:
+            # First send : give an ID to the packet
+            self.__packet_id = self.__packet_id + 1
+            packet.id = self.__packet_id
+            if self.debug: packet.creation = time.time()
+        need_ack = first_send and not packet.skippable
+        
+        # Read binary version of the packet
+        data = packet.pack()
 
-		# Send data to client(s)
-		if self.__is_server:
-			if to==None:
-				for addr,client in self.clients.items(): # use internal copy for clients
-					self.__sendDataTo(packet, data, client, need_ack)
-			else:
-				self.__sendDataTo(packet, data, to, need_ack)
-		else:
-			self.__sendDataTo(packet, data, self.__server, need_ack)
-		
-	def sendBinary(self, data, client):
-		""" Send binary data that doesn't need an acknoledge. 
-		@type data: C{str}
-		@type client: C{L{IO_Client<io.IO_Client>}}
-		"""		
-		if self.debug: print "Send data %s to %s (without ack)" % (data, client.name)
-		self.__socket.sendto(data, client.addr)	
-		
-		# Call user event if needed
-		if self.on_send != None: self.on_send(data)
-	
-	def __sendDataTo(self, packet, data, client, need_ack):
-		""" Send binary data with an acknoledge to a client.
-		@type data: C{str}
-		@type client: C{L{IO_Client<io.IO_Client>}}
-		@type need_ack: C{bool}
-		"""
-		if self.debug: print "Send packet %s to %s" % (packet.toStr(), client.name)
-		self.__socket.sendto(data, client.addr)
+        # Send data to client(s)
+        if self.__is_server:
+            if to==None:
+                for addr,client in self.clients.items(): # use internal copy for clients
+                    self.__sendDataTo(packet, data, client, need_ack)
+            else:
+                self.__sendDataTo(packet, data, to, need_ack)
+        else:
+            self.__sendDataTo(packet, data, self.__server, need_ack)
+        
+    def sendBinary(self, data, client):
+        """ Send binary data that doesn't need an acknoledge. 
+        @type data: C{str}
+        @type client: C{L{IO_Client<io.IO_Client>}}
+        """        
+        if self.debug: print "Send data %s to %s (without ack)" % (data, client.name)
+        self.__socket.sendto(data, client.addr)    
+        
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+    
+    def __sendDataTo(self, packet, data, client, need_ack):
+        """ Send binary data with an acknoledge to a client.
+        @type data: C{str}
+        @type client: C{L{IO_Client<io.IO_Client>}}
+        @type need_ack: C{bool}
+        """
+        if self.debug: print "Send packet %s to %s" % (packet.toStr(), client.name)
+        self.__socket.sendto(data, client.addr)
 
-		# If the packet need an ack, add it to the list
-		if need_ack: client.needAck(packet)
-		
-		# Call user event if needed
-		if self.on_send != None: self.on_send(data)
-	
-	def receive(self, max_size = 1024):
-		""" Read a packet from the socket.
-		Returns None if there is not new data.
-		@type max_size: C{int}
-		@rtype: C{L{Packet<io.Packet>}}
-		"""
-		if not self.__socket_open: return None
+        # If the packet need an ack, add it to the list
+        if need_ack: client.needAck(packet)
+        
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+    
+    def receive(self, max_size = 1024):
+        """ Read a packet from the socket.
+        Returns None if there is not new data.
+        @type max_size: C{int}
+        @rtype: C{L{Packet<io.Packet>}}
+        """
+        if not self.__socket_open: return None
 
-		# Try to read data from the socket
-		try:						
-			data,addr = self.__socket.recvfrom(max_size)
-		except socket.error, err:
-			if err[0] == 11: return None
-			raise
-	
-		# New client ?
-		return self.__processRecvData(data, addr)
+        # Try to read data from the socket
+        try:                        
+            data,addr = self.__socket.recvfrom(max_size)
+        except socket.error, err:
+            if err[0] == 11: return None
+            raise
+    
+        # New client ?
+        return self.__processRecvData(data, addr)
 
-	def live(self):				
-		""" Keep the connection alive. """
-		# Resend packets which don't have received their ack
-		for addr, client in self.clients.items(): # use internal copy for clients
-			client.live()							
-					
-		# Read data from network (if needed)
-		packet = self.receive()				
-		if packet != None: self.__processNewPacket(packet)
-					
+    def live(self):                
+        """ Keep the connection alive. """
+        # Resend packets which don't have received their ack
+        for addr, client in self.clients.items(): # use internal copy for clients
+            client.live()                            
+                    
+        # Read data from network (if needed)
+        packet = self.receive()                
+        if packet != None: self.__processNewPacket(packet)
+                    
 
-	def clientLostConnection(self, client):
-		if self.__is_server:
-			self.__lostClient(client)
-		else:
-			self.lostConnection()
+    def clientLostConnection(self, client):
+        if self.__is_server:
+            self.__lostClient(client)
+        else:
+            self.lostConnection()
 
-	def __lostClient(self, client):
-		if not client.addr in self.__clients: return
-		client = self.__clients[client.addr]
-		if self.verbose:
-			print "Lost connection with client %s !" % (client.name)
-		self.disconnectClient(client)
-	
-	def lostConnection(self):
-		if self.verbose:
-			print "Lost connection to %s:%u!" % (self.host, self.port)
-		if self.__socket_open:
-			self.__socket.close()
-			self.__socket_open = False
-		if self.on_lost_connection: self.on_lost_connection()
-		self.stop()
-	
-	def run_thread(self):
-		""" Function which should be called in a thread : call L{live()} with a sleep. """
-		try:
-			while self.__running:
-				self.live()				
-				time.sleep(self.thread_sleep)
-		except Exception, msg:
-			print "EXCEPTION DANS LE THREAD IO :"
-			print msg
-			traceback.print_exc()
-			self.stop()
+    def __lostClient(self, client):
+        if not client.addr in self.__clients: return
+        client = self.__clients[client.addr]
+        if self.verbose:
+            print "Lost connection with client %s !" % (client.name)
+        self.disconnectClient(client)
+    
+    def lostConnection(self):
+        if self.verbose:
+            print "Lost connection to %s:%u!" % (self.host, self.port)
+        if self.__socket_open:
+            self.__socket.close()
+            self.__socket_open = False
+        if self.on_lost_connection: self.on_lost_connection()
+        self.stop()
+    
+    def run_thread(self):
+        """ Function which should be called in a thread : call L{live()} with a sleep. """
+        try:
+            while self.__running:
+                self.live()                
+                time.sleep(self.thread_sleep)
+        except Exception, msg:
+            print "EXCEPTION DANS LE THREAD IO :"
+            print msg
+            traceback.print_exc()
+            self.stop()
 
-	def stop(self):
-		if not self.__running: return
-		self.__running = False 
-		self.disconnect()
+    def stop(self):
+        if not self.__running: return
+        self.__running = False 
+        self.disconnect()
 
-	def isRunning(self): return self.__running
+    def isRunning(self): return self.__running
 
-	#--- Private functions ------------------------------------------------------
+    #--- Private functions ------------------------------------------------------
 
-	def __processRecvData(self, data, addr):
-		if self.__is_server:
-			self.__clients_sema.acquire()
-			if addr not in self.__clients:
-				client = UDP_Client(self, addr)
-				self.__clients[addr] = client
-				self.__clients_sema.release()
-				if self.verbose: print "New client : %s:%u" % (addr[0], addr[1])
-				client.send_ping = True
-				if self.on_client_connect != None: self.on_client_connect(client)
-			else:
-				client = self.__clients[addr] 
-				self.__clients_sema.release()
-		else:
-			# Drop packets which doesn't come from server
-			if self.__server.addr != addr:
-				if self.debug:
-					print "Drop packet from %s:%u (it isn't the server address)" % (addr[0], addr[1])
-				return None
-			client = self.__server
-	
-		# Call user event if needed
-		if self.on_receive != None: self.on_receive(data)
-					
-		# Decode data to normal packet (unpack) 
-		packet = io.Packet()
-		packet.unpack(data)
-		if not packet.isValid():
-			if self.debug: print "Drop invalid packet (%s) from %s" % (data, client.name)			
-			return None
-		
-		# Return packet
-		packet.recv_from = client 
-		return self.__processPacket(packet)
+    def __processRecvData(self, data, addr):
+        if self.__is_server:
+            self.__clients_sema.acquire()
+            if addr not in self.__clients:
+                client = UDP_Client(self, addr)
+                self.__clients[addr] = client
+                self.__clients_sema.release()
+                if self.verbose: print "New client : %s:%u" % (addr[0], addr[1])
+                client.send_ping = True
+                if self.on_client_connect != None: self.on_client_connect(client)
+            else:
+                client = self.__clients[addr] 
+                self.__clients_sema.release()
+        else:
+            # Drop packets which doesn't come from server
+            if self.__server.addr != addr:
+                if self.debug:
+                    print "Drop packet from %s:%u (it isn't the server address)" % (addr[0], addr[1])
+                return None
+            client = self.__server
+    
+        # Call user event if needed
+        if self.on_receive != None: self.on_receive(data)
+                    
+        # Decode data to normal packet (unpack) 
+        packet = io.Packet()
+        packet.unpack(data)
+        if not packet.isValid():
+            if self.debug: print "Drop invalid packet (%s) from %s" % (data, client.name)            
+            return None
+        
+        # Return packet
+        packet.recv_from = client 
+        return self.__processPacket(packet)
 
-	def __processPacket(self, packet):
-		client = packet.recv_from
+    def __processPacket(self, packet):
+        client = packet.recv_from
 
-		if self.debug:
-			print "Received packet %s from %s:%u" % (packet.toStr(), client.host, client.port)
-		
-		# Send an ack if needed
-		if not packet.skippable: self.__sendAck(packet)
-		
-		# Is is a special packet (ack / ping / poing) ?
-		if packet.type == io.Packet.PACKET_ACK:
-			client.processAck(packet)
-			return None
-		if packet.type == io.Packet.PACKET_PING:
-			client.processPing(packet)
-			return None
-		if packet.type == io.Packet.PACKET_PONG:
-			client.processPong(packet)
-			return None
-			
-		# This packet is already received ? Drop it!
-		if client.alreadyReceived(packet.id):
-			if self.debug:
-				print "Drop packet %u (already received)" % (packet.id)
-			return None	
-			
-		client.receivePacket(packet)
-		
-		# Returns the new packet
-		return packet
+        if self.debug:
+            print "Received packet %s from %s:%u" % (packet.toStr(), client.host, client.port)
+        
+        # Send an ack if needed
+        if not packet.skippable: self.__sendAck(packet)
+        
+        # Is is a special packet (ack / ping / poing) ?
+        if packet.type == io.Packet.PACKET_ACK:
+            client.processAck(packet)
+            return None
+        if packet.type == io.Packet.PACKET_PING:
+            client.processPing(packet)
+            return None
+        if packet.type == io.Packet.PACKET_PONG:
+            client.processPong(packet)
+            return None
+            
+        # This packet is already received ? Drop it!
+        if client.alreadyReceived(packet.id):
+            if self.debug:
+                print "Drop packet %u (already received)" % (packet.id)
+            return None    
+            
+        client.receivePacket(packet)
+        
+        # Returns the new packet
+        return packet
 
-	def __sendAck(self, packet):
-		""" Send an ack for a packet.
-		@type packet: C{L{Packet<io.Packet>}}
-		"""
-		# Write ack to socket
-		ack = io.Packet(skippable=True)
-		ack.type = io.Packet.PACKET_ACK
-		ack.writeStr( struct.pack("!I", packet.id) )
-		#if self.debug: print "Send ACK %u." % (ack.id)
-		packet.recv_from.send(ack)
+    def __sendAck(self, packet):
+        """ Send an ack for a packet.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        # Write ack to socket
+        ack = io.Packet(skippable=True)
+        ack.type = io.Packet.PACKET_ACK
+        ack.writeStr( struct.pack("!I", packet.id) )
+        #if self.debug: print "Send ACK %u." % (ack.id)
+        packet.recv_from.send(ack)
 
-	def __processNewPacket(self, packet):
-		""" Do something with a new packet
-		@type packet: C{L{Packet<io.Packet>}}
-		"""
-		if self.verbose:
-			print "New udp message : %s" % (packet.toStr())
-		if self.on_new_packet != None: self.on_new_packet(packet)		
+    def __processNewPacket(self, packet):
+        """ Do something with a new packet
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        if self.verbose:
+            print "New udp message : %s" % (packet.toStr())
+        if self.on_new_packet != None: self.on_new_packet(packet)        
 
-	def __getPort(self):
-		return self.__addr[1]
+    def __getPort(self):
+        return self.__addr[1]
 
-	def __getHost(self):
-		if self.__addr[0]=='': return "localhost"
-		return self.__addr[0]
+    def __getHost(self):
+        if self.__addr[0]=='': return "localhost"
+        return self.__addr[0]
 
-	def __getAddr(self): return self.__addr
+    def __getAddr(self): return self.__addr
 
-	def __getName(self):
-		if self.__name != None: return self.__name
-		return self.host
-		
-	def __setName(self, name):
-		self.__name = name	
+    def __getName(self):
+        if self.__name != None: return self.__name
+        return self.host
+        
+    def __setName(self, name):
+        self.__name = name    
 
-	def __getClients(self):
-		self.__clients_sema.acquire()
-		clients = self.__clients.copy()
-		self.__clients_sema.release()
-		return clients
+    def __getClients(self):
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        return clients
 
-	def __getMaxClients(self):
-		return 0
-		
-	#--- Properties -------------------------------------------------------------
+    def __getMaxClients(self):
+        return 0
+        
+    #--- Properties -------------------------------------------------------------
 
-	name = property(__getName, __setName, doc="The IO name")
-	addr = property(__getAddr, doc="The IO addresse (host, port).")
-	port = property(__getPort, doc="The network port number.")
-	host = property(__getHost, doc="The network hostname.")
-	clients = property(__getClients, doc="List of clients.")
-	max_clients = property(__getMaxClients, doc="Maximum number of clients connected to the server.")
+    name = property(__getName, __setName, doc="The IO name")
+    addr = property(__getAddr, doc="The IO addresse (host, port).")
+    port = property(__getPort, doc="The network port number.")
+    host = property(__getHost, doc="The network hostname.")
+    clients = property(__getClients, doc="List of clients.")
+    max_clients = property(__getMaxClients, doc="Maximum number of clients connected to the server.")

Modified: happyboom/trunk/net/io_udp/udp_client.py
===================================================================
--- happyboom/trunk/net/io_udp/udp_client.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io_udp/udp_client.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,145 +1,145 @@
 from net import io
-import threading
+import thread
 import time
 import struct
 from udp_ping import UDP_Pinger 
 
 class UDP_Client(io.IO_Client):
-	""" An UDP Client.
-	@ivar __waitAck: List of packets (id) which are waiting for an acknoledge.
-	@type __waitAck: C{dict<int>, L{Packet<io.Packet>}}
-	@ivar __waitAck_sema: Semaphore used to access L{__waitAck}.
-	@type __waitAck_sema: C{threading.Semaphore}
-	@ivar __received: List of received packets (id). List used to remove duplicated packets.
-	@type __received: C{dict<int, L{Packet<io.Packet>}>}
-	@ivar __received_sema: Semaphore used to access L{__received}.
-	@type __received_sema: C{threading.Semaphore}
-	@ivar __pinger: Send regulary ping to server.
-	@type __pinger: C{L{UDP_Pinger}}
-	"""
-	def __init__(self, io_udp, addr, name=None):
-		""" Constructor.
-		@parameter io_udp: Main IO.
-		@type io_udp: C{L{IO_UDP}}
-		@parameter addr: The client network address (host, port).
-		@type addr: C{(str, int)}
-		@parameter name: The client name.
-		@type name: C{str}
-		"""
-		io.IO_Client.__init__(self, io_udp, addr, name)
-		self.send_ping = False
-		self.__waitAck = {}
-		self.__received = {}
-		self.__waitAck_sema = threading.Semaphore()
-		self.__received_sema = threading.Semaphore()
-		self.__pinger = UDP_Pinger(self)
+    """ An UDP Client.
+    @ivar __waitAck: List of packets (id) which are waiting for an acknoledge.
+    @type __waitAck: C{dict<int>, L{Packet<io.Packet>}}
+    @ivar __waitAck_sema: Lock used to access L{__waitAck}.
+    @type __waitAck_sema: C{thread.lock}
+    @ivar __received: List of received packets (id). List used to remove duplicated packets.
+    @type __received: C{dict<int, L{Packet<io.Packet>}>}
+    @ivar __received_sema: Lock used to access L{__received}.
+    @type __received_sema: C{thread.lock}
+    @ivar __pinger: Send regulary ping to server.
+    @type __pinger: C{L{UDP_Pinger}}
+    """
+    def __init__(self, io_udp, addr, name=None):
+        """ Constructor.
+        @parameter io_udp: Main IO.
+        @type io_udp: C{L{IO_UDP}}
+        @parameter addr: The client network address (host, port).
+        @type addr: C{(str, int)}
+        @parameter name: The client name.
+        @type name: C{str}
+        """
+        io.IO_Client.__init__(self, io_udp, addr, name)
+        self.send_ping = False
+        self.__waitAck = {}
+        self.__received = {}
+        self.__waitAck_sema = thread.allocate_lock()
+        self.__received_sema = thread.allocate_lock()
+        self.__pinger = UDP_Pinger(self)
 
-	def alreadyReceived(self, id):
-		""" Tell if a packet (id) is already received.
-		@rtype: C{bool}
-		"""
-		self.__received_sema.acquire()
-		received = id in self.__received
-		self.__received_sema.release()
-		return received
+    def alreadyReceived(self, id):
+        """ Tell if a packet (id) is already received.
+        @rtype: C{bool}
+        """
+        self.__received_sema.acquire()
+        received = id in self.__received
+        self.__received_sema.release()
+        return received
 
-	def receivePacket(self, packet):
-		""" Process a new received packet.
-		@type packet: C{L{Packet<io.Packet>}}
-		"""
-		if packet.skippable: return
-		
-		# Store packet to drop packet which are receive twice
-		timeout = time.time()+io.Packet.total_timeout
-		self.__received_sema.acquire()
-		self.__received[packet.id] = timeout 
-		self.__received_sema.release()	
+    def receivePacket(self, packet):
+        """ Process a new received packet.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        if packet.skippable: return
+        
+        # Store packet to drop packet which are receive twice
+        timeout = time.time()+io.Packet.total_timeout
+        self.__received_sema.acquire()
+        self.__received[packet.id] = timeout 
+        self.__received_sema.release()    
 
-	def processPing(self, id):
-		""" Process a new received ping.
-		@type id: C{int}
-		"""
-		self.__pinger.processPing(id)
-		
-	def processPong(self, id):
-		""" Process a new received pong.
-		@type id: C{int}
-		"""
-		self.__pinger.processPong(id)
-		
-	def processAck(self, packet):
-		""" Process new received acknoledge.
-		@type packet: C{L{Packet<io.Packet>}}
-		"""
-		# Read packet ID
-		format  = "!I"
-		if len(packet.data) != struct.calcsize(format): return None
-		data = struct.unpack(format, packet.data)
-		id = data[0]
+    def processPing(self, id):
+        """ Process a new received ping.
+        @type id: C{int}
+        """
+        self.__pinger.processPing(id)
+        
+    def processPong(self, id):
+        """ Process a new received pong.
+        @type id: C{int}
+        """
+        self.__pinger.processPong(id)
+        
+    def processAck(self, packet):
+        """ Process new received acknoledge.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        # Read packet ID
+        format  = "!I"
+        if len(packet.data) != struct.calcsize(format): return None
+        data = struct.unpack(format, packet.data)
+        id = data[0]
 
-		# Packet still exists ?
-		self.__waitAck_sema.acquire()
-		if not self.__waitAck.has_key(id):
-			self.__waitAck_sema.release()
-			return
+        # Packet still exists ?
+        self.__waitAck_sema.acquire()
+        if not self.__waitAck.has_key(id):
+            self.__waitAck_sema.release()
+            return
 
-		# Debug message
-		if self.io.debug:
-			t = time.time() - self.__waitAck[id].creation
-			print "Ack %u received (time=%.1f ms)" % (id, t*1000)
+        # Debug message
+        if self.io.debug:
+            t = time.time() - self.__waitAck[id].creation
+            print "Ack %u received (time=%.1f ms)" % (id, t*1000)
 
-		# The packet don't need ack anymore
-		del self.__waitAck[id]
-		self.__waitAck_sema.release()
+        # The packet don't need ack anymore
+        del self.__waitAck[id]
+        self.__waitAck_sema.release()
 
-	def disconnect(self):
-		""" Disconnect client. """
-		self.io.disconnectClient(self)
+    def disconnect(self):
+        """ Disconnect client. """
+        self.io.disconnectClient(self)
 
-	def needAck(self, packet):
-		""" Tell that a packet needs an acknoledge. """
-		self.__waitAck_sema.acquire()
-		self.__waitAck[packet.id] = packet
-		self.__waitAck_sema.release()
+    def needAck(self, packet):
+        """ Tell that a packet needs an acknoledge. """
+        self.__waitAck_sema.acquire()
+        self.__waitAck[packet.id] = packet
+        self.__waitAck_sema.release()
 
-	def live(self):
-		""" Keep the connection alive :
-		Resend packet if needed,
-		clean old received packets,
-		send ping if needed.
-		"""
-		
-		# Resend packet which don't have received their ack yet
-		self.__waitAck_sema.acquire()
-		waitAckCopy = self.__waitAck.copy()
-		self.__waitAck_sema.release()
-		for id,packet in waitAckCopy.items():
-			if packet.timeout < time.time():
-				if packet.sent < io.Packet.max_resend:
-					self.send(packet)
-				else:
-					self.io.clientLostConnection(self)
+    def live(self):
+        """ Keep the connection alive :
+        Resend packet if needed,
+        clean old received packets,
+        send ping if needed.
+        """
+        
+        # Resend packet which don't have received their ack yet
+        self.__waitAck_sema.acquire()
+        waitAckCopy = self.__waitAck.copy()
+        self.__waitAck_sema.release()
+        for id,packet in waitAckCopy.items():
+            if packet.timeout < time.time():
+                if packet.sent < io.Packet.max_resend:
+                    self.send(packet)
+                else:
+                    self.io.clientLostConnection(self)
 
-		# Clean old received packets 
-		self.__received_sema.acquire()
-		receivedCopy = self.__received.copy()
-		self.__received_sema.release()
-		for id,timeout in receivedCopy.items():
-			if timeout < time.time():
-				if self.io.debug:
-					print "Supprime ancien paquet %u de %s:%u (timeout)" \
-						% (id, self.host, self.port)
-				self.__received_sema.acquire()
-				del self.__received[id]
-				self.__received_sema.release()
+        # Clean old received packets 
+        self.__received_sema.acquire()
+        receivedCopy = self.__received.copy()
+        self.__received_sema.release()
+        for id,timeout in receivedCopy.items():
+            if timeout < time.time():
+                if self.io.debug:
+                    print "Supprime ancien paquet %u de %s:%u (timeout)" \
+                        % (id, self.host, self.port)
+                self.__received_sema.acquire()
+                del self.__received[id]
+                self.__received_sema.release()
 
-		# Send ping if needed
-		if self.send_ping: self.__pinger.live()
+        # Send ping if needed
+        if self.send_ping: self.__pinger.live()
 
-	def send(self, packet):
-		""" Send packet to the client. """
-		self.io.send(packet, to=self)
-		
-	def sendBinary(self, data):
-		""" Send binary datas the client. """
-		self.io.sendBinary(data, self)
+    def send(self, packet):
+        """ Send packet to the client. """
+        self.io.send(packet, to=self)
+        
+    def sendBinary(self, data):
+        """ Send binary datas the client. """
+        self.io.sendBinary(data, self)

Modified: happyboom/trunk/net/io_udp/udp_ping.py
===================================================================
--- happyboom/trunk/net/io_udp/udp_ping.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/io_udp/udp_ping.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -3,121 +3,121 @@
 from net import io
 
 class UDP_Ping:
-	""" One UDP ping.
-	@ivar timeout: Ping timeout (in seconds).
-	@type timeout: C{float}
-	@ivar creation: Creation time.
-	@type creation: C{float}
-	@ivar id: Ping id.
-	@type id: C{int}
-	"""
-	timeout = 5.000
-	
-	def __init__(self, id):
-		""" Constuctor.
-		@type id: C{int}
-		"""
-		self.creation = time.time()
-		self.timeout = self.creation+UDP_Ping.timeout
-		self.id = id
+    """ One UDP ping.
+    @ivar timeout: Ping timeout (in seconds).
+    @type timeout: C{float}
+    @ivar creation: Creation time.
+    @type creation: C{float}
+    @ivar id: Ping id.
+    @type id: C{int}
+    """
+    timeout = 5.000
+    
+    def __init__(self, id):
+        """ Constuctor.
+        @type id: C{int}
+        """
+        self.creation = time.time()
+        self.timeout = self.creation+UDP_Ping.timeout
+        self.id = id
 
-	def getPacket(self):
-		""" Create a network packet containing the ping. """
-		ping = io.Packet()
-		ping.type = io.Packet.PACKET_PING
-		ping.writeStr( struct.pack("!I", self.id) )
-		return ping	
+    def getPacket(self):
+        """ Create a network packet containing the ping. """
+        ping = io.Packet()
+        ping.type = io.Packet.PACKET_PING
+        ping.writeStr( struct.pack("!I", self.id) )
+        return ping    
 
 class UDP_Pinger:
-	""" An UDP pinger (send ping and process pong).
-	@ivar ping_sleep: Sleep (in seconds) after sending one ping.
-	@type ping_sleep: C{float}
-	@ivar client: The UDP Client.
-	@type client: C{L{UDP_Client<udp.UDP_Client>}}
-	@ivar __sent_ping: List of sent pings (id,packet).
-	@type __sent_ping: C{dict<int, L{UDP_Ping}>}
-	@ivar __ping_id: Next ping id.
-	@type __ping_id: C{int}
-	@ivar __next_ping: Timer until next ping.
-	@type __next_ping: C{float}
-	"""
+    """ An UDP pinger (send ping and process pong).
+    @ivar ping_sleep: Sleep (in seconds) after sending one ping.
+    @type ping_sleep: C{float}
+    @ivar client: The UDP Client.
+    @type client: C{L{UDP_Client<udp.UDP_Client>}}
+    @ivar __sent_ping: List of sent pings (id,packet).
+    @type __sent_ping: C{dict<int, L{UDP_Ping}>}
+    @ivar __ping_id: Next ping id.
+    @type __ping_id: C{int}
+    @ivar __next_ping: Timer until next ping.
+    @type __next_ping: C{float}
+    """
 
-	ping_sleep = 1.000
-	
-	def __init__(self, client):
-		""" Constructor.
-		@type client: C{L{UDP_Client<udp.UDP_Client>}}
-		"""
-		self.__next_ping = time.time()+UDP_Pinger.ping_sleep
-		self.__ping_id = 0
-		self.client = client
-		self.__sent_ping = {}
+    ping_sleep = 1.000
+    
+    def __init__(self, client):
+        """ Constructor.
+        @type client: C{L{UDP_Client<udp.UDP_Client>}}
+        """
+        self.__next_ping = time.time()+UDP_Pinger.ping_sleep
+        self.__ping_id = 0
+        self.client = client
+        self.__sent_ping = {}
 
-	def processPong(self, id):
-		""" Process pong. """
-		pass
+    def processPong(self, id):
+        """ Process pong. """
+        pass
 
-	def sendPing(self):
-		""" Send a new ping : create the packet and send it to the client. """
-		self.__ping_id = self.__ping_id + 1
-		ping = UDP_Ping(self.__ping_id)
-		self.client.send( ping.getPacket() )
-		self.__sent_ping[ping.id] = ping
-				
-	def pingTimeout(self, id):
-		""" Function called when a ping timeout is raised.
-		@parameter id: The ping id.
-		@type id: C{int}
-		"""
-		print "Ping timeout."
-#		print "Disconnect client %s:%u (ping timeout)." \
-#			% (self.client.host, self.client.port)
-#		self.client.disconnect()
+    def sendPing(self):
+        """ Send a new ping : create the packet and send it to the client. """
+        self.__ping_id = self.__ping_id + 1
+        ping = UDP_Ping(self.__ping_id)
+        self.client.send( ping.getPacket() )
+        self.__sent_ping[ping.id] = ping
+                
+    def pingTimeout(self, id):
+        """ Function called when a ping timeout is raised.
+        @parameter id: The ping id.
+        @type id: C{int}
+        """
+        print "Ping timeout."
+#        print "Disconnect client %s:%u (ping timeout)." \
+#            % (self.client.host, self.client.port)
+#        self.client.disconnect()
 
-	def live(self):
-		""" Remove old ping and send ping if needed. """
-		
-		# Remove old ping
-		for id,ping in self.__sent_ping.items():
-			if ping.timeout < time.time():
-				del self.__sent_ping[id]
-				self.pingTimeout(id)
-		
-		# Send ping if needed
-		if self.__next_ping < time.time():
-			self.__next_ping = time.time()+UDP_Pinger.ping_sleep
-			self.sendPing()
+    def live(self):
+        """ Remove old ping and send ping if needed. """
+        
+        # Remove old ping
+        for id,ping in self.__sent_ping.items():
+            if ping.timeout < time.time():
+                del self.__sent_ping[id]
+                self.pingTimeout(id)
+        
+        # Send ping if needed
+        if self.__next_ping < time.time():
+            self.__next_ping = time.time()+UDP_Pinger.ping_sleep
+            self.sendPing()
 
-	def __getPingId(self, data):
-		""" Utility used to get an ping id from binary data.
-		@type data: C{str}
-		"""
-		format  = "!I"
-		if len(data) != struct.calcsize(format): return None
-		data = struct.unpack(format, data)
-		return data[0]
+    def __getPingId(self, data):
+        """ Utility used to get an ping id from binary data.
+        @type data: C{str}
+        """
+        format  = "!I"
+        if len(data) != struct.calcsize(format): return None
+        data = struct.unpack(format, data)
+        return data[0]
 
-	def processPing(self, packet):
-		""" Process ping : send pong.
-		@type packet: C{L{Packet<io.Packet>}}
-		"""
-		pong = io.Packet(skippable=True)
-		pong.type = io.Packet.PACKET_PONG
-		pong.writeStr( packet.data )
-		self.client.send(pong)
-		
-	def processPong(self, packet):
-		""" Process pong.
-		@type packet: C{L{Packet<io.Packet>}}
-		"""
-		id = self.__getPingId(packet.data)
-		if id == None:
-			if self.debug:
-				print "Wrong ping packet (%s)!" % (packet.toStr())
-			return
+    def processPing(self, packet):
+        """ Process ping : send pong.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        pong = io.Packet(skippable=True)
+        pong.type = io.Packet.PACKET_PONG
+        pong.writeStr( packet.data )
+        self.client.send(pong)
+        
+    def processPong(self, packet):
+        """ Process pong.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        id = self.__getPingId(packet.data)
+        if id == None:
+            if self.debug:
+                print "Wrong ping packet (%s)!" % (packet.toStr())
+            return
 
-		# Received too late ?
-		if not self.__sent_ping.has_key(id): return
+        # Received too late ?
+        if not self.__sent_ping.has_key(id): return
 
-		# Remove ping from the list
-		del self.__sent_ping[id]
+        # Remove ping from the list
+        del self.__sent_ping[id]

Modified: happyboom/trunk/net/net_buffer.py
===================================================================
--- happyboom/trunk/net/net_buffer.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/net/net_buffer.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -2,58 +2,58 @@
 import time
 
 class NetBuffer:
-	""" Buffer used to store network packets. Support multithreading.
-	@ivar blocking_read_sleep : Sleep duration when waiting data from network.
-	@type blocking_read_sleep: C{float}
-	@ivar __buffer: Buffer which store network packets.
-	@type __buffer: C{list<L{Packet<io.Packet>}>}
-	"""
-	
-	def __init__(self):
-		""" Constructor. """
-		self.blocking_read_sleep = 0.010
-		self.__buffer = {} 
-		self.__sema = thread.allocate_lock()
+    """ Buffer used to store network packets. Support multithreading.
+    @ivar blocking_read_sleep : Sleep duration when waiting data from network.
+    @type blocking_read_sleep: C{float}
+    @ivar __buffer: Buffer which store network packets.
+    @type __buffer: C{list<L{Packet<io.Packet>}>}
+    """
+    
+    def __init__(self):
+        """ Constructor. """
+        self.blocking_read_sleep = 0.010
+        self.__buffer = {} 
+        self.__sema = thread.allocate_lock()
 
-	def clear(self, key):
-		""" Clear buffer. """
-		self.__sema.acquire()
-		self.__buffer[key] = [] 
-		self.__sema.release()
-	
-	def append(self, key, data):
-		""" Append new data to the buffer. """
-		self.__sema.acquire()
-		if self.__buffer.has_key(key):
-			self.__buffer[key].append(data)
-		else:
-			self.__buffer[key] = [data]
-		self.__sema.release()
+    def clear(self, key):
+        """ Clear buffer. """
+        self.__sema.acquire()
+        self.__buffer[key] = [] 
+        self.__sema.release()
+    
+    def append(self, key, data):
+        """ Append new data to the buffer. """
+        self.__sema.acquire()
+        if self.__buffer.has_key(key):
+            self.__buffer[key].append(data)
+        else:
+            self.__buffer[key] = [data]
+        self.__sema.release()
 
-	def readNonBlocking(self, key):
-		""" Read one data. Returns None if their is no data.
-		@rtype: C{str}
-		"""
-		self.__sema.acquire()
-		buffer = self.__buffer.get(key, [])
-		self.__buffer[key] = []
-		self.__sema.release()
-		return buffer
+    def readNonBlocking(self, key):
+        """ Read one data. Returns None if their is no data.
+        @rtype: C{str}
+        """
+        self.__sema.acquire()
+        buffer = self.__buffer.get(key, [])
+        self.__buffer[key] = []
+        self.__sema.release()
+        return buffer
 
-	def readBlocking(self, key, timeout):
-		""" Read one data.
-		Returns None if their is no data after the timeout.
-		@type timeout: C{float}
-		@rtype: C{str}
-		"""
-		data = None
-		timeout = time.time()+timeout
-		while data == None:
-			if timeout < time.time(): break
-			self.__sema.acquire()
-			if self.__buffer.has_key(key) and len(self.__buffer[key]) != 0:
-				data = self.__buffer[key][0]
-				del self.__buffer[key][0] 
-			self.__sema.release()
-			if data == None: time.sleep(self.blocking_read_sleep)
-		return data
+    def readBlocking(self, key, timeout):
+        """ Read one data.
+        Returns None if their is no data after the timeout.
+        @type timeout: C{float}
+        @rtype: C{str}
+        """
+        data = None
+        timeout = time.time()+timeout
+        while data == None:
+            if timeout < time.time(): break
+            self.__sema.acquire()
+            if self.__buffer.has_key(key) and len(self.__buffer[key]) != 0:
+                data = self.__buffer[key][0]
+                del self.__buffer[key][0] 
+            self.__sema.release()
+            if data == None: time.sleep(self.blocking_read_sleep)
+        return data

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/server/base_server.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,6 +1,7 @@
 # TODO: Check if it's always possible to send skippable packets
 
-from net import io, io_udp, io_tcp, net_buffer
+from happyboom.common.packer import HappyBoomPacker
+from happyboom.net import io, io_udp, io_tcp, net_buffer
 from pysma import Kernel, DummyScheduler, ActionAgent, ActionMessage
 import re, random, thread, traceback, time
 import types # maybe only used for assertions

Modified: happyboom/trunk/server/server_agent.py
===================================================================
--- happyboom/trunk/server/server_agent.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/server/server_agent.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -1,14 +1,14 @@
 from agent import *
 
 class ServerAgent(Agent):
-	def __init__(self, type):
-		Agent.__init__(self)
-		self.type = type
-		self.id = -1 
-		self.server = None
+    def __init__(self, type):
+        Agent.__init__(self)
+        self.type = type
+        self.id = -1 
+        self.server = None
 
-	def sendMsg(self, role, type, arg=None, client=None, skippable=False):
-		if client != None:
-			self.server.sendMsgToClient(client, role, type, arg, skippable=skippable)
-		else:
-			self.server.sendMsg(role, type, arg, skippable=skippable)
+    def sendMsg(self, role, type, arg=None, client=None, skippable=False):
+        if client != None:
+            self.server.sendMsgToClient(client, role, type, arg, skippable=skippable)
+        else:
+            self.server.sendMsg(role, type, arg, skippable=skippable)

Modified: happyboom/trunk/server/stat.py
===================================================================
--- happyboom/trunk/server/stat.py	2005-09-14 00:03:32 UTC (rev 140)
+++ happyboom/trunk/server/stat.py	2005-09-14 00:32:33 UTC (rev 141)
@@ -2,90 +2,90 @@
 import server_agent 
 
 class ServerStat:
-	def __init__(self, server):
-		self.started = time.time()
-		self.server = server
-		self.net_in = 0
-		self.net_out = 0
+    def __init__(self, server):
+        self.started = time.time()
+        self.server = server
+        self.net_in = 0
+        self.net_out = 0
 
-	# Event called on new sent/read data from network
-	def onNetSend(self, data):
-		self.net_out = self.net_out + len(data)
-	def onNetReceive(self, data):
-		self.net_in = self.net_in + len(data)
+    # Event called on new sent/read data from network
+    def onNetSend(self, data):
+        self.net_out = self.net_out + len(data)
+    def onNetReceive(self, data):
+        self.net_in = self.net_in + len(data)
 
-	# Number of seconds since server started
-	def getUptime(self):
-		return int( time.time() - self.started )
+    # Number of seconds since server started
+    def getUptime(self):
+        return int( time.time() - self.started )
 
-	# Current/Maximum number of view/input clients
-	def getNbInputs(self):
-		return self.server.getNbInput()
-	def getNbViews(self):
-		return self.server.getNbView()
-	def getMaxViews(self):
-		return self.server.getMaxNbView()
-	def getMaxInputs(self):
-		return self.server.getMaxNbInput()
+    # Current/Maximum number of view/input clients
+    def getNbInputs(self):
+        return self.server.getNbInput()
+    def getNbViews(self):
+        return self.server.getNbView()
+    def getMaxViews(self):
+        return self.server.getMaxNbView()
+    def getMaxInputs(self):
+        return self.server.getMaxNbInput()
 
 class ServerStatAgent(server_agent.ServerAgent):
-	def __init__(self):
-		server_agent.ServerAgent.__init__(self, "server_stat")
-		self.uptime = None
-		self.nb_view = None
-		self.nb_input = None
-		self.net_in = None
-		self.net_out = None
-		self.max_views = None
-		self.max_inputs = None
-		self.net_time = time.time()
-		self.net_time_update = 1.0
+    def __init__(self):
+        server_agent.ServerAgent.__init__(self, "server_stat")
+        self.uptime = None
+        self.nb_view = None
+        self.nb_input = None
+        self.net_in = None
+        self.net_out = None
+        self.max_views = None
+        self.max_inputs = None
+        self.net_time = time.time()
+        self.net_time_update = 1.0
 
-	def sync(self, client=None):
-		if self.uptime != None:
-			self.sendMsg("server_stat", "Uptime", "%u" % self.uptime, client)
-		if self.max_views != None:
-			self.sendMsg("server_stat", "MaxViews", "%u" % self.max_views, client)
-		if self.max_inputs != None:
-			self.sendMsg("server_stat", "MaxInputs", "%u" % self.max_inputs, client)
-		if self.nb_input != None:
-			self.sendMsg("server_stat", "NbInput", "%u" % self.nb_input, client)
-		if self.nb_view != None:
-			self.sendMsg("server_stat", "NbView", "%u" % self.nb_view, client)
-		if (self.net_in != None) and (self.net_out != None):
-			self.sendMsg("server_stat", "NetStat", "%u,%u" % (self.net_in, self.net_out), client)
-	
-	def update(self):
-		if self.server.stat == None: return
-		
-		if self.max_views == None:
-			self.max_views = self.server.stat.getMaxViews()
-		
-		if self.max_inputs == None:
-			self.max_inputs = self.server.stat.getMaxInputs()
-		
-		if self.net_time_update < time.time() - self.net_time:
-			self.net_time = time.time()
-			if (self.server.stat.net_in != self.net_in) \
-			or (self.server.stat.net_out != self.net_out):
-				self.net_in = self.server.stat.net_in
-				self.net_out = self.server.stat.net_out
-				self.sendMsg("server_stat", "NetStat", "%u,%u" % (self.net_in, self.net_out,))
-		
-		input = self.server.stat.getNbInputs()
-		if input != self.nb_input:
-			self.nb_input = input
-			self.sendMsg("server_stat", "NbInput", "%u" % self.nb_input)
-		
-		view = self.server.stat.getNbViews()
-		if view != self.nb_view:
-			self.nb_view = view
-			self.sendMsg("server_stat", "NbView", "%u" % self.nb_view)
+    def sync(self, client=None):
+        if self.uptime != None:
+            self.sendMsg("server_stat", "Uptime", "%u" % self.uptime, client)
+        if self.max_views != None:
+            self.sendMsg("server_stat", "MaxViews", "%u" % self.max_views, client)
+        if self.max_inputs != None:
+            self.sendMsg("server_stat", "MaxInputs", "%u" % self.max_inputs, client)
+        if self.nb_input != None:
+            self.sendMsg("server_stat", "NbInput", "%u" % self.nb_input, client)
+        if self.nb_view != None:
+            self.sendMsg("server_stat", "NbView", "%u" % self.nb_view, client)
+        if (self.net_in != None) and (self.net_out != None):
+            self.sendMsg("server_stat", "NetStat", "%u,%u" % (self.net_in, self.net_out), client)
+    
+    def update(self):
+        if self.server.stat == None: return
+        
+        if self.max_views == None:
+            self.max_views = self.server.stat.getMaxViews()
+        
+        if self.max_inputs == None:
+            self.max_inputs = self.server.stat.getMaxInputs()
+        
+        if self.net_time_update < time.time() - self.net_time:
+            self.net_time = time.time()
+            if (self.server.stat.net_in != self.net_in) \
+            or (self.server.stat.net_out != self.net_out):
+                self.net_in = self.server.stat.net_in
+                self.net_out = self.server.stat.net_out
+                self.sendMsg("server_stat", "NetStat", "%u,%u" % (self.net_in, self.net_out,))
+        
+        input = self.server.stat.getNbInputs()
+        if input != self.nb_input:
+            self.nb_input = input
+            self.sendMsg("server_stat", "NbInput", "%u" % self.nb_input)
+        
+        view = self.server.stat.getNbViews()
+        if view != self.nb_view:
+            self.nb_view = view
+            self.sendMsg("server_stat", "NbView", "%u" % self.nb_view)
 
-		uptime = self.server.stat.getUptime()
-		if uptime != self.uptime:
-			self.uptime = uptime
-			self.sendMsg("server_stat", "Uptime", "%u" % self.uptime)			
+        uptime = self.server.stat.getUptime()
+        if uptime != self.uptime:
+            self.uptime = uptime
+            self.sendMsg("server_stat", "Uptime", "%u" % self.uptime)            
 
-	def live(self):
-		self.update()
+    def live(self):
+        self.update()



From haypo at berlios.de  Wed Sep 14 02:33:59 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 02:33:59 +0200
Subject: [Happyboom-svn] r142 - in boomboom: . server server/agents
Message-ID: <200509140033.j8E0XxYH026707@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 02:33:55 +0200 (Wed, 14 Sep 2005)
New Revision: 142

Modified:
   boomboom/boomboom_server.py
   boomboom/server/agents/character.py
   boomboom/server/agents/game.py
   boomboom/server/agents/projectile.py
   boomboom/server/agents/weapon.py
   boomboom/server/agents/world.py
   boomboom/server/bb_agent.py
   boomboom/server/bb_server.py
Log:
Replace tab with four spaces.


Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/boomboom_server.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -70,10 +70,14 @@
     happyboomdir = os.path.join(file_dir, "..", "happyboom", "trunk")
     sys.path.append(happyboomdir)
     
-    # Add HappyBoom/server to PYTHONPATH
-    happyboomserverdir = os.path.join(happyboomdir, "server")
-    sys.path.append(happyboomserverdir)
+    # Add HappyBoom/common to PYTHONPATH
+#    happyboomserverdir = os.path.join(happyboomdir, "common")
+#    sys.path.append(happyboomserverdir)
     
+     # Add HappyBoom/server to PYTHONPATH
+#    happyboomserverdir = os.path.join(happyboomdir, "server")
+#    sys.path.append(happyboomserverdir)
+    
     val = { \
         "input_port": 12430,
         "max_clients": 4,

Modified: boomboom/server/agents/character.py
===================================================================
--- boomboom/server/agents/character.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/agents/character.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -1,47 +1,47 @@
 from server.bb_agent import BoomBoomAgent, BoomBoomMessage
 
 class Character(BoomBoomAgent):
-	def __init__(self, x, team, **args):
-		BoomBoomAgent.__init__(self, "character", **args)
-		self.x = x
-		self.y = 0
-		self.width = 28
-		self.height = 29
-		self.team = team
-		self.next = False
-		self.current = False
-		
-	def born(self):
-		BoomBoomAgent.born(self)
-		self.requestActions("game")
-		self.requestActions("network")
-		self.sendBroadcastMessage(BoomBoomMessage("character_search_place", (self.x, self.width, self.height)), "world")
-		self.sendBroadcastMessage(BoomBoomMessage("new_character", (self.id, self.team)), "game")
-		self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+    def __init__(self, x, team, **args):
+        BoomBoomAgent.__init__(self, "character", **args)
+        self.x = x
+        self.y = 0
+        self.width = 28
+        self.height = 29
+        self.team = team
+        self.next = False
+        self.current = False
+        
+    def born(self):
+        BoomBoomAgent.born(self)
+        self.requestActions("game")
+        self.requestActions("network")
+        self.sendBroadcastMessage(BoomBoomMessage("character_search_place", (self.x, self.width, self.height)), "world")
+        self.sendBroadcastMessage(BoomBoomMessage("new_character", (self.id, self.team)), "game")
+        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
 
-	def move(self, x, y, force=False):
-		if self.x == x and self.y == y and not force: return
-		self.x = x
-		self.y = y
-		self.sendBroadcastMessage(BoomBoomMessage("character_move", ("%u,%i,%i" % (self.id, self.x, self.y),)), "network")
-		if self.current:
-			self.sendBBMessage("active_coord", self.x, self.y)
+    def move(self, x, y, force=False):
+        if self.x == x and self.y == y and not force: return
+        self.x = x
+        self.y = y
+        self.sendBroadcastMessage(BoomBoomMessage("character_move", ("%u,%i,%i" % (self.id, self.x, self.y),)), "network")
+        if self.current:
+            self.sendBBMessage("active_coord", self.x, self.y)
 
-	def sync(self):
-		self.move(self.x, self.y, force=True)
+    def sync(self):
+        self.move(self.x, self.y, force=True)
 
-	def msg_found_place(self, x, y):
-		self.move(x, y, True)
-		
-	def msg_game_next_character(self, char, team):
-		if self.id == char:
-			self.next = True
-		
-	def msg_game_next_turn(self):
-		self.current = self.next
-		if self.current:
-			self.sendBBMessage("active_coord", self.x, self.y)
-		self.next = False
-		
-	def msg_network_sync(self):
-		self.sync()
\ No newline at end of file
+    def msg_found_place(self, x, y):
+        self.move(x, y, True)
+        
+    def msg_game_next_character(self, char, team):
+        if self.id == char:
+            self.next = True
+        
+    def msg_game_next_turn(self):
+        self.current = self.next
+        if self.current:
+            self.sendBBMessage("active_coord", self.x, self.y)
+        self.next = False
+        
+    def msg_network_sync(self):
+        self.sync()
\ No newline at end of file

Modified: boomboom/server/agents/game.py
===================================================================
--- boomboom/server/agents/game.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/agents/game.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -2,62 +2,62 @@
 import traceback
 
 class Game(BoomBoomAgent):
-	def __init__(self, **args):
-		BoomBoomAgent.__init__(self, "game", **args)
-		self.teams = []
-		self.characters = {}
-		self.next_team_pos = None
-		self.next_char_pos = {}
-		self.current = (None, None)
+    def __init__(self, **args):
+        BoomBoomAgent.__init__(self, "game", **args)
+        self.teams = []
+        self.characters = {}
+        self.next_team_pos = None
+        self.next_char_pos = {}
+        self.current = (None, None)
 
-	def born(self):
-		BoomBoomAgent.born(self)
-		self.requestActions("world")
-		self.requestActions("network")
+    def born(self):
+        BoomBoomAgent.born(self)
+        self.requestActions("world")
+        self.requestActions("network")
 
-	def sendNextCharacter(self, char_pos, team_pos):
-		if self.next_team_pos != None:
-			self.current = (self.nextCharacter, self.nextTeam)
-		self.next_team_pos = team_pos
-		self.next_char_pos[self.nextTeam] = char_pos
-		self.sendBBMessage("next_character", self.nextCharacter, self.nextTeam)
+    def sendNextCharacter(self, char_pos, team_pos):
+        if self.next_team_pos != None:
+            self.current = (self.nextCharacter, self.nextTeam)
+        self.next_team_pos = team_pos
+        self.next_char_pos[self.nextTeam] = char_pos
+        self.sendBBMessage("next_character", self.nextCharacter, self.nextTeam)
 
-	def msg_network_sync(self):
-		self.sync()
+    def msg_network_sync(self):
+        self.sync()
 
-	def msg_new_character(self, character, team):
-		if team in self.teams:
-			self.characters[team].append(character)
-		else:
-			self.teams.append(team)
-			self.characters[team] = [character,]
-			self.next_char_pos[team] = 0
+    def msg_new_character(self, character, team):
+        if team in self.teams:
+            self.characters[team].append(character)
+        else:
+            self.teams.append(team)
+            self.characters[team] = [character,]
+            self.next_char_pos[team] = 0
 
-	def sync(self):
-		char, team = self.current
-		self.sendBroadcastMessage(BoomBoomMessage("game_current_character", (char, team)), "network")
+    def sync(self):
+        char, team = self.current
+        self.sendBroadcastMessage(BoomBoomMessage("game_current_character", (char, team)), "network")
 
-	def __getNextCharacter(self):
-		return self.characters[self.nextTeam][self.next_char_pos[self.nextTeam]]
-	nextCharacter = property(__getNextCharacter)
+    def __getNextCharacter(self):
+        return self.characters[self.nextTeam][self.next_char_pos[self.nextTeam]]
+    nextCharacter = property(__getNextCharacter)
 
-	def __getNextTeam(self):
-		return self.teams[self.next_team_pos]
-	nextTeam = property(__getNextTeam)
+    def __getNextTeam(self):
+        return self.teams[self.next_team_pos]
+    nextTeam = property(__getNextTeam)
 
-	def incCharacter(self):
-		tpos = (self.next_team_pos + 1) % 2
-		cpos = (self.next_char_pos[self.teams[tpos]] + 1) % len(self.characters[self.teams[tpos]])
-		self.sendNextCharacter(cpos, tpos)
+    def incCharacter(self):
+        tpos = (self.next_team_pos + 1) % 2
+        cpos = (self.next_char_pos[self.teams[tpos]] + 1) % len(self.characters[self.teams[tpos]])
+        self.sendNextCharacter(cpos, tpos)
 
-	def msg_world_collision(self, x, y):
-		self.sendBBMessage("next_turn")
-		self.incCharacter()
-		
-	def msg_start(self):
-		self.launchGame()
+    def msg_world_collision(self, x, y):
+        self.sendBBMessage("next_turn")
+        self.incCharacter()
+        
+    def msg_start(self):
+        self.launchGame()
 
-	def launchGame(self):	
-		self.sendNextCharacter(0, 0)
-		self.sendBBMessage("next_turn")
-		self.incCharacter()
\ No newline at end of file
+    def launchGame(self):    
+        self.sendNextCharacter(0, 0)
+        self.sendBBMessage("next_turn")
+        self.incCharacter()
\ No newline at end of file

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/agents/projectile.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -3,74 +3,74 @@
 import math
 
 class Projectile(BoomBoomAgent):
-	def __init__(self, **args):
-		BoomBoomAgent.__init__(self, "projectile", **args)
-		self.x, self.y = 0, 0
-		self.start_pos = None
-		self.active = False
-		self.time = None
-		self.speed = None
-		self.weapon_angle = None
-		self.weapon_strength = None
-		self.mass = 10
+    def __init__(self, **args):
+        BoomBoomAgent.__init__(self, "projectile", **args)
+        self.x, self.y = 0, 0
+        self.start_pos = None
+        self.active = False
+        self.time = None
+        self.speed = None
+        self.weapon_angle = None
+        self.weapon_strength = None
+        self.mass = 10
 
-	def born(self):
-		BoomBoomAgent.born(self)
-		self.requestRole("command_manager")
-		self.requestActions("weapon")
-		self.requestActions("character")
-		self.requestActions("world")
-		self.requestActions("game")
-		self.requestActions("network")
-		self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+    def born(self):
+        BoomBoomAgent.born(self)
+        self.requestRole("command_manager")
+        self.requestActions("weapon")
+        self.requestActions("character")
+        self.requestActions("world")
+        self.requestActions("game")
+        self.requestActions("network")
+        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
 
-	def msg_weapon_strength(self, arg):
-		self.weapon_strength = int(arg) * 4
-		
-	def msg_weapon_angle(self, angle):
-		self.weapon_angle = (-int(angle)) * math.pi / 180
+    def msg_weapon_strength(self, arg):
+        self.weapon_strength = int(arg) * 4
+        
+    def msg_weapon_angle(self, angle):
+        self.weapon_angle = (-int(angle)) * math.pi / 180
 
-	def msg_new_command(self, cmd):
-		if cmd == "shoot" and not self.active:
-			self.shoot()
+    def msg_new_command(self, cmd):
+        if cmd == "shoot" and not self.active:
+            self.shoot()
 
-	def msg_character_active_coord(self, x, y):
-		self.start_pos = (x, y)
+    def msg_character_active_coord(self, x, y):
+        self.start_pos = (x, y)
 
-	def msg_world_collision(self, x, y):
-		self.setActive(False)
+    def msg_world_collision(self, x, y):
+        self.setActive(False)
 
-	def setActive(self, active):
-		self.active = active
-		self.sendBBMessage("activate", active)
+    def setActive(self, active):
+        self.active = active
+        self.sendBBMessage("activate", active)
 
-	def shoot(self):
-		if self.weapon_angle==None: return
-		if self.weapon_strength==None: return
-		self.move(self.start_pos[0], self.start_pos[1])
-		self.setActive(True)
-		self.time = time.time()
-		sx = self.weapon_strength * math.cos(self.weapon_angle)
-		sy = self.weapon_strength * math.sin(self.weapon_angle)
-		if self.start_pos[0] > 300: # TODO: Bad test to know which character it is
-			sx = -sx
-		self.speed = (sx, sy,)
+    def shoot(self):
+        if self.weapon_angle==None: return
+        if self.weapon_strength==None: return
+        self.move(self.start_pos[0], self.start_pos[1])
+        self.setActive(True)
+        self.time = time.time()
+        sx = self.weapon_strength * math.cos(self.weapon_angle)
+        sy = self.weapon_strength * math.sin(self.weapon_angle)
+        if self.start_pos[0] > 300: # TODO: Bad test to know which character it is
+            sx = -sx
+        self.speed = (sx, sy,)
 
-	def move(self, x, y):
-		self.x = x
-		self.y = y
-		self.sendBBMessage("move", x, y)
+    def move(self, x, y):
+        self.x = x
+        self.y = y
+        self.sendBBMessage("move", x, y)
 
-	def live(self):
-		BoomBoomAgent.live(self)
-		if self.active:
-			dt = time.time() - self.time
-			x = self.start_pos[0] +self.speed[0] * dt
-			y = self.start_pos[1] +self.speed[1] * dt +9.8*dt*dt*self.mass
-			self.move (x, y)
+    def live(self):
+        BoomBoomAgent.live(self)
+        if self.active:
+            dt = time.time() - self.time
+            x = self.start_pos[0] +self.speed[0] * dt
+            y = self.start_pos[1] +self.speed[1] * dt +9.8*dt*dt*self.mass
+            self.move (x, y)
 
-	def sync(self):
-		self.setActive(self.active)
+    def sync(self):
+        self.setActive(self.active)
 
-	def msg_network_sync(self):
-		self.sync()
\ No newline at end of file
+    def msg_network_sync(self):
+        self.sync()
\ No newline at end of file

Modified: boomboom/server/agents/weapon.py
===================================================================
--- boomboom/server/agents/weapon.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/agents/weapon.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -10,7 +10,7 @@
         self.nextTeam = None
 
     def born(self):
-    	BoomBoomAgent.born(self)
+        BoomBoomAgent.born(self)
         self.requestRole("command_manager")
         self.requestActions("game")
         self.requestActions("network")

Modified: boomboom/server/agents/world.py
===================================================================
--- boomboom/server/agents/world.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/agents/world.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -2,94 +2,94 @@
 import random
 
 class Building:
-	def __init__(self, x, y, height, width):
-		self.x = x
-		self.y = y
-		self.width = width
-		self.height = height
+    def __init__(self, x, y, height, width):
+        self.x = x
+        self.y = y
+        self.width = width
+        self.height = height
 
-	def isPartOf(self, x, y):
-		if x < self.x:
-			return False
-		if self.x + self.width < x:
-			return False
-		if y < self.y:
-			return False
-		if self.y + self.height < y:
-			return False
-		return True
+    def isPartOf(self, x, y):
+        if x < self.x:
+            return False
+        if self.x + self.width < x:
+            return False
+        if y < self.y:
+            return False
+        if self.y + self.height < y:
+            return False
+        return True
 
 
 class World(BoomBoomAgent):
-	def __init__(self, **args):
-		BoomBoomAgent.__init__(self, "world", **args)
-		self.buildings = None
-		self.height = 350
-		self.width = 640
-		self.generate()
+    def __init__(self, **args):
+        BoomBoomAgent.__init__(self, "world", **args)
+        self.buildings = None
+        self.height = 350
+        self.width = 640
+        self.generate()
 
-	def born(self):
-		BoomBoomAgent.born(self)
-		self.requestActions("projectile")
-		self.requestActions("game")
-		self.requestActions("network")
-		self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+    def born(self):
+        BoomBoomAgent.born(self)
+        self.requestActions("projectile")
+        self.requestActions("game")
+        self.requestActions("network")
+        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
 
-	def generate(self):
-		width = self.width
-		x = 0
-		self.buildings = []
-		building_hmin = 100
-		building_hmax = self.height-100
-		building_wmin = 40
-		building_wmax = 60
-		while building_wmin<width:
-			w = random.randint(building_wmin, building_wmax)
-			h = random.randint(building_hmin, building_hmax)
-			building = Building(x, self.height-h, h, w)
-			self.buildings.append(building)
-			width = width - w
-			x = x + w
-		if 0 < width:
-			h = random.randint(building_hmin, building_hmax)
-			building = Building(x, self.height-h, h, width)
-			self.buildings.append(building)
+    def generate(self):
+        width = self.width
+        x = 0
+        self.buildings = []
+        building_hmin = 100
+        building_hmax = self.height-100
+        building_wmin = 40
+        building_wmax = 60
+        while building_wmin<width:
+            w = random.randint(building_wmin, building_wmax)
+            h = random.randint(building_hmin, building_hmax)
+            building = Building(x, self.height-h, h, w)
+            self.buildings.append(building)
+            width = width - w
+            x = x + w
+        if 0 < width:
+            h = random.randint(building_hmin, building_hmax)
+            building = Building(x, self.height-h, h, width)
+            self.buildings.append(building)
 
-	def hitGround(self, x, y):
-		# Testing screen bounds
-		if self.height <= y or x < 0 or self.width <= x:
-			return True
-		# Testing building collision
-		for b in self.buildings:
-			if b.isPartOf(x,y):
-				return True
-		return False	
+    def hitGround(self, x, y):
+        # Testing screen bounds
+        if self.height <= y or x < 0 or self.width <= x:
+            return True
+        # Testing building collision
+        for b in self.buildings:
+            if b.isPartOf(x,y):
+                return True
+        return False    
 
-	def sync(self):
-		msg = ""
-		for b in self.buildings:
-			if len(msg) != 0: msg = msg + ";"
-			msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
-		self.sendBroadcastMessage(BoomBoomMessage("world_create", (msg,)), "network")
+    def sync(self):
+        msg = ""
+        for b in self.buildings:
+            if len(msg) != 0: msg = msg + ";"
+            msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
+        self.sendBroadcastMessage(BoomBoomMessage("world_create", (msg,)), "network")
 
-	def msg_character_search_place(self, x0, width, height):
-		if x0 < 0:
-			x0 = self.width + x0
-		else:
-			x0 = x0
-		x1 = x0 + width
-		x = -1
-		y = -1
-		for b in self.buildings:
-			if x1 <= b.x + b.width and width < b.width:
-				x = int(b.x + (b.width - width) / 2)
-				y = b.y - height
-				break
-		self.sendMessage(BoomBoomMessage("found_place", (x, y)), self.currentMessage.sender)
-				
-	def msg_projectile_move(self, x, y):
-		if self.hitGround(x, y):
-			self.sendBBMessage("collision", x, y)
+    def msg_character_search_place(self, x0, width, height):
+        if x0 < 0:
+            x0 = self.width + x0
+        else:
+            x0 = x0
+        x1 = x0 + width
+        x = -1
+        y = -1
+        for b in self.buildings:
+            if x1 <= b.x + b.width and width < b.width:
+                x = int(b.x + (b.width - width) / 2)
+                y = b.y - height
+                break
+        self.sendMessage(BoomBoomMessage("found_place", (x, y)), self.currentMessage.sender)
+                
+    def msg_projectile_move(self, x, y):
+        if self.hitGround(x, y):
+            self.sendBBMessage("collision", x, y)
 
-	def msg_network_sync(self):
-		self.sync()
\ No newline at end of file
+    def msg_network_sync(self):
+        self.sync()
\ No newline at end of file

Modified: boomboom/server/bb_agent.py
===================================================================
--- boomboom/server/bb_agent.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/bb_agent.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -1,25 +1,25 @@
 from pysma import ActionAgent, ActionMessage
 
 class BoomBoomMessage(ActionMessage):
-	def __init__(self, action, arg, kw={}):
-		ActionMessage.__init__(self, action, arg, kw)
+    def __init__(self, action, arg, kw={}):
+        ActionMessage.__init__(self, action, arg, kw)
 
 class BoomBoomAgent(ActionAgent):
-	def __init__(self, type, **args):
-		ActionAgent.__init__(self, prefix="msg_")
-		self.type = type
-		self.__debug = args.get("debug", False)
+    def __init__(self, type, **args):
+        ActionAgent.__init__(self, prefix="msg_")
+        self.type = type
+        self.__debug = args.get("debug", False)
 
-	def born(self):
-		self.requestRole(self.type)
+    def born(self):
+        self.requestRole(self.type)
 
-	def requestActions(self, type):
-		self.requestRole("%s_listener" %type)
-		
-	def sendBBMessage(self, action, *arg, **kw):
-		message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
-		self.sendBroadcastMessage(message, "%s_listener" %self.type)
+    def requestActions(self, type):
+        self.requestRole("%s_listener" %type)
+        
+    def sendBBMessage(self, action, *arg, **kw):
+        message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
+        self.sendBroadcastMessage(message, "%s_listener" %self.type)
 
-	def messageReceived(self, msg):
-		if self.__debug:
-			print "Unhandled message : %s -- %s" %(type(self), msg)
\ No newline at end of file
+    def messageReceived(self, msg):
+        if self.__debug:
+            print "Unhandled message : %s -- %s" %(type(self), msg)
\ No newline at end of file

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-14 00:32:33 UTC (rev 141)
+++ boomboom/server/bb_server.py	2005-09-14 00:33:55 UTC (rev 142)
@@ -1,6 +1,6 @@
+from happyboom.server.base_server import HappyBoomServer, HappyBoomGateway, HappyBoomMessage
+from pysma import Kernel
 from agents import Character, Projectile, Weapon, World, Game
-from base_server import HappyBoomServer, HappyBoomGateway, HappyBoomMessage
-from pysma import Kernel
 
 class BoomBoomGateway(HappyBoomGateway):
     def __init__(self, server, arg):
@@ -15,6 +15,7 @@
         self.requestActions("projectile")
 
     def start(self):
+        HappyBoomGateway.start(self)
         if self._verbose: print "[*] Creating agents"
         self.addAgent(Game(debug=self._debug))
         self.addAgent(World(debug=self._debug))



From haypo at berlios.de  Wed Sep 14 04:52:54 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 04:52:54 +0200
Subject: [Happyboom-svn] r143 - happyboom/trunk/common
Message-ID: <200509140252.j8E2qsFm017225@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 04:52:45 +0200 (Wed, 14 Sep 2005)
New Revision: 143

Added:
   happyboom/trunk/common/protocol.py
Modified:
   happyboom/trunk/common/packer.py
Log:
Packer is converted to functions and support integer type. Add protocol classes.


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 00:33:55 UTC (rev 142)
+++ happyboom/trunk/common/packer.py	2005-09-14 02:52:45 UTC (rev 143)
@@ -1,38 +1,48 @@
-class HappyBoomPacker:
-    """
-    Pack arguments to binary string. Types :
-    - "bin": Binary string
-    - "utf8": Unicode string which will be encoded into UTF-8
-    """
+import types # maybe only used for assertions
+import struct
 
-    def __init__(self):
-        pass
+class PackerException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
 
-    def packUtf8(self, data):
-        data = 10
-        assert type(data)==types.unicode, "packUtf8 argument have to be Unicode"
-        return data.encode("utf-8")
+def packInt(data):
+    assert type(data)==type(1), "packInt argument have to be an integer"
+    # Overflow is checked by struct.pack
+    #assert data <= 2147483647, "packInt argument is too big (%s)" % data
+    #assert -2147483648 <= data, "packInt argument is too small (%s)" % data
+    return struct.pack("!i", data)
+    
+def packUtf8(data):
+    assert type(data)==types.unicode, "packUtf8 argument have to be Unicode"
+    return packBin(data.encode("utf-8"))
 
-    def packBin(self, data):
-        return data
+def packBin(data):
+    return struct.pack("!Hs", len(data), data)
 
-    def pack(self, func, event, args):
-        assert (len(args) % 2) == 0, "Arguments length have to be even"
-        out = "%s:%s" % (func, event)
+def pack(func, event, args):
+    """
+    Pack arguments to binary string. Supported types :
+    - "int": L{packInt}
+    - "bin": L{packBin}
+    - "utf8": L{packUtf8}
+    """
 
-        #TODO: Fix this :-)
-        for i in range(1,len(args), 2):
-            type = args[i]
-            data = args[i+1]
-            
-            # TODO: Use dict instead of long if list
-            if type=="bin":
-                data = self.packBin(data)
-            elif type=="utf8":
-                data = self.packUtf8(data)
-            else:
-                raise HappyBoomPackerException("Wrong argument type: %s" % type)
-            out = out + data
-        return out        
+    assert (len(args) % 2) == 0, "Arguments length have to be even"
+    out = "%s:%s" % (func, event)
 
-
+    #TODO: Fix this :-)
+    for i in range(0,len(args)-1, 2):
+        type = args[i]
+        data = args[i+1]
+        
+        # TODO: Use dict instead of long if list
+        if type=="int":
+            data = packInt(data)
+        elif type=="bin":
+            data = packBin(data)
+        elif type=="utf8":
+            data = packUtf8(data)
+        else:
+            raise PackerException("Wrong argument type: %s" % type)
+        out = out + data
+    return out        

Added: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-14 00:33:55 UTC (rev 142)
+++ happyboom/trunk/common/protocol.py	2005-09-14 02:52:45 UTC (rev 143)
@@ -0,0 +1,102 @@
+import xml.dom.minidom
+
+class ProtocolEventParam:
+    def __init__(self, name, type):
+        self.name = name
+        self.type = type
+
+    def __str__(self):
+        return self.name
+       
+class ProtocolEvent:
+    def __init__(self, name, id):
+        self.name = name
+        self.id = id
+        self.__params_dict = {}
+        self.__params_array = [] 
+        
+    def addParam(self, name, id):
+        param = ProtocolEventParam(name, id)
+        self.__params_dict[name] = param
+        self.__params_array.append(param)
+        return param
+        
+    def __str__(self):
+        out = "%s(" % (self.name)
+        comma = False
+        for param in self.__params_array:
+            if comma:
+                out = out + ","
+            else:
+                comma = True
+            out = out + str(param)
+        out = out + ")"
+        return out
+
+class ProtocolFunc:
+    def __init__(self, name, id):
+        self.name = name
+        self.id = id
+        self.__events = {}
+
+    def addEvent(self, name, id):
+        event = ProtocolEvent(name, id)
+        self.__events[name] = event
+        return event
+
+    def __str__(self):
+        first = True
+        out = ""
+        for event_name, event in self.__events.items():
+            if first:
+                first = False
+            else:
+                out = out + "\n"
+            out = out + "%s.%s" % (self.name, event)
+        return out
+
+class Protocol:
+    def __init__(self, version):
+        self.__funcs = {}
+        self.version = version
+
+    def addFunc(self, name, id):
+        func = ProtocolFunc(name, id)
+        self.__funcs[name] = func
+        return func
+
+    def __str__(self):
+        out = ""
+        first = True
+        for func_name, func in self.__funcs.items():
+            if first:
+                first = False
+            else:
+                out = out + "\n"
+            out = out + "[ %s ]\n" % func.name
+            out = out + str(func)
+        return out
+ 
+def loadProtocol(filename):
+    doc = xml.dom.minidom.parse(filename)
+    protocol = doc.documentElement
+    p = Protocol(protocol.getAttribute("version"))
+    funcs = protocol.getElementsByTagName("func")
+    for func in funcs:
+        f = p.addFunc( \
+            func.getAttribute("name"),
+            func.getAttribute("id"))
+        events = func.getElementsByTagName("event")
+        for event in events:
+            e = f.addEvent( \
+                event.getAttribute("name"),
+                event.getAttribute("id"))
+            params = func.getElementsByTagName("param")
+            for param in params:
+                e.addParam( \
+                    param.getAttribute("name"),
+                    param.getAttribute("id"))
+    print "-- Protocol --"                
+    print p
+    print "-- Protocol end --"                
+    return p



From haypo at berlios.de  Wed Sep 14 04:58:30 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 04:58:30 +0200
Subject: [Happyboom-svn] r144 - in happyboom/trunk: . server
Message-ID: <200509140258.j8E2wUpb018022@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 04:58:26 +0200 (Wed, 14 Sep 2005)
New Revision: 144

Added:
   happyboom/trunk/__init__.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/client.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Modified:
   happyboom/trunk/server/base_server.py
Log:
Split server to several files. Server is built is this order :
  ClientManager -> Gateway -> Server

Gateway need a Protocol instance which will be used to send
data to network.


Added: happyboom/trunk/__init__.py
===================================================================

Added: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-14 02:52:45 UTC (rev 143)
+++ happyboom/trunk/server/agent.py	2005-09-14 02:58:26 UTC (rev 144)
@@ -0,0 +1,34 @@
+from pysma import ActionAgent, ActionMessage
+
+class Agent(ActionAgent):
+    """
+    SMA agent in HappyBoom.
+    """
+    def __init__(self, type, gateway, **args):
+        ActionAgent.__init__(self, prefix="msg_")
+        self._gateway = gateway
+        self.type = type
+        self.__debug = args.get("debug", False)
+        self.sendBroadcast = self.sendBroadcastMessage
+
+    def born(self):
+        self.requestRole(self.type)
+
+    def requestActions(self, type):
+        self.requestRole("%s_listener" %type)
+        
+    def send(self, action, *arg, **kw):
+        message = Message("%s_%s" %(self.type, action), arg, kw)
+        self.sendBroadcastMessage(message, "%s_listener" %self.type)
+
+    def sendNetMsg(self, func, event, *args):
+        print args
+        self._gateway.sendNetMsg(func, event, *args)
+
+    def messageReceived(self, msg):
+        if self.__debug:
+            print "Unhandled message : %s -- %s" %(type(self), msg)
+
+class Message(ActionMessage):
+    def __init__(self, action, arg, kw={}):
+        ActionMessage.__init__(self, action, arg, kw)

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-14 02:52:45 UTC (rev 143)
+++ happyboom/trunk/server/base_server.py	2005-09-14 02:58:26 UTC (rev 144)
@@ -1,255 +1,18 @@
 # TODO: Check if it's always possible to send skippable packets
 
-from happyboom.common.packer import HappyBoomPacker
-from happyboom.net import io, io_udp, io_tcp, net_buffer
-from pysma import Kernel, DummyScheduler, ActionAgent, ActionMessage
-import re, random, thread, traceback, time
-import types # maybe only used for assertions
+from happyboom.server.gateway import Gateway
+from happyboom.server.client_manager import ClientManager
+import random, thread, time
 
-class HappyBoomClient:
-    """
-    High-level class for a client in the server.
-    """
-
-    def __init__(self, io_client, client_manager):
-        self.__io = io_client
-        self.__client_manager = client_manager
-        self.signature = None
-
-    # Stop client: close socket.
-    def stop(self):
-        self.__io.stop()
-
-    # Read a message from network stack
-    # Blocking function, returns None after timeout seconds (no data)
-    def read(self, timeout):
-        return self.__client_manager.readClientAnswer(self.__io, timeout)
-
-    # Send a network packet the the client socket
-    def sendPacket(self, packet):
-        self.__io.send(packet)
-
-    # Send a HappyBoom message to the client (see L{sendPacket})
-    def sendNetMsg(self, func, event, *args):
-        packet = self.__gateway.createMsgTuple(func, event, args)
-        self.__io.send(packet)
-
-class HappyBoomAgent(ActionAgent):
-    """
-    SMA agent in HappyBoom.
-    """
-    def __init__(self, type, **args):
-        ActionAgent.__init__(self, prefix="msg_")
-        self.type = type
-        self.__debug = args.get("debug", False)
-
-    def born(self):
-        self.requestRole(self.type)
-
-    def requestActions(self, type):
-        self.requestRole("%s_listener" %type)
-        
-    def sendBBMessage(self, action, *arg, **kw):
-        message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
-        self.sendBroadcastMessage(message, "%s_listener" %self.type)
-
-    def messageReceived(self, msg):
-        if self.__debug:
-            print "Unhandled message : %s -- %s" %(type(self), msg)
-
-class HappyBoomMessage(ActionMessage):
-    def __init__(self, action, arg, kw={}):
-        ActionMessage.__init__(self, action, arg, kw)
-
-# TODO: Use better name :-)
-class HappyBoomPackerException(Exception):
-    def __init__(self, msg):
-        Exception.__init__(self, msg)
-
-class HappyBoomGateway(HappyBoomAgent):
-    def __init__(self, server, arg):
-        self.__server = server
-        HappyBoomAgent.__init__(self, "gateway")
-        self.nextChar = None
-        self._debug = arg.get("debug", False)
-        self._verbose = arg.get("verbose", False)
-        Kernel().addAgent(DummyScheduler(sleep=0.01))
-        self.packer = HappyBoomPacker()
-
-    # Create a network packet for the event func.event(args) where
-    # args is a tuple
-    def createMsgTuple(self, func, event, args):
-        data = self.packer.pack(func, event, args)
-        return io.Packet(data)
-            
-    # Create a network packet for the event func.event(args), see
-    # L{self.createMsgTuple}
-    def createMsg(self, func, event, *args):
-        return self.createMsgTuple(func, event, args)
-
-    def start(self):
-        Kernel.instance.addAgent(self)
-        
-    def stop(self):
-        Kernel.instance.stopKernel()
-
-    def sendText(self, txt, client=None):
-        if client != None:
-            client.sendMsg("agent_manager", "Text", txt)
-        else:
-            self.sendNetMsg("agent_manager", "Text", txt)
-
-    def sendMsg(self, func, event, *args):
-        packet = self.createMsgTuple(role, type, args, func)
-        clients = self.__server.client_manager.supported_features.get(role, ())
-        for client in clients:
-            client.sendPacket(packet)
-
-class HappyBoomClientManager(object):
-    def __init__(self, server, gateway, arg): 
-        self.__server = server
-        self.__gateway = gateway
-        self.__io = io_tcp.IO_TCP(is_server=True)
-        self.__io.debug = arg.get("debug", False)
-        self.__io.verbose = arg.get("verbose", False)
-        self.__buffer = net_buffer.NetBuffer()
-        self.__debug = arg.get("debug", False)
-        self.__verbose = arg.get("verbose", False)
-        self.max_clients = arg.get("max_clients", 2)
-        self.client_port = arg.get("client_port", 12430)
-        self.__protocol_version = "0.1.4"
-        self.__supported_features = {}
-        self.__clients = []
-        self.__clients_sema = thread.allocate_lock()
-        
-    def recvClientPacket(self, packet):
-        self.__buffer.append(packet.recv_from.addr, packet)
-
-    def stop(self):
-        self.__gateway.sendNetMsg("game", "stop")
-        for client in self.__clients:
-            client.stop()
-
-    def process(self):
-        pass
-#        processInputs()
-
-    def start(self):
-        if self.__verbose: print "[*] Starting server"
-        self.__io.name = "server"
-        self.__io.on_client_connect = self.openClient
-        self.__io.on_client_disconnect = self.closeClient
-        self.__io.on_new_packet = self.recvClientPacket
-        self.__io.connect('', self.client_port)
-        thread.start_new_thread(self.run_io_thread, ())
-
-    def readClientAnswer(self, client, timeout=1.000):
-        answer = self.__buffer.readBlocking(client.addr, timeout)
-        if answer==None: return None
-        return answer.data
-
-    def registerFeature(self, client, role):
-        if role in self.__supported_features:
-            if client not in self.__supported_features[role]:
-                self.__supported_features[role].append(client)
-        else:
-            self.__supported_features[role] = [client,]
-        
-    def openClient(self, client):
-        # TODO: Ne pas utiliser de thread ?!
-        thread.start_new_thread( self.__clientChallenge, (client,self.__do_openClient))
-
-    def closeClient(self, client):
-        if self.__verbose:
-            log.info("Client %s disconnected." % client.name)
-        
-        txt = "Client %s (display) leave us." % (client.name)
-        self.__gateway.sendText(txt)
-        
-        client.sendMsg("presentation", "bye", "utf8", u"Lost connection")
-        
-    def __clientChallenge(self, client, func):
-        try:
-            func(client)
-        except Exception, msg:
-            print "EXCEPTION WHEN A CLIENT TRY TO CONNECT :"
-            print msg
-            print "--"
-            traceback.print_exc()
-            self.stop()
-
-    # Function which should be called in a thread
-    # TODO: Pourquoi c'est utilis? ?a ?
-    def run_io_thread(self):
-        try:
-            while self.__io.isRunning():
-                self.__io.live()                
-                time.sleep(0.001)
-        except Exception, msg:
-            print "EXCEPTION IN IO THREAD :"
-            print msg
-            print "--"            
-            traceback.print_exc()
-            self.stop()
-
-    def generateSignature(self, client):
-        import random
-        r = random.randint(0,1000000)
-        return r
-
-    def __do_openClient(self, io_client):
-        if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
-        client = HappyBoomClientSocket(io_client, self)
-        
-#        self.__buffer.clear(client.addr)
-       
-        # Check protocol version (max: wait 200ms)
-        answer = self.readClientAnswer(client, 0.200)
-        if answer != self.__protocol_version:
-            # If it isn't the right version, send presention.bye(...)
-            txt = u"Sorry, you don't have same protocol version (%s VS %s)" \
-                % (answer, self.__protocol_version)
-            client.sendMsg("presentation", "bye", "utf8", txt)
-
-            # Wait 0.5s and then disconnect the client
-            time.sleep(0.500)
-            client.disconnect()
-            return
-            
-        # Send protocol version with "hello()"
-        client.signature = self.generateSignature()        
-        client.send("presentation", "hello", \
-            "bin", self.__protocol_version, \
-            "bin", signature)
-         
-        # Read features (max: wait 1sec)
-        answer = client.read(1.0)
-        #TODO: do something with answer :-)
-
-        self.__clients_sema.acquire() 
-        self.__clients.append(client)
-        self.__clients_sema.release() 
-
-        txt = "Welcome to new (display) client : %s" % (client.name)
-        self.__gateway.sendText(txt)
-        if self.__verbose: print "[*] Display %s connected" % (client.name)
-        self.sendBBMessage("sync")
-
-    def __getSupportedFeatures(self): return self.__supported_features
-    supported_features = property(__getSupportedFeatures)
-
-class HappyBoomServer(object):
-    def __init__(self, arg): #verbose=False, debug=False):
+class Server(object):
+    def __init__(self, gateway, arg): #verbose=False, debug=False):
         self.started = False
         self.__debug = arg.get('debug', False)
         self.__verbose = arg.get('verbose', False)
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
-        if arg.has_key("gateway"):
-            self.__gateway = arg["gateway"]
-        else:
-            self.__gateway = HappyBoomGateway(self, arg)
-        self.__client_manager = HappyBoomClientManager(self, self.__gateway, arg)
+        self.__gateway = gateway 
+        gateway.server = self
         random.seed()
         self.__items = []
         
@@ -258,7 +21,6 @@
         
     def start(self):
         if self.__verbose: print "[*] Starting server..."
-        self.__client_manager.start()
         self.__gateway.start()
         print "[*] Server started"
         
@@ -266,7 +28,7 @@
         running = not self.__stopped
         self.__stoplock.release()
         while running:
-            self.__client_manager.process()
+            self.__gateway.process()
             time.sleep(0.01)
             self.__stoplock.acquire()
             running = not self.__stopped
@@ -281,8 +43,4 @@
         self.__stoplock.release()
         print "[*] Stopping server..."
         self.__gateway.stop()
-        self.__client_manager.stop()
         if self.__verbose: print "[*] Server stopped"
-
-    def __getClientManager(self): return self.__client_manager
-    client_manager = property(__getClientManager)

Added: happyboom/trunk/server/client.py
===================================================================
--- happyboom/trunk/server/client.py	2005-09-14 02:52:45 UTC (rev 143)
+++ happyboom/trunk/server/client.py	2005-09-14 02:58:26 UTC (rev 144)
@@ -0,0 +1,27 @@
+class Client:
+    """
+    High-level class for a client in the server.
+    """
+
+    def __init__(self, io_client, client_manager):
+        self.__io = io_client
+        self.__client_manager = client_manager
+        self.signature = None
+
+    # Stop client: close socket.
+    def stop(self):
+        self.__io.stop()
+
+    # Read a message from network stack
+    # Blocking function, returns None after timeout seconds (no data)
+    def read(self, timeout):
+        return self.__client_manager.readClientAnswer(self.__io, timeout)
+
+    # Send a network packet the the client socket
+    def sendPacket(self, packet):
+        self.__io.send(packet)
+
+    # Send a HappyBoom message to the client (see L{sendPacket})
+    def sendNetMsg(self, func, event, *args):
+        packet = self.__gateway.createMsgTuple(func, event, args)
+        self.__io.send(packet)

Added: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-14 02:52:45 UTC (rev 143)
+++ happyboom/trunk/server/client_manager.py	2005-09-14 02:58:26 UTC (rev 144)
@@ -0,0 +1,134 @@
+from happyboom.net import io, io_udp, io_tcp, net_buffer
+import thread, traceback
+
+class ClientManager(object):
+    def __init__(self, arg): 
+        self.__server = None 
+        self.__io = io_tcp.IO_TCP(is_server=True)
+        self.__io.debug = arg.get("debug", False)
+        self.__io.verbose = arg.get("verbose", False)
+        self.__buffer = net_buffer.NetBuffer()
+        self.__debug = arg.get("debug", False)
+        self.__verbose = arg.get("verbose", False)
+        self.max_clients = arg.get("max_clients", 2)
+        self.client_port = arg.get("client_port", 12430)
+        self.__supported_features = {}
+        self.__clients = []
+        self.__clients_sema = thread.allocate_lock()
+        
+    def recvClientPacket(self, packet):
+        self.__buffer.append(packet.recv_from.addr, packet)
+
+    def stop(self):
+        for client in self.__clients:
+            client.stop()
+
+    def process(self):
+        pass
+#        processInputs()
+
+    def start(self):
+        if self.__verbose: print "[*] Starting server"
+        self.__io.name = "server"
+        self.__io.on_client_connect = self.openClient
+        self.__io.on_client_disconnect = self.closeClient
+        self.__io.on_new_packet = self.recvClientPacket
+        self.__io.connect('', self.client_port)
+        thread.start_new_thread(self.run_io_thread, ())
+
+    def readClientAnswer(self, client, timeout=1.000):
+        answer = self.__buffer.readBlocking(client.addr, timeout)
+        if answer==None: return None
+        return answer.data
+
+    def registerFeature(self, client, role):
+        if role in self.__supported_features:
+            if client not in self.__supported_features[role]:
+                self.__supported_features[role].append(client)
+        else:
+            self.__supported_features[role] = [client,]
+        
+    def openClient(self, client):
+        # TODO: Ne pas utiliser de thread ?!
+        thread.start_new_thread( self.__clientChallenge, (client,self.__do_openClient))
+
+    def closeClient(self, client):
+        if self.__verbose:
+            log.info("Client %s disconnected." % client.name)
+        
+        txt = "Client %s (display) leave us." % (client.name)
+        self.__gateway.sendText(txt)
+        
+        client.sendMsg("presentation", "bye", "utf8", u"Lost connection")
+        
+    def __clientChallenge(self, client, func):
+        try:
+            func(client)
+        except Exception, msg:
+            print "EXCEPTION WHEN A CLIENT TRY TO CONNECT :"
+            print msg
+            print "--"
+            traceback.print_exc()
+            self.stop()
+
+    # Function which should be called in a thread
+    # TODO: Pourquoi c'est utilis? ?a ?
+    def run_io_thread(self):
+        try:
+            while self.__io.isRunning():
+                self.__io.live()                
+                time.sleep(0.001)
+        except Exception, msg:
+            print "EXCEPTION IN IO THREAD :"
+            print msg
+            print "--"            
+            traceback.print_exc()
+            self.stop()
+
+    def generateSignature(self, client):
+        import random
+        r = random.randint(0,1000000)
+        return r
+
+    def __do_openClient(self, io_client):
+        if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
+        client = ClientSocket(io_client, self)
+        
+#        self.__buffer.clear(client.addr)
+       
+        # Check protocol version (max: wait 200ms)
+        answer = self.readClientAnswer(client, 0.200)
+        if answer != self.__gateway.protocol_version:
+            # If it isn't the right version, send presention.bye(...)
+            txt = u"Sorry, you don't have same protocol version (%s VS %s)" \
+                % (answer, self.__gateway.protocol_version)
+            client.sendMsg("presentation", "bye", "utf8", txt)
+
+            # Wait 0.5s and then disconnect the client
+            time.sleep(0.500)
+            client.disconnect()
+            return
+            
+        # Send protocol version with "hello()"
+        client.signature = self.generateSignature()        
+        client.send("presentation", "hello", \
+            "bin", self.__gateway.protocol_version, \
+            "bin", signature)
+         
+        # Read features (max: wait 1sec)
+        answer = client.read(1.0)
+        #TODO: do something with answer :-)
+
+        self.__clients_sema.acquire() 
+        self.__clients.append(client)
+        self.__clients_sema.release() 
+
+        txt = "Welcome to new (display) client : %s" % (client.name)
+        self.__gateway.sendText(txt)
+        if self.__verbose: print "[*] Display %s connected" % (client.name)
+        self.sendBBMessage("sync")
+
+    def __getSupportedFeatures(self): return self.__supported_features
+    supported_features = property(__getSupportedFeatures)
+
+

Added: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-14 02:52:45 UTC (rev 143)
+++ happyboom/trunk/server/gateway.py	2005-09-14 02:58:26 UTC (rev 144)
@@ -0,0 +1,65 @@
+from happyboom.common import packer
+from happyboom.server.agent import Agent
+from pysma import Kernel, DummyScheduler
+from happyboom.common.protocol import loadProtocol
+from happyboom.net.io import Packet
+
+class Gateway(Agent):
+    def __init__(self, protocol, client_manager, arg):
+        Agent.__init__(self, self, "gateway")
+        self.__protocol = protocol
+        self.__client_manager = client_manager
+        self.__server = None 
+        self._debug = arg.get("debug", False)
+        self._verbose = arg.get("verbose", False)
+        self.__scheduler = DummyScheduler(sleep=0.01)
+        Kernel().addAgent(self.__scheduler)
+
+    def __setServer(self, server):
+        self.__server = server
+        self.__client_manager.server = server
+    server = property(None, __setServer)
+
+
+    # Create a network packet for the event func.event(args) where
+    # args is a tuple
+    def createMsgTuple(self, func, event, args):
+        data = packer.pack(func, event, args)
+        return Packet(data)
+            
+    # Create a network packet for the event func.event(args), see
+    # L{self.createMsgTuple}
+    def createMsg(self, func, event, *args):
+        return self.createMsgTuple(func, event, args)
+
+    def start(self):
+        self.__client_manager.start()
+        Kernel.instance.addAgent(self)
+        
+    def stop(self):
+        self.sendNetMsg("game", "stop")
+        self.__client_manager.stop()
+        Kernel.instance.stopKernel()
+
+    def process(self):
+        # Stop server if the scheduler is dead
+        if not self.__scheduler.alive:
+            self.__server.stop()
+        self.__client_manager.process()
+
+    def sendText(self, txt, client=None):
+        if client != None:
+            client.sendMsg("agent_manager", "Text", txt)
+        else:
+            self.sendNetMsg("agent_manager", "Text", txt)
+
+    def sendNetMsg(self, func, event, *args):
+        packet = self.createMsgTuple(func, type, args)
+        clients = self.__client_manager.supported_features.get(func, ())
+        for client in clients:
+            client.sendPacket(packet)
+
+    def __getProtocolVersion(self): return self.__protocol.version
+    protocol_version = property(__getProtocolVersion)
+
+



From haypo at berlios.de  Wed Sep 14 04:59:24 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 04:59:24 +0200
Subject: [Happyboom-svn] r145 - in boomboom: . server server/agents
Message-ID: <200509140259.j8E2xOZn018105@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 04:59:17 +0200 (Wed, 14 Sep 2005)
New Revision: 145

Added:
   boomboom/protocol.xml
Modified:
   boomboom/boomboom_server.py
   boomboom/server/__init__.py
   boomboom/server/agents/character.py
   boomboom/server/agents/game.py
   boomboom/server/agents/projectile.py
   boomboom/server/agents/weapon.py
   boomboom/server/agents/world.py
   boomboom/server/bb_agent.py
   boomboom/server/bb_server.py
Log:
Update for last HappyBoom version.


Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/boomboom_server.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -5,6 +5,7 @@
 
 import getopt
 import sys
+from happyboom.common.protocol import loadProtocol
 
 def usage(defval):
     print "%s server version %s" % (PROGRAM, VERSION)
@@ -85,8 +86,9 @@
         "debug": False}
     arg = parseArgs(val)
     
-    from server import BoomBoomServer
-    server = BoomBoomServer(arg)
+    from server.bb_server import Server
+    protocol = loadProtocol("protocol.xml")
+    server = Server(protocol, arg)
 
     try:
         server.start()

Added: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/protocol.xml	2005-09-14 02:59:17 UTC (rev 145)
@@ -0,0 +1,14 @@
+<?xml version="1.0"?>
+<protocol game="BoomBoom" version="0.2">
+  <func name="game" id="1">
+    <event name="start" id="1" />
+    <event name="stop" id="2" />
+  </func>
+  <func name="character" id="4">
+    <event name="move" id="1">
+      <param name="id" type="int" />
+      <param name="x" type="int" />
+      <param name="y" type="int" />
+    </event>
+  </func>
+</protocol>

Modified: boomboom/server/__init__.py
===================================================================
--- boomboom/server/__init__.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/__init__.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,2 +0,0 @@
-from bb_server import BoomBoomServer
-from bb_agent import BoomBoomAgent, BoomBoomMessage

Modified: boomboom/server/agents/character.py
===================================================================
--- boomboom/server/agents/character.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/agents/character.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,8 +1,8 @@
-from server.bb_agent import BoomBoomAgent, BoomBoomMessage
+from server.bb_agent import Agent, Message
 
-class Character(BoomBoomAgent):
-    def __init__(self, x, team, **args):
-        BoomBoomAgent.__init__(self, "character", **args)
+class Character(Agent):
+    def __init__(self, gateway, x, team, **args):
+        Agent.__init__(self, "character", gateway, **args)
         self.x = x
         self.y = 0
         self.width = 28
@@ -12,20 +12,22 @@
         self.current = False
         
     def born(self):
-        BoomBoomAgent.born(self)
+        Agent.born(self)
         self.requestActions("game")
         self.requestActions("network")
-        self.sendBroadcastMessage(BoomBoomMessage("character_search_place", (self.x, self.width, self.height)), "world")
-        self.sendBroadcastMessage(BoomBoomMessage("new_character", (self.id, self.team)), "game")
-        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+        self.sendBroadcast(Message("character_search_place", (self.x, self.width, self.height)), "world")
+        self.sendBroadcast(Message("new_character", (self.id, self.team)), "game")
+        self.sendBroadcast(Message("new_item", (self.type, self.id)), "network")
 
     def move(self, x, y, force=False):
         if self.x == x and self.y == y and not force: return
         self.x = x
         self.y = y
-        self.sendBroadcastMessage(BoomBoomMessage("character_move", ("%u,%i,%i" % (self.id, self.x, self.y),)), "network")
+        self.sendBroadcast(Message("character_move", ("%u,%i,%i" % (self.id, self.x, self.y),)), "network")
         if self.current:
-            self.sendBBMessage("active_coord", self.x, self.y)
+            self.send("active_coord", self.x, self.y)
+            self.sendNetMsg("character", "move", \
+                "int", self.id, "int", self.x, "int", self.y)
 
     def sync(self):
         self.move(self.x, self.y, force=True)
@@ -40,8 +42,8 @@
     def msg_game_next_turn(self):
         self.current = self.next
         if self.current:
-            self.sendBBMessage("active_coord", self.x, self.y)
+            self.send("active_coord", self.x, self.y)
         self.next = False
         
     def msg_network_sync(self):
-        self.sync()
\ No newline at end of file
+        self.sync()

Modified: boomboom/server/agents/game.py
===================================================================
--- boomboom/server/agents/game.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/agents/game.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,57 +1,40 @@
-from server.bb_agent import BoomBoomAgent, BoomBoomMessage
+from server.bb_agent import Agent, Message
 import traceback
 
-class Game(BoomBoomAgent):
-    def __init__(self, **args):
-        BoomBoomAgent.__init__(self, "game", **args)
-        self.teams = []
-        self.characters = {}
-        self.next_team_pos = None
-        self.next_char_pos = {}
-        self.current = (None, None)
+class Game(Agent):
+    def __init__(self, gateway, **args):
+        Agent.__init__(self, "game", gateway, **args)
+        self.characters = []
+        self.current = None 
 
     def born(self):
-        BoomBoomAgent.born(self)
+        Agent.born(self)
         self.requestActions("world")
         self.requestActions("network")
 
-    def sendNextCharacter(self, char_pos, team_pos):
-        if self.next_team_pos != None:
-            self.current = (self.nextCharacter, self.nextTeam)
-        self.next_team_pos = team_pos
-        self.next_char_pos[self.nextTeam] = char_pos
-        self.sendBBMessage("next_character", self.nextCharacter, self.nextTeam)
-
     def msg_network_sync(self):
         self.sync()
 
-    def msg_new_character(self, character, team):
-        if team in self.teams:
-            self.characters[team].append(character)
-        else:
-            self.teams.append(team)
-            self.characters[team] = [character,]
-            self.next_char_pos[team] = 0
+    def msg_new_character(self, character):
+        self.characters.append(character)
+        if self.current == None: self.current = 0 
 
     def sync(self):
-        char, team = self.current
-        self.sendBroadcastMessage(BoomBoomMessage("game_current_character", (char, team)), "network")
+        self.sendBroadcast(Message("game_current_character", self.current), "network")
 
-    def __getNextCharacter(self):
-        return self.characters[self.nextTeam][self.next_char_pos[self.nextTeam]]
-    nextCharacter = property(__getNextCharacter)
-
-    def __getNextTeam(self):
-        return self.teams[self.next_team_pos]
-    nextTeam = property(__getNextTeam)
-
     def incCharacter(self):
         tpos = (self.next_team_pos + 1) % 2
         cpos = (self.next_char_pos[self.teams[tpos]] + 1) % len(self.characters[self.teams[tpos]])
         self.sendNextCharacter(cpos, tpos)
 
+    def nextTurn(self):
+        self.send("next_turn")
+        self.sendNetMsg("game", "next_turn")
+        self.sendNetMsg("game", "active_character", \
+            "int", self.current)
+
     def msg_world_collision(self, x, y):
-        self.sendBBMessage("next_turn")
+        self.nextTurn()
         self.incCharacter()
         
     def msg_start(self):
@@ -59,5 +42,5 @@
 
     def launchGame(self):    
         self.sendNextCharacter(0, 0)
-        self.sendBBMessage("next_turn")
-        self.incCharacter()
\ No newline at end of file
+        self.nextTurn()
+        self.incCharacter()

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/agents/projectile.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,10 +1,10 @@
-from server.bb_agent import BoomBoomAgent, BoomBoomMessage
+from server.bb_agent import Agent, Message
 import time
 import math
 
-class Projectile(BoomBoomAgent):
-    def __init__(self, **args):
-        BoomBoomAgent.__init__(self, "projectile", **args)
+class Projectile(Agent):
+    def __init__(self, gateway, **args):
+        Agent.__init__(self, "projectile", gateway, **args)
         self.x, self.y = 0, 0
         self.start_pos = None
         self.active = False
@@ -15,14 +15,14 @@
         self.mass = 10
 
     def born(self):
-        BoomBoomAgent.born(self)
+        Agent.born(self)
         self.requestRole("command_manager")
         self.requestActions("weapon")
         self.requestActions("character")
         self.requestActions("world")
         self.requestActions("game")
         self.requestActions("network")
-        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+        self.sendBroadcastMessage(Message("new_item", (self.type, self.id)), "network")
 
     def msg_weapon_strength(self, arg):
         self.weapon_strength = int(arg) * 4
@@ -62,7 +62,7 @@
         self.sendBBMessage("move", x, y)
 
     def live(self):
-        BoomBoomAgent.live(self)
+        Agent.live(self)
         if self.active:
             dt = time.time() - self.time
             x = self.start_pos[0] +self.speed[0] * dt
@@ -73,4 +73,4 @@
         self.setActive(self.active)
 
     def msg_network_sync(self):
-        self.sync()
\ No newline at end of file
+        self.sync()

Modified: boomboom/server/agents/weapon.py
===================================================================
--- boomboom/server/agents/weapon.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/agents/weapon.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,8 +1,8 @@
-from server.bb_agent import BoomBoomAgent, BoomBoomMessage
+from server.bb_agent import Agent, Message
 
-class Weapon(BoomBoomAgent):
-    def __init__(self, **args):
-        BoomBoomAgent.__init__(self, "weapon", **args)
+class Weapon(Agent):
+    def __init__(self, gateway, **args):
+        Agent.__init__(self, "weapon", gateway, **args)
         self.angle = None
         self.strength = None
         self.last_values = {}
@@ -10,11 +10,11 @@
         self.nextTeam = None
 
     def born(self):
-        BoomBoomAgent.born(self)
+        Agent.born(self)
         self.requestRole("command_manager")
         self.requestActions("game")
         self.requestActions("network")
-        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+        self.sendBroadcast(Message("new_item", (self.type, self.id)), "network")
 
     def msg_game_next_character(self, char, team):
         self.nextTeam = team
@@ -40,17 +40,17 @@
         if angle < -80: angle = -80
         elif 80 < angle: angle = 80
         self.angle = angle 
-        self.sendBBMessage("angle", angle)
+        self.send("angle", angle)
 
     def updateStrength(self, strength):
         if strength < 10: strength = 10
         elif 100 < strength: strength = 100
         self.strength = strength
-        self.sendBBMessage("strength", strength)
+        self.send("strength", strength)
 
     def sync(self):
         self.updateStrength(self.strength)
         self.updateAngle(self.angle)
 
     def msg_network_sync(self):
-        self.sync()
\ No newline at end of file
+        self.sync()

Modified: boomboom/server/agents/world.py
===================================================================
--- boomboom/server/agents/world.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/agents/world.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,4 +1,4 @@
-from server.bb_agent import BoomBoomAgent, BoomBoomMessage
+from server.bb_agent import Agent, Message
 import random
 
 class Building:
@@ -20,20 +20,20 @@
         return True
 
 
-class World(BoomBoomAgent):
-    def __init__(self, **args):
-        BoomBoomAgent.__init__(self, "world", **args)
+class World(Agent):
+    def __init__(self, gateway, **args):
+        Agent.__init__(self, "world", gateway, **args)
         self.buildings = None
         self.height = 350
         self.width = 640
         self.generate()
 
     def born(self):
-        BoomBoomAgent.born(self)
+        Agent.born(self)
         self.requestActions("projectile")
         self.requestActions("game")
         self.requestActions("network")
-        self.sendBroadcastMessage(BoomBoomMessage("new_item", (self.type, self.id)), "network")
+        self.sendBroadcastMessage(Message("new_item", (self.type, self.id)), "network")
 
     def generate(self):
         width = self.width
@@ -70,7 +70,7 @@
         for b in self.buildings:
             if len(msg) != 0: msg = msg + ";"
             msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
-        self.sendBroadcastMessage(BoomBoomMessage("world_create", (msg,)), "network")
+        self.sendBroadcastMessage(Message("world_create", (msg,)), "network")
 
     def msg_character_search_place(self, x0, width, height):
         if x0 < 0:
@@ -85,11 +85,11 @@
                 x = int(b.x + (b.width - width) / 2)
                 y = b.y - height
                 break
-        self.sendMessage(BoomBoomMessage("found_place", (x, y)), self.currentMessage.sender)
+        self.sendMessage(Message("found_place", (x, y)), self.currentMessage.sender)
                 
     def msg_projectile_move(self, x, y):
         if self.hitGround(x, y):
             self.sendBBMessage("collision", x, y)
 
     def msg_network_sync(self):
-        self.sync()
\ No newline at end of file
+        self.sync()

Modified: boomboom/server/bb_agent.py
===================================================================
--- boomboom/server/bb_agent.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/bb_agent.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,25 +1 @@
-from pysma import ActionAgent, ActionMessage
-
-class BoomBoomMessage(ActionMessage):
-    def __init__(self, action, arg, kw={}):
-        ActionMessage.__init__(self, action, arg, kw)
-
-class BoomBoomAgent(ActionAgent):
-    def __init__(self, type, **args):
-        ActionAgent.__init__(self, prefix="msg_")
-        self.type = type
-        self.__debug = args.get("debug", False)
-
-    def born(self):
-        self.requestRole(self.type)
-
-    def requestActions(self, type):
-        self.requestRole("%s_listener" %type)
-        
-    def sendBBMessage(self, action, *arg, **kw):
-        message = BoomBoomMessage("%s_%s" %(self.type, action), arg, kw)
-        self.sendBroadcastMessage(message, "%s_listener" %self.type)
-
-    def messageReceived(self, msg):
-        if self.__debug:
-            print "Unhandled message : %s -- %s" %(type(self), msg)
\ No newline at end of file
+from happyboom.server.agent import Agent, Message

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-14 02:58:26 UTC (rev 144)
+++ boomboom/server/bb_server.py	2005-09-14 02:59:17 UTC (rev 145)
@@ -1,13 +1,17 @@
-from happyboom.server.base_server import HappyBoomServer, HappyBoomGateway, HappyBoomMessage
+from happyboom.server.base_server import \
+    Server as HBServer, \
+    Gateway as HBGateway, \
+    ClientManager
 from pysma import Kernel
+from bb_agent import Message
 from agents import Character, Projectile, Weapon, World, Game
 
-class BoomBoomGateway(HappyBoomGateway):
-    def __init__(self, server, arg):
-        HappyBoomGateway.__init__(self, server, arg)
+class Gateway(HBGateway):
+    def __init__(self, protocol, manager, arg):
+        HBGateway.__init__(self, protocol, manager, arg)
 
     def born(self):
-        HappyBoomGateway.born(self)
+        HBGateway.born(self)
         self.requestActions("game")
         self.requestActions("weapon")
         self.requestActions("character")
@@ -15,15 +19,15 @@
         self.requestActions("projectile")
 
     def start(self):
-        HappyBoomGateway.start(self)
+        HBGateway.start(self)
         if self._verbose: print "[*] Creating agents"
-        self.addAgent(Game(debug=self._debug))
-        self.addAgent(World(debug=self._debug))
-        self.addAgent(Character(100, 1, debug=self._debug))
-        self.addAgent(Character(-150, 2, debug=self._debug))
-        self.addAgent(Weapon(debug=self._debug))
-        self.addAgent(Projectile(debug=self._debug))
-        self.sendBroadcastMessage(HappyBoomMessage("start", ()), "game")
+        self.addAgent(Game(self, debug=self._debug))
+        self.addAgent(World(self, debug=self._debug))
+        self.addAgent(Character(self, 100, 1, debug=self._debug))
+        self.addAgent(Character(self, -150, 2, debug=self._debug))
+        self.addAgent(Weapon(self, debug=self._debug))
+        self.addAgent(Projectile(self, debug=self._debug))
+        self.sendBroadcastMessage(Message("start", ()), "game")
                         
     def msg_game_next_character(self, char, team):
         if self._debug: print "Next character : %s,%s" %(char, team)
@@ -31,36 +35,34 @@
                         
     def msg_game_next_turn(self):
         if self._debug: print "Next turn : %s" %self.nextChar
-        self.sendNetworkMessage("game", "next_turn")
-        self.sendNetworkMessage("game", "active_character", self.nextChar)
         
     def msg_game_collision(self, x, y):
         if self._debug: print "Hit ground : %s,%s" %(x, y)
-        self.sendNetworkMessage("projectile", "hit_ground")
+        self.sendNetMsg("projectile", "hit_ground")
     
     def msg_projectile_move(self, x, y):
         if self._debug: print "Projectile move : %s,%s" %(x, y)
-        self.sendNetworkMessage("projectile", "move", "%i,%i" %(x,y), True)
+        self.sendNetMsg("projectile", "move", "%i,%i" %(x,y), True)
         
     def msg_projectile_activate(self, flag):
         if self._debug: print "Projectile activate : %s" %flag
-        self.sendNetworkMessage("projectile", "activate", "%u" %(flag))
+        self.sendNetMsg("projectile", "activate", "%u" %(flag))
         
     def msg_weapon_angle(self, a):
         if self._debug: print "Weapon angle : %s" %a
-        self.sendNetworkMessage("weapon", "angle", a)
+        self.sendNetMsg("weapon", "angle", a)
         
     def msg_weapon_strength(self, s):
         if self._debug: print "Weapon strength : %s" %s
-        self.sendNetworkMessage("weapon", "force", s)
+        self.sendNetMsg("weapon", "force", s)
         
     def msg_world_create(self, m):
         if self._debug: print "World create : %s" %m
-        self.sendNetworkMessage("world", "create", m)
+        self.sendNetMsg("world", "create", m)
         
     def msg_character_move(self, m):
         if self._debug: print "Character move : %s" %m
-        self.sendNetworkMessage("character", "move", m)
+        self.sendNetMsg("character", "move", m)
         
     def msg_new_item(self, type, id):
         if self._debug: print "New item : %s,%s" %(type, id)
@@ -68,9 +70,10 @@
         
     def msg_game_current_character(self, char, team):
         if self._debug: print "Current character : %s,%s" %(char, team)
-        self.sendNetworkMessage("game", "active_character", char)
+        self.sendNetMsg("game", "active_character", char)
 
-class BoomBoomServer(HappyBoomServer):
-    def __init__(self, arg):
-        arg["gateway"] = BoomBoomGateway(self, arg)
-        HappyBoomServer.__init__(self, arg)
+class Server(HBServer):
+    def __init__(self, protocol, arg):
+        manager = ClientManager(arg)
+        gateway = Gateway(protocol, manager, arg)
+        HBServer.__init__(self, gateway, arg)



From dboucard at berlios.de  Wed Sep 14 05:10:56 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 05:10:56 +0200
Subject: [Happyboom-svn] r146 - happyboom/trunk/common
Message-ID: <200509140310.j8E3AuW4020976@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 05:10:51 +0200 (Wed, 14 Sep 2005)
New Revision: 146

Modified:
   happyboom/trunk/common/packer.py
Log:


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 02:59:17 UTC (rev 145)
+++ happyboom/trunk/common/packer.py	2005-09-14 03:10:51 UTC (rev 146)
@@ -46,3 +46,10 @@
             raise PackerException("Wrong argument type: %s" % type)
         out = out + data
     return out        
+    
+def unpack(data):
+    """
+    Unpack binary string to arguments.
+    """
+    # TODO
+    pass



From dboucard at berlios.de  Wed Sep 14 05:28:36 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 05:28:36 +0200
Subject: [Happyboom-svn] r147 - happyboom/trunk/common
Message-ID: <200509140328.j8E3Sa1O027320@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 05:28:30 +0200 (Wed, 14 Sep 2005)
New Revision: 147

Modified:
   happyboom/trunk/common/packer.py
Log:


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 03:10:51 UTC (rev 146)
+++ happyboom/trunk/common/packer.py	2005-09-14 03:28:30 UTC (rev 147)
@@ -46,10 +46,15 @@
             raise PackerException("Wrong argument type: %s" % type)
         out = out + data
     return out        
+
+def unpackBin(data):
+    return struct.unpack("!Hs", data)[1]
     
+def unpackInt(data):
+    return struct.pack("!i", data)[0]
+
 def unpack(data):
     """
     Unpack binary string to arguments.
     """
-    # TODO
-    pass
+    



From dboucard at berlios.de  Wed Sep 14 06:12:42 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 06:12:42 +0200
Subject: [Happyboom-svn] r148 - happyboom/trunk/common
Message-ID: <200509140412.j8E4CgCS004886@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 06:12:39 +0200 (Wed, 14 Sep 2005)
New Revision: 148

Modified:
   happyboom/trunk/common/packer.py
Log:
unpack


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 03:28:30 UTC (rev 147)
+++ happyboom/trunk/common/packer.py	2005-09-14 04:12:39 UTC (rev 148)
@@ -48,13 +48,34 @@
     return out        
 
 def unpackBin(data):
-    return struct.unpack("!Hs", data)[1]
+    fmt = "!H"
+    i = struct.calcsize(fmt)
+    strlen, data = struct.unpack(fmt, data[:i]), data[i:]
+    fmt = "!%ss" %(strlen)
+    i = struct.calcsize(fmt)
+    return (struct.unpack(fmt, data[:i]), data[i:])
     
 def unpackInt(data):
-    return struct.pack("!i", data)[0]
+    fmt = "!i"
+    i = struct.calcsize(fmt)
+    return (struct.unpack(fmt, data[:i]), data[i:])
 
 def unpack(data):
     """
     Unpack binary string to arguments.
     """
-    
+    fmt = "!BB"
+    i = struct.calcsize(fmt)
+    feat, evt = struct.unpack(fmt, data[:i])
+    data = data[i:]
+    args = []
+    for type in getArgTypes(feat, evt):
+        if type=="int":
+            arg, tail = unpackInt(data)
+        elif type=="bin":
+            arg, tail = unpackBin(data)
+        else:
+            raise PackerException("Wrong argument type: %s" % type)
+        args.append(arg)
+        data = tail
+    return (feat, evt, args)
\ No newline at end of file



From haypo at berlios.de  Wed Sep 14 06:13:05 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 06:13:05 +0200
Subject: [Happyboom-svn] r149 - poilu/trunk
Message-ID: <200509140413.j8E4D5iD004920@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 06:13:03 +0200 (Wed, 14 Sep 2005)
New Revision: 149

Modified:
   poilu/trunk/dico_poilu.py
   poilu/trunk/insulte.txt
   poilu/trunk/motcle.py
   poilu/trunk/motcle_regex.txt
   poilu/trunk/pypoil.py
Log:
On peut activer ou desactiver les modes dico et motcle. Corrige deux-trois bugs.


Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-14 04:12:39 UTC (rev 148)
+++ poilu/trunk/dico_poilu.py	2005-09-14 04:13:03 UTC (rev 149)
@@ -87,7 +87,7 @@
         f.close()
 
     def terminaison(self, str):
-        str = unicode.rstrip(str, self.muet)
+        str = unicode.rstrip(str.lower(), self.muet)
         for item in self.regex:
             fin = item[0]
             expr = item[1]

Modified: poilu/trunk/insulte.txt
===================================================================
--- poilu/trunk/insulte.txt	2005-09-14 04:12:39 UTC (rev 148)
+++ poilu/trunk/insulte.txt	2005-09-14 04:13:03 UTC (rev 149)
@@ -1 +1,9 @@
 mdr:Ta gueule grosse vache !
+asp:"dot NET" ??apucpalibre
+oracle:Oracle ??apucpalibre, PostgreSQL c'est libre au moins!
+java:Java ??apucpalibre, utilisez Python !
+mirc:mIrc ??apucpalibre, utilisez Xchat, bitchx, irsii ou autre !
+apple:Apple ---> Mangez des pommes !
+clanlib:ClanLib c'est affreux, n'utilisez pas cette biblioth??que !
+troll:Troll detected !!! :)
+windows:Windows ??apucpalibre, utilisez Linux ou *BSD !

Modified: poilu/trunk/motcle.py
===================================================================
--- poilu/trunk/motcle.py	2005-09-14 04:12:39 UTC (rev 148)
+++ poilu/trunk/motcle.py	2005-09-14 04:13:03 UTC (rev 149)
@@ -3,6 +3,7 @@
 
 import re
 import random
+import codecs
 
 def unicode2term(str): 
 	return str.encode("latin-1")
@@ -10,7 +11,7 @@
 class motcle_poilu:
     def __init__(self):
 		self.insulte = dict()
-		self.regex = []
+		self.regex = dict() 
 		self.charge_regex()
 		self.charge()
 
@@ -50,25 +51,27 @@
         self.insulte = {}
         for ligne in f:
 			ligne = unicode(ligne.strip(), "utf8")
-			regs = re.compile("^(.+):(.+)$").search(ligne)
+			regs = re.compile("^([^:]+):(.+)$").search(ligne)
 			if regs != None: self.ajoute(regs.group(1), regs.group(2))
         f.close()
 
     def charge_regex(self):
-        self.regex = []
-        f = file("motcle_regex.txt","r")
+        f = codecs.open("motcle_regex.txt","r","utf8")
+        self.regex = dict()
         for ligne in f:
-            ligne = unicode(ligne.strip(), "utf8")
-            regs = re.compile("^(.+):(.+)$").search(ligne)
+            ligne = ligne.strip()
+            regs = re.compile("^([^:]+):(.+)$").search(ligne)
             if regs != None: 
                 regex = re.compile(regs.group(2))
-                self.regex.append( (regs.group(1), regex,) )
+                self.regex[regs.group(1)] = regex
+            else:
+                print "La ligne \"%s\" de motcle_regex.txt n'a pas ??t?? comprise !" % ligne
         f.close()
 
     def calcule_cle(self, str):
-        for item in self.regex:
-            r = item[1].search(str)
-            if r != None: return item[0] 
+        for key,regex in self.regex.items():
+            r = regex.search(str)
+            if r != None: return key 
         return None
 
     def reponse(self, str):

Modified: poilu/trunk/motcle_regex.txt
===================================================================
--- poilu/trunk/motcle_regex.txt	2005-09-14 04:12:39 UTC (rev 148)
+++ poilu/trunk/motcle_regex.txt	2005-09-14 04:13:03 UTC (rev 149)
@@ -1 +1,9 @@
 mdr:([Mm]dr|lo+l|ptdr+)
+asp:(ASP|\.(NET|Net))
+oracle:[Oo]racle
+java:[Jj]ava
+mirc:(mI|mi)rc
+apple:[Aa]pple
+clanlib:(ClanLib|clanlib)
+troll:([Mm]andrake|[Gg]entoo|utf-8)
+windows:([Ww]indows)

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-14 04:12:39 UTC (rev 148)
+++ poilu/trunk/pypoil.py	2005-09-14 04:13:03 UTC (rev 149)
@@ -34,6 +34,8 @@
         self.motcle = motcle_poilu()
         self.taux_reponse = 100
         self.welcome = u"Salut"
+        self.reponse_motcle = True
+        self.reponse_dico = True
 
     def on_nicknameinuse(self, c, e):
         c.nick(c.get_nickname() + "_")
@@ -59,7 +61,6 @@
         self.echou(u"- recharge_muet            : recharge muet.txt")
         self.echou(u"- recharge_terminaison     : recharge terminaison.txt")
         self.echou(u"- recharge_dico            : recharge dico.txt")
-        self.echou(u"- recharge_insult          : recharge insulte.txt")
         self.echou(u"- recharge_motcle          : recharge motcle_regex.txt")
         self.echou(u"- join #chan / leave #chan : joint/quitte le canal #<chan>")
         self.echou(u"- nick xxx                 : change de surnom")
@@ -67,8 +68,9 @@
         self.echou(u"- utf-8 / iso              : parle en UTF-8 / iso-8859-1")
         self.echou(u"- muet                     : liste des caract?res muets")
         self.echou(u"- taux_reponse xxx         : fixe le taux de r?ponse (en pourcent)")
+        self.echou(u"- reponse_dico             : active/d?sactive la r?ponse du dico")
+        self.echou(u"- reponse_motcle           : active/d?sactive la r?ponse des mot-cl?s")
 
-
     def on_privmsg(self, c, e):
         cmd = self.get_command(e)
         self.do_priv_command(cmd) 
@@ -90,9 +92,9 @@
             return
             
         # Sinon, cherche une rime
-        cmd = cmd.lower()
-        reponse = self.dico.reponse(cmd)
-        if reponse==None: reponse = self.motcle.reponse(cmd)
+        reponse = None
+        if reponse==None and self.reponse_dico: reponse = self.dico.reponse(cmd)
+        if reponse==None and self.reponse_motcle: reponse = self.motcle.reponse(cmd)
         if reponse==None: return
         
         if self.taux_reponse <= random.uniform(0,101): return
@@ -201,6 +203,18 @@
                     %(regs.group(1), ", ".join(termes)))
             return True
             
+        regs = re.compile("^reponse_dico$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            self.reponse_dico = not self.reponse_dico
+            self.echou(u"R?ponse par dico : %s"  % self.reponse_dico)
+            return True
+            
+        regs = re.compile("^reponse_motcle$", re.IGNORECASE).search(cmd)
+        if regs != None:
+            self.reponse_motcle = not self.reponse_motcle
+            self.echou(u"R?ponse par mot-cl? : %s"  % self.reponse_motcle)
+            return True
+            
         regs = re.compile("^taux_reponse (.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
             try:
@@ -237,9 +251,6 @@
         if (cmd == "recharge_motcle"):
             self.echo("(recharge motcle_regex.txt)")
             self.motcle.charge_regex()
-            return True
-            
-        if (cmd == "recharge_insulte"):
             self.echo("(recharge insulte.txt)")
             self.motcle.charge()
             return True



From haypo at berlios.de  Wed Sep 14 06:16:09 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 06:16:09 +0200
Subject: [Happyboom-svn] r150 - in happyboom/trunk: common server
Message-ID: <200509140416.j8E4G9OB005952@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 06:16:04 +0200 (Wed, 14 Sep 2005)
New Revision: 150

Modified:
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/protocol.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Game protocol is loaded and checked from the XML file. Gateway.createMsg() checks
that the feature and event do exist, and also checks the arguments type.


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 04:13:03 UTC (rev 149)
+++ happyboom/trunk/common/packer.py	2005-09-14 04:16:04 UTC (rev 150)
@@ -5,6 +5,16 @@
     def __init__(self, msg):
         Exception.__init__(self, msg)
 
+def checkType(datatype, data):
+    if datatype=="int":
+        return (type(data) == type(1)) and (data <= 2147483647) and (-2147483648 <= data)
+    elif datatype=="bin":
+        return true
+    elif datatype=="utf8":
+        return type(data)==types.unicode
+    else:
+        raise PackerException("Wrong argument type: %s" % datatype)
+
 def packInt(data):
     assert type(data)==type(1), "packInt argument have to be an integer"
     # Overflow is checked by struct.pack
@@ -17,9 +27,9 @@
     return packBin(data.encode("utf-8"))
 
 def packBin(data):
-    return struct.pack("!Hs", len(data), data)
+    return struct.pack("!H%us" % len(data), len(data), data)
 
-def pack(func, event, args):
+def pack(func, event, types, values):
     """
     Pack arguments to binary string. Supported types :
     - "int": L{packInt}
@@ -27,13 +37,13 @@
     - "utf8": L{packUtf8}
     """
 
-    assert (len(args) % 2) == 0, "Arguments length have to be even"
-    out = "%s:%s" % (func, event)
+    assert len(types) == len(values), "Lengths of types and args have to be the same."
+    out = struct.pack("!ii", func, event)
 
     #TODO: Fix this :-)
-    for i in range(0,len(args)-1, 2):
-        type = args[i]
-        data = args[i+1]
+    for i in range(len(values)):
+        type = types[i]
+        data = values[i]
         
         # TODO: Use dict instead of long if list
         if type=="int":

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-14 04:13:03 UTC (rev 149)
+++ happyboom/trunk/common/protocol.py	2005-09-14 04:16:04 UTC (rev 150)
@@ -1,25 +1,37 @@
 import xml.dom.minidom
 
+class ProtocolException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
 class ProtocolEventParam:
-    def __init__(self, name, type):
+    def __init__(self, event, name, type):
         self.name = name
         self.type = type
+        self.event = event
 
     def __str__(self):
-        return self.name
+        return "%s: %s" % (self.name, self.type)
        
 class ProtocolEvent:
-    def __init__(self, name, id):
+    def __init__(self, feature, name, id):
         self.name = name
         self.id = id
+        self.feature = feature
         self.__params_dict = {}
         self.__params_array = [] 
         
     def addParam(self, name, id):
-        param = ProtocolEventParam(name, id)
+        param = ProtocolEventParam(self, name, id)
         self.__params_dict[name] = param
         self.__params_array.append(param)
         return param
+
+    def getParamsType(self):
+        types = []
+        for param in self.__params_array:
+            types.append(param.type)
+        return types
         
     def __str__(self):
         out = "%s(" % (self.name)
@@ -33,21 +45,37 @@
         out = out + ")"
         return out
 
-class ProtocolFunc:
-    def __init__(self, name, id):
+class ProtocolFeature:
+    def __init__(self, protocol, name, id):
+        self.protocol = protocol
         self.name = name
         self.id = id
         self.__events = {}
 
     def addEvent(self, name, id):
-        event = ProtocolEvent(name, id)
+        # Check if no other event have the same identifier
+        for event in self.__events.values():
+            if event.id==id:
+                raise ProtocolException( \
+                    "Events %s.%s and %s.%s have the same identifier (%s)." \
+                    % (self.name, event.name, self.name, name, id))
+
+        # Add the new event 
+        event = ProtocolEvent(self, name, id)
         self.__events[name] = event
         return event
 
+    def getEvent(self, event):
+        if not self.__events.has_key(event):
+            raise ProtocolException( \
+                "The protocol %s has no event %s.%s(...)." 
+                % (self.protocol.name, self.name, event))
+        return self.__events[event]
+
     def __str__(self):
         first = True
         out = ""
-        for event_name, event in self.__events.items():
+        for event in self.__events.values():
             if first:
                 first = False
             else:
@@ -56,46 +84,64 @@
         return out
 
 class Protocol:
-    def __init__(self, version):
-        self.__funcs = {}
+    def __init__(self, name, version):
+        self.name = name
         self.version = version
+        self.__features = {}
 
-    def addFunc(self, name, id):
-        func = ProtocolFunc(name, id)
-        self.__funcs[name] = func
-        return func
+    def addFeature(self, name, id):
+        # Check if no other feature have the same identifier
+        for feature in self.__features.values():
+            if feature.id==id:
+                raise ProtocolException( \
+                    "Features %s and %s have the same identifier (%s)." \
+                    % (feature.name, name, id))
 
+        # Add the new feature
+        feature = ProtocolFeature(self, name, id)
+        self.__features[name] = feature
+        return feature
+
+    def getFeature(self, feature):
+        if not self.__features.has_key(feature):
+            raise ProtocolException( \
+                "The protocol %s has no feature %s." \
+                % (self.name, feature))
+        return self.__features[feature]
+
     def __str__(self):
         out = ""
         first = True
-        for func_name, func in self.__funcs.items():
+        for feature in self.__features.values():
             if first:
                 first = False
             else:
                 out = out + "\n"
-            out = out + "[ %s ]\n" % func.name
-            out = out + str(func)
+            out = out + "[ %s ]\n" % feature.name
+            out = out + str(feature)
         return out
  
 def loadProtocol(filename):
     doc = xml.dom.minidom.parse(filename)
     protocol = doc.documentElement
-    p = Protocol(protocol.getAttribute("version"))
-    funcs = protocol.getElementsByTagName("func")
-    for func in funcs:
-        f = p.addFunc( \
-            func.getAttribute("name"),
-            func.getAttribute("id"))
-        events = func.getElementsByTagName("event")
+    p = Protocol( \
+        protocol.getAttribute("name"),
+        protocol.getAttribute("version"))
+    features = protocol.getElementsByTagName("feature")
+    for feature in features:
+        f = p.addFeature( \
+            feature.getAttribute("name"),
+            int(feature.getAttribute("id")))
+        events = feature.getElementsByTagName("event")
         for event in events:
             e = f.addEvent( \
                 event.getAttribute("name"),
-                event.getAttribute("id"))
-            params = func.getElementsByTagName("param")
+                int(event.getAttribute("id")))
+            params = event.getElementsByTagName("param")
             for param in params:
                 e.addParam( \
                     param.getAttribute("name"),
-                    param.getAttribute("id"))
+                    param.getAttribute("type"))
     print "-- Protocol --"                
     print p
     print "-- Protocol end --"                

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-14 04:13:03 UTC (rev 149)
+++ happyboom/trunk/server/client_manager.py	2005-09-14 04:16:04 UTC (rev 150)
@@ -1,5 +1,5 @@
 from happyboom.net import io, io_udp, io_tcp, net_buffer
-import thread, traceback
+import thread, traceback, time
 
 class ClientManager(object):
     def __init__(self, arg): 

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-14 04:13:03 UTC (rev 149)
+++ happyboom/trunk/server/gateway.py	2005-09-14 04:16:04 UTC (rev 150)
@@ -1,8 +1,9 @@
-from happyboom.common import packer
+from happyboom.common import packer 
 from happyboom.server.agent import Agent
 from pysma import Kernel, DummyScheduler
-from happyboom.common.protocol import loadProtocol
+from happyboom.common.protocol import loadProtocol, ProtocolException
 from happyboom.net.io import Packet
+import struct
 
 class Gateway(Agent):
     def __init__(self, protocol, client_manager, arg):
@@ -21,17 +22,23 @@
     server = property(None, __setServer)
 
 
-    # Create a network packet for the event func.event(args) where
-    # args is a tuple
-    def createMsgTuple(self, func, event, args):
-        data = packer.pack(func, event, args)
+    # Create a network packet for the event feature.event(args)
+    def createMsg(self, feature, event, *args):
+        f = self.__protocol.getFeature(feature)
+        e = f.getEvent(event)
+        types = e.getParamsType()
+        if len(args) != len(types):
+            raise ProtocolException( \
+                "Wrong parameter count (%u) for the event %s." \
+                % (len(args), e))
+        for i in range(len(args)):
+            if not packer.checkType(types[i], args[i]):
+                raise ProtocolException( \
+                    "Parameter %u of event %s should be of type %s (and not %s)." \
+                    % (i, event, types[i], type(args[i])))
+        data = packer.pack(f.id, e.id, types, args)
         return Packet(data)
             
-    # Create a network packet for the event func.event(args), see
-    # L{self.createMsgTuple}
-    def createMsg(self, func, event, *args):
-        return self.createMsgTuple(func, event, args)
-
     def start(self):
         self.__client_manager.start()
         Kernel.instance.addAgent(self)
@@ -53,9 +60,9 @@
         else:
             self.sendNetMsg("agent_manager", "Text", txt)
 
-    def sendNetMsg(self, func, event, *args):
-        packet = self.createMsgTuple(func, type, args)
-        clients = self.__client_manager.supported_features.get(func, ())
+    def sendNetMsg(self, feature, event, *args):
+        packet = self.createMsg(feature, event, *args)
+        clients = self.__client_manager.supported_features.get(feature, ())
         for client in clients:
             client.sendPacket(packet)
 



From haypo at berlios.de  Wed Sep 14 06:17:33 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 06:17:33 +0200
Subject: [Happyboom-svn] r151 - in boomboom: . server server/agents
Message-ID: <200509140417.j8E4HXX9006446@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 06:17:31 +0200 (Wed, 14 Sep 2005)
New Revision: 151

Modified:
   boomboom/protocol.xml
   boomboom/server/agents/character.py
   boomboom/server/agents/game.py
   boomboom/server/agents/projectile.py
   boomboom/server/agents/weapon.py
   boomboom/server/bb_server.py
Log:
Update BoomBoom protocol and agents send events to network.


Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-14 04:16:04 UTC (rev 150)
+++ boomboom/protocol.xml	2005-09-14 04:17:31 UTC (rev 151)
@@ -1,14 +1,34 @@
 <?xml version="1.0"?>
-<protocol game="BoomBoom" version="0.2">
-  <func name="game" id="1">
+<protocol name="BoomBoom" version="0.2">
+  <feature name="game" id="1">
     <event name="start" id="1" />
     <event name="stop" id="2" />
-  </func>
-  <func name="character" id="4">
+    <event name="setActiveCharacter" id="3">
+      <param type="int" name="player" />
+    </event>
+    <event name="nextTurn" id="4" />
+  </feature>
+  
+  <feature name="character" id="2">
     <event name="move" id="1">
-      <param name="id" type="int" />
-      <param name="x" type="int" />
-      <param name="y" type="int" />
+      <param type="int" name="id" />
+      <param type="int" name="x" />
+      <param type="int"  name="y"/>
     </event>
-  </func>
+  </feature>
+  
+  <feature name="projectile" id="3">
+    <event name="activate" id="1">
+      <param type="int" name="on" />
+    </event>
+  </feature>
+  
+  <feature name="weapon" id="4">
+    <event name="setAngle" id="1">
+      <param type="int" name="angle" />
+    </event>
+    <event name="setStrength" id="2">
+      <param type="int" name="angle" />
+    </event>
+  </feature>
 </protocol>

Modified: boomboom/server/agents/character.py
===================================================================
--- boomboom/server/agents/character.py	2005-09-14 04:16:04 UTC (rev 150)
+++ boomboom/server/agents/character.py	2005-09-14 04:17:31 UTC (rev 151)
@@ -16,7 +16,7 @@
         self.requestActions("game")
         self.requestActions("network")
         self.sendBroadcast(Message("character_search_place", (self.x, self.width, self.height)), "world")
-        self.sendBroadcast(Message("new_character", (self.id, self.team)), "game")
+        self.sendBroadcast(Message("new_character", (self,)), "game")
         self.sendBroadcast(Message("new_item", (self.type, self.id)), "network")
 
     def move(self, x, y, force=False):

Modified: boomboom/server/agents/game.py
===================================================================
--- boomboom/server/agents/game.py	2005-09-14 04:16:04 UTC (rev 150)
+++ boomboom/server/agents/game.py	2005-09-14 04:17:31 UTC (rev 151)
@@ -17,30 +17,32 @@
 
     def msg_new_character(self, character):
         self.characters.append(character)
-        if self.current == None: self.current = 0 
+        if self.current == None:
+            self.setCurrent(0)
 
     def sync(self):
         self.sendBroadcast(Message("game_current_character", self.current), "network")
 
-    def incCharacter(self):
-        tpos = (self.next_team_pos + 1) % 2
-        cpos = (self.next_char_pos[self.teams[tpos]] + 1) % len(self.characters[self.teams[tpos]])
-        self.sendNextCharacter(cpos, tpos)
+    def setCurrent(self, current):
+        self.current = current
+        self.sendNetMsg("game", "setActiveCharacter", current)
 
+    def nextCharacter(self):
+        new = (self.current + 1) % len(self.characters)
+        self.setCurrent(new)
+
     def nextTurn(self):
         self.send("next_turn")
-        self.sendNetMsg("game", "next_turn")
-        self.sendNetMsg("game", "active_character", \
-            "int", self.current)
+        self.sendNetMsg("game", "nextTurn")
+        self.sendNetMsg("game", "setActiveCharacter", self.current)
 
     def msg_world_collision(self, x, y):
         self.nextTurn()
-        self.incCharacter()
+        self.nextCharacter()
         
     def msg_start(self):
         self.launchGame()
 
     def launchGame(self):    
-        self.sendNextCharacter(0, 0)
+        self.setCurrent(self.current)
         self.nextTurn()
-        self.incCharacter()

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-14 04:16:04 UTC (rev 150)
+++ boomboom/server/agents/projectile.py	2005-09-14 04:17:31 UTC (rev 151)
@@ -43,6 +43,7 @@
     def setActive(self, active):
         self.active = active
         self.sendBBMessage("activate", active)
+        self.sendNetMsg("projectile", "activate", 0) 
 
     def shoot(self):
         if self.weapon_angle==None: return
@@ -60,6 +61,7 @@
         self.x = x
         self.y = y
         self.sendBBMessage("move", x, y)
+        self.sendNetMsg("projectile", "move", x, y)
 
     def live(self):
         Agent.live(self)

Modified: boomboom/server/agents/weapon.py
===================================================================
--- boomboom/server/agents/weapon.py	2005-09-14 04:16:04 UTC (rev 150)
+++ boomboom/server/agents/weapon.py	2005-09-14 04:17:31 UTC (rev 151)
@@ -41,12 +41,14 @@
         elif 80 < angle: angle = 80
         self.angle = angle 
         self.send("angle", angle)
+        self.sendNetMsg("weapon", "setAngle", angle)
 
     def updateStrength(self, strength):
         if strength < 10: strength = 10
         elif 100 < strength: strength = 100
         self.strength = strength
         self.send("strength", strength)
+        self.sendNetMsg("weapon", "setStrength", strength)
 
     def sync(self):
         self.updateStrength(self.strength)

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-14 04:16:04 UTC (rev 150)
+++ boomboom/server/bb_server.py	2005-09-14 04:17:31 UTC (rev 151)
@@ -33,29 +33,10 @@
         if self._debug: print "Next character : %s,%s" %(char, team)
         self.nextChar = char
                         
-    def msg_game_next_turn(self):
-        if self._debug: print "Next turn : %s" %self.nextChar
-        
     def msg_game_collision(self, x, y):
         if self._debug: print "Hit ground : %s,%s" %(x, y)
         self.sendNetMsg("projectile", "hit_ground")
     
-    def msg_projectile_move(self, x, y):
-        if self._debug: print "Projectile move : %s,%s" %(x, y)
-        self.sendNetMsg("projectile", "move", "%i,%i" %(x,y), True)
-        
-    def msg_projectile_activate(self, flag):
-        if self._debug: print "Projectile activate : %s" %flag
-        self.sendNetMsg("projectile", "activate", "%u" %(flag))
-        
-    def msg_weapon_angle(self, a):
-        if self._debug: print "Weapon angle : %s" %a
-        self.sendNetMsg("weapon", "angle", a)
-        
-    def msg_weapon_strength(self, s):
-        if self._debug: print "Weapon strength : %s" %s
-        self.sendNetMsg("weapon", "force", s)
-        
     def msg_world_create(self, m):
         if self._debug: print "World create : %s" %m
         self.sendNetMsg("world", "create", m)



From haypo at berlios.de  Wed Sep 14 07:06:00 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 07:06:00 +0200
Subject: [Happyboom-svn] r152 - in happyboom/trunk: common net/io net/io_tcp net/io_udp server
Message-ID: <200509140506.j8E560IK008569@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 07:05:49 +0200 (Wed, 14 Sep 2005)
New Revision: 152

Modified:
   happyboom/trunk/common/log.py
   happyboom/trunk/common/protocol.py
   happyboom/trunk/net/io/base_io.py
   happyboom/trunk/net/io/io_client.py
   happyboom/trunk/net/io/packet.py
   happyboom/trunk/net/io_tcp/server_waiter.py
   happyboom/trunk/net/io_tcp/tcp.py
   happyboom/trunk/net/io_tcp/tcp_client.py
   happyboom/trunk/net/io_udp/udp.py
   happyboom/trunk/net/io_udp/udp_client.py
   happyboom/trunk/net/io_udp/udp_ping.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/base_server.py
   happyboom/trunk/server/client_manager.py
Log:
Replace all print by log.(info|warning|error).


Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/common/log.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -71,7 +71,7 @@
         """
         self.new_message(Log.LOG_INFO, str)
 
-    def warn(self, str):
+    def warning(self, str):
         """
         New warning message.
         @type str: C{str}

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/common/protocol.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -142,7 +142,4 @@
                 e.addParam( \
                     param.getAttribute("name"),
                     param.getAttribute("type"))
-    print "-- Protocol --"                
-    print p
-    print "-- Protocol end --"                
     return p

Modified: happyboom/trunk/net/io/base_io.py
===================================================================
--- happyboom/trunk/net/io/base_io.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io/base_io.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -99,6 +99,9 @@
         """ Stop the IO (close connections). """
         pass
 
+    def __str__(self):
+        return self.__name
+
     #--- Private functions ------------------------------------------------------
 
     def __getName(self):

Modified: happyboom/trunk/net/io/io_client.py
===================================================================
--- happyboom/trunk/net/io/io_client.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io/io_client.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -39,6 +39,9 @@
         self.connected = False
         self.io.disconnectClient(self)
 
+    def __str__(self):
+        return self.name
+
     def __getAddr(self):
         return self.__addr
     def __getHost(self):

Modified: happyboom/trunk/net/io/packet.py
===================================================================
--- happyboom/trunk/net/io/packet.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io/packet.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -1,10 +1,14 @@
-"""A network packet. It can have differents types :
+"""
+A network packet. It can have differents types :
 1. Data
 2. Ping
 3. Pong
 4. Ack
 
-Ping, pong and ack(nowledge) are only used on transport layer."""
+Ping, pong and ack(nowledge) are only used on transport layer.
+"""
+
+from happyboom.common.log import log
 import time
 import struct
 
@@ -99,7 +103,7 @@
             format = "!I"
             size = struct.calcsize(format)
             if len(binary_data) <  size:
-                print "Taille du paquet (%s) incorrect !" % (binary_data)
+                log.warning("Wrong network packet size from %s!" % (self.recv_from)
                 return None
             data = struct.unpack(format, binary_data[:size])
             data_len = data[0]
@@ -109,7 +113,7 @@
             format = "!BBII"
             size = struct.calcsize(format)
             if len(binary_data) <  size:
-                print "Taille du paquet (%s) incorrect !" % (binary_data)
+                log.warning("Wrong network packet size from %s!" % (self.recv_from)
                 return None
             data = struct.unpack(format, binary_data[:size])
             self.type = data[0]
@@ -123,7 +127,7 @@
             format = "!%us" % (data_len)
             size = struct.calcsize(format)
             if len(binary_data) < size:
-                print "Taille du paquet (%s) incorrect !" % (binary_data)
+                log.warning("Wrong network packet size from %s!" % (self.recv_from)
                 return None
             data = struct.unpack(format, binary_data[:size]) 
             self.__data = data[0] 

Modified: happyboom/trunk/net/io_tcp/server_waiter.py
===================================================================
--- happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -2,6 +2,8 @@
 import thread
 import traceback
 from tcp_client import TCP_Client
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
 
 class NetworkServerWaiter(object):
     def __init__(self, server):
@@ -24,22 +26,21 @@
             self.__running = True
             self.start(port, max_connection)
         except Exception, msg:
-            print "NETWORK SERVER EXCEPTION!"
-            print "ERROR MSG: %s" % (msg)
-            traceback.print_exc()
+            log.error("EXCEPTION IN TCP SERVER WAITER!\n%s\n%s" \
+                % (msg, getBacktrace())
         self.__running = False 
         
     def clientConnect(self, client):
         if self.__server.debug:
-            print "Client %s enter server %s." \
-                % (client.name, self.__server.name)
+            log.info("Client %s enter server %s." \
+                % (client.name, self.__server.name))
         self.__nb_clients_sema.acquire()
         self.__nb_clients = self.__nb_clients + 1
         self.__nb_clients_sema.release()
         self.__server.clientConnect (client)
 
     def clientDisconnect(self, client):
-        if self.__server.debug: print "New client : %s" % (client.getName())
+        if self.__server.debug: log.info("New client : %s" % (client.getName()))
         self.__nb_clients_sema.acquire()
         self.__nb_clients = self.__nb_clients - 1
         self.__nb_clients_sema.release()
@@ -53,9 +54,9 @@
             raise
         if self.__max_clients <= self.getNbClients():
             if self.__server.debug:
-                print "Client %s refused on server %s (too many connection, %u/%u)." \
-                    % (addr, self.__server.name, \
-                       self.getNbClients(), self.__max_clients)
+                log.info( \
+                    "Client %s refused on server %s (too many connection, %u/%u)." \
+                    % (addr, self.__server.name, self.getNbClients(), self.__max_clients))
             conn.close()
             return None
         return TCP_Client(self.__server, addr, socket=conn)
@@ -64,21 +65,21 @@
         self.__max_clients = max_connection
         self.__port = port
         if self.__server.debug: 
-            print "Start %s on port %u." \
-                % (self.__server.name, port)
+            log.info("Start %s on port %u." \
+                % (self.__server.name, port))
         self.__socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         try:
             self.__socket.bind((self.__host, self.__port))
             self.__socket.listen(max_connection)
         except socket.error, err:
             if self.__server.debug:
-                print "Binding error for %s." % (self.__server.name)
+                log.error("Binding error for %s." % (self.__server.name))
             if self.__server.on_binding_error != None:
                 self.__server.on_binding_error (self.__server)
             return
         if self.__server.debug: 
-            print "Server %s is listening (max=%u clients)." \
-                % (self.__server.name, max_connection)
+            log.info("Server %s is listening (max=%u clients)." \
+                % (self.__server.name, max_connection))
         self.__listening_sema.acquire()
         self.__listening = True 
         self.__listening_sema.release()

Modified: happyboom/trunk/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io_tcp/tcp.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -9,6 +9,8 @@
 from tcp_client import TCP_Client
 from net import io
 from server_waiter import NetworkServerWaiter
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
 
 class IO_TCP(io.BaseIO):
     """
@@ -53,18 +55,18 @@
         self.__addr = (host, port,)
         if self.__is_server:
             if self.verbose:
-                print "Run server at %s:%u (tcp)" % (self.host, self.port)
+                log.info("Run server at %s:%u (tcp)" % (self.host, self.port))
             thread.start_new_thread( self.__waiter.run_thread, (port,max_connection,))
         else:
             if self.verbose:
-                print "Connect to server %s:%u" % (self.host, self.port)            
+                log.info("Connect to server %s:%u" % (self.host, self.port))
             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
             try:
                 s.connect(self.__addr)
             except socket.error, err:
                 if err[0]==111:
                     if self.verbose:
-                        print "Fail to connect to server %s:%u" % (self.host, self.port)            
+                        log.warning("Fail to connect to server %s:%u" % (self.host, self.port))
                     if self.on_connection_fails:
                         self.on_connection_fails()
                     return
@@ -97,7 +99,7 @@
         if  self.__clients.has_key(client.addr): del self.__clients[client.addr]
         self.__clients_sema.release()
         if self.verbose:
-            print "Disconnect client %s:%u" % (client.host, client.port)
+            log.info("Disconnect client %s." % client)
         if self.on_client_disconnect != None: self.on_client_disconnect (client)
         if self.__server == client: self.disconnect()
     
@@ -139,9 +141,11 @@
             packet.recv_from = client
             data = packet.unpack(data)
             if not packet.isValid():
-                print "Bad data packet (%s) from %s !" % (data, client.name)
+                if self.debug:
+                    log.warning("Received buggy network packet from %s!" % client)
                 return
-            if self.debug: print "Received %s:%u => \"%s\"" % (client.host, client.port, packet.data)
+            if self.debug:
+                log.info("Received %s:%u => \"%s\"" % (client.host, client.port, packet.data))
             if self.on_new_packet: self.on_new_packet(packet)
     
     def run_thread(self):
@@ -151,9 +155,9 @@
                 self.live()                
                 time.sleep(self.thread_sleep)
         except Exception, msg:
-            print "EXCEPTION DANS LE THREAD IO :"
-            print msg
-            traceback.print_exc()
+            log.error( \
+                "EXCEPTION DANS LE THREAD IO :\n%s\n%s"
+                % (msg, getBacktrace()))
         self.stop()
 
     def stop(self):
@@ -199,9 +203,8 @@
         if self.on_client_connect != None: self.on_client_connect (client)
         
     def clientDisconnect(self, client):
-        if self.debug:
-            print "Client %s leave server %s." \
-                % (client.name, self.name)
+        if self.verbose:
+            log.info("Client %s leave server %s." % (client, self))
         self.__clients_sema.acquire()
         self.__clients.remove(client)
         self.__clients_sema.release()

Modified: happyboom/trunk/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -1,4 +1,5 @@
 from net import io
+from happyboom.common.log import log
 import socket
 
 class TCP_Client(io.IO_Client):
@@ -58,7 +59,6 @@
             if err[0] in (32, 104,):
                 self.disconnect()
                 return None
-            print err
             raise
         return self.__processRecvData(data)
 
@@ -71,7 +71,7 @@
         # If no data, connection is lost
         if len(data)==0:
             if self.io.verbose:
-                print "Client %s lost connection with server!" % (self.name)
+                log.warning("Client %s lost connection with server!" % self)
             self.disconnect()
             return None
 

Modified: happyboom/trunk/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/net/io_udp/udp.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io_udp/udp.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -7,6 +7,8 @@
 import struct
 from net import io
 from udp_client import UDP_Client
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
 
 class IO_UDP(io.BaseIO):
     """ IO for UDP transport.
@@ -64,11 +66,11 @@
         self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
         if self.__is_server:
             if self.verbose:
-                print "Run server at %s:%u (udp)" % ("", self.port)
+                log.info("Run server on port %u (udp)." % self.port)
             self.__socket.bind(("",port,))
         else:
             if self.verbose:
-                print "Connect to server %s:%u" % (self.host, self.port)
+                log.info("Connect to server %s:%u." % (self.host, self.port))
             self.__server = UDP_Client(self, self.__addr)
             self.__server.name = "server"
             self.__server.send_ping = True
@@ -103,7 +105,7 @@
         if self.__clients.has_key(client.addr): del self.__clients[client.addr]
         self.__clients_sema.release()
         if self.verbose:
-            print "Disconnect client %s" % (client.name)
+            log.info("Disconnect client %s." % client)
         if self.on_client_disconnect != None: self.on_client_disconnect(client)
     
     def send(self, packet, to=None):
@@ -148,7 +150,8 @@
         @type data: C{str}
         @type client: C{L{IO_Client<io.IO_Client>}}
         """        
-        if self.debug: print "Send data %s to %s (without ack)" % (data, client.name)
+        if self.debug:
+            log.info("Send data %s to %s (without ack)" % (data, client))
         self.__socket.sendto(data, client.addr)    
         
         # Call user event if needed
@@ -160,7 +163,8 @@
         @type client: C{L{IO_Client<io.IO_Client>}}
         @type need_ack: C{bool}
         """
-        if self.debug: print "Send packet %s to %s" % (packet.toStr(), client.name)
+        if self.debug:
+            log.info("Send packet %s to %s" % (packet.toStr(), client))
         self.__socket.sendto(data, client.addr)
 
         # If the packet need an ack, add it to the list
@@ -208,12 +212,12 @@
         if not client.addr in self.__clients: return
         client = self.__clients[client.addr]
         if self.verbose:
-            print "Lost connection with client %s !" % (client.name)
+            log.warning("Lost connection with client %s !" % client)
         self.disconnectClient(client)
     
     def lostConnection(self):
         if self.verbose:
-            print "Lost connection to %s:%u!" % (self.host, self.port)
+            log.warning("Lost connection to %s:%u!" % (self.host, self.port))
         if self.__socket_open:
             self.__socket.close()
             self.__socket_open = False
@@ -227,9 +231,9 @@
                 self.live()                
                 time.sleep(self.thread_sleep)
         except Exception, msg:
-            print "EXCEPTION DANS LE THREAD IO :"
-            print msg
-            traceback.print_exc()
+            log.error( \
+                "EXCEPTION IN UDP SERVER:\n%s\n%s" \
+                msg, getBacktrace())
             self.stop()
 
     def stop(self):
@@ -248,7 +252,7 @@
                 client = UDP_Client(self, addr)
                 self.__clients[addr] = client
                 self.__clients_sema.release()
-                if self.verbose: print "New client : %s:%u" % (addr[0], addr[1])
+                if self.verbose: log.info("New client: %s:%u." % (addr[0], addr[1]))
                 client.send_ping = True
                 if self.on_client_connect != None: self.on_client_connect(client)
             else:
@@ -258,7 +262,7 @@
             # Drop packets which doesn't come from server
             if self.__server.addr != addr:
                 if self.debug:
-                    print "Drop packet from %s:%u (it isn't the server address)" % (addr[0], addr[1])
+                    log.warning("Drop packet from %s:%u (it isn't the server address)." % (addr[0], addr[1]))
                 return None
             client = self.__server
     
@@ -269,7 +273,8 @@
         packet = io.Packet()
         packet.unpack(data)
         if not packet.isValid():
-            if self.debug: print "Drop invalid packet (%s) from %s" % (data, client.name)            
+            if self.debug:
+                log.warning("Drop invalid network packet from %s" % (data, client))
             return None
         
         # Return packet
@@ -280,7 +285,7 @@
         client = packet.recv_from
 
         if self.debug:
-            print "Received packet %s from %s:%u" % (packet.toStr(), client.host, client.port)
+            log.info("Received packet %s from %s:%u" % (packet.toStr(), client.host, client.port))
         
         # Send an ack if needed
         if not packet.skippable: self.__sendAck(packet)
@@ -299,7 +304,7 @@
         # This packet is already received ? Drop it!
         if client.alreadyReceived(packet.id):
             if self.debug:
-                print "Drop packet %u (already received)" % (packet.id)
+                log.warning("Drop packet %u (already received)" % packet.id))
             return None    
             
         client.receivePacket(packet)
@@ -315,7 +320,7 @@
         ack = io.Packet(skippable=True)
         ack.type = io.Packet.PACKET_ACK
         ack.writeStr( struct.pack("!I", packet.id) )
-        #if self.debug: print "Send ACK %u." % (ack.id)
+        #if self.debug: log.info("Send ACK %u." % ack.id)
         packet.recv_from.send(ack)
 
     def __processNewPacket(self, packet):
@@ -323,7 +328,7 @@
         @type packet: C{L{Packet<io.Packet>}}
         """
         if self.verbose:
-            print "New udp message : %s" % (packet.toStr())
+            log.info("New udp message : %s" % packet.toStr())
         if self.on_new_packet != None: self.on_new_packet(packet)        
 
     def __getPort(self):

Modified: happyboom/trunk/net/io_udp/udp_client.py
===================================================================
--- happyboom/trunk/net/io_udp/udp_client.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io_udp/udp_client.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -2,6 +2,7 @@
 import thread
 import time
 import struct
+from happyboom.common.log import log
 from udp_ping import UDP_Pinger 
 
 class UDP_Client(io.IO_Client):
@@ -86,7 +87,7 @@
         # Debug message
         if self.io.debug:
             t = time.time() - self.__waitAck[id].creation
-            print "Ack %u received (time=%.1f ms)" % (id, t*1000)
+            log.info("Ack %u received (time=%.1f ms)" % (id, t*1000))
 
         # The packet don't need ack anymore
         del self.__waitAck[id]
@@ -127,8 +128,8 @@
         for id,timeout in receivedCopy.items():
             if timeout < time.time():
                 if self.io.debug:
-                    print "Supprime ancien paquet %u de %s:%u (timeout)" \
-                        % (id, self.host, self.port)
+                    log.info("Remove old packet %u from %s:%u (clear cache)." \
+                        % (id, self.host, self.port))
                 self.__received_sema.acquire()
                 del self.__received[id]
                 self.__received_sema.release()

Modified: happyboom/trunk/net/io_udp/udp_ping.py
===================================================================
--- happyboom/trunk/net/io_udp/udp_ping.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/net/io_udp/udp_ping.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -1,6 +1,7 @@
 import time
 import struct
 from net import io
+from happyboom.common.log import log
 
 class UDP_Ping:
     """ One UDP ping.
@@ -69,9 +70,9 @@
         @parameter id: The ping id.
         @type id: C{int}
         """
-        print "Ping timeout."
-#        print "Disconnect client %s:%u (ping timeout)." \
-#            % (self.client.host, self.client.port)
+        log.error("UDP ping timeout.")
+#        log.error("Disconnect client %s:%u (ping timeout)." \
+#            % (self.client.host, self.client.port))
 #        self.client.disconnect()
 
     def live(self):
@@ -113,7 +114,7 @@
         id = self.__getPingId(packet.data)
         if id == None:
             if self.debug:
-                print "Wrong ping packet (%s)!" % (packet.toStr())
+                log.warning("Received invalid udp ping packet!")
             return
 
         # Received too late ?

Modified: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/server/agent.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -1,4 +1,5 @@
 from pysma import ActionAgent, ActionMessage
+from happyboom.common.log import log
 
 class Agent(ActionAgent):
     """
@@ -22,12 +23,11 @@
         self.sendBroadcastMessage(message, "%s_listener" %self.type)
 
     def sendNetMsg(self, func, event, *args):
-        print args
         self._gateway.sendNetMsg(func, event, *args)
 
     def messageReceived(self, msg):
         if self.__debug:
-            print "Unhandled message : %s -- %s" %(type(self), msg)
+            log.warning("Unhandled message : %s -- %s" %(type(self), msg))
 
 class Message(ActionMessage):
     def __init__(self, action, arg, kw={}):

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/server/base_server.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -1,5 +1,6 @@
 # TODO: Check if it's always possible to send skippable packets
 
+from happyboom.common.log import log
 from happyboom.server.gateway import Gateway
 from happyboom.server.client_manager import ClientManager
 import random, thread, time
@@ -20,9 +21,9 @@
         self.gateway.born()
         
     def start(self):
-        if self.__verbose: print "[*] Starting server..."
+        if self.__verbose: log.info("[*] Starting server...")
         self.__gateway.start()
-        print "[*] Server started"
+        log.info("[*] Server started")
         
         self.__stoplock.acquire()
         running = not self.__stopped
@@ -41,6 +42,6 @@
             return
         self.__stopped = True
         self.__stoplock.release()
-        print "[*] Stopping server..."
+        if self.__verbose: log.info("[*] Stopping server...")
         self.__gateway.stop()
-        if self.__verbose: print "[*] Server stopped"
+        log.info("[*] Server stopped")

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-14 04:17:31 UTC (rev 151)
+++ happyboom/trunk/server/client_manager.py	2005-09-14 05:05:49 UTC (rev 152)
@@ -1,5 +1,7 @@
 from happyboom.net import io, io_udp, io_tcp, net_buffer
-import thread, traceback, time
+import thread, time
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
 
 class ClientManager(object):
     def __init__(self, arg): 
@@ -28,7 +30,7 @@
 #        processInputs()
 
     def start(self):
-        if self.__verbose: print "[*] Starting server"
+        if self.__verbose: log.info("[*] Starting server")
         self.__io.name = "server"
         self.__io.on_client_connect = self.openClient
         self.__io.on_client_disconnect = self.closeClient
@@ -65,10 +67,9 @@
         try:
             func(client)
         except Exception, msg:
-            print "EXCEPTION WHEN A CLIENT TRY TO CONNECT :"
-            print msg
-            print "--"
-            traceback.print_exc()
+            log.error( \
+                "EXCEPTION WHEN A CLIENT TRY TO CONNECT :\n%s\n%s" \
+                % (msg, getBacktrace()))
             self.stop()
 
     # Function which should be called in a thread
@@ -79,10 +80,9 @@
                 self.__io.live()                
                 time.sleep(0.001)
         except Exception, msg:
-            print "EXCEPTION IN IO THREAD :"
-            print msg
-            print "--"            
-            traceback.print_exc()
+            log.error( \
+                "EXCEPTION IN IO THREAD :\n%s\n%s" \
+                % (msg, getBacktrace()))
             self.stop()
 
     def generateSignature(self, client):
@@ -91,7 +91,7 @@
         return r
 
     def __do_openClient(self, io_client):
-        if self.__verbose: print "[*] Display %s try to connect ..." % (client.name)
+        log.info("[*] Display %s try to connect ..." % (client.name))
         client = ClientSocket(io_client, self)
         
 #        self.__buffer.clear(client.addr)
@@ -125,7 +125,7 @@
 
         txt = "Welcome to new (display) client : %s" % (client.name)
         self.__gateway.sendText(txt)
-        if self.__verbose: print "[*] Display %s connected" % (client.name)
+        log.info("[*] Display %s connected" % (client.name))
         self.sendBBMessage("sync")
 
     def __getSupportedFeatures(self): return self.__supported_features



From haypo at berlios.de  Wed Sep 14 07:10:30 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 07:10:30 +0200
Subject: [Happyboom-svn] r153 - in happyboom/trunk/net: io io_tcp io_udp
Message-ID: <200509140510.j8E5AUVX011437@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 07:10:10 +0200 (Wed, 14 Sep 2005)
New Revision: 153

Modified:
   happyboom/trunk/net/io/packet.py
   happyboom/trunk/net/io_tcp/server_waiter.py
   happyboom/trunk/net/io_udp/udp.py
Log:
Fix syntax bugs ...


Modified: happyboom/trunk/net/io/packet.py
===================================================================
--- happyboom/trunk/net/io/packet.py	2005-09-14 05:05:49 UTC (rev 152)
+++ happyboom/trunk/net/io/packet.py	2005-09-14 05:10:10 UTC (rev 153)
@@ -103,7 +103,7 @@
             format = "!I"
             size = struct.calcsize(format)
             if len(binary_data) <  size:
-                log.warning("Wrong network packet size from %s!" % (self.recv_from)
+                log.warning("Wrong network packet size from %s!" % self.recv_from)
                 return None
             data = struct.unpack(format, binary_data[:size])
             data_len = data[0]
@@ -113,7 +113,7 @@
             format = "!BBII"
             size = struct.calcsize(format)
             if len(binary_data) <  size:
-                log.warning("Wrong network packet size from %s!" % (self.recv_from)
+                log.warning("Wrong network packet size from %s!" % self.recv_from)
                 return None
             data = struct.unpack(format, binary_data[:size])
             self.type = data[0]
@@ -127,7 +127,7 @@
             format = "!%us" % (data_len)
             size = struct.calcsize(format)
             if len(binary_data) < size:
-                log.warning("Wrong network packet size from %s!" % (self.recv_from)
+                log.warning("Wrong network packet size from %s!" % self.recv_from)
                 return None
             data = struct.unpack(format, binary_data[:size]) 
             self.__data = data[0] 

Modified: happyboom/trunk/net/io_tcp/server_waiter.py
===================================================================
--- happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-14 05:05:49 UTC (rev 152)
+++ happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-14 05:10:10 UTC (rev 153)
@@ -27,7 +27,7 @@
             self.start(port, max_connection)
         except Exception, msg:
             log.error("EXCEPTION IN TCP SERVER WAITER!\n%s\n%s" \
-                % (msg, getBacktrace())
+                % (msg, getBacktrace()))
         self.__running = False 
         
     def clientConnect(self, client):

Modified: happyboom/trunk/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/net/io_udp/udp.py	2005-09-14 05:05:49 UTC (rev 152)
+++ happyboom/trunk/net/io_udp/udp.py	2005-09-14 05:10:10 UTC (rev 153)
@@ -233,7 +233,7 @@
         except Exception, msg:
             log.error( \
                 "EXCEPTION IN UDP SERVER:\n%s\n%s" \
-                msg, getBacktrace())
+                % (msg, getBacktrace()))
             self.stop()
 
     def stop(self):
@@ -304,7 +304,7 @@
         # This packet is already received ? Drop it!
         if client.alreadyReceived(packet.id):
             if self.debug:
-                log.warning("Drop packet %u (already received)" % packet.id))
+                log.warning("Drop packet %u (already received)" % packet.id)
             return None    
             
         client.receivePacket(packet)



From haypo at berlios.de  Wed Sep 14 07:13:48 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 07:13:48 +0200
Subject: [Happyboom-svn] r154 - in boomboom: . server server/agents
Message-ID: <200509140513.j8E5Dmuv012581@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 07:13:05 +0200 (Wed, 14 Sep 2005)
New Revision: 154

Modified:
   boomboom/boomboom_server.py
   boomboom/protocol.xml
   boomboom/server/agents/character.py
   boomboom/server/agents/world.py
   boomboom/server/bb_server.py
Log:
Fix some events, and replace some print by log.(info|warning|error).


Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-14 05:10:10 UTC (rev 153)
+++ boomboom/boomboom_server.py	2005-09-14 05:13:05 UTC (rev 154)
@@ -95,7 +95,6 @@
     except KeyboardInterrupt:
         pass
     server.stop()
-    print "Server quit."
 
 def main():
     try:

Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-14 05:10:10 UTC (rev 153)
+++ boomboom/protocol.xml	2005-09-14 05:13:05 UTC (rev 154)
@@ -21,6 +21,7 @@
     <event name="activate" id="1">
       <param type="int" name="on" />
     </event>
+    <event name="hitGround" id="2" />
   </feature>
   
   <feature name="weapon" id="4">

Modified: boomboom/server/agents/character.py
===================================================================
--- boomboom/server/agents/character.py	2005-09-14 05:10:10 UTC (rev 153)
+++ boomboom/server/agents/character.py	2005-09-14 05:13:05 UTC (rev 154)
@@ -26,8 +26,7 @@
         self.sendBroadcast(Message("character_move", ("%u,%i,%i" % (self.id, self.x, self.y),)), "network")
         if self.current:
             self.send("active_coord", self.x, self.y)
-            self.sendNetMsg("character", "move", \
-                "int", self.id, "int", self.x, "int", self.y)
+            self.sendNetMsg("character", "move", self.id, self.x, self.y)
 
     def sync(self):
         self.move(self.x, self.y, force=True)
@@ -35,10 +34,6 @@
     def msg_found_place(self, x, y):
         self.move(x, y, True)
         
-    def msg_game_next_character(self, char, team):
-        if self.id == char:
-            self.next = True
-        
     def msg_game_next_turn(self):
         self.current = self.next
         if self.current:

Modified: boomboom/server/agents/world.py
===================================================================
--- boomboom/server/agents/world.py	2005-09-14 05:10:10 UTC (rev 153)
+++ boomboom/server/agents/world.py	2005-09-14 05:13:05 UTC (rev 154)
@@ -71,6 +71,7 @@
             if len(msg) != 0: msg = msg + ";"
             msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
         self.sendBroadcastMessage(Message("world_create", (msg,)), "network")
+        self.sendNetMsg("world", "create", m)
 
     def msg_character_search_place(self, x0, width, height):
         if x0 < 0:
@@ -90,6 +91,7 @@
     def msg_projectile_move(self, x, y):
         if self.hitGround(x, y):
             self.sendBBMessage("collision", x, y)
+            self.sendNetMsg("projectile", "hitGround")
 
     def msg_network_sync(self):
         self.sync()

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-14 05:10:10 UTC (rev 153)
+++ boomboom/server/bb_server.py	2005-09-14 05:13:05 UTC (rev 154)
@@ -5,6 +5,7 @@
 from pysma import Kernel
 from bb_agent import Message
 from agents import Character, Projectile, Weapon, World, Game
+from happyboom.common.log import log
 
 class Gateway(HBGateway):
     def __init__(self, protocol, manager, arg):
@@ -20,7 +21,7 @@
 
     def start(self):
         HBGateway.start(self)
-        if self._verbose: print "[*] Creating agents"
+        if self._verbose: log.info("[*] Creating agents")
         self.addAgent(Game(self, debug=self._debug))
         self.addAgent(World(self, debug=self._debug))
         self.addAgent(Character(self, 100, 1, debug=self._debug))
@@ -30,29 +31,13 @@
         self.sendBroadcastMessage(Message("start", ()), "game")
                         
     def msg_game_next_character(self, char, team):
-        if self._debug: print "Next character : %s,%s" %(char, team)
+        if self._debug: log.info("Next character : %s,%s" %(char, team))
         self.nextChar = char
                         
-    def msg_game_collision(self, x, y):
-        if self._debug: print "Hit ground : %s,%s" %(x, y)
-        self.sendNetMsg("projectile", "hit_ground")
-    
-    def msg_world_create(self, m):
-        if self._debug: print "World create : %s" %m
-        self.sendNetMsg("world", "create", m)
-        
-    def msg_character_move(self, m):
-        if self._debug: print "Character move : %s" %m
-        self.sendNetMsg("character", "move", m)
-        
     def msg_new_item(self, type, id):
-        if self._debug: print "New item : %s,%s" %(type, id)
+        if self._debug: log.info("New item : %s,%s" %(type, id))
         self.__items.append((type, id))
         
-    def msg_game_current_character(self, char, team):
-        if self._debug: print "Current character : %s,%s" %(char, team)
-        self.sendNetMsg("game", "active_character", char)
-
 class Server(HBServer):
     def __init__(self, protocol, arg):
         manager = ClientManager(arg)



From haypo at berlios.de  Wed Sep 14 07:34:34 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 07:34:34 +0200
Subject: [Happyboom-svn] r155 - boomboom boomboom/server happyboom/trunk/common happyboom/trunk/server
Message-ID: <200509140534.j8E5YYBl025870@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 07:34:27 +0200 (Wed, 14 Sep 2005)
New Revision: 155

Modified:
   boomboom/protocol.xml
   boomboom/server/bb_server.py
   happyboom/trunk/common/log.py
   happyboom/trunk/server/client.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Fix some bugs (server is more stable).


Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-14 05:13:05 UTC (rev 154)
+++ boomboom/protocol.xml	2005-09-14 05:34:27 UTC (rev 155)
@@ -32,4 +32,10 @@
       <param type="int" name="angle" />
     </event>
   </feature>
+  
+  <feature name="chat" id="5">
+    <event name="mesage" id="1">
+      <param type="utf8" name="text" />
+    </event>
+  </feature>
 </protocol>

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-14 05:13:05 UTC (rev 154)
+++ boomboom/server/bb_server.py	2005-09-14 05:34:27 UTC (rev 155)
@@ -42,4 +42,5 @@
     def __init__(self, protocol, arg):
         manager = ClientManager(arg)
         gateway = Gateway(protocol, manager, arg)
+        manager.gateway = gateway
         HBServer.__init__(self, gateway, arg)

Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-14 05:13:05 UTC (rev 154)
+++ happyboom/trunk/common/log.py	2005-09-14 05:34:27 UTC (rev 155)
@@ -38,7 +38,7 @@
         @return: C{str}
         """
         if level==Log.LOG_WARN: return "[warn]"
-        if level==Log.LOG_ERROR: return "[error]"
+        if level==Log.LOG_ERROR: return "[err] "
         return "[info]"
 
     def new_message(self, level, str):
@@ -57,12 +57,12 @@
             self.__buffer[level] = [str]
         else:
             self.__buffer[level].append(str)
-        print str
+        prefix = self.getLevelPrefix(level)            
+        print "%s %s" % (prefix, str)
         if self.__file:
             self.__file.write(u"%s - %s %s\n" \
                 % (time.strftime("%Y-%M-%d %H:%M:%S"),
-                   self.getLevelPrefix(level),
-                   str))
+                   prefix, str))
 
     def info(self, str):
         """

Modified: happyboom/trunk/server/client.py
===================================================================
--- happyboom/trunk/server/client.py	2005-09-14 05:13:05 UTC (rev 154)
+++ happyboom/trunk/server/client.py	2005-09-14 05:34:27 UTC (rev 155)
@@ -1,3 +1,6 @@
+from happyboom.common.protocol import ProtocolException
+from happyboom.common.log import log
+
 class Client:
     """
     High-level class for a client in the server.
@@ -3,12 +6,13 @@
     """
 
-    def __init__(self, io_client, client_manager):
+    def __init__(self, io_client, gateway, client_manager):
         self.__io = io_client
         self.__client_manager = client_manager
+        self.__gateway = gateway
         self.signature = None
 
     # Stop client: close socket.
     def stop(self):
-        self.__io.stop()
+        self.__io.disconnect()
 
     # Read a message from network stack
@@ -23,5 +27,9 @@
 
     # Send a HappyBoom message to the client (see L{sendPacket})
     def sendNetMsg(self, func, event, *args):
-        packet = self.__gateway.createMsgTuple(func, event, args)
+        try:
+            packet = self.__gateway.createMsg(func, event, *args)
+        except ProtocolException, err:
+            log.error(err)
+            return
         self.__io.send(packet)

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-14 05:13:05 UTC (rev 154)
+++ happyboom/trunk/server/client_manager.py	2005-09-14 05:34:27 UTC (rev 155)
@@ -1,7 +1,8 @@
 from happyboom.net import io, io_udp, io_tcp, net_buffer
-import thread, time
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
+from happyboom.server.client import Client
+import thread, time
 
 class ClientManager(object):
     def __init__(self, arg): 
@@ -17,6 +18,7 @@
         self.__supported_features = {}
         self.__clients = []
         self.__clients_sema = thread.allocate_lock()
+        self.gateway = None
         
     def recvClientPacket(self, packet):
         self.__buffer.append(packet.recv_from.addr, packet)
@@ -56,13 +58,15 @@
 
     def closeClient(self, client):
         if self.__verbose:
-            log.info("Client %s disconnected." % client.name)
+            log.info("Client %s disconnected." % client)
         
-        txt = "Client %s (display) leave us." % (client.name)
-        self.__gateway.sendText(txt)
+        txt = "Client %s leave us." % client
+        self.gateway.sendText(txt)
+       
+        # TODO: get client of type Client for the client of type ClientIO to send
+        # him bye
+#        client.sendNetMsg("presentation", "bye", "utf8", u"Lost connection")
         
-        client.sendMsg("presentation", "bye", "utf8", u"Lost connection")
-        
     def __clientChallenge(self, client, func):
         try:
             func(client)
@@ -91,28 +95,28 @@
         return r
 
     def __do_openClient(self, io_client):
-        log.info("[*] Display %s try to connect ..." % (client.name))
-        client = ClientSocket(io_client, self)
+        log.info("[*] Display %s try to connect ..." % io_client)
+        client = Client(io_client, self.gateway, self)
         
 #        self.__buffer.clear(client.addr)
        
         # Check protocol version (max: wait 200ms)
-        answer = self.readClientAnswer(client, 0.200)
-        if answer != self.__gateway.protocol_version:
+        answer = client.read(0.200)
+        if answer != self.gateway.protocol_version:
             # If it isn't the right version, send presention.bye(...)
             txt = u"Sorry, you don't have same protocol version (%s VS %s)" \
-                % (answer, self.__gateway.protocol_version)
-            client.sendMsg("presentation", "bye", "utf8", txt)
+                % (answer, self.gateway.protocol_version)
+            client.sendNetMsg("presentation", "bye", "utf8", txt)
 
             # Wait 0.5s and then disconnect the client
             time.sleep(0.500)
-            client.disconnect()
+            client.stop()
             return
             
         # Send protocol version with "hello()"
         client.signature = self.generateSignature()        
         client.send("presentation", "hello", \
-            "bin", self.__gateway.protocol_version, \
+            "bin", self.gateway.protocol_version, \
             "bin", signature)
          
         # Read features (max: wait 1sec)
@@ -124,7 +128,7 @@
         self.__clients_sema.release() 
 
         txt = "Welcome to new (display) client : %s" % (client.name)
-        self.__gateway.sendText(txt)
+        self.gateway.sendText(txt)
         log.info("[*] Display %s connected" % (client.name))
         self.sendBBMessage("sync")
 

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-14 05:13:05 UTC (rev 154)
+++ happyboom/trunk/server/gateway.py	2005-09-14 05:34:27 UTC (rev 155)
@@ -1,8 +1,9 @@
 from happyboom.common import packer 
 from happyboom.server.agent import Agent
-from pysma import Kernel, DummyScheduler
 from happyboom.common.protocol import loadProtocol, ProtocolException
 from happyboom.net.io import Packet
+from happyboom.common.log import log
+from pysma import Kernel, DummyScheduler
 import struct
 
 class Gateway(Agent):
@@ -56,12 +57,16 @@
 
     def sendText(self, txt, client=None):
         if client != None:
-            client.sendMsg("agent_manager", "Text", txt)
+            client.sendMsg("chat", "message", txt)
         else:
-            self.sendNetMsg("agent_manager", "Text", txt)
+            self.sendNetMsg("chat", "message", txt)
 
     def sendNetMsg(self, feature, event, *args):
-        packet = self.createMsg(feature, event, *args)
+        try:
+            packet = self.createMsg(feature, event, *args)
+        except ProtocolException, err:
+            log.error(err)
+            return
         clients = self.__client_manager.supported_features.get(feature, ())
         for client in clients:
             client.sendPacket(packet)



From dboucard at berlios.de  Wed Sep 14 07:47:53 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 07:47:53 +0200
Subject: [Happyboom-svn] r156 - in happyboom/trunk: common server
Message-ID: <200509140547.j8E5lrqB000610@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 07:47:50 +0200 (Wed, 14 Sep 2005)
New Revision: 156

Modified:
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/protocol.py
   happyboom/trunk/server/gateway.py
Log:
seek by ID in the protocol module


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 05:34:27 UTC (rev 155)
+++ happyboom/trunk/common/packer.py	2005-09-14 05:47:50 UTC (rev 156)
@@ -38,7 +38,7 @@
     """
 
     assert len(types) == len(values), "Lengths of types and args have to be the same."
-    out = struct.pack("!ii", func, event)
+    out = struct.pack("!HH", func, event)
 
     #TODO: Fix this :-)
     for i in range(len(values)):
@@ -70,16 +70,18 @@
     i = struct.calcsize(fmt)
     return (struct.unpack(fmt, data[:i]), data[i:])
 
-def unpack(data):
+def unpack(data, protocol):
     """
     Unpack binary string to arguments.
     """
-    fmt = "!BB"
+    fmt = "!HH"
     i = struct.calcsize(fmt)
-    feat, evt = struct.unpack(fmt, data[:i])
+    feat_id, evt_id = struct.unpack(fmt, data[:i])
     data = data[i:]
     args = []
-    for type in getArgTypes(feat, evt):
+    feat = protocol.getFeature(feat_id)
+    evt = feat.getEvent(evt_id)
+    for type in evt.getParamTypes():
         if type=="int":
             arg, tail = unpackInt(data)
         elif type=="bin":
@@ -88,4 +90,4 @@
             raise PackerException("Wrong argument type: %s" % type)
         args.append(arg)
         data = tail
-    return (feat, evt, args)
\ No newline at end of file
+    return (fea.namet, evt.name, args)
\ No newline at end of file

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-14 05:34:27 UTC (rev 155)
+++ happyboom/trunk/common/protocol.py	2005-09-14 05:47:50 UTC (rev 156)
@@ -27,7 +27,7 @@
         self.__params_array.append(param)
         return param
 
-    def getParamsType(self):
+    def getParamTypes(self):
         types = []
         for param in self.__params_array:
             types.append(param.type)
@@ -50,32 +50,49 @@
         self.protocol = protocol
         self.name = name
         self.id = id
-        self.__events = {}
+        self.__evtnames = {}
+        self.__evtids = {}
 
     def addEvent(self, name, id):
         # Check if no other event have the same identifier
-        for event in self.__events.values():
-            if event.id==id:
-                raise ProtocolException( \
-                    "Events %s.%s and %s.%s have the same identifier (%s)." \
-                    % (self.name, event.name, self.name, name, id))
+        event = self.__evtids.get(id, None)
+        if event != None:
+            raise ProtocolException( \
+                "Events %s.%s and %s.%s have the same identifier (%s)." \
+                % (self.name, event.name, self.name, name, id))
+        # Check if no other event have the same name
+        event = self.__evtnames.get(name, None)
+        if event != None:
+            raise ProtocolException( \
+                "Events %s[%s] and %s[%s] have the same name (%s)." \
+                % (self.name, event.id, self.name, id, name))
 
         # Add the new event 
         event = ProtocolEvent(self, name, id)
-        self.__events[name] = event
+        self.__evtnames[name] = event
+        self.__evtids[id] = event
         return event
 
-    def getEvent(self, event):
-        if not self.__events.has_key(event):
+    def getEvent(self, name):
+        event = self.__evtnames.get(name, None)
+        if event == None:
             raise ProtocolException( \
                 "The protocol %s has no event %s.%s(...)." 
-                % (self.protocol.name, self.name, event))
-        return self.__events[event]
+                % (self.protocol.name, self.name, name))
+        return self.__evtnames[name]
 
+    def __getitem__(self, id):
+        event = self.__evtids.get(id, None)
+        if event == None:
+            raise ProtocolException( \
+                "The protocol %s has no event %s[%s](...)." 
+                % (self.protocol.name, self.name, id))
+        return self.__evtids[id]
+
     def __str__(self):
         first = True
         out = ""
-        for event in self.__events.values():
+        for event in self.__evtnames.values():
             if first:
                 first = False
             else:
@@ -87,32 +104,49 @@
     def __init__(self, name, version):
         self.name = name
         self.version = version
-        self.__features = {}
+        self.__featnames = {}
+        self.__featids = {}
 
     def addFeature(self, name, id):
         # Check if no other feature have the same identifier
-        for feature in self.__features.values():
-            if feature.id==id:
-                raise ProtocolException( \
-                    "Features %s and %s have the same identifier (%s)." \
-                    % (feature.name, name, id))
+        feature = self.__featnames.get(name, None)
+        if feature != None:
+            raise ProtocolException( \
+                "Features %s and %s have the same identifier (%s)." \
+                % (feature.name, name, id))
+        # Check if no other feature have the same name
+        feature = self.__featids.get(id, None)
+        if feature != None:
+            raise ProtocolException( \
+                "Features %s and %s have the same name (%s)." \
+                % (feature.id, id, name))
 
         # Add the new feature
         feature = ProtocolFeature(self, name, id)
-        self.__features[name] = feature
+        self.__featnames[name] = feature
+        self.__featids[id] = feature
         return feature
 
-    def getFeature(self, feature):
-        if not self.__features.has_key(feature):
+    def getFeature(self, name):
+        feature = self.__featnames.get(name, None)
+        if feature == None:
             raise ProtocolException( \
                 "The protocol %s has no feature %s." \
-                % (self.name, feature))
-        return self.__features[feature]
+                % (self.name, name))
+        return feature
 
+    def __getitem__(self, id):
+        feature = self.__featids.get(id, None)
+        if  feature == None:
+            raise ProtocolException( \
+                "The protocol %s has no feature %s." \
+                % (self.name, id))
+        return feature
+        
     def __str__(self):
         out = ""
         first = True
-        for feature in self.__features.values():
+        for feature in self.__featnames.values():
             if first:
                 first = False
             else:

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-14 05:34:27 UTC (rev 155)
+++ happyboom/trunk/server/gateway.py	2005-09-14 05:47:50 UTC (rev 156)
@@ -36,7 +36,7 @@
             if not packer.checkType(types[i], args[i]):
                 raise ProtocolException( \
                     "Parameter %u of event %s should be of type %s (and not %s)." \
-                    % (i, event, types[i], type(args[i])))
+                    % (i, e, types[i], type(args[i])))
         data = packer.pack(f.id, e.id, types, args)
         return Packet(data)
             



From dboucard at berlios.de  Wed Sep 14 07:49:30 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Wed, 14 Sep 2005 07:49:30 +0200
Subject: [Happyboom-svn] r157 - in happyboom/trunk: . client
Message-ID: <200509140549.j8E5nUAR002221@sheep.berlios.de>

Author: dboucard
Date: 2005-09-14 07:49:28 +0200 (Wed, 14 Sep 2005)
New Revision: 157

Added:
   happyboom/trunk/client/
   happyboom/trunk/client/base_client.py
Log:
happyboom client core (unstable)


Added: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-14 05:47:50 UTC (rev 156)
+++ happyboom/trunk/client/base_client.py	2005-09-14 05:49:28 UTC (rev 157)
@@ -0,0 +1,173 @@
+from net import io_udp
+import struct
+
+class HappyBoomClient(object):
+    
+    def __init__(self, args):
+        self.host = args.get("host", "127.0.0.1")
+        self.port = args.get("port", "12430")
+        self.verbose = args.get("verbose", False)
+        self.debug = args.get("debug", False)
+        protocol = args.get("protocol", None)
+        self.__io = io_udp.IO_UDP()
+        self.__verbose = verbose
+        self.__io.verbose = verbose
+        self.__debug = debug
+        self.__io.debug = debug
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        
+        self.signature = None
+        self.gateway = Gateway(self.__io, protocol)
+        
+    def start(self):
+        """ Starts the client : connection to the server, etc. """
+        # Try to connect to server
+        if self.__verbose: print "[HAPPYBOOM] Trying to connect to server %s:%u" % (self.host, self.port)
+        self.__io.on_connect = self.onConnect
+        self.__io.on_connection_fails = self.onConnectionFails
+        self.__io.on_disconnect = self.onDisconnect
+        self.__io.on_new_packet = self.gateway.processPacket
+        self.__io.on_lost_connection = self.onLostConnection
+        self.__io.connect(self.host, self.port)
+        if not self.__io.is_ready: return
+        thread.start_new_thread(self.__io.run_thread, ())
+        
+    def stop(self):
+        """ Stops the display client : disconnection from the server, etc. """
+        # Does not stop several times
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return
+        self.__stopped = True
+        self.__stoplock.release()
+        
+        self.send("quit")
+        self.__io.stop()
+        if self.__verbose: print "[HAPPYBOOM] Stopped"
+        
+    def __isStopped(self):
+        self.__stoplock.acquire()
+        stop = self.__stopped
+        self.__stoplock.release()
+        return stop
+    stopped = property(__isStopped)
+    
+    def onConnect(self):
+        """ Handler called on network connection. """
+        if self.__verbose: print "[HAPPYBOOM] Connected to server"
+        
+    def onConnectionFails(self):
+        """ Handler called when network connection fails. """
+        print "[HAPPYBOOM] Fail to connect to the server"
+
+    def onDisconnect(self):
+        """ Handler called on network disconnection. """
+        print "[HAPPYBOOM] Connection to server closed"
+        self.launchEvent("happyboom", "stop")
+
+    def onLostConnection(self):
+        """ Handler called on losting network connection. """
+        print "[HAPPYBOOM] Lost connection with server"
+        self.launchEvent("happyboom", "stop")
+        
+    def processPacket(self, new_packet):
+        """ Processes incomming network packets (converts and launches local event).
+        @param new_packet: incomming network packet.
+        @type new_packet: C{net.io.packet.Packet}
+        """
+        event_type, arg = self.str2evt(new_packet.data)
+        if event_type != None: 
+            if self.__debug: print "Received message: type=%s arg=%s" %(event_type, arg)
+            self.launchEvent(event_type, arg)
+            
+    def send(self, str):
+        """ Sends a string to the network server.
+        @param str: String to send.
+        @type str: C{str}
+        """
+        p = io.Packet()
+        p.writeStr(str)
+        self.__io.send(p)
+        
+
+class Gateway(EventLauncher, EventListener):
+    
+    CONNECTION    = 0x1
+    DISCONNECTION = 0x2
+    FEATURES      = 0x3
+    CREATE        = 0x4
+    DESTROY       = 0x5
+    EVENT         = 0x6
+    
+    def __init__(self, connection, protocol):
+        self.protocol = protocol
+        self.connection = connection
+        self.items = {}
+        
+    def processPacket(self, newPacket):
+        """ Processes incomming network packets (converts and launches local event).
+        @param new_packet: incomming network packet.
+        @type new_packet: C{net.io.packet.Packet}
+        """
+        type, data = self.splitPacket(new_packtet.data)
+        if type == self.CONNECTION:
+            self.recvConnection(data)
+            self.sendFeatures()
+        elif type == self.DISCONNECTION:
+            print "[happyboom] Disconnected from server : %s" %(self.getReason(data))
+            self.launchEvent("happyboom", "stop")
+        elif type == self.CREATE:
+            self.createItem(data)
+        elif type == self.DESTROY:
+            self.destroyItem(data)
+        elif type == self.EVENT:
+            self.processEvent(data)
+        else:
+            print "ProtocoleWarning : received unexpected packet type %s" %(type)
+            
+    def splitPacket(self, data):
+        fmt = "!B"
+        struct.calcsize(fmt)
+        return (struct.unpack(fmt, data[:i]), date[i:])
+        
+    def recvConnection(self, data):
+        fmt = "!H"
+        i = struct.calcsize(fmt)
+        version_len, data = (struct.unpack(fmt, data[:i]), data[i:])
+        fmt = "!%us" %(version_len)
+        i = struct.calcsize(fmt)
+        version, data = (struct.unpack(fmt, data[:i]), data[i:])
+        
+        fmt = "!H"
+        i = struct.calcsize(fmt)
+        sign_len, data = (struct.unpack(fmt, data[:i]), data[i:])
+        fmt = "!%us" %(version_len)
+        i = struct.calcsize(fmt)
+        signature, data = (struct.unpack(fmt, data[:i]), data[i:])
+        
+        if len(data) != 0:
+            raise TesUneGrosseMerdeError "Received a message with an unexpected length."
+        
+        if version != protocole.version:
+            pass # TODO
+            
+        self.launchEvent("happyboom", "signature", (signature,))
+            
+    def sendFeatures(self):
+        pass
+    
+    def getReason(self, data):
+        pass
+    
+    def createItem(self, data):
+        pass
+        
+    def destroyItem(self, data):
+        pass
+    
+    def processEvent(self, data):
+        packer.unpack(data, self.protocol)
+        if self.__debug: print "Received message: feature=%s event=%s arguments=%s" %(feat, evt, args)
+        self.launchEvent(feat, evt, args)
\ No newline at end of file



From haypo at berlios.de  Wed Sep 14 08:28:55 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 08:28:55 +0200
Subject: [Happyboom-svn] r158 - boomboom happyboom/trunk happyboom/trunk/client
Message-ID: <200509140628.j8E6SttK008642@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 08:28:51 +0200 (Wed, 14 Sep 2005)
New Revision: 158

Added:
   boomboom/AUTHORS
   boomboom/ChangeLog
   boomboom/README
   boomboom/TODO
   happyboom/trunk/makedoc.sh
Removed:
   happyboom/trunk/agent/
   happyboom/trunk/input/
   happyboom/trunk/makedoc
Modified:
   happyboom/trunk/README
   happyboom/trunk/TODO
   happyboom/trunk/client/base_client.py
Log:
Update documentation.


Added: boomboom/AUTHORS
===================================================================
--- boomboom/AUTHORS	2005-09-14 05:49:28 UTC (rev 157)
+++ boomboom/AUTHORS	2005-09-14 06:28:51 UTC (rev 158)
@@ -0,0 +1,2 @@
+Victor STINNER <victor.stinner AT haypocalc.com>
+Damien BOUCARD <damien.boucard AT tchoy.net>
\ No newline at end of file

Added: boomboom/ChangeLog
===================================================================
--- boomboom/ChangeLog	2005-09-14 05:49:28 UTC (rev 157)
+++ boomboom/ChangeLog	2005-09-14 06:28:51 UTC (rev 158)
@@ -0,0 +1,6 @@
+2005-04-29
+	- Version 0.1.4, quite playable with two human player over a network (or
+	in local). HappyBoom is using UDP transport for low latency.
+
+2005-04-25
+	- First line of BoomBoom source code

Added: boomboom/README
===================================================================
--- boomboom/README	2005-09-14 05:49:28 UTC (rev 157)
+++ boomboom/README	2005-09-14 06:28:51 UTC (rev 158)
@@ -0,0 +1,36 @@
+BoomBoom
+========
+
+BoomBoom is a rewrite of old game "Gorilla" (a Quick Basic game written
+by Microsoft). It's just a test for the HappyBoom kernel.
+
+See our website: http://www.happyboom.org/BoomBoom
+
+  Requirements
+  ------------
+- Python : version 2.2 or earlier (tested with 2.3 and 2.4)
+--> http://python.org/download/
+
+- pygame : version 1.6 or earlier (just tested 1.6)
+--> http://www.pygame.org/download.shtml
+
+- pysma : version 0.3 (tested until 0.3)
+--> https://developer.berlios.de/project/showfiles.php?group_id=3535
+
+  How to play
+  -----------
+To play, launch a term, go to the boomboom subdirectory and run
+a server:
+  python boomboom_server.py
+  
+Next, launch another term, go to the boomboom subdirectory again and run a client :
+  python boomboom_client.py <yourname>
+
+You can play it over Internet by giving a host name to client :
+  python boomboom_client.py --host <host ip or address> <yourname>
+
+   Controls
+   --------
+- Left/Right : Changes strength
+- Up/Down    : Changes angle
+- Space      : Shoots

Added: boomboom/TODO
===================================================================
--- boomboom/TODO	2005-09-14 05:49:28 UTC (rev 157)
+++ boomboom/TODO	2005-09-14 06:28:51 UTC (rev 158)
@@ -0,0 +1,2 @@
+See our webpage to get the last todo list:
+   http://www.happyboom.org/BoomBoom#Todo

Modified: happyboom/trunk/README
===================================================================
--- happyboom/trunk/README	2005-09-14 05:49:28 UTC (rev 157)
+++ happyboom/trunk/README	2005-09-14 06:28:51 UTC (rev 158)
@@ -1,60 +1,16 @@
-BoomBoom
-========
-
-BoomBoom is a rewrite of old game "Gorilla" (a Quick Basic game written
-by Microsoft). It's just a test for the HappyBoom kernel.
-
-  Requirements
-  ------------
-- Python : version 2.3 or earlier (tested until 2.4.1)
---> http://python.org/download/
-
-- pygame : version 1.6 or earlier (just tested 1.6)
---> http://www.pygame.org/download.shtml
-
-- pysma : version 0.3 (tested until 0.3)
---> https://developer.berlios.de/project/showfiles.php?group_id=3535
-
-  How to play
-  -----------
-To play, launch a term, go to the boomboom subdirectory and run
-a server :
-  python boomboom_server.py
-  
-Next, launch another term, go to the boomboom subdirectory again and run a client :
-  python boomboom_client.py <yourname>
-
-You can play it over Internet by giving a host name to client :
-  python boomboom_client.py --host <host ip or address> <yourname>
-
-   Controls
-   --------
-- Left/Right : Changes strength
-- Up/Down    : Changes angle
-- Space      : Shoots
-
-
 HappyBoom
 =========
 
-HappyBoom is a rewrite of Wormux game but with better conception :
-- inputs, server & "view" are well separated
-- it uses multi-agents system
+HappyBoom is a game engine based on client-server architecture. The server is
+based ony multi-agents system.
 
+Website: http://www.happyboom.org/
 
-Console
-=======
-
-It's a basic package of console tools. First it was a test for the kernel. But
-it should be compatible with new games. It can be used to display server stats
-for example :
-  python console_view.py --stats
-  
-  
 Documentation
 =============
 
-You can generate the API documentation of some package (presently 'boomboom'
-and 'net'). To do that, you must install Epydoc (version 2.1 or earlier, just
-tested 2.1) and run the 'makedoc' shell script in the concerned directory,
-or read the Epydoc manpage.
+You can generate the API documentation of HappyBoom which this command:
+    ./makedoc.sh
+
+Documentation will be generated in HTML in the subdirectory "doc". You
+need Epydoc (version 2.1 or earlier, just tested 2.1).

Modified: happyboom/trunk/TODO
===================================================================
--- happyboom/trunk/TODO	2005-09-14 05:49:28 UTC (rev 157)
+++ happyboom/trunk/TODO	2005-09-14 06:28:51 UTC (rev 158)
@@ -1,20 +1,2 @@
-# -*- coding: UTF-8 -*-
-TODO LIST
-=========
-o Improve network security
-o Improve input threading
-o For network : not all blocking read functions catch socket error 11
-o Catch UDP Binding error
-o Limit number of UDP clients
-o IO_Client : should self.io be self.__io ? 
-o Add timeout when a client try to connect
-
-En fran?ais pour la suite et pour BoomBoom :
-o Ecrire un vrai protocole r?seau
-o Ecrire un client texte en python
-o Ecrire un client 3D en C++
-o Un autre client 3D en Python pour Damien ?
-o Test de collision avec rectangle et/ou cercle
-o R?seau : Utiliser des canaux pour pouvoir partager une connexion Internet
-  entre view et input
-o Client 2D avec des th?mes graphiques
+See our webpage to get the last todo list:
+   http://www.happyboom.org/HappyBoom#Todo

Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-14 05:49:28 UTC (rev 157)
+++ happyboom/trunk/client/base_client.py	2005-09-14 06:28:51 UTC (rev 158)
@@ -92,82 +92,4 @@
         self.__io.send(p)
         
 
-class Gateway(EventLauncher, EventListener):
-    
-    CONNECTION    = 0x1
-    DISCONNECTION = 0x2
-    FEATURES      = 0x3
-    CREATE        = 0x4
-    DESTROY       = 0x5
-    EVENT         = 0x6
-    
-    def __init__(self, connection, protocol):
-        self.protocol = protocol
-        self.connection = connection
-        self.items = {}
-        
-    def processPacket(self, newPacket):
-        """ Processes incomming network packets (converts and launches local event).
-        @param new_packet: incomming network packet.
-        @type new_packet: C{net.io.packet.Packet}
-        """
-        type, data = self.splitPacket(new_packtet.data)
-        if type == self.CONNECTION:
-            self.recvConnection(data)
-            self.sendFeatures()
-        elif type == self.DISCONNECTION:
-            print "[happyboom] Disconnected from server : %s" %(self.getReason(data))
-            self.launchEvent("happyboom", "stop")
-        elif type == self.CREATE:
-            self.createItem(data)
-        elif type == self.DESTROY:
-            self.destroyItem(data)
-        elif type == self.EVENT:
-            self.processEvent(data)
-        else:
-            print "ProtocoleWarning : received unexpected packet type %s" %(type)
-            
-    def splitPacket(self, data):
-        fmt = "!B"
-        struct.calcsize(fmt)
-        return (struct.unpack(fmt, data[:i]), date[i:])
-        
-    def recvConnection(self, data):
-        fmt = "!H"
-        i = struct.calcsize(fmt)
-        version_len, data = (struct.unpack(fmt, data[:i]), data[i:])
-        fmt = "!%us" %(version_len)
-        i = struct.calcsize(fmt)
-        version, data = (struct.unpack(fmt, data[:i]), data[i:])
-        
-        fmt = "!H"
-        i = struct.calcsize(fmt)
-        sign_len, data = (struct.unpack(fmt, data[:i]), data[i:])
-        fmt = "!%us" %(version_len)
-        i = struct.calcsize(fmt)
-        signature, data = (struct.unpack(fmt, data[:i]), data[i:])
-        
-        if len(data) != 0:
-            raise TesUneGrosseMerdeError "Received a message with an unexpected length."
-        
-        if version != protocole.version:
-            pass # TODO
-            
-        self.launchEvent("happyboom", "signature", (signature,))
-            
-    def sendFeatures(self):
-        pass
-    
-    def getReason(self, data):
-        pass
-    
-    def createItem(self, data):
-        pass
-        
-    def destroyItem(self, data):
-        pass
-    
-    def processEvent(self, data):
-        packer.unpack(data, self.protocol)
-        if self.__debug: print "Received message: feature=%s event=%s arguments=%s" %(feat, evt, args)
-        self.launchEvent(feat, evt, args)
\ No newline at end of file
+

Deleted: happyboom/trunk/makedoc
===================================================================
--- happyboom/trunk/makedoc	2005-09-14 05:49:28 UTC (rev 157)
+++ happyboom/trunk/makedoc	2005-09-14 06:28:51 UTC (rev 158)
@@ -1,3 +0,0 @@
-#!/bin/sh
-test -e doc || mkdir doc
-epydoc -o doc/api -n "BoomBoom Client 0.2" --private-css blue net

Copied: happyboom/trunk/makedoc.sh (from rev 157, happyboom/trunk/makedoc)
===================================================================
--- happyboom/trunk/makedoc	2005-09-14 05:49:28 UTC (rev 157)
+++ happyboom/trunk/makedoc.sh	2005-09-14 06:28:51 UTC (rev 158)
@@ -0,0 +1,7 @@
+#!/bin/sh
+test -e doc || mkdir doc
+epydoc \
+    -o doc/api
+    -n "HappyBoom game engine 0.2" \
+    --private-css blue \
+    common net server



From haypo at berlios.de  Wed Sep 14 08:53:27 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 08:53:27 +0200
Subject: [Happyboom-svn] r159 - poilu/trunk
Message-ID: <200509140653.j8E6rRW9012053@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 08:53:25 +0200 (Wed, 14 Sep 2005)
New Revision: 159

Removed:
   poilu/trunk/irclib.py
Modified:
   poilu/trunk/pypoil.py
Log:
Use irclib part() function.


Deleted: poilu/trunk/irclib.py
===================================================================
--- poilu/trunk/irclib.py	2005-09-14 06:28:51 UTC (rev 158)
+++ poilu/trunk/irclib.py	2005-09-14 06:53:25 UTC (rev 159)
@@ -1,1556 +0,0 @@
-# Copyright (C) 1999--2002  Joel Rosdahl
-#
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-#
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with this library; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
-#
-# Joel Rosdahl <joel at rosdahl.net>
-#
-# $Id: irclib.py,v 1.30 2005/02/24 01:25:50 keltus Exp $
-
-"""irclib -- Internet Relay Chat (IRC) protocol client library.
-
-This library is intended to encapsulate the IRC protocol at a quite
-low level.  It provides an event-driven IRC client framework.  It has
-a fairly thorough support for the basic IRC protocol and CTCP, but DCC
-connection support is not yet implemented.
-
-In order to understand how to make an IRC client, I'm afraid you more
-or less must understand the IRC specifications.  They are available
-here: [IRC specifications].
-
-The main features of the IRC client framework are:
-
-  * Abstraction of the IRC protocol.
-  * Handles multiple simultaneous IRC server connections.
-  * Handles server PONGing transparently.
-  * Messages to the IRC server are done by calling methods on an IRC
-    connection object.
-  * Messages from an IRC server triggers events, which can be caught
-    by event handlers.
-  * Reading from and writing to IRC server sockets are normally done
-    by an internal select() loop, but the select()ing may be done by
-    an external main loop.
-  * Functions can be registered to execute at specified times by the
-    event-loop.
-  * Decodes CTCP tagging correctly (hopefully); I haven't seen any
-    other IRC client implementation that handles the CTCP
-    specification subtilties.
-  * A kind of simple, single-server, object-oriented IRC client class
-    that dispatches events to instance methods is included.
-
-Current limitations:
-
-  * The IRC protocol shines through the abstraction a bit too much.
-  * Data is not written asynchronously to the server, i.e. the write()
-    may block if the TCP buffers are stuffed.
-  * There are no support for DCC connections.
-  * The author haven't even read RFC 2810, 2811, 2812 and 2813.
-  * Like most projects, documentation is lacking...
-
-Since I seldom use IRC anymore, I will probably not work much on the
-library.  If you want to help or continue developing the library,
-please contact me (Joel Rosdahl <joel at rosdahl.net>).
-
-.. [IRC specifications] http://www.irchelp.org/irchelp/rfc/
-"""
-
-import bisect
-import re
-import select
-import socket
-import string
-import sys
-import time
-import types
-
-VERSION = 0, 4, 4
-DEBUG = 0
-
-# TODO
-# ----
-# (maybe) thread safety
-# (maybe) color parser convenience functions
-# documentation (including all event types)
-# (maybe) add awareness of different types of ircds
-# send data asynchronously to the server (and DCC connections)
-# (maybe) automatically close unused, passive DCC connections after a while
-
-# NOTES
-# -----
-# connection.quit() only sends QUIT to the server.
-# ERROR from the server triggers the error event and the disconnect event.
-# dropping of the connection triggers the disconnect event.
-
-class IRCError(Exception):
-    """Represents an IRC exception."""
-    pass
-
-
-class IRC:
-    """Class that handles one or several IRC server connections.
-
-    When an IRC object has been instantiated, it can be used to create
-    Connection objects that represent the IRC connections.  The
-    responsibility of the IRC object is to provide an event-driven
-    framework for the connections and to keep the connections alive.
-    It runs a select loop to poll each connection's TCP socket and
-    hands over the sockets with incoming data for processing by the
-    corresponding connection.
-
-    The methods of most interest for an IRC client writer are server,
-    add_global_handler, remove_global_handler, execute_at,
-    execute_delayed, process_once and process_forever.
-
-    Here is an example:
-
-        irc = irclib.IRC()
-        server = irc.server()
-        server.connect(\"irc.some.where\", 6667, \"my_nickname\")
-        server.privmsg(\"a_nickname\", \"Hi there!\")
-        server.process_forever()
-
-    This will connect to the IRC server irc.some.where on port 6667
-    using the nickname my_nickname and send the message \"Hi there!\"
-    to the nickname a_nickname.
-    """
-
-    def __init__(self, fn_to_add_socket=None,
-                 fn_to_remove_socket=None,
-                 fn_to_add_timeout=None):
-        """Constructor for IRC objects.
-
-        Optional arguments are fn_to_add_socket, fn_to_remove_socket
-        and fn_to_add_timeout.  The first two specify functions that
-        will be called with a socket object as argument when the IRC
-        object wants to be notified (or stop being notified) of data
-        coming on a new socket.  When new data arrives, the method
-        process_data should be called.  Similarly, fn_to_add_timeout
-        is called with a number of seconds (a floating point number)
-        as first argument when the IRC object wants to receive a
-        notification (by calling the process_timeout method).  So, if
-        e.g. the argument is 42.17, the object wants the
-        process_timeout method to be called after 42 seconds and 170
-        milliseconds.
-
-        The three arguments mainly exist to be able to use an external
-        main loop (for example Tkinter's or PyGTK's main app loop)
-        instead of calling the process_forever method.
-
-        An alternative is to just call ServerConnection.process_once()
-        once in a while.
-        """
-
-        if fn_to_add_socket and fn_to_remove_socket:
-            self.fn_to_add_socket = fn_to_add_socket
-            self.fn_to_remove_socket = fn_to_remove_socket
-        else:
-            self.fn_to_add_socket = None
-            self.fn_to_remove_socket = None
-
-        self.fn_to_add_timeout = fn_to_add_timeout
-        self.connections = []
-        self.handlers = {}
-        self.delayed_commands = [] # list of tuples in the format (time, function, arguments)
-
-        self.add_global_handler("ping", _ping_ponger, -42)
-
-    def server(self):
-        """Creates and returns a ServerConnection object."""
-
-        c = ServerConnection(self)
-        self.connections.append(c)
-        return c
-
-    def process_data(self, sockets):
-        """Called when there is more data to read on connection sockets.
-
-        Arguments:
-
-            sockets -- A list of socket objects.
-
-        See documentation for IRC.__init__.
-        """
-        for s in sockets:
-            for c in self.connections:
-                if s == c._get_socket():
-                    c.process_data()
-
-    def process_timeout(self):
-        """Called when a timeout notification is due.
-
-        See documentation for IRC.__init__.
-        """
-        t = time.time()
-        while self.delayed_commands:
-            if t >= self.delayed_commands[0][0]:
-                self.delayed_commands[0][1](*self.delayed_commands[0][2])
-                del self.delayed_commands[0]
-            else:
-                break
-
-    def process_once(self, timeout=0):
-        """Process data from connections once.
-
-        Arguments:
-
-            timeout -- How long the select() call should wait if no
-                       data is available.
-
-        This method should be called periodically to check and process
-        incoming data, if there are any.  If that seems boring, look
-        at the process_forever method.
-        """
-        sockets = map(lambda x: x._get_socket(), self.connections)
-        sockets = filter(lambda x: x != None, sockets)
-        if sockets:
-            (i, o, e) = select.select(sockets, [], [], timeout)
-            self.process_data(i)
-        else:
-            time.sleep(timeout)
-        self.process_timeout()
-
-    def process_forever(self, timeout=0.2):
-        """Run an infinite loop, processing data from connections.
-
-        This method repeatedly calls process_once.
-
-        Arguments:
-
-            timeout -- Parameter to pass to process_once.
-        """
-        while 1:
-            self.process_once(timeout)
-
-    def disconnect_all(self, message=""):
-        """Disconnects all connections."""
-        for c in self.connections:
-            c.quit(message)
-            c.disconnect(message)
-
-    def add_global_handler(self, event, handler, priority=0):
-        """Adds a global handler function for a specific event type.
-
-        Arguments:
-
-            event -- Event type (a string).  Check the values of the
-            numeric_events dictionary in irclib.py for possible event
-            types.
-
-            handler -- Callback function.
-
-            priority -- A number (the lower number, the higher priority).
-
-        The handler function is called whenever the specified event is
-        triggered in any of the connections.  See documentation for
-        the Event class.
-
-        The handler functions are called in priority order (lowest
-        number is highest priority).  If a handler function returns
-        \"NO MORE\", no more handlers will be called.
-        """
-
-        if not self.handlers.has_key(event):
-            self.handlers[event] = []
-        bisect.insort(self.handlers[event], ((priority, handler)))
-
-    def remove_global_handler(self, event, handler):
-        """Removes a global handler function.
-
-        Arguments:
-
-            event -- Event type (a string).
-
-            handler -- Callback function.
-
-        Returns 1 on success, otherwise 0.
-        """
-        if not self.handlers.has_key(event):
-            return 0
-        for h in self.handlers[event]:
-            if handler == h[1]:
-                self.handlers[event].remove(h)
-        return 1
-
-    def execute_at(self, at, function, arguments=()):
-        """Execute a function at a specified time.
-
-        Arguments:
-
-            at -- Execute at this time (standard \"time_t\" time).
-
-            function -- Function to call.
-
-            arguments -- Arguments to give the function.
-        """
-        self.execute_delayed(at-time.time(), function, arguments)
-
-    def execute_delayed(self, delay, function, arguments=()):
-        """Execute a function after a specified time.
-
-        Arguments:
-
-            delay -- How many seconds to wait.
-
-            function -- Function to call.
-
-            arguments -- Arguments to give the function.
-        """
-        bisect.insort(self.delayed_commands, (delay+time.time(), function, arguments))
-        if self.fn_to_add_timeout:
-            self.fn_to_add_timeout(delay)
-
-    def dcc(self, dcctype="chat"):
-        """Creates and returns a DCCConnection object.
-
-        Arguments:
-
-            dcctype -- "chat" for DCC CHAT connections or "raw" for
-                       DCC SEND (or other DCC types). If "chat",
-                       incoming data will be split in newline-separated
-                       chunks. If "raw", incoming data is not touched.
-        """
-        c = DCCConnection(self, dcctype)
-        self.connections.append(c)
-        return c
-
-    def _handle_event(self, connection, event):
-        """[Internal]"""
-        h = self.handlers
-        for handler in h.get("all_events", []) + h.get(event.eventtype(), []):
-            if handler[1](connection, event) == "NO MORE":
-                return
-
-    def _remove_connection(self, connection):
-        """[Internal]"""
-        self.connections.remove(connection)
-        if self.fn_to_remove_socket:
-            self.fn_to_remove_socket(connection._get_socket())
-
-_rfc_1459_command_regexp = re.compile("^(:(?P<prefix>[^ ]+) +)?(?P<command>[^ ]+)( *(?P<argument> .+))?")
-
-
-class Connection:
-    """Base class for IRC connections.
-
-    Must be overridden.
-    """
-    def __init__(self, irclibobj):
-        self.irclibobj = irclibobj
-
-    def _get_socket():
-        raise IRCError, "Not overridden"
-
-    ##############################
-    ### Convenience wrappers.
-
-    def execute_at(self, at, function, arguments=()):
-        self.irclibobj.execute_at(at, function, arguments)
-
-    def execute_delayed(self, delay, function, arguments=()):
-        self.irclibobj.execute_delayed(delay, function, arguments)
-
-
-class ServerConnectionError(IRCError):
-    pass
-
-class ServerNotConnectedError(ServerConnectionError):
-    pass
-
-
-# Huh!?  Crrrrazy EFNet doesn't follow the RFC: their ircd seems to
-# use \n as message separator!  :P
-_linesep_regexp = re.compile("\r?\n")
-
-class ServerConnection(Connection):
-    """This class represents an IRC server connection.
-
-    ServerConnection objects are instantiated by calling the server
-    method on an IRC object.
-    """
-
-    def __init__(self, irclibobj):
-        Connection.__init__(self, irclibobj)
-        self.connected = 0  # Not connected yet.
-
-    def connect(self, server, port, nickname, password=None, username=None,
-                ircname=None, localaddress="", localport=0):
-        """Connect/reconnect to a server.
-
-        Arguments:
-
-            server -- Server name.
-
-            port -- Port number.
-
-            nickname -- The nickname.
-
-            password -- Password (if any).
-
-            username -- The username.
-
-            ircname -- The IRC name ("realname").
-
-            localaddress -- Bind the connection to a specific local IP address.
-
-            localport -- Bind the connection to a specific local port.
-
-        This function can be called to reconnect a closed connection.
-
-        Returns the ServerConnection object.
-        """
-        if self.connected:
-            self.quit("Changing servers")
-
-        self.socket = None
-        self.previous_buffer = ""
-        self.handlers = {}
-        self.real_server_name = ""
-        self.real_nickname = nickname
-        self.server = server
-        self.port = port
-        self.nickname = nickname
-        self.username = username or nickname
-        self.ircname = ircname or nickname
-        self.password = password
-        self.localaddress = localaddress
-        self.localport = localport
-        self.localhost = socket.gethostname()
-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        try:
-            self.socket.bind((self.localaddress, self.localport))
-            self.socket.connect((self.server, self.port))
-        except socket.error, x:
-            self.socket.close()
-            self.socket = None
-            raise ServerConnectionError, "Couldn't connect to socket: %s" % x
-        self.connected = 1
-        if self.irclibobj.fn_to_add_socket:
-            self.irclibobj.fn_to_add_socket(self.socket)
-
-        # Log on...
-        if self.password:
-            self.pass_(self.password)
-        self.nick(self.nickname)
-        self.user(self.username, self.ircname)
-        return self
-
-    def close(self):
-        """Close the connection.
-
-        This method closes the connection permanently; after it has
-        been called, the object is unusable.
-        """
-
-        self.disconnect("Closing object")
-
-    def _get_socket(self):
-        """[Internal]"""
-        return self.socket
-
-    def get_server_name(self):
-        """Get the (real) server name.
-
-        This method returns the (real) server name, or, more
-        specifically, what the server calls itself.
-        """
-
-        if self.real_server_name:
-            return self.real_server_name
-        else:
-            return ""
-
-    def get_nickname(self):
-        """Get the (real) nick name.
-
-        This method returns the (real) nickname.  The library keeps
-        track of nick changes, so it might not be the nick name that
-        was passed to the connect() method.  """
-
-        return self.real_nickname
-
-    def process_data(self):
-        """[Internal]"""
-
-        try:
-            new_data = self.socket.recv(2**14)
-        except socket.error, x:
-            # The server hung up.
-            self.disconnect("Connection reset by peer")
-            return
-        if not new_data:
-            # Read nothing: connection must be down.
-            self.disconnect("Connection reset by peer")
-            return
-
-        lines = _linesep_regexp.split(self.previous_buffer + new_data)
-
-        # Save the last, unfinished line.
-        self.previous_buffer = lines[-1]
-        lines = lines[:-1]
-
-        for line in lines:
-            if DEBUG:
-                print "FROM SERVER:", line
-
-            if not line:
-                continue
-
-            prefix = None
-            command = None
-            arguments = None
-            self._handle_event(Event("all_raw_messages",
-                                     self.get_server_name(),
-                                     None,
-                                     [line]))
-
-            m = _rfc_1459_command_regexp.match(line)
-            if m.group("prefix"):
-                prefix = m.group("prefix")
-                if not self.real_server_name:
-                    self.real_server_name = prefix
-
-            if m.group("command"):
-                command = string.lower(m.group("command"))
-
-            if m.group("argument"):
-                a = string.split(m.group("argument"), " :", 1)
-                arguments = string.split(a[0])
-                if len(a) == 2:
-                    arguments.append(a[1])
-
-            if command == "nick":
-                if nm_to_n(prefix) == self.real_nickname:
-                    self.real_nickname = arguments[0]
-            elif command == "001":
-                # Record the nickname in case the client changed nick
-                # in a nicknameinuse callback.
-                self.real_nickname = arguments[0]
-
-            if command in ["privmsg", "notice"]:
-                target, message = arguments[0], arguments[1]
-                messages = _ctcp_dequote(message)
-
-                if command == "privmsg":
-                    if is_channel(target):
-                        command = "pubmsg"
-                else:
-                    if is_channel(target):
-                        command = "pubnotice"
-                    else:
-                        command = "privnotice"
-
-                for m in messages:
-                    if type(m) is types.TupleType:
-                        if command in ["privmsg", "pubmsg"]:
-                            command = "ctcp"
-                        else:
-                            command = "ctcpreply"
-
-                        m = list(m)
-                        if DEBUG:
-                            print "command: %s, source: %s, target: %s, arguments: %s" % (
-                                command, prefix, target, m)
-                        self._handle_event(Event(command, prefix, target, m))
-                        if command == "ctcp" and m[0] == "ACTION":
-                            # Emit an action event too. We're generous today.
-                            self._handle_event(Event("action", prefix, target, m[1:]))
-                    else:
-                        if DEBUG:
-                            print "command: %s, source: %s, target: %s, arguments: %s" % (
-                                command, prefix, target, [m])
-                        self._handle_event(Event(command, prefix, target, [m]))
-            else:
-                target = None
-
-                if command == "quit":
-                    arguments = [arguments[0]]
-                elif command == "ping":
-                    target = arguments[0]
-                else:
-                    target = arguments[0]
-                    arguments = arguments[1:]
-
-                if command == "mode":
-                    if not is_channel(target):
-                        command = "umode"
-
-                # Translate numerics into more readable strings.
-                if numeric_events.has_key(command):
-                    command = numeric_events[command]
-
-                if DEBUG:
-                    print "command: %s, source: %s, target: %s, arguments: %s" % (
-                        command, prefix, target, arguments)
-                self._handle_event(Event(command, prefix, target, arguments))
-
-    def _handle_event(self, event):
-        """[Internal]"""
-        self.irclibobj._handle_event(self, event)
-        if self.handlers.has_key(event.eventtype()):
-            for fn in self.handlers[event.eventtype()]:
-                fn(self, event)
-
-    def is_connected(self):
-        """Return connection status.
-
-        Returns true if connected, otherwise false.
-        """
-        return self.connected
-
-    def add_global_handler(self, *args):
-        """Add global handler.
-
-        See documentation for IRC.add_global_handler.
-        """
-        self.irclibobj.add_global_handler(*args)
-
-    def remove_global_handler(self, *args):
-        """Remove global handler.
-
-        See documentation for IRC.remove_global_handler.
-        """
-        self.irclibobj.remove_global_handler(*args)
-
-    def action(self, target, action):
-        """Send a CTCP ACTION command."""
-        self.ctcp("ACTION", target, action)
-
-    def admin(self, server=""):
-        """Send an ADMIN command."""
-        self.send_raw(string.strip(string.join(["ADMIN", server])))
-
-    def ctcp(self, ctcptype, target, parameter=""):
-        """Send a CTCP command."""
-        ctcptype = string.upper(ctcptype)
-        self.privmsg(target, "\001%s%s\001" % (ctcptype, parameter and (" " + parameter) or ""))
-
-    def ctcp_reply(self, target, parameter):
-        """Send a CTCP REPLY command."""
-        self.notice(target, "\001%s\001" % parameter)
-
-    def disconnect(self, message=""):
-        """Hang up the connection.
-
-        Arguments:
-
-            message -- Quit message.
-        """
-        if not self.connected:
-            return
-
-        self.irclibobj._remove_connection(self)
-        self.connected = 0
-        try:
-            self.socket.close()
-        except socket.error, x:
-            pass
-        self.socket = None
-        self._handle_event(Event("disconnect", self.server, "", [message]))
-
-    def globops(self, text):
-        """Send a GLOBOPS command."""
-        self.send_raw("GLOBOPS :" + text)
-
-    def info(self, server=""):
-        """Send an INFO command."""
-        self.send_raw(string.strip(string.join(["INFO", server])))
-
-    def invite(self, nick, channel):
-        """Send an INVITE command."""
-        self.send_raw(string.strip(string.join(["INVITE", nick, channel])))
-
-    def ison(self, nicks):
-        """Send an ISON command.
-
-        Arguments:
-
-            nicks -- List of nicks.
-        """
-        self.send_raw("ISON " + string.join(nicks, " "))
-
-    def leave(self, channel, key=""):
-        """Send a LEAVE command."""
-        self.send_raw("PART %s%s" % (channel, (key and (" " + key))))
-
-    def join(self, channel, key=""):
-        """Send a JOIN command."""
-        self.send_raw("JOIN %s%s" % (channel, (key and (" " + key))))
-
-    def kick(self, channel, nick, comment=""):
-        """Send a KICK command."""
-        self.send_raw("KICK %s %s%s" % (channel, nick, (comment and (" :" + comment))))
-
-    def links(self, remote_server="", server_mask=""):
-        """Send a LINKS command."""
-        command = "LINKS"
-        if remote_server:
-            command = command + " " + remote_server
-        if server_mask:
-            command = command + " " + server_mask
-        self.send_raw(command)
-
-    def list(self, channels=None, server=""):
-        """Send a LIST command."""
-        command = "LIST"
-        if channels:
-            command = command + " " + string.join(channels, ",")
-        if server:
-            command = command + " " + server
-        self.send_raw(command)
-
-    def lusers(self, server=""):
-        """Send a LUSERS command."""
-        self.send_raw("LUSERS" + (server and (" " + server)))
-
-    def mode(self, target, command):
-        """Send a MODE command."""
-        self.send_raw("MODE %s %s" % (target, command))
-
-    def motd(self, server=""):
-        """Send an MOTD command."""
-        self.send_raw("MOTD" + (server and (" " + server)))
-
-    def names(self, channels=None):
-        """Send a NAMES command."""
-        self.send_raw("NAMES" + (channels and (" " + string.join(channels, ",")) or ""))
-
-    def nick(self, newnick):
-        """Send a NICK command."""
-        self.send_raw("NICK " + newnick)
-
-    def notice(self, target, text):
-        """Send a NOTICE command."""
-        # Should limit len(text) here!
-        self.send_raw("NOTICE %s :%s" % (target, text))
-
-    def oper(self, nick, password):
-        """Send an OPER command."""
-        self.send_raw("OPER %s %s" % (nick, password))
-
-    def part(self, channels):
-        """Send a PART command."""
-        if type(channels) == types.StringType:
-            self.send_raw("PART " + channels)
-        else:
-            self.send_raw("PART " + string.join(channels, ","))
-
-    def pass_(self, password):
-        """Send a PASS command."""
-        self.send_raw("PASS " + password)
-
-    def ping(self, target, target2=""):
-        """Send a PING command."""
-        self.send_raw("PING %s%s" % (target, target2 and (" " + target2)))
-
-    def pong(self, target, target2=""):
-        """Send a PONG command."""
-        self.send_raw("PONG %s%s" % (target, target2 and (" " + target2)))
-
-    def privmsg(self, target, text):
-        """Send a PRIVMSG command."""
-        # Should limit len(text) here!
-        self.send_raw("PRIVMSG %s :%s" % (target, text))
-
-    def privmsg_many(self, targets, text):
-        """Send a PRIVMSG command to multiple targets."""
-        # Should limit len(text) here!
-        self.send_raw("PRIVMSG %s :%s" % (string.join(targets, ","), text))
-
-    def quit(self, message=""):
-        """Send a QUIT command."""
-        # Note that many IRC servers don't use your QUIT message
-        # unless you've been connected for at least 5 minutes!
-        self.send_raw("QUIT" + (message and (" :" + message)))
-
-    def sconnect(self, target, port="", server=""):
-        """Send an SCONNECT command."""
-        self.send_raw("CONNECT %s%s%s" % (target,
-                                          port and (" " + port),
-                                          server and (" " + server)))
-
-    def send_raw(self, string):
-        """Send raw string to the server.
-
-        The string will be padded with appropriate CR LF.
-        """
-        if self.socket is None:
-            raise ServerNotConnectedError, "Not connected."
-        try:
-            self.socket.send(string + "\r\n")
-            if DEBUG:
-                print "TO SERVER:", string
-        except socket.error, x:
-            # Ouch!
-            self.disconnect("Connection reset by peer.")
-
-    def squit(self, server, comment=""):
-        """Send an SQUIT command."""
-        self.send_raw("SQUIT %s%s" % (server, comment and (" :" + comment)))
-
-    def stats(self, statstype, server=""):
-        """Send a STATS command."""
-        self.send_raw("STATS %s%s" % (statstype, server and (" " + server)))
-
-    def time(self, server=""):
-        """Send a TIME command."""
-        self.send_raw("TIME" + (server and (" " + server)))
-
-    def topic(self, channel, new_topic=None):
-        """Send a TOPIC command."""
-        if new_topic == None:
-            self.send_raw("TOPIC " + channel)
-        else:
-            self.send_raw("TOPIC %s :%s" % (channel, new_topic))
-
-    def trace(self, target=""):
-        """Send a TRACE command."""
-        self.send_raw("TRACE" + (target and (" " + target)))
-
-    def user(self, username, realname):
-        """Send a USER command."""
-        self.send_raw("USER %s 0 * :%s" % (username, realname))
-
-    def userhost(self, nicks):
-        """Send a USERHOST command."""
-        self.send_raw("USERHOST " + string.join(nicks, ","))
-
-    def users(self, server=""):
-        """Send a USERS command."""
-        self.send_raw("USERS" + (server and (" " + server)))
-
-    def version(self, server=""):
-        """Send a VERSION command."""
-        self.send_raw("VERSION" + (server and (" " + server)))
-
-    def wallops(self, text):
-        """Send a WALLOPS command."""
-        self.send_raw("WALLOPS :" + text)
-
-    def who(self, target="", op=""):
-        """Send a WHO command."""
-        self.send_raw("WHO%s%s" % (target and (" " + target), op and (" o")))
-
-    def whois(self, targets):
-        """Send a WHOIS command."""
-        self.send_raw("WHOIS " + string.join(targets, ","))
-
-    def whowas(self, nick, max="", server=""):
-        """Send a WHOWAS command."""
-        self.send_raw("WHOWAS %s%s%s" % (nick,
-                                         max and (" " + max),
-                                         server and (" " + server)))
-
-
-class DCCConnectionError(IRCError):
-    pass
-
-
-class DCCConnection(Connection):
-    """This class represents a DCC connection.
-
-    DCCConnection objects are instantiated by calling the dcc
-    method on an IRC object.
-    """
-    def __init__(self, irclibobj, dcctype):
-        Connection.__init__(self, irclibobj)
-        self.connected = 0
-        self.passive = 0
-        self.dcctype = dcctype
-        self.peeraddress = None
-        self.peerport = None
-
-    def connect(self, address, port):
-        """Connect/reconnect to a DCC peer.
-
-        Arguments:
-            address -- Host/IP address of the peer.
-
-            port -- The port number to connect to.
-
-        Returns the DCCConnection object.
-        """
-        self.peeraddress = socket.gethostbyname(address)
-        self.peerport = port
-        self.socket = None
-        self.previous_buffer = ""
-        self.handlers = {}
-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        self.passive = 0
-        try:
-            self.socket.connect((self.peeraddress, self.peerport))
-        except socket.error, x:
-            raise DCCConnectionError, "Couldn't connect to socket: %s" % x
-        self.connected = 1
-        if self.irclibobj.fn_to_add_socket:
-            self.irclibobj.fn_to_add_socket(self.socket)
-        return self
-
-    def listen(self):
-        """Wait for a connection/reconnection from a DCC peer.
-
-        Returns the DCCConnection object.
-
-        The local IP address and port are available as
-        self.localaddress and self.localport.  After connection from a
-        peer, the peer address and port are available as
-        self.peeraddress and self.peerport.
-        """
-        self.previous_buffer = ""
-        self.handlers = {}
-        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        self.passive = 1
-        try:
-            self.socket.bind((socket.gethostbyname(socket.gethostname()), 0))
-            self.localaddress, self.localport = self.socket.getsockname()
-            self.socket.listen(10)
-        except socket.error, x:
-            raise DCCConnectionError, "Couldn't bind socket: %s" % x
-        return self
-
-    def disconnect(self, message=""):
-        """Hang up the connection and close the object.
-
-        Arguments:
-
-            message -- Quit message.
-        """
-        if not self.connected:
-            return
-
-        self.connected = 0
-        try:
-            self.socket.close()
-        except socket.error, x:
-            pass
-        self.socket = None
-        self.irclibobj._handle_event(
-            self,
-            Event("dcc_disconnect", self.peeraddress, "", [message]))
-        self.irclibobj._remove_connection(self)
-
-    def process_data(self):
-        """[Internal]"""
-
-        if self.passive and not self.connected:
-            conn, (self.peeraddress, self.peerport) = self.socket.accept()
-            self.socket.close()
-            self.socket = conn
-            self.connected = 1
-            if DEBUG:
-                print "DCC connection from %s:%d" % (
-                    self.peeraddress, self.peerport)
-            self.irclibobj._handle_event(
-                self,
-                Event("dcc_connect", self.peeraddress, None, None))
-            return
-
-        try:
-            new_data = self.socket.recv(2**14)
-        except socket.error, x:
-            # The server hung up.
-            self.disconnect("Connection reset by peer")
-            return
-        if not new_data:
-            # Read nothing: connection must be down.
-            self.disconnect("Connection reset by peer")
-            return
-
-        if self.dcctype == "chat":
-            # The specification says lines are terminated with LF, but
-            # it seems safer to handle CR LF terminations too.
-            chunks = _linesep_regexp.split(self.previous_buffer + new_data)
-
-            # Save the last, unfinished line.
-            self.previous_buffer = chunks[-1]
-            if len(self.previous_buffer) > 2**14:
-                # Bad peer! Naughty peer!
-                self.disconnect()
-                return
-            chunks = chunks[:-1]
-        else:
-            chunks = [new_data]
-
-        command = "dccmsg"
-        prefix = self.peeraddress
-        target = None
-        for chunk in chunks:
-            if DEBUG:
-                print "FROM PEER:", chunk
-            arguments = [chunk]
-            if DEBUG:
-                print "command: %s, source: %s, target: %s, arguments: %s" % (
-                    command, prefix, target, arguments)
-            self.irclibobj._handle_event(
-                self,
-                Event(command, prefix, target, arguments))
-
-    def _get_socket(self):
-        """[Internal]"""
-        return self.socket
-
-    def privmsg(self, string):
-        """Send data to DCC peer.
-
-        The string will be padded with appropriate LF if it's a DCC
-        CHAT session.
-        """
-        try:
-            self.socket.send(string)
-            if self.dcctype == "chat":
-                self.socket.send("\n")
-            if DEBUG:
-                print "TO PEER: %s\n" % string
-        except socket.error, x:
-            # Ouch!
-            self.disconnect("Connection reset by peer.")
-
-class SimpleIRCClient:
-    """A simple single-server IRC client class.
-
-    This is an example of an object-oriented wrapper of the IRC
-    framework.  A real IRC client can be made by subclassing this
-    class and adding appropriate methods.
-
-    The method on_join will be called when a "join" event is created
-    (which is done when the server sends a JOIN messsage/command),
-    on_privmsg will be called for "privmsg" events, and so on.  The
-    handler methods get two arguments: the connection object (same as
-    self.connection) and the event object.
-
-    Instance attributes that can be used by sub classes:
-
-        ircobj -- The IRC instance.
-
-        connection -- The ServerConnection instance.
-
-        dcc_connections -- A list of DCCConnection instances.
-    """
-    def __init__(self):
-        self.ircobj = IRC()
-        self.connection = self.ircobj.server()
-        self.dcc_connections = []
-        self.ircobj.add_global_handler("all_events", self._dispatcher, -10)
-        self.ircobj.add_global_handler("dcc_disconnect", self._dcc_disconnect, -10)
-
-    def _dispatcher(self, c, e):
-        """[Internal]"""
-        m = "on_" + e.eventtype()
-        if hasattr(self, m):
-            getattr(self, m)(c, e)
-
-    def _dcc_disconnect(self, c, e):
-        self.dcc_connections.remove(c)
-
-    def connect(self, server, port, nickname, password=None, username=None,
-                ircname=None, localaddress="", localport=0):
-        """Connect/reconnect to a server.
-
-        Arguments:
-
-            server -- Server name.
-
-            port -- Port number.
-
-            nickname -- The nickname.
-
-            password -- Password (if any).
-
-            username -- The username.
-
-            ircname -- The IRC name.
-
-            localaddress -- Bind the connection to a specific local IP address.
-
-            localport -- Bind the connection to a specific local port.
-
-        This function can be called to reconnect a closed connection.
-        """
-        self.connection.connect(server, port, nickname,
-                                password, username, ircname,
-                                localaddress, localport)
-
-    def dcc_connect(self, address, port, dcctype="chat"):
-        """Connect to a DCC peer.
-
-        Arguments:
-
-            address -- IP address of the peer.
-
-            port -- Port to connect to.
-
-        Returns a DCCConnection instance.
-        """
-        dcc = self.ircobj.dcc(dcctype)
-        self.dcc_connections.append(dcc)
-        dcc.connect(address, port)
-        return dcc
-
-    def dcc_listen(self, dcctype="chat"):
-        """Listen for connections from a DCC peer.
-
-        Returns a DCCConnection instance.
-        """
-        dcc = self.ircobj.dcc(dcctype)
-        self.dcc_connections.append(dcc)
-        dcc.listen()
-        return dcc
-
-    def start(self):
-        """Start the IRC client."""
-        self.ircobj.process_forever()
-
-
-class Event:
-    """Class representing an IRC event."""
-    def __init__(self, eventtype, source, target, arguments=None):
-        """Constructor of Event objects.
-
-        Arguments:
-
-            eventtype -- A string describing the event.
-
-            source -- The originator of the event (a nick mask or a server). XXX Correct?
-
-            target -- The target of the event (a nick or a channel). XXX Correct?
-
-            arguments -- Any event specific arguments.
-        """
-        self._eventtype = eventtype
-        self._source = source
-        self._target = target
-        if arguments:
-            self._arguments = arguments
-        else:
-            self._arguments = []
-
-    def eventtype(self):
-        """Get the event type."""
-        return self._eventtype
-
-    def source(self):
-        """Get the event source."""
-        return self._source
-
-    def target(self):
-        """Get the event target."""
-        return self._target
-
-    def arguments(self):
-        """Get the event arguments."""
-        return self._arguments
-
-_LOW_LEVEL_QUOTE = "\020"
-_CTCP_LEVEL_QUOTE = "\134"
-_CTCP_DELIMITER = "\001"
-
-_low_level_mapping = {
-    "0": "\000",
-    "n": "\n",
-    "r": "\r",
-    _LOW_LEVEL_QUOTE: _LOW_LEVEL_QUOTE
-}
-
-_low_level_regexp = re.compile(_LOW_LEVEL_QUOTE + "(.)")
-
-def mask_matches(nick, mask):
-    """Check if a nick matches a mask.
-
-    Returns true if the nick matches, otherwise false.
-    """
-    nick = irc_lower(nick)
-    mask = irc_lower(mask)
-    mask = string.replace(mask, "\\", "\\\\")
-    for ch in ".$|[](){}+":
-        mask = string.replace(mask, ch, "\\" + ch)
-    mask = string.replace(mask, "?", ".")
-    mask = string.replace(mask, "*", ".*")
-    r = re.compile(mask, re.IGNORECASE)
-    return r.match(nick)
-
-_alpha = "abcdefghijklmnopqrstuvwxyz"
-_special = "-[]\\`^{}"
-nick_characters = _alpha + string.upper(_alpha) + string.digits + _special
-_ircstring_translation = string.maketrans(string.upper(_alpha) + "[]\\^",
-                                          _alpha + "{}|~")
-
-def irc_lower(s):
-    """Returns a lowercased string.
-
-    The definition of lowercased comes from the IRC specification (RFC
-    1459).
-    """
-    return string.translate(s, _ircstring_translation)
-
-def _ctcp_dequote(message):
-    """[Internal] Dequote a message according to CTCP specifications.
-
-    The function returns a list where each element can be either a
-    string (normal message) or a tuple of one or two strings (tagged
-    messages).  If a tuple has only one element (ie is a singleton),
-    that element is the tag; otherwise the tuple has two elements: the
-    tag and the data.
-
-    Arguments:
-
-        message -- The message to be decoded.
-    """
-
-    def _low_level_replace(match_obj):
-        ch = match_obj.group(1)
-
-        # If low_level_mapping doesn't have the character as key, we
-        # should just return the character.
-        return _low_level_mapping.get(ch, ch)
-
-    if _LOW_LEVEL_QUOTE in message:
-        # Yup, there was a quote.  Release the dequoter, man!
-        message = _low_level_regexp.sub(_low_level_replace, message)
-
-    if _CTCP_DELIMITER not in message:
-        return [message]
-    else:
-        # Split it into parts.  (Does any IRC client actually *use*
-        # CTCP stacking like this?)
-        chunks = string.split(message, _CTCP_DELIMITER)
-
-        messages = []
-        i = 0
-        while i < len(chunks)-1:
-            # Add message if it's non-empty.
-            if len(chunks[i]) > 0:
-                messages.append(chunks[i])
-
-            if i < len(chunks)-2:
-                # Aye!  CTCP tagged data ahead!
-                messages.append(tuple(string.split(chunks[i+1], " ", 1)))
-
-            i = i + 2
-
-        if len(chunks) % 2 == 0:
-            # Hey, a lonely _CTCP_DELIMITER at the end!  This means
-            # that the last chunk, including the delimiter, is a
-            # normal message!  (This is according to the CTCP
-            # specification.)
-            messages.append(_CTCP_DELIMITER + chunks[-1])
-
-        return messages
-
-def is_channel(string):
-    """Check if a string is a channel name.
-
-    Returns true if the argument is a channel name, otherwise false.
-    """
-    return string and string[0] in "#&+!"
-
-def ip_numstr_to_quad(num):
-    """Convert an IP number as an integer given in ASCII
-    representation (e.g. '3232235521') to an IP address string
-    (e.g. '192.168.0.1')."""
-    n = long(num)
-    p = map(str, map(int, [n >> 24 & 0xFF, n >> 16 & 0xFF,
-                           n >> 8 & 0xFF, n & 0xFF]))
-    return string.join(p, ".")
-
-def ip_quad_to_numstr(quad):
-    """Convert an IP address string (e.g. '192.168.0.1') to an IP
-    number as an integer given in ASCII representation
-    (e.g. '3232235521')."""
-    p = map(long, string.split(quad, "."))
-    s = str((p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3])
-    if s[-1] == "L":
-        s = s[:-1]
-    return s
-
-def nm_to_n(s):
-    """Get the nick part of a nickmask.
-
-    (The source of an Event is a nickmask.)
-    """
-    return string.split(s, "!")[0]
-
-def nm_to_uh(s):
-    """Get the userhost part of a nickmask.
-
-    (The source of an Event is a nickmask.)
-    """
-    return string.split(s, "!")[1]
-
-def nm_to_h(s):
-    """Get the host part of a nickmask.
-
-    (The source of an Event is a nickmask.)
-    """
-    return string.split(s, "@")[1]
-
-def nm_to_u(s):
-    """Get the user part of a nickmask.
-
-    (The source of an Event is a nickmask.)
-    """
-    s = string.split(s, "!")[1]
-    return string.split(s, "@")[0]
-
-def parse_nick_modes(mode_string):
-    """Parse a nick mode string.
-
-    The function returns a list of lists with three members: sign,
-    mode and argument.  The sign is \"+\" or \"-\".  The argument is
-    always None.
-
-    Example:
-
-    >>> irclib.parse_nick_modes(\"+ab-c\")
-    [['+', 'a', None], ['+', 'b', None], ['-', 'c', None]]
-    """
-
-    return _parse_modes(mode_string, "")
-
-def parse_channel_modes(mode_string):
-    """Parse a channel mode string.
-
-    The function returns a list of lists with three members: sign,
-    mode and argument.  The sign is \"+\" or \"-\".  The argument is
-    None if mode isn't one of \"b\", \"k\", \"l\", \"v\" or \"o\".
-
-    Example:
-
-    >>> irclib.parse_channel_modes(\"+ab-c foo\")
-    [['+', 'a', None], ['+', 'b', 'foo'], ['-', 'c', None]]
-    """
-
-    return _parse_modes(mode_string, "bklvo")
-
-def _parse_modes(mode_string, unary_modes=""):
-    """[Internal]"""
-    modes = []
-    arg_count = 0
-
-    # State variable.
-    sign = ""
-
-    a = string.split(mode_string)
-    if len(a) == 0:
-        return []
-    else:
-        mode_part, args = a[0], a[1:]
-
-    if mode_part[0] not in "+-":
-        return []
-    for ch in mode_part:
-        if ch in "+-":
-            sign = ch
-        elif ch == " ":
-            collecting_arguments = 1
-        elif ch in unary_modes:
-            if len(args) >= arg_count + 1:
-                modes.append([sign, ch, args[arg_count]])
-                arg_count = arg_count + 1
-            else:
-                modes.append([sign, ch, None])
-        else:
-            modes.append([sign, ch, None])
-    return modes
-
-def _ping_ponger(connection, event):
-    """[Internal]"""
-    connection.pong(event.target())
-
-# Numeric table mostly stolen from the Perl IRC module (Net::IRC).
-numeric_events = {
-    "001": "welcome",
-    "002": "yourhost",
-    "003": "created",
-    "004": "myinfo",
-    "005": "featurelist",  # XXX
-    "200": "tracelink",
-    "201": "traceconnecting",
-    "202": "tracehandshake",
-    "203": "traceunknown",
-    "204": "traceoperator",
-    "205": "traceuser",
-    "206": "traceserver",
-    "207": "traceservice",
-    "208": "tracenewtype",
-    "209": "traceclass",
-    "210": "tracereconnect",
-    "211": "statslinkinfo",
-    "212": "statscommands",
-    "213": "statscline",
-    "214": "statsnline",
-    "215": "statsiline",
-    "216": "statskline",
-    "217": "statsqline",
-    "218": "statsyline",
-    "219": "endofstats",
-    "221": "umodeis",
-    "231": "serviceinfo",
-    "232": "endofservices",
-    "233": "service",
-    "234": "servlist",
-    "235": "servlistend",
-    "241": "statslline",
-    "242": "statsuptime",
-    "243": "statsoline",
-    "244": "statshline",
-    "250": "luserconns",
-    "251": "luserclient",
-    "252": "luserop",
-    "253": "luserunknown",
-    "254": "luserchannels",
-    "255": "luserme",
-    "256": "adminme",
-    "257": "adminloc1",
-    "258": "adminloc2",
-    "259": "adminemail",
-    "261": "tracelog",
-    "262": "endoftrace",
-    "263": "tryagain",
-    "265": "n_local",
-    "266": "n_global",
-    "300": "none",
-    "301": "away",
-    "302": "userhost",
-    "303": "ison",
-    "305": "unaway",
-    "306": "nowaway",
-    "311": "whoisuser",
-    "312": "whoisserver",
-    "313": "whoisoperator",
-    "314": "whowasuser",
-    "315": "endofwho",
-    "316": "whoischanop",
-    "317": "whoisidle",
-    "318": "endofwhois",
-    "319": "whoischannels",
-    "321": "liststart",
-    "322": "list",
-    "323": "listend",
-    "324": "channelmodeis",
-    "329": "channelcreate",
-    "331": "notopic",
-    "332": "topic",
-    "333": "topicinfo",
-    "341": "inviting",
-    "342": "summoning",
-    "346": "invitelist",
-    "347": "endofinvitelist",
-    "348": "exceptlist",
-    "349": "endofexceptlist",
-    "351": "version",
-    "352": "whoreply",
-    "353": "namreply",
-    "361": "killdone",
-    "362": "closing",
-    "363": "closeend",
-    "364": "links",
-    "365": "endoflinks",
-    "366": "endofnames",
-    "367": "banlist",
-    "368": "endofbanlist",
-    "369": "endofwhowas",
-    "371": "info",
-    "372": "motd",
-    "373": "infostart",
-    "374": "endofinfo",
-    "375": "motdstart",
-    "376": "endofmotd",
-    "377": "motd2",        # 1997-10-16 -- tkil
-    "381": "youreoper",
-    "382": "rehashing",
-    "384": "myportis",
-    "391": "time",
-    "392": "usersstart",
-    "393": "users",
-    "394": "endofusers",
-    "395": "nousers",
-    "401": "nosuchnick",
-    "402": "nosuchserver",
-    "403": "nosuchchannel",
-    "404": "cannotsendtochan",
-    "405": "toomanychannels",
-    "406": "wasnosuchnick",
-    "407": "toomanytargets",
-    "409": "noorigin",
-    "411": "norecipient",
-    "412": "notexttosend",
-    "413": "notoplevel",
-    "414": "wildtoplevel",
-    "421": "unknowncommand",
-    "422": "nomotd",
-    "423": "noadmininfo",
-    "424": "fileerror",
-    "431": "nonicknamegiven",
-    "432": "erroneusnickname", # Thiss iz how its speld in thee RFC.
-    "433": "nicknameinuse",
-    "436": "nickcollision",
-    "437": "unavailresource",  # "Nick temporally unavailable"
-    "441": "usernotinchannel",
-    "442": "notonchannel",
-    "443": "useronchannel",
-    "444": "nologin",
-    "445": "summondisabled",
-    "446": "usersdisabled",
-    "451": "notregistered",
-    "461": "needmoreparams",
-    "462": "alreadyregistered",
-    "463": "nopermforhost",
-    "464": "passwdmismatch",
-    "465": "yourebannedcreep", # I love this one...
-    "466": "youwillbebanned",
-    "467": "keyset",
-    "471": "channelisfull",
-    "472": "unknownmode",
-    "473": "inviteonlychan",
-    "474": "bannedfromchan",
-    "475": "badchannelkey",
-    "476": "badchanmask",
-    "477": "nochanmodes",  # "Channel doesn't support modes"
-    "478": "banlistfull",
-    "481": "noprivileges",
-    "482": "chanoprivsneeded",
-    "483": "cantkillserver",
-    "484": "restricted",   # Connection is restricted
-    "485": "uniqopprivsneeded",
-    "491": "nooperhost",
-    "492": "noservicehost",
-    "501": "umodeunknownflag",
-    "502": "usersdontmatch",
-}
-
-generated_events = [
-    # Generated events
-    "dcc_connect",
-    "dcc_disconnect",
-    "dccmsg",
-    "disconnect",
-    "ctcp",
-    "ctcpreply",
-]
-
-protocol_events = [
-    # IRC protocol events
-    "error",
-    "join",
-    "kick",
-    "mode",
-    "part",
-    "ping",
-    "privmsg",
-    "privnotice",
-    "pubmsg",
-    "pubnotice",
-    "quit",
-]
-
-all_events = generated_events + protocol_events + numeric_events.values()

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-14 06:28:51 UTC (rev 158)
+++ poilu/trunk/pypoil.py	2005-09-14 06:53:25 UTC (rev 159)
@@ -262,8 +262,8 @@
             
         regs = re.compile("^leave (#.*)$", re.IGNORECASE).search(cmd)
         if regs != None:
-            self.channel = regs.group(1) 
-            self.connection.leave(self.channel)
+            self.channel = regs.group(1).encode("ascii")
+            self.connection.part(self.channel)
             return True
              
         regs = re.compile("^nick (.*)$", re.IGNORECASE).search(cmd)



From haypo at berlios.de  Wed Sep 14 09:26:41 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 09:26:41 +0200
Subject: [Happyboom-svn] r160 - happyboom/trunk/common
Message-ID: <200509140726.j8E7QfPX016981@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 09:26:40 +0200 (Wed, 14 Sep 2005)
New Revision: 160

Added:
   happyboom/trunk/common/file.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/common/simple_event.py
   happyboom/trunk/common/thread.py
Modified:
   happyboom/trunk/common/protocol.py
Log:
Add missing files, and move simple_event.py in HappyBoom.


Added: happyboom/trunk/common/file.py
===================================================================
--- happyboom/trunk/common/file.py	2005-09-14 06:53:25 UTC (rev 159)
+++ happyboom/trunk/common/file.py	2005-09-14 07:26:40 UTC (rev 160)
@@ -0,0 +1,25 @@
+import os
+
+def getCreateHomeDir(subdir):
+    """
+    Get the home directory, and then create a subdirectory.
+    Example: create ~/.subdir/ in Linux.
+    
+    Returns None if fails to find home directory and/or create subdirectory.
+    """
+
+    # Get user directory 
+    if os.name=="nt":
+        home = os.environ['USERHOME']
+    else:
+        subdir = "."+subdir
+        home = os.environ['HOME']
+
+    # Create happywarry directory if needed
+    logdir = os.path.join(home, subdir)
+    try:
+        os.mkdir(logdir)
+    except OSError, err:
+        if err[0]==17: pass
+        logdir = None
+    return logdir

Added: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-14 06:53:25 UTC (rev 159)
+++ happyboom/trunk/common/presentation.py	2005-09-14 07:26:40 UTC (rev 160)
@@ -0,0 +1,89 @@
+from happyboom.common.simple_event import EventLauncher, EventListener
+from happyboom.common.log import log
+
+class Presentation(EventLauncher, EventListener):
+    
+    CONNECTION    = 0x1
+    DISCONNECTION = 0x2
+    FEATURES      = 0x3
+    CREATE        = 0x4
+    DESTROY       = 0x5
+    EVENT         = 0x6
+    
+    def __init__(self, protocol):
+        self.protocol = protocol
+        self.items = {}
+        self.gateway = None
+        
+    def processPacket(self, newPacket):
+        """ Processes incomming network packets (converts and launches local event).
+        @param new_packet: incomming network packet.
+        @type new_packet: C{net.io.packet.Packet}
+        """
+      
+        # Get packet type
+        data = new_packtet.data
+        fmt = "!B"
+        i = struct.calcsize(fmt)
+        type, data = (struct.unpack(fmt, data[:i]), date[i:],)
+
+        # Choose process function
+        if type == self.CONNECTION:
+            self.recvConnection(data)
+            self.sendFeatures()
+        elif type == self.DISCONNECTION:
+            log.warning(u"Disconnected from server : %s" % self.getReason(data))
+            self.launchEvent("happyboom", "stop")
+        elif type == self.CREATE:
+            self.createItem(data)
+        elif type == self.DESTROY:
+            self.destroyItem(data)
+        elif type == self.EVENT:
+            self.processEvent(data)
+        else:
+            log.warning("ProtocoleWarning: received unexpected packet type %s." % type)
+        
+    def recvConnection(self, data):
+        fmt = "!H"
+        i = struct.calcsize(fmt)
+        version_len, data = (struct.unpack(fmt, data[:i]), data[i:])
+        fmt = "!%us" %(version_len)
+        i = struct.calcsize(fmt)
+        version, data = (struct.unpack(fmt, data[:i]), data[i:])
+        
+        fmt = "!H"
+        i = struct.calcsize(fmt)
+        sign_len, data = (struct.unpack(fmt, data[:i]), data[i:])
+        fmt = "!%us" %(version_len)
+        i = struct.calcsize(fmt)
+        signature, data = (struct.unpack(fmt, data[:i]), data[i:])
+        
+        if len(data) != 0:
+            raise TesUneGrosseMerdeError "Received a message with an unexpected length."
+        
+        if version != protocole.version:
+            pass # TODO
+            
+        self.launchEvent("happyboom", "signature", (signature,))
+            
+    def sendFeatures(self):
+        pass
+    
+    def getReason(self, data):
+        pass
+    
+    def createItem(self, data):
+        pass
+
+    def sendMsg(self, data):
+        data = struct.pack("!B", self.EVENT) + data
+        return data
+        
+    def destroyItem(self, data):
+        pass
+    
+    def processEvent(self, data):
+        packer.unpack(data, self.protocol)
+        if self.__debug:
+            log.info("Received message: feature=%s event=%s arguments=%s." % (feat, evt, args))
+        self.launchEvent(feat, evt, args)

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-14 06:53:25 UTC (rev 159)
+++ happyboom/trunk/common/protocol.py	2005-09-14 07:26:40 UTC (rev 160)
@@ -1,3 +1,7 @@
+"""
+Tools to load HappyBoom protocol in Python from an XML description file.
+"""
+
 import xml.dom.minidom
 
 class ProtocolException(Exception):

Copied: happyboom/trunk/common/simple_event.py (from rev 157, boomboom/common/simple_event.py)

Added: happyboom/trunk/common/thread.py
===================================================================
--- happyboom/trunk/common/thread.py	2005-09-14 06:53:25 UTC (rev 159)
+++ happyboom/trunk/common/thread.py	2005-09-14 07:26:40 UTC (rev 160)
@@ -0,0 +1,6 @@
+import traceback, sys
+
+def getBacktrace():
+    bt = traceback.format_exception( \
+        sys.exc_type, sys.exc_value, sys.exc_traceback)
+    return "".join(bt)



From haypo at berlios.de  Wed Sep 14 09:27:35 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 09:27:35 +0200
Subject: [Happyboom-svn] r161 - in boomboom: . client common
Message-ID: <200509140727.j8E7RZOm017072@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 09:27:34 +0200 (Wed, 14 Sep 2005)
New Revision: 161

Added:
   boomboom/COPYING
Removed:
   boomboom/common/simple_event.py
Modified:
   boomboom/boomboom_client.py
   boomboom/boomboom_server.py
   boomboom/client/bb_client.py
   boomboom/client/bb_display.py
   boomboom/client/bb_input.py
   boomboom/protocol.xml
Log:
Small changes in argument for __init__


Added: boomboom/COPYING
===================================================================
--- boomboom/COPYING	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/COPYING	2005-09-14 07:27:34 UTC (rev 161)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/boomboom_client.py	2005-09-14 07:27:34 UTC (rev 161)
@@ -61,6 +61,17 @@
             val["debug"] = True
     return val
 
+def run(arg):
+    from client import BoomBoomClient
+    client = BoomBoomClient(arg)
+    try:
+        client.start()
+    except KeyboardInterrupt:
+        print "Program interrupted (CTRL+C)."
+        pass
+    client.stop()
+    print "Classic stop."
+
 def main():
     # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
     import sys, os
@@ -80,15 +91,8 @@
 
     # Create the client
     import pygame
-    from client import BoomBoomClient
-    client = BoomBoomClient(arg["host"], arg["view_port"], arg["input_port"],\
-                            arg["verbose"], arg["debug"], arg["max_fps"])
-    try:
-        client.start()
-    except KeyboardInterrupt:
-        print "Program interrupted (CTRL+C)."
-        pass
-    client.stop()
+    run(arg)
+    print "pygame.quit()"
     pygame.quit()
 
 if __name__=="__main__": main()

Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/boomboom_server.py	2005-09-14 07:27:34 UTC (rev 161)
@@ -6,6 +6,7 @@
 import getopt
 import sys
 from happyboom.common.protocol import loadProtocol
+from happyboom.common.log import log
 
 def usage(defval):
     print "%s server version %s" % (PROGRAM, VERSION)
@@ -64,42 +65,44 @@
             val["debug"] = True
     return val
 
-def run():
+def main():
     # Add HappyBoom to PYTHONPATH
     import sys, os
     file_dir = os.path.dirname(__file__)
     happyboomdir = os.path.join(file_dir, "..", "happyboom", "trunk")
     sys.path.append(happyboomdir)
     
-    # Add HappyBoom/common to PYTHONPATH
-#    happyboomserverdir = os.path.join(happyboomdir, "common")
-#    sys.path.append(happyboomserverdir)
-    
-     # Add HappyBoom/server to PYTHONPATH
-#    happyboomserverdir = os.path.join(happyboomdir, "server")
-#    sys.path.append(happyboomserverdir)
-    
+    # Get user directory 
+    from happyboom.common.file import getCreateHomeDir
+    logdir = getCreateHomeDir("boomboom")
+
+    # Setup log filename
+    from happyboom.common.log import log
+    if logdir != None:
+        logname = os.path.join(logdir, "server-log")    
+        log.setFilename(logname)
+   
+    # Read command line arguments
     val = { \
         "input_port": 12430,
         "max_clients": 4,
         "verbose": False,
         "debug": False}
     arg = parseArgs(val)
-    
+   
+    # Create BoomBoom server
     from server.bb_server import Server
     protocol = loadProtocol("protocol.xml")
     server = Server(protocol, arg)
 
+    # Main loop
     try:
         server.start()
     except KeyboardInterrupt:
+        log.info("Program interrupted (CTRL+C).")
         pass
+    
+    # Stop the server
     server.stop()
 
-def main():
-    try:
-        run()
-    except KeyboardInterrupt:
-        print "Program interrupted (CTRL+C)."
-
 if __name__=="__main__": main()

Modified: boomboom/client/bb_client.py
===================================================================
--- boomboom/client/bb_client.py	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/client/bb_client.py	2005-09-14 07:27:34 UTC (rev 161)
@@ -25,7 +25,7 @@
     @type __stoplock: C{thread.lock}
     """
     
-    def __init__(self, host, display_port, input_port, verbose=False, debug=False, max_fps=25):
+    def __init__(self, arg):
         """ BoomBoomClient constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -42,9 +42,9 @@
         """
         EventListener.__init__(self, prefix="evt_")
         
-        self.display = BoomBoomDisplay(host, display_port, verbose=verbose, debug=debug, max_fps=max_fps)
-        self.input = BoomBoomInput(host, input_port, verbose=verbose, debug=debug)
-        self.__verbose = verbose
+        self.display = BoomBoomDisplay(arg)
+        self.input = BoomBoomInput(arg)
+        self.__verbose = arg.get("verbose", False)
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/client/bb_display.py	2005-09-14 07:27:34 UTC (rev 161)
@@ -38,7 +38,7 @@
     @type __stoplock: C{thread.lock}
     """
     
-    def __init__(self, host, port=12430, name="no name", verbose=False, debug=False, max_fps=25):
+    def __init__(self, arg):
         """ BoomBoomDisplay constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -55,16 +55,16 @@
         """
         EventLauncher.__init__(self)
         EventListener.__init__(self, prefix="evt_")
-        self.drawer = BoomBoomDrawer(max_fps)
-        self.host = host
-        self.port = port
-        self.name = name
+        self.drawer = BoomBoomDrawer(arg.get("max_fps", 25))
+        self.host = arg.get("host", "localhost")
+        self.port = arg.get("display_port", 12430)
+        self.name = arg.get("name", "no name")
         self.__protocol_version = "0.1.4"
         self.__io = io_tcp.IO_TCP()
-        self.__verbose = verbose
-        self.__io.verbose = verbose
-        self.__debug = debug
-        self.__io.debug = debug
+        self.__verbose = arg.get("verbose", False)
+        self.__io.verbose = self.__verbose
+        self.__debug = arg.get("debug", False)
+        self.__io.debug = self.__debug
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/client/bb_input.py	2005-09-14 07:27:34 UTC (rev 161)
@@ -36,7 +36,7 @@
     @type __stoplock: C{thread.lock}
     """
     
-    def __init__(self, host, port=12431, name="-", verbose=False, debug=False):
+    def __init__(self, arg):
         """ BoomBoomInput constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -49,16 +49,17 @@
         @param debug: Debug mode flag.
         @type debug: C{bool}
         """
+
         EventLauncher.__init__(self)
-        self.host = host
-        self.port = port
-        self.name = name
+        self.host = arg.get("host", "localhost")
+        self.port = arg.get("input_port", 12431)
+        self.name = arg.get("name", "no name")
         self.__io = io_tcp.IO_TCP()
         self.__recv_buffer = net_buffer.NetBuffer()
-        self.__verbose = verbose
-        self.__io.verbose = verbose
-        self.__debug = debug
-        self.__io.debug = debug
+        self.__verbose = arg.get("verbose", False)
+        self.__io.verbose = self.__verbose
+        self.__debug = arg.get("debug", False)
+        self.__io.debug = self.__debug
         self.__protocol_version = "0.1.4"
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()

Deleted: boomboom/common/simple_event.py
===================================================================
--- boomboom/common/simple_event.py	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/common/simple_event.py	2005-09-14 07:27:34 UTC (rev 161)
@@ -1,175 +0,0 @@
-"""
-Module to use event-system very easily.
- at author: Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 1.0
-"""
-class EventManager:
-    """ Manages the event-system.
-    This class is instanciated on importing the module,
-    so it is not needed to use it directly but via EventLaunch and EventListener.
-    @cvar instance: The instance created on importing the module.
-    @type instance: C{L{EventManager}}
-    @ivar listeners: Dictionnary with keys of type C{str} representing a event type and with values of type C{list} representing a collection of C{EventListener}.
-    @type listeners: C{dict<str, list<L{EventListener}>>}
-    """
-    def __init__(self):
-        """ EventManager constructor. """
-        EventManager.instance = self
-        self.listeners = {}
-        
-    def addListener(self, obj, event_type):
-        """ Add a listener to a specific event.
-        @param obj: Listener to add.
-        @type obj: C{L{EventListener}}
-        @param event_type: Type of the event to listen.
-        @type event_type: C{str}
-        """
-        if event_type in self.listeners and obj not in self.listeners[event_type]:
-            self.listeners[event_type].append(obj)
-        else:
-            self.listeners[event_type] = [obj]
-    
-    def removeListener(self, obj, event_type):
-        """ Remove a listener from a specific event.
-        @param obj: Listener to remove.
-        @type obj: C{L{EventListener}}
-        @param event_type: Type of the event that was listening.
-        @type event_type: C{str}
-        """
-        if event_type in self.listeners and obj in self.listeners[event_type]:
-            self.listeners[event_type].remove(obj)
-    
-    def dispatchEvent(self, event):
-        """ Dispatch a launched event to all affected listeners.
-        @param event: Event launched.
-        @type event: C{L{Event}}
-        """
-        if event.type in self.listeners:
-            for obj in self.listeners[event.type]:
-                # Try to call event-specific handle method
-                fctname = obj.pattern %(event.type)
-                if hasattr(obj, fctname):
-                    function = getattr(obj, fctname)
-                    if callable(function):
-                        function(event)
-                        continue
-                # Try to call default handle method
-                if hasattr(obj, obj.default):
-                    function = getattr(obj, obj.default)
-                    if callable(function):
-                        function(event)
-                        continue
-                # No handle method found, raise error ?
-                if not obj.silent:
-                    raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
-
-EventManager()
-
-    
-class EventListener:
-    """ Generic class for listening to events.
-    
-    It is just needed to herite from this class and register to events to listen easily events.
-    It is also needed to write handler methods with event-specific and/or C{L{default}} function.
-    
-    Event-specific functions have name as the concatenation of the C{prefix} parameter + the listened event type + the C{suffix} parameter.
-    
-    If it does not exist, the default function is called as defined by the C{L{default}} parameter/attribute.
-    
-    If the event cannot be handled, a C{L{UnhandledEventError}} is raised, except if C{L{silent}} flag is C{True}.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    @ivar pattern: Event-specific handler pattern.
-    @type pattern: C{str}
-    @ivar default: Default handler function name.
-    @type default: C{str}
-    @ivar silent: Silent flag. If C{False}, C{L{UnhandledEventError}} is raised if an event cannot be handled. If C{True}, do nothing, listener does not handle the event.
-    @type silent: C{str}
-    """
-    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
-        """ EventListener constructor.
-        @param prefix: Prefix for all event-specific handler function name.
-        @type prefix: C{str}
-        @param suffix: Suffix for all event-specific handler function name.
-        @type suffix: C{str}
-        @param default: Default handler function name.
-        @type default: C{str}
-        @param silent: Silent flag.
-        @type silent: C{bool}
-        """
-        self.manager = EventManager.instance
-        self.pattern = prefix + "%s" + suffix
-        self.default = default
-        self.silent = silent
-        
-    def registerEvent(self, event_type):
-        """ Registers itself to a new event.
-        @param event_type: Type of the event to listen.
-        @type event_type: C{str}
-        """
-        self.manager.addListener(self, event_type)
-        
-    def unregisterEvent(self, event_type):
-        """ Unregisters itself from a event.
-        @param event_type: Type of the event which was listening.
-        @type event_type: C{str}
-        """
-        self.manager.removeListener(self, event_type)
-
-
-class EventLauncher:
-    """ Generic class for launching events.
-    It is just needed to herite from this class to launch easily events.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    """
-    def __init__(self):
-        """ EventLauncher constructor. """
-        self.manager = EventManager.instance
-        
-        
-    def launchEvent(self, event_type, content=None):
-        """ Launches a new event to the listeners.
-        @param event_type: Type of the event to launch.
-        @type event_type: C{str}
-        @param content: Content to attach with the event (Optional).
-        @type content: any
-        """
-        self.manager.dispatchEvent(Event(event_type, self, content))
-    
-    
-class Event:
-    """ Represents an event entity.
-    @ivar type: Type of the event.
-    @type type: C{str}
-    @ivar source: Instance which launched the event.
-    @type source: C{L{EventLauncher}}
-    @ivar content: Content attached to the event (C{None} if none).
-    @type content: any
-    """
-    def __init__(self, type, source, content):
-        """ Event constructor.
-        @param type: Type of the event.
-        @type type: C{str}
-        @param source: Instance which launched the event.
-        @type source: C{L{EventLauncher}}
-        @param content: Content attached to the event (C{None} if none).
-        @type content: any
-        """
-        self.type = type
-        self.source = source
-        self.content = content
-    
-    def __str__(self):
-        """ Converts object itself to string.
-        @return: Object converted string.
-        @rtype: C{str}
-        """
-        return "<bb_events.BoomBoomEvent type=%s source=%s content=%s>" %(self.type, self.source, self.content)
-    
-    
-class UnhandledEventError(AttributeError):
-    """ Error raised when an event cannot be handled, except if C{L{silent<EventListener.silent>}} flag is C{True}. """
-    pass
\ No newline at end of file

Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-14 07:26:40 UTC (rev 160)
+++ boomboom/protocol.xml	2005-09-14 07:27:34 UTC (rev 161)
@@ -34,7 +34,7 @@
   </feature>
   
   <feature name="chat" id="5">
-    <event name="mesage" id="1">
+    <event name="message" id="1">
       <param type="utf8" name="text" />
     </event>
   </feature>



From haypo at berlios.de  Wed Sep 14 12:47:39 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 14 Sep 2005 12:47:39 +0200
Subject: [Happyboom-svn] r162 - boomboom boomboom/client boomboom/server boomboom/server/agents happyboom/trunk/common happyboom/trunk/net/io happyboom/trunk/net/io_tcp happyboom/trunk/server happywarry
Message-ID: <200509141047.j8EAld39025710@sheep.berlios.de>

Author: haypo
Date: 2005-09-14 12:47:34 +0200 (Wed, 14 Sep 2005)
New Revision: 162

Modified:
   boomboom/boomboom_client.py
   boomboom/boomboom_server.py
   boomboom/client/bb_client.py
   boomboom/client/bb_constructor.py
   boomboom/client/bb_display.py
   boomboom/client/bb_drawer.py
   boomboom/client/bb_events.py
   boomboom/client/bb_input.py
   boomboom/client/bb_item.py
   boomboom/protocol.xml
   boomboom/server/agents/projectile.py
   boomboom/server/bb_server.py
   happyboom/trunk/common/log.py
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/common/protocol.py
   happyboom/trunk/common/simple_event.py
   happyboom/trunk/net/io/base_io.py
   happyboom/trunk/net/io/packet.py
   happyboom/trunk/net/io_tcp/tcp.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/base_server.py
   happyboom/trunk/server/client.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
   happywarry/happywarry-server.py
Log:
Client and server can exchange events.


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/boomboom_client.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -16,8 +16,7 @@
     print "\t--help            : Print this help"
     print "\t--version         : Print the software version"
     print "\t-h,--host HOST    : Server ip/name (default %s)" % (defval["host"])
-    print "\t--view-port PORT  : Server view port (default %u)" % (defval["view_port"])
-    print "\t--input-port PORT : Server input port (default %u)" % (defval["input_port"])
+    print "\t--port PORT       : Server port (default %u)" % (defval["port"])
     print "\t-d,--debug        : Enable debug mode"
     print "\t-v,--verbose      : Enable verbose mode"
     print "\t--max-fps MAX     : Set maximum frame par second (fps)"
@@ -44,10 +43,8 @@
             sys.exit()
         if o == "--version":
             print "%s version %s" % (PROGRAM, VERSION)
-        if o == "--input-port":
-            val["input_port"] = int(a)
-        if o == "--view-port":
-            val["view_port"] = int(a)
+        if o == "--port":
+            val["port"] = int(a)
         if o in ("-h", "--host",):
             val["host"] = a
         if o in ("-v", "--verbose",):
@@ -62,15 +59,19 @@
     return val
 
 def run(arg):
+    from happyboom.common.protocol import loadProtocol
     from client import BoomBoomClient
-    client = BoomBoomClient(arg)
+    from client.bb_display import BoomBoomDisplay
+
+    protocol = loadProtocol("protocol.xml")
+    display = BoomBoomDisplay(protocol, arg)
+    client = BoomBoomClient(display, arg)
     try:
         client.start()
     except KeyboardInterrupt:
         print "Program interrupted (CTRL+C)."
         pass
     client.stop()
-    print "Classic stop."
 
 def main():
     # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
@@ -81,8 +82,7 @@
  
     val = {
         "host": "127.0.0.1", \
-        "view_port": 12430, \
-        "input_port": 12431, \
+        "port": 12430, \
         "max_fps": 50, \
         "verbose": False, \
         "name": "-", \
@@ -92,7 +92,6 @@
     # Create the client
     import pygame
     run(arg)
-    print "pygame.quit()"
     pygame.quit()
 
 if __name__=="__main__": main()

Modified: boomboom/boomboom_server.py
===================================================================
--- boomboom/boomboom_server.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/boomboom_server.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -5,8 +5,6 @@
 
 import getopt
 import sys
-from happyboom.common.protocol import loadProtocol
-from happyboom.common.log import log
 
 def usage(defval):
     print "%s server version %s" % (PROGRAM, VERSION)
@@ -71,7 +69,7 @@
     file_dir = os.path.dirname(__file__)
     happyboomdir = os.path.join(file_dir, "..", "happyboom", "trunk")
     sys.path.append(happyboomdir)
-    
+
     # Get user directory 
     from happyboom.common.file import getCreateHomeDir
     logdir = getCreateHomeDir("boomboom")
@@ -92,6 +90,7 @@
    
     # Create BoomBoom server
     from server.bb_server import Server
+    from happyboom.common.protocol import loadProtocol
     protocol = loadProtocol("protocol.xml")
     server = Server(protocol, arg)
 

Modified: boomboom/client/bb_client.py
===================================================================
--- boomboom/client/bb_client.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_client.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -4,10 +4,8 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from common import simple_event
-from common.simple_event import EventListener
+from happyboom.common.simple_event import EventListener
 import bb_events
-from bb_display import BoomBoomDisplay
 from bb_input import BoomBoomInput
 import thread, time, traceback, pygame
 
@@ -25,7 +23,7 @@
     @type __stoplock: C{thread.lock}
     """
     
-    def __init__(self, arg):
+    def __init__(self, display, arg):
         """ BoomBoomClient constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -42,7 +40,7 @@
         """
         EventListener.__init__(self, prefix="evt_")
         
-        self.display = BoomBoomDisplay(arg)
+        self.display = display
         self.input = BoomBoomInput(arg)
         self.__verbose = arg.get("verbose", False)
         self.__stopped = False
@@ -58,11 +56,10 @@
         
         # Create thread for input and display
         thread.start_new_thread(self.thread_display, ())
-        thread.start_new_thread(self.thread_input, ())
 
         quit = False
         while not quit:
-            # Wait for Keyboard Interrupt
+            self.input.process()
             time.sleep(0.100)
             quit = self.is_stopped
         
@@ -78,7 +75,6 @@
         
         if self.__verbose: print "[CLIENT] Stopping client..."
         self.display.stop()
-        self.input.stop()
     
     def evt_game_Stop(self, event):
         """ Stop event handler.
@@ -91,9 +87,14 @@
         """ Thread handler for the "display" part."""
         try:
             self.display.start()
-        except:
+        except Exception, msg:
+            print "EXCEPTION IN DISPLAY THREAD:\n%s" % msg
             traceback.print_exc()
-        self.stop()
+        try:
+            self.stop()
+        except Exception, msg:
+            print "EXCEPTION IN DISPLAY THREAD:\n%s" % msg
+            traceback.print_exc()
         
     def thread_input(self):
         """ Thread handler for the "input" part."""

Modified: boomboom/client/bb_constructor.py
===================================================================
--- boomboom/client/bb_constructor.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_constructor.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -4,8 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from common import simple_event
-from common.simple_event import EventListener
+from happyboom.common.simple_event import EventListener
 import bb_events
 from items import Sun, Projectile, Weapon, World, Character
 
@@ -65,4 +64,4 @@
         @param event: Event with "agent_manager_Text" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        print "[DISPLAY] Server message: %s" %(event.content)
\ No newline at end of file
+        print "[DISPLAY] Server message: %s" %(event.content)

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_display.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -4,12 +4,13 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from common import simple_event
-from common.simple_event import EventLauncher, EventListener
+from happyboom.common.presentation import Presentation
+from happyboom.common.simple_event import EventLauncher, EventListener
 import bb_events
 from bb_drawer import BoomBoomDrawer
 from bb_constructor import BoomBoomConstructor
 from net import io
+from happyboom.net.io import Packet
 from net import io_udp, io_tcp
 import thread
 
@@ -38,7 +39,7 @@
     @type __stoplock: C{thread.lock}
     """
     
-    def __init__(self, arg):
+    def __init__(self, protocol, arg):
         """ BoomBoomDisplay constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -55,11 +56,13 @@
         """
         EventLauncher.__init__(self)
         EventListener.__init__(self, prefix="evt_")
+        self.launchEvent("x")
+        self.presentation = Presentation(protocol, False)
         self.drawer = BoomBoomDrawer(arg.get("max_fps", 25))
         self.host = arg.get("host", "localhost")
-        self.port = arg.get("display_port", 12430)
+        self.port = arg.get("port", 12430)
         self.name = arg.get("name", "no name")
-        self.__protocol_version = "0.1.4"
+        self.__protocol = protocol
         self.__io = io_tcp.IO_TCP()
         self.__verbose = arg.get("verbose", False)
         self.__io.verbose = self.__verbose
@@ -68,8 +71,7 @@
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         
-        self.registerEvent(bb_events.askVersion)
-        self.registerEvent(bb_events.askName)
+        self.registerEvent(bb_events.shoot)
         
     def start(self):
         """ Starts the display client : connection to the server, etc. """
@@ -78,13 +80,14 @@
         self.__io.on_connect = self.onConnect
         self.__io.on_connection_fails = self.onConnectionFails
         self.__io.on_disconnect = self.onDisconnect
-        self.__io.on_new_packet = self.processPacket
+        self.__io.on_new_packet = self.presentation.processPacket
         self.__io.on_lost_connection = self.onLostConnection
         self.__io.connect(self.host, self.port)
         if not self.__io.is_ready: return
         thread.start_new_thread(self.__io.run_thread, ())
     
         BoomBoomConstructor()
+        self.__io.send(self.presentation.connectionPacket())
         print "==== BoomBoom ===="
         self.drawer.start()
         
@@ -93,7 +96,9 @@
         self.__stoplock.acquire()
         self.__stopped = True
         self.__stoplock.release()
-        self.send("quit")
+        # TODO: clean "bye"
+        packet = self.presentation.disconnectionPacket(u"Quit.")
+        self.__io.send(packet)
         self.__io.stop()
         if self.__verbose: print "[DISPLAY] Stopped"
         
@@ -125,56 +130,18 @@
         print "[DISPLAY] Lost connection with server"
         self.launchEvent(bb_events.stop)
     
-    def str2evt(self, str):
-        """ Utility method to convert incomming network message string to local event.
-        @param str: incomming network message string to convert.
-        @type str: C{str}
-        @return: A couple containing the event type and its optional argument for representing a local event to send.
-        @rtype: C{(str, str)}
-        """
-        import re
-        # Ugly regex to parse string
-        r = re.compile("^([^:]+):([^:]+)(:(.*))?$")
-        regs = r.match(str)
-        if regs == None: return (None, None)
-        role = regs.group(1)
-        type = regs.group(2)
-        if 2<regs.lastindex:
-            arg = regs.group(4)
-        else:
-            arg = None
-        event_type = "%s_%s" %(role, type)
-        return (event_type, arg)
-        
-    def processPacket(self, new_packet):
-        """ Processes incomming network packets (converts and launches local event).
-        @param new_packet: incomming network packet.
-        @type new_packet: C{net.io.packet.Packet}
-        """
-        event_type, arg = self.str2evt(new_packet.data)
-        if event_type != None: 
-            if self.__debug: print "Received message: type=%s arg=%s" %(event_type, arg)
-            self.launchEvent(event_type, arg)
-            
-    def send(self, str):
+    def send(self, feature, event, *args):
         """ Sends a string to the network server.
         @param str: String to send.
         @type str: C{str}
         """
-        p = io.Packet()
-        p.writeStr(str)
-        self.__io.send(p)
+        data = self.__protocol.createMsg(feature, event, *args)
+        data = self.presentation.sendMsg(data)
+        self.__io.send(Packet(data))
+
+    def evt_x(self, event):
+        print "x"
         
-    def evt_agent_manager_AskVersion(self, event):
-        """ AskVersion event handler (when server asks for client version).
-        @param event: Event with "agent_manager_AskVersion" type
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.send(self.__protocol_version)
-        
-    def evt_agent_manager_AskName(self, event):
-        """ AskName event handler (when server asks for client name).
-        @param event: Event with "agent_manager_AskName" type
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.send(self.name)
+    def evt_weapon_shoot(self, event):
+        print "Shoot aussi"
+        self.send("weapon", "shoot")

Modified: boomboom/client/bb_drawer.py
===================================================================
--- boomboom/client/bb_drawer.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_drawer.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -4,8 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from common import simple_event
-from common.simple_event import EventListener
+from happyboom.common.simple_event import EventListener
 import bb_events
 import pygame, time
 

Modified: boomboom/client/bb_events.py
===================================================================
--- boomboom/client/bb_events.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_events.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -3,6 +3,8 @@
 nextTurn = "game_next_turn"
 activeCharacter = "game_active_character"
 
+shoot = "weapon_shoot"
+
 create = "agent_manager_Create"
 text = "agent_manager_Text"
 askVersion = "agent_manager_AskVersion"
@@ -20,4 +22,4 @@
 characterMove = "character_move"
 
 visibleItem = "graphical_item"
-activeCharAbs = "active_character_abscisse"
\ No newline at end of file
+activeCharAbs = "active_character_abscisse"

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_input.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -4,8 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from common import simple_event
-from common.simple_event import EventLauncher
+from happyboom.common.simple_event import EventLauncher
 import bb_events
 from net import io
 from net import io_udp, io_tcp
@@ -51,167 +50,11 @@
         """
 
         EventLauncher.__init__(self)
-        self.host = arg.get("host", "localhost")
-        self.port = arg.get("input_port", 12431)
-        self.name = arg.get("name", "no name")
-        self.__io = io_tcp.IO_TCP()
-        self.__recv_buffer = net_buffer.NetBuffer()
-        self.__verbose = arg.get("verbose", False)
-        self.__io.verbose = self.__verbose
-        self.__debug = arg.get("debug", False)
-        self.__io.debug = self.__debug
-        self.__protocol_version = "0.1.4"
-        self.__stopped = False
-        self.__stoplock = thread.allocate_lock()
         
-    def start(self):
-        """ Starts the input client : connection to the server, etc. """
-        # Try to connect to server
-        if self.__verbose: print "[INPUT] Trying to connect to server %s:%s" % (self.host, self.port)
-        self.__io.on_connect = self.onConnect
-        self.__io.on_connection_fails = self.onConnectionFails
-        self.__io.on_disconnect = self.onDisconnect
-        self.__io.on_lost_connection = self.onLostConnection
-        self.__io.on_new_packet = self.processPacket
-        self.__io.connect(self.host, self.port)
-        if not self.__io.is_ready: return
-        thread.start_new_thread( self.__io.run_thread, ())
-        
-        stopped = False
-        # Server "challenge" (version, name, ...)
-        if self.serverChallenge() != True:
-            self.__stoplock.acquire()
-            stopped = self.__stopped
-            self.__stoplock.release()
-            if not stopped:
-                print "[INPUT] Server communication mistake !?"
-                self.launchEvent(bb_events.stop)
-            return
-
-        thread.start_new_thread(self.runIo, ())
-        
-        while not stopped:
-            for input_event in pygame.event.get():
-                self.process_event(input_event)
-            time.sleep(0.020)
-            self.__stoplock.acquire()
-            stopped = self.__stopped
-            self.__stoplock.release()
-        
-    def stop(self):
-        """ Stops the input client : disconnection from the server, etc. """
-        self.__stoplock.acquire()
-        self.__stopped = True
-        self.__stoplock.release()
-        self.__io.stop()
-        if self.__verbose: print "[INPUT] Stopped"
-        
-    def processPacket(self, new_packet):
-        """ Bufferizes incomming packets.
-        @param new_packet: Incomming network packet.
-        @type new_packet: C{net.io.packet.Packet}
-        """
-        self.__recv_buffer.append(0,new_packet.data)
-    
-    def readCmd(self, timeout=1.000):
-        """ Reads incomming commands via the reception buffer.
-        @param timeout: Timeout to unblock the function.
-        @type timeout: C{float}
-        @return: Command read if timeout didn't perform.
-        @rtype: C{str}
-        """
-        return self.__recv_buffer.readBlocking(0,timeout)
-        
-    def sendCmd(self, cmd):
-        """ Sends a command to the network server.
-        @param cmd: Command to send.
-        @type cmd: C{str}
-        """
-        self.__io.send(io.Packet(cmd))
-        
-    def processCmd(self, cmd):
-        """ Sends only non empty-string command.
-        @param cmd: Command to send.
-        @type cmd: C{str}
-        """
-        if cmd != "": self.sendCmd(cmd)
-        
-    def serverChallenge(self):
-        """ Negociate initialisation with the network server. """
-        if self.__verbose: print "[INPUT] Start server challenge (send version, send name, ...)."
-
-        cmd = self.readCmd()
-        if cmd==None: return False
-        if cmd != "Version?": 
-            if self.__debug: print "[INPUT] Server answer: %s instead of Version?" % (cmd)
-            return False
-        self.sendCmd(self.__protocol_version)
-        
-        cmd = self.readCmd()
-        if cmd==None: return False
-        if cmd != "OK":
-            if self.__debug: print "[INPUT] Server answer: %s instead of OK" % (cmd)
-            return False
-        
-        cmd = self.readCmd()
-        if cmd==None: return False
-        if cmd != "Name?":
-            if self.__debug: print "[INPUT] Server answer: %s instead of Name?" % (cmd)
-            return False
-        self.sendCmd(self.name)
-
-        if self.__debug: print "[INPUT]Challenge: Wait Name OK"
-        cmd = self.readCmd()
-        if cmd==None: return False
-        if cmd != "OK":
-            if self.__debug: print "[INPUT] Server answer: %s instead of OK" % (cmd)
-            return False
-        if self.__verbose: print "[INPUT] Server challenge done successfully"
-        return True
-        
-    def runIo(self):
-        """ Waits for a quit command from server. """
-        while 1:
-            cmd = self.__recv_buffer.readNonBlocking(0)
-            while cmd != None:
-                if cmd == "quit":
-                    self.launchEvent(bb_events.stop)
-                    break
-                cmd = self.__recv_buffer.readNonBlocking(0)
-            time.sleep(0.250)
-            
-    def onConnect(self):
-        """ Handler called on network connection. """
-        if self.__verbose: print "[INPUT] Connected to the server"
-        
-    def onConnectionFails(self):
-        """ Handler called when network connection fails. """
-        print "[INPUT] Fail to connect to the server"
-            
-    def onDisconnect(self):
-        """ Handler called on network disconnection. """
-        print "[INPUT] Disconnected from server"
-        self.launchEvent(bb_events.stop)
-
-    def onLostConnection(self):
-        """ Handler called on losting network connection. """
-        print "[INPUT] Lost connection with server"
-        self.launchEvent(bb_events.stop)
-            
-    def process_event_active(self, event):
-        """ Manages when a pygame event is caught and interact with the server.
-        @param event: Pygame event.
-        @type event: C{pygame.Event}
-        """
-        #delta_angle = -30
-        if event.type == pygame.KEYDOWN: 
-            # arrow keys: move character
-            if event.key == 32: self.sendCmd("shoot")
-            elif event.key == 275: self.sendCmd("move_right")
-            elif event.key == 273: self.sendCmd("move_up") 
-            elif event.key == 274: self.sendCmd("move_down")
-            elif event.key == 276: self.sendCmd("move_left")
-
+    def process(self):
+        for input_event in pygame.event.get():
+            self.process_event(input_event)
+           
     def process_event(self, event):
         """ Manages when a pygame event is caught.
         @param event: Pygame event.
@@ -228,3 +71,22 @@
         #character = self.client.view.getActiveCharacter()
         #if character != None: self.process_event_active(character, event)
         self.process_event_active(event)
+
+    def sendCmd(self, cmd):
+        self.x.sendNetMsg("input", cmd)
+
+    def process_event_active(self, event):
+        """ Manages when a pygame event is caught and interact with the server.
+        @param event: Pygame event.
+        @type event: C{pygame.Event}
+        """
+        #delta_angle = -30
+        if event.type == pygame.KEYDOWN: 
+            # arrow keys: move character
+            if event.key == 32:
+                print "Event %s" % bb_events.shoot
+                self.launchEvent(bb_events.shoot)
+            elif event.key == 275: self.sendCmd("move_right")
+            elif event.key == 273: self.sendCmd("move_up") 
+            elif event.key == 274: self.sendCmd("move_down")
+            elif event.key == 276: self.sendCmd("move_left")

Modified: boomboom/client/bb_item.py
===================================================================
--- boomboom/client/bb_item.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/client/bb_item.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -4,8 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from common import simple_event
-from common.simple_event import EventListener, EventLauncher
+from happyboom.common.simple_event import EventListener, EventLauncher
 import bb_events
 import pygame
 
@@ -29,7 +28,6 @@
         """
         if self.visual == None: return
         self.visual.draw(screen)
-        
 
 class VisualObject(object):
     """ Manage representation and transformation of an external image to be drawn into game screen.

Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/protocol.xml	2005-09-14 10:47:34 UTC (rev 162)
@@ -25,10 +25,11 @@
   </feature>
   
   <feature name="weapon" id="4">
-    <event name="setAngle" id="1">
+    <event name="shoot" id="1" />
+    <event name="setAngle" id="2">
       <param type="int" name="angle" />
     </event>
-    <event name="setStrength" id="2">
+    <event name="setStrength" id="3">
       <param type="int" name="angle" />
     </event>
   </feature>

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/server/agents/projectile.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -1,4 +1,5 @@
 from server.bb_agent import Agent, Message
+from happyboom.common.log import log
 import time
 import math
 
@@ -30,8 +31,8 @@
     def msg_weapon_angle(self, angle):
         self.weapon_angle = (-int(angle)) * math.pi / 180
 
-    def msg_new_command(self, cmd):
-        if cmd == "shoot" and not self.active:
+    def msg_weapon_shoot(self, cmd):
+        if not self.active:
             self.shoot()
 
     def msg_character_active_coord(self, x, y):
@@ -46,8 +47,10 @@
         self.sendNetMsg("projectile", "activate", 0) 
 
     def shoot(self):
+        log.info("Shoot!")
         if self.weapon_angle==None: return
         if self.weapon_strength==None: return
+        if self.start_pos==None: return
         self.move(self.start_pos[0], self.start_pos[1])
         self.setActive(True)
         self.time = time.time()

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-14 07:27:34 UTC (rev 161)
+++ boomboom/server/bb_server.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -1,3 +1,4 @@
+from happyboom.common.presentation import Presentation
 from happyboom.server.base_server import \
     Server as HBServer, \
     Gateway as HBGateway, \
@@ -8,8 +9,8 @@
 from happyboom.common.log import log
 
 class Gateway(HBGateway):
-    def __init__(self, protocol, manager, arg):
-        HBGateway.__init__(self, protocol, manager, arg)
+    def __init__(self, protocol, presentation, manager, arg):
+        HBGateway.__init__(self, protocol, presentation, manager, arg)
 
     def born(self):
         HBGateway.born(self)
@@ -41,6 +42,7 @@
 class Server(HBServer):
     def __init__(self, protocol, arg):
         manager = ClientManager(arg)
-        gateway = Gateway(protocol, manager, arg)
+        presentation = Presentation(protocol, True)
+        gateway = Gateway(protocol, presentation, manager, arg)
         manager.gateway = gateway
         HBServer.__init__(self, gateway, arg)

Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/common/log.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -52,7 +52,7 @@
         @param str: Message content.
         @type str: C{str}
         """
-        
+
         if not self.__buffer.has_key(level):
             self.__buffer[level] = [str]
         else:

Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/common/packer.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -11,7 +11,7 @@
     elif datatype=="bin":
         return true
     elif datatype=="utf8":
-        return type(data)==types.unicode
+        return type(data)==types.UnicodeType
     else:
         raise PackerException("Wrong argument type: %s" % datatype)
 
@@ -23,10 +23,11 @@
     return struct.pack("!i", data)
     
 def packUtf8(data):
-    assert type(data)==types.unicode, "packUtf8 argument have to be Unicode"
+    assert type(data)==types.UnicodeType, "packUtf8 argument have to be an unicode string"
     return packBin(data.encode("utf-8"))
 
 def packBin(data):
+    assert type(data)==types.StringType, "packBin argument have to be a string"
     return struct.pack("!H%us" % len(data), len(data), data)
 
 def pack(func, event, types, values):
@@ -38,7 +39,7 @@
     """
 
     assert len(types) == len(values), "Lengths of types and args have to be the same."
-    out = struct.pack("!HH", func, event)
+    out = struct.pack("!BB", func, event)
 
     #TODO: Fix this :-)
     for i in range(len(values)):
@@ -57,37 +58,40 @@
         out = out + data
     return out        
 
-def unpackBin(data):
+def unpackBin(data):        
     fmt = "!H"
     i = struct.calcsize(fmt)
-    strlen, data = struct.unpack(fmt, data[:i]), data[i:]
-    fmt = "!%ss" %(strlen)
+    version_len, = struct.unpack(fmt, data[:i])
+    data = data[i:]
+    fmt = "!%us" %(version_len)
     i = struct.calcsize(fmt)
-    return (struct.unpack(fmt, data[:i]), data[i:])
-    
+    bin, = struct.unpack(fmt, data[:i])
+    return bin, data[i:]
+
+def unpackUtf8(data):
+    str, data = unpackBin(data)
+    str = unicode(str, "UTF-8")
+    return str, data
+ 
 def unpackInt(data):
     fmt = "!i"
     i = struct.calcsize(fmt)
-    return (struct.unpack(fmt, data[:i]), data[i:])
+    value = struct.unpack(fmt, data[:i])
+    return value, data[i:]
 
-def unpack(data, protocol):
+def unpack(data, feature_id, event_id, protocol):
     """
     Unpack binary string to arguments.
     """
-    fmt = "!HH"
-    i = struct.calcsize(fmt)
-    feat_id, evt_id = struct.unpack(fmt, data[:i])
-    data = data[i:]
+    feat = protocol.getFeatureById(feature_id)
+    evt = feat.getEventById(event_id)
     args = []
-    feat = protocol.getFeature(feat_id)
-    evt = feat.getEvent(evt_id)
     for type in evt.getParamTypes():
         if type=="int":
-            arg, tail = unpackInt(data)
+            arg, data = unpackInt(data)
         elif type=="bin":
-            arg, tail = unpackBin(data)
+            arg, data = unpackBin(data)
         else:
             raise PackerException("Wrong argument type: %s" % type)
         args.append(arg)
-        data = tail
-    return (fea.namet, evt.name, args)
\ No newline at end of file
+    return (feat.name, evt.name, args)

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/common/presentation.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -1,6 +1,15 @@
+from happyboom.common.packer import packUtf8, packBin
 from happyboom.common.simple_event import EventLauncher, EventListener
 from happyboom.common.log import log
+from happyboom.common.packer import unpack, unpackBin, unpackUtf8
+from happyboom.net.io.packet import Packet
+from happyboom.server.client import Client
+import struct
 
+class PresentationException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
 class Presentation(EventLauncher, EventListener):
     
     CONNECTION    = 0x1
@@ -10,80 +19,118 @@
     DESTROY       = 0x5
     EVENT         = 0x6
     
-    def __init__(self, protocol):
+    def __init__(self, protocol, is_server):
+        EventListener.__init__(self)
+        EventLauncher.__init__(self)
         self.protocol = protocol
         self.items = {}
         self.gateway = None
+        self.client_manager = None
+        self.is_server = is_server 
         
-    def processPacket(self, newPacket):
+    def processPacket(self, packet):
         """ Processes incomming network packets (converts and launches local event).
-        @param new_packet: incomming network packet.
-        @type new_packet: C{net.io.packet.Packet}
+        @param packet: incomming network packet.
+        @type packet: C{net.io.packet.Packet}
         """
       
         # Get packet type
-        data = new_packtet.data
+        data = packet.data
         fmt = "!B"
         i = struct.calcsize(fmt)
-        type, data = (struct.unpack(fmt, data[:i]), date[i:],)
+        ptype, = struct.unpack(fmt, data[:i]) 
+        data = data[i:]
 
         # Choose process function
-        if type == self.CONNECTION:
-            self.recvConnection(data)
-            self.sendFeatures()
-        elif type == self.DISCONNECTION:
-            log.warning(u"Disconnected from server : %s" % self.getReason(data))
+        if ptype == self.CONNECTION:
+            data = self.recvConnection(packet.recv_from, data)
+        elif ptype == self.DISCONNECTION:
+            data = self.processDisconnect(packet.recv_from, data)
+        elif ptype == self.FEATURES:
+            data = self.processFeatures(packet.recv_from, data)
+        elif ptype == self.CREATE:
+            data = self.createItem(data)
+        elif ptype == self.DESTROY:
+            data = self.destroyItem(data)
+        elif ptype == self.EVENT:
+            data = self.processEvent(data)
+        else:
+            log.warning("ProtocoleWarning: received unexpected packet type %s." % ptype)
+        if len(data) != 0:
+            log.warning("ProtocolWarning: Received a message with an unexpected length.")
+            log.warning(u"Rest: [%s]." % data)
+
+    def processDisconnect(self, ioclient, data):
+        reason, data = unpackUtf8(data)
+        if self.is_server:
+            self.client_manager.closeClient(ioclient)
+        else:
+            log.warning(u"Received disconnected from server: %s" % reason)
             self.launchEvent("happyboom", "stop")
-        elif type == self.CREATE:
-            self.createItem(data)
-        elif type == self.DESTROY:
-            self.destroyItem(data)
-        elif type == self.EVENT:
-            self.processEvent(data)
-        else:
-            log.warning("ProtocoleWarning: received unexpected packet type %s." % type)
+        return data
         
-    def recvConnection(self, data):
-        fmt = "!H"
-        i = struct.calcsize(fmt)
-        version_len, data = (struct.unpack(fmt, data[:i]), data[i:])
-        fmt = "!%us" %(version_len)
-        i = struct.calcsize(fmt)
-        version, data = (struct.unpack(fmt, data[:i]), data[i:])
+    def processFeatures(self, ioclient, data):
+        features, data = unpackBin(data)
+        print "Features: %s" % (features)
+        client = Client(ioclient, self.gateway, self.client_manager)
+        self.client_manager.appendClient(client)
+        return data
+
+    def recvConnection(self, client, data):
+        version, data = unpackBin(data)
+        signature, data = unpackBin(data) 
         
-        fmt = "!H"
-        i = struct.calcsize(fmt)
-        sign_len, data = (struct.unpack(fmt, data[:i]), data[i:])
-        fmt = "!%us" %(version_len)
-        i = struct.calcsize(fmt)
-        signature, data = (struct.unpack(fmt, data[:i]), data[i:])
-        
-        if len(data) != 0:
-            raise TesUneGrosseMerdeError "Received a message with an unexpected length."
-        
-        if version != protocole.version:
-            pass # TODO
+        if version != self.protocol.version:
+            # TODO: send presentation bye(<why>)
+            raise PresentationException("Wrong protocol version.")
+        else:
+            if self.is_server:
+                # Send hello().
+                self.client_manager.generateSignature(client)
+                packet = self.connectionPacket(signature)
+            else:
+                # Send features().
+                self.launchEvent("signature", (signature,))
+                packet = self.featuresPacket()
+            client.send(packet)
+        return data
             
-        self.launchEvent("happyboom", "signature", (signature,))
-            
-    def sendFeatures(self):
-        pass
-    
-    def getReason(self, data):
-        pass
-    
+    def featuresPacket(self, features="TODO: Feed me!"):
+        data = struct.pack("!B", self.FEATURES)
+        data = data + packBin(features)
+        return Packet(data)
+       
     def createItem(self, data):
-        pass
+        # TODO
+        return data
 
+    def connectionPacket(self, signature=""):
+        data = struct.pack("!B", self.CONNECTION)
+        data = data + packBin(self.protocol.version.encode("ascii"))
+        data = data + packBin(signature)
+        return Packet(data)
+
+    def disconnectionPacket(self, reason):
+        data = struct.pack("!B", self.DISCONNECTION) + packUtf8(reason)
+        return Packet(data)
+
     def sendMsg(self, data):
         data = struct.pack("!B", self.EVENT) + data
         return data
         
     def destroyItem(self, data):
-        pass
+        # TODO
+        return data
     
     def processEvent(self, data):
-        packer.unpack(data, self.protocol)
-        if self.__debug:
-            log.info("Received message: feature=%s event=%s arguments=%s." % (feat, evt, args))
-        self.launchEvent(feat, evt, args)
+        fmt = "!BB"
+        i = struct.calcsize(fmt)
+        feature_id, event_id = struct.unpack(fmt, data[:i])
+        data = data[i:]
+
+        feature, event, args = unpack(data, feature_id, event_id, self.protocol)
+        log.info("Received: %s.%s(%s)" \
+            % (feature, event, args))
+
+        self.gateway.recvNetMsg(feature, event, args)
+        return ""

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/common/protocol.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -3,6 +3,7 @@
 """
 
 import xml.dom.minidom
+from happyboom.common.packer import pack, checkType
 
 class ProtocolException(Exception):
     def __init__(self, msg):
@@ -85,7 +86,7 @@
                 % (self.protocol.name, self.name, name))
         return self.__evtnames[name]
 
-    def __getitem__(self, id):
+    def getEventById(self, id):
         event = self.__evtids.get(id, None)
         if event == None:
             raise ProtocolException( \
@@ -105,12 +106,31 @@
         return out
 
 class Protocol:
+    """
+    HappyBoom protocol utility.
+    version is unicode
+    """
     def __init__(self, name, version):
         self.name = name
         self.version = version
         self.__featnames = {}
         self.__featids = {}
 
+    def createMsg(self, feature, event, *args):
+        f = self.getFeature(feature)
+        e = f.getEvent(event)
+        types = e.getParamTypes()
+        if len(args) != len(types):
+            raise ProtocolException( \
+                "Wrong parameter count (%u) for the event %s." \
+                % (len(args), e))
+        for i in range(len(args)):
+            if not checkType(types[i], args[i]):
+                raise ProtocolException( \
+                    "Parameter %u of event %s should be of type %s (and not %s)." \
+                    % (i, f, types[i], type(args[i])))
+        return pack(f.id, e.id, types, args)
+
     def addFeature(self, name, id):
         # Check if no other feature have the same identifier
         feature = self.__featnames.get(name, None)
@@ -118,6 +138,7 @@
             raise ProtocolException( \
                 "Features %s and %s have the same identifier (%s)." \
                 % (feature.name, name, id))
+                
         # Check if no other feature have the same name
         feature = self.__featids.get(id, None)
         if feature != None:
@@ -135,15 +156,15 @@
         feature = self.__featnames.get(name, None)
         if feature == None:
             raise ProtocolException( \
-                "The protocol %s has no feature %s." \
+                "The protocol %s has no feature \"%s\"." \
                 % (self.name, name))
         return feature
 
-    def __getitem__(self, id):
+    def getFeatureById(self, id):
         feature = self.__featids.get(id, None)
         if  feature == None:
             raise ProtocolException( \
-                "The protocol %s has no feature %s." \
+                "The protocol %s has no feature with \"%s\" identifier." \
                 % (self.name, id))
         return feature
         

Modified: happyboom/trunk/common/simple_event.py
===================================================================
--- happyboom/trunk/common/simple_event.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/common/simple_event.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -64,9 +64,10 @@
                 # No handle method found, raise error ?
                 if not obj.silent:
                     raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
+        else:
+            print("Pas de event.type %s" % event.type)
 
 EventManager()
-
     
 class EventListener:
     """ Generic class for listening to events.
@@ -172,4 +173,4 @@
     
 class UnhandledEventError(AttributeError):
     """ Error raised when an event cannot be handled, except if C{L{silent<EventListener.silent>}} flag is C{True}. """
-    pass
\ No newline at end of file
+    pass

Modified: happyboom/trunk/net/io/base_io.py
===================================================================
--- happyboom/trunk/net/io/base_io.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/net/io/base_io.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -31,6 +31,8 @@
     @type on_new_packet: C{function(L{Packet})}
     @ivar __name: The IO name.
     @type __name: C{str}
+    @ivar _running: Is the thread running ?
+    @type _running: C{bool}
     """
     
     def __init__(self, is_server=False):
@@ -41,6 +43,7 @@
         self.debug = False
         self.verbose = False 
         self._is_ready = False
+        self._running = False 
 
         # Events
         self.on_connect = None            # No argument
@@ -64,6 +67,7 @@
         """
         if self.__name==None:
             self.__name = "%s:%u" % (host, port)
+        self._running = True
 
     def disconnect(self):
         """ Close connection. """
@@ -97,10 +101,14 @@
     
     def stop(self):
         """ Stop the IO (close connections). """
-        pass
+        if not self._running: return
+        self._running = False
+        self.disconnect()
 
     def __str__(self):
         return self.__name
+    
+    def isRunning(self): return self._running
 
     #--- Private functions ------------------------------------------------------
 

Modified: happyboom/trunk/net/io/packet.py
===================================================================
--- happyboom/trunk/net/io/packet.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/net/io/packet.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -148,7 +148,7 @@
             data = struct.pack("!I", data_len)
         else:
             data = struct.pack("!BBII", 
-                self.type, self.skippable+0, self.id, data_len)
+                self.type, int(self.skippable), self.id, data_len)
         if data_len != 0:
             data = data + struct.pack("!%us" % data_len, self.__data)
         return data

Modified: happyboom/trunk/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/net/io_tcp/tcp.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -7,12 +7,13 @@
 import traceback
 import struct
 from tcp_client import TCP_Client
-from net import io
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.base_io import BaseIO
 from server_waiter import NetworkServerWaiter
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
 
-class IO_TCP(io.BaseIO):
+class IO_TCP(BaseIO):
     """
     IO for TCP transport.
     @ivar packet_timeout: Timeout of packets (in seconds)
@@ -29,12 +30,10 @@
     @type __clients: C{list<L{IO_client<io.IO_Client>}>?}
     @ivar __clients_sema: Semaphore used to access L{__clients}.
     @type __clients_sema: C{thread.lock}
-    @ivar __running: Is the thread running ?
-    @type __running: C{bool}
     """
     
     def __init__(self, is_server=False):
-        io.BaseIO.__init__(self)
+        BaseIO.__init__(self)
         self.packet_timeout = 1.000
         self.thread_sleep = 0.010
 
@@ -45,8 +44,7 @@
         self.__clients = {}
         self.__server = None
         self.__clients_sema = thread.allocate_lock()
-        self.__running = False 
-        io.Packet.use_tcp = True
+        Packet.use_tcp = True
 
     def connect(self, host, port):
         """ Connect to host:port """
@@ -79,9 +77,8 @@
             self.__clients_sema.release()
 
         if self.on_connect != None: self.on_connect()
-        io.BaseIO.connect(self, host, port)
+        BaseIO.connect(self, host, port)
         self._is_ready = True
-        self.__running = True
 
     def disconnect(self):
         """ Close connection """
@@ -107,7 +104,7 @@
         """ Send a packet to the server or to all clients
         @type packet: Packet
         """
-        if not self.__running: return
+        if not self._running: return
         
         # Read binary version of the packet
         data = packet.pack()
@@ -137,7 +134,7 @@
 
     def __processData(self, client, data):
         while data != "":
-            packet = io.Packet()
+            packet = Packet()
             packet.recv_from = client
             data = packet.unpack(data)
             if not packet.isValid():
@@ -151,7 +148,7 @@
     def run_thread(self):
         """ Function which should be called in a thread. """
         try:
-            while self.__running:
+            while self._running:
                 self.live()                
                 time.sleep(self.thread_sleep)
         except Exception, msg:
@@ -160,13 +157,6 @@
                 % (msg, getBacktrace()))
         self.stop()
 
-    def stop(self):
-        if not self.__running: return
-        self.__running = False
-        self.disconnect()
-
-    def isRunning(self): return self.__running
-
     #--- Private functions ------------------------------------------------------
 
     def __getPort(self):

Modified: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/server/agent.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -1,4 +1,4 @@
-from pysma import ActionAgent, ActionMessage
+from pysma import ActionAgent, ActionMessage as Message
 from happyboom.common.log import log
 
 class Agent(ActionAgent):
@@ -28,7 +28,3 @@
     def messageReceived(self, msg):
         if self.__debug:
             log.warning("Unhandled message : %s -- %s" %(type(self), msg))
-
-class Message(ActionMessage):
-    def __init__(self, action, arg, kw={}):
-        ActionMessage.__init__(self, action, arg, kw)

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/server/base_server.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -13,7 +13,8 @@
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         self.__gateway = gateway 
-        gateway.server = self
+        self.__gateway.server = self
+        self.__gateway.client_manager.server = self
         random.seed()
         self.__items = []
         

Modified: happyboom/trunk/server/client.py
===================================================================
--- happyboom/trunk/server/client.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/server/client.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -1,7 +1,7 @@
 from happyboom.common.protocol import ProtocolException
 from happyboom.common.log import log
 
-class Client:
+class Client(object):
     """
     High-level class for a client in the server.
     """
@@ -12,6 +12,14 @@
         self.__gateway = gateway
         self.signature = None
 
+    def __str__(self):
+        return self.__io.__str__()
+
+    def disconnect(self, reason):
+        packet = self.__gateway.presentation.disconnectionPacket(reason)
+        self.sendPacket(packet)
+        self.stop()        
+
     # Stop client: close socket.
     def stop(self):
         self.__io.disconnect()
@@ -33,3 +41,6 @@
             log.error(err)
             return
         self.__io.send(packet)
+
+    def __getAddr(self): return self.__io.addr
+    addr = property(__getAddr)

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/server/client_manager.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -6,7 +6,7 @@
 
 class ClientManager(object):
     def __init__(self, arg): 
-        self.__server = None 
+        self.server = None 
         self.__io = io_tcp.IO_TCP(is_server=True)
         self.__io.debug = arg.get("debug", False)
         self.__io.verbose = arg.get("verbose", False)
@@ -16,27 +16,28 @@
         self.max_clients = arg.get("max_clients", 2)
         self.client_port = arg.get("client_port", 12430)
         self.__supported_features = {}
-        self.__clients = []
-        self.__clients_sema = thread.allocate_lock()
+        self.__clients = {}
+        self.__clients_lock = thread.allocate_lock()
         self.gateway = None
+        self.presentation = None
         
     def recvClientPacket(self, packet):
         self.__buffer.append(packet.recv_from.addr, packet)
 
     def stop(self):
-        for client in self.__clients:
+        for client in self.__clients.values():
             client.stop()
 
     def process(self):
-        pass
-#        processInputs()
+        if not self.__io.isRunning():
+            self.server.stop()
 
     def start(self):
         if self.__verbose: log.info("[*] Starting server")
         self.__io.name = "server"
         self.__io.on_client_connect = self.openClient
         self.__io.on_client_disconnect = self.closeClient
-        self.__io.on_new_packet = self.recvClientPacket
+        self.__io.on_new_packet = self.presentation.processPacket
         self.__io.connect('', self.client_port)
         thread.start_new_thread(self.run_io_thread, ())
 
@@ -53,19 +54,23 @@
             self.__supported_features[role] = [client,]
         
     def openClient(self, client):
-        # TODO: Ne pas utiliser de thread ?!
-        thread.start_new_thread( self.__clientChallenge, (client,self.__do_openClient))
+        log.info("[*] Client %s try to connect ..." % client)
 
-    def closeClient(self, client):
-        if self.__verbose:
-            log.info("Client %s disconnected." % client)
-        
-        txt = "Client %s leave us." % client
-        self.gateway.sendText(txt)
-       
+    def removeClient(self, ioclient):
+        client = self.getClientByAddr(ioclient.addr)
+        if client == None: return
+        log.info("Disconnect client %s." % client)
+        self.gateway.sendText(u"Client %s leave us." % client)
+
+        self.__clients_lock.acquire() 
+        del self.__clients[ioclient.addr]
+        self.__clients_lock.release() 
+    
+    def closeClient(self, ioclient):
         # TODO: get client of type Client for the client of type ClientIO to send
         # him bye
 #        client.sendNetMsg("presentation", "bye", "utf8", u"Lost connection")
+        self.removeClient(ioclient)
         
     def __clientChallenge(self, client, func):
         try:
@@ -77,7 +82,7 @@
             self.stop()
 
     # Function which should be called in a thread
-    # TODO: Pourquoi c'est utilis? ?a ?
+    # TODO: Why is this used?
     def run_io_thread(self):
         try:
             while self.__io.isRunning():
@@ -87,51 +92,30 @@
             log.error( \
                 "EXCEPTION IN IO THREAD :\n%s\n%s" \
                 % (msg, getBacktrace()))
-            self.stop()
+            self.server.stop()
 
-    def generateSignature(self, client):
+    def generateSignature(self, ioclient):
         import random
         r = random.randint(0,1000000)
         return r
 
-    def __do_openClient(self, io_client):
-        log.info("[*] Display %s try to connect ..." % io_client)
-        client = Client(io_client, self.gateway, self)
-        
-#        self.__buffer.clear(client.addr)
-       
-        # Check protocol version (max: wait 200ms)
-        answer = client.read(0.200)
-        if answer != self.gateway.protocol_version:
-            # If it isn't the right version, send presention.bye(...)
-            txt = u"Sorry, you don't have same protocol version (%s VS %s)" \
-                % (answer, self.gateway.protocol_version)
-            client.sendNetMsg("presentation", "bye", "utf8", txt)
+    def getClientByAddr(self, addr):
+        """ Returns None if no client matchs. """
+        self.__clients_lock.acquire() 
+        client = self.__clients.get(addr, None)
+        self.__clients_lock.release() 
+        return client
+    
+    def appendClient(self, client):
+        self.__clients_lock.acquire() 
+        self.__clients[client.addr] = client
+        self.__clients_lock.release() 
 
-            # Wait 0.5s and then disconnect the client
-            time.sleep(0.500)
-            client.stop()
-            return
-            
-        # Send protocol version with "hello()"
-        client.signature = self.generateSignature()        
-        client.send("presentation", "hello", \
-            "bin", self.gateway.protocol_version, \
-            "bin", signature)
-         
-        # Read features (max: wait 1sec)
-        answer = client.read(1.0)
-        #TODO: do something with answer :-)
-
-        self.__clients_sema.acquire() 
-        self.__clients.append(client)
-        self.__clients_sema.release() 
-
-        txt = "Welcome to new (display) client : %s" % (client.name)
+        txt = u"Welcome to new (display) client : %s" % client
         self.gateway.sendText(txt)
-        log.info("[*] Display %s connected" % (client.name))
-        self.sendBBMessage("sync")
-
+        log.info("[*] Display %s connected" % client)
+        self.gateway.send("sync")
+    
     def __getSupportedFeatures(self): return self.__supported_features
     supported_features = property(__getSupportedFeatures)
 

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happyboom/trunk/server/gateway.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -1,5 +1,4 @@
-from happyboom.common import packer 
-from happyboom.server.agent import Agent
+from happyboom.server.agent import Agent, Message
 from happyboom.common.protocol import loadProtocol, ProtocolException
 from happyboom.net.io import Packet
 from happyboom.common.log import log
@@ -7,10 +6,14 @@
 import struct
 
 class Gateway(Agent):
-    def __init__(self, protocol, client_manager, arg):
+    def __init__(self, protocol, presentation, client_manager, arg):
         Agent.__init__(self, self, "gateway")
         self.__protocol = protocol
-        self.__client_manager = client_manager
+        self.client_manager = client_manager
+        self.presentation = presentation
+        self.presentation.gateway = self 
+        self.presentation.client_manager = self.client_manager
+        self.client_manager.presentation = self.presentation
         self.__server = None 
         self._debug = arg.get("debug", False)
         self._verbose = arg.get("verbose", False)
@@ -19,41 +22,29 @@
 
     def __setServer(self, server):
         self.__server = server
-        self.__client_manager.server = server
+        self.client_manager.server = server
     server = property(None, __setServer)
 
-
     # Create a network packet for the event feature.event(args)
     def createMsg(self, feature, event, *args):
-        f = self.__protocol.getFeature(feature)
-        e = f.getEvent(event)
-        types = e.getParamsType()
-        if len(args) != len(types):
-            raise ProtocolException( \
-                "Wrong parameter count (%u) for the event %s." \
-                % (len(args), e))
-        for i in range(len(args)):
-            if not packer.checkType(types[i], args[i]):
-                raise ProtocolException( \
-                    "Parameter %u of event %s should be of type %s (and not %s)." \
-                    % (i, e, types[i], type(args[i])))
-        data = packer.pack(f.id, e.id, types, args)
+        data = self.__protocol.createMsg(feature, event, *args)
+        data = self.presentation.sendMsg(data)
         return Packet(data)
             
     def start(self):
-        self.__client_manager.start()
+        self.client_manager.start()
         Kernel.instance.addAgent(self)
         
     def stop(self):
         self.sendNetMsg("game", "stop")
-        self.__client_manager.stop()
+        self.client_manager.stop()
         Kernel.instance.stopKernel()
 
     def process(self):
         # Stop server if the scheduler is dead
         if not self.__scheduler.alive:
             self.__server.stop()
-        self.__client_manager.process()
+        self.client_manager.process()
 
     def sendText(self, txt, client=None):
         if client != None:
@@ -61,13 +52,17 @@
         else:
             self.sendNetMsg("chat", "message", txt)
 
+    def recvNetMsg(self, feature, event, *args):
+        message = Message("%s_%s" % (feature, event), args)
+        self.sendBroadcastMessage(message, "%s_listener" % feature)
+
     def sendNetMsg(self, feature, event, *args):
         try:
             packet = self.createMsg(feature, event, *args)
         except ProtocolException, err:
             log.error(err)
             return
-        clients = self.__client_manager.supported_features.get(feature, ())
+        clients = self.client_manager.supported_features.get(feature, ())
         for client in clients:
             client.sendPacket(packet)
 

Modified: happywarry/happywarry-server.py
===================================================================
--- happywarry/happywarry-server.py	2005-09-14 07:27:34 UTC (rev 161)
+++ happywarry/happywarry-server.py	2005-09-14 10:47:34 UTC (rev 162)
@@ -17,27 +17,17 @@
     sys.path.append(happyboomdir)
 
     # Get user directory 
-    from common.log import log
-    if os.name=="nt":
-        home = os.environ['USERHOME']
-    else:
-        home = os.environ['HOME']
+    from happyboom.common.file import getCreateHomeDir
+    logdir = getCreateHomeDir("happywarry")
 
-    # Create happywarry directory if needed
-    logdir = os.path.join(home, ".happywarry")
-    try:
-        os.mkdir(logdir)
-    except OSError, err:
-        if err[0]==17: pass
-        logdir = None
-
     # Setup log filename
+    from happyboom.common.log import log
     if logdir != None:
         logname = os.path.join(logdir, "server-log")    
         log.setFilename(logname)
 
     # Setup gettext
-    localedir = os.path.join(file_dir, "./locale")
+    localedir = os.path.join(file_dir, "locale")
     gettext.install('happywarry', localedir, unicode=1)
 
 def main():



From dboucard at berlios.de  Thu Sep 15 20:15:59 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 20:15:59 +0200
Subject: [Happyboom-svn] r163 - happyboom/trunk/common
Message-ID: <200509151815.j8FIFxQJ019531@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 20:15:58 +0200 (Thu, 15 Sep 2005)
New Revision: 163

Added:
   happyboom/trunk/common/event.py
Removed:
   happyboom/trunk/common/simple_event.py
Log:
not as simple as that


Copied: happyboom/trunk/common/event.py (from rev 162, happyboom/trunk/common/simple_event.py)

Deleted: happyboom/trunk/common/simple_event.py
===================================================================
--- happyboom/trunk/common/simple_event.py	2005-09-14 10:47:34 UTC (rev 162)
+++ happyboom/trunk/common/simple_event.py	2005-09-15 18:15:58 UTC (rev 163)
@@ -1,176 +0,0 @@
-"""
-Module to use event-system very easily.
- at author: Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 1.0
-"""
-class EventManager:
-    """ Manages the event-system.
-    This class is instanciated on importing the module,
-    so it is not needed to use it directly but via EventLaunch and EventListener.
-    @cvar instance: The instance created on importing the module.
-    @type instance: C{L{EventManager}}
-    @ivar listeners: Dictionnary with keys of type C{str} representing a event type and with values of type C{list} representing a collection of C{EventListener}.
-    @type listeners: C{dict<str, list<L{EventListener}>>}
-    """
-    def __init__(self):
-        """ EventManager constructor. """
-        EventManager.instance = self
-        self.listeners = {}
-        
-    def addListener(self, obj, event_type):
-        """ Add a listener to a specific event.
-        @param obj: Listener to add.
-        @type obj: C{L{EventListener}}
-        @param event_type: Type of the event to listen.
-        @type event_type: C{str}
-        """
-        if event_type in self.listeners and obj not in self.listeners[event_type]:
-            self.listeners[event_type].append(obj)
-        else:
-            self.listeners[event_type] = [obj]
-    
-    def removeListener(self, obj, event_type):
-        """ Remove a listener from a specific event.
-        @param obj: Listener to remove.
-        @type obj: C{L{EventListener}}
-        @param event_type: Type of the event that was listening.
-        @type event_type: C{str}
-        """
-        if event_type in self.listeners and obj in self.listeners[event_type]:
-            self.listeners[event_type].remove(obj)
-    
-    def dispatchEvent(self, event):
-        """ Dispatch a launched event to all affected listeners.
-        @param event: Event launched.
-        @type event: C{L{Event}}
-        """
-        if event.type in self.listeners:
-            for obj in self.listeners[event.type]:
-                # Try to call event-specific handle method
-                fctname = obj.pattern %(event.type)
-                if hasattr(obj, fctname):
-                    function = getattr(obj, fctname)
-                    if callable(function):
-                        function(event)
-                        continue
-                # Try to call default handle method
-                if hasattr(obj, obj.default):
-                    function = getattr(obj, obj.default)
-                    if callable(function):
-                        function(event)
-                        continue
-                # No handle method found, raise error ?
-                if not obj.silent:
-                    raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
-        else:
-            print("Pas de event.type %s" % event.type)
-
-EventManager()
-    
-class EventListener:
-    """ Generic class for listening to events.
-    
-    It is just needed to herite from this class and register to events to listen easily events.
-    It is also needed to write handler methods with event-specific and/or C{L{default}} function.
-    
-    Event-specific functions have name as the concatenation of the C{prefix} parameter + the listened event type + the C{suffix} parameter.
-    
-    If it does not exist, the default function is called as defined by the C{L{default}} parameter/attribute.
-    
-    If the event cannot be handled, a C{L{UnhandledEventError}} is raised, except if C{L{silent}} flag is C{True}.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    @ivar pattern: Event-specific handler pattern.
-    @type pattern: C{str}
-    @ivar default: Default handler function name.
-    @type default: C{str}
-    @ivar silent: Silent flag. If C{False}, C{L{UnhandledEventError}} is raised if an event cannot be handled. If C{True}, do nothing, listener does not handle the event.
-    @type silent: C{str}
-    """
-    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
-        """ EventListener constructor.
-        @param prefix: Prefix for all event-specific handler function name.
-        @type prefix: C{str}
-        @param suffix: Suffix for all event-specific handler function name.
-        @type suffix: C{str}
-        @param default: Default handler function name.
-        @type default: C{str}
-        @param silent: Silent flag.
-        @type silent: C{bool}
-        """
-        self.manager = EventManager.instance
-        self.pattern = prefix + "%s" + suffix
-        self.default = default
-        self.silent = silent
-        
-    def registerEvent(self, event_type):
-        """ Registers itself to a new event.
-        @param event_type: Type of the event to listen.
-        @type event_type: C{str}
-        """
-        self.manager.addListener(self, event_type)
-        
-    def unregisterEvent(self, event_type):
-        """ Unregisters itself from a event.
-        @param event_type: Type of the event which was listening.
-        @type event_type: C{str}
-        """
-        self.manager.removeListener(self, event_type)
-
-
-class EventLauncher:
-    """ Generic class for launching events.
-    It is just needed to herite from this class to launch easily events.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    """
-    def __init__(self):
-        """ EventLauncher constructor. """
-        self.manager = EventManager.instance
-        
-        
-    def launchEvent(self, event_type, content=None):
-        """ Launches a new event to the listeners.
-        @param event_type: Type of the event to launch.
-        @type event_type: C{str}
-        @param content: Content to attach with the event (Optional).
-        @type content: any
-        """
-        self.manager.dispatchEvent(Event(event_type, self, content))
-    
-    
-class Event:
-    """ Represents an event entity.
-    @ivar type: Type of the event.
-    @type type: C{str}
-    @ivar source: Instance which launched the event.
-    @type source: C{L{EventLauncher}}
-    @ivar content: Content attached to the event (C{None} if none).
-    @type content: any
-    """
-    def __init__(self, type, source, content):
-        """ Event constructor.
-        @param type: Type of the event.
-        @type type: C{str}
-        @param source: Instance which launched the event.
-        @type source: C{L{EventLauncher}}
-        @param content: Content attached to the event (C{None} if none).
-        @type content: any
-        """
-        self.type = type
-        self.source = source
-        self.content = content
-    
-    def __str__(self):
-        """ Converts object itself to string.
-        @return: Object converted string.
-        @rtype: C{str}
-        """
-        return "<bb_events.BoomBoomEvent type=%s source=%s content=%s>" %(self.type, self.source, self.content)
-    
-    
-class UnhandledEventError(AttributeError):
-    """ Error raised when an event cannot be handled, except if C{L{silent<EventListener.silent>}} flag is C{True}. """
-    pass



From dboucard at berlios.de  Thu Sep 15 21:28:55 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 21:28:55 +0200
Subject: [Happyboom-svn] r164 - happyboom/trunk/common
Message-ID: <200509151928.j8FJStNX026724@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 21:28:53 +0200 (Thu, 15 Sep 2005)
New Revision: 164

Added:
   happyboom/trunk/common/event.py
   happyboom/trunk/common/generic_event.py
Removed:
   happyboom/trunk/common/event.py
Log:
happyboom generic event system


Deleted: happyboom/trunk/common/event.py
===================================================================
--- happyboom/trunk/common/event.py	2005-09-15 18:15:58 UTC (rev 163)
+++ happyboom/trunk/common/event.py	2005-09-15 19:28:53 UTC (rev 164)
@@ -1,176 +0,0 @@
-"""
-Module to use event-system very easily.
- at author: Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 1.0
-"""
-class EventManager:
-    """ Manages the event-system.
-    This class is instanciated on importing the module,
-    so it is not needed to use it directly but via EventLaunch and EventListener.
-    @cvar instance: The instance created on importing the module.
-    @type instance: C{L{EventManager}}
-    @ivar listeners: Dictionnary with keys of type C{str} representing a event type and with values of type C{list} representing a collection of C{EventListener}.
-    @type listeners: C{dict<str, list<L{EventListener}>>}
-    """
-    def __init__(self):
-        """ EventManager constructor. """
-        EventManager.instance = self
-        self.listeners = {}
-        
-    def addListener(self, obj, event_type):
-        """ Add a listener to a specific event.
-        @param obj: Listener to add.
-        @type obj: C{L{EventListener}}
-        @param event_type: Type of the event to listen.
-        @type event_type: C{str}
-        """
-        if event_type in self.listeners and obj not in self.listeners[event_type]:
-            self.listeners[event_type].append(obj)
-        else:
-            self.listeners[event_type] = [obj]
-    
-    def removeListener(self, obj, event_type):
-        """ Remove a listener from a specific event.
-        @param obj: Listener to remove.
-        @type obj: C{L{EventListener}}
-        @param event_type: Type of the event that was listening.
-        @type event_type: C{str}
-        """
-        if event_type in self.listeners and obj in self.listeners[event_type]:
-            self.listeners[event_type].remove(obj)
-    
-    def dispatchEvent(self, event):
-        """ Dispatch a launched event to all affected listeners.
-        @param event: Event launched.
-        @type event: C{L{Event}}
-        """
-        if event.type in self.listeners:
-            for obj in self.listeners[event.type]:
-                # Try to call event-specific handle method
-                fctname = obj.pattern %(event.type)
-                if hasattr(obj, fctname):
-                    function = getattr(obj, fctname)
-                    if callable(function):
-                        function(event)
-                        continue
-                # Try to call default handle method
-                if hasattr(obj, obj.default):
-                    function = getattr(obj, obj.default)
-                    if callable(function):
-                        function(event)
-                        continue
-                # No handle method found, raise error ?
-                if not obj.silent:
-                    raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
-        else:
-            print("Pas de event.type %s" % event.type)
-
-EventManager()
-    
-class EventListener:
-    """ Generic class for listening to events.
-    
-    It is just needed to herite from this class and register to events to listen easily events.
-    It is also needed to write handler methods with event-specific and/or C{L{default}} function.
-    
-    Event-specific functions have name as the concatenation of the C{prefix} parameter + the listened event type + the C{suffix} parameter.
-    
-    If it does not exist, the default function is called as defined by the C{L{default}} parameter/attribute.
-    
-    If the event cannot be handled, a C{L{UnhandledEventError}} is raised, except if C{L{silent}} flag is C{True}.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    @ivar pattern: Event-specific handler pattern.
-    @type pattern: C{str}
-    @ivar default: Default handler function name.
-    @type default: C{str}
-    @ivar silent: Silent flag. If C{False}, C{L{UnhandledEventError}} is raised if an event cannot be handled. If C{True}, do nothing, listener does not handle the event.
-    @type silent: C{str}
-    """
-    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
-        """ EventListener constructor.
-        @param prefix: Prefix for all event-specific handler function name.
-        @type prefix: C{str}
-        @param suffix: Suffix for all event-specific handler function name.
-        @type suffix: C{str}
-        @param default: Default handler function name.
-        @type default: C{str}
-        @param silent: Silent flag.
-        @type silent: C{bool}
-        """
-        self.manager = EventManager.instance
-        self.pattern = prefix + "%s" + suffix
-        self.default = default
-        self.silent = silent
-        
-    def registerEvent(self, event_type):
-        """ Registers itself to a new event.
-        @param event_type: Type of the event to listen.
-        @type event_type: C{str}
-        """
-        self.manager.addListener(self, event_type)
-        
-    def unregisterEvent(self, event_type):
-        """ Unregisters itself from a event.
-        @param event_type: Type of the event which was listening.
-        @type event_type: C{str}
-        """
-        self.manager.removeListener(self, event_type)
-
-
-class EventLauncher:
-    """ Generic class for launching events.
-    It is just needed to herite from this class to launch easily events.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    """
-    def __init__(self):
-        """ EventLauncher constructor. """
-        self.manager = EventManager.instance
-        
-        
-    def launchEvent(self, event_type, content=None):
-        """ Launches a new event to the listeners.
-        @param event_type: Type of the event to launch.
-        @type event_type: C{str}
-        @param content: Content to attach with the event (Optional).
-        @type content: any
-        """
-        self.manager.dispatchEvent(Event(event_type, self, content))
-    
-    
-class Event:
-    """ Represents an event entity.
-    @ivar type: Type of the event.
-    @type type: C{str}
-    @ivar source: Instance which launched the event.
-    @type source: C{L{EventLauncher}}
-    @ivar content: Content attached to the event (C{None} if none).
-    @type content: any
-    """
-    def __init__(self, type, source, content):
-        """ Event constructor.
-        @param type: Type of the event.
-        @type type: C{str}
-        @param source: Instance which launched the event.
-        @type source: C{L{EventLauncher}}
-        @param content: Content attached to the event (C{None} if none).
-        @type content: any
-        """
-        self.type = type
-        self.source = source
-        self.content = content
-    
-    def __str__(self):
-        """ Converts object itself to string.
-        @return: Object converted string.
-        @rtype: C{str}
-        """
-        return "<bb_events.BoomBoomEvent type=%s source=%s content=%s>" %(self.type, self.source, self.content)
-    
-    
-class UnhandledEventError(AttributeError):
-    """ Error raised when an event cannot be handled, except if C{L{silent<EventListener.silent>}} flag is C{True}. """
-    pass

Added: happyboom/trunk/common/event.py
===================================================================
--- happyboom/trunk/common/event.py	2005-09-15 18:15:58 UTC (rev 163)
+++ happyboom/trunk/common/event.py	2005-09-15 19:28:53 UTC (rev 164)
@@ -0,0 +1,68 @@
+"""
+Module to use event-system very easily.
+ at author: Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 1.0
+"""
+import generic_event as evt
+
+class EventListener(evt.EventListener):
+    """ Happyboom generic class for listening to events.
+    """
+    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
+        """ EventListener constructor.
+        """
+        evt.EventListener.__init__(self, prefix, suffix, __eventPerformed, silent)
+        self.hb_default = default
+        
+    def getEventName(self, feature, event):
+        return "%s_%s" %(feature, event)
+        
+    def __eventPerformed(self, event):
+        if issubclass(event, Event):
+            # Try to call event-specific handle method
+            fctname = self.pattern %(self.getEventName(event.type, event.event))
+            if hasattr(self, fctname):
+                function = getattr(self, fctname)
+                if callable(function):
+                    function(event)
+                    return
+        # Try to call default handle method
+        if hasattr(self, self.hb_default):
+            function = getattr(self, self.hb_default)
+            if callable(function):
+                function(event)
+                return
+        # No handle method found, raise error ?
+        if not obj.silent:
+            raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
+
+class EventLauncher(evt.EventLauncher):
+    """ Happyboom generic class for launching events.
+    """
+    def __init__(self):
+        """ EventLauncher constructor. """
+        self.manager = EventManager.instance
+        
+    def launchEvent(self, feature, event, *args):
+        """ Launches a new event to the listeners.
+        """
+        self.manager.dispatchEvent(Event(feature, event, self, args))
+
+class Event(evt.Event):
+    """ Represents an happyboom event entity.
+    """
+    def __init__(self, feature, event, source, content):
+        """ Event constructor.
+        """
+        evt.Event.__init__(self, feature, source, content)
+        self.event = event
+    
+    def __str__(self):
+        """ Converts object itself to string.
+        @return: Object converted string.
+        @rtype: C{str}
+        """
+        return "<event.Event feature=%s event=%s source=%s content=%s>" %(self.type, self.event, self.source, self.content)
+    
\ No newline at end of file

Copied: happyboom/trunk/common/generic_event.py (from rev 163, happyboom/trunk/common/event.py)



From dboucard at berlios.de  Thu Sep 15 21:35:04 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 21:35:04 +0200
Subject: [Happyboom-svn] r165 - happyboom/trunk/common
Message-ID: <200509151935.j8FJZ4n7027263@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 21:35:03 +0200 (Thu, 15 Sep 2005)
New Revision: 165

Modified:
   happyboom/trunk/common/event.py
Log:


Modified: happyboom/trunk/common/event.py
===================================================================
--- happyboom/trunk/common/event.py	2005-09-15 19:28:53 UTC (rev 164)
+++ happyboom/trunk/common/event.py	2005-09-15 19:35:03 UTC (rev 165)
@@ -43,7 +43,7 @@
     """
     def __init__(self):
         """ EventLauncher constructor. """
-        self.manager = EventManager.instance
+        evt.EventLauncher.__init__(self)
         
     def launchEvent(self, feature, event, *args):
         """ Launches a new event to the listeners.



From haypo at berlios.de  Thu Sep 15 22:12:13 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 15 Sep 2005 22:12:13 +0200
Subject: [Happyboom-svn] r166 - happyboom/trunk/common happyboom/trunk/server poilu/trunk
Message-ID: <200509152012.j8FKCDIP029782@sheep.berlios.de>

Author: haypo
Date: 2005-09-15 22:12:12 +0200 (Thu, 15 Sep 2005)
New Revision: 166

Modified:
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/client.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
   poilu/trunk/insulte.txt
   poilu/trunk/motcle_regex.txt
Log:
Petite corrections.


Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-15 19:35:03 UTC (rev 165)
+++ happyboom/trunk/common/packer.py	2005-09-15 20:12:12 UTC (rev 166)
@@ -9,25 +9,22 @@
     if datatype=="int":
         return (type(data) == type(1)) and (data <= 2147483647) and (-2147483648 <= data)
     elif datatype=="bin":
-        return true
+        return len(data) < 65535 
     elif datatype=="utf8":
-        return type(data)==types.UnicodeType
+        return len(data) < 65535 and type(data)==types.UnicodeType
     else:
         raise PackerException("Wrong argument type: %s" % datatype)
 
 def packInt(data):
-    assert type(data)==type(1), "packInt argument have to be an integer"
-    # Overflow is checked by struct.pack
-    #assert data <= 2147483647, "packInt argument is too big (%s)" % data
-    #assert -2147483648 <= data, "packInt argument is too small (%s)" % data
+    assert checkType("int", data), "packInt argument have to be an integer"
     return struct.pack("!i", data)
     
 def packUtf8(data):
-    assert type(data)==types.UnicodeType, "packUtf8 argument have to be an unicode string"
+    assert checkType("utf8", data), "packUtf8 argument have to be an unicode string"
     return packBin(data.encode("utf-8"))
 
 def packBin(data):
-    assert type(data)==types.StringType, "packBin argument have to be a string"
+    assert checkType("bin", data), "packBin argument have to be a string"
     return struct.pack("!H%us" % len(data), len(data), data)
 
 def pack(func, event, types, values):
@@ -41,12 +38,10 @@
     assert len(types) == len(values), "Lengths of types and args have to be the same."
     out = struct.pack("!BB", func, event)
 
-    #TODO: Fix this :-)
     for i in range(len(values)):
         type = types[i]
         data = values[i]
         
-        # TODO: Use dict instead of long if list
         if type=="int":
             data = packInt(data)
         elif type=="bin":

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 19:35:03 UTC (rev 165)
+++ happyboom/trunk/common/presentation.py	2005-09-15 20:12:12 UTC (rev 166)
@@ -1,5 +1,5 @@
 from happyboom.common.packer import packUtf8, packBin
-from happyboom.common.simple_event import EventLauncher, EventListener
+from happyboom.common.simple_event import EventListener
 from happyboom.common.log import log
 from happyboom.common.packer import unpack, unpackBin, unpackUtf8
 from happyboom.net.io.packet import Packet
@@ -10,7 +10,7 @@
     def __init__(self, msg):
         Exception.__init__(self, msg)
 
-class Presentation(EventLauncher, EventListener):
+class Presentation(EventListener):
     
     CONNECTION    = 0x1
     DISCONNECTION = 0x2
@@ -21,13 +21,36 @@
     
     def __init__(self, protocol, is_server):
         EventListener.__init__(self)
-        EventLauncher.__init__(self)
         self.protocol = protocol
         self.items = {}
         self.gateway = None
-        self.client_manager = None
         self.is_server = is_server 
+        self._unpackFunc = { \
+            self.CONNECTION: self.unpackConnection,
+            self.DISCONNECTION: self.unpackDisconnect,
+            self.FEATURES: self.unpackFeatures,
+            self.CREATE: self.unpackCreateItem,
+            self.DESTROY: self.unpackDestroyItem,
+            self.EVENT: self.unpackEvent}
+
+        # Event (IOClient client, str version, str signature)
+        self._on_client_connection = None
+
+        # Event (IOClient client, str features)
+        self._on_features = None
         
+        # Event (IOClient client)
+        self._on_client_disconnection = None
+
+        # Event (IOClient client, str feature, str event, str arguments)
+        self._on_recv_event = None
+
+        # Event (IOClient client, str type, int id)
+        self._on_create_item = None
+
+        # Event (IOClient client, int id)
+        self._on_destroy_item = None
+        
     def processPacket(self, packet):
         """ Processes incomming network packets (converts and launches local event).
         @param packet: incomming network packet.
@@ -42,25 +65,15 @@
         data = data[i:]
 
         # Choose process function
-        if ptype == self.CONNECTION:
-            data = self.recvConnection(packet.recv_from, data)
-        elif ptype == self.DISCONNECTION:
-            data = self.processDisconnect(packet.recv_from, data)
-        elif ptype == self.FEATURES:
-            data = self.processFeatures(packet.recv_from, data)
-        elif ptype == self.CREATE:
-            data = self.createItem(data)
-        elif ptype == self.DESTROY:
-            data = self.destroyItem(data)
-        elif ptype == self.EVENT:
-            data = self.processEvent(data)
+        if ptype in self._unpackFunc:
+            self._unpackFunc(packet.recv_from, data)
         else:
             log.warning("ProtocoleWarning: received unexpected packet type %s." % ptype)
         if len(data) != 0:
             log.warning("ProtocolWarning: Received a message with an unexpected length.")
             log.warning(u"Rest: [%s]." % data)
 
-    def processDisconnect(self, ioclient, data):
+    def unpackDisconnect(self, ioclient, data):
         reason, data = unpackUtf8(data)
         if self.is_server:
             self.client_manager.closeClient(ioclient)
@@ -69,30 +82,34 @@
             self.launchEvent("happyboom", "stop")
         return data
         
-    def processFeatures(self, ioclient, data):
+    def unpackFeatures(self, ioclient, data):
         features, data = unpackBin(data)
-        print "Features: %s" % (features)
-        client = Client(ioclient, self.gateway, self.client_manager)
-        self.client_manager.appendClient(client)
+        if self._on_features != None:
+            self._on_features(ioclient, features)
         return data
 
-    def recvConnection(self, client, data):
+    def evt_happyboom_closeConnection(self, ioclient, reason):
+        """
+        Close client connection.
+        @type ioclient L{IOClient}
+        @type reason Unicode
+        """
+        self.evt_happyboom_clientDisconnection(ioclient, reason)
+
+    def unpackConnection(self, ioclient, data):
         version, data = unpackBin(data)
         signature, data = unpackBin(data) 
         
-        if version != self.protocol.version:
-            # TODO: send presentation bye(<why>)
-            raise PresentationException("Wrong protocol version.")
-        else:
-            if self.is_server:
-                # Send hello().
-                self.client_manager.generateSignature(client)
-                packet = self.connectionPacket(signature)
-            else:
-                # Send features().
-                self.launchEvent("signature", (signature,))
-                packet = self.featuresPacket()
-            client.send(packet)
+        if self._on_client_connection != None:
+            self._on_client_connection(ioclient, version, signature)
+#        if version != self.protocol.version:
+#            # TODO: send presentation bye(<why>)
+#            raise PresentationException("Wrong protocol version.")
+#        else:
+#            if not self.is_server:
+#                self.launchEvent("signature", (signature,))
+#                packet = self.featuresPacket()
+#                ioclient.send(packet)
         return data
             
     def featuresPacket(self, features="TODO: Feed me!"):
@@ -100,29 +117,43 @@
         data = data + packBin(features)
         return Packet(data)
        
-    def createItem(self, data):
+    def unpackCreateItem(self, data):
         # TODO
         return data
 
-    def connectionPacket(self, signature=""):
+    def evt_happyboom_clientConnection(self, ioclient, version, signature=""):
+        """
+        Send a connection message to ioclient.
+        @type version ASCII string
+        @type signature string
+        """
+        
         data = struct.pack("!B", self.CONNECTION)
-        data = data + packBin(self.protocol.version.encode("ascii"))
+        data = data + packBin(version)
         data = data + packBin(signature)
-        return Packet(data)
+        ioclient.send( Packet(data) )
 
-    def disconnectionPacket(self, reason):
+    def evt_happyboom_clientDisconnection(self, ioclient, reason):
+        """
+        Send a disconnection message to ioclient.
+        @type ioclient L{IOClient}
+        @type reason Unicode
+        """
+        
         data = struct.pack("!B", self.DISCONNECTION) + packUtf8(reason)
-        return Packet(data)
+        ioclient.send( Packet(data) )
+        ioclient.disconnect()
 
-    def sendMsg(self, data):
+    def evt_happyboom_event(self, clients, data):
         data = struct.pack("!B", self.EVENT) + data
-        return data
+        packet = Packet(data)
+        for client in clients: client.send(packet)
         
-    def destroyItem(self, data):
+    def unpackDestroyItem(self, data):
         # TODO
         return data
     
-    def processEvent(self, data):
+    def unpackEvent(self, ioclient, data):
         fmt = "!BB"
         i = struct.calcsize(fmt)
         feature_id, event_id = struct.unpack(fmt, data[:i])

Modified: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-15 19:35:03 UTC (rev 165)
+++ happyboom/trunk/server/agent.py	2005-09-15 20:12:12 UTC (rev 166)
@@ -23,7 +23,7 @@
         self.sendBroadcastMessage(message, "%s_listener" %self.type)
 
     def sendNetMsg(self, func, event, *args):
-        self._gateway.sendNetMsg(func, event, *args)
+        self.launchEvent("happyboom", "network", func, event, *args)
 
     def messageReceived(self, msg):
         if self.__debug:

Modified: happyboom/trunk/server/client.py
===================================================================
--- happyboom/trunk/server/client.py	2005-09-15 19:35:03 UTC (rev 165)
+++ happyboom/trunk/server/client.py	2005-09-15 20:12:12 UTC (rev 166)
@@ -16,9 +16,7 @@
         return self.__io.__str__()
 
     def disconnect(self, reason):
-        packet = self.__gateway.presentation.disconnectionPacket(reason)
-        self.sendPacket(packet)
-        self.stop()        
+        self.launchEvent("happyboom", "clientDisconnect", self.__io, reason)
 
     # Stop client: close socket.
     def stop(self):
@@ -34,13 +32,13 @@
         self.__io.send(packet)
 
     # Send a HappyBoom message to the client (see L{sendPacket})
-    def sendNetMsg(self, func, event, *args):
+    def sendNetMsg(self, feature, event, *args):
         try:
-            packet = self.__gateway.createMsg(func, event, *args)
+            data = self.__protocol.createMsg(feature, event, *args)
         except ProtocolException, err:
             log.error(err)
             return
-        self.__io.send(packet)
+        self.launchEvent("happyboom", "event", (self,), data);
 
     def __getAddr(self): return self.__io.addr
     addr = property(__getAddr)

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-15 19:35:03 UTC (rev 165)
+++ happyboom/trunk/server/client_manager.py	2005-09-15 20:12:12 UTC (rev 166)
@@ -1,11 +1,14 @@
 from happyboom.net import io, io_udp, io_tcp, net_buffer
+from happyboom.common.packer import unpackBin
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
 from happyboom.server.client import Client
+from happyboom.common.simple_event import EventLauncher
 import thread, time
 
-class ClientManager(object):
+class ClientManager(EventLauncher, object):
     def __init__(self, arg): 
+        EventLauncher.__init__(self)
         self.server = None 
         self.__io = io_tcp.IO_TCP(is_server=True)
         self.__io.debug = arg.get("debug", False)
@@ -20,7 +23,36 @@
         self.__clients_lock = thread.allocate_lock()
         self.gateway = None
         self.presentation = None
-        
+
+    def onClientConnection(self, ioclient, version, signature):
+        # TODO: Et le cas o? signature ne vaut pas "" ???
+        if version == self.protocol.version:
+            signature = self.generateSignature(ioclient)
+            self.launchEvent("happyboom", "clientConnection", ioclient, self.version, signature)
+        else:    
+            self.launchEvent("happyboom", "closeConnection", ioclient, u"Wrong server version")
+
+    def onClientFeatures(self, ioclient, features):
+        # Register client in the clients list
+        client = Client(ioclient, self.gateway, self)
+        self.__clients_lock.acquire() 
+        self.__clients[client.addr] = client
+        self.__clients_lock.release() 
+
+        # Register client to features
+        features = unpackBin(features)
+        for feature in features:
+            if feature in self.__supported_features:
+                self.__supported_features[feature].append(ioclient)
+            else:
+                self.__supported_features[feature] = [ioclient]
+      
+        # Send message to network and to the log
+        txt = u"Welcome to new (display) client : %s" % client
+        log.info("[*] Client %s connected" % client)
+        self.launchEvent("happyboom", "network", "info", "notice", txt)
+        self.launchEvent("happyboom", "newClient", client)
+
     def recvClientPacket(self, packet):
         self.__buffer.append(packet.recv_from.addr, packet)
 
@@ -39,6 +71,7 @@
         self.__io.on_client_disconnect = self.closeClient
         self.__io.on_new_packet = self.presentation.processPacket
         self.__io.connect('', self.client_port)
+        self.launchEvent("happyboom", "register", "on_connection", self.onClientConnection)
         thread.start_new_thread(self.run_io_thread, ())
 
     def readClientAnswer(self, client, timeout=1.000):
@@ -105,17 +138,7 @@
         client = self.__clients.get(addr, None)
         self.__clients_lock.release() 
         return client
-    
-    def appendClient(self, client):
-        self.__clients_lock.acquire() 
-        self.__clients[client.addr] = client
-        self.__clients_lock.release() 
-
-        txt = u"Welcome to new (display) client : %s" % client
-        self.gateway.sendText(txt)
-        log.info("[*] Display %s connected" % client)
-        self.gateway.send("sync")
-    
+        
     def __getSupportedFeatures(self): return self.__supported_features
     supported_features = property(__getSupportedFeatures)
 

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-15 19:35:03 UTC (rev 165)
+++ happyboom/trunk/server/gateway.py	2005-09-15 20:12:12 UTC (rev 166)
@@ -3,10 +3,12 @@
 from happyboom.net.io import Packet
 from happyboom.common.log import log
 from pysma import Kernel, DummyScheduler
+from happyboom.common.simple_event import EventListener
 import struct
 
-class Gateway(Agent):
+class Gateway(Agent, EventListener):
     def __init__(self, protocol, presentation, client_manager, arg):
+        EventListener.__init__(self)
         Agent.__init__(self, self, "gateway")
         self.__protocol = protocol
         self.client_manager = client_manager
@@ -18,6 +20,7 @@
         self._debug = arg.get("debug", False)
         self._verbose = arg.get("verbose", False)
         self.__scheduler = DummyScheduler(sleep=0.01)
+        self.registerEvent("happyboom")
         Kernel().addAgent(self.__scheduler)
 
     def __setServer(self, server):
@@ -25,12 +28,9 @@
         self.client_manager.server = server
     server = property(None, __setServer)
 
-    # Create a network packet for the event feature.event(args)
-    def createMsg(self, feature, event, *args):
-        data = self.__protocol.createMsg(feature, event, *args)
-        data = self.presentation.sendMsg(data)
-        return Packet(data)
-            
+    def evt_happyboom_network(self, feature, event, *args):
+        self.sendMsg(feature, event, *args)
+        
     def start(self):
         self.client_manager.start()
         Kernel.instance.addAgent(self)
@@ -56,15 +56,18 @@
         message = Message("%s_%s" % (feature, event), args)
         self.sendBroadcastMessage(message, "%s_listener" % feature)
 
+    def evt_happyboom_newClient(self, client):
+        self.send("sync") #TODO: Add client argument ...
+
     def sendNetMsg(self, feature, event, *args):
+        clients = self.client_manager.supported_features.get(feature, ())
+        if len(clients)==0: return
         try:
-            packet = self.createMsg(feature, event, *args)
+            data = self.__protocol.createMsg(feature, event, *args)
         except ProtocolException, err:
             log.error(err)
             return
-        clients = self.client_manager.supported_features.get(feature, ())
-        for client in clients:
-            client.sendPacket(packet)
+        self.launchEvent("happyboom", "event", clients, data);
 
     def __getProtocolVersion(self): return self.__protocol.version
     protocol_version = property(__getProtocolVersion)

Modified: poilu/trunk/insulte.txt
===================================================================
--- poilu/trunk/insulte.txt	2005-09-15 19:35:03 UTC (rev 165)
+++ poilu/trunk/insulte.txt	2005-09-15 20:12:12 UTC (rev 166)
@@ -1,4 +1,3 @@
-mdr:Ta gueule grosse vache !
 asp:"dot NET" ?apucpalibre
 oracle:Oracle ?apucpalibre, PostgreSQL c'est libre au moins!
 java:Java ?apucpalibre, utilisez Python !

Modified: poilu/trunk/motcle_regex.txt
===================================================================
--- poilu/trunk/motcle_regex.txt	2005-09-15 19:35:03 UTC (rev 165)
+++ poilu/trunk/motcle_regex.txt	2005-09-15 20:12:12 UTC (rev 166)
@@ -1,4 +1,3 @@
-mdr:([Mm]dr|lo+l|ptdr+)
 asp:(ASP|\.(NET|Net))
 oracle:[Oo]racle
 java:[Jj]ava



From dboucard at berlios.de  Thu Sep 15 22:35:10 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 22:35:10 +0200
Subject: [Happyboom-svn] r167 - happyboom/trunk/common
Message-ID: <200509152035.j8FKZAMr031376@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 22:35:10 +0200 (Thu, 15 Sep 2005)
New Revision: 167

Modified:
   happyboom/trunk/common/presentation.py
Log:
IO_Client


Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 20:12:12 UTC (rev 166)
+++ happyboom/trunk/common/presentation.py	2005-09-15 20:35:10 UTC (rev 167)
@@ -33,22 +33,22 @@
             self.DESTROY: self.unpackDestroyItem,
             self.EVENT: self.unpackEvent}
 
-        # Event (IOClient client, str version, str signature)
+        # Event (IO_Client client, str version, str signature)
         self._on_client_connection = None
 
-        # Event (IOClient client, str features)
+        # Event (IO_Client client, str features)
         self._on_features = None
         
-        # Event (IOClient client)
+        # Event (IO_Client client)
         self._on_client_disconnection = None
 
-        # Event (IOClient client, str feature, str event, str arguments)
+        # Event (IO_Client client, str feature, str event, str arguments)
         self._on_recv_event = None
 
-        # Event (IOClient client, str type, int id)
+        # Event (IO_Client client, str type, int id)
         self._on_create_item = None
 
-        # Event (IOClient client, int id)
+        # Event (IO_Client client, int id)
         self._on_destroy_item = None
         
     def processPacket(self, packet):



From haypo at berlios.de  Thu Sep 15 23:24:02 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 15 Sep 2005 23:24:02 +0200
Subject: [Happyboom-svn] r168 - in happyboom/trunk: common server
Message-ID: <200509152124.j8FLO2qX002442@sheep.berlios.de>

Author: haypo
Date: 2005-09-15 23:24:01 +0200 (Thu, 15 Sep 2005)
New Revision: 168

Modified:
   happyboom/trunk/common/event.py
   happyboom/trunk/common/generic_event.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Fixe les vilains bugs a Damien (bouuuuuuuuuh).


Modified: happyboom/trunk/common/event.py
===================================================================
--- happyboom/trunk/common/event.py	2005-09-15 20:35:10 UTC (rev 167)
+++ happyboom/trunk/common/event.py	2005-09-15 21:24:01 UTC (rev 168)
@@ -13,21 +13,22 @@
     def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
         """ EventListener constructor.
         """
-        evt.EventListener.__init__(self, prefix, suffix, __eventPerformed, silent)
+        evt.EventListener.__init__(self, prefix, suffix, "happyboomEventPerformed", silent)
         self.hb_default = default
         
     def getEventName(self, feature, event):
         return "%s_%s" %(feature, event)
         
-    def __eventPerformed(self, event):
-        if issubclass(event, Event):
+    def happyboomEventPerformed(self, event):
+        if issubclass(event.__class__, Event):
             # Try to call event-specific handle method
             fctname = self.pattern %(self.getEventName(event.type, event.event))
             if hasattr(self, fctname):
                 function = getattr(self, fctname)
                 if callable(function):
-                    function(event)
+                    function(*event.content)
                     return
+
         # Try to call default handle method
         if hasattr(self, self.hb_default):
             function = getattr(self, self.hb_default)
@@ -35,8 +36,8 @@
                 function(event)
                 return
         # No handle method found, raise error ?
-        if not obj.silent:
-            raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
+        if not self.event_silent:
+            raise evt.UnhandledEventError("%s has no method to handle %s" %(self, event))
 
 class EventLauncher(evt.EventLauncher):
     """ Happyboom generic class for launching events.
@@ -65,4 +66,4 @@
         @rtype: C{str}
         """
         return "<event.Event feature=%s event=%s source=%s content=%s>" %(self.type, self.event, self.source, self.content)
-    
\ No newline at end of file
+    

Modified: happyboom/trunk/common/generic_event.py
===================================================================
--- happyboom/trunk/common/generic_event.py	2005-09-15 20:35:10 UTC (rev 167)
+++ happyboom/trunk/common/generic_event.py	2005-09-15 21:24:01 UTC (rev 168)
@@ -62,7 +62,7 @@
                         function(event)
                         continue
                 # No handle method found, raise error ?
-                if not obj.silent:
+                if not obj.event_silent:
                     raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
         else:
             print("Pas de event.type %s" % event.type)
@@ -103,7 +103,7 @@
         self.manager = EventManager.instance
         self.pattern = prefix + "%s" + suffix
         self.default = default
-        self.silent = silent
+        self.event_silent = silent
         
     def registerEvent(self, event_type):
         """ Registers itself to a new event.

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 20:35:10 UTC (rev 167)
+++ happyboom/trunk/common/presentation.py	2005-09-15 21:24:01 UTC (rev 168)
@@ -1,5 +1,5 @@
 from happyboom.common.packer import packUtf8, packBin
-from happyboom.common.simple_event import EventListener
+from happyboom.common.event import EventListener
 from happyboom.common.log import log
 from happyboom.common.packer import unpack, unpackBin, unpackUtf8
 from happyboom.net.io.packet import Packet
@@ -20,7 +20,7 @@
     EVENT         = 0x6
     
     def __init__(self, protocol, is_server):
-        EventListener.__init__(self)
+        EventListener.__init__(self, "evt_", silent=True)
         self.protocol = protocol
         self.items = {}
         self.gateway = None
@@ -32,6 +32,7 @@
             self.CREATE: self.unpackCreateItem,
             self.DESTROY: self.unpackDestroyItem,
             self.EVENT: self.unpackEvent}
+        self.registerEvent("happyboom")
 
         # Event (IO_Client client, str version, str signature)
         self._on_client_connection = None
@@ -50,7 +51,7 @@
 
         # Event (IO_Client client, int id)
         self._on_destroy_item = None
-        
+
     def processPacket(self, packet):
         """ Processes incomming network packets (converts and launches local event).
         @param packet: incomming network packet.
@@ -88,6 +89,11 @@
             self._on_features(ioclient, features)
         return data
 
+    def evt_happyboom_register(self, event, handler):
+        import re
+        if hasattr(self, event) and re.compile("^_on_").search(event):
+            self.setattr(event, handler, handler)
+    
     def evt_happyboom_closeConnection(self, ioclient, reason):
         """
         Close client connection.

Modified: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-15 20:35:10 UTC (rev 167)
+++ happyboom/trunk/server/agent.py	2005-09-15 21:24:01 UTC (rev 168)
@@ -1,11 +1,13 @@
 from pysma import ActionAgent, ActionMessage as Message
 from happyboom.common.log import log
+from happyboom.common.event import EventLauncher
 
-class Agent(ActionAgent):
+class Agent(ActionAgent, EventLauncher):
     """
     SMA agent in HappyBoom.
     """
     def __init__(self, type, gateway, **args):
+        EventLauncher.__init__(self)
         ActionAgent.__init__(self, prefix="msg_")
         self._gateway = gateway
         self.type = type

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-15 20:35:10 UTC (rev 167)
+++ happyboom/trunk/server/client_manager.py	2005-09-15 21:24:01 UTC (rev 168)
@@ -3,7 +3,7 @@
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
 from happyboom.server.client import Client
-from happyboom.common.simple_event import EventLauncher
+from happyboom.common.event import EventLauncher
 import thread, time
 
 class ClientManager(EventLauncher, object):

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-15 20:35:10 UTC (rev 167)
+++ happyboom/trunk/server/gateway.py	2005-09-15 21:24:01 UTC (rev 168)
@@ -3,12 +3,12 @@
 from happyboom.net.io import Packet
 from happyboom.common.log import log
 from pysma import Kernel, DummyScheduler
-from happyboom.common.simple_event import EventListener
+from happyboom.common.event import EventListener
 import struct
 
 class Gateway(Agent, EventListener):
     def __init__(self, protocol, presentation, client_manager, arg):
-        EventListener.__init__(self)
+        EventListener.__init__(self, "evt_", silent=True)
         Agent.__init__(self, self, "gateway")
         self.__protocol = protocol
         self.client_manager = client_manager
@@ -28,6 +28,9 @@
         self.client_manager.server = server
     server = property(None, __setServer)
 
+#    def eventPerformed(self, event):
+#        print "gzzz", event
+
     def evt_happyboom_network(self, feature, event, *args):
         self.sendMsg(feature, event, *args)
         
@@ -42,8 +45,9 @@
 
     def process(self):
         # Stop server if the scheduler is dead
-        if not self.__scheduler.alive:
-            self.__server.stop()
+#       TODO: Waiting for last PySMA version...        
+#        if not self.__scheduler.alive:
+#            self.__server.stop()
         self.client_manager.process()
 
     def sendText(self, txt, client=None):



From dboucard at berlios.de  Thu Sep 15 23:35:33 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 23:35:33 +0200
Subject: [Happyboom-svn] r169 - happyboom/trunk/common
Message-ID: <200509152135.j8FLZXgX003467@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 23:35:33 +0200 (Thu, 15 Sep 2005)
New Revision: 169

Added:
   happyboom/trunk/common/happyboom_protocol.py
Modified:
   happyboom/trunk/common/presentation.py
Log:
split prensentation in two for alternative presentation protocol


Added: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-15 21:24:01 UTC (rev 168)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-15 21:35:33 UTC (rev 169)
@@ -0,0 +1,42 @@
+    def unpackPacketType(self, data):
+        # Get packet type
+        fmt = "!B"
+        i = struct.calcsize(fmt)
+        ptype, = struct.unpack(fmt, data[:i]) 
+        return data[i:]
+
+    def unpackDisconnect(self, ioclient, data):
+        reason, data = unpackUtf8(data)
+        if self.is_server:
+            self.client_manager.closeClient(ioclient)
+        else:
+            log.warning(u"Received disconnected from server: %s" % reason)
+            self.launchEvent("happyboom", "stop")
+        return data
+        
+    def unpackFeatures(self, ioclient, data):
+        features, data = unpackBin(data)
+        if self._on_features != None:
+            self._on_features(ioclient, features)
+        return data
+
+    def unpackCreateItem(self, data):
+        # TODO
+        return data
+
+    def unpackDestroyItem(self, data):
+        # TODO
+        return data
+    
+    def unpackEvent(self, ioclient, data):
+        fmt = "!BB"
+        i = struct.calcsize(fmt)
+        feature_id, event_id = struct.unpack(fmt, data[:i])
+        data = data[i:]
+
+        feature, event, args = unpack(data, feature_id, event_id, self.protocol)
+        log.info("Received: %s.%s(%s)" \
+            % (feature, event, args))
+
+        self.gateway.recvNetMsg(feature, event, args)
+        return ""

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 21:24:01 UTC (rev 168)
+++ happyboom/trunk/common/presentation.py	2005-09-15 21:35:33 UTC (rev 169)
@@ -57,14 +57,8 @@
         @param packet: incomming network packet.
         @type packet: C{net.io.packet.Packet}
         """
-      
-        # Get packet type
-        data = packet.data
-        fmt = "!B"
-        i = struct.calcsize(fmt)
-        ptype, = struct.unpack(fmt, data[:i]) 
-        data = data[i:]
-
+        data = unpackPacketType(packet.data)
+        
         # Choose process function
         if ptype in self._unpackFunc:
             self._unpackFunc(packet.recv_from, data)
@@ -74,21 +68,6 @@
             log.warning("ProtocolWarning: Received a message with an unexpected length.")
             log.warning(u"Rest: [%s]." % data)
 
-    def unpackDisconnect(self, ioclient, data):
-        reason, data = unpackUtf8(data)
-        if self.is_server:
-            self.client_manager.closeClient(ioclient)
-        else:
-            log.warning(u"Received disconnected from server: %s" % reason)
-            self.launchEvent("happyboom", "stop")
-        return data
-        
-    def unpackFeatures(self, ioclient, data):
-        features, data = unpackBin(data)
-        if self._on_features != None:
-            self._on_features(ioclient, features)
-        return data
-
     def evt_happyboom_register(self, event, handler):
         import re
         if hasattr(self, event) and re.compile("^_on_").search(event):
@@ -123,10 +102,6 @@
         data = data + packBin(features)
         return Packet(data)
        
-    def unpackCreateItem(self, data):
-        # TODO
-        return data
-
     def evt_happyboom_clientConnection(self, ioclient, version, signature=""):
         """
         Send a connection message to ioclient.
@@ -155,19 +130,9 @@
         packet = Packet(data)
         for client in clients: client.send(packet)
         
-    def unpackDestroyItem(self, data):
-        # TODO
-        return data
-    
-    def unpackEvent(self, ioclient, data):
-        fmt = "!BB"
-        i = struct.calcsize(fmt)
-        feature_id, event_id = struct.unpack(fmt, data[:i])
-        data = data[i:]
-
-        feature, event, args = unpack(data, feature_id, event_id, self.protocol)
-        log.info("Received: %s.%s(%s)" \
-            % (feature, event, args))
-
-        self.gateway.recvNetMsg(feature, event, args)
-        return ""
+    def unpackPacketType(self, data): pass
+    def unpackDisconnect(self, ioclient, data): pass
+    def unpackFeatures(self, ioclient, data): pass
+    def unpackCreateItem(self, data): pass
+    def unpackDestroyItem(self, data): pass
+    def unpackEvent(self, ioclient, data): pass
\ No newline at end of file



From haypo at berlios.de  Thu Sep 15 23:38:43 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 15 Sep 2005 23:38:43 +0200
Subject: [Happyboom-svn] r170 - in happyboom/trunk: common server
Message-ID: <200509152138.j8FLchff003736@sheep.berlios.de>

Author: haypo
Date: 2005-09-15 23:38:43 +0200 (Thu, 15 Sep 2005)
New Revision: 170

Modified:
   happyboom/trunk/common/presentation.py
   happyboom/trunk/server/gateway.py
Log:
Change happyboom en prensentationProtocol pour les evenements.


Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 21:35:33 UTC (rev 169)
+++ happyboom/trunk/common/presentation.py	2005-09-15 21:38:43 UTC (rev 170)
@@ -32,7 +32,7 @@
             self.CREATE: self.unpackCreateItem,
             self.DESTROY: self.unpackDestroyItem,
             self.EVENT: self.unpackEvent}
-        self.registerEvent("happyboom")
+        self.registerEvent("presentationProtocol")
 
         # Event (IO_Client client, str version, str signature)
         self._on_client_connection = None
@@ -68,18 +68,18 @@
             log.warning("ProtocolWarning: Received a message with an unexpected length.")
             log.warning(u"Rest: [%s]." % data)
 
-    def evt_happyboom_register(self, event, handler):
+    def evt_presentationProtocol_register(self, event, handler):
         import re
         if hasattr(self, event) and re.compile("^_on_").search(event):
             self.setattr(event, handler, handler)
     
-    def evt_happyboom_closeConnection(self, ioclient, reason):
+    def evt_presentationProtocol_closeConnection(self, ioclient, reason):
         """
         Close client connection.
         @type ioclient L{IOClient}
         @type reason Unicode
         """
-        self.evt_happyboom_clientDisconnection(ioclient, reason)
+        self.evt_presentationProtocol_clientDisconnection(ioclient, reason)
 
     def unpackConnection(self, ioclient, data):
         version, data = unpackBin(data)
@@ -102,7 +102,7 @@
         data = data + packBin(features)
         return Packet(data)
        
-    def evt_happyboom_clientConnection(self, ioclient, version, signature=""):
+    def evt_presentationProtocol_clientConnection(self, ioclient, version, signature=""):
         """
         Send a connection message to ioclient.
         @type version ASCII string
@@ -114,7 +114,7 @@
         data = data + packBin(signature)
         ioclient.send( Packet(data) )
 
-    def evt_happyboom_clientDisconnection(self, ioclient, reason):
+    def evt_presentationProtocol_clientDisconnection(self, ioclient, reason):
         """
         Send a disconnection message to ioclient.
         @type ioclient L{IOClient}
@@ -125,7 +125,7 @@
         ioclient.send( Packet(data) )
         ioclient.disconnect()
 
-    def evt_happyboom_event(self, clients, data):
+    def evt_presentationProtocol_event(self, clients, data):
         data = struct.pack("!B", self.EVENT) + data
         packet = Packet(data)
         for client in clients: client.send(packet)

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-15 21:35:33 UTC (rev 169)
+++ happyboom/trunk/server/gateway.py	2005-09-15 21:38:43 UTC (rev 170)
@@ -71,7 +71,7 @@
         except ProtocolException, err:
             log.error(err)
             return
-        self.launchEvent("happyboom", "event", clients, data);
+        self.launchEvent("presentationProtocol", "event", clients, data);
 
     def __getProtocolVersion(self): return self.__protocol.version
     protocol_version = property(__getProtocolVersion)



From dboucard at berlios.de  Thu Sep 15 23:40:57 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 23:40:57 +0200
Subject: [Happyboom-svn] r171 - happyboom/trunk/common
Message-ID: <200509152140.j8FLevp6003956@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 23:40:57 +0200 (Thu, 15 Sep 2005)
New Revision: 171

Modified:
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/presentation.py
Log:


Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-15 21:38:43 UTC (rev 170)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-15 21:40:57 UTC (rev 171)
@@ -1,3 +1,8 @@
+from presentation import Presentation
+from packer import *
+
+
+class HappyboomProtocol(Presentation):
     def unpackPacketType(self, data):
         # Get packet type
         fmt = "!B"

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 21:38:43 UTC (rev 170)
+++ happyboom/trunk/common/presentation.py	2005-09-15 21:40:57 UTC (rev 171)
@@ -1,7 +1,5 @@
-from happyboom.common.packer import packUtf8, packBin
 from happyboom.common.event import EventListener
 from happyboom.common.log import log
-from happyboom.common.packer import unpack, unpackBin, unpackUtf8
 from happyboom.net.io.packet import Packet
 from happyboom.server.client import Client
 import struct



From dboucard at berlios.de  Thu Sep 15 23:43:30 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Thu, 15 Sep 2005 23:43:30 +0200
Subject: [Happyboom-svn] r172 - happyboom/trunk/common
Message-ID: <200509152143.j8FLhUKZ004405@sheep.berlios.de>

Author: dboucard
Date: 2005-09-15 23:43:29 +0200 (Thu, 15 Sep 2005)
New Revision: 172

Modified:
   happyboom/trunk/common/presentation.py
Log:


Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 21:40:57 UTC (rev 171)
+++ happyboom/trunk/common/presentation.py	2005-09-15 21:43:29 UTC (rev 172)
@@ -30,7 +30,7 @@
             self.CREATE: self.unpackCreateItem,
             self.DESTROY: self.unpackDestroyItem,
             self.EVENT: self.unpackEvent}
-        self.registerEvent("presentationProtocol")
+        self.registerEvent("happyboom")
 
         # Event (IO_Client client, str version, str signature)
         self._on_client_connection = None
@@ -66,18 +66,18 @@
             log.warning("ProtocolWarning: Received a message with an unexpected length.")
             log.warning(u"Rest: [%s]." % data)
 
-    def evt_presentationProtocol_register(self, event, handler):
+    def evt_happyboom_register(self, event, handler):
         import re
         if hasattr(self, event) and re.compile("^_on_").search(event):
             self.setattr(event, handler, handler)
     
-    def evt_presentationProtocol_closeConnection(self, ioclient, reason):
+    def evt_happyboom_closeConnection(self, ioclient, reason):
         """
         Close client connection.
         @type ioclient L{IOClient}
         @type reason Unicode
         """
-        self.evt_presentationProtocol_clientDisconnection(ioclient, reason)
+        self.evt_happyboom_clientDisconnection(ioclient, reason)
 
     def unpackConnection(self, ioclient, data):
         version, data = unpackBin(data)
@@ -100,7 +100,7 @@
         data = data + packBin(features)
         return Packet(data)
        
-    def evt_presentationProtocol_clientConnection(self, ioclient, version, signature=""):
+    def evt_happyboom_clientConnection(self, ioclient, version, signature=""):
         """
         Send a connection message to ioclient.
         @type version ASCII string
@@ -112,7 +112,7 @@
         data = data + packBin(signature)
         ioclient.send( Packet(data) )
 
-    def evt_presentationProtocol_clientDisconnection(self, ioclient, reason):
+    def evt_happyboom_clientDisconnection(self, ioclient, reason):
         """
         Send a disconnection message to ioclient.
         @type ioclient L{IOClient}
@@ -123,7 +123,7 @@
         ioclient.send( Packet(data) )
         ioclient.disconnect()
 
-    def evt_presentationProtocol_event(self, clients, data):
+    def evt_happyboom_event(self, clients, data):
         data = struct.pack("!B", self.EVENT) + data
         packet = Packet(data)
         for client in clients: client.send(packet)



From haypo at berlios.de  Thu Sep 15 23:59:27 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 15 Sep 2005 23:59:27 +0200
Subject: [Happyboom-svn] r173 - happyboom/trunk/common
Message-ID: <200509152159.j8FLxRFi005267@sheep.berlios.de>

Author: haypo
Date: 2005-09-15 23:59:26 +0200 (Thu, 15 Sep 2005)
New Revision: 173

Modified:
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/presentation.py
Log:
Je sais plus.


Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-15 21:43:29 UTC (rev 172)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-15 21:59:26 UTC (rev 173)
@@ -1,7 +1,6 @@
 from presentation import Presentation
-from packer import *
+from happyboom.common.packer import unpack, unpackBin, unpackUtf8, unpackInt
 
-
 class HappyboomProtocol(Presentation):
     def unpackPacketType(self, data):
         # Get packet type
@@ -25,12 +24,17 @@
             self._on_features(ioclient, features)
         return data
 
-    def unpackCreateItem(self, data):
-        # TODO
+    def unpackCreateItem(self, ioclient, data):
+        itemid,data = unpackInt(data)
+        type,data = unpackBin(data)
+        if self._on_create_item != None:
+            self._on_create_item(ioclient, type, itemid)
         return data
 
-    def unpackDestroyItem(self, data):
-        # TODO
+    def unpackDestroyItem(self, ioclient, data):
+        itemid,data = unpackInt(data)
+        if self._on_destroy_item != None:
+            self._on_destroy_item(ioclient, itemid)
         return data
     
     def unpackEvent(self, ioclient, data):

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 21:43:29 UTC (rev 172)
+++ happyboom/trunk/common/presentation.py	2005-09-15 21:59:26 UTC (rev 173)
@@ -133,4 +133,4 @@
     def unpackFeatures(self, ioclient, data): pass
     def unpackCreateItem(self, data): pass
     def unpackDestroyItem(self, data): pass
-    def unpackEvent(self, ioclient, data): pass
\ No newline at end of file
+    def unpackEvent(self, ioclient, data): pass



From haypo at berlios.de  Fri Sep 16 00:05:45 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 00:05:45 +0200
Subject: [Happyboom-svn] r174 - in happyboom/trunk: common server
Message-ID: <200509152205.j8FM5jL2005651@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 00:05:45 +0200 (Fri, 16 Sep 2005)
New Revision: 174

Modified:
   happyboom/trunk/common/presentation.py
   happyboom/trunk/server/client_manager.py
Log:
happyboom.register n'a plus besoin du "_on_" en prefixe.


Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 21:59:26 UTC (rev 173)
+++ happyboom/trunk/common/presentation.py	2005-09-15 22:05:45 UTC (rev 174)
@@ -33,13 +33,13 @@
         self.registerEvent("happyboom")
 
         # Event (IO_Client client, str version, str signature)
-        self._on_client_connection = None
+        self._on_connection = None
 
         # Event (IO_Client client, str features)
         self._on_features = None
         
         # Event (IO_Client client)
-        self._on_client_disconnection = None
+        self._on_disconnection = None
 
         # Event (IO_Client client, str feature, str event, str arguments)
         self._on_recv_event = None
@@ -67,8 +67,8 @@
             log.warning(u"Rest: [%s]." % data)
 
     def evt_happyboom_register(self, event, handler):
-        import re
-        if hasattr(self, event) and re.compile("^_on_").search(event):
+        event = "_on_"+event
+        if hasattr(self, event):
             self.setattr(event, handler, handler)
     
     def evt_happyboom_closeConnection(self, ioclient, reason):
@@ -77,14 +77,14 @@
         @type ioclient L{IOClient}
         @type reason Unicode
         """
-        self.evt_happyboom_clientDisconnection(ioclient, reason)
+        self.evt_happyboom_disconnection(ioclient, reason)
 
     def unpackConnection(self, ioclient, data):
         version, data = unpackBin(data)
         signature, data = unpackBin(data) 
         
-        if self._on_client_connection != None:
-            self._on_client_connection(ioclient, version, signature)
+        if self._on_connection != None:
+            self._on_connection(ioclient, version, signature)
 #        if version != self.protocol.version:
 #            # TODO: send presentation bye(<why>)
 #            raise PresentationException("Wrong protocol version.")
@@ -100,7 +100,7 @@
         data = data + packBin(features)
         return Packet(data)
        
-    def evt_happyboom_clientConnection(self, ioclient, version, signature=""):
+    def evt_happyboom_connection(self, ioclient, version, signature=""):
         """
         Send a connection message to ioclient.
         @type version ASCII string
@@ -112,7 +112,7 @@
         data = data + packBin(signature)
         ioclient.send( Packet(data) )
 
-    def evt_happyboom_clientDisconnection(self, ioclient, reason):
+    def evt_happyboom_disconnection(self, ioclient, reason):
         """
         Send a disconnection message to ioclient.
         @type ioclient L{IOClient}

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-15 21:59:26 UTC (rev 173)
+++ happyboom/trunk/server/client_manager.py	2005-09-15 22:05:45 UTC (rev 174)
@@ -71,7 +71,7 @@
         self.__io.on_client_disconnect = self.closeClient
         self.__io.on_new_packet = self.presentation.processPacket
         self.__io.connect('', self.client_port)
-        self.launchEvent("happyboom", "register", "on_connection", self.onClientConnection)
+        self.launchEvent("happyboom", "register", "connection", self.onClientConnection)
         thread.start_new_thread(self.run_io_thread, ())
 
     def readClientAnswer(self, client, timeout=1.000):



From haypo at berlios.de  Fri Sep 16 00:14:16 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 00:14:16 +0200
Subject: [Happyboom-svn] r175 - happyboom/trunk/common
Message-ID: <200509152214.j8FMEGQE006150@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 00:14:15 +0200 (Fri, 16 Sep 2005)
New Revision: 175

Modified:
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/presentation.py
Log:
Nettoie presentation.


Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-15 22:05:45 UTC (rev 174)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-15 22:14:15 UTC (rev 175)
@@ -49,3 +49,19 @@
 
         self.gateway.recvNetMsg(feature, event, args)
         return ""
+
+    def unpackConnection(self, ioclient, data):
+        version, data = unpackBin(data)
+        signature, data = unpackBin(data) 
+        
+        if self._on_connection != None:
+            self._on_connection(ioclient, version, signature)
+#        if version != self.protocol.version:
+#            # TODO: send presentation bye(<why>)
+#            raise PresentationException("Wrong protocol version.")
+#        else:
+#            if not self.is_server:
+#                self.launchEvent("signature", (signature,))
+#                packet = self.featuresPacket()
+#                ioclient.send(packet)
+        return data

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 22:05:45 UTC (rev 174)
+++ happyboom/trunk/common/presentation.py	2005-09-15 22:14:15 UTC (rev 175)
@@ -2,6 +2,7 @@
 from happyboom.common.log import log
 from happyboom.net.io.packet import Packet
 from happyboom.server.client import Client
+from happyboom.common.packer import packUtf8, packBin
 import struct
 
 class PresentationException(Exception):
@@ -78,22 +79,6 @@
         @type reason Unicode
         """
         self.evt_happyboom_disconnection(ioclient, reason)
-
-    def unpackConnection(self, ioclient, data):
-        version, data = unpackBin(data)
-        signature, data = unpackBin(data) 
-        
-        if self._on_connection != None:
-            self._on_connection(ioclient, version, signature)
-#        if version != self.protocol.version:
-#            # TODO: send presentation bye(<why>)
-#            raise PresentationException("Wrong protocol version.")
-#        else:
-#            if not self.is_server:
-#                self.launchEvent("signature", (signature,))
-#                packet = self.featuresPacket()
-#                ioclient.send(packet)
-        return data
             
     def featuresPacket(self, features="TODO: Feed me!"):
         data = struct.pack("!B", self.FEATURES)



From dboucard at berlios.de  Fri Sep 16 00:38:33 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Fri, 16 Sep 2005 00:38:33 +0200
Subject: [Happyboom-svn] r176 - happyboom/trunk/server
Message-ID: <200509152238.j8FMcXq3023094@sheep.berlios.de>

Author: dboucard
Date: 2005-09-16 00:37:59 +0200 (Fri, 16 Sep 2005)
New Revision: 176

Modified:
   happyboom/trunk/server/gateway.py
Log:


Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-15 22:14:15 UTC (rev 175)
+++ happyboom/trunk/server/gateway.py	2005-09-15 22:37:59 UTC (rev 176)
@@ -32,7 +32,7 @@
 #        print "gzzz", event
 
     def evt_happyboom_network(self, feature, event, *args):
-        self.sendMsg(feature, event, *args)
+        self.sendNetMsg(feature, event, *args)
         
     def start(self):
         self.client_manager.start()



From dboucard at berlios.de  Fri Sep 16 00:43:51 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Fri, 16 Sep 2005 00:43:51 +0200
Subject: [Happyboom-svn] r177 - happyboom/trunk/client
Message-ID: <200509152243.j8FMhpX7026190@sheep.berlios.de>

Author: dboucard
Date: 2005-09-16 00:43:49 +0200 (Fri, 16 Sep 2005)
New Revision: 177

Modified:
   happyboom/trunk/client/base_client.py
Log:
gateway management


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-15 22:37:59 UTC (rev 176)
+++ happyboom/trunk/client/base_client.py	2005-09-15 22:43:49 UTC (rev 177)
@@ -1,11 +1,15 @@
 from net import io_udp
+from common.happyboom_protocol import HappyboomProtocol
+from common.event import EventLauncher, EventListener
 import struct
 
-class HappyBoomClient(object):
+class Client(object, EventListener, EventLauncher):
     
     def __init__(self, args):
+        EventLauncher.__init__(self)
+        EventListener.__init__(self) # TODO : Fix me (with good arguments)
         self.host = args.get("host", "127.0.0.1")
-        self.port = args.get("port", "12430")
+        self.port = args.get("port", 12430)
         self.verbose = args.get("verbose", False)
         self.debug = args.get("debug", False)
         protocol = args.get("protocol", None)
@@ -18,7 +22,8 @@
         self.__stoplock = thread.allocate_lock()
         
         self.signature = None
-        self.gateway = Gateway(self.__io, protocol)
+        self.presentation = common.HappyboomProtocol(protocol)
+        self.gateway = Gateway()
         
     def start(self):
         """ Starts the client : connection to the server, etc. """
@@ -91,5 +96,39 @@
         p.writeStr(str)
         self.__io.send(p)
         
+class Gateway(EventLauncher, EventListener):
+    def __init__(self):
+        EventLauncher.__init__(self)
+        EventListener.__init__(self, "evt_")
+        self.launchEvent("happyboom", "register", "connection", self.processConnection)
+        self.launchEvent("happyboom", "register", "disconnection", self.processDisconnection)
+        self.launchEvent("happyboom", "register", "create_item", self.processConnection)
+        self.launchEvent("happyboom", "register", "destroy_item", self.processConnection)
+        self.launchEvent("happyboom", "register", "recv_event", self.processConnection)
+        self.registerEvent("happyboom")
+        
+    def processConnection(self, version, signature):
+        self.launchEvent("happyboom", "signature", signature)
+        
+    def processDisconnection(self, reason):
+        self.launchEvent("happyboom", "stop", reason)
+    
+    def processCreateItem(self, feature, id):
+        self.launchEvent(feature, "new", id)
+    
+    def processDestroyItem(self, id):
+        self.launchEvent(feature, "delete", id)
+    
+    def processEvent(self, feature, event, args):
+        self.launchEvent(feature, event, *args)
 
-
+    def evt_happyboom_features(self, feature):
+        if feature not in self.features:
+            self.features.append(feature)
+            self.registerEvent(feature)
+            
+    def processEvent(self, event):
+        if self.type != "happyboom":
+            self.launchEvent("happyboom", "send", *event.content)
+            
+    
\ No newline at end of file



From haypo at berlios.de  Fri Sep 16 01:01:02 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 01:01:02 +0200
Subject: [Happyboom-svn] r178 - boomboom boomboom/client boomboom/server happyboom/trunk/common happyboom/trunk/server
Message-ID: <200509152301.j8FN12Xn009308@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 01:00:40 +0200 (Fri, 16 Sep 2005)
New Revision: 178

Modified:
   boomboom/client/bb_client.py
   boomboom/client/bb_constructor.py
   boomboom/client/bb_display.py
   boomboom/client/bb_drawer.py
   boomboom/client/bb_events.py
   boomboom/client/bb_input.py
   boomboom/client/bb_item.py
   boomboom/protocol.xml
   boomboom/server/bb_server.py
   happyboom/trunk/common/event.py
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/common/protocol.py
   happyboom/trunk/server/base_server.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Fix a lot of things for simple_event => event change, and small bugfixes.


Modified: boomboom/client/bb_client.py
===================================================================
--- boomboom/client/bb_client.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_client.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.simple_event import EventListener
+from happyboom.common.event import EventListener
 import bb_events
 from bb_input import BoomBoomInput
 import thread, time, traceback, pygame
@@ -46,7 +46,7 @@
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         
-        self.registerEvent(bb_events.stop)
+        self.registerEvent("game")
         
     def start(self):
         """ Starts the game client."""
@@ -76,9 +76,9 @@
         if self.__verbose: print "[CLIENT] Stopping client..."
         self.display.stop()
     
-    def evt_game_Stop(self, event):
+    def evt_game_stop(self):
         """ Stop event handler.
-        @param event: Event with "game_Stop" type.
+        @param event: Event game.stop()
         @type event: C{L{common.simple_event.Event}}
         """
         self.stop()

Modified: boomboom/client/bb_constructor.py
===================================================================
--- boomboom/client/bb_constructor.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_constructor.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.simple_event import EventListener
+from happyboom.common.event import EventListener
 import bb_events
 from items import Sun, Projectile, Weapon, World, Character
 
@@ -13,14 +13,14 @@
     def __init__(self):
         """ BoomBoomConstructor constructor. """
         EventListener.__init__(self, prefix="evt_")
-        self.registerEvent(bb_events.start)
+        self.registerEvent("game")
         self.registerEvent(bb_events.create)
         self.registerEvent(bb_events.text)
         
     def evt_agent_manager_Create(self, event):
         """ Create event handler.
         @param event: Event with "agent_manager_Create" type.
-        @type event: C{L{common.simple_event.Event}}
+        @type event: C{L{common.event.Event}}
         """
         arg = event.content.split(":")
         type = arg[0]
@@ -52,16 +52,16 @@
             return Character(id, "foo")
         return None
         
-    def evt_game_Start(self, event):
+    def evt_game_start(self):
         """ Start event handler.
         @param event: Event with "game_Start" type.
-        @type event: C{L{common.simple_event.Event}}
+        @type event: C{L{common.event.Event}}
         """
         Sun()
         
     def evt_agent_manager_Text(self, event):
         """ Text event handler.
         @param event: Event with "agent_manager_Text" type.
-        @type event: C{L{common.simple_event.Event}}
+        @type event: C{L{common.event.Event}}
         """
         print "[DISPLAY] Server message: %s" %(event.content)

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_display.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -4,8 +4,9 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.presentation import Presentation
-from happyboom.common.simple_event import EventLauncher, EventListener
+from happyboom.common.happyboom_protocol import HappyboomProtocol as Presentation
+from happyboom.common.event import EventLauncher, EventListener
+from happyboom.common.log import log
 import bb_events
 from bb_drawer import BoomBoomDrawer
 from bb_constructor import BoomBoomConstructor
@@ -56,8 +57,7 @@
         """
         EventLauncher.__init__(self)
         EventListener.__init__(self, prefix="evt_")
-        self.launchEvent("x")
-        self.presentation = Presentation(protocol, False)
+        self.presentation = Presentation(protocol)
         self.drawer = BoomBoomDrawer(arg.get("max_fps", 25))
         self.host = arg.get("host", "localhost")
         self.port = arg.get("port", 12430)
@@ -71,7 +71,17 @@
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         
-        self.registerEvent(bb_events.shoot)
+        self.registerEvent("weapon")
+        self.registerEvent("happyboom")
+
+    def evt_happyboom_connection(self, ioclient, version, signature):
+        # TODO: Save signature to reuse it later
+        features = "TODO: Feed me!"
+        self.launchEvent("happyboom", "features", features)
+    
+    def evt_happyboom_disconnection(self, ioclient, reason):
+        log.warning(u"Received disconnected from server: %s" % reason)
+        self.launchEvent("game", "stop")
         
     def start(self):
         """ Starts the display client : connection to the server, etc. """
@@ -87,7 +97,7 @@
         thread.start_new_thread(self.__io.run_thread, ())
     
         BoomBoomConstructor()
-        self.__io.send(self.presentation.connectionPacket())
+        self.launchEvent("happyboom", "connection", self.__io, self.__protocol.version.encode("ascii"), "")
         print "==== BoomBoom ===="
         self.drawer.start()
         
@@ -97,8 +107,7 @@
         self.__stopped = True
         self.__stoplock.release()
         # TODO: clean "bye"
-        packet = self.presentation.disconnectionPacket(u"Quit.")
-        self.__io.send(packet)
+        self.launchEvent("happyboom", "disconnection", self.__io, u"Quit.")
         self.__io.stop()
         if self.__verbose: print "[DISPLAY] Stopped"
         
@@ -123,12 +132,12 @@
     def onDisconnect(self):
         """ Handler called on network disconnection. """
         print "[DISPLAY] Connection to server closed"
-        self.launchEvent(bb_events.stop)
+        self.launchEvent("game", "start")
 
     def onLostConnection(self):
         """ Handler called on losting network connection. """
         print "[DISPLAY] Lost connection with server"
-        self.launchEvent(bb_events.stop)
+        self.launchEvent("game", "stop")
     
     def send(self, feature, event, *args):
         """ Sends a string to the network server.
@@ -138,9 +147,6 @@
         data = self.__protocol.createMsg(feature, event, *args)
         data = self.presentation.sendMsg(data)
         self.__io.send(Packet(data))
-
-    def evt_x(self, event):
-        print "x"
         
     def evt_weapon_shoot(self, event):
         print "Shoot aussi"

Modified: boomboom/client/bb_drawer.py
===================================================================
--- boomboom/client/bb_drawer.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_drawer.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.simple_event import EventListener
+from happyboom.common.event import EventListener
 import bb_events
 import pygame, time
 
@@ -28,7 +28,7 @@
         self.__screen = None
         self.__frameTime = 1.0 / max_fps
         self.__items = []
-        self.registerEvent(bb_events.visibleItem)
+        self.registerEvent("graphical")
     
     def start(self):
         """ Creates game window and starts display loop. """
@@ -51,13 +51,13 @@
                 delay = self.__frameTime - delay
                 time.sleep(delay)
         
-    def evt_graphical_item(self, event):
+    def evt_graphical_item(self, item):
         """ active item event handler.
         @param event: Event with "graphical_item" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        if event.source not in self.__items:
-            self.__items.append(event.source)
+        if item not in self.__items:
+            self.__items.append(item)
         
         
 class Window:

Modified: boomboom/client/bb_events.py
===================================================================
--- boomboom/client/bb_events.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_events.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -1,10 +1,6 @@
-start = "game_Start"
-stop = "game_Stop"
 nextTurn = "game_next_turn"
 activeCharacter = "game_active_character"
 
-shoot = "weapon_shoot"
-
 create = "agent_manager_Create"
 text = "agent_manager_Text"
 askVersion = "agent_manager_AskVersion"
@@ -21,5 +17,4 @@
 
 characterMove = "character_move"
 
-visibleItem = "graphical_item"
 activeCharAbs = "active_character_abscisse"

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_input.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.simple_event import EventLauncher
+from happyboom.common.event import EventLauncher
 import bb_events
 from net import io
 from net import io_udp, io_tcp
@@ -63,10 +63,10 @@
         if event.type == pygame.KEYDOWN: 
             # q, Q or escape: quit
             if event.unicode in (u'q', u'Q') or event.key == 27:
-                self.launchEvent(bb_events.stop)
+                self.launchEvent("game", "stop")
         # Quit event: quit
         elif event.type in (pygame.QUIT, ):
-            self.launchEvent(bb_events.stop)
+            self.launchEvent("game", "stop")
     
         #character = self.client.view.getActiveCharacter()
         #if character != None: self.process_event_active(character, event)
@@ -85,7 +85,7 @@
             # arrow keys: move character
             if event.key == 32:
                 print "Event %s" % bb_events.shoot
-                self.launchEvent(bb_events.shoot)
+                self.launchEvent("weapon", "shoot")
             elif event.key == 275: self.sendCmd("move_right")
             elif event.key == 273: self.sendCmd("move_up") 
             elif event.key == 274: self.sendCmd("move_down")

Modified: boomboom/client/bb_item.py
===================================================================
--- boomboom/client/bb_item.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/client/bb_item.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.simple_event import EventListener, EventLauncher
+from happyboom.common.event import EventListener, EventLauncher
 import bb_events
 import pygame
 
@@ -19,7 +19,7 @@
         EventListener.__init__(self, "evt_")
         EventLauncher.__init__(self)
         self.visual = None
-        self.launchEvent(bb_events.visibleItem)
+        self.launchEvent("graphical", "item", self)
         
     def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}

Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/protocol.xml	2005-09-15 23:00:40 UTC (rev 178)
@@ -1,5 +1,5 @@
 <?xml version="1.0"?>
-<protocol name="BoomBoom" version="0.2">
+<protocol name="BoomBoom" version="BoomBoom 0.2">
   <feature name="game" id="1">
     <event name="start" id="1" />
     <event name="stop" id="2" />

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-15 22:43:49 UTC (rev 177)
+++ boomboom/server/bb_server.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -1,4 +1,4 @@
-from happyboom.common.presentation import Presentation
+from happyboom.common.happyboom_protocol import HappyboomProtocol as Presentation
 from happyboom.server.base_server import \
     Server as HBServer, \
     Gateway as HBGateway, \
@@ -41,8 +41,8 @@
         
 class Server(HBServer):
     def __init__(self, protocol, arg):
-        manager = ClientManager(arg)
-        presentation = Presentation(protocol, True)
+        manager = ClientManager(protocol, arg)
+        presentation = Presentation(protocol)
         gateway = Gateway(protocol, presentation, manager, arg)
         manager.gateway = gateway
-        HBServer.__init__(self, gateway, arg)
+        HBServer.__init__(self, gateway, manager, arg)

Modified: happyboom/trunk/common/event.py
===================================================================
--- happyboom/trunk/common/event.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/common/event.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -10,7 +10,7 @@
 class EventListener(evt.EventListener):
     """ Happyboom generic class for listening to events.
     """
-    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
+    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=True):
         """ EventListener constructor.
         """
         evt.EventListener.__init__(self, prefix, suffix, "happyboomEventPerformed", silent)

Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -1,21 +1,30 @@
 from presentation import Presentation
 from happyboom.common.packer import unpack, unpackBin, unpackUtf8, unpackInt
+import struct
 
 class HappyboomProtocol(Presentation):
+    def __init__(self, protocol):
+        Presentation.__init__(self, protocol)
+        self._unpackFunc = { \
+            self.CONNECTION: self.unpackConnection,
+            self.DISCONNECTION: self.unpackDisconnect,
+            self.FEATURES: self.unpackFeatures,
+            self.CREATE: self.unpackCreateItem,
+            self.DESTROY: self.unpackDestroyItem,
+            self.EVENT: self.unpackEvent}
+
     def unpackPacketType(self, data):
         # Get packet type
         fmt = "!B"
         i = struct.calcsize(fmt)
-        ptype, = struct.unpack(fmt, data[:i]) 
-        return data[i:]
+        type, = struct.unpack(fmt, data[:i]) 
+        return type, data[i:]
 
     def unpackDisconnect(self, ioclient, data):
         reason, data = unpackUtf8(data)
-        if self.is_server:
-            self.client_manager.closeClient(ioclient)
-        else:
-            log.warning(u"Received disconnected from server: %s" % reason)
-            self.launchEvent("happyboom", "stop")
+        if self._on_disconnection != None:
+            self._on_disconnection(ioclient, reason)
+#            self.client_manager.closeClient(ioclient)
         return data
         
     def unpackFeatures(self, ioclient, data):
@@ -44,24 +53,15 @@
         data = data[i:]
 
         feature, event, args = unpack(data, feature_id, event_id, self.protocol)
-        log.info("Received: %s.%s(%s)" \
-            % (feature, event, args))
+        log.info("Received: %s.%s(%s)" % (feature, event, args))
 
-        self.gateway.recvNetMsg(feature, event, args)
+        if self._on_recv_event != None:
+            self._on_recv_event(ioclient, feature, event, args)
         return ""
 
     def unpackConnection(self, ioclient, data):
         version, data = unpackBin(data)
         signature, data = unpackBin(data) 
-        
         if self._on_connection != None:
             self._on_connection(ioclient, version, signature)
-#        if version != self.protocol.version:
-#            # TODO: send presentation bye(<why>)
-#            raise PresentationException("Wrong protocol version.")
-#        else:
-#            if not self.is_server:
-#                self.launchEvent("signature", (signature,))
-#                packet = self.featuresPacket()
-#                ioclient.send(packet)
         return data

Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/common/packer.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -9,9 +9,9 @@
     if datatype=="int":
         return (type(data) == type(1)) and (data <= 2147483647) and (-2147483648 <= data)
     elif datatype=="bin":
-        return len(data) < 65535 
+        return type(data)==types.StringType and len(data) < 65535 
     elif datatype=="utf8":
-        return len(data) < 65535 and type(data)==types.UnicodeType
+        return type(data)==types.UnicodeType and len(data) < 65535
     else:
         raise PackerException("Wrong argument type: %s" % datatype)
 

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/common/presentation.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -18,19 +18,11 @@
     DESTROY       = 0x5
     EVENT         = 0x6
     
-    def __init__(self, protocol, is_server):
+    def __init__(self, protocol):
         EventListener.__init__(self, "evt_", silent=True)
         self.protocol = protocol
         self.items = {}
-        self.gateway = None
-        self.is_server = is_server 
-        self._unpackFunc = { \
-            self.CONNECTION: self.unpackConnection,
-            self.DISCONNECTION: self.unpackDisconnect,
-            self.FEATURES: self.unpackFeatures,
-            self.CREATE: self.unpackCreateItem,
-            self.DESTROY: self.unpackDestroyItem,
-            self.EVENT: self.unpackEvent}
+        self._unpackFunc = {}
         self.registerEvent("happyboom")
 
         # Event (IO_Client client, str version, str signature)
@@ -56,11 +48,11 @@
         @param packet: incomming network packet.
         @type packet: C{net.io.packet.Packet}
         """
-        data = unpackPacketType(packet.data)
+        ptype, data = self.unpackPacketType(packet.data)
         
         # Choose process function
         if ptype in self._unpackFunc:
-            self._unpackFunc(packet.recv_from, data)
+            data = self._unpackFunc[ptype] (packet.recv_from, data)
         else:
             log.warning("ProtocoleWarning: received unexpected packet type %s." % ptype)
         if len(data) != 0:
@@ -70,7 +62,7 @@
     def evt_happyboom_register(self, event, handler):
         event = "_on_"+event
         if hasattr(self, event):
-            self.setattr(event, handler, handler)
+            setattr(self, event, handler)
     
     def evt_happyboom_closeConnection(self, ioclient, reason):
         """
@@ -85,7 +77,7 @@
         data = data + packBin(features)
         return Packet(data)
        
-    def evt_happyboom_connection(self, ioclient, version, signature=""):
+    def evt_happyboom_connection(self, ioclient, version, signature):
         """
         Send a connection message to ioclient.
         @type version ASCII string
@@ -113,9 +105,11 @@
         packet = Packet(data)
         for client in clients: client.send(packet)
         
-    def unpackPacketType(self, data): pass
-    def unpackDisconnect(self, ioclient, data): pass
-    def unpackFeatures(self, ioclient, data): pass
-    def unpackCreateItem(self, data): pass
-    def unpackDestroyItem(self, data): pass
-    def unpackEvent(self, ioclient, data): pass
+    def unpackPacketType(self, data):
+        """ returns type, data """
+        return 0, data
+    def unpackDisconnect(self, ioclient, data): return data
+    def unpackFeatures(self, ioclient, data): return data
+    def unpackCreateItem(self, data): return data
+    def unpackDestroyItem(self, data): return data
+    def unpackEvent(self, ioclient, data): return data

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/common/protocol.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -108,11 +108,11 @@
 class Protocol:
     """
     HappyBoom protocol utility.
-    version is unicode
+    version is ASCII 
     """
     def __init__(self, name, version):
         self.name = name
-        self.version = version
+        self.version = version.encode("ascii")
         self.__featnames = {}
         self.__featids = {}
 

Modified: happyboom/trunk/server/base_server.py
===================================================================
--- happyboom/trunk/server/base_server.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/server/base_server.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -6,13 +6,14 @@
 import random, thread, time
 
 class Server(object):
-    def __init__(self, gateway, arg): #verbose=False, debug=False):
+    def __init__(self, gateway, client_manager, arg): #verbose=False, debug=False):
         self.started = False
         self.__debug = arg.get('debug', False)
         self.__verbose = arg.get('verbose', False)
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         self.__gateway = gateway 
+        self.__client_manager = client_manager
         self.__gateway.server = self
         self.__gateway.client_manager.server = self
         random.seed()
@@ -24,6 +25,7 @@
     def start(self):
         if self.__verbose: log.info("[*] Starting server...")
         self.__gateway.start()
+        self.__client_manager.start()
         log.info("[*] Server started")
         
         self.__stoplock.acquire()
@@ -31,6 +33,7 @@
         self.__stoplock.release()
         while running:
             self.__gateway.process()
+            self.__client_manager.process()
             time.sleep(0.01)
             self.__stoplock.acquire()
             running = not self.__stopped
@@ -44,5 +47,6 @@
         self.__stopped = True
         self.__stoplock.release()
         if self.__verbose: log.info("[*] Stopping server...")
+        self.__client_manager.stop()
         self.__gateway.stop()
         log.info("[*] Server stopped")

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/server/client_manager.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -7,9 +7,10 @@
 import thread, time
 
 class ClientManager(EventLauncher, object):
-    def __init__(self, arg): 
+    def __init__(self, protocol, arg): 
         EventLauncher.__init__(self)
         self.server = None 
+        self.__protocol = protocol
         self.__io = io_tcp.IO_TCP(is_server=True)
         self.__io.debug = arg.get("debug", False)
         self.__io.verbose = arg.get("verbose", False)
@@ -24,13 +25,18 @@
         self.gateway = None
         self.presentation = None
 
+    def onClientDisconnection(self, ioclient, reason):
+        log.info("Client %s leave us: %s" % (ioclient, reason))
+        self.closeClient(ioclient)
+
     def onClientConnection(self, ioclient, version, signature):
-        # TODO: Et le cas o? signature ne vaut pas "" ???
-        if version == self.protocol.version:
+        # TODO: Case where signature != "" ??? (reconnection)
+        server_version = self.__protocol.version
+        if version == server_version:
             signature = self.generateSignature(ioclient)
-            self.launchEvent("happyboom", "clientConnection", ioclient, self.version, signature)
+            self.launchEvent("happyboom", "clientConnection", ioclient, server_version, signature)
         else:    
-            self.launchEvent("happyboom", "closeConnection", ioclient, u"Wrong server version")
+            self.launchEvent("happyboom", "closeConnection", ioclient, u"Wrong server version (%s VS %s)" % (version, serverur_version))
 
     def onClientFeatures(self, ioclient, features):
         # Register client in the clients list
@@ -72,6 +78,7 @@
         self.__io.on_new_packet = self.presentation.processPacket
         self.__io.connect('', self.client_port)
         self.launchEvent("happyboom", "register", "connection", self.onClientConnection)
+        self.launchEvent("happyboom", "register", "disconnection", self.onClientDisconnection)
         thread.start_new_thread(self.run_io_thread, ())
 
     def readClientAnswer(self, client, timeout=1.000):
@@ -103,6 +110,7 @@
         # TODO: get client of type Client for the client of type ClientIO to send
         # him bye
 #        client.sendNetMsg("presentation", "bye", "utf8", u"Lost connection")
+        log.info("[*] Client %s leave us." % ioclient)
         self.removeClient(ioclient)
         
     def __clientChallenge(self, client, func):

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-15 22:43:49 UTC (rev 177)
+++ happyboom/trunk/server/gateway.py	2005-09-15 23:00:40 UTC (rev 178)
@@ -35,12 +35,10 @@
         self.sendNetMsg(feature, event, *args)
         
     def start(self):
-        self.client_manager.start()
         Kernel.instance.addAgent(self)
         
     def stop(self):
         self.sendNetMsg("game", "stop")
-        self.client_manager.stop()
         Kernel.instance.stopKernel()
 
     def process(self):
@@ -48,7 +46,7 @@
 #       TODO: Waiting for last PySMA version...        
 #        if not self.__scheduler.alive:
 #            self.__server.stop()
-        self.client_manager.process()
+        pass
 
     def sendText(self, txt, client=None):
         if client != None:



From haypo at berlios.de  Fri Sep 16 01:28:18 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 01:28:18 +0200
Subject: [Happyboom-svn] r179 - boomboom/client boomboom/server/agents happyboom/trunk/common happyboom/trunk/server
Message-ID: <200509152328.j8FNSIBM026053@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 01:28:07 +0200 (Fri, 16 Sep 2005)
New Revision: 179

Modified:
   boomboom/client/bb_display.py
   boomboom/server/agents/projectile.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Diverses corrections pour faire marcher client et serveur.


Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-15 23:00:40 UTC (rev 178)
+++ boomboom/client/bb_display.py	2005-09-15 23:28:07 UTC (rev 179)
@@ -73,13 +73,16 @@
         
         self.registerEvent("weapon")
         self.registerEvent("happyboom")
+        self.launchEvent("happyboom", "register", "connection", self.onConnection)
+        self.launchEvent("happyboom", "register", "disconnection", self.onDisconnection)
 
-    def evt_happyboom_connection(self, ioclient, version, signature):
+    def onConnection(self, ioclient, version, signature):
         # TODO: Save signature to reuse it later
         features = "TODO: Feed me!"
-        self.launchEvent("happyboom", "features", features)
+        if self.__verbose: log.info("Connected to server, send features ...")
+        self.launchEvent("happyboom", "features", self.__io, features)
     
-    def evt_happyboom_disconnection(self, ioclient, reason):
+    def onDisconnection(self, ioclient, reason):
         log.warning(u"Received disconnected from server: %s" % reason)
         self.launchEvent("game", "stop")
         

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-15 23:00:40 UTC (rev 178)
+++ boomboom/server/agents/projectile.py	2005-09-15 23:28:07 UTC (rev 179)
@@ -22,7 +22,7 @@
         self.requestActions("character")
         self.requestActions("world")
         self.requestActions("game")
-        self.requestActions("network")
+        self.requestActions("gateway")
         self.sendBroadcastMessage(Message("new_item", (self.type, self.id)), "network")
 
     def msg_weapon_strength(self, arg):
@@ -74,8 +74,9 @@
             y = self.start_pos[1] +self.speed[1] * dt +9.8*dt*dt*self.mass
             self.move (x, y)
 
-    def sync(self):
+    def sync(self, client):
+        # TODO: Only send it to client
         self.setActive(self.active)
 
-    def msg_network_sync(self):
-        self.sync()
+    def msg_gateway_syncClient(self, client):
+        self.sync(client)

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-15 23:00:40 UTC (rev 178)
+++ happyboom/trunk/common/presentation.py	2005-09-15 23:28:07 UTC (rev 179)
@@ -71,11 +71,11 @@
         @type reason Unicode
         """
         self.evt_happyboom_disconnection(ioclient, reason)
-            
-    def featuresPacket(self, features="TODO: Feed me!"):
+
+    def evt_happyboom_features(self, ioclient, features):
         data = struct.pack("!B", self.FEATURES)
         data = data + packBin(features)
-        return Packet(data)
+        ioclient.send( Packet(data) )
        
     def evt_happyboom_connection(self, ioclient, version, signature):
         """

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-15 23:00:40 UTC (rev 178)
+++ happyboom/trunk/server/client_manager.py	2005-09-15 23:28:07 UTC (rev 179)
@@ -31,12 +31,15 @@
 
     def onClientConnection(self, ioclient, version, signature):
         # TODO: Case where signature != "" ??? (reconnection)
+        if self.__verbose: log.info("Client %s try to connect : check version." % ioclient)
         server_version = self.__protocol.version
         if version == server_version:
+            if self.__verbose: log.info("Client %s try to connect: version ok." % ioclient)
             signature = self.generateSignature(ioclient)
-            self.launchEvent("happyboom", "clientConnection", ioclient, server_version, signature)
+            self.launchEvent("happyboom", "connection", ioclient, server_version, signature)
         else:    
-            self.launchEvent("happyboom", "closeConnection", ioclient, u"Wrong server version (%s VS %s)" % (version, serverur_version))
+            if self.__verbose: log.warning("Client %s try to connect: wrong version (%s)." % version)
+            self.launchEvent("happyboom", "closeConnection", ioclient, u"Wrong server version (%s VS %s)" % (version, serveur_version))
 
     def onClientFeatures(self, ioclient, features):
         # Register client in the clients list
@@ -46,7 +49,6 @@
         self.__clients_lock.release() 
 
         # Register client to features
-        features = unpackBin(features)
         for feature in features:
             if feature in self.__supported_features:
                 self.__supported_features[feature].append(ioclient)
@@ -79,6 +81,7 @@
         self.__io.connect('', self.client_port)
         self.launchEvent("happyboom", "register", "connection", self.onClientConnection)
         self.launchEvent("happyboom", "register", "disconnection", self.onClientDisconnection)
+        self.launchEvent("happyboom", "register", "features", self.onClientFeatures)
         thread.start_new_thread(self.run_io_thread, ())
 
     def readClientAnswer(self, client, timeout=1.000):
@@ -93,14 +96,12 @@
         else:
             self.__supported_features[role] = [client,]
         
-    def openClient(self, client):
-        log.info("[*] Client %s try to connect ..." % client)
+    def openClient(self, ioclient):
+        log.info("[*] Client %s try to connect ..." % ioclient)
 
     def removeClient(self, ioclient):
-        client = self.getClientByAddr(ioclient.addr)
-        if client == None: return
-        log.info("Disconnect client %s." % client)
-        self.gateway.sendText(u"Client %s leave us." % client)
+        log.info("Disconnect client %s." % ioclient)
+        self.gateway.sendText(u"Client %s leave us." % ioclient)
 
         self.__clients_lock.acquire() 
         del self.__clients[ioclient.addr]
@@ -110,7 +111,9 @@
         # TODO: get client of type Client for the client of type ClientIO to send
         # him bye
 #        client.sendNetMsg("presentation", "bye", "utf8", u"Lost connection")
-        log.info("[*] Client %s leave us." % ioclient)
+        client = self.getClientByAddr(ioclient.addr)
+        if client == None: return
+        log.info("[*] Client %s leave us." % client)
         self.removeClient(ioclient)
         
     def __clientChallenge(self, client, func):
@@ -137,8 +140,9 @@
 
     def generateSignature(self, ioclient):
         import random
-        r = random.randint(0,1000000)
-        return r
+        r1 = random.randint(0,1000000)
+        r2 = random.randint(0,1000000)
+        return "%s%s%s" % (r1,ioclient.addr,r2)
 
     def getClientByAddr(self, addr):
         """ Returns None if no client matchs. """

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-15 23:00:40 UTC (rev 178)
+++ happyboom/trunk/server/gateway.py	2005-09-15 23:28:07 UTC (rev 179)
@@ -59,7 +59,7 @@
         self.sendBroadcastMessage(message, "%s_listener" % feature)
 
     def evt_happyboom_newClient(self, client):
-        self.send("sync") #TODO: Add client argument ...
+        self.send("syncClient", client)
 
     def sendNetMsg(self, feature, event, *args):
         clients = self.client_manager.supported_features.get(feature, ())



From dboucard at berlios.de  Fri Sep 16 01:29:38 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Fri, 16 Sep 2005 01:29:38 +0200
Subject: [Happyboom-svn] r180 - happyboom/trunk/client
Message-ID: <200509152329.j8FNTcDB026515@sheep.berlios.de>

Author: dboucard
Date: 2005-09-16 01:29:36 +0200 (Fri, 16 Sep 2005)
New Revision: 180

Modified:
   happyboom/trunk/client/base_client.py
Log:


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-15 23:28:07 UTC (rev 179)
+++ happyboom/trunk/client/base_client.py	2005-09-15 23:29:36 UTC (rev 180)
@@ -1,7 +1,7 @@
 from net import io_udp
 from common.happyboom_protocol import HappyboomProtocol
 from common.event import EventLauncher, EventListener
-import struct
+import struct, string
 
 class Client(object, EventListener, EventLauncher):
     
@@ -106,29 +106,61 @@
         self.launchEvent("happyboom", "register", "destroy_item", self.processConnection)
         self.launchEvent("happyboom", "register", "recv_event", self.processConnection)
         self.registerEvent("happyboom")
+        self.features = []
+        self.items = {}
+        #self.gamepath = None
+        self.module = __import__("items")
         
     def processConnection(self, version, signature):
         self.launchEvent("happyboom", "signature", signature)
+        self.launchEvent("happyboom", "sendFeatures", self.features)
         
     def processDisconnection(self, reason):
         self.launchEvent("happyboom", "stop", reason)
     
     def processCreateItem(self, feature, id):
+        assert feature in self.features, "Unexpected feature"
+        classname = self.getClassnameByFeature(feature)
+        assert hasattr(self.module, classname), "Item class not found : %s" %classname
+        itemclass = getattr(self.module, classname)
+        item = itemclass(id)
+        self.items[id] = item
         self.launchEvent(feature, "new", id)
     
     def processDestroyItem(self, id):
+        assert id in self.items, "Unknown item identifier %s" %id
         self.launchEvent(feature, "delete", id)
-    
+        del self.items[id]
+        
     def processEvent(self, feature, event, args):
         self.launchEvent(feature, event, *args)
 
+    def getClassnameByFeature(self, feature):
+        classname = ""
+        prefix = True
+        space = True
+        for i in range(len(feature)):
+            if feature[i] not in string.ascii_letters:
+                if prefix:
+                    classname = classname + feature[i]
+                space = True
+            else:
+                prefix = False
+                if space:
+                    classname = classname + feature[i].upper()
+                else:
+                    classname = classname + feature[i]
+        return classname
+
     def evt_happyboom_features(self, feature):
         if feature not in self.features:
             self.features.append(feature)
             self.registerEvent(feature)
-            
-    def processEvent(self, event):
+        
+#    def evt_happyboom_gamepath(self, path):
+#        self.gamepath = path
+        
+    def eventPerformed(self, event):
         if self.type != "happyboom":
             self.launchEvent("happyboom", "send", *event.content)
-            
-    
\ No newline at end of file
+            
\ No newline at end of file



From haypo at berlios.de  Fri Sep 16 06:40:43 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 06:40:43 +0200
Subject: [Happyboom-svn] r181 - in happyboom/trunk/net: io io_tcp io_udp
Message-ID: <200509160440.j8G4ehfL015115@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 06:40:17 +0200 (Fri, 16 Sep 2005)
New Revision: 181

Modified:
   happyboom/trunk/net/io/base_io.py
   happyboom/trunk/net/io_tcp/__init__.py
   happyboom/trunk/net/io_tcp/tcp.py
   happyboom/trunk/net/io_tcp/tcp_client.py
   happyboom/trunk/net/io_udp/udp.py
Log:
Affiche les importations de module et corrige la defintions des noms
pour BaseIO, IO_TCP et IO_UDP.


Modified: happyboom/trunk/net/io/base_io.py
===================================================================
--- happyboom/trunk/net/io/base_io.py	2005-09-15 23:29:36 UTC (rev 180)
+++ happyboom/trunk/net/io/base_io.py	2005-09-16 04:40:17 UTC (rev 181)
@@ -1,13 +1,13 @@
 #!/usr/bin/python
 # -*- coding: ISO-8859-1 -*-
 
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.io_client import IO_Client
 import time
 import threading
 import socket
 import traceback
 import struct
-from packet import Packet
-from io_client import IO_Client
 
 class BaseIO(object):
     """
@@ -29,8 +29,8 @@
     @type on_client_disconnect: C{function(L{IO_Client})}
     @ivar on_new_packet: Event called when a new packet is received.
     @type on_new_packet: C{function(L{Packet})}
-    @ivar __name: The IO name.
-    @type __name: C{str}
+    @ivar _name: The IO name.
+    @type _name: C{str}
     @ivar _running: Is the thread running ?
     @type _running: C{bool}
     """
@@ -56,7 +56,7 @@
         self.on_send = None               # (data)
         self.on_receive = None            # (data)
 
-        self.__name = None
+        self._name = None
 
     def connect(self, host, port):
         """ Connect to host:port.
@@ -65,8 +65,8 @@
         @parameter port: Network port number.
         @type port: C{int}
         """
-        if self.__name==None:
-            self.__name = "%s:%u" % (host, port)
+        if self._name==None:
+            self._name = "%s:%u" % (host, port)
         self._running = True
 
     def disconnect(self):
@@ -106,23 +106,23 @@
         self.disconnect()
 
     def __str__(self):
-        return self.__name
+        return self.name
     
     def isRunning(self): return self._running
 
     #--- Private functions ------------------------------------------------------
 
-    def __getName(self):
-        if self.__name == None: return "no name"
-        return self.__name
+    def _getName(self):
+        if self._name == None: return "no name"
+        return self._name
     
-    def __setName(self, name):
-        self.__name = name
+    def _setName(self, name):
+        self._name = name
 
     def __getReady(self):
         return self._is_ready
 
     #--- Properties -------------------------------------------------------------
 
-    name = property(__getName, __setName, doc="The IO name.")
+    name = property(_getName, _setName, doc="The IO name.")
     is_ready = property(__getReady, doc="Tells if the IO is ready to use.");

Modified: happyboom/trunk/net/io_tcp/__init__.py
===================================================================
--- happyboom/trunk/net/io_tcp/__init__.py	2005-09-15 23:29:36 UTC (rev 180)
+++ happyboom/trunk/net/io_tcp/__init__.py	2005-09-16 04:40:17 UTC (rev 181)
@@ -1 +0,0 @@
-from tcp import IO_TCP

Modified: happyboom/trunk/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp.py	2005-09-15 23:29:36 UTC (rev 180)
+++ happyboom/trunk/net/io_tcp/tcp.py	2005-09-16 04:40:17 UTC (rev 181)
@@ -1,17 +1,17 @@
 #!/usr/bin/python
 # -*- coding: ISO-8859-1 -*-
 
+from happyboom.net.io_tcp.tcp_client import TCP_Client
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.base_io import BaseIO
+from server_waiter import NetworkServerWaiter
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
 import time
 import thread
 import socket
 import traceback
 import struct
-from tcp_client import TCP_Client
-from happyboom.net.io.packet import Packet
-from happyboom.net.io.base_io import BaseIO
-from server_waiter import NetworkServerWaiter
-from happyboom.common.log import log
-from happyboom.common.thread import getBacktrace
 
 class IO_TCP(BaseIO):
     """
@@ -76,8 +76,8 @@
             self.__clients[client.addr] = client
             self.__clients_sema.release()
 
+        BaseIO.connect(self, host, port)
         if self.on_connect != None: self.on_connect()
-        BaseIO.connect(self, host, port)
         self._is_ready = True
 
     def disconnect(self):
@@ -160,21 +160,21 @@
     #--- Private functions ------------------------------------------------------
 
     def __getPort(self):
+        if self.__addr==None: return "(no port)"
         return self.__addr[1]
 
     def __getHost(self):
+        if self.__addr==None: return "(no hostname)"
         if self.__addr[0]=='': return "localhost"
         return self.__addr[0]
 
     def __getAddr(self): return self.__addr
 
-    def __getName(self):
-        if self.__name != None: return self.__name
-        return self.host
+    def _getName(self):
+        if self._name != None: return self._name
+        if self.__addr != None: return self.host
+        return "(no name)"
         
-    def __setName(self, name):
-        self.__name = name    
-
     def __getClients(self):
         self.__clients_sema.acquire()
         clients = self.__clients.copy()
@@ -203,7 +203,7 @@
         
     #--- Properties -------------------------------------------------------------
 
-    name = property(__getName, __setName)
+    name = property(_getName, BaseIO._setName)
     addr = property(__getAddr)
     port = property(__getPort)
     host = property(__getHost)

Modified: happyboom/trunk/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-15 23:29:36 UTC (rev 180)
+++ happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-16 04:40:17 UTC (rev 181)
@@ -1,8 +1,8 @@
-from net import io
+from happyboom.net.io.io_client import IO_Client
 from happyboom.common.log import log
 import socket
 
-class TCP_Client(io.IO_Client):
+class TCP_Client(IO_Client):
     """ An TCP client.
     @ivar __socket: The TCP socket
     @type __socket: C{socket}
@@ -12,7 +12,7 @@
     @type on_receive: C{function}
     """
     def __init__(self, io_tcp, addr, name=None, socket=None):
-        io.IO_Client.__init__(self, io_tcp, addr, name)
+        IO_Client.__init__(self, io_tcp, addr, name)
         self.__socket = socket 
         self.on_send = None
         self.on_receive = None
@@ -65,7 +65,7 @@
     def disconnect(self):
         """ Disconned the client : close the socket. """
         self.__socket.close()
-        io.IO_Client.disconnect(self)
+        IO_Client.disconnect(self)
 
     def __processRecvData(self, data):
         # If no data, connection is lost

Modified: happyboom/trunk/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/net/io_udp/udp.py	2005-09-15 23:29:36 UTC (rev 180)
+++ happyboom/trunk/net/io_udp/udp.py	2005-09-16 04:40:17 UTC (rev 181)
@@ -5,12 +5,12 @@
 import socket
 import traceback
 import struct
-from net import io
+from net.io.base_io import BaseIO
 from udp_client import UDP_Client
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
 
-class IO_UDP(io.BaseIO):
+class IO_UDP(BaseIO):
     """ IO for UDP transport.
     @ivar packet_timeout: Try to send a packet until this timeout.
     @type packet_timeout: C{float}
@@ -38,7 +38,7 @@
     
     def __init__(self, is_server=False):
         """ Constructor. """
-        io.BaseIO.__init__(self)
+        BaseIO.__init__(self)
         self.packet_timeout = 1.000
         self.thread_sleep = 0.010
 
@@ -84,7 +84,7 @@
         if not self.__is_server:
             self.send( io.Packet("I'm here") )
         
-        io.BaseIO.connect(self, host, port)
+        BaseIO.connect(self, host, port)
 
         # Call user event if needed
         if self.on_connect != None: self.on_connect()
@@ -340,13 +340,10 @@
 
     def __getAddr(self): return self.__addr
 
-    def __getName(self):
-        if self.__name != None: return self.__name
+    def _getName(self):
+        if self._name != None: return self._name
         return self.host
         
-    def __setName(self, name):
-        self.__name = name    
-
     def __getClients(self):
         self.__clients_sema.acquire()
         clients = self.__clients.copy()
@@ -358,7 +355,7 @@
         
     #--- Properties -------------------------------------------------------------
 
-    name = property(__getName, __setName, doc="The IO name")
+    name = property(_getName, BaseIO._setName, doc="The IO name")
     addr = property(__getAddr, doc="The IO addresse (host, port).")
     port = property(__getPort, doc="The network port number.")
     host = property(__getHost, doc="The network hostname.")



From haypo at berlios.de  Fri Sep 16 06:41:50 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 06:41:50 +0200
Subject: [Happyboom-svn] r182 - in happyboom/trunk: client common server
Message-ID: <200509160441.j8G4foe6016240@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 06:41:41 +0200 (Fri, 16 Sep 2005)
New Revision: 182

Added:
   happyboom/trunk/client/__init__.py
Modified:
   happyboom/trunk/client/base_client.py
   happyboom/trunk/common/event.py
   happyboom/trunk/common/generic_event.py
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/log.py
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/common/protocol.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/client.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Correction de bugs, et modification du code pour prendre en compte
la nouvelle architecture.


Added: happyboom/trunk/client/__init__.py
===================================================================

Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/client/base_client.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -1,9 +1,26 @@
-from net import io_udp
-from common.happyboom_protocol import HappyboomProtocol
-from common.event import EventLauncher, EventListener
+from happyboom.common.happyboom_protocol import HappyboomProtocol
+from happyboom.common.protocol import ProtocolException
+from happyboom.common.log import log
+from happyboom.common.event import EventLauncher, EventListener
+from happyboom.net.io.packet import Packet
+from happyboom.net.io_tcp.tcp import IO_TCP
 import struct, string
+import thread
 
 class Client(object, EventListener, EventLauncher):
+    """
+    Base HappyBoom client.
+    @ivar __stopped: Stopped display client flag.
+    @type __stopped: C{bool}
+    @ivar __stoplock: Mutex for synchronizing __stopped.
+    @type __stoplock: C{thread.lock}
+    @ivar _io: Network input/output object using UDP protocole.
+    @type _io: C{net.io_udp.IO_UDP}
+    @ivar verbose: Verbose mode flag.
+    @type verbose: C{bool}
+    @ivar debug: Debug mode flag.
+    @type debug: C{bool}
+    """
     
     def __init__(self, args):
         EventLauncher.__init__(self)
@@ -13,30 +30,38 @@
         self.verbose = args.get("verbose", False)
         self.debug = args.get("debug", False)
         protocol = args.get("protocol", None)
-        self.__io = io_udp.IO_UDP()
-        self.__verbose = verbose
-        self.__io.verbose = verbose
-        self.__debug = debug
-        self.__io.debug = debug
+        self._io = IO_TCP()
+        self._io.verbose = self.verbose
+        self._io.debug = self.debug
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         
         self.signature = None
-        self.presentation = common.HappyboomProtocol(protocol)
-        self.gateway = Gateway()
+        self.presentation = HappyboomProtocol(protocol)
+        self.gateway = Gateway(protocol)
+
+    def send(self, feature, event, *args):
+        """ Sends a string to the network server.
+        @param str: String to send.
+        @type str: C{str}
+        """
+        data = self.presentation.protocol.createMsg(feature, event, *args)
+        self.launchEvent("happyboom", "event", (self._io,), data)
+#        data = self.presentation.sendMsg(data)
+#        self._io.send(Packet(data))
         
     def start(self):
         """ Starts the client : connection to the server, etc. """
         # Try to connect to server
-        if self.__verbose: print "[HAPPYBOOM] Trying to connect to server %s:%u" % (self.host, self.port)
-        self.__io.on_connect = self.onConnect
-        self.__io.on_connection_fails = self.onConnectionFails
-        self.__io.on_disconnect = self.onDisconnect
-        self.__io.on_new_packet = self.gateway.processPacket
-        self.__io.on_lost_connection = self.onLostConnection
-        self.__io.connect(self.host, self.port)
-        if not self.__io.is_ready: return
-        thread.start_new_thread(self.__io.run_thread, ())
+        if self.verbose: print "[HAPPYBOOM] Trying to connect to server %s:%u" % (self.host, self.port)
+        self._io.on_connect = self.onConnect
+        self._io.on_connection_fails = self.onConnectionFails
+        self._io.on_disconnect = self.onDisconnect
+        self._io.on_new_packet = self.presentation.processPacket
+        self._io.on_lost_connection = self.onLostConnection
+        self._io.connect(self.host, self.port)
+        if not self._io.is_ready: return
+        thread.start_new_thread(self._io.run_thread, ())
         
     def stop(self):
         """ Stops the display client : disconnection from the server, etc. """
@@ -44,13 +69,13 @@
         self.__stoplock.acquire()
         if self.__stopped:
             self.__stoplock.release()
-            return
+            return False
         self.__stopped = True
         self.__stoplock.release()
         
-        self.send("quit")
-        self.__io.stop()
-        if self.__verbose: print "[HAPPYBOOM] Stopped"
+        self._io.stop()
+        if self.verbose: print "[HAPPYBOOM] Stopped"
+        return True
         
     def __isStopped(self):
         self.__stoplock.acquire()
@@ -61,7 +86,8 @@
     
     def onConnect(self):
         """ Handler called on network connection. """
-        if self.__verbose: print "[HAPPYBOOM] Connected to server"
+        if self.verbose: print "[HAPPYBOOM] Connected to server"
+        self.launchEvent("happyboom", "connection", self._io, self.presentation.protocol.version.encode("ascii"), "")
         
     def onConnectionFails(self):
         """ Handler called when network connection fails. """
@@ -84,36 +110,35 @@
         """
         event_type, arg = self.str2evt(new_packet.data)
         if event_type != None: 
-            if self.__debug: print "Received message: type=%s arg=%s" %(event_type, arg)
+            if self.debug: print "Received message: type=%s arg=%s" %(event_type, arg)
             self.launchEvent(event_type, arg)
             
-    def send(self, str):
-        """ Sends a string to the network server.
-        @param str: String to send.
-        @type str: C{str}
-        """
-        p = io.Packet()
-        p.writeStr(str)
-        self.__io.send(p)
-        
 class Gateway(EventLauncher, EventListener):
-    def __init__(self):
+    def __init__(self, protocol):
         EventLauncher.__init__(self)
         EventListener.__init__(self, "evt_")
+        self.protocol = protocol
         self.launchEvent("happyboom", "register", "connection", self.processConnection)
         self.launchEvent("happyboom", "register", "disconnection", self.processDisconnection)
-        self.launchEvent("happyboom", "register", "create_item", self.processConnection)
-        self.launchEvent("happyboom", "register", "destroy_item", self.processConnection)
-        self.launchEvent("happyboom", "register", "recv_event", self.processConnection)
+        self.launchEvent("happyboom", "register", "create_item", self.processCreate)
+#        self.launchEvent("happyboom", "register", "destroy_item", self.processXX)
+        self.launchEvent("happyboom", "register", "recv_event", self.processEvent)
         self.registerEvent("happyboom")
         self.features = []
         self.items = {}
         #self.gamepath = None
-        self.module = __import__("items")
+        self.module = __import__("client/items")
         
-    def processConnection(self, version, signature):
-        self.launchEvent("happyboom", "signature", signature)
-        self.launchEvent("happyboom", "sendFeatures", self.features)
+    def processConnection(self, ioclient, version, signature):
+        self.launchEvent("happyboom", "signature", ioclient, signature)
+        features = ""
+        for name in self.features:
+            try:
+                feature = self.protocol.getFeature(name)
+                features = features + "%c" % feature.id
+            except ProtocolException:
+                pass
+        self.launchEvent("happyboom", "features", ioclient, features)
         
     def processDisconnection(self, reason):
         self.launchEvent("happyboom", "stop", reason)
@@ -132,7 +157,7 @@
         self.launchEvent(feature, "delete", id)
         del self.items[id]
         
-    def processEvent(self, feature, event, args):
+    def processEvent(self, ioclient, feature, event, *args):
         self.launchEvent(feature, event, *args)
 
     def getClassnameByFeature(self, feature):
@@ -152,15 +177,18 @@
                     classname = classname + feature[i]
         return classname
 
-    def evt_happyboom_features(self, feature):
-        if feature not in self.features:
-            self.features.append(feature)
-            self.registerEvent(feature)
-        
 #    def evt_happyboom_gamepath(self, path):
 #        self.gamepath = path
         
-    def eventPerformed(self, event):
-        if self.type != "happyboom":
-            self.launchEvent("happyboom", "send", *event.content)
-            
\ No newline at end of file
+    def processCreate(self, ioclient, type, id):
+        try:
+            type = self.protocol.getFeatureById(type)
+            type = type.name
+        except ProtocolException, err:
+            log.error(err)
+            return
+        self.launchEvent("happyboom", "doCreateItem", type, id)
+
+    def processEvent(self, ioclient, feature, event, *args):       
+        log.info("New event: %s.%s%s" % (feature, event, args))
+        self.launchEvent(feature, event, *args)

Modified: happyboom/trunk/common/event.py
===================================================================
--- happyboom/trunk/common/event.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/event.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -10,11 +10,11 @@
 class EventListener(evt.EventListener):
     """ Happyboom generic class for listening to events.
     """
-    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=True):
+    def __init__(self, prefix="evt_", suffix="", default="eventPerformed", silent=True):
         """ EventListener constructor.
         """
         evt.EventListener.__init__(self, prefix, suffix, "happyboomEventPerformed", silent)
-        self.hb_default = default
+        self.event_hb_default = default
         
     def getEventName(self, feature, event):
         return "%s_%s" %(feature, event)
@@ -22,7 +22,7 @@
     def happyboomEventPerformed(self, event):
         if issubclass(event.__class__, Event):
             # Try to call event-specific handle method
-            fctname = self.pattern %(self.getEventName(event.type, event.event))
+            fctname = self.event_pattern %(self.getEventName(event.type, event.event))
             if hasattr(self, fctname):
                 function = getattr(self, fctname)
                 if callable(function):
@@ -30,8 +30,8 @@
                     return
 
         # Try to call default handle method
-        if hasattr(self, self.hb_default):
-            function = getattr(self, self.hb_default)
+        if hasattr(self, self.event_hb_default):
+            function = getattr(self, self.event_hb_default)
             if callable(function):
                 function(event)
                 return
@@ -49,7 +49,8 @@
     def launchEvent(self, feature, event, *args):
         """ Launches a new event to the listeners.
         """
-        self.manager.dispatchEvent(Event(feature, event, self, args))
+        e = Event(feature, event, self, args)
+        self.event_manager.dispatchEvent(e)
 
 class Event(evt.Event):
     """ Represents an happyboom event entity.
@@ -67,3 +68,5 @@
         """
         return "<event.Event feature=%s event=%s source=%s content=%s>" %(self.type, self.event, self.source, self.content)
     
+    def getFeature(self): return feature
+    feature = property(getFeature)

Modified: happyboom/trunk/common/generic_event.py
===================================================================
--- happyboom/trunk/common/generic_event.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/generic_event.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -49,15 +49,15 @@
         if event.type in self.listeners:
             for obj in self.listeners[event.type]:
                 # Try to call event-specific handle method
-                fctname = obj.pattern %(event.type)
+                fctname = obj.event_pattern %(event.type)
                 if hasattr(obj, fctname):
                     function = getattr(obj, fctname)
                     if callable(function):
                         function(event)
                         continue
                 # Try to call default handle method
-                if hasattr(obj, obj.default):
-                    function = getattr(obj, obj.default)
+                if hasattr(obj, obj.event_default):
+                    function = getattr(obj, obj.event_default)
                     if callable(function):
                         function(event)
                         continue
@@ -80,12 +80,12 @@
     If it does not exist, the default function is called as defined by the C{L{default}} parameter/attribute.
     
     If the event cannot be handled, a C{L{UnhandledEventError}} is raised, except if C{L{silent}} flag is C{True}.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
-    @ivar pattern: Event-specific handler pattern.
-    @type pattern: C{str}
-    @ivar default: Default handler function name.
-    @type default: C{str}
+    @ivar event_manager: The event manager instance.
+    @type event_manager: C{L{EventManager}}
+    @ivar event_pattern: Event-specific handler pattern.
+    @type event_pattern: C{str}
+    @ivar event_default: Default handler function name.
+    @type event_default: C{str}
     @ivar silent: Silent flag. If C{False}, C{L{UnhandledEventError}} is raised if an event cannot be handled. If C{True}, do nothing, listener does not handle the event.
     @type silent: C{str}
     """
@@ -95,14 +95,14 @@
         @type prefix: C{str}
         @param suffix: Suffix for all event-specific handler function name.
         @type suffix: C{str}
-        @param default: Default handler function name.
-        @type default: C{str}
-        @param silent: Silent flag.
-        @type silent: C{bool}
+        @param event_default: Default handler function name.
+        @type event_default: C{str}
+        @param event_silent: Silent flag.
+        @type event_silent: C{bool}
         """
-        self.manager = EventManager.instance
-        self.pattern = prefix + "%s" + suffix
-        self.default = default
+        self.event_manager = EventManager.instance
+        self.event_pattern = prefix + "%s" + suffix
+        self.event_default = default
         self.event_silent = silent
         
     def registerEvent(self, event_type):
@@ -110,25 +110,25 @@
         @param event_type: Type of the event to listen.
         @type event_type: C{str}
         """
-        self.manager.addListener(self, event_type)
+        self.event_manager.addListener(self, event_type)
         
     def unregisterEvent(self, event_type):
         """ Unregisters itself from a event.
         @param event_type: Type of the event which was listening.
         @type event_type: C{str}
         """
-        self.manager.removeListener(self, event_type)
+        self.event_manager.removeListener(self, event_type)
 
 
 class EventLauncher:
     """ Generic class for launching events.
     It is just needed to herite from this class to launch easily events.
-    @ivar manager: The event manager instance.
-    @type manager: C{L{EventManager}}
+    @ivar event_manager: The event manager instance.
+    @type event_manager: C{L{EventManager}}
     """
     def __init__(self):
         """ EventLauncher constructor. """
-        self.manager = EventManager.instance
+        self.event_manager = EventManager.instance
         
         
     def launchEvent(self, event_type, content=None):
@@ -138,7 +138,7 @@
         @param content: Content to attach with the event (Optional).
         @type content: any
         """
-        self.manager.dispatchEvent(Event(event_type, self, content))
+        self.event_manager.dispatchEvent(Event(event_type, self, content))
     
     
 class Event:

Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -1,5 +1,6 @@
 from presentation import Presentation
 from happyboom.common.packer import unpack, unpackBin, unpackUtf8, unpackInt
+from happyboom.common.log import log
 import struct
 
 class HappyboomProtocol(Presentation):
@@ -34,8 +35,10 @@
         return data
 
     def unpackCreateItem(self, ioclient, data):
-        itemid,data = unpackInt(data)
-        type,data = unpackBin(data)
+        fmt = "!BI"
+        i = struct.calcsize(fmt)
+        type, itemid = struct.unpack(fmt, data)
+        data = data[i:]
         if self._on_create_item != None:
             self._on_create_item(ioclient, type, itemid)
         return data
@@ -51,12 +54,9 @@
         i = struct.calcsize(fmt)
         feature_id, event_id = struct.unpack(fmt, data[:i])
         data = data[i:]
-
         feature, event, args = unpack(data, feature_id, event_id, self.protocol)
-        log.info("Received: %s.%s(%s)" % (feature, event, args))
-
         if self._on_recv_event != None:
-            self._on_recv_event(ioclient, feature, event, args)
+            self._on_recv_event(ioclient, feature, event, *args)
         return ""
 
     def unpackConnection(self, ioclient, data):

Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/log.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -11,6 +11,7 @@
     def __init__(self):
         self.__buffer = {}
         self.__file = None
+        self.on_new_message = None # (level, prefix, text)
 
     def setFilename(self, filename):
         """
@@ -38,7 +39,7 @@
         @return: C{str}
         """
         if level==Log.LOG_WARN: return "[warn]"
-        if level==Log.LOG_ERROR: return "[err] "
+        if level==Log.LOG_ERROR: return "[err!]"
         return "[info]"
 
     def new_message(self, level, str):
@@ -63,6 +64,8 @@
             self.__file.write(u"%s - %s %s\n" \
                 % (time.strftime("%Y-%M-%d %H:%M:%S"),
                    prefix, str))
+        if self.on_new_message:
+            self.on_new_message (level, prefix, str)
 
     def info(self, str):
         """

Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/packer.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -71,7 +71,7 @@
 def unpackInt(data):
     fmt = "!i"
     i = struct.calcsize(fmt)
-    value = struct.unpack(fmt, data[:i])
+    value, = struct.unpack(fmt, data[:i])
     return value, data[i:]
 
 def unpack(data, feature_id, event_id, protocol):
@@ -86,6 +86,8 @@
             arg, data = unpackInt(data)
         elif type=="bin":
             arg, data = unpackBin(data)
+        elif type=="utf8":
+            arg, data = unpackUtf8(data)
         else:
             raise PackerException("Wrong argument type: %s" % type)
         args.append(arg)

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/presentation.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -76,6 +76,10 @@
         data = struct.pack("!B", self.FEATURES)
         data = data + packBin(features)
         ioclient.send( Packet(data) )
+        
+    def evt_happyboom_create(self, ioclient, feature, id):
+        data = struct.pack("!BBI", self.CREATE, feature, id)
+        ioclient.send( Packet(data) )
        
     def evt_happyboom_connection(self, ioclient, version, signature):
         """
@@ -83,7 +87,7 @@
         @type version ASCII string
         @type signature string
         """
-        
+       
         data = struct.pack("!B", self.CONNECTION)
         data = data + packBin(version)
         data = data + packBin(signature)

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/common/protocol.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -11,7 +11,7 @@
 
 class ProtocolEventParam:
     def __init__(self, event, name, type):
-        self.name = name
+        self.name = name.encode("ascii")
         self.type = type
         self.event = event
 
@@ -20,7 +20,7 @@
        
 class ProtocolEvent:
     def __init__(self, feature, name, id):
-        self.name = name
+        self.name = name.encode("ascii")
         self.id = id
         self.feature = feature
         self.__params_dict = {}
@@ -53,7 +53,7 @@
 class ProtocolFeature:
     def __init__(self, protocol, name, id):
         self.protocol = protocol
-        self.name = name
+        self.name = name.encode("ascii")
         self.id = id
         self.__evtnames = {}
         self.__evtids = {}
@@ -111,7 +111,7 @@
     version is ASCII 
     """
     def __init__(self, name, version):
-        self.name = name
+        self.name = name.encode("ascii")
         self.version = version.encode("ascii")
         self.__featnames = {}
         self.__featids = {}
@@ -122,13 +122,13 @@
         types = e.getParamTypes()
         if len(args) != len(types):
             raise ProtocolException( \
-                "Wrong parameter count (%u) for the event %s." \
-                % (len(args), e))
+                "Wrong parameter count (%u) for the event %s.%s." \
+                % (len(args), f.name, e))
         for i in range(len(args)):
             if not checkType(types[i], args[i]):
                 raise ProtocolException( \
-                    "Parameter %u of event %s should be of type %s (and not %s)." \
-                    % (i, f, types[i], type(args[i])))
+                    "Parameter %u of event %s.%s should be of type %s (and not %s)." \
+                    % (i, f.name, e, types[i], type(args[i])))
         return pack(f.id, e.id, types, args)
 
     def addFeature(self, name, id):

Modified: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/server/agent.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -1,19 +1,23 @@
 from pysma import ActionAgent, ActionMessage as Message
 from happyboom.common.log import log
-from happyboom.common.event import EventLauncher
+from happyboom.common.event import EventLauncher, EventListener
 
-class Agent(ActionAgent, EventLauncher):
+class Agent(ActionAgent, EventLauncher, EventListener):
     """
     SMA agent in HappyBoom.
     """
     def __init__(self, type, gateway, **args):
         EventLauncher.__init__(self)
+        EventListener.__init__(self)
         ActionAgent.__init__(self, prefix="msg_")
         self._gateway = gateway
         self.type = type
         self.__debug = args.get("debug", False)
         self.sendBroadcast = self.sendBroadcastMessage
 
+    def netCreateItem(self, client):
+        self.launchEvent("happyboom", "netCreateItem", client, self)
+
     def born(self):
         self.requestRole(self.type)
 

Modified: happyboom/trunk/server/client.py
===================================================================
--- happyboom/trunk/server/client.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/server/client.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -7,29 +7,29 @@
     """
 
     def __init__(self, io_client, gateway, client_manager):
-        self.__io = io_client
+        self.io = io_client
         self.__client_manager = client_manager
         self.__gateway = gateway
         self.signature = None
 
     def __str__(self):
-        return self.__io.__str__()
+        return self.io.__str__()
 
     def disconnect(self, reason):
-        self.launchEvent("happyboom", "clientDisconnect", self.__io, reason)
+        self.launchEvent("happyboom", "clientDisconnect", self.io, reason)
 
     # Stop client: close socket.
     def stop(self):
-        self.__io.disconnect()
+        self.io.disconnect()
 
     # Read a message from network stack
     # Blocking function, returns None after timeout seconds (no data)
     def read(self, timeout):
-        return self.__client_manager.readClientAnswer(self.__io, timeout)
+        return self.__client_manager.readClientAnswer(self.io, timeout)
 
     # Send a network packet the the client socket
     def sendPacket(self, packet):
-        self.__io.send(packet)
+        self.io.send(packet)
 
     # Send a HappyBoom message to the client (see L{sendPacket})
     def sendNetMsg(self, feature, event, *args):
@@ -40,5 +40,5 @@
             return
         self.launchEvent("happyboom", "event", (self,), data);
 
-    def __getAddr(self): return self.__io.addr
+    def __getAddr(self): return self.io.addr
     addr = property(__getAddr)

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/server/client_manager.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -1,4 +1,4 @@
-from happyboom.net import io, io_udp, io_tcp, net_buffer
+from happyboom.net.io_tcp.tcp import IO_TCP
 from happyboom.common.packer import unpackBin
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
@@ -11,10 +11,9 @@
         EventLauncher.__init__(self)
         self.server = None 
         self.__protocol = protocol
-        self.__io = io_tcp.IO_TCP(is_server=True)
+        self.__io = IO_TCP(is_server=True)
         self.__io.debug = arg.get("debug", False)
         self.__io.verbose = arg.get("verbose", False)
-        self.__buffer = net_buffer.NetBuffer()
         self.__debug = arg.get("debug", False)
         self.__verbose = arg.get("verbose", False)
         self.max_clients = arg.get("max_clients", 2)
@@ -49,7 +48,11 @@
         self.__clients_lock.release() 
 
         # Register client to features
+        print type(features)
         for feature in features:
+            f = self.__protocol.getFeatureById(ord(feature))
+            feature = f.name
+            log.info("Register feature %s for client %s" % (feature, client))
             if feature in self.__supported_features:
                 self.__supported_features[feature].append(ioclient)
             else:
@@ -61,9 +64,6 @@
         self.launchEvent("happyboom", "network", "info", "notice", txt)
         self.launchEvent("happyboom", "newClient", client)
 
-    def recvClientPacket(self, packet):
-        self.__buffer.append(packet.recv_from.addr, packet)
-
     def stop(self):
         for client in self.__clients.values():
             client.stop()
@@ -84,11 +84,6 @@
         self.launchEvent("happyboom", "register", "features", self.onClientFeatures)
         thread.start_new_thread(self.run_io_thread, ())
 
-    def readClientAnswer(self, client, timeout=1.000):
-        answer = self.__buffer.readBlocking(client.addr, timeout)
-        if answer==None: return None
-        return answer.data
-
     def registerFeature(self, client, role):
         if role in self.__supported_features:
             if client not in self.__supported_features[role]:

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-16 04:40:17 UTC (rev 181)
+++ happyboom/trunk/server/gateway.py	2005-09-16 04:41:41 UTC (rev 182)
@@ -8,7 +8,7 @@
 
 class Gateway(Agent, EventListener):
     def __init__(self, protocol, presentation, client_manager, arg):
-        EventListener.__init__(self, "evt_", silent=True)
+        EventListener.__init__(self, "evt_")
         Agent.__init__(self, self, "gateway")
         self.__protocol = protocol
         self.client_manager = client_manager
@@ -23,6 +23,9 @@
         self.registerEvent("happyboom")
         Kernel().addAgent(self.__scheduler)
 
+    def eventPerformed(self, event):
+        p = self.pattern % self.getEventName(event.type, event.event)
+
     def __setServer(self, server):
         self.__server = server
         self.client_manager.server = server
@@ -34,8 +37,19 @@
     def evt_happyboom_network(self, feature, event, *args):
         self.sendNetMsg(feature, event, *args)
         
+    def evt_happyboom_netCreateItem(self, client, item):
+        try:
+            type = item.type
+            type = self.presentation.protocol.getFeature(type)
+            type = type.id
+        except ProtocolException, err:
+            log.error(err)
+            return
+        self.launchEvent("happyboom", "create", client.io, type, item.id);
+        
     def start(self):
         Kernel.instance.addAgent(self)
+        self.launchEvent("happyboom", "register", "recv_event", self.recvNetMsg)
         
     def stop(self):
         self.sendNetMsg("game", "stop")
@@ -54,24 +68,19 @@
         else:
             self.sendNetMsg("chat", "message", txt)
 
-    def recvNetMsg(self, feature, event, *args):
+    def recvNetMsg(self, ioclient, feature, event, *args):
         message = Message("%s_%s" % (feature, event), args)
         self.sendBroadcastMessage(message, "%s_listener" % feature)
 
     def evt_happyboom_newClient(self, client):
-        self.send("syncClient", client)
+        self.launchEvent("gateway", "syncClient", client)
 
     def sendNetMsg(self, feature, event, *args):
         clients = self.client_manager.supported_features.get(feature, ())
         if len(clients)==0: return
         try:
-            data = self.__protocol.createMsg(feature, event, *args)
+            data = self.presentation.protocol.createMsg(feature, event, *args)
         except ProtocolException, err:
             log.error(err)
             return
-        self.launchEvent("presentationProtocol", "event", clients, data);
-
-    def __getProtocolVersion(self): return self.__protocol.version
-    protocol_version = property(__getProtocolVersion)
-
-
+        self.launchEvent("happyboom", "event", clients, data);



From haypo at berlios.de  Fri Sep 16 06:43:05 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 06:43:05 +0200
Subject: [Happyboom-svn] r183 - in boomboom: . client client/items server server/agents
Message-ID: <200509160443.j8G4h5Nt017074@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 06:42:34 +0200 (Fri, 16 Sep 2005)
New Revision: 183

Added:
   boomboom/server/agents/log.py
Modified:
   boomboom/boomboom_client.py
   boomboom/client/bb_constructor.py
   boomboom/client/bb_display.py
   boomboom/client/bb_input.py
   boomboom/client/items/character.py
   boomboom/client/items/projectile.py
   boomboom/client/items/weapon.py
   boomboom/client/items/world.py
   boomboom/protocol.xml
   boomboom/server/agents/__init__.py
   boomboom/server/agents/character.py
   boomboom/server/agents/game.py
   boomboom/server/agents/projectile.py
   boomboom/server/agents/weapon.py
   boomboom/server/agents/world.py
   boomboom/server/bb_server.py
Log:
Corrections de bugs et modifications pour la nouvelle architecture.


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/boomboom_client.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python -W all
 # -*- coding: ISO-8859-1 -*-
 VERSION="0.2.0"
 PROGRAM="BoomBoom client"
@@ -63,8 +63,8 @@
     from client import BoomBoomClient
     from client.bb_display import BoomBoomDisplay
 
-    protocol = loadProtocol("protocol.xml")
-    display = BoomBoomDisplay(protocol, arg)
+    arg["protocol"] = loadProtocol("protocol.xml")
+    display = BoomBoomDisplay(arg)
     client = BoomBoomClient(display, arg)
     try:
         client.start()

Modified: boomboom/client/bb_constructor.py
===================================================================
--- boomboom/client/bb_constructor.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/bb_constructor.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -5,6 +5,7 @@
 @version: 0.2
 """
 from happyboom.common.event import EventListener
+from happyboom.common.log import log
 import bb_events
 from items import Sun, Projectile, Weapon, World, Character
 
@@ -13,44 +14,24 @@
     def __init__(self):
         """ BoomBoomConstructor constructor. """
         EventListener.__init__(self, prefix="evt_")
+        self.registerEvent("happyboom")
         self.registerEvent("game")
-        self.registerEvent(bb_events.create)
-        self.registerEvent(bb_events.text)
+        self.registerEvent("log")
         
-    def evt_agent_manager_Create(self, event):
+    def evt_happyboom_doCreateItem(self, type, id):
         """ Create event handler.
         @param event: Event with "agent_manager_Create" type.
         @type event: C{L{common.event.Event}}
         """
-        arg = event.content.split(":")
-        type = arg[0]
-        id = int(arg[1])
-        item = self.tryCreateItem(id, type)
-        if item != None:
-            event.source.send("yes")
-            event.source.send(type)
-            event.source.send(".")
-        else:
-            event.source.send("no")
-        
-    def tryCreateItem(self, id, type):
-        """ Constructs an item of required type.
-        @param id: Server id of the item.
-        @type id: C{int}
-        @param type: Type of item to construct.
-        @type type: C{str}
-        @return: The constructed item or C{None}, if the type does not exist.
-        @rtype: C{L{BoomBoomItem}}
-        """
+        log.info("Try to create object %s ..." % type)
         if type=="projectile":
-            return Projectile()
+            Projectile()
         if type=="weapon":
-            return Weapon()
+            Weapon()
         if type=="world":
-            return World()
+            World()
         if type=="character":
-            return Character(id, "foo")
-        return None
+            Character(id, "foo")
         
     def evt_game_start(self):
         """ Start event handler.
@@ -59,9 +40,18 @@
         """
         Sun()
         
+    def evt_log_info(self, text):
+        print u"[SERVER info] %s" % text
+        
+    def evt_log_warning(self, text):
+        print u"[SERVER warn] %s" % text
+        
+    def evt_log_error(self, text):
+        print u"[SERVER error] %s" % text
+        
     def evt_agent_manager_Text(self, event):
         """ Text event handler.
         @param event: Event with "agent_manager_Text" type.
         @type event: C{L{common.event.Event}}
         """
-        print "[DISPLAY] Server message: %s" %(event.content)
+        print "[CLIENT] Server message: %s" %(event.content)

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/bb_display.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -5,17 +5,15 @@
 @version: 0.2
 """
 from happyboom.common.happyboom_protocol import HappyboomProtocol as Presentation
-from happyboom.common.event import EventLauncher, EventListener
 from happyboom.common.log import log
+from happyboom.client.base_client import Client as BaseClient
+from happyboom.common.event import EventListener
 import bb_events
 from bb_drawer import BoomBoomDrawer
 from bb_constructor import BoomBoomConstructor
-from net import io
 from happyboom.net.io import Packet
-from net import io_udp, io_tcp
-import thread
 
-class BoomBoomDisplay(EventLauncher, EventListener):
+class BoomBoomDisplay(BaseClient, EventListener):
     """ Class which manages "display" part of the network connections.
     Also creates a drawer and a constuctor for "display" management.
     @ivar drawer: instance which draws screen game.
@@ -26,21 +24,9 @@
     @type port: C{int}
     @ivar name: Name of the client (as known by the server).
     @type name: C{str}
-    @ivar __protocol_version: Current version of the protocol used by the client.
-    @type __protocol_version: C{str}
-    @ivar __io: Network input/output object using UDP protocole.
-    @type __io: C{net.io_udp.IO_UDP}
-    @ivar __verbose: Verbose mode flag.
-    @type __verbose: C{bool}
-    @ivar __debug: Debug mode flag.
-    @type __debug: C{bool}
-    @ivar __stopped: Stopped display client flag.
-    @type __stopped: C{bool}
-    @ivar __stoplock: Mutex for synchronizing __stopped.
-    @type __stoplock: C{thread.lock}
     """
     
-    def __init__(self, protocol, arg):
+    def __init__(self, arg):
         """ BoomBoomDisplay constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -55,102 +41,40 @@
         @param max_fps: Maximal number of frames per second, for optimization.
         @type max_fps: C{int}
         """
-        EventLauncher.__init__(self)
-        EventListener.__init__(self, prefix="evt_")
-        self.presentation = Presentation(protocol)
+
+        EventListener.__init__(self)
+        BaseClient.__init__(self, arg)
         self.drawer = BoomBoomDrawer(arg.get("max_fps", 25))
-        self.host = arg.get("host", "localhost")
-        self.port = arg.get("port", 12430)
         self.name = arg.get("name", "no name")
-        self.__protocol = protocol
-        self.__io = io_tcp.IO_TCP()
-        self.__verbose = arg.get("verbose", False)
-        self.__io.verbose = self.__verbose
-        self.__debug = arg.get("debug", False)
-        self.__io.debug = self.__debug
-        self.__stopped = False
-        self.__stoplock = thread.allocate_lock()
-        
-        self.registerEvent("weapon")
+        #TODO: Support chat?
+        self.gateway.features = ["game", "character", "projectile", "weapon", "world", "log"]
         self.registerEvent("happyboom")
-        self.launchEvent("happyboom", "register", "connection", self.onConnection)
-        self.launchEvent("happyboom", "register", "disconnection", self.onDisconnection)
 
-    def onConnection(self, ioclient, version, signature):
-        # TODO: Save signature to reuse it later
-        features = "TODO: Feed me!"
-        if self.__verbose: log.info("Connected to server, send features ...")
-        self.launchEvent("happyboom", "features", self.__io, features)
-    
-    def onDisconnection(self, ioclient, reason):
-        log.warning(u"Received disconnected from server: %s" % reason)
-        self.launchEvent("game", "stop")
-        
+    def evt_happyboom_netSendMsg(self, feature, event, *args):
+        self.send(feature, event, *args)
+
     def start(self):
         """ Starts the display client : connection to the server, etc. """
-        # Try to connect to server
-        if self.__verbose: print "[DISPLAY] Trying to connect to server %s:%u" % (self.host, self.port)
-        self.__io.on_connect = self.onConnect
-        self.__io.on_connection_fails = self.onConnectionFails
-        self.__io.on_disconnect = self.onDisconnect
-        self.__io.on_new_packet = self.presentation.processPacket
-        self.__io.on_lost_connection = self.onLostConnection
-        self.__io.connect(self.host, self.port)
-        if not self.__io.is_ready: return
-        thread.start_new_thread(self.__io.run_thread, ())
+        BaseClient.start(self)
     
         BoomBoomConstructor()
-        self.launchEvent("happyboom", "connection", self.__io, self.__protocol.version.encode("ascii"), "")
         print "==== BoomBoom ===="
         self.drawer.start()
         
     def stop(self):
         """ Stops the display client : disconnection from the server, etc. """
-        self.__stoplock.acquire()
-        self.__stopped = True
-        self.__stoplock.release()
-        # TODO: clean "bye"
-        self.launchEvent("happyboom", "disconnection", self.__io, u"Quit.")
-        self.__io.stop()
-        if self.__verbose: print "[DISPLAY] Stopped"
-        
-    def setIoSendReceive(self, on_send, on_receive):
-        """ Set new handler functions for I/O network.
-        @param on_send: Handler called for sending data.
-        @type C{function}
-        @param on_receive: Handler called for receiving data.
-        @type C{function}
-        """
-        self.__io.on_send = on_send
-        self.__io.on_receive = on_receive
-        
-    def onConnect(self):
-        """ Handler called on network connection. """
-        if self.__verbose: print "[DISPLAY] Connected to server"
-        
-    def onConnectionFails(self):
-        """ Handler called when network connection fails. """
-        print "[DISPLAY] Fail to connect to the server"
+        if not BaseClient.stop(self): return
+        self.launchEvent("happyboom", "disconnection", self._io, u"Quit.")
+        self._io.stop()
+        if self.verbose: print "[CLIENT] Stopped"
 
-    def onDisconnect(self):
-        """ Handler called on network disconnection. """
-        print "[DISPLAY] Connection to server closed"
-        self.launchEvent("game", "start")
-
-    def onLostConnection(self):
-        """ Handler called on losting network connection. """
-        print "[DISPLAY] Lost connection with server"
-        self.launchEvent("game", "stop")
-    
-    def send(self, feature, event, *args):
-        """ Sends a string to the network server.
-        @param str: String to send.
-        @type str: C{str}
-        """
-        data = self.__protocol.createMsg(feature, event, *args)
-        data = self.presentation.sendMsg(data)
-        self.__io.send(Packet(data))
-        
-    def evt_weapon_shoot(self, event):
-        print "Shoot aussi"
-        self.send("weapon", "shoot")
+# Wass used for stats
+#    def setIoSendReceive(self, on_send, on_receive):
+#        """ Set new handler functions for I/O network.
+#        @param on_send: Handler called for sending data.
+#        @type C{function}
+#        @param on_receive: Handler called for receiving data.
+#        @type C{function}
+#        """
+#        self._io.on_send = on_send
+#        self._io.on_receive = on_receive

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/bb_input.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -84,8 +84,7 @@
         if event.type == pygame.KEYDOWN: 
             # arrow keys: move character
             if event.key == 32:
-                print "Event %s" % bb_events.shoot
-                self.launchEvent("weapon", "shoot")
+                self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
             elif event.key == 275: self.sendCmd("move_right")
             elif event.key == 273: self.sendCmd("move_up") 
             elif event.key == 274: self.sendCmd("move_down")

Modified: boomboom/client/items/character.py
===================================================================
--- boomboom/client/items/character.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/items/character.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -36,18 +36,16 @@
         self.__name = name
         self.visual = VisualObject(os.path.join("data", "gorilla.png"))
         self.active = False
-        self.registerEvent(bb_events.characterMove)
-        self.registerEvent(bb_events.activeCharacter)
+        self.registerEvent("character")
         
-    def evt_character_move(self, event):
+    def evt_character_move(self, id, x, y):
         """ Character move event handler.
         @param event: Event with "character_move" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        id, x, y = event.content.split(",")
-        if self.__id != int(id): return
-        self.__x = int(x)
-        self.__y = int(y)
+        if self.__id != id: return
+        self.__x = x
+        self.__y = y
         self.visual.move(self.__x, self.__y)
         if self.active:
             self.launchEvent(bb_events.activeCharAbs, self.__x)
@@ -61,4 +59,4 @@
         if self.__id == int(event.content):
             self.active = True
             if self.__x != None:
-                self.launchEvent(bb_events.activeCharAbs, self.__x)
\ No newline at end of file
+                self.launchEvent(bb_events.activeCharAbs, self.__x)

Modified: boomboom/client/items/projectile.py
===================================================================
--- boomboom/client/items/projectile.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/items/projectile.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -17,21 +17,17 @@
     def __init__(self):
         """ Projectile itemp constructor. """
         BoomBoomItem.__init__(self)
-        
         self.visual = VisualObject(os.path.join("data", "banana.png"))
-        self.registerEvent(bb_events.projectileMove)
-        self.registerEvent(bb_events.projectileHitGround)
-        self.registerEvent(bb_events.projectileActivate)
+        self.registerEvent("projectile")
         
-    def evt_projectile_move(self, event):
+    def evt_projectile_move(self, x, y):
         """ Projectile move event handler.
         @param event: Event with "projectile_move" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        x, y = event.content.split(",")
-        self.visual.move(int(x), int(y))
+        self.visual.move(x, y)
         
-    def evt_projectile_hit_ground(self, event):
+    def evt_projectile_hitGround(self, x, y):
         """ Projectile hit ground event handler.
         @param event: Event with "projectile_hit_ground" type.
         @type event: C{L{common.simple_event.Event}}
@@ -39,9 +35,9 @@
         print "[DISPLAY] Hit ground"
         # TODO: Graphic effect
         
-    def evt_projectile_activate(self, event):
+    def evt_projectile_activate(self, state):
         """ Projectile activate event handler.
         @param event: Event with "projectile_activate" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        self.visual.setVisibility(event.content == '1')
+        self.visual.setVisibility(state == 1)

Modified: boomboom/client/items/weapon.py
===================================================================
--- boomboom/client/items/weapon.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/items/weapon.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -36,30 +36,41 @@
         self.__font_background = (0,0,0,0)
         self.__y = 10
         self.__x = 10
-        self.registerEvent(bb_events.weaponStrength)
-        self.registerEvent(bb_events.weaponAngle)
-        self.registerEvent(bb_events.activeCharAbs)
+        self.character_pos = {}
+        self.registerEvent("weapon")
+        self.registerEvent("character")
+        print self.event_manager.listeners["character"]
+        self.registerEvent("game")
+#        self.registerEvent(bb_events.activeCharAbs)
+
+    def eventPerformed(self, event):
+        print "WTF ? ", event
         
-    def evt_weapon_force(self, event):
+    def evt_weapon_setStrength(self, strength):
         """ Weapon strength event handler.
         @param event: Event with "weapon_force" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        self.__strength = int(event.content)
+        self.__strength = strength
         
-    def evt_weapon_angle(self, event):
+    def evt_weapon_setAngle(self, angle):
         """ Weapon angle event handler.
         @param event: Event with "weapon_angle" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        self.__angle = int(event.content)
+        self.__angle = angle 
+
+    def evt_charactr_move(self, id, x, y):
+        print "move *** %s,%s" % (x,y)
+        self.character_pos[id] = (x, y,)
         
-    def evt_active_character_abscisse(self, event):
+    def evt_game_setActiveCharacter(self, id):
         """ Active character abcsisse event handler.
         @param event: Event with "active_character_abscisse" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        self.__x = int(event.content)
+        print "active *** %s" % (id)
+        self.__x = self.character_pos[id][0]
         
     def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}
@@ -70,4 +81,4 @@
         if self.__strength == None: return
         txt = "Angle: %s  Strength: %s" % (self.__angle, self.__strength)
         surface = self.__font.render(txt, True, self.__font_color, self.__font_background)
-        screen.blit(surface, (self.__x,self.__y))
\ No newline at end of file
+        screen.blit(surface, (self.__x,self.__y))

Modified: boomboom/client/items/world.py
===================================================================
--- boomboom/client/items/world.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/client/items/world.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -48,15 +48,20 @@
         """ World item constructor. """
         BoomBoomItem.__init__(self)
         self.__buildings = []
-        self.registerEvent(bb_events.worldCreate)
+        self.registerEvent("world")
 
-    def evt_world_create(self, event):
+    def born(self):
+        Agent.born(self)
+        self.registerAction("world")
+
+    def evt_world_create(self, data):
         """ World create event handler.
         @param event: Event with "world_create" type.
         @type event: C{L{common.simple_event.Event}}
         """
+        print "Create world."
         self.__buildings = []
-        rects = event.content.split(";")
+        rects = data.split(";")
         for rect in rects:
             x, y, w, h = rect.split(",")
             b = Building(int(x), int(y), int(w), int(h))
@@ -67,4 +72,4 @@
         @param screen: Offscreen to draw in.
         @type screen: C{L{Window<bb_drawer.Window>}}
         """
-        for b in self.__buildings: b.draw(screen)
\ No newline at end of file
+        for b in self.__buildings: b.draw(screen)

Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/protocol.xml	2005-09-16 04:42:34 UTC (rev 183)
@@ -9,7 +9,25 @@
     <event name="nextTurn" id="4" />
   </feature>
   
-  <feature name="character" id="2">
+  <feature name="log" id="2">
+    <event name="info" id="1">
+      <param type="utf8" name="text" />
+    </event>
+    <event name="warning" id="2">
+      <param type="utf8" name="text" />
+    </event>
+    <event name="error" id="3">
+      <param type="utf8" name="text" />
+    </event>
+  </feature>  
+
+  <feature name="chat" id="3">
+    <event name="message" id="1">
+      <param type="utf8" name="text" />
+    </event>
+  </feature>  
+
+  <feature name="character" id="4">
     <event name="move" id="1">
       <param type="int" name="id" />
       <param type="int" name="x" />
@@ -17,14 +35,21 @@
     </event>
   </feature>
   
-  <feature name="projectile" id="3">
+  <feature name="projectile" id="5">
     <event name="activate" id="1">
       <param type="int" name="on" />
     </event>
-    <event name="hitGround" id="2" />
+    <event name="move" id="2">
+      <param type="int" name="x" />
+      <param type="int" name="y" />
+    </event>
+    <event name="hitGround" id="3">
+      <param type="int" name="x" />
+      <param type="int" name="y" />
+    </event>
   </feature>
   
-  <feature name="weapon" id="4">
+  <feature name="weapon" id="6">
     <event name="shoot" id="1" />
     <event name="setAngle" id="2">
       <param type="int" name="angle" />
@@ -34,9 +59,9 @@
     </event>
   </feature>
   
-  <feature name="chat" id="5">
-    <event name="message" id="1">
-      <param type="utf8" name="text" />
+  <feature name="world" id="7">
+    <event name="create" id="1">
+      <param type="bin" name="buildings" />
     </event>
   </feature>
 </protocol>

Modified: boomboom/server/agents/__init__.py
===================================================================
--- boomboom/server/agents/__init__.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/__init__.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -1,3 +1,4 @@
+from log import LogAgent
 from projectile import Projectile
 from weapon import Weapon
 from world import World
@@ -2,2 +3,2 @@
 from character import Character
-from game import Game
\ No newline at end of file
+from game import Game

Modified: boomboom/server/agents/character.py
===================================================================
--- boomboom/server/agents/character.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/character.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -10,6 +10,7 @@
         self.team = team
         self.next = False
         self.current = False
+        self.registerEvent("gateway")
         
     def born(self):
         Agent.born(self)
@@ -23,12 +24,11 @@
         if self.x == x and self.y == y and not force: return
         self.x = x
         self.y = y
-        self.sendBroadcast(Message("character_move", ("%u,%i,%i" % (self.id, self.x, self.y),)), "network")
-        if self.current:
-            self.send("active_coord", self.x, self.y)
-            self.sendNetMsg("character", "move", self.id, self.x, self.y)
+        self.send("move", self.id, self.x, self.y)
+        self.sendNetMsg("character", "move", self.id, self.x, self.y)
 
-    def sync(self):
+    def evt_gateway_syncClient(self, client):
+        self.netCreateItem(client)
         self.move(self.x, self.y, force=True)
 
     def msg_found_place(self, x, y):
@@ -39,6 +39,3 @@
         if self.current:
             self.send("active_coord", self.x, self.y)
         self.next = False
-        
-    def msg_network_sync(self):
-        self.sync()

Modified: boomboom/server/agents/game.py
===================================================================
--- boomboom/server/agents/game.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/game.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -6,26 +6,23 @@
         Agent.__init__(self, "game", gateway, **args)
         self.characters = []
         self.current = None 
+        self.registerEvent("gateway")
 
     def born(self):
         Agent.born(self)
         self.requestActions("world")
         self.requestActions("network")
 
-    def msg_network_sync(self):
-        self.sync()
-
     def msg_new_character(self, character):
         self.characters.append(character)
         if self.current == None:
             self.setCurrent(0)
 
-    def sync(self):
-        self.sendBroadcast(Message("game_current_character", self.current), "network")
-
     def setCurrent(self, current):
         self.current = current
-        self.sendNetMsg("game", "setActiveCharacter", current)
+        char = self.characters[self.current].id
+        self.send("setActiveCharacter", char)
+        self.sendNetMsg("game", "setActiveCharacter", char)
 
     def nextCharacter(self):
         new = (self.current + 1) % len(self.characters)
@@ -34,9 +31,9 @@
     def nextTurn(self):
         self.send("next_turn")
         self.sendNetMsg("game", "nextTurn")
-        self.sendNetMsg("game", "setActiveCharacter", self.current)
+        self.setCurrent(self.current)
 
-    def msg_world_collision(self, x, y):
+    def msg_world_hitGround(self, x, y):
         self.nextTurn()
         self.nextCharacter()
         
@@ -46,3 +43,7 @@
     def launchGame(self):    
         self.setCurrent(self.current)
         self.nextTurn()
+
+    def evt_gateway_syncClient(self, client):
+        self.sendNetMsg("game", "start")
+        self.setCurrent(self.current)

Added: boomboom/server/agents/log.py
===================================================================
--- boomboom/server/agents/log.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/log.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -0,0 +1,23 @@
+from server.bb_agent import Agent
+from happyboom.common.log import Log, log
+import types
+
+class LogAgent(Agent):
+    def __init__(self, gateway, **args):
+        Agent.__init__(self, "log", gateway, **args)
+        self.registerEvent("gateway")
+        log.on_new_message = self.onNewMessage
+
+    def onNewMessage(self, level, prefix, text):
+        if type(text) != types.UnicodeType:
+            text = unicode(text)
+        if level==Log.LOG_INFO:
+            self.sendNetMsg("log", "info", text)
+        elif level==Log.LOG_INFO:
+            self.sendNetMsg("log", "warning", text)
+        elif level==Log.LOG_INFO:
+            self.sendNetMsg("log", "error", text)
+        
+    def evt_gateway_syncClient(self, client):
+        # Send last messages?
+        pass

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/projectile.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -9,11 +9,14 @@
         self.x, self.y = 0, 0
         self.start_pos = None
         self.active = False
+        self.active_character = None
         self.time = None
         self.speed = None
         self.weapon_angle = None
         self.weapon_strength = None
         self.mass = 10
+        self.registerEvent("gateway")
+        self.registerEvent("weapon")
 
     def born(self):
         Agent.born(self)
@@ -31,28 +34,32 @@
     def msg_weapon_angle(self, angle):
         self.weapon_angle = (-int(angle)) * math.pi / 180
 
-    def msg_weapon_shoot(self, cmd):
+    def msg_weapon_shoot(self):
         if not self.active:
             self.shoot()
 
-    def msg_character_active_coord(self, x, y):
-        self.start_pos = (x, y)
+    def msg_game_setActiveCharacter(self, id):
+        self.active_character = id
 
-    def msg_world_collision(self, x, y):
+    def msg_character_move(self, id, x, y):
+        if self.active_character == id:
+            self.start_pos = (x, y) 
+
+    def msg_world_hitGround(self, x, y):
         self.setActive(False)
 
     def setActive(self, active):
         self.active = active
-        self.sendBBMessage("activate", active)
-        self.sendNetMsg("projectile", "activate", 0) 
+        self.send("activate", active)
+        self.sendNetMsg("projectile", "activate", int(active)) 
 
     def shoot(self):
-        log.info("Shoot!")
         if self.weapon_angle==None: return
         if self.weapon_strength==None: return
         if self.start_pos==None: return
         self.move(self.start_pos[0], self.start_pos[1])
         self.setActive(True)
+
         self.time = time.time()
         sx = self.weapon_strength * math.cos(self.weapon_angle)
         sy = self.weapon_strength * math.sin(self.weapon_angle)
@@ -63,8 +70,8 @@
     def move(self, x, y):
         self.x = x
         self.y = y
-        self.sendBBMessage("move", x, y)
-        self.sendNetMsg("projectile", "move", x, y)
+        self.send("move", x, y)
+        self.sendNetMsg("projectile", "move", int(x), int(y))
 
     def live(self):
         Agent.live(self)
@@ -74,8 +81,9 @@
             y = self.start_pos[1] +self.speed[1] * dt +9.8*dt*dt*self.mass
             self.move (x, y)
 
-    def sync(self, client):
-        # TODO: Only send it to client
+    def evt_gateway_syncClient(self, client):
+        self.netCreateItem(client)
+        self.move(self.x, self.y)
         self.setActive(self.active)
 
     def msg_gateway_syncClient(self, client):

Modified: boomboom/server/agents/weapon.py
===================================================================
--- boomboom/server/agents/weapon.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/weapon.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -8,6 +8,7 @@
         self.last_values = {}
         self.currentTeam = None
         self.nextTeam = None
+        self.registerEvent("gateway")
 
     def born(self):
         Agent.born(self)
@@ -26,16 +27,6 @@
         self.updateAngle(angle)
         self.updateStrength(strength)
 
-    def msg_new_command(self, cmd):
-        if cmd == "move_left":
-            self.updateStrength (self.strength - 5)
-        if cmd == "move_right":
-            self.updateStrength (self.strength + 5)
-        if cmd == "move_down":
-            self.updateAngle (self.angle - 5)
-        if cmd == "move_up":
-            self.updateAngle (self.angle + 5)
-
     def updateAngle(self, angle):
         if angle < -80: angle = -80
         elif 80 < angle: angle = 80
@@ -50,9 +41,7 @@
         self.send("strength", strength)
         self.sendNetMsg("weapon", "setStrength", strength)
 
-    def sync(self):
+    def evt_gateway_syncClient(self, client):
+        self.netCreateItem(client)
         self.updateStrength(self.strength)
         self.updateAngle(self.angle)
-
-    def msg_network_sync(self):
-        self.sync()

Modified: boomboom/server/agents/world.py
===================================================================
--- boomboom/server/agents/world.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/agents/world.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -26,13 +26,13 @@
         self.buildings = None
         self.height = 350
         self.width = 640
+        self.registerEvent("gateway")
         self.generate()
 
     def born(self):
         Agent.born(self)
         self.requestActions("projectile")
         self.requestActions("game")
-        self.requestActions("network")
         self.sendBroadcastMessage(Message("new_item", (self.type, self.id)), "network")
 
     def generate(self):
@@ -65,13 +65,14 @@
                 return True
         return False    
 
-    def sync(self):
+    def sync(self, client):
         msg = ""
         for b in self.buildings:
             if len(msg) != 0: msg = msg + ";"
             msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
         self.sendBroadcastMessage(Message("world_create", (msg,)), "network")
-        self.sendNetMsg("world", "create", m)
+        self.netCreateItem(client)
+        self.sendNetMsg("world", "create", msg)
 
     def msg_character_search_place(self, x0, width, height):
         if x0 < 0:
@@ -90,8 +91,8 @@
                 
     def msg_projectile_move(self, x, y):
         if self.hitGround(x, y):
-            self.sendBBMessage("collision", x, y)
-            self.sendNetMsg("projectile", "hitGround")
+            self.send("hitGround", x, y)
+            self.sendNetMsg("projectile", "hitGround", int(x), int(y))
 
-    def msg_network_sync(self):
-        self.sync()
+    def evt_gateway_syncClient(self, client):
+        self.sync(client)

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-16 04:41:41 UTC (rev 182)
+++ boomboom/server/bb_server.py	2005-09-16 04:42:34 UTC (rev 183)
@@ -5,7 +5,7 @@
     ClientManager
 from pysma import Kernel
 from bb_agent import Message
-from agents import Character, Projectile, Weapon, World, Game
+from agents import Character, Projectile, Weapon, World, Game, LogAgent
 from happyboom.common.log import log
 
 class Gateway(HBGateway):
@@ -23,6 +23,7 @@
     def start(self):
         HBGateway.start(self)
         if self._verbose: log.info("[*] Creating agents")
+        self.addAgent(LogAgent(self, debug=self._debug))
         self.addAgent(Game(self, debug=self._debug))
         self.addAgent(World(self, debug=self._debug))
         self.addAgent(Character(self, 100, 1, debug=self._debug))



From haypo at berlios.de  Fri Sep 16 19:03:08 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Fri, 16 Sep 2005 19:03:08 +0200
Subject: [Happyboom-svn] r184 - boomboom boomboom/client boomboom/client/items boomboom/server boomboom/server/agents happyboom/trunk/client happyboom/trunk/common happyboom/trunk/server
Message-ID: <200509161703.j8GH38sB007694@sheep.berlios.de>

Author: haypo
Date: 2005-09-16 19:03:03 +0200 (Fri, 16 Sep 2005)
New Revision: 184

Modified:
   boomboom/boomboom_client.py
   boomboom/client/bb_constructor.py
   boomboom/client/bb_display.py
   boomboom/client/bb_drawer.py
   boomboom/client/bb_input.py
   boomboom/client/bb_item.py
   boomboom/client/items/__init__.py
   boomboom/client/items/sun.py
   boomboom/client/items/weapon.py
   boomboom/client/items/world.py
   boomboom/protocol.xml
   boomboom/server/agents/character.py
   boomboom/server/agents/log.py
   boomboom/server/agents/projectile.py
   boomboom/server/agents/weapon.py
   boomboom/server/agents/world.py
   boomboom/server/bb_server.py
   happyboom/trunk/client/base_client.py
   happyboom/trunk/common/generic_event.py
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/server/agent.py
   happyboom/trunk/server/client.py
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
Dernieres corrections pour faire fonctionner client et serveur.
J'ai du ajouter weapon.askSetStrength() et weapon.askSetAngle().


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/boomboom_client.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -1,4 +1,4 @@
-#!/usr/bin/python -W all
+#!/usr/bin/python
 # -*- coding: ISO-8859-1 -*-
 VERSION="0.2.0"
 PROGRAM="BoomBoom client"
@@ -19,6 +19,7 @@
     print "\t--port PORT       : Server port (default %u)" % (defval["port"])
     print "\t-d,--debug        : Enable debug mode"
     print "\t-v,--verbose      : Enable verbose mode"
+    print "\t--server-log      : Output server log (default: %u)" % (defval["server-log"])
     print "\t--max-fps MAX     : Set maximum frame par second (fps)"
 
 def parseArgs(val):
@@ -29,7 +30,7 @@
         short = "h:dv"
         long = ["debug", "help", "version", "verbose", \
             "view-port=", "input-port=",
-            "host=", "max-fps="]
+            "host=", "max-fps=", "server-log"]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage(defval)
@@ -49,6 +50,8 @@
             val["host"] = a
         if o in ("-v", "--verbose",):
             val["verbose"] = True
+        if o == "--verbose":
+            val["server-log"] = True
         if o == "--max-fps":
             a = int(a)
             if a < 1: a=1
@@ -85,6 +88,7 @@
         "port": 12430, \
         "max_fps": 50, \
         "verbose": False, \
+        "server-log": False, \
         "name": "-", \
         "debug": False}
     arg = parseArgs(val)

Modified: boomboom/client/bb_constructor.py
===================================================================
--- boomboom/client/bb_constructor.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/bb_constructor.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -7,27 +7,30 @@
 from happyboom.common.event import EventListener
 from happyboom.common.log import log
 import bb_events
-from items import Sun, Projectile, Weapon, World, Character
+from items import Sun, Projectile, Weapon, World, Character, LogItem
 
 class BoomBoomConstructor(EventListener):
     """ Constructs visual items when server requires creation. """
-    def __init__(self):
+    def __init__(self, arg):
         """ BoomBoomConstructor constructor. """
         EventListener.__init__(self, prefix="evt_")
+        self.verbose = arg.get("verbose", False)
         self.registerEvent("happyboom")
         self.registerEvent("game")
-        self.registerEvent("log")
         
     def evt_happyboom_doCreateItem(self, type, id):
         """ Create event handler.
         @param event: Event with "agent_manager_Create" type.
         @type event: C{L{common.event.Event}}
         """
-        log.info("Try to create object %s ..." % type)
+        if self.verbose:
+            log.info("Try to create object %s ..." % type)
         if type=="projectile":
             Projectile()
         if type=="weapon":
             Weapon()
+        if type=="log":
+            LogItem()
         if type=="world":
             World()
         if type=="character":
@@ -40,15 +43,6 @@
         """
         Sun()
         
-    def evt_log_info(self, text):
-        print u"[SERVER info] %s" % text
-        
-    def evt_log_warning(self, text):
-        print u"[SERVER warn] %s" % text
-        
-    def evt_log_error(self, text):
-        print u"[SERVER error] %s" % text
-        
     def evt_agent_manager_Text(self, event):
         """ Text event handler.
         @param event: Event with "agent_manager_Text" type.

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/bb_display.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -47,7 +47,9 @@
         self.drawer = BoomBoomDrawer(arg.get("max_fps", 25))
         self.name = arg.get("name", "no name")
         #TODO: Support chat?
-        self.gateway.features = ["game", "character", "projectile", "weapon", "world", "log"]
+        self.gateway.features = ["game", "character", "projectile", "weapon", "world"]
+#        if arg.get("server-log", False):
+#            self.gateway.features.append("log")
         self.registerEvent("happyboom")
 
     def evt_happyboom_netSendMsg(self, feature, event, *args):
@@ -55,11 +57,12 @@
 
     def start(self):
         """ Starts the display client : connection to the server, etc. """
-        BaseClient.start(self)
-    
-        BoomBoomConstructor()
         print "==== BoomBoom ===="
         self.drawer.start()
+        BaseClient.start(self)
+        args = {"verbose": self.verbose}
+        BoomBoomConstructor(args)
+        self.drawer.mainLoop()
         
     def stop(self):
         """ Stops the display client : disconnection from the server, etc. """

Modified: boomboom/client/bb_drawer.py
===================================================================
--- boomboom/client/bb_drawer.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/bb_drawer.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -35,6 +35,8 @@
         self.__screen = Window(640, 350)
         self.__screen.background_color = (0, 0, 168)
         
+    def mainLoop(self):
+        """ Display loop. """
         while True:
             live_begin = time.time()
             

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/bb_input.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -4,14 +4,14 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from happyboom.common.event import EventLauncher
+from happyboom.common.event import EventLauncher, EventListener
 import bb_events
 from net import io
 from net import io_udp, io_tcp
 from net import net_buffer
 import thread, time, pygame
 
-class BoomBoomInput(EventLauncher):
+class BoomBoomInput(EventLauncher, EventListener):
     """ Class which manages "input" part of the network connections.
     @ivar host: Server hostname.
     @type host: C{str}
@@ -50,7 +50,17 @@
         """
 
         EventLauncher.__init__(self)
+        EventListener.__init__(self)
+        self.weapon_angle = None
+        self.weapon_strength = None
+        self.registerEvent("weapon")
+
+    def evt_weapon_setStrength(self, strength):
+        self.weapon_strength = strength
         
+    def evt_weapon_setAngle(self, angle):
+        self.weapon_angle = angle
+        
     def process(self):
         for input_event in pygame.event.get():
             self.process_event(input_event)
@@ -72,9 +82,14 @@
         #if character != None: self.process_event_active(character, event)
         self.process_event_active(event)
 
-    def sendCmd(self, cmd):
-        self.x.sendNetMsg("input", cmd)
+    def weapon_setStrengthDelta(self, delta):
+        self.launchEvent("happyboom", "network", \
+            "weapon", "askSetStrength", self.weapon_strength + delta)
 
+    def weapon_setAngleDelta(self, delta):
+        self.launchEvent("happyboom", "network", \
+            "weapon", "askSetAngle", self.weapon_angle + delta)
+
     def process_event_active(self, event):
         """ Manages when a pygame event is caught and interact with the server.
         @param event: Pygame event.
@@ -85,7 +100,11 @@
             # arrow keys: move character
             if event.key == 32:
                 self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
-            elif event.key == 275: self.sendCmd("move_right")
-            elif event.key == 273: self.sendCmd("move_up") 
-            elif event.key == 274: self.sendCmd("move_down")
-            elif event.key == 276: self.sendCmd("move_left")
+            elif event.key == 275:
+                self.weapon_setStrengthDelta(10) # RIGHT 
+            elif event.key == 273:
+                self.weapon_setAngleDelta(10) # UP
+            elif event.key == 274:
+                self.weapon_setAngleDelta(-10) # DOWN
+            elif event.key == 276:
+                self.weapon_setStrengthDelta(-10) # LEFT

Modified: boomboom/client/bb_item.py
===================================================================
--- boomboom/client/bb_item.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/bb_item.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -28,6 +28,11 @@
         """
         if self.visual == None: return
         self.visual.draw(screen)
+    
+    def sendNetMsg(self, feature, event, *args):
+        print "SEND NET %s" % (feature)
+        self.launchEvent("happyboom", "network", \
+            feature, event, *args)
 
 class VisualObject(object):
     """ Manage representation and transformation of an external image to be drawn into game screen.

Modified: boomboom/client/items/__init__.py
===================================================================
--- boomboom/client/items/__init__.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/items/__init__.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -2,4 +2,5 @@
 from projectile import Projectile
 from weapon import Weapon
 from world import World
-from character import Character
\ No newline at end of file
+from character import Character
+from log import LogItem

Modified: boomboom/client/items/sun.py
===================================================================
--- boomboom/client/items/sun.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/items/sun.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -26,25 +26,22 @@
         self.__visual1.move (300,10)
         self.__visual2.move (300,10)
         self.visual = self.__visual1
-        self.registerEvent(bb_events.nextTurn)
-        self.registerEvent(bb_events.projectileMove)
+        self.registerEvent("projectile")
+        self.registerEvent("game")
         
-    def evt_game_next_turn(self, event):
+    def evt_game_nextTurn(self):
         """ Next turn event handler.
         @param event: Event with "game_next_turn" type.
         @type event: C{L{common.simple_event.Event}}
         """
         self.resetHit()
         
-    def evt_projectile_move(self, event):
+    def evt_projectile_move(self, x, y):
         """ Projectile move event handler.
         @param event: Event with "projectile_move" type.
         @type event: C{L{common.simple_event.Event}}
         """
         if self.visual == self.__visual2: return
-        arg = event.content.split(",")
-        x = int(arg[0])
-        y = int(arg[1])
         projectile_rect = pygame.Rect([x,y,10,10]) # TODO: Incorrect projectile size!
         if self.visual.rect.colliderect(projectile_rect):
             self.hit()
@@ -55,4 +52,4 @@
     
     def hit(self):
         """ Shows the sun which makes "oh". """
-        self.visual = self.__visual2
\ No newline at end of file
+        self.visual = self.__visual2

Modified: boomboom/client/items/weapon.py
===================================================================
--- boomboom/client/items/weapon.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/items/weapon.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -34,18 +34,13 @@
         self.__font = pygame.font.SysFont(fontname, 14)
         self.__font_color = (255,255,255,255)
         self.__font_background = (0,0,0,0)
-        self.__y = 10
-        self.__x = 10
+        self.x, self.y = (None, 10)
         self.character_pos = {}
+        self.active_character = None
         self.registerEvent("weapon")
         self.registerEvent("character")
-        print self.event_manager.listeners["character"]
         self.registerEvent("game")
-#        self.registerEvent(bb_events.activeCharAbs)
 
-    def eventPerformed(self, event):
-        print "WTF ? ", event
-        
     def evt_weapon_setStrength(self, strength):
         """ Weapon strength event handler.
         @param event: Event with "weapon_force" type.
@@ -60,18 +55,18 @@
         """
         self.__angle = angle 
 
-    def evt_charactr_move(self, id, x, y):
-        print "move *** %s,%s" % (x,y)
+    def evt_character_move(self, id, x, y):
         self.character_pos[id] = (x, y,)
+        self.updateX()
         
     def evt_game_setActiveCharacter(self, id):
         """ Active character abcsisse event handler.
         @param event: Event with "active_character_abscisse" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        print "active *** %s" % (id)
-        self.__x = self.character_pos[id][0]
-        
+        self.active_character = id
+        self.updateX()
+               
     def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}
         @param screen: Offscreen to draw in.
@@ -79,6 +74,12 @@
         """
         if self.__angle == None: return
         if self.__strength == None: return
+        if self.x == None: return
         txt = "Angle: %s  Strength: %s" % (self.__angle, self.__strength)
         surface = self.__font.render(txt, True, self.__font_color, self.__font_background)
-        screen.blit(surface, (self.__x,self.__y))
+        screen.blit(surface, (self.x,self.y))
+
+    def updateX(self):
+        if self.active_character==None: return
+        pos = self.character_pos.get(self.active_character, None)
+        if pos != None: self.x = pos[0]

Modified: boomboom/client/items/world.py
===================================================================
--- boomboom/client/items/world.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/client/items/world.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -59,7 +59,6 @@
         @param event: Event with "world_create" type.
         @type event: C{L{common.simple_event.Event}}
         """
-        print "Create world."
         self.__buildings = []
         rects = data.split(";")
         for rect in rects:

Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/protocol.xml	2005-09-16 17:03:03 UTC (rev 184)
@@ -57,6 +57,12 @@
     <event name="setStrength" id="3">
       <param type="int" name="angle" />
     </event>
+    <event name="askSetAngle" id="4">
+      <param type="int" name="angle" />
+    </event>
+    <event name="askSetStrength" id="5">
+      <param type="int" name="angle" />
+    </event>
   </feature>
   
   <feature name="world" id="7">

Modified: boomboom/server/agents/character.py
===================================================================
--- boomboom/server/agents/character.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/server/agents/character.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -27,8 +27,10 @@
         self.send("move", self.id, self.x, self.y)
         self.sendNetMsg("character", "move", self.id, self.x, self.y)
 
+    def evt_gateway_syncClientCreate(self, client):
+        self.netCreateItem(client)
+
     def evt_gateway_syncClient(self, client):
-        self.netCreateItem(client)
         self.move(self.x, self.y, force=True)
 
     def msg_found_place(self, x, y):

Modified: boomboom/server/agents/log.py
===================================================================
--- boomboom/server/agents/log.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/server/agents/log.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -18,6 +18,9 @@
         elif level==Log.LOG_INFO:
             self.sendNetMsg("log", "error", text)
         
+    def evt_gateway_syncClientCreate(self, client):
+        self.netCreateItem(client)    
+
     def evt_gateway_syncClient(self, client):
         # Send last messages?
         pass

Modified: boomboom/server/agents/projectile.py
===================================================================
--- boomboom/server/agents/projectile.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/server/agents/projectile.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -10,6 +10,8 @@
         self.start_pos = None
         self.active = False
         self.active_character = None
+        self.character_pos = {}
+        self.start_pos = None
         self.time = None
         self.speed = None
         self.weapon_angle = None
@@ -28,11 +30,11 @@
         self.requestActions("gateway")
         self.sendBroadcastMessage(Message("new_item", (self.type, self.id)), "network")
 
-    def msg_weapon_strength(self, arg):
-        self.weapon_strength = int(arg) * 4
+    def msg_weapon_setStrength(self, strength):
+        self.weapon_strength = strength * 4 
         
-    def msg_weapon_angle(self, angle):
-        self.weapon_angle = (-int(angle)) * math.pi / 180
+    def msg_weapon_setAngle(self, angle):
+        self.weapon_angle = (-angle) * math.pi / 180
 
     def msg_weapon_shoot(self):
         if not self.active:
@@ -42,8 +44,7 @@
         self.active_character = id
 
     def msg_character_move(self, id, x, y):
-        if self.active_character == id:
-            self.start_pos = (x, y) 
+        self.character_pos[id] = (x,y)
 
     def msg_world_hitGround(self, x, y):
         self.setActive(False)
@@ -56,7 +57,9 @@
     def shoot(self):
         if self.weapon_angle==None: return
         if self.weapon_strength==None: return
-        if self.start_pos==None: return
+        self.start_pos = self.character_pos.get(self.active_character, None)
+        if self.start_pos == None: return
+
         self.move(self.start_pos[0], self.start_pos[1])
         self.setActive(True)
 
@@ -81,8 +84,10 @@
             y = self.start_pos[1] +self.speed[1] * dt +9.8*dt*dt*self.mass
             self.move (x, y)
 
+    def evt_gateway_syncClientCreate(self, client):
+        self.netCreateItem(client)
+
     def evt_gateway_syncClient(self, client):
-        self.netCreateItem(client)
         self.move(self.x, self.y)
         self.setActive(self.active)
 

Modified: boomboom/server/agents/weapon.py
===================================================================
--- boomboom/server/agents/weapon.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/server/agents/weapon.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -1,10 +1,11 @@
 from server.bb_agent import Agent, Message
+from happyboom.common.log import log
 
 class Weapon(Agent):
     def __init__(self, gateway, **args):
         Agent.__init__(self, "weapon", gateway, **args)
-        self.angle = None
-        self.strength = None
+        self.angle = 45 
+        self.strength = 50
         self.last_values = {}
         self.currentTeam = None
         self.nextTeam = None
@@ -13,6 +14,7 @@
     def born(self):
         Agent.born(self)
         self.requestRole("command_manager")
+        self.requestActions("weapon")
         self.requestActions("game")
         self.requestActions("network")
         self.sendBroadcast(Message("new_item", (self.type, self.id)), "network")
@@ -31,17 +33,25 @@
         if angle < -80: angle = -80
         elif 80 < angle: angle = 80
         self.angle = angle 
-        self.send("angle", angle)
+        self.send("setAngle", angle)
         self.sendNetMsg("weapon", "setAngle", angle)
 
+    def msg_weapon_askSetAngle(self, angle):
+        self.updateAngle(angle)
+
+    def msg_weapon_askSetStrength(self, strength):
+        self.updateStrength(strength)
+
     def updateStrength(self, strength):
         if strength < 10: strength = 10
         elif 100 < strength: strength = 100
         self.strength = strength
-        self.send("strength", strength)
+        self.send("setStrength", strength)
         self.sendNetMsg("weapon", "setStrength", strength)
 
+    def evt_gateway_syncClientCreate(self, client):
+        self.netCreateItem(client)
+
     def evt_gateway_syncClient(self, client):
-        self.netCreateItem(client)
         self.updateStrength(self.strength)
         self.updateAngle(self.angle)

Modified: boomboom/server/agents/world.py
===================================================================
--- boomboom/server/agents/world.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/server/agents/world.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -65,15 +65,6 @@
                 return True
         return False    
 
-    def sync(self, client):
-        msg = ""
-        for b in self.buildings:
-            if len(msg) != 0: msg = msg + ";"
-            msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
-        self.sendBroadcastMessage(Message("world_create", (msg,)), "network")
-        self.netCreateItem(client)
-        self.sendNetMsg("world", "create", msg)
-
     def msg_character_search_place(self, x0, width, height):
         if x0 < 0:
             x0 = self.width + x0
@@ -94,5 +85,13 @@
             self.send("hitGround", x, y)
             self.sendNetMsg("projectile", "hitGround", int(x), int(y))
 
+    def evt_gateway_syncClientCreate(self, client):
+        self.netCreateItem(client)
+
     def evt_gateway_syncClient(self, client):
-        self.sync(client)
+        msg = ""
+        for b in self.buildings:
+            if len(msg) != 0: msg = msg + ";"
+            msg = msg + "%i,%i,%i,%i" % (b.x, b.y, b.width, b.height)
+        self.sendBroadcastMessage(Message("world_create", (msg,)), "network")
+        self.sendNetMsg("world", "create", msg)

Modified: boomboom/server/bb_server.py
===================================================================
--- boomboom/server/bb_server.py	2005-09-16 04:42:34 UTC (rev 183)
+++ boomboom/server/bb_server.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -43,7 +43,7 @@
 class Server(HBServer):
     def __init__(self, protocol, arg):
         manager = ClientManager(protocol, arg)
-        presentation = Presentation(protocol)
+        presentation = Presentation(protocol, arg)
         gateway = Gateway(protocol, presentation, manager, arg)
         manager.gateway = gateway
         HBServer.__init__(self, gateway, manager, arg)

Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/client/base_client.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -23,23 +23,27 @@
     """
     
     def __init__(self, args):
+        EventListener.__init__(self) # TODO : Fix me (with good arguments)
         EventLauncher.__init__(self)
-        EventListener.__init__(self) # TODO : Fix me (with good arguments)
         self.host = args.get("host", "127.0.0.1")
         self.port = args.get("port", 12430)
         self.verbose = args.get("verbose", False)
         self.debug = args.get("debug", False)
         protocol = args.get("protocol", None)
         self._io = IO_TCP()
-        self._io.verbose = self.verbose
-        self._io.debug = self.debug
+        self._io.verbose = False # self.verbose
+        self._io.debug = False # self.debug
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
         
         self.signature = None
-        self.presentation = HappyboomProtocol(protocol)
-        self.gateway = Gateway(protocol)
+        self.presentation = HappyboomProtocol(protocol, args)
+        self.gateway = Gateway(protocol, args)
+        self.registerEvent("happyboom")
 
+    def evt_happyboom_network(self, feature, event, *args):
+        self.send(feature, event, *args)
+
     def send(self, feature, event, *args):
         """ Sends a string to the network server.
         @param str: String to send.
@@ -86,7 +90,7 @@
     
     def onConnect(self):
         """ Handler called on network connection. """
-        if self.verbose: print "[HAPPYBOOM] Connected to server"
+        if self.verbose: print "[HAPPYBOOM] Connected to server, send presentation connection()."
         self.launchEvent("happyboom", "connection", self._io, self.presentation.protocol.version.encode("ascii"), "")
         
     def onConnectionFails(self):
@@ -95,6 +99,7 @@
 
     def onDisconnect(self):
         """ Handler called on network disconnection. """
+        if self.stopped: return
         print "[HAPPYBOOM] Connection to server closed"
         self.launchEvent("happyboom", "stop")
 
@@ -114,7 +119,7 @@
             self.launchEvent(event_type, arg)
             
 class Gateway(EventLauncher, EventListener):
-    def __init__(self, protocol):
+    def __init__(self, protocol, args):
         EventLauncher.__init__(self)
         EventListener.__init__(self, "evt_")
         self.protocol = protocol
@@ -124,6 +129,8 @@
 #        self.launchEvent("happyboom", "register", "destroy_item", self.processXX)
         self.launchEvent("happyboom", "register", "recv_event", self.processEvent)
         self.registerEvent("happyboom")
+        self.verbose = args.get("verbose", False)
+        self.debug = args.get("debug", False)
         self.features = []
         self.items = {}
         #self.gamepath = None
@@ -190,5 +197,6 @@
         self.launchEvent("happyboom", "doCreateItem", type, id)
 
     def processEvent(self, ioclient, feature, event, *args):       
-        log.info("New event: %s.%s%s" % (feature, event, args))
+        if self.debug:
+            log.info("New event: %s.%s%s" % (feature, event, args))
         self.launchEvent(feature, event, *args)

Modified: happyboom/trunk/common/generic_event.py
===================================================================
--- happyboom/trunk/common/generic_event.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/common/generic_event.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -26,8 +26,9 @@
         @param event_type: Type of the event to listen.
         @type event_type: C{str}
         """
-        if event_type in self.listeners and obj not in self.listeners[event_type]:
-            self.listeners[event_type].append(obj)
+        if event_type in self.listeners:
+            if obj not in self.listeners[event_type]:
+                self.listeners[event_type].append(obj)
         else:
             self.listeners[event_type] = [obj]
     

Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -4,8 +4,8 @@
 import struct
 
 class HappyboomProtocol(Presentation):
-    def __init__(self, protocol):
-        Presentation.__init__(self, protocol)
+    def __init__(self, protocol, args):
+        Presentation.__init__(self, protocol, args)
         self._unpackFunc = { \
             self.CONNECTION: self.unpackConnection,
             self.DISCONNECTION: self.unpackDisconnect,

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/common/presentation.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -18,12 +18,13 @@
     DESTROY       = 0x5
     EVENT         = 0x6
     
-    def __init__(self, protocol):
-        EventListener.__init__(self, "evt_", silent=True)
+    def __init__(self, protocol, args):
+        EventListener.__init__(self)
         self.protocol = protocol
         self.items = {}
         self._unpackFunc = {}
         self.registerEvent("happyboom")
+        self.verbose = args.get("verbose", False)
 
         # Event (IO_Client client, str version, str signature)
         self._on_connection = None
@@ -73,11 +74,15 @@
         self.evt_happyboom_disconnection(ioclient, reason)
 
     def evt_happyboom_features(self, ioclient, features):
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send features(%s)" % features)
         data = struct.pack("!B", self.FEATURES)
         data = data + packBin(features)
         ioclient.send( Packet(data) )
         
     def evt_happyboom_create(self, ioclient, feature, id):
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send create(%s, %s)" % (feature, id))
         data = struct.pack("!BBI", self.CREATE, feature, id)
         ioclient.send( Packet(data) )
        
@@ -87,7 +92,8 @@
         @type version ASCII string
         @type signature string
         """
-       
+        if self.verbose:
+            log.info("[PRESENTATION] Send connection(\"%s\", \"%s\")" % (version, signature))
         data = struct.pack("!B", self.CONNECTION)
         data = data + packBin(version)
         data = data + packBin(signature)
@@ -100,6 +106,8 @@
         @type reason Unicode
         """
         
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send disconnection(\"%s\")" % reason)
         data = struct.pack("!B", self.DISCONNECTION) + packUtf8(reason)
         ioclient.send( Packet(data) )
         ioclient.disconnect()

Modified: happyboom/trunk/server/agent.py
===================================================================
--- happyboom/trunk/server/agent.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/server/agent.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -16,7 +16,10 @@
         self.sendBroadcast = self.sendBroadcastMessage
 
     def netCreateItem(self, client):
-        self.launchEvent("happyboom", "netCreateItem", client, self)
+        if self.type in client.features:
+            self.launchEvent("happyboom", "netCreateItem", client, self)
+        elif self.__debug:
+            log.info("Client %s doesn't want item %s" % (client, self.type))
 
     def born(self):
         self.requestRole(self.type)

Modified: happyboom/trunk/server/client.py
===================================================================
--- happyboom/trunk/server/client.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/server/client.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -11,6 +11,7 @@
         self.__client_manager = client_manager
         self.__gateway = gateway
         self.signature = None
+        self.features = [] 
 
     def __str__(self):
         return self.io.__str__()

Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/server/client_manager.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -48,15 +48,15 @@
         self.__clients_lock.release() 
 
         # Register client to features
-        print type(features)
         for feature in features:
             f = self.__protocol.getFeatureById(ord(feature))
             feature = f.name
-            log.info("Register feature %s for client %s" % (feature, client))
+            if self.__verbose: log.info("Register feature %s for client %s" % (feature, client))
             if feature in self.__supported_features:
                 self.__supported_features[feature].append(ioclient)
             else:
                 self.__supported_features[feature] = [ioclient]
+            client.features.append(feature)
       
         # Send message to network and to the log
         txt = u"Welcome to new (display) client : %s" % client
@@ -92,10 +92,10 @@
             self.__supported_features[role] = [client,]
         
     def openClient(self, ioclient):
-        log.info("[*] Client %s try to connect ..." % ioclient)
+        if self.__verbose: log.info("[*] Client %s try to connect ..." % ioclient)
 
     def removeClient(self, ioclient):
-        log.info("Disconnect client %s." % ioclient)
+        if self.__verbose: log.info("Disconnect client %s." % ioclient)
         self.gateway.sendText(u"Client %s leave us." % ioclient)
 
         self.__clients_lock.acquire() 

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-16 04:42:34 UTC (rev 183)
+++ happyboom/trunk/server/gateway.py	2005-09-16 17:03:03 UTC (rev 184)
@@ -69,10 +69,12 @@
             self.sendNetMsg("chat", "message", txt)
 
     def recvNetMsg(self, ioclient, feature, event, *args):
+        if self._verbose: log.info("Received: %s.%s%s" % (feature, event, args))
         message = Message("%s_%s" % (feature, event), args)
         self.sendBroadcastMessage(message, "%s_listener" % feature)
 
     def evt_happyboom_newClient(self, client):
+        self.launchEvent("gateway", "syncClientCreate", client)
         self.launchEvent("gateway", "syncClient", client)
 
     def sendNetMsg(self, feature, event, *args):



From haypo at berlios.de  Sat Sep 17 05:24:26 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 17 Sep 2005 05:24:26 +0200
Subject: [Happyboom-svn] r185 - in happyboom/trunk: client common
Message-ID: <200509170324.j8H3OQDF025725@sheep.berlios.de>

Author: haypo
Date: 2005-09-17 05:24:01 +0200 (Sat, 17 Sep 2005)
New Revision: 185

Modified:
   happyboom/trunk/client/base_client.py
   happyboom/trunk/common/file.py
   happyboom/trunk/common/generic_event.py
   happyboom/trunk/common/log.py
Log:
Corrige createHomedir() et ameliore la gestion des log.


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-16 17:03:03 UTC (rev 184)
+++ happyboom/trunk/client/base_client.py	2005-09-17 03:24:01 UTC (rev 185)
@@ -57,7 +57,7 @@
     def start(self):
         """ Starts the client : connection to the server, etc. """
         # Try to connect to server
-        if self.verbose: print "[HAPPYBOOM] Trying to connect to server %s:%u" % (self.host, self.port)
+        if self.verbose: log.info("[HAPPYBOOM] Trying to connect to server %s:%u" % (self.host, self.port))
         self._io.on_connect = self.onConnect
         self._io.on_connection_fails = self.onConnectionFails
         self._io.on_disconnect = self.onDisconnect
@@ -78,7 +78,8 @@
         self.__stoplock.release()
         
         self._io.stop()
-        if self.verbose: print "[HAPPYBOOM] Stopped"
+        if self.verbose:
+            log.info("[HAPPYBOOM] Stopped")
         return True
         
     def __isStopped(self):
@@ -90,22 +91,23 @@
     
     def onConnect(self):
         """ Handler called on network connection. """
-        if self.verbose: print "[HAPPYBOOM] Connected to server, send presentation connection()."
+        if self.verbose:
+            log.info("[HAPPYBOOM] Connected to server, send presentation connection().")
         self.launchEvent("happyboom", "connection", self._io, self.presentation.protocol.version.encode("ascii"), "")
         
     def onConnectionFails(self):
         """ Handler called when network connection fails. """
-        print "[HAPPYBOOM] Fail to connect to the server"
+        log.error("[HAPPYBOOM] Fail to connect to the server.")
 
     def onDisconnect(self):
         """ Handler called on network disconnection. """
         if self.stopped: return
-        print "[HAPPYBOOM] Connection to server closed"
+        log.info("[HAPPYBOOM] Connection to server closed")
         self.launchEvent("happyboom", "stop")
 
     def onLostConnection(self):
         """ Handler called on losting network connection. """
-        print "[HAPPYBOOM] Lost connection with server"
+        log.warning("[HAPPYBOOM] Lost connection with server.")
         self.launchEvent("happyboom", "stop")
         
     def processPacket(self, new_packet):
@@ -115,7 +117,8 @@
         """
         event_type, arg = self.str2evt(new_packet.data)
         if event_type != None: 
-            if self.debug: print "Received message: type=%s arg=%s" %(event_type, arg)
+            if self.debug:
+                log.info("Received message: type=%s arg=%s" %(event_type, arg))
             self.launchEvent(event_type, arg)
             
 class Gateway(EventLauncher, EventListener):

Modified: happyboom/trunk/common/file.py
===================================================================
--- happyboom/trunk/common/file.py	2005-09-16 17:03:03 UTC (rev 184)
+++ happyboom/trunk/common/file.py	2005-09-17 03:24:01 UTC (rev 185)
@@ -20,6 +20,6 @@
     try:
         os.mkdir(logdir)
     except OSError, err:
-        if err[0]==17: pass
-        logdir = None
+        if err[0] != 17:
+            logdir = None
     return logdir

Modified: happyboom/trunk/common/generic_event.py
===================================================================
--- happyboom/trunk/common/generic_event.py	2005-09-16 17:03:03 UTC (rev 184)
+++ happyboom/trunk/common/generic_event.py	2005-09-17 03:24:01 UTC (rev 185)
@@ -5,6 +5,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 1.0
 """
+from happyboom.common.log import log
 class EventManager:
     """ Manages the event-system.
     This class is instanciated on importing the module,
@@ -66,7 +67,7 @@
                 if not obj.event_silent:
                     raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
         else:
-            print("Pas de event.type %s" % event.type)
+            log.error("Pas de event.type %s" % event.type)
 
 EventManager()
     

Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-16 17:03:03 UTC (rev 184)
+++ happyboom/trunk/common/log.py	2005-09-17 03:24:01 UTC (rev 185)
@@ -11,6 +11,7 @@
     def __init__(self):
         self.__buffer = {}
         self.__file = None
+        self.use_print = True
         self.on_new_message = None # (level, prefix, text)
 
     def setFilename(self, filename):
@@ -59,7 +60,8 @@
         else:
             self.__buffer[level].append(str)
         prefix = self.getLevelPrefix(level)            
-        print "%s %s" % (prefix, str)
+        if self.use_print:
+            print "%s %s" % (prefix, str)
         if self.__file:
             self.__file.write(u"%s - %s %s\n" \
                 % (time.strftime("%Y-%M-%d %H:%M:%S"),



From haypo at berlios.de  Sat Sep 17 05:26:40 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 17 Sep 2005 05:26:40 +0200
Subject: [Happyboom-svn] r186 - in boomboom: . client client/items
Message-ID: <200509170326.j8H3QeoG025877@sheep.berlios.de>

Author: haypo
Date: 2005-09-17 05:26:37 +0200 (Sat, 17 Sep 2005)
New Revision: 186

Added:
   boomboom/client/bb_drawer_curses.py
   boomboom/client/bb_input_curses.py
   boomboom/client/bb_input_pygame.py
   boomboom/client/curses_tools.py
   boomboom/client/items/character_curses.py
   boomboom/client/items/log.py
   boomboom/client/items/projectile_curses.py
   boomboom/client/items/projectile_pygame.py
   boomboom/client/items/weapon_curses.py
   boomboom/client/items/world_curses.py
Modified:
   boomboom/boomboom_client.py
   boomboom/client/bb_client.py
   boomboom/client/bb_constructor.py
   boomboom/client/bb_display.py
   boomboom/client/bb_drawer.py
   boomboom/client/bb_input.py
   boomboom/client/items/character.py
   boomboom/client/items/projectile.py
   boomboom/client/items/weapon.py
   boomboom/client/items/world.py
Log:
Supporte le mode texte (en utilisant curses).


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/boomboom_client.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -21,6 +21,7 @@
     print "\t-v,--verbose      : Enable verbose mode"
     print "\t--server-log      : Output server log (default: %u)" % (defval["server-log"])
     print "\t--max-fps MAX     : Set maximum frame par second (fps)"
+    print "\t--text            : Use text output"
 
 def parseArgs(val):
     import getopt
@@ -30,7 +31,7 @@
         short = "h:dv"
         long = ["debug", "help", "version", "verbose", \
             "view-port=", "input-port=",
-            "host=", "max-fps=", "server-log"]
+            "host=", "max-fps=", "server-log", "text"]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage(defval)
@@ -50,8 +51,10 @@
             val["host"] = a
         if o in ("-v", "--verbose",):
             val["verbose"] = True
-        if o == "--verbose":
+        if o == "--server-log":
             val["server-log"] = True
+        if o == "--text":
+            val["textmode"] = True
         if o == "--max-fps":
             a = int(a)
             if a < 1: a=1
@@ -65,6 +68,7 @@
     from happyboom.common.protocol import loadProtocol
     from client import BoomBoomClient
     from client.bb_display import BoomBoomDisplay
+    from happyboom.common.log import log
 
     arg["protocol"] = loadProtocol("protocol.xml")
     display = BoomBoomDisplay(arg)
@@ -72,30 +76,62 @@
     try:
         client.start()
     except KeyboardInterrupt:
-        print "Program interrupted (CTRL+C)."
+        log.warning("Program interrupted (CTRL+C).")
         pass
     client.stop()
 
+def run_curses(stdscr, args):
+    from happyboom.common.log import log
+    try:
+        args["window"] = stdscr
+        stdscr.scrollok(True)
+        run(args)
+    except Exception, err:
+        log.error("Uncatched error in run_curses: %s" % err)
+        raise
+
 def main():
     # Add HappyBoom to PYTHONPATH ("../" today, but should be improved)
     import sys, os
     file_dir = os.path.dirname(__file__)
     happyboomdir = os.path.join(file_dir, "../happyboom/trunk")
     sys.path.append(happyboomdir)
- 
+
+    # Get user directory 
+    from happyboom.common.file import getCreateHomeDir
+    logdir = getCreateHomeDir("boomboom")
+
+    # Setup log filename
+    from happyboom.common.log import log
+    if logdir != None:
+        logname = os.path.join(logdir, "client-log")    
+        log.setFilename(logname)
+
+    # Read command line arguments
     val = {
         "host": "127.0.0.1", \
         "port": 12430, \
         "max_fps": 50, \
         "verbose": False, \
+        "textmode": False, \
         "server-log": False, \
         "name": "-", \
         "debug": False}
     arg = parseArgs(val)
+    textmode = arg["textmode"]
 
     # Create the client
-    import pygame
-    run(arg)
-    pygame.quit()
+    if not textmode:
+        log.info("Start client with pygame.")
+        import pygame
+        pygame.init()
+        run(arg)
+        pygame.quit()
+    else:
+        log.info("Start client with curses.")
+        import curses
+        curses.wrapper(run_curses, arg)
+        log.use_print = True
+    log.info("Quit.")
 
 if __name__=="__main__": main()

Modified: boomboom/client/bb_client.py
===================================================================
--- boomboom/client/bb_client.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_client.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -5,9 +5,11 @@
 @version: 0.2
 """
 from happyboom.common.event import EventListener
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
 import bb_events
-from bb_input import BoomBoomInput
-import thread, time, traceback, pygame
+import thread, time, traceback
+import curses_tools
 
 class BoomBoomClient(EventListener):
     """ The main class of the client of BoomBoom.
@@ -41,18 +43,24 @@
         EventListener.__init__(self, prefix="evt_")
         
         self.display = display
+        if not arg.get("textmode", False):
+            from bb_input_pygame import BoomBoomInput
+        else:
+            log.use_print = False
+            log.on_new_message = curses_tools.onLogMessage
+            curses_tools.window = arg["window"]
+            from bb_input_curses import BoomBoomInput
         self.input = BoomBoomInput(arg)
         self.__verbose = arg.get("verbose", False)
         self.__stopped = False
         self.__stoplock = thread.allocate_lock()
-        
+        self.args = arg        
         self.registerEvent("game")
         
     def start(self):
         """ Starts the game client."""
-        if self.__verbose: print "[CLIENT] Starting client..."
-        # Start pygame
-        pygame.init()
+        if self.__verbose:
+            log.info("[CLIENT] Starting client...")
         
         # Create thread for input and display
         thread.start_new_thread(self.thread_display, ())
@@ -73,7 +81,8 @@
         self.__stopped = True
         self.__stoplock.release()
         
-        if self.__verbose: print "[CLIENT] Stopping client..."
+        if self.__verbose:
+            log.info("[CLIENT] Stopping client...")
         self.display.stop()
     
     def evt_game_stop(self):
@@ -88,22 +97,14 @@
         try:
             self.display.start()
         except Exception, msg:
-            print "EXCEPTION IN DISPLAY THREAD:\n%s" % msg
-            traceback.print_exc()
+            bt = getBacktrace()
+            log.error("EXCEPTION IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))
         try:
             self.stop()
         except Exception, msg:
-            print "EXCEPTION IN DISPLAY THREAD:\n%s" % msg
-            traceback.print_exc()
+            bt = getBacktrace()
+            log.error("EXCEPTION (2) IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))
         
-    def thread_input(self):
-        """ Thread handler for the "input" part."""
-        try:
-            self.input.start()
-        except:
-            traceback.print_exc()
-        self.stop()
-
     def __isStopped(self):
         self.__stoplock.acquire()
         stop = self.__stopped

Modified: boomboom/client/bb_constructor.py
===================================================================
--- boomboom/client/bb_constructor.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_constructor.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -7,7 +7,6 @@
 from happyboom.common.event import EventListener
 from happyboom.common.log import log
 import bb_events
-from items import Sun, Projectile, Weapon, World, Character, LogItem
 
 class BoomBoomConstructor(EventListener):
     """ Constructs visual items when server requires creation. """
@@ -17,6 +16,8 @@
         self.verbose = arg.get("verbose", False)
         self.registerEvent("happyboom")
         self.registerEvent("game")
+        self.textmode = arg["textmode"]
+        self.args = arg
         
     def evt_happyboom_doCreateItem(self, type, id):
         """ Create event handler.
@@ -26,22 +27,41 @@
         if self.verbose:
             log.info("Try to create object %s ..." % type)
         if type=="projectile":
-            Projectile()
+            if self.textmode:
+                from items.projectile_curses import Projectile
+            else:
+                from items.projectile import Projectile
+            Projectile(self.args)
         if type=="weapon":
-            Weapon()
+            if self.textmode:
+                from items.weapon_curses import Weapon 
+            else:
+                from items.weapon import Weapon
+            Weapon(self.args)
         if type=="log":
+            from items import LogItem
             LogItem()
         if type=="world":
-            World()
+            if self.textmode:
+                from items.world_curses import World
+            else:
+                from items.world import World
+            World(self.args)
         if type=="character":
-            Character(id, "foo")
+            if self.textmode:
+                from items.character_curses import Character
+            else:
+                from items.character import Character
+            Character(id, "foo", self.args)
         
     def evt_game_start(self):
         """ Start event handler.
         @param event: Event with "game_Start" type.
         @type event: C{L{common.event.Event}}
         """
-        Sun()
+        if not self.textmode:
+            from items import Sun
+            Sun()
         
     def evt_agent_manager_Text(self, event):
         """ Text event handler.

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_display.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -9,7 +9,6 @@
 from happyboom.client.base_client import Client as BaseClient
 from happyboom.common.event import EventListener
 import bb_events
-from bb_drawer import BoomBoomDrawer
 from bb_constructor import BoomBoomConstructor
 from happyboom.net.io import Packet
 
@@ -44,8 +43,13 @@
 
         EventListener.__init__(self)
         BaseClient.__init__(self, arg)
-        self.drawer = BoomBoomDrawer(arg.get("max_fps", 25))
+        if arg["textmode"]:
+            from bb_drawer_curses import BoomBoomDrawer
+        else:
+            from bb_drawer import BoomBoomDrawer
+        self.drawer = BoomBoomDrawer(arg)
         self.name = arg.get("name", "no name")
+        self.args = arg
         #TODO: Support chat?
         self.gateway.features = ["game", "character", "projectile", "weapon", "world"]
 #        if arg.get("server-log", False):
@@ -57,11 +61,10 @@
 
     def start(self):
         """ Starts the display client : connection to the server, etc. """
-        print "==== BoomBoom ===="
+        log.info("==== BoomBoom ====")
         self.drawer.start()
         BaseClient.start(self)
-        args = {"verbose": self.verbose}
-        BoomBoomConstructor(args)
+        BoomBoomConstructor(self.args)
         self.drawer.mainLoop()
         
     def stop(self):

Modified: boomboom/client/bb_drawer.py
===================================================================
--- boomboom/client/bb_drawer.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_drawer.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -18,7 +18,7 @@
     @type __items: C{list<L{BoomBoomItem}>}
     """
     
-    def __init__(self, max_fps=25):
+    def __init__(self, args):
         """ BoomBoomDrawer constructor.
         @param max_fps: Maximal number of frames per second, for optimization.
         @type max_fps: C{int}
@@ -26,6 +26,7 @@
         EventListener.__init__(self, prefix="evt_")
         # Current offscreen
         self.__screen = None
+        max_fps = args.get("max_fps", 25)
         self.__frameTime = 1.0 / max_fps
         self.__items = []
         self.registerEvent("graphical")

Added: boomboom/client/bb_drawer_curses.py
===================================================================
--- boomboom/client/bb_drawer_curses.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_drawer_curses.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,58 @@
+from happyboom.common.event import EventListener
+import bb_events
+import curses, time
+
+class BoomBoomDrawer(EventListener):
+    """ Manages the drawing of the screen game (double buffered) in a display loop.
+    @ivar __screen: Current drawed offscreen.
+    @type __screen: C{{Window}}
+    @ivar __frameTime: Minimum time to draw a frame.
+    @type __frameTime: C{float}
+    @ivar __items: Objects which have graphical content to draw (visual items) genered by visible item events.
+    @type __items: C{list<L{BoomBoomItem}>}
+    """
+    
+    def __init__(self, args):
+        """ BoomBoomDrawer constructor.
+        @param max_fps: Maximal number of frames per second, for optimization.
+        @type max_fps: C{int}
+        """
+        EventListener.__init__(self, prefix="evt_")
+        # Current offscreen
+        self.__screen = None
+        max_fps = args.get("max_fps", 25)
+        self.__frameTime = 1.0 / max_fps
+        self.__items = []
+        self.registerEvent("graphical")
+        self.window = args["window"]
+    
+    def start(self):
+        pass
+        
+    def mainLoop(self):
+        """ Display loop. """
+        while True:
+            live_begin = time.time()
+            
+            # Clearing screen
+            self.window.clear()
+
+            # Drawing each items
+            for item in self.__items:
+                item.draw()
+
+            # Displaying offscreen 
+            self.window.refresh()
+            
+            delay = time.time() - live_begin
+            if delay < self.__frameTime:
+                delay = self.__frameTime - delay
+                time.sleep(delay)
+        
+    def evt_graphical_item(self, item):
+        """ active item event handler.
+        @param event: Event with "graphical_item" type.
+        @type event: C{L{common.simple_event.Event}}
+        """
+        if item not in self.__items:
+            self.__items.append(item)

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_input.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -9,7 +9,7 @@
 from net import io
 from net import io_udp, io_tcp
 from net import net_buffer
-import thread, time, pygame
+import thread, time
 
 class BoomBoomInput(EventLauncher, EventListener):
     """ Class which manages "input" part of the network connections.
@@ -60,27 +60,6 @@
         
     def evt_weapon_setAngle(self, angle):
         self.weapon_angle = angle
-        
-    def process(self):
-        for input_event in pygame.event.get():
-            self.process_event(input_event)
-           
-    def process_event(self, event):
-        """ Manages when a pygame event is caught.
-        @param event: Pygame event.
-        @type event: C{pygame.Event}
-        """
-        if event.type == pygame.KEYDOWN: 
-            # q, Q or escape: quit
-            if event.unicode in (u'q', u'Q') or event.key == 27:
-                self.launchEvent("game", "stop")
-        # Quit event: quit
-        elif event.type in (pygame.QUIT, ):
-            self.launchEvent("game", "stop")
-    
-        #character = self.client.view.getActiveCharacter()
-        #if character != None: self.process_event_active(character, event)
-        self.process_event_active(event)
 
     def weapon_setStrengthDelta(self, delta):
         self.launchEvent("happyboom", "network", \
@@ -90,21 +69,5 @@
         self.launchEvent("happyboom", "network", \
             "weapon", "askSetAngle", self.weapon_angle + delta)
 
-    def process_event_active(self, event):
-        """ Manages when a pygame event is caught and interact with the server.
-        @param event: Pygame event.
-        @type event: C{pygame.Event}
-        """
-        #delta_angle = -30
-        if event.type == pygame.KEYDOWN: 
-            # arrow keys: move character
-            if event.key == 32:
-                self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
-            elif event.key == 275:
-                self.weapon_setStrengthDelta(10) # RIGHT 
-            elif event.key == 273:
-                self.weapon_setAngleDelta(10) # UP
-            elif event.key == 274:
-                self.weapon_setAngleDelta(-10) # DOWN
-            elif event.key == 276:
-                self.weapon_setStrengthDelta(-10) # LEFT
+    def process(self):
+        pass

Added: boomboom/client/bb_input_curses.py
===================================================================
--- boomboom/client/bb_input_curses.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_input_curses.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,30 @@
+from client.bb_input import BoomBoomInput as BaseInput
+import curses
+                
+class BoomBoomInput(BaseInput):
+    def __init__(self, arg):
+        BaseInput.__init__(self, arg)
+        self.window = arg["window"]
+
+    def process(self):
+        self.window.nodelay(True)
+        key = self.window.getch()
+        self.process_key(key)
+           
+    def process_key(self, key):
+        if key == -1: return
+        keyname = curses.keyname(key)
+        if keyname in ('q', 'Q'):
+            self.launchEvent("game", "stop")
+#            return
+    
+        if key == 32: # space
+            self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
+        elif key == curses.KEY_RIGHT:
+            self.weapon_setStrengthDelta(10)
+        elif key == curses.KEY_UP:
+            self.weapon_setAngleDelta(10)
+        elif key == curses.KEY_DOWN:
+            self.weapon_setAngleDelta(-10)
+        elif key == curses.KEY_LEFT:
+            self.weapon_setStrengthDelta(-10)

Added: boomboom/client/bb_input_pygame.py
===================================================================
--- boomboom/client/bb_input_pygame.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/bb_input_pygame.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,47 @@
+from client.bb_input import BoomBoomInput as BaseInput
+import pygame                
+
+class BoomBoomInput(BaseInput):
+    def __init__(self, arg):
+        BaseInput.__init__(self, arg)
+#        import pygame
+
+    def process(self):
+        for input_event in pygame.event.get():
+            self.process_event(input_event)
+           
+    def process_event(self, event):
+        """ Manages when a pygame event is caught.
+        @param event: Pygame event.
+        @type event: C{pygame.Event}
+        """
+        if event.type == pygame.KEYDOWN: 
+            # q, Q or escape: quit
+            if event.unicode in (u'q', u'Q') or event.key == 27:
+                self.launchEvent("game", "stop")
+        # Quit event: quit
+        elif event.type in (pygame.QUIT, ):
+            self.launchEvent("game", "stop")
+    
+        #character = self.client.view.getActiveCharacter()
+        #if character != None: self.process_event_active(character, event)
+        self.process_event_active(event)
+
+    def process_event_active(self, event):
+        """ Manages when a pygame event is caught and interact with the server.
+        @param event: Pygame event.
+        @type event: C{pygame.Event}
+        """
+        #delta_angle = -30
+        if event.type == pygame.KEYDOWN: 
+            # arrow keys: move character
+            if event.key == 32:
+                self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
+            elif event.key == 275:
+                self.weapon_setStrengthDelta(10) # RIGHT 
+            elif event.key == 273:
+                self.weapon_setAngleDelta(10) # UP
+            elif event.key == 274:
+                self.weapon_setAngleDelta(-10) # DOWN
+            elif event.key == 276:
+                self.weapon_setStrengthDelta(-10) # LEFT

Added: boomboom/client/curses_tools.py
===================================================================
--- boomboom/client/curses_tools.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/curses_tools.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,13 @@
+import curses
+
+def convertXY(x, y):
+    global window
+    maxy, maxx = window.getmaxyx()
+    x = int(x * maxx / 640)
+    y = int(y * maxy / 350)
+    return x, y
+
+def onLogMessage(level, prefix, message):
+    window.addstr(message+"\n")
+
+window = None

Modified: boomboom/client/items/character.py
===================================================================
--- boomboom/client/items/character.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/character.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -22,7 +22,7 @@
     @ivar __name: Name of the player controlling the character (as known by the server).
     @type __name: C{str}
     """
-    def __init__(self, id, name):
+    def __init__(self, id, name, args):
         """ Character item constructor.
         @param id:  Server item id.
         @type id: C{int}
@@ -47,8 +47,6 @@
         self.__x = x
         self.__y = y
         self.visual.move(self.__x, self.__y)
-        if self.active:
-            self.launchEvent(bb_events.activeCharAbs, self.__x)
         
     def evt_game_active_character(self, event):
         """ Active character event handler.

Added: boomboom/client/items/character_curses.py
===================================================================
--- boomboom/client/items/character_curses.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/character_curses.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,20 @@
+from client.bb_item import BoomBoomItem
+from client.curses_tools import convertXY
+
+class Character(BoomBoomItem):
+    def __init__(self, id, name, args):
+        BoomBoomItem.__init__(self)
+        self.x, self.y = None, None
+        self.__id = id
+        self.__name = name
+        self.active = False
+        self.registerEvent("character")
+        self.window = args["window"]
+        
+    def evt_character_move(self, id, x, y):
+        if self.__id != id: return
+        self.x, self.y = convertXY(x, y)
+        
+    def draw(self):
+        if self.x == None: return
+        self.window.addstr(self.y, self.x, "Gorilla")

Added: boomboom/client/items/log.py
===================================================================
--- boomboom/client/items/log.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/log.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,15 @@
+from client.bb_item import BoomBoomItem
+
+class LogItem(BoomBoomItem):
+    def __init__(self):
+        BoomBoomItem.__init__(self)
+        self.registerEvent("log")
+        
+    def evt_log_info(self, text):
+        log.info(u"[Server Log][info] %s" % text)
+        
+    def evt_log_warning(self, text):
+        log.info(u"[Server Log][warn] %s" % text)
+        
+    def evt_log_error(self, text):
+        log.info(u"[Server Log][err!] %s" % text)

Modified: boomboom/client/items/projectile.py
===================================================================
--- boomboom/client/items/projectile.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/projectile.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client import bb_events
+#from client import bb_events
 from client.bb_item import BoomBoomItem, VisualObject
 import os.path
 
@@ -14,7 +14,7 @@
     @type visual: C{L{VisualObject}}
     """
     
-    def __init__(self):
+    def __init__(self, args):
         """ Projectile itemp constructor. """
         BoomBoomItem.__init__(self)
         self.visual = VisualObject(os.path.join("data", "banana.png"))

Added: boomboom/client/items/projectile_curses.py
===================================================================
--- boomboom/client/items/projectile_curses.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/projectile_curses.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,40 @@
+"""
+ at author: Victor Stinner and Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 0.2
+"""
+from client.bb_item import BoomBoomItem
+from client.curses_tools import convertXY
+import curses
+
+class Projectile(BoomBoomItem):
+    """ Represents a banana projectile launch by the monkey.
+    @ivar visual: Graphical object containing data and transformations
+    @type visual: C{L{VisualObject}}
+    """
+    
+    def __init__(self, args):
+        """ Projectile itemp constructor. """
+        BoomBoomItem.__init__(self)
+        self.registerEvent("projectile")
+        self.window = args["window"]
+        self.x, self.y = 10,10
+        self.display = False
+
+    def draw(self):
+        if not self.display: return
+        maxy, maxx = self.window.getmaxyx()
+        if self.x < 0 or maxx < self.x: return
+        if self.y < 0 or maxy < self.y: return
+        self.window.addstr(self.y,self.x,"*")
+        
+    def evt_projectile_move(self, x, y):
+        height,width = self.window.getmaxyx()
+        self.x, self.y = convertXY(x, y)
+        
+#    def evt_projectile_hitGround(self, x, y):
+#        pass
+        
+    def evt_projectile_activate(self, state):
+        self.display = state

Added: boomboom/client/items/projectile_pygame.py
===================================================================
--- boomboom/client/items/projectile_pygame.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/projectile_pygame.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,8 @@
+from client.bb_item import VisualObject
+import os.path
+from projectile import Projectile as Base
+
+class Projectile(Base):
+    def __init__(self):
+        Base.__init__(self)
+        self.visual = VisualObject(os.path.join("data", "banana.png"))

Modified: boomboom/client/items/weapon.py
===================================================================
--- boomboom/client/items/weapon.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/weapon.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -4,7 +4,6 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client import bb_events
 from client.bb_item import BoomBoomItem
 import pygame
 
@@ -25,7 +24,7 @@
     @ivar __y: Item ordonnee.
     @type __y: C{int}
     """
-    def __init__(self):
+    def __init__(self, args):
         """ Weapon item constructor. """
         BoomBoomItem.__init__(self)
         self.__angle = None 

Added: boomboom/client/items/weapon_curses.py
===================================================================
--- boomboom/client/items/weapon_curses.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/weapon_curses.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,74 @@
+"""
+ at author: Victor Stinner and Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 0.2
+"""
+from client.bb_item import BoomBoomItem
+import curses 
+from client.curses_tools import convertXY
+
+class Weapon(BoomBoomItem):
+    def __init__(self, args):
+        """ Weapon item constructor. """
+        BoomBoomItem.__init__(self)
+        self.__angle = None 
+        self.__strength = None
+        self.x, self.y = (None, 10)
+        self.character_pos = {}
+        self.window = args["window"]
+        self.active_character = None
+        self.registerEvent("weapon")
+        self.registerEvent("character")
+        self.registerEvent("game")
+
+    def evt_weapon_setStrength(self, strength):
+        """ Weapon strength event handler.
+        @param event: Event with "weapon_force" type.
+        @type event: C{L{common.simple_event.Event}}
+        """
+        self.__strength = strength
+        
+    def evt_weapon_setAngle(self, angle):
+        """ Weapon angle event handler.
+        @param event: Event with "weapon_angle" type.
+        @type event: C{L{common.simple_event.Event}}
+        """
+        self.__angle = angle 
+
+    def evt_character_move(self, id, x, y):
+        self.character_pos[id] = (x, y,)
+        self.updateXY()
+        
+    def evt_game_setActiveCharacter(self, id):
+        """ Active character abcsisse event handler.
+        @param event: Event with "active_character_abscisse" type.
+        @type event: C{L{common.simple_event.Event}}
+        """
+        self.active_character = id
+        self.updateXY()
+               
+    def draw(self):
+        """ Drawing method called by C{BoomBoomDrawer}
+        @param screen: Offscreen to draw in.
+        @type screen: C{L{Window<bb_drawer.Window>}}
+        """
+        if self.__angle == None: return
+        if self.__strength == None: return
+        if self.x == None: return
+        txt = "Angle: %s" % self.__angle
+        self.window.addstr(self.y, self.x, txt)
+        txt = "Strength: %s" % self.__strength
+        self.window.addstr(self.y+1, self.x, txt)
+
+    def updateXY(self):
+        if self.active_character==None: return
+        pos = self.character_pos.get(self.active_character, None)
+        if pos == None: return
+        x, y = convertXY(pos[0], pos[1])
+        maxy,maxx = self.window.getmaxyx()
+        if x < maxx/2:
+            self.x = 1
+        else:
+            self.x = maxx - 20
+        self.y = 1

Modified: boomboom/client/items/world.py
===================================================================
--- boomboom/client/items/world.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/world.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -37,14 +37,13 @@
         @type screen: C{L{Window<bb_drawer.Window>}}
         """
         screen.surface.fill(self.color, self.rect)
-
-
+        
 class World(BoomBoomItem):
     """ Represents the ground of the game (collection of buildings).
     @ivar __buildings: Collection of buildings.
     @type __buildings: C{list<L{Building}>}
     """
-    def __init__(self):
+    def __init__(self, args):
         """ World item constructor. """
         BoomBoomItem.__init__(self)
         self.__buildings = []

Added: boomboom/client/items/world_curses.py
===================================================================
--- boomboom/client/items/world_curses.py	2005-09-17 03:24:01 UTC (rev 185)
+++ boomboom/client/items/world_curses.py	2005-09-17 03:26:37 UTC (rev 186)
@@ -0,0 +1,70 @@
+from client.bb_item import BoomBoomItem
+from client.curses_tools import convertXY
+
+class Building:
+    """ Represents a building which is used as plat-form in the game.
+    @ivar rect: Representation of the building.
+    @type rect: C{pygame.Rect}
+    @ivar color: Random color tuple of the building (Red, Green, Blue, Alpha).
+    @type color: C{(int, int, int, int)}
+    """
+    def __init__(self, x, y, width, height):
+        """ Building constructor.
+        @param x: Building left abscisse.
+        @type x: C{int}
+        @param y: Building top ordonnee.
+        @type y: C{int}
+        @param width: Buiding width.
+        @type width: C{int}
+        @param height: Building height.
+        @type height: C{int}
+        """
+        self.x, self.y = x,y
+        self.width, self.height = width, height
+#        self.color = None # TODO: Choose color 
+
+    def draw(self, win):
+        """ Drawing method called by C{BoomBoomDrawer}
+        @param screen: Offscreen to draw in.
+        @type screen: C{L{Window<bb_drawer.Window>}}
+        """
+        for y in range(self.y, self.y+self.height):
+            win.addstr(y, self.x, "#" * self.width)
+        
+class World(BoomBoomItem):
+    """ Represents the ground of the game (collection of buildings).
+    @ivar __buildings: Collection of buildings.
+    @type __buildings: C{list<L{Building}>}
+    """
+    def __init__(self, args):
+        """ World item constructor. """
+        BoomBoomItem.__init__(self)
+        self.__buildings = []
+        self.registerEvent("world")
+        self.window = args["window"]
+
+    def born(self):
+        Agent.born(self)
+        self.registerAction("world")
+
+    def evt_world_create(self, data):
+        """ World create event handler.
+        @param event: Event with "world_create" type.
+        @type event: C{L{common.simple_event.Event}}
+        """
+        self.__buildings = []
+        rects = data.split(";")
+        maxy, maxx = self.window.getmaxyx()
+        for rect in rects:
+            x, y, w, h = rect.split(",")
+            x, y = convertXY(int(x), int(y))
+            w, h = convertXY(int(w), int(h))
+            b = Building(x, y, w, h)
+            self.__buildings.append(b)
+
+    def draw(self):
+        """ Drawing method called by C{BoomBoomDrawer}
+        @param screen: Offscreen to draw in.
+        @type screen: C{L{Window<bb_drawer.Window>}}
+        """
+        for b in self.__buildings: b.draw(self.window)



From haypo at berlios.de  Sat Sep 17 05:34:06 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 17 Sep 2005 05:34:06 +0200
Subject: [Happyboom-svn] r187 - happyboom/trunk/net/io_tcp
Message-ID: <200509170334.j8H3Y6Ww028230@sheep.berlios.de>

Author: haypo
Date: 2005-09-17 05:34:03 +0200 (Sat, 17 Sep 2005)
New Revision: 187

Modified:
   happyboom/trunk/net/io_tcp/tcp_client.py
Log:
Corrige l'envoi de donnee a un client qui s'est deconnecte pour TCP_Client


Modified: happyboom/trunk/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-17 03:26:37 UTC (rev 186)
+++ happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-17 03:34:03 UTC (rev 187)
@@ -28,7 +28,14 @@
         @type data: str
         """
         if not self.connected: return
-        self.__socket.send(data)
+        try:
+            self.__socket.send(data)
+        except SocketError, err:
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
 
         # Call user event if needed
         if self.on_send != None: self.on_send(data)



From dboucard at berlios.de  Sun Sep 18 07:38:01 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:38:01 +0200
Subject: [Happyboom-svn] r188 - in boomboom/client: . items
Message-ID: <200509180538.j8I5c17c013484@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:37:58 +0200 (Sun, 18 Sep 2005)
New Revision: 188

Added:
   boomboom/client/client.py
Removed:
   boomboom/client/bb_client.py
Modified:
   boomboom/client/__init__.py
   boomboom/client/bb_display.py
   boomboom/client/bb_input.py
   boomboom/client/bb_input_pygame.py
   boomboom/client/bb_item.py
   boomboom/client/items/character.py
   boomboom/client/items/log.py
   boomboom/client/items/projectile.py
   boomboom/client/items/sun.py
   boomboom/client/items/weapon.py
   boomboom/client/items/world.py
Log:
cleaning boomboom client code


Modified: boomboom/client/__init__.py
===================================================================
--- boomboom/client/__init__.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/__init__.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -1,8 +1,5 @@
-from bb_client import BoomBoomClient
-from bb_display import BoomBoomDisplay
-from bb_input import BoomBoomInput
-from bb_drawer import BoomBoomDrawer
-from bb_constructor import BoomBoomConstructor
-from bb_item import BoomBoomItem
-import bb_events
-import items
\ No newline at end of file
+from client import Client
+from display import Display
+from input import Input
+from item import Item
+import items

Deleted: boomboom/client/bb_client.py
===================================================================
--- boomboom/client/bb_client.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/bb_client.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -1,113 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from happyboom.common.event import EventListener
-from happyboom.common.log import log
-from happyboom.common.thread import getBacktrace
-import bb_events
-import thread, time, traceback
-import curses_tools
-
-class BoomBoomClient(EventListener):
-    """ The main class of the client of BoomBoom.
-    @ivar display: Display manager of the game.
-    @type display: C{L{BoomBoomDisplay}}
-    @ivar input: Input manager of the game.
-    @type input: C{L{BoomBoomInput}}
-    @ivar __verbose: Verbose mode flag.
-    @type __verbose: C{bool}
-    @ivar __stopped: Stopped game flag.
-    @type __stopped: C{bool}
-    @ivar __stoplock: Mutex for synchronizing __stopped.
-    @type __stoplock: C{thread.lock}
-    """
-    
-    def __init__(self, display, arg):
-        """ BoomBoomClient constructor.
-        @param host: Server hostname.
-        @type host: C{str}
-        @param display_port: Server port for "display"/"view" connection.
-        @type display_port: C{int}
-        @param input_port: Server port for "input" connection.
-        @type input_port: C{int}
-        @param verbose: Verbose mode flag.
-        @type verbose: C{bool}
-        @param debug: Debug mode flag.
-        @type debug: C{bool}
-        @param max_fps: Maximal number of frames per second, for optimization.
-        @type max_fps: C{int}
-        """
-        EventListener.__init__(self, prefix="evt_")
-        
-        self.display = display
-        if not arg.get("textmode", False):
-            from bb_input_pygame import BoomBoomInput
-        else:
-            log.use_print = False
-            log.on_new_message = curses_tools.onLogMessage
-            curses_tools.window = arg["window"]
-            from bb_input_curses import BoomBoomInput
-        self.input = BoomBoomInput(arg)
-        self.__verbose = arg.get("verbose", False)
-        self.__stopped = False
-        self.__stoplock = thread.allocate_lock()
-        self.args = arg        
-        self.registerEvent("game")
-        
-    def start(self):
-        """ Starts the game client."""
-        if self.__verbose:
-            log.info("[CLIENT] Starting client...")
-        
-        # Create thread for input and display
-        thread.start_new_thread(self.thread_display, ())
-
-        quit = False
-        while not quit:
-            self.input.process()
-            time.sleep(0.100)
-            quit = self.is_stopped
-        
-    def stop(self):
-        """  Stops the game client."""
-        # Does not stop several times
-        self.__stoplock.acquire()
-        if self.__stopped:
-            self.__stoplock.release()
-            return
-        self.__stopped = True
-        self.__stoplock.release()
-        
-        if self.__verbose:
-            log.info("[CLIENT] Stopping client...")
-        self.display.stop()
-    
-    def evt_game_stop(self):
-        """ Stop event handler.
-        @param event: Event game.stop()
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.stop()
-    
-    def thread_display(self):
-        """ Thread handler for the "display" part."""
-        try:
-            self.display.start()
-        except Exception, msg:
-            bt = getBacktrace()
-            log.error("EXCEPTION IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))
-        try:
-            self.stop()
-        except Exception, msg:
-            bt = getBacktrace()
-            log.error("EXCEPTION (2) IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))
-        
-    def __isStopped(self):
-        self.__stoplock.acquire()
-        stop = self.__stopped
-        self.__stoplock.release()
-        return stop
-    is_stopped = property(__isStopped)

Modified: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/bb_display.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -6,13 +6,10 @@
 """
 from happyboom.common.happyboom_protocol import HappyboomProtocol as Presentation
 from happyboom.common.log import log
-from happyboom.client.base_client import Client as BaseClient
 from happyboom.common.event import EventListener
-import bb_events
-from bb_constructor import BoomBoomConstructor
-from happyboom.net.io import Packet
+import thread, pygame, time
 
-class BoomBoomDisplay(BaseClient, EventListener):
+class Display(EventListener):
     """ Class which manages "display" part of the network connections.
     Also creates a drawer and a constuctor for "display" management.
     @ivar drawer: instance which draws screen game.
@@ -25,7 +22,7 @@
     @type name: C{str}
     """
     
-    def __init__(self, arg):
+    def __init__(self, args):
         """ BoomBoomDisplay constructor.
         @param host: Server hostname.
         @type host: C{str}
@@ -42,45 +39,99 @@
         """
 
         EventListener.__init__(self)
-        BaseClient.__init__(self, arg)
-        if arg["textmode"]:
-            from bb_drawer_curses import BoomBoomDrawer
-        else:
-            from bb_drawer import BoomBoomDrawer
-        self.drawer = BoomBoomDrawer(arg)
-        self.name = arg.get("name", "no name")
-        self.args = arg
-        #TODO: Support chat?
-        self.gateway.features = ["game", "character", "projectile", "weapon", "world"]
-#        if arg.get("server-log", False):
-#            self.gateway.features.append("log")
-        self.registerEvent("happyboom")
+        self.registerEvent("graphical")
+        # Current offscreen
+        self._screen = None
+        max_fps = args.get("max_fps", 25)
+        self._frameTime = 1.0 / max_fps
+        self._items = []
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
 
-    def evt_happyboom_netSendMsg(self, feature, event, *args):
-        self.send(feature, event, *args)
-
     def start(self):
-        """ Starts the display client : connection to the server, etc. """
-        log.info("==== BoomBoom ====")
-        self.drawer.start()
-        BaseClient.start(self)
-        BoomBoomConstructor(self.args)
-        self.drawer.mainLoop()
+        """ Creates game window and starts display loop. """
+        self._screen = Window(640, 350)
+        self._screen.background_color = (0, 0, 168)
+        self.mainLoop()
         
     def stop(self):
-        """ Stops the display client : disconnection from the server, etc. """
-        if not BaseClient.stop(self): return
-        self.launchEvent("happyboom", "disconnection", self._io, u"Quit.")
-        self._io.stop()
-        if self.verbose: print "[CLIENT] Stopped"
+        """ Stops the display loop. """
+        # Does not stop several times
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return False
+        self.__stopped = True
+        self.__stoplock.release()
+        
+    def mainLoop(self):
+        """ Display loop. """
+        while not self.stopped:
+            live_begin = time.time()
+            
+            # Clearing screen
+            self._screen.surface.fill(self._screen.background_color)
+            # Drawing each items
+            if len(self._items) == 0:
+                fontname = pygame.font.get_default_font()
+                font = pygame.font.SysFont(fontname, 64)
+                font_color = (255,255,0,255)
+                #font_background = (0,0,0,0)
+                surface = font.render(" Not connected to server...", True, font_color)
+                self._screen.blit(surface, (0,0))
+            for item in self._items:
+                item.draw(self._screen)
+            # Displaying offscreen
+            pygame.display.flip()
+            
+            delay = time.time() - live_begin
+            if delay < self._frameTime:
+                delay = self._frameTime - delay
+                time.sleep(delay)
+        
+    def evt_graphical_item(self, item):
+        """ active item event handler.
+        @param event: Event with "graphical_item" type.
+        @type event: C{L{common.simple_event.Event}}
+        """
+        if item not in self._items:
+            self._items.append(item)
+    
+    def __isStopped(self):
+        self.__stoplock.acquire()
+        stop = self.__stopped
+        self.__stoplock.release()
+        return stop
+    stopped = property(__isStopped)
+        
+class Window:
+    """ Represents a GUI window or surface using pygame.
+    @ivar type: Type of pygame surface : "window" or "surface" (panel into another window).
+    @type type: C{str}
+    @ivar surface: pygame surface object.
+    @type surface: C{pygame.Surface}
+    """
+    def __init__(self, width, height, type="window"):
+        """ Window constructor.
+        @param width: Width of the window.
+        @type width: C{int}
+        @param height: Height of the window.
+        @type height: C{int}
+        @param type: Type of pygame surface : "window" (by default) or "surface".
+        @type type: C{str}
+        """
+        if type=="surface":
+            self.type = "surface" 
+            self.surface = pygame.Surface((width,height))
+        else:
+            self.type = "window"
+            self.surface = pygame.display.set_mode((width,height), pygame.HWSURFACE | pygame.DOUBLEBUF)
+        self.pos = (0,0)
+        self.view_pos = (0,0)
+        self.scale = 1
+        self.border_color = (255, 255, 255)
+        self.background_color = (0, 0, 0)
 
-# Wass used for stats
-#    def setIoSendReceive(self, on_send, on_receive):
-#        """ Set new handler functions for I/O network.
-#        @param on_send: Handler called for sending data.
-#        @type C{function}
-#        @param on_receive: Handler called for receiving data.
-#        @type C{function}
-#        """
-#        self._io.on_send = on_send
-#        self._io.on_receive = on_receive
+    def blit(self, surface, pos):
+        new_pos = (pos[0] - self.view_pos[0], pos[1] - self.view_pos[1],)
+        self.surface.blit(surface, new_pos)
\ No newline at end of file

Modified: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/bb_input.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -5,13 +5,9 @@
 @version: 0.2
 """
 from happyboom.common.event import EventLauncher, EventListener
-import bb_events
-from net import io
-from net import io_udp, io_tcp
-from net import net_buffer
 import thread, time
 
-class BoomBoomInput(EventLauncher, EventListener):
+class Input(EventLauncher, EventListener):
     """ Class which manages "input" part of the network connections.
     @ivar host: Server hostname.
     @type host: C{str}

Modified: boomboom/client/bb_input_pygame.py
===================================================================
--- boomboom/client/bb_input_pygame.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/bb_input_pygame.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -1,7 +1,7 @@
-from client.bb_input import BoomBoomInput as BaseInput
+from generic_input import Input as BaseInput
 import pygame                
 
-class BoomBoomInput(BaseInput):
+class Input(BaseInput):
     def __init__(self, arg):
         BaseInput.__init__(self, arg)
 #        import pygame
@@ -18,10 +18,10 @@
         if event.type == pygame.KEYDOWN: 
             # q, Q or escape: quit
             if event.unicode in (u'q', u'Q') or event.key == 27:
-                self.launchEvent("game", "stop")
+                self.launchEvent("happyboom", "stop")
         # Quit event: quit
         elif event.type in (pygame.QUIT, ):
-            self.launchEvent("game", "stop")
+            self.launchEvent("happyboom", "stop")
     
         #character = self.client.view.getActiveCharacter()
         #if character != None: self.process_event_active(character, event)
@@ -36,7 +36,7 @@
         if event.type == pygame.KEYDOWN: 
             # arrow keys: move character
             if event.key == 32:
-                self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
+                self.launchEvent("happyboom", "network", "weapon", "shoot")
             elif event.key == 275:
                 self.weapon_setStrengthDelta(10) # RIGHT 
             elif event.key == 273:

Modified: boomboom/client/bb_item.py
===================================================================
--- boomboom/client/bb_item.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/bb_item.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -5,21 +5,23 @@
 @version: 0.2
 """
 from happyboom.common.event import EventListener, EventLauncher
-import bb_events
 import pygame
 
-class BoomBoomItem(EventListener, EventLauncher):
+class Item(EventListener, EventLauncher):
     """ Generic class for representing graphical items.
     @ivar visual: Graphical object containing data and transformations
     @type visual: C{L{VisualObject}}
     """
     
-    def __init__(self):
+    feature = None
+    
+    def __init__(self, id=None):
         """ BoomBoomItem constructor. """
         EventListener.__init__(self, "evt_")
         EventLauncher.__init__(self)
         self.visual = None
         self.launchEvent("graphical", "item", self)
+        self.id = id
         
     def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}

Copied: boomboom/client/client.py (from rev 187, boomboom/client/bb_client.py)
===================================================================
--- boomboom/client/bb_client.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/client.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -0,0 +1,95 @@
+"""
+ at author: Victor Stinner and Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 0.2
+"""
+from happyboom.common.event import EventListener
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+from happyboom.common import protocol
+from happyboom.client.base_client import Client as Happyboom
+from display import Display
+from input import Input
+import thread, time
+import curses_tools
+
+class Client(Happyboom, EventListener):
+    """ The main class of the client of BoomBoom.
+    @ivar display: Display manager of the game.
+    @type display: C{L{BoomBoomDisplay}}
+    @ivar input: Input manager of the game.
+    @type input: C{L{BoomBoomInput}}
+    @ivar __verbose: Verbose mode flag.
+    @type __verbose: C{bool}
+    @ivar __stopped: Stopped game flag.
+    @type __stopped: C{bool}
+    @ivar __stoplock: Mutex for synchronizing __stopped.
+    @type __stoplock: C{thread.lock}
+    """
+    
+    def __init__(self, args):
+        """ BoomBoomClient constructor.
+        @param host: Server hostname.
+        @type host: C{str}
+        @param display_port: Server port for "display"/"view" connection.
+        @type display_port: C{int}
+        @param input_port: Server port for "input" connection.
+        @type input_port: C{int}
+        @param verbose: Verbose mode flag.
+        @type verbose: C{bool}
+        @param debug: Debug mode flag.
+        @type debug: C{bool}
+        @param max_fps: Maximal number of frames per second, for optimization.
+        @type max_fps: C{int}
+        """
+        args["protocol"] = protocol.loadProtocol("protocol.xml")
+        args["features"] = ["game"] # Constant features
+        
+        Happyboom.__init__(self, args)
+        EventListener.__init__(self, prefix="evt_")
+        
+        self.display = Display(args)
+        self.input = Input(args)
+        self.__verbose = args.get("verbose", False)
+        self.registerEvent("happyboom")
+        
+    def start(self):
+        """ Starts the game client."""
+        if self.__verbose:
+            log.info("[BOOMBOOM] Starting client...")
+        Happyboom.start(self)
+        # Create thread for display
+        thread.start_new_thread(self.displayThread, ())
+        
+        quit = False
+        while not quit:
+            self.input.process()
+            time.sleep(0.100)
+            quit = self.stopped
+        
+    def stop(self):
+        """  Stops the game client."""
+        if self.__verbose:
+            log.info("[BOOMBOOM] Stopping client...")
+        Happyboom.stop(self)
+        self.launchEvent("happyboom", "disconnection", self._io, u"Quit.")
+        self.display.stop()
+    
+    def evt_happyboom_stop(self):
+        """ Stop event handler.
+        """
+        self.stop()
+    
+    def displayThread(self):
+        """ Thread handler for the "display" part."""
+        try:
+            self.display.start()
+        except Exception, msg:
+            bt = getBacktrace()
+            log.error("EXCEPTION IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))
+        try:
+            self.stop()
+        except Exception, msg:
+            bt = getBacktrace()
+            log.error("EXCEPTION (2) IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))

Modified: boomboom/client/items/character.py
===================================================================
--- boomboom/client/items/character.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/items/character.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -4,12 +4,11 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client import bb_events
-from client.bb_item import BoomBoomItem, VisualObject
+from client.item import Item, VisualObject
 import os.path
 import pygame
 
-class Character(BoomBoomItem):
+class Character(Item):
     """ Represents a monkey character controlled by the player.
     @ivar visual: Graphical object containing data and transformations
     @type visual: C{L{VisualObject}}
@@ -22,18 +21,20 @@
     @ivar __name: Name of the player controlling the character (as known by the server).
     @type __name: C{str}
     """
-    def __init__(self, id, name, args):
+    feature = "character"
+    
+    def __init__(self, id):
         """ Character item constructor.
         @param id:  Server item id.
         @type id: C{int}
         @param name: Character name.
         @type name: C{str}
         """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self, id)
         self.__x = None
         self.__y = None
         self.__id = id
-        self.__name = name
+        self.__name = "unamed%s" %id
         self.visual = VisualObject(os.path.join("data", "gorilla.png"))
         self.active = False
         self.registerEvent("character")
@@ -47,14 +48,10 @@
         self.__x = x
         self.__y = y
         self.visual.move(self.__x, self.__y)
-        
-    def evt_game_active_character(self, event):
-        """ Active character event handler.
-        Adverts weapon the abscisse of the new active character.
-        @param event: Event with "game_active_character" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        if self.__id == int(event.content):
-            self.active = True
-            if self.__x != None:
-                self.launchEvent(bb_events.activeCharAbs, self.__x)
+    
+    def eventPerformed(self, event):
+        if event.event == "move":
+            raise Exception(event)
+    
+    def evt_character_name(self, id, name):
+        self.__name = name

Modified: boomboom/client/items/log.py
===================================================================
--- boomboom/client/items/log.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/items/log.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -1,8 +1,11 @@
-from client.bb_item import BoomBoomItem
+from client.item import Item
+from happyboom.common.log import log
 
-class LogItem(BoomBoomItem):
-    def __init__(self):
-        BoomBoomItem.__init__(self)
+class LogItem(Item):
+    feature = "log"
+    
+    def __init__(self, id):
+        Item.__init__(self, id)
         self.registerEvent("log")
         
     def evt_log_info(self, text):

Modified: boomboom/client/items/projectile.py
===================================================================
--- boomboom/client/items/projectile.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/items/projectile.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -5,18 +5,20 @@
 @version: 0.2
 """
 #from client import bb_events
-from client.bb_item import BoomBoomItem, VisualObject
+from client.item import Item, VisualObject
 import os.path
 
-class Projectile(BoomBoomItem):
+class Projectile(Item):
     """ Represents a banana projectile launch by the monkey.
     @ivar visual: Graphical object containing data and transformations
     @type visual: C{L{VisualObject}}
     """
     
-    def __init__(self, args):
+    feature = "projectile"
+    
+    def __init__(self, id):
         """ Projectile itemp constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self, id)
         self.visual = VisualObject(os.path.join("data", "banana.png"))
         self.registerEvent("projectile")
         

Modified: boomboom/client/items/sun.py
===================================================================
--- boomboom/client/items/sun.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/items/sun.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -4,12 +4,11 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client import bb_events
-from client.bb_item import BoomBoomItem, VisualObject
+from client.item import Item, VisualObject
 import os.path
 import pygame
 
-class Sun(BoomBoomItem):
+class Sun(Item):
     """ Represents a smiling sun which makes "oh" when collided.
     @ivar visual: Graphical object containing data and transformations
     @type visual: C{L{VisualObject}}
@@ -18,9 +17,12 @@
     @ivar __visual2: Visual with the "oh"-ing sun image.
     @type __visual2: C{L{VisualObject}}
     """
+    
+    feature = "sun"
+    
     def __init__(self):
         """ Sun item constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self)
         self.__visual1 = VisualObject(os.path.join("data", "sun.png"))
         self.__visual2 = VisualObject(os.path.join("data", "sun2.png"))
         self.__visual1.move (300,10)

Modified: boomboom/client/items/weapon.py
===================================================================
--- boomboom/client/items/weapon.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/items/weapon.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -4,10 +4,10 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.bb_item import BoomBoomItem
+from client.item import Item
 import pygame
 
-class Weapon(BoomBoomItem):
+class Weapon(Item):
     """ Represents the weapon parameters controlled by the player.
     @ivar __angle: Projection angle.
     @type __angle: C{int}
@@ -24,9 +24,12 @@
     @ivar __y: Item ordonnee.
     @type __y: C{int}
     """
-    def __init__(self, args):
+    
+    feature = "weapon"
+    
+    def __init__(self, id):
         """ Weapon item constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self, id)
         self.__angle = None 
         self.__strength = None
         fontname = pygame.font.get_default_font()
@@ -38,7 +41,6 @@
         self.active_character = None
         self.registerEvent("weapon")
         self.registerEvent("character")
-        self.registerEvent("game")
 
     def evt_weapon_setStrength(self, strength):
         """ Weapon strength event handler.
@@ -58,7 +60,7 @@
         self.character_pos[id] = (x, y,)
         self.updateX()
         
-    def evt_game_setActiveCharacter(self, id):
+    def evt_character_activate(self, id):
         """ Active character abcsisse event handler.
         @param event: Event with "active_character_abscisse" type.
         @type event: C{L{common.simple_event.Event}}

Modified: boomboom/client/items/world.py
===================================================================
--- boomboom/client/items/world.py	2005-09-17 03:34:03 UTC (rev 187)
+++ boomboom/client/items/world.py	2005-09-18 05:37:58 UTC (rev 188)
@@ -4,8 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client import bb_events
-from client.bb_item import BoomBoomItem
+from client.item import Item
 import random, pygame
 
 class Building:
@@ -15,6 +14,7 @@
     @ivar color: Random color tuple of the building (Red, Green, Blue, Alpha).
     @type color: C{(int, int, int, int)}
     """
+    
     def __init__(self, x, y, width, height):
         """ Building constructor.
         @param x: Building left abscisse.
@@ -38,14 +38,17 @@
         """
         screen.surface.fill(self.color, self.rect)
         
-class World(BoomBoomItem):
+class World(Item):
     """ Represents the ground of the game (collection of buildings).
     @ivar __buildings: Collection of buildings.
     @type __buildings: C{list<L{Building}>}
     """
-    def __init__(self, args):
+    
+    feature = "world"
+    
+    def __init__(self, id):
         """ World item constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self, id)
         self.__buildings = []
         self.registerEvent("world")
 



From dboucard at berlios.de  Sun Sep 18 07:48:56 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:48:56 +0200
Subject: [Happyboom-svn] r189 - boomboom/client
Message-ID: <200509180548.j8I5muBV022297@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:48:54 +0200 (Sun, 18 Sep 2005)
New Revision: 189

Added:
   boomboom/client/display.py
   boomboom/client/generic_input.py
   boomboom/client/input.py
   boomboom/client/item.py
Removed:
   boomboom/client/bb_constructor.py
   boomboom/client/bb_display.py
   boomboom/client/bb_drawer.py
   boomboom/client/bb_events.py
   boomboom/client/bb_input.py
   boomboom/client/bb_input_pygame.py
   boomboom/client/bb_item.py
Log:
renaming file names


Deleted: boomboom/client/bb_constructor.py
===================================================================
--- boomboom/client/bb_constructor.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_constructor.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,71 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from happyboom.common.event import EventListener
-from happyboom.common.log import log
-import bb_events
-
-class BoomBoomConstructor(EventListener):
-    """ Constructs visual items when server requires creation. """
-    def __init__(self, arg):
-        """ BoomBoomConstructor constructor. """
-        EventListener.__init__(self, prefix="evt_")
-        self.verbose = arg.get("verbose", False)
-        self.registerEvent("happyboom")
-        self.registerEvent("game")
-        self.textmode = arg["textmode"]
-        self.args = arg
-        
-    def evt_happyboom_doCreateItem(self, type, id):
-        """ Create event handler.
-        @param event: Event with "agent_manager_Create" type.
-        @type event: C{L{common.event.Event}}
-        """
-        if self.verbose:
-            log.info("Try to create object %s ..." % type)
-        if type=="projectile":
-            if self.textmode:
-                from items.projectile_curses import Projectile
-            else:
-                from items.projectile import Projectile
-            Projectile(self.args)
-        if type=="weapon":
-            if self.textmode:
-                from items.weapon_curses import Weapon 
-            else:
-                from items.weapon import Weapon
-            Weapon(self.args)
-        if type=="log":
-            from items import LogItem
-            LogItem()
-        if type=="world":
-            if self.textmode:
-                from items.world_curses import World
-            else:
-                from items.world import World
-            World(self.args)
-        if type=="character":
-            if self.textmode:
-                from items.character_curses import Character
-            else:
-                from items.character import Character
-            Character(id, "foo", self.args)
-        
-    def evt_game_start(self):
-        """ Start event handler.
-        @param event: Event with "game_Start" type.
-        @type event: C{L{common.event.Event}}
-        """
-        if not self.textmode:
-            from items import Sun
-            Sun()
-        
-    def evt_agent_manager_Text(self, event):
-        """ Text event handler.
-        @param event: Event with "agent_manager_Text" type.
-        @type event: C{L{common.event.Event}}
-        """
-        print "[CLIENT] Server message: %s" %(event.content)

Deleted: boomboom/client/bb_display.py
===================================================================
--- boomboom/client/bb_display.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_display.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,137 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from happyboom.common.happyboom_protocol import HappyboomProtocol as Presentation
-from happyboom.common.log import log
-from happyboom.common.event import EventListener
-import thread, pygame, time
-
-class Display(EventListener):
-    """ Class which manages "display" part of the network connections.
-    Also creates a drawer and a constuctor for "display" management.
-    @ivar drawer: instance which draws screen game.
-    @type drawer: C{L{BoomBoomDrawer}}
-    @ivar host: Server hostname.
-    @type host: C{str}
-    @ivar port: Server port for "display"/"view" connection.
-    @type port: C{int}
-    @ivar name: Name of the client (as known by the server).
-    @type name: C{str}
-    """
-    
-    def __init__(self, args):
-        """ BoomBoomDisplay constructor.
-        @param host: Server hostname.
-        @type host: C{str}
-        @param port: Server port for "display"/"view" connection.
-        @type port: C{int}
-        @param name: Name of the client (as known by the server).
-        @type name: C{string}
-        @param verbose: Verbose mode flag.
-        @type verbose: C{bool}
-        @param debug: Debug mode flag.
-        @type debug: C{bool}
-        @param max_fps: Maximal number of frames per second, for optimization.
-        @type max_fps: C{int}
-        """
-
-        EventListener.__init__(self)
-        self.registerEvent("graphical")
-        # Current offscreen
-        self._screen = None
-        max_fps = args.get("max_fps", 25)
-        self._frameTime = 1.0 / max_fps
-        self._items = []
-        self.__stopped = False
-        self.__stoplock = thread.allocate_lock()
-
-    def start(self):
-        """ Creates game window and starts display loop. """
-        self._screen = Window(640, 350)
-        self._screen.background_color = (0, 0, 168)
-        self.mainLoop()
-        
-    def stop(self):
-        """ Stops the display loop. """
-        # Does not stop several times
-        self.__stoplock.acquire()
-        if self.__stopped:
-            self.__stoplock.release()
-            return False
-        self.__stopped = True
-        self.__stoplock.release()
-        
-    def mainLoop(self):
-        """ Display loop. """
-        while not self.stopped:
-            live_begin = time.time()
-            
-            # Clearing screen
-            self._screen.surface.fill(self._screen.background_color)
-            # Drawing each items
-            if len(self._items) == 0:
-                fontname = pygame.font.get_default_font()
-                font = pygame.font.SysFont(fontname, 64)
-                font_color = (255,255,0,255)
-                #font_background = (0,0,0,0)
-                surface = font.render(" Not connected to server...", True, font_color)
-                self._screen.blit(surface, (0,0))
-            for item in self._items:
-                item.draw(self._screen)
-            # Displaying offscreen
-            pygame.display.flip()
-            
-            delay = time.time() - live_begin
-            if delay < self._frameTime:
-                delay = self._frameTime - delay
-                time.sleep(delay)
-        
-    def evt_graphical_item(self, item):
-        """ active item event handler.
-        @param event: Event with "graphical_item" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        if item not in self._items:
-            self._items.append(item)
-    
-    def __isStopped(self):
-        self.__stoplock.acquire()
-        stop = self.__stopped
-        self.__stoplock.release()
-        return stop
-    stopped = property(__isStopped)
-        
-class Window:
-    """ Represents a GUI window or surface using pygame.
-    @ivar type: Type of pygame surface : "window" or "surface" (panel into another window).
-    @type type: C{str}
-    @ivar surface: pygame surface object.
-    @type surface: C{pygame.Surface}
-    """
-    def __init__(self, width, height, type="window"):
-        """ Window constructor.
-        @param width: Width of the window.
-        @type width: C{int}
-        @param height: Height of the window.
-        @type height: C{int}
-        @param type: Type of pygame surface : "window" (by default) or "surface".
-        @type type: C{str}
-        """
-        if type=="surface":
-            self.type = "surface" 
-            self.surface = pygame.Surface((width,height))
-        else:
-            self.type = "window"
-            self.surface = pygame.display.set_mode((width,height), pygame.HWSURFACE | pygame.DOUBLEBUF)
-        self.pos = (0,0)
-        self.view_pos = (0,0)
-        self.scale = 1
-        self.border_color = (255, 255, 255)
-        self.background_color = (0, 0, 0)
-
-    def blit(self, surface, pos):
-        new_pos = (pos[0] - self.view_pos[0], pos[1] - self.view_pos[1],)
-        self.surface.blit(surface, new_pos)
\ No newline at end of file

Deleted: boomboom/client/bb_drawer.py
===================================================================
--- boomboom/client/bb_drawer.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_drawer.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,96 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from happyboom.common.event import EventListener
-import bb_events
-import pygame, time
-
-class BoomBoomDrawer(EventListener):
-    """ Manages the drawing of the screen game (double buffered) in a display loop.
-    @ivar __screen: Current drawed offscreen.
-    @type __screen: C{{Window}}
-    @ivar __frameTime: Minimum time to draw a frame.
-    @type __frameTime: C{float}
-    @ivar __items: Objects which have graphical content to draw (visual items) genered by visible item events.
-    @type __items: C{list<L{BoomBoomItem}>}
-    """
-    
-    def __init__(self, args):
-        """ BoomBoomDrawer constructor.
-        @param max_fps: Maximal number of frames per second, for optimization.
-        @type max_fps: C{int}
-        """
-        EventListener.__init__(self, prefix="evt_")
-        # Current offscreen
-        self.__screen = None
-        max_fps = args.get("max_fps", 25)
-        self.__frameTime = 1.0 / max_fps
-        self.__items = []
-        self.registerEvent("graphical")
-    
-    def start(self):
-        """ Creates game window and starts display loop. """
-        self.__screen = Window(640, 350)
-        self.__screen.background_color = (0, 0, 168)
-        
-    def mainLoop(self):
-        """ Display loop. """
-        while True:
-            live_begin = time.time()
-            
-            # Clearing screen
-            self.__screen.surface.fill(self.__screen.background_color)
-            # Drawing each items
-            for item in self.__items:
-                item.draw(self.__screen)
-            # Displaying offscreen 
-            pygame.display.flip()
-            
-            delay = time.time() - live_begin
-            if delay < self.__frameTime:
-                delay = self.__frameTime - delay
-                time.sleep(delay)
-        
-    def evt_graphical_item(self, item):
-        """ active item event handler.
-        @param event: Event with "graphical_item" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        if item not in self.__items:
-            self.__items.append(item)
-        
-        
-class Window:
-    """ Represents a GUI window or surface using pygame.
-    @ivar type: Type of pygame surface : "window" or "surface" (panel into another window).
-    @type type: C{str}
-    @ivar surface: pygame surface object.
-    @type surface: C{pygame.Surface}
-    """
-    def __init__(self, width, height, type="window"):
-        """ Window constructor.
-        @param width: Width of the window.
-        @type width: C{int}
-        @param height: Height of the window.
-        @type height: C{int}
-        @param type: Type of pygame surface : "window" (by default) or "surface".
-        @type type: C{str}
-        """
-        if type=="surface":
-            self.type = "surface" 
-            self.surface = pygame.Surface((width,height))
-        else:
-            self.type = "window"
-            self.surface = pygame.display.set_mode((width,height), pygame.HWSURFACE | pygame.DOUBLEBUF)
-        self.pos = (0,0)
-        self.view_pos = (0,0)
-        self.scale = 1
-        self.border_color = (255, 255, 255)
-        self.background_color = (0, 0, 0)
-
-    def blit(self, surface, pos):
-        new_pos = (pos[0] - self.view_pos[0], pos[1] - self.view_pos[1],)
-        self.surface.blit(surface, new_pos)

Deleted: boomboom/client/bb_events.py
===================================================================
--- boomboom/client/bb_events.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_events.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,20 +0,0 @@
-nextTurn = "game_next_turn"
-activeCharacter = "game_active_character"
-
-create = "agent_manager_Create"
-text = "agent_manager_Text"
-askVersion = "agent_manager_AskVersion"
-askName = "agent_manager_AskName"
-
-projectileMove = "projectile_move"
-projectileHitGround = "projectile_hit_ground"
-projectileActivate = "projectile_activate"
-
-weaponStrength = "weapon_force"
-weaponAngle = "weapon_angle"
-
-worldCreate = "world_create"
-
-characterMove = "character_move"
-
-activeCharAbs = "active_character_abscisse"

Deleted: boomboom/client/bb_input.py
===================================================================
--- boomboom/client/bb_input.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_input.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,69 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from happyboom.common.event import EventLauncher, EventListener
-import thread, time
-
-class Input(EventLauncher, EventListener):
-    """ Class which manages "input" part of the network connections.
-    @ivar host: Server hostname.
-    @type host: C{str}
-    @ivar port: Server port for "input" connection.
-    @type port: C{int}
-    @ivar name: Name of the client (as known by the server).
-    @type name: C{str}
-    @ivar __protocol_version: Current version of the protocol used by the client.
-    @type __protocol_version: C{str}
-    @ivar __io: Network input/output object using UDP protocole.
-    @type __io: C{net.io_udp.IO_UDP}
-    @ivar __recv_buffer: Network data reception buffer.
-    @type __recv_buffer: C{net.net_buffer.NetBuffer}
-    @ivar __verbose: Verbose mode flag.
-    @type __verbose: C{bool}
-    @ivar __debug: Debug mode flag.
-    @type __debug: C{bool}
-    @ivar __stopped: Stopped input client flag.
-    @type __stopped: C{bool}
-    @ivar __stoplock: Mutex for synchronizing __stopped.
-    @type __stoplock: C{thread.lock}
-    """
-    
-    def __init__(self, arg):
-        """ BoomBoomInput constructor.
-        @param host: Server hostname.
-        @type host: C{str}
-        @param port: Server port for "input" connection.
-        @type port: C{int}
-        @param name: Name of the client (as known by the server).
-        @type name: C{string}
-        @param verbose: Verbose mode flag.
-        @type verbose: C{bool}
-        @param debug: Debug mode flag.
-        @type debug: C{bool}
-        """
-
-        EventLauncher.__init__(self)
-        EventListener.__init__(self)
-        self.weapon_angle = None
-        self.weapon_strength = None
-        self.registerEvent("weapon")
-
-    def evt_weapon_setStrength(self, strength):
-        self.weapon_strength = strength
-        
-    def evt_weapon_setAngle(self, angle):
-        self.weapon_angle = angle
-
-    def weapon_setStrengthDelta(self, delta):
-        self.launchEvent("happyboom", "network", \
-            "weapon", "askSetStrength", self.weapon_strength + delta)
-
-    def weapon_setAngleDelta(self, delta):
-        self.launchEvent("happyboom", "network", \
-            "weapon", "askSetAngle", self.weapon_angle + delta)
-
-    def process(self):
-        pass

Deleted: boomboom/client/bb_input_pygame.py
===================================================================
--- boomboom/client/bb_input_pygame.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_input_pygame.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,47 +0,0 @@
-from generic_input import Input as BaseInput
-import pygame                
-
-class Input(BaseInput):
-    def __init__(self, arg):
-        BaseInput.__init__(self, arg)
-#        import pygame
-
-    def process(self):
-        for input_event in pygame.event.get():
-            self.process_event(input_event)
-           
-    def process_event(self, event):
-        """ Manages when a pygame event is caught.
-        @param event: Pygame event.
-        @type event: C{pygame.Event}
-        """
-        if event.type == pygame.KEYDOWN: 
-            # q, Q or escape: quit
-            if event.unicode in (u'q', u'Q') or event.key == 27:
-                self.launchEvent("happyboom", "stop")
-        # Quit event: quit
-        elif event.type in (pygame.QUIT, ):
-            self.launchEvent("happyboom", "stop")
-    
-        #character = self.client.view.getActiveCharacter()
-        #if character != None: self.process_event_active(character, event)
-        self.process_event_active(event)
-
-    def process_event_active(self, event):
-        """ Manages when a pygame event is caught and interact with the server.
-        @param event: Pygame event.
-        @type event: C{pygame.Event}
-        """
-        #delta_angle = -30
-        if event.type == pygame.KEYDOWN: 
-            # arrow keys: move character
-            if event.key == 32:
-                self.launchEvent("happyboom", "network", "weapon", "shoot")
-            elif event.key == 275:
-                self.weapon_setStrengthDelta(10) # RIGHT 
-            elif event.key == 273:
-                self.weapon_setAngleDelta(10) # UP
-            elif event.key == 274:
-                self.weapon_setAngleDelta(-10) # DOWN
-            elif event.key == 276:
-                self.weapon_setStrengthDelta(-10) # LEFT

Deleted: boomboom/client/bb_item.py
===================================================================
--- boomboom/client/bb_item.py	2005-09-18 05:37:58 UTC (rev 188)
+++ boomboom/client/bb_item.py	2005-09-18 05:48:54 UTC (rev 189)
@@ -1,156 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from happyboom.common.event import EventListener, EventLauncher
-import pygame
-
-class Item(EventListener, EventLauncher):
-    """ Generic class for representing graphical items.
-    @ivar visual: Graphical object containing data and transformations
-    @type visual: C{L{VisualObject}}
-    """
-    
-    feature = None
-    
-    def __init__(self, id=None):
-        """ BoomBoomItem constructor. """
-        EventListener.__init__(self, "evt_")
-        EventLauncher.__init__(self)
-        self.visual = None
-        self.launchEvent("graphical", "item", self)
-        self.id = id
-        
-    def draw(self, screen):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        if self.visual == None: return
-        self.visual.draw(screen)
-    
-    def sendNetMsg(self, feature, event, *args):
-        print "SEND NET %s" % (feature)
-        self.launchEvent("happyboom", "network", \
-            feature, event, *args)
-
-class VisualObject(object):
-    """ Manage representation and transformation of an external image to be drawn into game screen.
-    @ivar visible: Visibility item flag (Default: C{True}).
-    @type visible: C{bool}
-    @ivar surface: Pygame item surface object.
-    @type surface: C{pygame.Surface}
-    @type rect: C{pygame.Rect}
-    @type x: C{int}
-    @type y: C{int}
-    @type width: C{int}
-    @type height: C{int}
-    @ivar __x: Item top-left abcsisse.
-    @type __x: C{int}
-    @ivar __y: Item top-left ordonnee.
-    @type __y: C{int}
-    @ivar __width: Item width.
-    @type __width: C{int}
-    @ivar __height: Item height.
-    @type __height. C{int}
-    @ivar __rect: Including box of the item for collide detection.
-    @type __rect: C{pygame.Rect}
-    """
-    def __init__(self, file):
-        """ VisualObject constructor.
-        @param file: Path of the external image.
-        @type file: C{str}
-        """
-        self.__x, self.__y = (0,0)
-        self.loadImage(file)
-        self.visible = True
-
-    def loadImage(self, file):
-        """ Loads external image with pygame.
-        @param file: Path of the external image.
-        @type file: C{str}
-        """
-        self.surface = pygame.image.load(file).convert_alpha()
-        self.__width = self.surface.get_width()
-        self.__height = self.surface.get_height()
-        self.__rect = pygame.Rect( [self.__x, self.__y, self.__width, self.__height] )
-
-    def move(self, x, y):
-        """ Moves the items in absolute coordinates.
-        @param x: New abcsisse.
-        @type x: C{int}
-        @param y: New ordonnee.
-        @type y: C{int}
-        """
-        self.__x = x
-        self.__y = y
-        self.__rect = pygame.Rect( [self.__x, self.__y, self.__width, self.__height] )
-
-    def __getRect(self):
-        """ C{L{rect}} property getter.
-        @return: The including box of the item.
-        @rtype: C{pygame.Rect}
-        """
-        return self.__rect
-    rect = property(__getRect, doc="Including box of the item for collide detection (read only).")
-    
-    def __getHeight(self):
-        """ C{L{height}} property getter.
-        @return: The height of the item.
-        @rtype: C{int}
-        """
-        return self.__height
-    height = property(__getHeight, doc="Item height (read only).")
-    
-    def __getWidth(self):
-        """ C{L{width}} property getter.
-        @return: The width of the item.
-        @rtype: C{int}
-        """
-        return self.__width
-    width = property(__getWidth, doc="Item width (read only).")
-    
-    def __getX(self):
-        """ C{L{x}} property getter.
-        @return: The left abcsisse ot the item.
-        @rtype: C{int}
-        """
-        return self.__x
-    def __setX(self, x):
-        """ C{L{x}} property setter.
-        @param x: New item abcsisse.
-        @type x: C{int}
-        """
-        self.move(x, self.__y)
-    x = property(__getX, __setX, doc="Item top-left abcsisse.")
-    
-    def __getY(self):
-        """ C{L{y}} property getter.
-        @return: The top ordonnee ot the item.
-        @rtype: C{int}
-        """
-        return self.__y
-    def __setY(self, y):
-        """ C{L{y}} property setter.
-        @param y: New item ordonnee.
-        @type y: C{int}
-        """
-        self.move(self.__x, y)
-    y = property(__getY, __setY, doc="Item top-left ordonnee.")
-
-    def setVisibility(self, visible):
-        """ Sets the visibility of the item.
-        @param visible: New visible flag value.
-        @type visible: C{bool}
-        """
-        self.visible = visible
-        
-    def draw(self, screen):
-        """ Draws the image (if visible) into the game offscreen.
-        @param screen: Current game offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        if not self.visible: return
-        screen.blit(self.surface, (self.x, self.y))

Copied: boomboom/client/display.py (from rev 188, boomboom/client/bb_display.py)

Copied: boomboom/client/generic_input.py (from rev 188, boomboom/client/bb_input.py)

Copied: boomboom/client/input.py (from rev 188, boomboom/client/bb_input_pygame.py)

Copied: boomboom/client/item.py (from rev 188, boomboom/client/bb_item.py)



From dboucard at berlios.de  Sun Sep 18 07:52:58 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:52:58 +0200
Subject: [Happyboom-svn] r190 - boomboom
Message-ID: <200509180552.j8I5qwwp026366@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:52:54 +0200 (Sun, 18 Sep 2005)
New Revision: 190

Modified:
   boomboom/protocol.xml
Log:
some modifications in a BoomBoom protocol way


Modified: boomboom/protocol.xml
===================================================================
--- boomboom/protocol.xml	2005-09-18 05:48:54 UTC (rev 189)
+++ boomboom/protocol.xml	2005-09-18 05:52:54 UTC (rev 190)
@@ -3,10 +3,8 @@
   <feature name="game" id="1">
     <event name="start" id="1" />
     <event name="stop" id="2" />
-    <event name="setActiveCharacter" id="3">
-      <param type="int" name="player" />
-    </event>
-    <event name="nextTurn" id="4" />
+    <event name="nextTurn" id="3" />
+    <event name="nextRound" id="4" />
   </feature>
   
   <feature name="log" id="2">
@@ -33,6 +31,9 @@
       <param type="int" name="x" />
       <param type="int"  name="y"/>
     </event>
+    <event name="activate" id="2">
+      <param type="int" name="id" />
+    </event>
   </feature>
   
   <feature name="projectile" id="5">
@@ -70,4 +71,10 @@
       <param type="bin" name="buildings" />
     </event>
   </feature>
+  <feature name="score" id="8">
+    <event name="update" id="1">
+      <param type="int" name="player" />
+      <param type="int" name="score" />
+    </event>
+  </feature>
 </protocol>



From dboucard at berlios.de  Sun Sep 18 07:53:46 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:53:46 +0200
Subject: [Happyboom-svn] r191 - boomboom
Message-ID: <200509180553.j8I5rkJ9026793@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:53:42 +0200 (Sun, 18 Sep 2005)
New Revision: 191

Modified:
   boomboom/boomboom_client.py
Log:
BoomBoom client script launcher


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-18 05:52:54 UTC (rev 190)
+++ boomboom/boomboom_client.py	2005-09-18 05:53:42 UTC (rev 191)
@@ -65,14 +65,10 @@
     return val
 
 def run(arg):
-    from happyboom.common.protocol import loadProtocol
-    from client import BoomBoomClient
-    from client.bb_display import BoomBoomDisplay
+    from client import Client
     from happyboom.common.log import log
-
-    arg["protocol"] = loadProtocol("protocol.xml")
-    display = BoomBoomDisplay(arg)
-    client = BoomBoomClient(display, arg)
+    
+    client = Client(arg)
     try:
         client.start()
     except KeyboardInterrupt:
@@ -116,7 +112,8 @@
         "textmode": False, \
         "server-log": False, \
         "name": "-", \
-        "debug": False}
+        "debug": False, \
+        "item_path": "client/items"}
     arg = parseArgs(val)
     textmode = arg["textmode"]
 



From dboucard at berlios.de  Sun Sep 18 07:54:38 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:54:38 +0200
Subject: [Happyboom-svn] r192 - boomboom/server/agents
Message-ID: <200509180554.j8I5scDX027195@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:54:36 +0200 (Sun, 18 Sep 2005)
New Revision: 192

Modified:
   boomboom/server/agents/game.py
Log:
protocol compliance


Modified: boomboom/server/agents/game.py
===================================================================
--- boomboom/server/agents/game.py	2005-09-18 05:53:42 UTC (rev 191)
+++ boomboom/server/agents/game.py	2005-09-18 05:54:36 UTC (rev 192)
@@ -22,7 +22,7 @@
         self.current = current
         char = self.characters[self.current].id
         self.send("setActiveCharacter", char)
-        self.sendNetMsg("game", "setActiveCharacter", char)
+        self.sendNetMsg("character", "activate", char)
 
     def nextCharacter(self):
         new = (self.current + 1) % len(self.characters)



From dboucard at berlios.de  Sun Sep 18 07:55:31 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:55:31 +0200
Subject: [Happyboom-svn] r193 - happyboom/trunk/common
Message-ID: <200509180555.j8I5tVib027915@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:55:25 +0200 (Sun, 18 Sep 2005)
New Revision: 193

Modified:
   happyboom/trunk/common/generic_event.py
   happyboom/trunk/common/happyboom_protocol.py
   happyboom/trunk/common/packer.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/common/protocol.py
Log:
code cleaning


Modified: happyboom/trunk/common/generic_event.py
===================================================================
--- happyboom/trunk/common/generic_event.py	2005-09-18 05:54:36 UTC (rev 192)
+++ happyboom/trunk/common/generic_event.py	2005-09-18 05:55:25 UTC (rev 193)
@@ -170,7 +170,7 @@
         @return: Object converted string.
         @rtype: C{str}
         """
-        return "<bb_events.BoomBoomEvent type=%s source=%s content=%s>" %(self.type, self.source, self.content)
+        return "<generic_event.Event type=%s source=%s content=%s>" %(self.type, self.source, self.content)
     
     
 class UnhandledEventError(AttributeError):

Modified: happyboom/trunk/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/common/happyboom_protocol.py	2005-09-18 05:54:36 UTC (rev 192)
+++ happyboom/trunk/common/happyboom_protocol.py	2005-09-18 05:55:25 UTC (rev 193)
@@ -1,5 +1,5 @@
 from presentation import Presentation
-from happyboom.common.packer import unpack, unpackBin, unpackUtf8, unpackInt
+import happyboom.common.packer as packer
 from happyboom.common.log import log
 import struct
 
@@ -8,12 +8,58 @@
         Presentation.__init__(self, protocol, args)
         self._unpackFunc = { \
             self.CONNECTION: self.unpackConnection,
-            self.DISCONNECTION: self.unpackDisconnect,
+            self.DISCONNECTION: self.unpackDisconnection,
             self.FEATURES: self.unpackFeatures,
             self.CREATE: self.unpackCreateItem,
             self.DESTROY: self.unpackDestroyItem,
             self.EVENT: self.unpackEvent}
 
+    def packConnection(self, version, signature):
+        data = struct.pack("!B", self.CONNECTION)
+        data = data + packer.packBin(version)
+        return data + packer.packBin(signature)
+
+    def packDisconnection(self, reason):
+        return struct.pack("!B", self.DISCONNECTION) + packer.packUtf8(reason)
+
+    def packFeatures(self, features):
+        data = struct.pack("!B", self.FEATURES)
+        return data + packer.packBin(features)
+
+    def packCreate(self, feature, id):
+        return struct.pack("!BBI", self.CREATE, feature, id)
+
+    def packEvent(self, id):
+        return struct.pack("!BI", self.DESTROY, id)
+
+    def packEvent(self, feature, event, args):
+        f = self.protocol.getFeature(feature)
+        e = f.getEvent(event)
+        out = struct.pack("!BB", f.id, e.id)
+        types = e.getParamTypes()
+        if len(args) != len(types):
+            raise ProtocolException( \
+                "Unexpected number of parameters (%u) for the event %s.%s." \
+                % (len(args), f.name, e))
+        for i in range(len(args)):
+            if not packer.checkType(types[i], args[i]):
+                raise ProtocolException( \
+                    "Parameter %u of event %s.%s should have type %s (instead of %s)." \
+                    % (i, f.name, e, types[i], type(args[i])))
+            type = types[i]
+            data = args[i]
+            
+            if type=="int":
+                data = packer.packInt(data)
+            elif type=="bin":
+                data = packer.packBin(data)
+            elif type=="utf8":
+                data = packer.packUtf8(data)
+            else:
+                raise packer.PackerException("Wrong argument type: %s" % type)
+            out = out + data
+        return struct.pack("!B", self.EVENT) + out
+
     def unpackPacketType(self, data):
         # Get packet type
         fmt = "!B"
@@ -21,15 +67,22 @@
         type, = struct.unpack(fmt, data[:i]) 
         return type, data[i:]
 
-    def unpackDisconnect(self, ioclient, data):
-        reason, data = unpackUtf8(data)
+    def unpackConnection(self, ioclient, data):
+        version, data = packer.unpackBin(data)
+        signature, data = packer.unpackBin(data) 
+        if self._on_connection != None:
+            self._on_connection(ioclient, version, signature)
+        return data
+
+    def unpackDisconnection(self, ioclient, data):
+        reason, data = packer.unpackUtf8(data)
         if self._on_disconnection != None:
             self._on_disconnection(ioclient, reason)
 #            self.client_manager.closeClient(ioclient)
         return data
         
     def unpackFeatures(self, ioclient, data):
-        features, data = unpackBin(data)
+        features, data = packer.unpackBin(data)
         if self._on_features != None:
             self._on_features(ioclient, features)
         return data
@@ -37,14 +90,15 @@
     def unpackCreateItem(self, ioclient, data):
         fmt = "!BI"
         i = struct.calcsize(fmt)
-        type, itemid = struct.unpack(fmt, data)
+        typeid, itemid = struct.unpack(fmt, data)
+        type = self.protocol[typeid]
         data = data[i:]
         if self._on_create_item != None:
-            self._on_create_item(ioclient, type, itemid)
+            self._on_create_item(ioclient, type.name, itemid)
         return data
 
     def unpackDestroyItem(self, ioclient, data):
-        itemid,data = unpackInt(data)
+        itemid,data = packer.unpackInt(data)
         if self._on_destroy_item != None:
             self._on_destroy_item(ioclient, itemid)
         return data
@@ -53,15 +107,20 @@
         fmt = "!BB"
         i = struct.calcsize(fmt)
         feature_id, event_id = struct.unpack(fmt, data[:i])
+        feat = self.protocol[feature_id]
+        evt = feat[event_id]
         data = data[i:]
-        feature, event, args = unpack(data, feature_id, event_id, self.protocol)
+        args = []
+        for type in evt.getParamTypes():
+            if type=="int":
+                arg, data = packer.unpackInt(data)
+            elif type=="bin":
+                arg, data = packer.unpackBin(data)
+            elif type=="utf8":
+                arg, data = packer.unpackUtf8(data)
+            else:
+                raise packer.PackerException("Wrong argument type: %s" % type)
+            args.append(arg)
         if self._on_recv_event != None:
-            self._on_recv_event(ioclient, feature, event, *args)
+            self._on_recv_event(ioclient, feat.name, evt.name, tuple(args))
         return ""
-
-    def unpackConnection(self, ioclient, data):
-        version, data = unpackBin(data)
-        signature, data = unpackBin(data) 
-        if self._on_connection != None:
-            self._on_connection(ioclient, version, signature)
-        return data

Modified: happyboom/trunk/common/packer.py
===================================================================
--- happyboom/trunk/common/packer.py	2005-09-18 05:54:36 UTC (rev 192)
+++ happyboom/trunk/common/packer.py	2005-09-18 05:55:25 UTC (rev 193)
@@ -15,44 +15,33 @@
     else:
         raise PackerException("Wrong argument type: %s" % datatype)
 
+# Integer type
 def packInt(data):
     assert checkType("int", data), "packInt argument have to be an integer"
     return struct.pack("!i", data)
     
+def unpackInt(data):
+    fmt = "!i"
+    i = struct.calcsize(fmt)
+    value, = struct.unpack(fmt, data[:i])
+    return value, data[i:]
+    
+# unicode string type (encoded in UTF-8)
 def packUtf8(data):
     assert checkType("utf8", data), "packUtf8 argument have to be an unicode string"
     return packBin(data.encode("utf-8"))
 
+def unpackUtf8(data):
+    str, data = unpackBin(data)
+    str = unicode(str, "UTF-8")
+    return str, data
+
+# Binary string type
 def packBin(data):
     assert checkType("bin", data), "packBin argument have to be a string"
+    # TODO : verify length
     return struct.pack("!H%us" % len(data), len(data), data)
 
-def pack(func, event, types, values):
-    """
-    Pack arguments to binary string. Supported types :
-    - "int": L{packInt}
-    - "bin": L{packBin}
-    - "utf8": L{packUtf8}
-    """
-
-    assert len(types) == len(values), "Lengths of types and args have to be the same."
-    out = struct.pack("!BB", func, event)
-
-    for i in range(len(values)):
-        type = types[i]
-        data = values[i]
-        
-        if type=="int":
-            data = packInt(data)
-        elif type=="bin":
-            data = packBin(data)
-        elif type=="utf8":
-            data = packUtf8(data)
-        else:
-            raise PackerException("Wrong argument type: %s" % type)
-        out = out + data
-    return out        
-
 def unpackBin(data):        
     fmt = "!H"
     i = struct.calcsize(fmt)
@@ -62,33 +51,3 @@
     i = struct.calcsize(fmt)
     bin, = struct.unpack(fmt, data[:i])
     return bin, data[i:]
-
-def unpackUtf8(data):
-    str, data = unpackBin(data)
-    str = unicode(str, "UTF-8")
-    return str, data
- 
-def unpackInt(data):
-    fmt = "!i"
-    i = struct.calcsize(fmt)
-    value, = struct.unpack(fmt, data[:i])
-    return value, data[i:]
-
-def unpack(data, feature_id, event_id, protocol):
-    """
-    Unpack binary string to arguments.
-    """
-    feat = protocol.getFeatureById(feature_id)
-    evt = feat.getEventById(event_id)
-    args = []
-    for type in evt.getParamTypes():
-        if type=="int":
-            arg, data = unpackInt(data)
-        elif type=="bin":
-            arg, data = unpackBin(data)
-        elif type=="utf8":
-            arg, data = unpackUtf8(data)
-        else:
-            raise PackerException("Wrong argument type: %s" % type)
-        args.append(arg)
-    return (feat.name, evt.name, args)

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-18 05:54:36 UTC (rev 192)
+++ happyboom/trunk/common/presentation.py	2005-09-18 05:55:25 UTC (rev 193)
@@ -2,7 +2,6 @@
 from happyboom.common.log import log
 from happyboom.net.io.packet import Packet
 from happyboom.server.client import Client
-from happyboom.common.packer import packUtf8, packBin
 import struct
 
 class PresentationException(Exception):
@@ -28,19 +27,14 @@
 
         # Event (IO_Client client, str version, str signature)
         self._on_connection = None
-
         # Event (IO_Client client, str features)
         self._on_features = None
-        
         # Event (IO_Client client)
         self._on_disconnection = None
-
         # Event (IO_Client client, str feature, str event, str arguments)
         self._on_recv_event = None
-
         # Event (IO_Client client, str type, int id)
         self._on_create_item = None
-
         # Event (IO_Client client, int id)
         self._on_destroy_item = None
 
@@ -73,30 +67,17 @@
         """
         self.evt_happyboom_disconnection(ioclient, reason)
 
-    def evt_happyboom_features(self, ioclient, features):
-        if self.verbose:
-            log.info(u"[PRESENTATION] Send features(%s)" % features)
-        data = struct.pack("!B", self.FEATURES)
-        data = data + packBin(features)
-        ioclient.send( Packet(data) )
-        
-    def evt_happyboom_create(self, ioclient, feature, id):
-        if self.verbose:
-            log.info(u"[PRESENTATION] Send create(%s, %s)" % (feature, id))
-        data = struct.pack("!BBI", self.CREATE, feature, id)
-        ioclient.send( Packet(data) )
-       
-    def evt_happyboom_connection(self, ioclient, version, signature):
+    def evt_happyboom_connection(self, ioclient, version=None, signature=""):
         """
         Send a connection message to ioclient.
         @type version ASCII string
         @type signature string
         """
+        if version == None:
+            version = self.protocol.version
         if self.verbose:
             log.info("[PRESENTATION] Send connection(\"%s\", \"%s\")" % (version, signature))
-        data = struct.pack("!B", self.CONNECTION)
-        data = data + packBin(version)
-        data = data + packBin(signature)
+        data = self.packConnection(version, signature)
         ioclient.send( Packet(data) )
 
     def evt_happyboom_disconnection(self, ioclient, reason):
@@ -108,20 +89,43 @@
         
         if self.verbose:
             log.info(u"[PRESENTATION] Send disconnection(\"%s\")" % reason)
-        data = struct.pack("!B", self.DISCONNECTION) + packUtf8(reason)
+        data = self.packDisconnection(reason)
         ioclient.send( Packet(data) )
         ioclient.disconnect()
+    
 
-    def evt_happyboom_event(self, clients, data):
-        data = struct.pack("!B", self.EVENT) + data
+    def evt_happyboom_features(self, ioclient, features):
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send features(%s)" % features)
+        data = self.packFeatures(features)
+        ioclient.send( Packet(data) )
+        
+    def evt_happyboom_create(self, ioclient, feature, id):
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send create(%s, %s)" % (feature, id))
+        data = self.packCreate(feature, id)
+        ioclient.send( Packet(data) )
+       
+    
+    def evt_happyboom_event(self, clients, feature, event, args):
+        data = self.packEvent(feature, event, args)
         packet = Packet(data)
         for client in clients: client.send(packet)
         
     def unpackPacketType(self, data):
         """ returns type, data """
         return 0, data
-    def unpackDisconnect(self, ioclient, data): return data
+        
+    def unpackConnection(self, ioclient, version, signature): return data
+    def unpackDisconnection(self, ioclient, data): return data
     def unpackFeatures(self, ioclient, data): return data
     def unpackCreateItem(self, data): return data
     def unpackDestroyItem(self, data): return data
     def unpackEvent(self, ioclient, data): return data
+
+    def packConnection(self, version, signature): return ""
+    def packDisconnect(self, reason): return ""
+    def packFeatures(self, features): return ""
+    def packCreateItem(self, feature, id): return ""
+    def packDestroyItem(self, id): return ""
+    def packEvent(self, feature, event, args): return ""
\ No newline at end of file

Modified: happyboom/trunk/common/protocol.py
===================================================================
--- happyboom/trunk/common/protocol.py	2005-09-18 05:54:36 UTC (rev 192)
+++ happyboom/trunk/common/protocol.py	2005-09-18 05:55:25 UTC (rev 193)
@@ -3,7 +3,6 @@
 """
 
 import xml.dom.minidom
-from happyboom.common.packer import pack, checkType
 
 class ProtocolException(Exception):
     def __init__(self, msg):
@@ -86,7 +85,7 @@
                 % (self.protocol.name, self.name, name))
         return self.__evtnames[name]
 
-    def getEventById(self, id):
+    def __getitem__(self, id):
         event = self.__evtids.get(id, None)
         if event == None:
             raise ProtocolException( \
@@ -116,21 +115,6 @@
         self.__featnames = {}
         self.__featids = {}
 
-    def createMsg(self, feature, event, *args):
-        f = self.getFeature(feature)
-        e = f.getEvent(event)
-        types = e.getParamTypes()
-        if len(args) != len(types):
-            raise ProtocolException( \
-                "Wrong parameter count (%u) for the event %s.%s." \
-                % (len(args), f.name, e))
-        for i in range(len(args)):
-            if not checkType(types[i], args[i]):
-                raise ProtocolException( \
-                    "Parameter %u of event %s.%s should be of type %s (and not %s)." \
-                    % (i, f.name, e, types[i], type(args[i])))
-        return pack(f.id, e.id, types, args)
-
     def addFeature(self, name, id):
         # Check if no other feature have the same identifier
         feature = self.__featnames.get(name, None)
@@ -160,7 +144,7 @@
                 % (self.name, name))
         return feature
 
-    def getFeatureById(self, id):
+    def __getitem__(self, id):
         feature = self.__featids.get(id, None)
         if  feature == None:
             raise ProtocolException( \



From dboucard at berlios.de  Sun Sep 18 07:56:32 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:56:32 +0200
Subject: [Happyboom-svn] r194 - happyboom/trunk/server
Message-ID: <200509180556.j8I5uWeC028314@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:56:27 +0200 (Sun, 18 Sep 2005)
New Revision: 194

Modified:
   happyboom/trunk/server/client_manager.py
   happyboom/trunk/server/gateway.py
Log:
adaptation to previous common-part code cleaning


Modified: happyboom/trunk/server/client_manager.py
===================================================================
--- happyboom/trunk/server/client_manager.py	2005-09-18 05:55:25 UTC (rev 193)
+++ happyboom/trunk/server/client_manager.py	2005-09-18 05:56:27 UTC (rev 194)
@@ -49,7 +49,7 @@
 
         # Register client to features
         for feature in features:
-            f = self.__protocol.getFeatureById(ord(feature))
+            f = self.__protocol[ord(feature)]
             feature = f.name
             if self.__verbose: log.info("Register feature %s for client %s" % (feature, client))
             if feature in self.__supported_features:

Modified: happyboom/trunk/server/gateway.py
===================================================================
--- happyboom/trunk/server/gateway.py	2005-09-18 05:55:25 UTC (rev 193)
+++ happyboom/trunk/server/gateway.py	2005-09-18 05:56:27 UTC (rev 194)
@@ -68,7 +68,7 @@
         else:
             self.sendNetMsg("chat", "message", txt)
 
-    def recvNetMsg(self, ioclient, feature, event, *args):
+    def recvNetMsg(self, ioclient, feature, event, args):
         if self._verbose: log.info("Received: %s.%s%s" % (feature, event, args))
         message = Message("%s_%s" % (feature, event), args)
         self.sendBroadcastMessage(message, "%s_listener" % feature)
@@ -80,9 +80,4 @@
     def sendNetMsg(self, feature, event, *args):
         clients = self.client_manager.supported_features.get(feature, ())
         if len(clients)==0: return
-        try:
-            data = self.presentation.protocol.createMsg(feature, event, *args)
-        except ProtocolException, err:
-            log.error(err)
-            return
-        self.launchEvent("happyboom", "event", clients, data);
+        self.launchEvent("happyboom", "event", clients, feature, event, args);



From dboucard at berlios.de  Sun Sep 18 07:56:58 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 07:56:58 +0200
Subject: [Happyboom-svn] r195 - happyboom/trunk/client
Message-ID: <200509180556.j8I5uwGM028577@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 07:56:52 +0200 (Sun, 18 Sep 2005)
New Revision: 195

Modified:
   happyboom/trunk/client/base_client.py
Log:
client code cleaning


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-18 05:56:27 UTC (rev 194)
+++ happyboom/trunk/client/base_client.py	2005-09-18 05:56:52 UTC (rev 195)
@@ -4,8 +4,7 @@
 from happyboom.common.event import EventLauncher, EventListener
 from happyboom.net.io.packet import Packet
 from happyboom.net.io_tcp.tcp import IO_TCP
-import struct, string
-import thread
+import struct, string, thread, imp, os.path, sys
 
 class Client(object, EventListener, EventLauncher):
     """
@@ -23,7 +22,7 @@
     """
     
     def __init__(self, args):
-        EventListener.__init__(self) # TODO : Fix me (with good arguments)
+        EventListener.__init__(self)
         EventLauncher.__init__(self)
         self.host = args.get("host", "127.0.0.1")
         self.port = args.get("port", 12430)
@@ -40,20 +39,13 @@
         self.presentation = HappyboomProtocol(protocol, args)
         self.gateway = Gateway(protocol, args)
         self.registerEvent("happyboom")
+        
+    def evt_happyboom_stop(self):
+        self.stop()
 
     def evt_happyboom_network(self, feature, event, *args):
-        self.send(feature, event, *args)
+        self.launchEvent("happyboom", "event", (self._io,), feature, event, args)
 
-    def send(self, feature, event, *args):
-        """ Sends a string to the network server.
-        @param str: String to send.
-        @type str: C{str}
-        """
-        data = self.presentation.protocol.createMsg(feature, event, *args)
-        self.launchEvent("happyboom", "event", (self._io,), data)
-#        data = self.presentation.sendMsg(data)
-#        self._io.send(Packet(data))
-        
     def start(self):
         """ Starts the client : connection to the server, etc. """
         # Try to connect to server
@@ -93,7 +85,7 @@
         """ Handler called on network connection. """
         if self.verbose:
             log.info("[HAPPYBOOM] Connected to server, send presentation connection().")
-        self.launchEvent("happyboom", "connection", self._io, self.presentation.protocol.version.encode("ascii"), "")
+        self.launchEvent("happyboom", "connection", self._io)
         
     def onConnectionFails(self):
         """ Handler called when network connection fails. """
@@ -110,17 +102,6 @@
         log.warning("[HAPPYBOOM] Lost connection with server.")
         self.launchEvent("happyboom", "stop")
         
-    def processPacket(self, new_packet):
-        """ Processes incomming network packets (converts and launches local event).
-        @param new_packet: incomming network packet.
-        @type new_packet: C{net.io.packet.Packet}
-        """
-        event_type, arg = self.str2evt(new_packet.data)
-        if event_type != None: 
-            if self.debug:
-                log.info("Received message: type=%s arg=%s" %(event_type, arg))
-            self.launchEvent(event_type, arg)
-            
 class Gateway(EventLauncher, EventListener):
     def __init__(self, protocol, args):
         EventLauncher.__init__(self)
@@ -128,16 +109,40 @@
         self.protocol = protocol
         self.launchEvent("happyboom", "register", "connection", self.processConnection)
         self.launchEvent("happyboom", "register", "disconnection", self.processDisconnection)
-        self.launchEvent("happyboom", "register", "create_item", self.processCreate)
-#        self.launchEvent("happyboom", "register", "destroy_item", self.processXX)
+        self.launchEvent("happyboom", "register", "create_item", self.processCreateItem)
+        self.launchEvent("happyboom", "register", "destroy_item", self.processDestroyItem)
         self.launchEvent("happyboom", "register", "recv_event", self.processEvent)
         self.registerEvent("happyboom")
         self.verbose = args.get("verbose", False)
         self.debug = args.get("debug", False)
-        self.features = []
+        self.features = {}
+        for feat in args.get("features", ()):
+            self.features[feat] = None
         self.items = {}
-        #self.gamepath = None
-        self.module = __import__("client/items")
+        itemPath = args["item_path"]
+        dirs = itemPath.split(os.path.sep)
+        if dirs[-1] == "":
+            dirs = dirs[:-1]
+        packagePath = None
+        try:
+            for d in dirs:
+                #print "imp.find_module(%s, %s)" %(repr(modName), repr(modDir))
+                f, fname, desc = imp.find_module(d, packagePath)
+                self.module = imp.load_module(d, f, fname, desc)
+                packagePath = self.module.__path__
+        except:
+            raise Exception("[HAPPYBOOM] Invalid item path : %s" %itemPath)
+        import types
+        for attr in self.module.__dict__:
+            if type(self.module.__dict__[attr]) == types.ClassType:
+                itemClass = self.module.__dict__[attr]
+                if hasattr(itemClass, "feature"):
+                    feat = getattr(itemClass, "feature")
+                    if feat != None:
+                        if feat in self.features:
+                            raise Exception("[HAPPYBOOM] Duplicated feature %s in %s and %s classes" %(feat, itemClass.__name__, self.features[feat].__name__))
+                        self.features[feat] = itemClass
+                    print "FEATURE : %s !!!!!!!!!!!!!!!!!!!!!!!" %feat
         
     def processConnection(self, ioclient, version, signature):
         self.launchEvent("happyboom", "signature", ioclient, signature)
@@ -150,56 +155,27 @@
                 pass
         self.launchEvent("happyboom", "features", ioclient, features)
         
-    def processDisconnection(self, reason):
+    def processDisconnection(self, ioclient, reason):
         self.launchEvent("happyboom", "stop", reason)
     
-    def processCreateItem(self, feature, id):
-        assert feature in self.features, "Unexpected feature"
-        classname = self.getClassnameByFeature(feature)
-        assert hasattr(self.module, classname), "Item class not found : %s" %classname
-        itemclass = getattr(self.module, classname)
-        item = itemclass(id)
-        self.items[id] = item
-        self.launchEvent(feature, "new", id)
+    def processCreateItem(self, ioclient, feature, id):
+        assert feature in self.features, "Unexpected feature : %s" %feature
+        itemClass = self.features[feature]
+        if itemClass != None:
+            item = itemClass(id)
+            self.items[id] = item
+            self.launchEvent(feature, "new", id)
     
-    def processDestroyItem(self, id):
+    def processDestroyItem(self, ioclient, id):
         assert id in self.items, "Unknown item identifier %s" %id
         self.launchEvent(feature, "delete", id)
         del self.items[id]
         
-    def processEvent(self, ioclient, feature, event, *args):
-        self.launchEvent(feature, event, *args)
-
-    def getClassnameByFeature(self, feature):
-        classname = ""
-        prefix = True
-        space = True
-        for i in range(len(feature)):
-            if feature[i] not in string.ascii_letters:
-                if prefix:
-                    classname = classname + feature[i]
-                space = True
-            else:
-                prefix = False
-                if space:
-                    classname = classname + feature[i].upper()
-                else:
-                    classname = classname + feature[i]
-        return classname
-
-#    def evt_happyboom_gamepath(self, path):
-#        self.gamepath = path
-        
-    def processCreate(self, ioclient, type, id):
-        try:
-            type = self.protocol.getFeatureById(type)
-            type = type.name
-        except ProtocolException, err:
-            log.error(err)
-            return
-        self.launchEvent("happyboom", "doCreateItem", type, id)
-
-    def processEvent(self, ioclient, feature, event, *args):       
+    def processEvent(self, ioclient, feature, event, args):
         if self.debug:
             log.info("New event: %s.%s%s" % (feature, event, args))
+        assert feature in self.features, "Unexpected feature"
         self.launchEvent(feature, event, *args)
+
+#    def evt_happyboom_gamepath(self, path):
+#        self.gamepath = path
\ No newline at end of file



From dboucard at berlios.de  Sun Sep 18 09:27:41 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 09:27:41 +0200
Subject: [Happyboom-svn] r196 - in boomboom: . curses_client curses_client/items
Message-ID: <200509180727.j8I7RfuQ031096@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 09:27:39 +0200 (Sun, 18 Sep 2005)
New Revision: 196

Added:
   boomboom/curses_client/
   boomboom/curses_client/bb_drawer_curses.py
   boomboom/curses_client/bb_input_curses.py
   boomboom/curses_client/curses_tools.py
   boomboom/curses_client/items/
   boomboom/curses_client/items/character_curses.py
   boomboom/curses_client/items/projectile_curses.py
   boomboom/curses_client/items/weapon_curses.py
   boomboom/curses_client/items/world_curses.py
Log:
separate pygame and curses clients


Copied: boomboom/curses_client/bb_drawer_curses.py (from rev 187, boomboom/client/bb_drawer_curses.py)

Copied: boomboom/curses_client/bb_input_curses.py (from rev 187, boomboom/client/bb_input_curses.py)

Copied: boomboom/curses_client/curses_tools.py (from rev 187, boomboom/client/curses_tools.py)

Copied: boomboom/curses_client/items/character_curses.py (from rev 187, boomboom/client/items/character_curses.py)

Copied: boomboom/curses_client/items/projectile_curses.py (from rev 187, boomboom/client/items/projectile_curses.py)

Copied: boomboom/curses_client/items/weapon_curses.py (from rev 187, boomboom/client/items/weapon_curses.py)

Copied: boomboom/curses_client/items/world_curses.py (from rev 187, boomboom/client/items/world_curses.py)



From dboucard at berlios.de  Sun Sep 18 09:30:21 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 09:30:21 +0200
Subject: [Happyboom-svn] r197 - in boomboom: client client/items curses_client curses_client/items
Message-ID: <200509180730.j8I7ULOG031748@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 09:30:19 +0200 (Sun, 18 Sep 2005)
New Revision: 197

Added:
   boomboom/curses_client/display.py
   boomboom/curses_client/input.py
   boomboom/curses_client/items/character.py
   boomboom/curses_client/items/projectile.py
   boomboom/curses_client/items/weapon.py
   boomboom/curses_client/items/world.py
Removed:
   boomboom/client/bb_drawer_curses.py
   boomboom/client/bb_input_curses.py
   boomboom/client/curses_tools.py
   boomboom/client/items/character_curses.py
   boomboom/client/items/projectile_curses.py
   boomboom/client/items/weapon_curses.py
   boomboom/client/items/world_curses.py
   boomboom/curses_client/bb_drawer_curses.py
   boomboom/curses_client/bb_input_curses.py
   boomboom/curses_client/items/character_curses.py
   boomboom/curses_client/items/projectile_curses.py
   boomboom/curses_client/items/weapon_curses.py
   boomboom/curses_client/items/world_curses.py
Modified:
   boomboom/client/item.py
   boomboom/client/items/character.py
   boomboom/client/items/projectile.py
   boomboom/client/items/sun.py
   boomboom/client/items/weapon.py
   boomboom/client/items/world.py
Log:
renaming curses source files


Deleted: boomboom/client/bb_drawer_curses.py
===================================================================
--- boomboom/client/bb_drawer_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/bb_drawer_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,58 +0,0 @@
-from happyboom.common.event import EventListener
-import bb_events
-import curses, time
-
-class BoomBoomDrawer(EventListener):
-    """ Manages the drawing of the screen game (double buffered) in a display loop.
-    @ivar __screen: Current drawed offscreen.
-    @type __screen: C{{Window}}
-    @ivar __frameTime: Minimum time to draw a frame.
-    @type __frameTime: C{float}
-    @ivar __items: Objects which have graphical content to draw (visual items) genered by visible item events.
-    @type __items: C{list<L{BoomBoomItem}>}
-    """
-    
-    def __init__(self, args):
-        """ BoomBoomDrawer constructor.
-        @param max_fps: Maximal number of frames per second, for optimization.
-        @type max_fps: C{int}
-        """
-        EventListener.__init__(self, prefix="evt_")
-        # Current offscreen
-        self.__screen = None
-        max_fps = args.get("max_fps", 25)
-        self.__frameTime = 1.0 / max_fps
-        self.__items = []
-        self.registerEvent("graphical")
-        self.window = args["window"]
-    
-    def start(self):
-        pass
-        
-    def mainLoop(self):
-        """ Display loop. """
-        while True:
-            live_begin = time.time()
-            
-            # Clearing screen
-            self.window.clear()
-
-            # Drawing each items
-            for item in self.__items:
-                item.draw()
-
-            # Displaying offscreen 
-            self.window.refresh()
-            
-            delay = time.time() - live_begin
-            if delay < self.__frameTime:
-                delay = self.__frameTime - delay
-                time.sleep(delay)
-        
-    def evt_graphical_item(self, item):
-        """ active item event handler.
-        @param event: Event with "graphical_item" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        if item not in self.__items:
-            self.__items.append(item)

Deleted: boomboom/client/bb_input_curses.py
===================================================================
--- boomboom/client/bb_input_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/bb_input_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,30 +0,0 @@
-from client.bb_input import BoomBoomInput as BaseInput
-import curses
-                
-class BoomBoomInput(BaseInput):
-    def __init__(self, arg):
-        BaseInput.__init__(self, arg)
-        self.window = arg["window"]
-
-    def process(self):
-        self.window.nodelay(True)
-        key = self.window.getch()
-        self.process_key(key)
-           
-    def process_key(self, key):
-        if key == -1: return
-        keyname = curses.keyname(key)
-        if keyname in ('q', 'Q'):
-            self.launchEvent("game", "stop")
-#            return
-    
-        if key == 32: # space
-            self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
-        elif key == curses.KEY_RIGHT:
-            self.weapon_setStrengthDelta(10)
-        elif key == curses.KEY_UP:
-            self.weapon_setAngleDelta(10)
-        elif key == curses.KEY_DOWN:
-            self.weapon_setAngleDelta(-10)
-        elif key == curses.KEY_LEFT:
-            self.weapon_setStrengthDelta(-10)

Deleted: boomboom/client/curses_tools.py
===================================================================
--- boomboom/client/curses_tools.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/curses_tools.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,13 +0,0 @@
-import curses
-
-def convertXY(x, y):
-    global window
-    maxy, maxx = window.getmaxyx()
-    x = int(x * maxx / 640)
-    y = int(y * maxy / 350)
-    return x, y
-
-def onLogMessage(level, prefix, message):
-    window.addstr(message+"\n")
-
-window = None

Modified: boomboom/client/item.py
===================================================================
--- boomboom/client/item.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/item.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -5,7 +5,6 @@
 @version: 0.2
 """
 from happyboom.common.event import EventListener, EventLauncher
-import pygame
 
 class Item(EventListener, EventLauncher):
     """ Generic class for representing graphical items.
@@ -153,4 +152,4 @@
         @type screen: C{L{Window<bb_drawer.Window>}}
         """
         if not self.visible: return
-        screen.blit(self.surface, (self.x, self.y))
+        screen.blit(self.surface, (self.x, self.y))
\ No newline at end of file

Modified: boomboom/client/items/character.py
===================================================================
--- boomboom/client/items/character.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/character.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -4,9 +4,8 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.item import Item, VisualObject
+from client.item import Item
 import os.path
-import pygame
 
 class Character(Item):
     """ Represents a monkey character controlled by the player.

Deleted: boomboom/client/items/character_curses.py
===================================================================
--- boomboom/client/items/character_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/character_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,20 +0,0 @@
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
-
-class Character(BoomBoomItem):
-    def __init__(self, id, name, args):
-        BoomBoomItem.__init__(self)
-        self.x, self.y = None, None
-        self.__id = id
-        self.__name = name
-        self.active = False
-        self.registerEvent("character")
-        self.window = args["window"]
-        
-    def evt_character_move(self, id, x, y):
-        if self.__id != id: return
-        self.x, self.y = convertXY(x, y)
-        
-    def draw(self):
-        if self.x == None: return
-        self.window.addstr(self.y, self.x, "Gorilla")

Modified: boomboom/client/items/projectile.py
===================================================================
--- boomboom/client/items/projectile.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/projectile.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -5,7 +5,7 @@
 @version: 0.2
 """
 #from client import bb_events
-from client.item import Item, VisualObject
+from client.item import Item
 import os.path
 
 class Projectile(Item):

Deleted: boomboom/client/items/projectile_curses.py
===================================================================
--- boomboom/client/items/projectile_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/projectile_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,40 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
-import curses
-
-class Projectile(BoomBoomItem):
-    """ Represents a banana projectile launch by the monkey.
-    @ivar visual: Graphical object containing data and transformations
-    @type visual: C{L{VisualObject}}
-    """
-    
-    def __init__(self, args):
-        """ Projectile itemp constructor. """
-        BoomBoomItem.__init__(self)
-        self.registerEvent("projectile")
-        self.window = args["window"]
-        self.x, self.y = 10,10
-        self.display = False
-
-    def draw(self):
-        if not self.display: return
-        maxy, maxx = self.window.getmaxyx()
-        if self.x < 0 or maxx < self.x: return
-        if self.y < 0 or maxy < self.y: return
-        self.window.addstr(self.y,self.x,"*")
-        
-    def evt_projectile_move(self, x, y):
-        height,width = self.window.getmaxyx()
-        self.x, self.y = convertXY(x, y)
-        
-#    def evt_projectile_hitGround(self, x, y):
-#        pass
-        
-    def evt_projectile_activate(self, state):
-        self.display = state

Modified: boomboom/client/items/sun.py
===================================================================
--- boomboom/client/items/sun.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/sun.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -4,9 +4,8 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.item import Item, VisualObject
+from client.item import Item
 import os.path
-import pygame
 
 class Sun(Item):
     """ Represents a smiling sun which makes "oh" when collided.

Modified: boomboom/client/items/weapon.py
===================================================================
--- boomboom/client/items/weapon.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/weapon.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -5,7 +5,6 @@
 @version: 0.2
 """
 from client.item import Item
-import pygame
 
 class Weapon(Item):
     """ Represents the weapon parameters controlled by the player.

Deleted: boomboom/client/items/weapon_curses.py
===================================================================
--- boomboom/client/items/weapon_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/weapon_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,74 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from client.bb_item import BoomBoomItem
-import curses 
-from client.curses_tools import convertXY
-
-class Weapon(BoomBoomItem):
-    def __init__(self, args):
-        """ Weapon item constructor. """
-        BoomBoomItem.__init__(self)
-        self.__angle = None 
-        self.__strength = None
-        self.x, self.y = (None, 10)
-        self.character_pos = {}
-        self.window = args["window"]
-        self.active_character = None
-        self.registerEvent("weapon")
-        self.registerEvent("character")
-        self.registerEvent("game")
-
-    def evt_weapon_setStrength(self, strength):
-        """ Weapon strength event handler.
-        @param event: Event with "weapon_force" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.__strength = strength
-        
-    def evt_weapon_setAngle(self, angle):
-        """ Weapon angle event handler.
-        @param event: Event with "weapon_angle" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.__angle = angle 
-
-    def evt_character_move(self, id, x, y):
-        self.character_pos[id] = (x, y,)
-        self.updateXY()
-        
-    def evt_game_setActiveCharacter(self, id):
-        """ Active character abcsisse event handler.
-        @param event: Event with "active_character_abscisse" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.active_character = id
-        self.updateXY()
-               
-    def draw(self):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        if self.__angle == None: return
-        if self.__strength == None: return
-        if self.x == None: return
-        txt = "Angle: %s" % self.__angle
-        self.window.addstr(self.y, self.x, txt)
-        txt = "Strength: %s" % self.__strength
-        self.window.addstr(self.y+1, self.x, txt)
-
-    def updateXY(self):
-        if self.active_character==None: return
-        pos = self.character_pos.get(self.active_character, None)
-        if pos == None: return
-        x, y = convertXY(pos[0], pos[1])
-        maxy,maxx = self.window.getmaxyx()
-        if x < maxx/2:
-            self.x = 1
-        else:
-            self.x = maxx - 20
-        self.y = 1

Modified: boomboom/client/items/world.py
===================================================================
--- boomboom/client/items/world.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/world.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -5,7 +5,7 @@
 @version: 0.2
 """
 from client.item import Item
-import random, pygame
+import random
 
 class Building:
     """ Represents a building which is used as plat-form in the game.

Deleted: boomboom/client/items/world_curses.py
===================================================================
--- boomboom/client/items/world_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/client/items/world_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,70 +0,0 @@
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
-
-class Building:
-    """ Represents a building which is used as plat-form in the game.
-    @ivar rect: Representation of the building.
-    @type rect: C{pygame.Rect}
-    @ivar color: Random color tuple of the building (Red, Green, Blue, Alpha).
-    @type color: C{(int, int, int, int)}
-    """
-    def __init__(self, x, y, width, height):
-        """ Building constructor.
-        @param x: Building left abscisse.
-        @type x: C{int}
-        @param y: Building top ordonnee.
-        @type y: C{int}
-        @param width: Buiding width.
-        @type width: C{int}
-        @param height: Building height.
-        @type height: C{int}
-        """
-        self.x, self.y = x,y
-        self.width, self.height = width, height
-#        self.color = None # TODO: Choose color 
-
-    def draw(self, win):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        for y in range(self.y, self.y+self.height):
-            win.addstr(y, self.x, "#" * self.width)
-        
-class World(BoomBoomItem):
-    """ Represents the ground of the game (collection of buildings).
-    @ivar __buildings: Collection of buildings.
-    @type __buildings: C{list<L{Building}>}
-    """
-    def __init__(self, args):
-        """ World item constructor. """
-        BoomBoomItem.__init__(self)
-        self.__buildings = []
-        self.registerEvent("world")
-        self.window = args["window"]
-
-    def born(self):
-        Agent.born(self)
-        self.registerAction("world")
-
-    def evt_world_create(self, data):
-        """ World create event handler.
-        @param event: Event with "world_create" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.__buildings = []
-        rects = data.split(";")
-        maxy, maxx = self.window.getmaxyx()
-        for rect in rects:
-            x, y, w, h = rect.split(",")
-            x, y = convertXY(int(x), int(y))
-            w, h = convertXY(int(w), int(h))
-            b = Building(x, y, w, h)
-            self.__buildings.append(b)
-
-    def draw(self):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        for b in self.__buildings: b.draw(self.window)

Deleted: boomboom/curses_client/bb_drawer_curses.py
===================================================================
--- boomboom/curses_client/bb_drawer_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/curses_client/bb_drawer_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,58 +0,0 @@
-from happyboom.common.event import EventListener
-import bb_events
-import curses, time
-
-class BoomBoomDrawer(EventListener):
-    """ Manages the drawing of the screen game (double buffered) in a display loop.
-    @ivar __screen: Current drawed offscreen.
-    @type __screen: C{{Window}}
-    @ivar __frameTime: Minimum time to draw a frame.
-    @type __frameTime: C{float}
-    @ivar __items: Objects which have graphical content to draw (visual items) genered by visible item events.
-    @type __items: C{list<L{BoomBoomItem}>}
-    """
-    
-    def __init__(self, args):
-        """ BoomBoomDrawer constructor.
-        @param max_fps: Maximal number of frames per second, for optimization.
-        @type max_fps: C{int}
-        """
-        EventListener.__init__(self, prefix="evt_")
-        # Current offscreen
-        self.__screen = None
-        max_fps = args.get("max_fps", 25)
-        self.__frameTime = 1.0 / max_fps
-        self.__items = []
-        self.registerEvent("graphical")
-        self.window = args["window"]
-    
-    def start(self):
-        pass
-        
-    def mainLoop(self):
-        """ Display loop. """
-        while True:
-            live_begin = time.time()
-            
-            # Clearing screen
-            self.window.clear()
-
-            # Drawing each items
-            for item in self.__items:
-                item.draw()
-
-            # Displaying offscreen 
-            self.window.refresh()
-            
-            delay = time.time() - live_begin
-            if delay < self.__frameTime:
-                delay = self.__frameTime - delay
-                time.sleep(delay)
-        
-    def evt_graphical_item(self, item):
-        """ active item event handler.
-        @param event: Event with "graphical_item" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        if item not in self.__items:
-            self.__items.append(item)

Deleted: boomboom/curses_client/bb_input_curses.py
===================================================================
--- boomboom/curses_client/bb_input_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/curses_client/bb_input_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,30 +0,0 @@
-from client.bb_input import BoomBoomInput as BaseInput
-import curses
-                
-class BoomBoomInput(BaseInput):
-    def __init__(self, arg):
-        BaseInput.__init__(self, arg)
-        self.window = arg["window"]
-
-    def process(self):
-        self.window.nodelay(True)
-        key = self.window.getch()
-        self.process_key(key)
-           
-    def process_key(self, key):
-        if key == -1: return
-        keyname = curses.keyname(key)
-        if keyname in ('q', 'Q'):
-            self.launchEvent("game", "stop")
-#            return
-    
-        if key == 32: # space
-            self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
-        elif key == curses.KEY_RIGHT:
-            self.weapon_setStrengthDelta(10)
-        elif key == curses.KEY_UP:
-            self.weapon_setAngleDelta(10)
-        elif key == curses.KEY_DOWN:
-            self.weapon_setAngleDelta(-10)
-        elif key == curses.KEY_LEFT:
-            self.weapon_setStrengthDelta(-10)

Copied: boomboom/curses_client/display.py (from rev 196, boomboom/curses_client/bb_drawer_curses.py)

Copied: boomboom/curses_client/input.py (from rev 196, boomboom/curses_client/bb_input_curses.py)

Copied: boomboom/curses_client/items/character.py (from rev 196, boomboom/curses_client/items/character_curses.py)

Deleted: boomboom/curses_client/items/character_curses.py
===================================================================
--- boomboom/curses_client/items/character_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/curses_client/items/character_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,20 +0,0 @@
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
-
-class Character(BoomBoomItem):
-    def __init__(self, id, name, args):
-        BoomBoomItem.__init__(self)
-        self.x, self.y = None, None
-        self.__id = id
-        self.__name = name
-        self.active = False
-        self.registerEvent("character")
-        self.window = args["window"]
-        
-    def evt_character_move(self, id, x, y):
-        if self.__id != id: return
-        self.x, self.y = convertXY(x, y)
-        
-    def draw(self):
-        if self.x == None: return
-        self.window.addstr(self.y, self.x, "Gorilla")

Copied: boomboom/curses_client/items/projectile.py (from rev 196, boomboom/curses_client/items/projectile_curses.py)

Deleted: boomboom/curses_client/items/projectile_curses.py
===================================================================
--- boomboom/curses_client/items/projectile_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/curses_client/items/projectile_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,40 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
-import curses
-
-class Projectile(BoomBoomItem):
-    """ Represents a banana projectile launch by the monkey.
-    @ivar visual: Graphical object containing data and transformations
-    @type visual: C{L{VisualObject}}
-    """
-    
-    def __init__(self, args):
-        """ Projectile itemp constructor. """
-        BoomBoomItem.__init__(self)
-        self.registerEvent("projectile")
-        self.window = args["window"]
-        self.x, self.y = 10,10
-        self.display = False
-
-    def draw(self):
-        if not self.display: return
-        maxy, maxx = self.window.getmaxyx()
-        if self.x < 0 or maxx < self.x: return
-        if self.y < 0 or maxy < self.y: return
-        self.window.addstr(self.y,self.x,"*")
-        
-    def evt_projectile_move(self, x, y):
-        height,width = self.window.getmaxyx()
-        self.x, self.y = convertXY(x, y)
-        
-#    def evt_projectile_hitGround(self, x, y):
-#        pass
-        
-    def evt_projectile_activate(self, state):
-        self.display = state

Copied: boomboom/curses_client/items/weapon.py (from rev 196, boomboom/curses_client/items/weapon_curses.py)

Deleted: boomboom/curses_client/items/weapon_curses.py
===================================================================
--- boomboom/curses_client/items/weapon_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/curses_client/items/weapon_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,74 +0,0 @@
-"""
- at author: Victor Stinner and Damien Boucard
- at license: Gnu/GPL v2 or later, see LICENSE file.
- at contact: See U{http://developer.berlios.de/projects/happyboom/}
- at version: 0.2
-"""
-from client.bb_item import BoomBoomItem
-import curses 
-from client.curses_tools import convertXY
-
-class Weapon(BoomBoomItem):
-    def __init__(self, args):
-        """ Weapon item constructor. """
-        BoomBoomItem.__init__(self)
-        self.__angle = None 
-        self.__strength = None
-        self.x, self.y = (None, 10)
-        self.character_pos = {}
-        self.window = args["window"]
-        self.active_character = None
-        self.registerEvent("weapon")
-        self.registerEvent("character")
-        self.registerEvent("game")
-
-    def evt_weapon_setStrength(self, strength):
-        """ Weapon strength event handler.
-        @param event: Event with "weapon_force" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.__strength = strength
-        
-    def evt_weapon_setAngle(self, angle):
-        """ Weapon angle event handler.
-        @param event: Event with "weapon_angle" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.__angle = angle 
-
-    def evt_character_move(self, id, x, y):
-        self.character_pos[id] = (x, y,)
-        self.updateXY()
-        
-    def evt_game_setActiveCharacter(self, id):
-        """ Active character abcsisse event handler.
-        @param event: Event with "active_character_abscisse" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.active_character = id
-        self.updateXY()
-               
-    def draw(self):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        if self.__angle == None: return
-        if self.__strength == None: return
-        if self.x == None: return
-        txt = "Angle: %s" % self.__angle
-        self.window.addstr(self.y, self.x, txt)
-        txt = "Strength: %s" % self.__strength
-        self.window.addstr(self.y+1, self.x, txt)
-
-    def updateXY(self):
-        if self.active_character==None: return
-        pos = self.character_pos.get(self.active_character, None)
-        if pos == None: return
-        x, y = convertXY(pos[0], pos[1])
-        maxy,maxx = self.window.getmaxyx()
-        if x < maxx/2:
-            self.x = 1
-        else:
-            self.x = maxx - 20
-        self.y = 1

Copied: boomboom/curses_client/items/world.py (from rev 196, boomboom/curses_client/items/world_curses.py)

Deleted: boomboom/curses_client/items/world_curses.py
===================================================================
--- boomboom/curses_client/items/world_curses.py	2005-09-18 07:27:39 UTC (rev 196)
+++ boomboom/curses_client/items/world_curses.py	2005-09-18 07:30:19 UTC (rev 197)
@@ -1,70 +0,0 @@
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
-
-class Building:
-    """ Represents a building which is used as plat-form in the game.
-    @ivar rect: Representation of the building.
-    @type rect: C{pygame.Rect}
-    @ivar color: Random color tuple of the building (Red, Green, Blue, Alpha).
-    @type color: C{(int, int, int, int)}
-    """
-    def __init__(self, x, y, width, height):
-        """ Building constructor.
-        @param x: Building left abscisse.
-        @type x: C{int}
-        @param y: Building top ordonnee.
-        @type y: C{int}
-        @param width: Buiding width.
-        @type width: C{int}
-        @param height: Building height.
-        @type height: C{int}
-        """
-        self.x, self.y = x,y
-        self.width, self.height = width, height
-#        self.color = None # TODO: Choose color 
-
-    def draw(self, win):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        for y in range(self.y, self.y+self.height):
-            win.addstr(y, self.x, "#" * self.width)
-        
-class World(BoomBoomItem):
-    """ Represents the ground of the game (collection of buildings).
-    @ivar __buildings: Collection of buildings.
-    @type __buildings: C{list<L{Building}>}
-    """
-    def __init__(self, args):
-        """ World item constructor. """
-        BoomBoomItem.__init__(self)
-        self.__buildings = []
-        self.registerEvent("world")
-        self.window = args["window"]
-
-    def born(self):
-        Agent.born(self)
-        self.registerAction("world")
-
-    def evt_world_create(self, data):
-        """ World create event handler.
-        @param event: Event with "world_create" type.
-        @type event: C{L{common.simple_event.Event}}
-        """
-        self.__buildings = []
-        rects = data.split(";")
-        maxy, maxx = self.window.getmaxyx()
-        for rect in rects:
-            x, y, w, h = rect.split(",")
-            x, y = convertXY(int(x), int(y))
-            w, h = convertXY(int(w), int(h))
-            b = Building(x, y, w, h)
-            self.__buildings.append(b)
-
-    def draw(self):
-        """ Drawing method called by C{BoomBoomDrawer}
-        @param screen: Offscreen to draw in.
-        @type screen: C{L{Window<bb_drawer.Window>}}
-        """
-        for b in self.__buildings: b.draw(self.window)



From dboucard at berlios.de  Sun Sep 18 09:32:33 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 09:32:33 +0200
Subject: [Happyboom-svn] r198 - boomboom/curses_client
Message-ID: <200509180732.j8I7WXXC032274@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 09:32:30 +0200 (Sun, 18 Sep 2005)
New Revision: 198

Added:
   boomboom/curses_client/client.py
   boomboom/curses_client/generic_input.py
   boomboom/curses_client/item.py
Log:
copying pygame files to curses dir (for adaptation)


Added: boomboom/curses_client/client.py
===================================================================
--- boomboom/curses_client/client.py	2005-09-18 07:30:19 UTC (rev 197)
+++ boomboom/curses_client/client.py	2005-09-18 07:32:30 UTC (rev 198)
@@ -0,0 +1,95 @@
+"""
+ at author: Victor Stinner and Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 0.2
+"""
+from happyboom.common.event import EventListener
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+from happyboom.common import protocol
+from happyboom.client.base_client import Client as Happyboom
+from display import Display
+from input import Input
+import thread, time
+import curses_tools
+
+class Client(Happyboom, EventListener):
+    """ The main class of the client of BoomBoom.
+    @ivar display: Display manager of the game.
+    @type display: C{L{BoomBoomDisplay}}
+    @ivar input: Input manager of the game.
+    @type input: C{L{BoomBoomInput}}
+    @ivar __verbose: Verbose mode flag.
+    @type __verbose: C{bool}
+    @ivar __stopped: Stopped game flag.
+    @type __stopped: C{bool}
+    @ivar __stoplock: Mutex for synchronizing __stopped.
+    @type __stoplock: C{thread.lock}
+    """
+    
+    def __init__(self, args):
+        """ BoomBoomClient constructor.
+        @param host: Server hostname.
+        @type host: C{str}
+        @param display_port: Server port for "display"/"view" connection.
+        @type display_port: C{int}
+        @param input_port: Server port for "input" connection.
+        @type input_port: C{int}
+        @param verbose: Verbose mode flag.
+        @type verbose: C{bool}
+        @param debug: Debug mode flag.
+        @type debug: C{bool}
+        @param max_fps: Maximal number of frames per second, for optimization.
+        @type max_fps: C{int}
+        """
+        args["protocol"] = protocol.loadProtocol("protocol.xml")
+        args["features"] = ["game"] # Constant features
+        
+        Happyboom.__init__(self, args)
+        EventListener.__init__(self, prefix="evt_")
+        
+        self.display = Display(args)
+        self.input = Input(args)
+        self.__verbose = args.get("verbose", False)
+        self.registerEvent("happyboom")
+        
+    def start(self):
+        """ Starts the game client."""
+        if self.__verbose:
+            log.info("[BOOMBOOM] Starting client...")
+        Happyboom.start(self)
+        # Create thread for display
+        thread.start_new_thread(self.displayThread, ())
+        
+        quit = False
+        while not quit:
+            self.input.process()
+            time.sleep(0.100)
+            quit = self.stopped
+        
+    def stop(self):
+        """  Stops the game client."""
+        if self.__verbose:
+            log.info("[BOOMBOOM] Stopping client...")
+        Happyboom.stop(self)
+        self.launchEvent("happyboom", "disconnection", self._io, u"Quit.")
+        self.display.stop()
+    
+    def evt_happyboom_stop(self):
+        """ Stop event handler.
+        """
+        self.stop()
+    
+    def displayThread(self):
+        """ Thread handler for the "display" part."""
+        try:
+            self.display.start()
+        except Exception, msg:
+            bt = getBacktrace()
+            log.error("EXCEPTION IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))
+        try:
+            self.stop()
+        except Exception, msg:
+            bt = getBacktrace()
+            log.error("EXCEPTION (2) IN DISPLAY THREAD:\n%s\n%s" % (msg, bt))

Added: boomboom/curses_client/generic_input.py
===================================================================
--- boomboom/curses_client/generic_input.py	2005-09-18 07:30:19 UTC (rev 197)
+++ boomboom/curses_client/generic_input.py	2005-09-18 07:32:30 UTC (rev 198)
@@ -0,0 +1,69 @@
+"""
+ at author: Victor Stinner and Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 0.2
+"""
+from happyboom.common.event import EventLauncher, EventListener
+import thread, time
+
+class Input(EventLauncher, EventListener):
+    """ Class which manages "input" part of the network connections.
+    @ivar host: Server hostname.
+    @type host: C{str}
+    @ivar port: Server port for "input" connection.
+    @type port: C{int}
+    @ivar name: Name of the client (as known by the server).
+    @type name: C{str}
+    @ivar __protocol_version: Current version of the protocol used by the client.
+    @type __protocol_version: C{str}
+    @ivar __io: Network input/output object using UDP protocole.
+    @type __io: C{net.io_udp.IO_UDP}
+    @ivar __recv_buffer: Network data reception buffer.
+    @type __recv_buffer: C{net.net_buffer.NetBuffer}
+    @ivar __verbose: Verbose mode flag.
+    @type __verbose: C{bool}
+    @ivar __debug: Debug mode flag.
+    @type __debug: C{bool}
+    @ivar __stopped: Stopped input client flag.
+    @type __stopped: C{bool}
+    @ivar __stoplock: Mutex for synchronizing __stopped.
+    @type __stoplock: C{thread.lock}
+    """
+    
+    def __init__(self, arg):
+        """ BoomBoomInput constructor.
+        @param host: Server hostname.
+        @type host: C{str}
+        @param port: Server port for "input" connection.
+        @type port: C{int}
+        @param name: Name of the client (as known by the server).
+        @type name: C{string}
+        @param verbose: Verbose mode flag.
+        @type verbose: C{bool}
+        @param debug: Debug mode flag.
+        @type debug: C{bool}
+        """
+
+        EventLauncher.__init__(self)
+        EventListener.__init__(self)
+        self.weapon_angle = None
+        self.weapon_strength = None
+        self.registerEvent("weapon")
+
+    def evt_weapon_setStrength(self, strength):
+        self.weapon_strength = strength
+        
+    def evt_weapon_setAngle(self, angle):
+        self.weapon_angle = angle
+
+    def weapon_setStrengthDelta(self, delta):
+        self.launchEvent("happyboom", "network", \
+            "weapon", "askSetStrength", self.weapon_strength + delta)
+
+    def weapon_setAngleDelta(self, delta):
+        self.launchEvent("happyboom", "network", \
+            "weapon", "askSetAngle", self.weapon_angle + delta)
+
+    def process(self):
+        pass

Added: boomboom/curses_client/item.py
===================================================================
--- boomboom/curses_client/item.py	2005-09-18 07:30:19 UTC (rev 197)
+++ boomboom/curses_client/item.py	2005-09-18 07:32:30 UTC (rev 198)
@@ -0,0 +1,155 @@
+"""
+ at author: Victor Stinner and Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 0.2
+"""
+from happyboom.common.event import EventListener, EventLauncher
+
+class Item(EventListener, EventLauncher):
+    """ Generic class for representing graphical items.
+    @ivar visual: Graphical object containing data and transformations
+    @type visual: C{L{VisualObject}}
+    """
+    
+    feature = None
+    
+    def __init__(self, id=None):
+        """ BoomBoomItem constructor. """
+        EventListener.__init__(self, "evt_")
+        EventLauncher.__init__(self)
+        self.visual = None
+        self.launchEvent("graphical", "item", self)
+        self.id = id
+        
+    def draw(self, screen):
+        """ Drawing method called by C{BoomBoomDrawer}
+        @param screen: Offscreen to draw in.
+        @type screen: C{L{Window<bb_drawer.Window>}}
+        """
+        if self.visual == None: return
+        self.visual.draw(screen)
+    
+    def sendNetMsg(self, feature, event, *args):
+        print "SEND NET %s" % (feature)
+        self.launchEvent("happyboom", "network", \
+            feature, event, *args)
+
+class VisualObject(object):
+    """ Manage representation and transformation of an external image to be drawn into game screen.
+    @ivar visible: Visibility item flag (Default: C{True}).
+    @type visible: C{bool}
+    @ivar surface: Pygame item surface object.
+    @type surface: C{pygame.Surface}
+    @type rect: C{pygame.Rect}
+    @type x: C{int}
+    @type y: C{int}
+    @type width: C{int}
+    @type height: C{int}
+    @ivar __x: Item top-left abcsisse.
+    @type __x: C{int}
+    @ivar __y: Item top-left ordonnee.
+    @type __y: C{int}
+    @ivar __width: Item width.
+    @type __width: C{int}
+    @ivar __height: Item height.
+    @type __height. C{int}
+    @ivar __rect: Including box of the item for collide detection.
+    @type __rect: C{pygame.Rect}
+    """
+    def __init__(self, file):
+        """ VisualObject constructor.
+        @param file: Path of the external image.
+        @type file: C{str}
+        """
+        self.__x, self.__y = (0,0)
+        self.loadImage(file)
+        self.visible = True
+
+    def loadImage(self, file):
+        """ Loads external image with pygame.
+        @param file: Path of the external image.
+        @type file: C{str}
+        """
+        self.surface = pygame.image.load(file).convert_alpha()
+        self.__width = self.surface.get_width()
+        self.__height = self.surface.get_height()
+        self.__rect = pygame.Rect( [self.__x, self.__y, self.__width, self.__height] )
+
+    def move(self, x, y):
+        """ Moves the items in absolute coordinates.
+        @param x: New abcsisse.
+        @type x: C{int}
+        @param y: New ordonnee.
+        @type y: C{int}
+        """
+        self.__x = x
+        self.__y = y
+        self.__rect = pygame.Rect( [self.__x, self.__y, self.__width, self.__height] )
+
+    def __getRect(self):
+        """ C{L{rect}} property getter.
+        @return: The including box of the item.
+        @rtype: C{pygame.Rect}
+        """
+        return self.__rect
+    rect = property(__getRect, doc="Including box of the item for collide detection (read only).")
+    
+    def __getHeight(self):
+        """ C{L{height}} property getter.
+        @return: The height of the item.
+        @rtype: C{int}
+        """
+        return self.__height
+    height = property(__getHeight, doc="Item height (read only).")
+    
+    def __getWidth(self):
+        """ C{L{width}} property getter.
+        @return: The width of the item.
+        @rtype: C{int}
+        """
+        return self.__width
+    width = property(__getWidth, doc="Item width (read only).")
+    
+    def __getX(self):
+        """ C{L{x}} property getter.
+        @return: The left abcsisse ot the item.
+        @rtype: C{int}
+        """
+        return self.__x
+    def __setX(self, x):
+        """ C{L{x}} property setter.
+        @param x: New item abcsisse.
+        @type x: C{int}
+        """
+        self.move(x, self.__y)
+    x = property(__getX, __setX, doc="Item top-left abcsisse.")
+    
+    def __getY(self):
+        """ C{L{y}} property getter.
+        @return: The top ordonnee ot the item.
+        @rtype: C{int}
+        """
+        return self.__y
+    def __setY(self, y):
+        """ C{L{y}} property setter.
+        @param y: New item ordonnee.
+        @type y: C{int}
+        """
+        self.move(self.__x, y)
+    y = property(__getY, __setY, doc="Item top-left ordonnee.")
+
+    def setVisibility(self, visible):
+        """ Sets the visibility of the item.
+        @param visible: New visible flag value.
+        @type visible: C{bool}
+        """
+        self.visible = visible
+        
+    def draw(self, screen):
+        """ Draws the image (if visible) into the game offscreen.
+        @param screen: Current game offscreen to draw in.
+        @type screen: C{L{Window<bb_drawer.Window>}}
+        """
+        if not self.visible: return
+        screen.blit(self.surface, (self.x, self.y))
\ No newline at end of file



From dboucard at berlios.de  Sun Sep 18 09:41:28 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 09:41:28 +0200
Subject: [Happyboom-svn] r199 - in boomboom/curses_client: . items
Message-ID: <200509180741.j8I7fStM001903@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 09:41:27 +0200 (Sun, 18 Sep 2005)
New Revision: 199

Added:
   boomboom/curses_client/__init__.py
   boomboom/curses_client/items/__init__.py
   boomboom/curses_client/items/log.py
Log:


Added: boomboom/curses_client/__init__.py
===================================================================
--- boomboom/curses_client/__init__.py	2005-09-18 07:32:30 UTC (rev 198)
+++ boomboom/curses_client/__init__.py	2005-09-18 07:41:27 UTC (rev 199)
@@ -0,0 +1,5 @@
+from client import Client
+from display import Display
+from input import Input
+from item import Item
+import items

Added: boomboom/curses_client/items/__init__.py
===================================================================
--- boomboom/curses_client/items/__init__.py	2005-09-18 07:32:30 UTC (rev 198)
+++ boomboom/curses_client/items/__init__.py	2005-09-18 07:41:27 UTC (rev 199)
@@ -0,0 +1,6 @@
+from sun import Sun
+from projectile import Projectile
+from weapon import Weapon
+from world import World
+from character import Character
+from log import LogItem

Added: boomboom/curses_client/items/log.py
===================================================================
--- boomboom/curses_client/items/log.py	2005-09-18 07:32:30 UTC (rev 198)
+++ boomboom/curses_client/items/log.py	2005-09-18 07:41:27 UTC (rev 199)
@@ -0,0 +1,18 @@
+from client.item import Item
+from happyboom.common.log import log
+
+class LogItem(Item):
+    feature = "log"
+    
+    def __init__(self, id):
+        Item.__init__(self, id)
+        self.registerEvent("log")
+        
+    def evt_log_info(self, text):
+        log.info(u"[Server Log][info] %s" % text)
+        
+    def evt_log_warning(self, text):
+        log.info(u"[Server Log][warn] %s" % text)
+        
+    def evt_log_error(self, text):
+        log.info(u"[Server Log][err!] %s" % text)



From dboucard at berlios.de  Sun Sep 18 09:41:48 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 09:41:48 +0200
Subject: [Happyboom-svn] r200 - boomboom/curses_client/items
Message-ID: <200509180741.j8I7fmW3002036@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 09:41:48 +0200 (Sun, 18 Sep 2005)
New Revision: 200

Modified:
   boomboom/curses_client/items/__init__.py
Log:


Modified: boomboom/curses_client/items/__init__.py
===================================================================
--- boomboom/curses_client/items/__init__.py	2005-09-18 07:41:27 UTC (rev 199)
+++ boomboom/curses_client/items/__init__.py	2005-09-18 07:41:48 UTC (rev 200)
@@ -1,4 +1,3 @@
-from sun import Sun
 from projectile import Projectile
 from weapon import Weapon
 from world import World



From dboucard at berlios.de  Sun Sep 18 09:46:34 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 09:46:34 +0200
Subject: [Happyboom-svn] r201 - in boomboom/client: . items
Message-ID: <200509180746.j8I7kYaQ004022@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 09:46:31 +0200 (Sun, 18 Sep 2005)
New Revision: 201

Modified:
   boomboom/client/item.py
   boomboom/client/items/character.py
   boomboom/client/items/projectile.py
   boomboom/client/items/sun.py
   boomboom/client/items/weapon.py
   boomboom/client/items/world.py
Log:
revert pygame interface modifications


Modified: boomboom/client/item.py
===================================================================
--- boomboom/client/item.py	2005-09-18 07:41:48 UTC (rev 200)
+++ boomboom/client/item.py	2005-09-18 07:46:31 UTC (rev 201)
@@ -5,6 +5,7 @@
 @version: 0.2
 """
 from happyboom.common.event import EventListener, EventLauncher
+import pygame
 
 class Item(EventListener, EventLauncher):
     """ Generic class for representing graphical items.

Modified: boomboom/client/items/character.py
===================================================================
--- boomboom/client/items/character.py	2005-09-18 07:41:48 UTC (rev 200)
+++ boomboom/client/items/character.py	2005-09-18 07:46:31 UTC (rev 201)
@@ -4,7 +4,7 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.item import Item
+from client.item import Item, VisualObject
 import os.path
 
 class Character(Item):

Modified: boomboom/client/items/projectile.py
===================================================================
--- boomboom/client/items/projectile.py	2005-09-18 07:41:48 UTC (rev 200)
+++ boomboom/client/items/projectile.py	2005-09-18 07:46:31 UTC (rev 201)
@@ -5,7 +5,7 @@
 @version: 0.2
 """
 #from client import bb_events
-from client.item import Item
+from client.item import Item, VisualObject
 import os.path
 
 class Projectile(Item):

Modified: boomboom/client/items/sun.py
===================================================================
--- boomboom/client/items/sun.py	2005-09-18 07:41:48 UTC (rev 200)
+++ boomboom/client/items/sun.py	2005-09-18 07:46:31 UTC (rev 201)
@@ -4,8 +4,8 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.item import Item
-import os.path
+from client.item import Item, VisualObject
+import os.path, pygame
 
 class Sun(Item):
     """ Represents a smiling sun which makes "oh" when collided.

Modified: boomboom/client/items/weapon.py
===================================================================
--- boomboom/client/items/weapon.py	2005-09-18 07:41:48 UTC (rev 200)
+++ boomboom/client/items/weapon.py	2005-09-18 07:46:31 UTC (rev 201)
@@ -5,6 +5,7 @@
 @version: 0.2
 """
 from client.item import Item
+import pygame
 
 class Weapon(Item):
     """ Represents the weapon parameters controlled by the player.

Modified: boomboom/client/items/world.py
===================================================================
--- boomboom/client/items/world.py	2005-09-18 07:41:48 UTC (rev 200)
+++ boomboom/client/items/world.py	2005-09-18 07:46:31 UTC (rev 201)
@@ -5,7 +5,7 @@
 @version: 0.2
 """
 from client.item import Item
-import random
+import random, pygame
 
 class Building:
     """ Represents a building which is used as plat-form in the game.



From dboucard at berlios.de  Sun Sep 18 11:28:19 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 11:28:19 +0200
Subject: [Happyboom-svn] r202 - in boomboom: . curses_client curses_client/items
Message-ID: <200509180928.j8I9SJj3024337@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 11:28:18 +0200 (Sun, 18 Sep 2005)
New Revision: 202

Modified:
   boomboom/boomboom_client.py
   boomboom/curses_client/curses_tools.py
   boomboom/curses_client/display.py
   boomboom/curses_client/input.py
   boomboom/curses_client/items/character.py
   boomboom/curses_client/items/log.py
   boomboom/curses_client/items/projectile.py
   boomboom/curses_client/items/weapon.py
   boomboom/curses_client/items/world.py
Log:
curses client works


Modified: boomboom/boomboom_client.py
===================================================================
--- boomboom/boomboom_client.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/boomboom_client.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -64,8 +64,7 @@
             val["debug"] = True
     return val
 
-def run(arg):
-    from client import Client
+def run(Client, arg):
     from happyboom.common.log import log
     
     client = Client(arg)
@@ -78,10 +77,12 @@
 
 def run_curses(stdscr, args):
     from happyboom.common.log import log
+    from curses_client import Client
     try:
         args["window"] = stdscr
+        args["item_path"] = "curses_client/items"
         stdscr.scrollok(True)
-        run(args)
+        run(Client, args)
     except Exception, err:
         log.error("Uncatched error in run_curses: %s" % err)
         raise
@@ -122,7 +123,8 @@
         log.info("Start client with pygame.")
         import pygame
         pygame.init()
-        run(arg)
+        from client import Client
+        run(Client, arg)
         pygame.quit()
     else:
         log.info("Start client with curses.")

Modified: boomboom/curses_client/curses_tools.py
===================================================================
--- boomboom/curses_client/curses_tools.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/curses_tools.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -1,7 +1,7 @@
 import curses
 
-def convertXY(x, y):
-    global window
+def convertXY(window, x, y):
+    #global window
     maxy, maxx = window.getmaxyx()
     x = int(x * maxx / 640)
     y = int(y * maxy / 350)

Modified: boomboom/curses_client/display.py
===================================================================
--- boomboom/curses_client/display.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/display.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -1,8 +1,8 @@
 from happyboom.common.event import EventListener
-import bb_events
-import curses, time
+from happyboom.common.log import log
+import curses, time, thread, item
 
-class BoomBoomDrawer(EventListener):
+class Display(EventListener):
     """ Manages the drawing of the screen game (double buffered) in a display loop.
     @ivar __screen: Current drawed offscreen.
     @type __screen: C{{Window}}
@@ -25,21 +25,44 @@
         self.__items = []
         self.registerEvent("graphical")
         self.window = args["window"]
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        self.__itemlock = thread.allocate_lock()
     
     def start(self):
-        pass
+        self.mainLoop()
         
+    def stop(self):
+        """ Stops the display loop. """
+        # Does not stop several times
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return False
+        self.__stopped = True
+        self.__stoplock.release()
+        
     def mainLoop(self):
         """ Display loop. """
-        while True:
+        while not self.stopped:
             live_begin = time.time()
             
             # Clearing screen
             self.window.clear()
 
             # Drawing each items
-            for item in self.__items:
-                item.draw()
+            items = self.getItems()
+            for item in items[:]:
+                if item.__class__.__name__ == "Projectile":
+                    item.draw(self.window)
+                    items.remove(item)
+            for item in items[:]:
+                if item.__class__.__name__ == "Character":
+                    item.draw(self.window)
+                    items.remove(item)
+            for item in items[:]:
+                item.draw(self.window)
+                items.remove(item)
 
             # Displaying offscreen 
             self.window.refresh()
@@ -55,4 +78,21 @@
         @type event: C{L{common.simple_event.Event}}
         """
         if item not in self.__items:
-            self.__items.append(item)
+            self.addItem(item)
+            
+    def __isStopped(self):
+        self.__stoplock.acquire()
+        stop = self.__stopped
+        self.__stoplock.release()
+        return stop
+    stopped = property(__isStopped)
+    
+    def getItems(self):
+        self.__itemlock.acquire()
+        items = self.__items[:]
+        self.__itemlock.release()
+        return items
+    def addItem(self, item):
+        self.__itemlock.acquire()
+        self.__items.append(item)
+        self.__itemlock.release()
\ No newline at end of file

Modified: boomboom/curses_client/input.py
===================================================================
--- boomboom/curses_client/input.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/input.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -1,7 +1,7 @@
-from client.bb_input import BoomBoomInput as BaseInput
+from generic_input import Input as BaseInput
 import curses
                 
-class BoomBoomInput(BaseInput):
+class Input(BaseInput):
     def __init__(self, arg):
         BaseInput.__init__(self, arg)
         self.window = arg["window"]
@@ -19,7 +19,7 @@
 #            return
     
         if key == 32: # space
-            self.launchEvent("happyboom", "netSendMsg", "weapon", "shoot")
+            self.launchEvent("happyboom", "network", "weapon", "shoot")
         elif key == curses.KEY_RIGHT:
             self.weapon_setStrengthDelta(10)
         elif key == curses.KEY_UP:

Modified: boomboom/curses_client/items/character.py
===================================================================
--- boomboom/curses_client/items/character.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/items/character.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -1,20 +1,23 @@
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
+from curses_client.item import Item
+from curses_client.curses_tools import convertXY
 
-class Character(BoomBoomItem):
-    def __init__(self, id, name, args):
-        BoomBoomItem.__init__(self)
+class Character(Item):
+    feature = "character"
+    
+    def __init__(self, id):
+        Item.__init__(self)
         self.x, self.y = None, None
         self.__id = id
-        self.__name = name
+        self.__name = "unamed%s"%id
         self.active = False
         self.registerEvent("character")
-        self.window = args["window"]
         
     def evt_character_move(self, id, x, y):
         if self.__id != id: return
-        self.x, self.y = convertXY(x, y)
+        self.x, self.y = (x, y)
         
-    def draw(self):
+    def draw(self, screen):
         if self.x == None: return
-        self.window.addstr(self.y, self.x, "Gorilla")
+        x, y = convertXY(screen, int(self.x), int(self.y))
+        screen.addstr(y, x, " oo")
+        screen.addstr(y+1, x, "(ww)"+" "*screen.getmaxyx()[1])

Modified: boomboom/curses_client/items/log.py
===================================================================
--- boomboom/curses_client/items/log.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/items/log.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -1,4 +1,4 @@
-from client.item import Item
+from curses_client.item import Item
 from happyboom.common.log import log
 
 class LogItem(Item):

Modified: boomboom/curses_client/items/projectile.py
===================================================================
--- boomboom/curses_client/items/projectile.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/items/projectile.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -4,34 +4,34 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
+from curses_client.item import Item
+from curses_client.curses_tools import convertXY
 import curses
 
-class Projectile(BoomBoomItem):
+class Projectile(Item):
     """ Represents a banana projectile launch by the monkey.
     @ivar visual: Graphical object containing data and transformations
     @type visual: C{L{VisualObject}}
     """
+    feature = "projectile"
     
-    def __init__(self, args):
+    def __init__(self, id):
         """ Projectile itemp constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self)
         self.registerEvent("projectile")
-        self.window = args["window"]
         self.x, self.y = 10,10
         self.display = False
 
-    def draw(self):
+    def draw(self, screen):
         if not self.display: return
-        maxy, maxx = self.window.getmaxyx()
-        if self.x < 0 or maxx < self.x: return
-        if self.y < 0 or maxy < self.y: return
-        self.window.addstr(self.y,self.x,"*")
+        maxy, maxx = screen.getmaxyx()
+        x, y = convertXY(screen, int(self.x), int(self.y))
+        if x < 0 or maxx < x: return
+        if y < 0 or maxy < y: return
+        screen.addstr(y,x,")"+" "*maxx)
         
     def evt_projectile_move(self, x, y):
-        height,width = self.window.getmaxyx()
-        self.x, self.y = convertXY(x, y)
+        self.x, self.y = (x, y)
         
 #    def evt_projectile_hitGround(self, x, y):
 #        pass

Modified: boomboom/curses_client/items/weapon.py
===================================================================
--- boomboom/curses_client/items/weapon.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/items/weapon.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -4,23 +4,24 @@
 @contact: See U{http://developer.berlios.de/projects/happyboom/}
 @version: 0.2
 """
-from client.bb_item import BoomBoomItem
+from curses_client.item import Item
+from curses_client.curses_tools import convertXY
+from happyboom.common.log import log
 import curses 
-from client.curses_tools import convertXY
 
-class Weapon(BoomBoomItem):
-    def __init__(self, args):
+class Weapon(Item):
+    feature = "weapon"
+    
+    def __init__(self, id):
         """ Weapon item constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self)
         self.__angle = None 
         self.__strength = None
         self.x, self.y = (None, 10)
         self.character_pos = {}
-        self.window = args["window"]
         self.active_character = None
         self.registerEvent("weapon")
         self.registerEvent("character")
-        self.registerEvent("game")
 
     def evt_weapon_setStrength(self, strength):
         """ Weapon strength event handler.
@@ -40,7 +41,7 @@
         self.character_pos[id] = (x, y,)
         self.updateXY()
         
-    def evt_game_setActiveCharacter(self, id):
+    def evt_character_activate(self, id):
         """ Active character abcsisse event handler.
         @param event: Event with "active_character_abscisse" type.
         @type event: C{L{common.simple_event.Event}}
@@ -48,7 +49,7 @@
         self.active_character = id
         self.updateXY()
                
-    def draw(self):
+    def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}
         @param screen: Offscreen to draw in.
         @type screen: C{L{Window<bb_drawer.Window>}}
@@ -56,19 +57,22 @@
         if self.__angle == None: return
         if self.__strength == None: return
         if self.x == None: return
+        maxy,maxx = screen.getmaxyx()
+        x, y = convertXY(screen, self.x, self.y)
+        if x < maxx/2:
+            x = 1
+        else:
+            x = maxx - 20
+        y = 1
+        log.info("x=%s, y=%s" %(x, y))
         txt = "Angle: %s" % self.__angle
-        self.window.addstr(self.y, self.x, txt)
+        screen.addstr(y, x, txt)
         txt = "Strength: %s" % self.__strength
-        self.window.addstr(self.y+1, self.x, txt)
+        screen.addstr(y+1, x, txt)
 
     def updateXY(self):
         if self.active_character==None: return
         pos = self.character_pos.get(self.active_character, None)
         if pos == None: return
-        x, y = convertXY(pos[0], pos[1])
-        maxy,maxx = self.window.getmaxyx()
-        if x < maxx/2:
-            self.x = 1
-        else:
-            self.x = maxx - 20
-        self.y = 1
+        self.x, self.y = pos
+        

Modified: boomboom/curses_client/items/world.py
===================================================================
--- boomboom/curses_client/items/world.py	2005-09-18 07:46:31 UTC (rev 201)
+++ boomboom/curses_client/items/world.py	2005-09-18 09:28:18 UTC (rev 202)
@@ -1,5 +1,5 @@
-from client.bb_item import BoomBoomItem
-from client.curses_tools import convertXY
+from curses_client.item import Item
+from curses_client.curses_tools import convertXY
 
 class Building:
     """ Represents a building which is used as plat-form in the game.
@@ -23,25 +23,28 @@
         self.width, self.height = width, height
 #        self.color = None # TODO: Choose color 
 
-    def draw(self, win):
+    def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}
         @param screen: Offscreen to draw in.
         @type screen: C{L{Window<bb_drawer.Window>}}
         """
-        for y in range(self.y, self.y+self.height):
-            win.addstr(y, self.x, "#" * self.width)
+        x, y = convertXY(screen, int(self.x), int(self.y))
+        w, h = convertXY(screen, int(self.width), int(self.height))
+        for line in range(y, y+h):
+            screen.addstr(line, x, "#" * w)
         
-class World(BoomBoomItem):
+class World(Item):
     """ Represents the ground of the game (collection of buildings).
     @ivar __buildings: Collection of buildings.
     @type __buildings: C{list<L{Building}>}
     """
-    def __init__(self, args):
+    feature = "world"
+    
+    def __init__(self, id):
         """ World item constructor. """
-        BoomBoomItem.__init__(self)
+        Item.__init__(self)
         self.__buildings = []
         self.registerEvent("world")
-        self.window = args["window"]
 
     def born(self):
         Agent.born(self)
@@ -54,17 +57,17 @@
         """
         self.__buildings = []
         rects = data.split(";")
-        maxy, maxx = self.window.getmaxyx()
+        #maxy, maxx = self.window.getmaxyx()
         for rect in rects:
             x, y, w, h = rect.split(",")
-            x, y = convertXY(int(x), int(y))
-            w, h = convertXY(int(w), int(h))
+            #x, y = convertXY(int(x), int(y))
+            #w, h = convertXY(int(w), int(h))
             b = Building(x, y, w, h)
             self.__buildings.append(b)
 
-    def draw(self):
+    def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}
         @param screen: Offscreen to draw in.
         @type screen: C{L{Window<bb_drawer.Window>}}
         """
-        for b in self.__buildings: b.draw(self.window)
+        for b in self.__buildings: b.draw(screen)



From dboucard at berlios.de  Sun Sep 18 11:41:12 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 11:41:12 +0200
Subject: [Happyboom-svn] r203 - happyboom/trunk/client
Message-ID: <200509180941.j8I9fCfg026417@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 11:41:10 +0200 (Sun, 18 Sep 2005)
New Revision: 203

Modified:
   happyboom/trunk/client/base_client.py
Log:
removes dummy prints


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-18 09:28:18 UTC (rev 202)
+++ happyboom/trunk/client/base_client.py	2005-09-18 09:41:10 UTC (rev 203)
@@ -142,7 +142,6 @@
                         if feat in self.features:
                             raise Exception("[HAPPYBOOM] Duplicated feature %s in %s and %s classes" %(feat, itemClass.__name__, self.features[feat].__name__))
                         self.features[feat] = itemClass
-                    print "FEATURE : %s !!!!!!!!!!!!!!!!!!!!!!!" %feat
         
     def processConnection(self, ioclient, version, signature):
         self.launchEvent("happyboom", "signature", ioclient, signature)



From dboucard at berlios.de  Sun Sep 18 12:22:23 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 12:22:23 +0200
Subject: [Happyboom-svn] r204 - in boomboom/curses_client: . items
Message-ID: <200509181022.j8IAMNKg032357@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 12:22:23 +0200 (Sun, 18 Sep 2005)
New Revision: 204

Modified:
   boomboom/curses_client/display.py
   boomboom/curses_client/items/character.py
   boomboom/curses_client/items/projectile.py
   boomboom/curses_client/items/weapon.py
   boomboom/curses_client/items/world.py
Log:
adding color support for curses client


Modified: boomboom/curses_client/display.py
===================================================================
--- boomboom/curses_client/display.py	2005-09-18 09:41:10 UTC (rev 203)
+++ boomboom/curses_client/display.py	2005-09-18 10:22:23 UTC (rev 204)
@@ -44,6 +44,8 @@
         
     def mainLoop(self):
         """ Display loop. """
+        for i in range(1,7):
+            curses.init_pair(i, i, curses.COLOR_BLACK)
         while not self.stopped:
             live_begin = time.time()
             

Modified: boomboom/curses_client/items/character.py
===================================================================
--- boomboom/curses_client/items/character.py	2005-09-18 09:41:10 UTC (rev 203)
+++ boomboom/curses_client/items/character.py	2005-09-18 10:22:23 UTC (rev 204)
@@ -19,5 +19,5 @@
     def draw(self, screen):
         if self.x == None: return
         x, y = convertXY(screen, int(self.x), int(self.y))
-        screen.addstr(y, x, " oo")
-        screen.addstr(y+1, x, "(ww)"+" "*screen.getmaxyx()[1])
+        screen.addstr(y, x, "oo")
+        screen.addstr(y+1, x-1, "(ww)"+" "*screen.getmaxyx()[1])

Modified: boomboom/curses_client/items/projectile.py
===================================================================
--- boomboom/curses_client/items/projectile.py	2005-09-18 09:41:10 UTC (rev 203)
+++ boomboom/curses_client/items/projectile.py	2005-09-18 10:22:23 UTC (rev 204)
@@ -28,7 +28,7 @@
         x, y = convertXY(screen, int(self.x), int(self.y))
         if x < 0 or maxx < x: return
         if y < 0 or maxy < y: return
-        screen.addstr(y,x,")"+" "*maxx)
+        screen.addstr(y,x,")"+" "*maxx, curses.color_pair(curses.COLOR_YELLOW))
         
     def evt_projectile_move(self, x, y):
         self.x, self.y = (x, y)

Modified: boomboom/curses_client/items/weapon.py
===================================================================
--- boomboom/curses_client/items/weapon.py	2005-09-18 09:41:10 UTC (rev 203)
+++ boomboom/curses_client/items/weapon.py	2005-09-18 10:22:23 UTC (rev 204)
@@ -6,7 +6,6 @@
 """
 from curses_client.item import Item
 from curses_client.curses_tools import convertXY
-from happyboom.common.log import log
 import curses 
 
 class Weapon(Item):
@@ -64,7 +63,6 @@
         else:
             x = maxx - 20
         y = 1
-        log.info("x=%s, y=%s" %(x, y))
         txt = "Angle: %s" % self.__angle
         screen.addstr(y, x, txt)
         txt = "Strength: %s" % self.__strength

Modified: boomboom/curses_client/items/world.py
===================================================================
--- boomboom/curses_client/items/world.py	2005-09-18 09:41:10 UTC (rev 203)
+++ boomboom/curses_client/items/world.py	2005-09-18 10:22:23 UTC (rev 204)
@@ -1,5 +1,6 @@
 from curses_client.item import Item
 from curses_client.curses_tools import convertXY
+import random, curses
 
 class Building:
     """ Represents a building which is used as plat-form in the game.
@@ -21,17 +22,19 @@
         """
         self.x, self.y = x,y
         self.width, self.height = width, height
-#        self.color = None # TODO: Choose color 
+        self.color = None
 
     def draw(self, screen):
         """ Drawing method called by C{BoomBoomDrawer}
         @param screen: Offscreen to draw in.
         @type screen: C{L{Window<bb_drawer.Window>}}
         """
+        if self.color == None:
+            self.color = random.randint(0, 6)
         x, y = convertXY(screen, int(self.x), int(self.y))
         w, h = convertXY(screen, int(self.width), int(self.height))
         for line in range(y, y+h):
-            screen.addstr(line, x, "#" * w)
+            screen.addstr(line, x, "#" * w, curses.color_pair(self.color))
         
 class World(Item):
     """ Represents the ground of the game (collection of buildings).



From dboucard at berlios.de  Sun Sep 18 12:50:23 2005
From: dboucard at berlios.de (Damien Boucard at BerliOS)
Date: Sun, 18 Sep 2005 12:50:23 +0200
Subject: [Happyboom-svn] r205 - boomboom/client
Message-ID: <200509181050.j8IAoN4l026743@sheep.berlios.de>

Author: dboucard
Date: 2005-09-18 12:50:19 +0200 (Sun, 18 Sep 2005)
New Revision: 205

Modified:
   boomboom/client/display.py
Log:
oups, sun has been forgotten


Modified: boomboom/client/display.py
===================================================================
--- boomboom/client/display.py	2005-09-18 10:22:23 UTC (rev 204)
+++ boomboom/client/display.py	2005-09-18 10:50:19 UTC (rev 205)
@@ -7,6 +7,7 @@
 from happyboom.common.happyboom_protocol import HappyboomProtocol as Presentation
 from happyboom.common.log import log
 from happyboom.common.event import EventListener
+from items import Sun
 import thread, pygame, time
 
 class Display(EventListener):
@@ -52,6 +53,7 @@
         """ Creates game window and starts display loop. """
         self._screen = Window(640, 350)
         self._screen.background_color = (0, 0, 168)
+        Sun()
         self.mainLoop()
         
     def stop(self):



From haypo at berlios.de  Mon Sep 19 15:43:59 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 19 Sep 2005 15:43:59 +0200
Subject: [Happyboom-svn] r206 - in happyboom/trunk: client common
Message-ID: <200509191343.j8JDhx0f019300@sheep.berlios.de>

Author: haypo
Date: 2005-09-19 15:43:59 +0200 (Mon, 19 Sep 2005)
New Revision: 206

Modified:
   happyboom/trunk/client/base_client.py
   happyboom/trunk/common/log.py
Log:
Fix log class (error display [err!] prefix), and client catchs more ProtocolException.


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-18 10:50:19 UTC (rev 205)
+++ happyboom/trunk/client/base_client.py	2005-09-19 13:43:59 UTC (rev 206)
@@ -44,7 +44,10 @@
         self.stop()
 
     def evt_happyboom_network(self, feature, event, *args):
-        self.launchEvent("happyboom", "event", (self._io,), feature, event, args)
+        try:
+            self.launchEvent("happyboom", "event", (self._io,), feature, event, args)
+        except ProtocolException, msg:
+            log.error("Protocol error: %s" % msg)
 
     def start(self):
         """ Starts the client : connection to the server, etc. """
@@ -150,7 +153,8 @@
             try:
                 feature = self.protocol.getFeature(name)
                 features = features + "%c" % feature.id
-            except ProtocolException:
+            except ProtocolException, msg:
+                log.warning("Protocol exception: %s" % msg)
                 pass
         self.launchEvent("happyboom", "features", ioclient, features)
         
@@ -177,4 +181,4 @@
         self.launchEvent(feature, event, *args)
 
 #    def evt_happyboom_gamepath(self, path):
-#        self.gamepath = path
\ No newline at end of file
+#        self.gamepath = path

Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-18 10:50:19 UTC (rev 205)
+++ happyboom/trunk/common/log.py	2005-09-19 13:43:59 UTC (rev 206)
@@ -88,6 +88,6 @@
         New error message.
         @type str: C{str}
         """
-        self.new_message(Log.LOG_WARN, str)
+        self.new_message(Log.LOG_ERROR, str)
 
 log = Log()        



From haypo at berlios.de  Mon Sep 19 16:02:01 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 19 Sep 2005 16:02:01 +0200
Subject: [Happyboom-svn] r207 - in happyboom/trunk: client net/io_tcp
Message-ID: <200509191402.j8JE216e020713@sheep.berlios.de>

Author: haypo
Date: 2005-09-19 16:02:01 +0200 (Mon, 19 Sep 2005)
New Revision: 207

Modified:
   happyboom/trunk/client/base_client.py
   happyboom/trunk/net/io_tcp/tcp_client.py
Log:
Ajoute un "socket." oublie pour une SocketError.


Modified: happyboom/trunk/client/base_client.py
===================================================================
--- happyboom/trunk/client/base_client.py	2005-09-19 13:43:59 UTC (rev 206)
+++ happyboom/trunk/client/base_client.py	2005-09-19 14:02:01 UTC (rev 207)
@@ -45,6 +45,8 @@
 
     def evt_happyboom_network(self, feature, event, *args):
         try:
+            if self.debug:
+                log.info("Send event: %s.%s%s" % (feature, event, args))
             self.launchEvent("happyboom", "event", (self._io,), feature, event, args)
         except ProtocolException, msg:
             log.error("Protocol error: %s" % msg)

Modified: happyboom/trunk/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-19 13:43:59 UTC (rev 206)
+++ happyboom/trunk/net/io_tcp/tcp_client.py	2005-09-19 14:02:01 UTC (rev 207)
@@ -30,7 +30,7 @@
         if not self.connected: return
         try:
             self.__socket.send(data)
-        except SocketError, err:
+        except socket.SocketError, err:
             # Broken pipe (32) or Connection reset by peer (104)
             if err[0] in (32, 104,):
                 self.disconnect()



From haypo at berlios.de  Mon Sep 19 22:09:07 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 19 Sep 2005 22:09:07 +0200
Subject: [Happyboom-svn] r208 - happyboom/trunk
Message-ID: <200509192009.j8JK975m012368@sheep.berlios.de>

Author: haypo
Date: 2005-09-19 22:09:06 +0200 (Mon, 19 Sep 2005)
New Revision: 208

Added:
   happyboom/trunk/happyboom/
Log:
Initial import.



From haypo at berlios.de  Mon Sep 19 22:18:43 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 19 Sep 2005 22:18:43 +0200
Subject: [Happyboom-svn] r210 - in happyboom/trunk: . common
Message-ID: <200509192018.j8JKIhja013631@sheep.berlios.de>

Author: haypo
Date: 2005-09-19 22:18:42 +0200 (Mon, 19 Sep 2005)
New Revision: 210

Removed:
   happyboom/trunk/happyboom/
Modified:
   happyboom/trunk/common/generic_event.py
   happyboom/trunk/common/log.py
   happyboom/trunk/common/presentation.py
   happyboom/trunk/makedoc.sh
Log:
Corrige la documentation et vire le happyboom en doublon.


Modified: happyboom/trunk/common/generic_event.py
===================================================================
--- happyboom/trunk/common/generic_event.py	2005-09-19 20:14:42 UTC (rev 209)
+++ happyboom/trunk/common/generic_event.py	2005-09-19 20:18:42 UTC (rev 210)
@@ -97,10 +97,10 @@
         @type prefix: C{str}
         @param suffix: Suffix for all event-specific handler function name.
         @type suffix: C{str}
-        @param event_default: Default handler function name.
-        @type event_default: C{str}
-        @param event_silent: Silent flag.
-        @type event_silent: C{bool}
+        @param default: Default handler function name.
+        @type default: C{str}
+        @param silent: Silent flag.
+        @type silent: C{bool}
         """
         self.event_manager = EventManager.instance
         self.event_pattern = prefix + "%s" + suffix

Modified: happyboom/trunk/common/log.py
===================================================================
--- happyboom/trunk/common/log.py	2005-09-19 20:14:42 UTC (rev 209)
+++ happyboom/trunk/common/log.py	2005-09-19 20:18:42 UTC (rev 210)
@@ -43,7 +43,7 @@
         if level==Log.LOG_ERROR: return "[err!]"
         return "[info]"
 
-    def new_message(self, level, str):
+    def newMessage(self, level, str):
         """
         Write a new message : append it in the buffer,
         display it to the screen (if needed), and write
@@ -74,20 +74,20 @@
         New informative message.
         @type str: C{str}
         """
-        self.new_message(Log.LOG_INFO, str)
+        self.newMessage(Log.LOG_INFO, str)
 
     def warning(self, str):
         """
         New warning message.
         @type str: C{str}
         """
-        self.new_message(Log.LOG_WARN, str)
+        self.newMessage(Log.LOG_WARN, str)
 
     def error(self, str):
         """
         New error message.
         @type str: C{str}
         """
-        self.new_message(Log.LOG_ERROR, str)
+        self.newMessage(Log.LOG_ERROR, str)
 
 log = Log()        

Modified: happyboom/trunk/common/presentation.py
===================================================================
--- happyboom/trunk/common/presentation.py	2005-09-19 20:14:42 UTC (rev 209)
+++ happyboom/trunk/common/presentation.py	2005-09-19 20:18:42 UTC (rev 210)
@@ -62,16 +62,16 @@
     def evt_happyboom_closeConnection(self, ioclient, reason):
         """
         Close client connection.
-        @type ioclient L{IOClient}
-        @type reason Unicode
+        @type ioclient: L{IOClient}
+        @type reason: C{unicode}
         """
         self.evt_happyboom_disconnection(ioclient, reason)
 
     def evt_happyboom_connection(self, ioclient, version=None, signature=""):
         """
         Send a connection message to ioclient.
-        @type version ASCII string
-        @type signature string
+        @type version: str
+        @type signature: str
         """
         if version == None:
             version = self.protocol.version
@@ -83,8 +83,8 @@
     def evt_happyboom_disconnection(self, ioclient, reason):
         """
         Send a disconnection message to ioclient.
-        @type ioclient L{IOClient}
-        @type reason Unicode
+        @type ioclient: L{IOClient}
+        @type reason: unicode
         """
         
         if self.verbose:
@@ -128,4 +128,4 @@
     def packFeatures(self, features): return ""
     def packCreateItem(self, feature, id): return ""
     def packDestroyItem(self, id): return ""
-    def packEvent(self, feature, event, args): return ""
\ No newline at end of file
+    def packEvent(self, feature, event, args): return ""

Modified: happyboom/trunk/makedoc.sh
===================================================================
--- happyboom/trunk/makedoc.sh	2005-09-19 20:14:42 UTC (rev 209)
+++ happyboom/trunk/makedoc.sh	2005-09-19 20:18:42 UTC (rev 210)
@@ -1,7 +1,7 @@
 #!/bin/sh
 test -e doc || mkdir doc
 epydoc \
-    -o doc/api
+    -o doc/api \
     -n "HappyBoom game engine 0.2" \
     --private-css blue \
     common net server



From haypo at berlios.de  Tue Sep 20 00:16:40 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 20 Sep 2005 00:16:40 +0200
Subject: [Happyboom-svn] r211 - in boomboom: client curses_client curses_client/items
Message-ID: <200509192216.j8JMGeHC024159@sheep.berlios.de>

Author: haypo
Date: 2005-09-20 00:16:40 +0200 (Tue, 20 Sep 2005)
New Revision: 211

Modified:
   boomboom/client/client.py
   boomboom/curses_client/client.py
   boomboom/curses_client/items/projectile.py
Log:
Client attrape game.stop(), le projectile n'est pas dessine s'il sort de
l'ecran.


Modified: boomboom/client/client.py
===================================================================
--- boomboom/client/client.py	2005-09-19 20:18:42 UTC (rev 210)
+++ boomboom/client/client.py	2005-09-19 22:16:40 UTC (rev 211)
@@ -52,7 +52,8 @@
         self.display = Display(args)
         self.input = Input(args)
         self.__verbose = args.get("verbose", False)
-        self.registerEvent("happyboom")
+        self.registerEvent("happyboom")        
+        self.registerEvent("game")
         
     def start(self):
         """ Starts the game client."""
@@ -76,6 +77,9 @@
         self.launchEvent("happyboom", "disconnection", self._io, u"Quit.")
         self.display.stop()
     
+    def evt_game_stop(self):        
+        self.stop()
+        
     def evt_happyboom_stop(self):
         """ Stop event handler.
         """

Modified: boomboom/curses_client/client.py
===================================================================
--- boomboom/curses_client/client.py	2005-09-19 20:18:42 UTC (rev 210)
+++ boomboom/curses_client/client.py	2005-09-19 22:16:40 UTC (rev 211)
@@ -53,6 +53,7 @@
         self.input = Input(args)
         self.__verbose = args.get("verbose", False)
         self.registerEvent("happyboom")
+        self.registerEvent("game")        
         
     def start(self):
         """ Starts the game client."""
@@ -75,7 +76,10 @@
         Happyboom.stop(self)
         self.launchEvent("happyboom", "disconnection", self._io, u"Quit.")
         self.display.stop()
-    
+        
+    def evt_game_stop(self):
+        self.stop()
+        
     def evt_happyboom_stop(self):
         """ Stop event handler.
         """

Modified: boomboom/curses_client/items/projectile.py
===================================================================
--- boomboom/curses_client/items/projectile.py	2005-09-19 20:18:42 UTC (rev 210)
+++ boomboom/curses_client/items/projectile.py	2005-09-19 22:16:40 UTC (rev 211)
@@ -26,8 +26,8 @@
         if not self.display: return
         maxy, maxx = screen.getmaxyx()
         x, y = convertXY(screen, int(self.x), int(self.y))
-        if x < 0 or maxx < x: return
-        if y < 0 or maxy < y: return
+        if x < 0 or maxx <= x: return
+        if y < 0 or maxy <= y: return
         screen.addstr(y,x,")"+" "*maxx, curses.color_pair(curses.COLOR_YELLOW))
         
     def evt_projectile_move(self, x, y):



From haypo at berlios.de  Tue Sep 20 00:19:00 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 20 Sep 2005 00:19:00 +0200
Subject: [Happyboom-svn] r212 - in happyboom/trunk/net: io io_udp
Message-ID: <200509192219.j8JMJ0mK024612@sheep.berlios.de>

Author: haypo
Date: 2005-09-20 00:19:00 +0200 (Tue, 20 Sep 2005)
New Revision: 212

Modified:
   happyboom/trunk/net/io/packet.py
   happyboom/trunk/net/io_udp/udp.py
   happyboom/trunk/net/io_udp/udp_ping.py
Log:
Supprime Packet.writeStr()

Modified: happyboom/trunk/net/io/packet.py
===================================================================
--- happyboom/trunk/net/io/packet.py	2005-09-19 22:16:40 UTC (rev 211)
+++ happyboom/trunk/net/io/packet.py	2005-09-19 22:19:00 UTC (rev 212)
@@ -43,15 +43,6 @@
     PACKET_PONG = 3
     PACKET_ACK = 4
 
-    def __str__(self):
-        txt = "Packet <type=%u, " % (self.type)
-        if self.__data:
-            txt = txt+"data=\"%s\"" % (self.__data)
-        else:
-            txt = txt+"no data"            
-        if self.skippable: txt = txt+", skippable"
-        return txt+">"
-
     def __init__(self, str=None, skippable=False):
         """ Constructor.
         @parameter str: String data.
@@ -60,14 +51,22 @@
         @type skippable: C{bool}
         """
         self.sent = 0
-        self.__data = None
         self.timeout = None
         self.skippable = skippable
         self.id = None
         self.type = Packet.PACKET_DATA
         self.recv_from = None
         self.__valid = True
-        if str != None: self.writeStr(str)
+        self.__data = str        
+            
+    def __str__(self):
+        txt = "Packet <type=%u, " % (self.type)
+        if self.__data:
+            txt = txt+"data=\"%s\"" % (self.__data)
+        else:
+            txt = txt+"no data"            
+        if self.skippable: txt = txt+", skippable"
+        return txt+">"
 
     def isValid(self):
         """ After unpack, say if the packet is valid or not.
@@ -153,13 +152,6 @@
             data = data + struct.pack("!%us" % data_len, self.__data)
         return data
         
-    def writeStr(self, str):
-        """ Write a sting into packet (still used ???) """
-        if self.__data == None:
-            self.__data = str
-        else:
-            self.__data = self.__data + str
-        
     def prepareSend(self):
         """ Prepare the packet before it will be send : set timeout and send counter. """
         self.timeout = time.time()+Packet.timeout

Modified: happyboom/trunk/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/net/io_udp/udp.py	2005-09-19 22:16:40 UTC (rev 211)
+++ happyboom/trunk/net/io_udp/udp.py	2005-09-19 22:19:00 UTC (rev 212)
@@ -6,6 +6,7 @@
 import traceback
 import struct
 from net.io.base_io import BaseIO
+from net.io.packet import Packet
 from udp_client import UDP_Client
 from happyboom.common.log import log
 from happyboom.common.thread import getBacktrace
@@ -82,7 +83,7 @@
         self.__socket.setblocking(0)
 
         if not self.__is_server:
-            self.send( io.Packet("I'm here") )
+            self.send( Packet("I'm here") )
         
         BaseIO.connect(self, host, port)
 
@@ -270,7 +271,7 @@
         if self.on_receive != None: self.on_receive(data)
                     
         # Decode data to normal packet (unpack) 
-        packet = io.Packet()
+        packet = Packet()
         packet.unpack(data)
         if not packet.isValid():
             if self.debug:
@@ -291,13 +292,13 @@
         if not packet.skippable: self.__sendAck(packet)
         
         # Is is a special packet (ack / ping / poing) ?
-        if packet.type == io.Packet.PACKET_ACK:
+        if packet.type == Packet.PACKET_ACK:
             client.processAck(packet)
             return None
-        if packet.type == io.Packet.PACKET_PING:
+        if packet.type == Packet.PACKET_PING:
             client.processPing(packet)
             return None
-        if packet.type == io.Packet.PACKET_PONG:
+        if packet.type == Packet.PACKET_PONG:
             client.processPong(packet)
             return None
             
@@ -314,18 +315,18 @@
 
     def __sendAck(self, packet):
         """ Send an ack for a packet.
-        @type packet: C{L{Packet<io.Packet>}}
+        @type packet: C{L{Packet}}
         """
         # Write ack to socket
-        ack = io.Packet(skippable=True)
-        ack.type = io.Packet.PACKET_ACK
-        ack.writeStr( struct.pack("!I", packet.id) )
-        #if self.debug: log.info("Send ACK %u." % ack.id)
+        data = struct.pack("!I", packet.id)
+        ack = Packet(data)
+        ack.type = Packet.PACKET_ACK
+        ack.skippable = True        
         packet.recv_from.send(ack)
 
     def __processNewPacket(self, packet):
         """ Do something with a new packet
-        @type packet: C{L{Packet<io.Packet>}}
+        @type packet: C{L{Packet}}
         """
         if self.verbose:
             log.info("New udp message : %s" % packet.toStr())

Modified: happyboom/trunk/net/io_udp/udp_ping.py
===================================================================
--- happyboom/trunk/net/io_udp/udp_ping.py	2005-09-19 22:16:40 UTC (rev 211)
+++ happyboom/trunk/net/io_udp/udp_ping.py	2005-09-19 22:19:00 UTC (rev 212)
@@ -1,6 +1,6 @@
 import time
 import struct
-from net import io
+from net.io.packet import Packet
 from happyboom.common.log import log
 
 class UDP_Ping:
@@ -24,9 +24,9 @@
 
     def getPacket(self):
         """ Create a network packet containing the ping. """
-        ping = io.Packet()
+        data = struct.pack("!I", self.id)
+        ping = io.Packet(data)
         ping.type = io.Packet.PACKET_PING
-        ping.writeStr( struct.pack("!I", self.id) )
         return ping    
 
 class UDP_Pinger:
@@ -102,9 +102,9 @@
         """ Process ping : send pong.
         @type packet: C{L{Packet<io.Packet>}}
         """
-        pong = io.Packet(skippable=True)
-        pong.type = io.Packet.PACKET_PONG
-        pong.writeStr( packet.data )
+        pong = Packet( packet.data )
+        pong.type = Packet.PACKET_PONG
+        pong.skippable = True        
         self.client.send(pong)
         
     def processPong(self, packet):



From haypo at berlios.de  Tue Sep 20 00:53:35 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 20 Sep 2005 00:53:35 +0200
Subject: [Happyboom-svn] r213 - happyboom/trunk/specification
Message-ID: <200509192253.j8JMrZZh020610@sheep.berlios.de>

Author: haypo
Date: 2005-09-20 00:53:33 +0200 (Tue, 20 Sep 2005)
New Revision: 213

Added:
   happyboom/trunk/specification/happyboom_communication.dia
Log:
Ajout du schema de la communication cote serveur.


Added: happyboom/trunk/specification/happyboom_communication.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/specification/happyboom_communication.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From haypo at berlios.de  Wed Sep 21 05:28:27 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 21 Sep 2005 05:28:27 +0200
Subject: [Happyboom-svn] r215 - / haypo
Message-ID: <200509210328.j8L3SRrn023775@sheep.berlios.de>

Author: haypo
Date: 2005-09-21 05:28:26 +0200 (Wed, 21 Sep 2005)
New Revision: 215

Added:
   haypo/
   haypo/apache_log.py
   haypo/evolution_set_smtp.py
Log:
Add apache_log and evolution_set_stmp scripts.


Added: haypo/apache_log.py
===================================================================
--- haypo/apache_log.py	2005-09-19 23:01:57 UTC (rev 214)
+++ haypo/apache_log.py	2005-09-21 03:28:26 UTC (rev 215)
@@ -0,0 +1,223 @@
+#
+# Python script to parse Apache log file
+# 21 septembre 2005
+# Author: Victor Stinner
+#
+
+import re, time, sys, traceback
+
+class ApacheLogParser:
+    def __init__(self):
+        # String like "abc" or "a\"bc" or just ""
+        match_string = r"\"((?:[^\"]+|\\\")*)\""
+
+        # Regex matching one line
+        regex  = r"^([^ ]+) " # Origin
+        regex += r"([^ ]+) " # Host
+        regex += r"([a-z]+|-) " # User
+        regex += r"\[([^]]+)\] " # Date
+        regex += r"\"(POST|GET|HEAD) ([^ ]+) HTTP/1\.[01]\" " # Method, Url 
+        regex += r"([0-9]{3}) ([0-9]+|-) " # Code, Size
+        regex += match_string+" " # Referrer
+        
+        match_string = r"\"([^\"]*)\""
+        regex += match_string+"$" # Browser string
+        
+        self._regex = re.compile(regex)
+        print "Pattern: %s" % self._regex.pattern
+        self.handler = self.processLine
+
+    def processLine(self, line_number, line, info):
+        print "Line %u: %s %s" % (line_number, info["method"], info["url"])
+
+    def parseLine(self, line_number, line):
+        try:
+            print "LINE %u ========= %s =======" % (line_number, line)
+            print "Regex."
+            m = self._regex.search(line)
+            if m == None:
+                print "Can't parse line %u:\n%s" % (line_number, line)
+                return
+            print "Assign."
+            origin, host, user, date, method, url, code, size, referrer, browser = m.groups()
+            kw = { \
+                "origin": origin,
+                "host": host,
+                "user": user,
+                "date": date,
+                "method": method,
+                "url": url,
+                "code": int(code),
+                "size": size,
+                "referrer": referrer,
+                "browser": browser}
+            print "Handler."
+            self.handler(line_number, line, kw)
+            print "Done."
+        except KeyboardInterrupt:
+            print "Interrupt line: %s" % line
+            raise
+
+    def parseFile(self, filename):
+        f = open(filename, "r")
+
+        data = f.read()
+        data = data.split("\n")
+        if data[-1]=="": del data[-1]
+        
+        line_number = 1
+        print "Load file %s ..." % filename
+        try:
+            nb_lines = len(data)
+            t = time.time()
+            for line in data:
+                if 40800<line_number: #0.3 < time.time() - t:
+                    t = time.time()
+                    progress = int( (line_number-1)*100/nb_lines )
+                    print "Progress: %s%% (%u on %u) - %s" % (progress, line_number, nb_lines, line)
+                self.parseLine(line_number, line)
+                line_number += 1
+            print "File loaded."
+        except KeyboardInterrupt:
+            print "Load interrupted (CTRL+C)."
+            traceback.print_exc()
+            sys.exit(1)
+
+    def result(self):
+        return self.origin
+
+class ApacheLogParser_Stat(ApacheLogParser):
+    def __init__(self, host):
+        ApacheLogParser.__init__(self)
+        self.host = host
+        self.regex_host = re.compile("^"+host+"(.*)$")
+        self.stat_page = {}
+        self.stat_referrer = {}
+        self.ignore_handler = None
+        
+    def hit(self, attr, key):
+        if key in attr:
+            attr[key] = attr[key] + 1
+        else:
+            attr[key] = 1
+
+    def processLine(self, line_number, line, info):
+        url = info["url"]
+        code = info["code"]
+        referrer = info["referrer"]
+        
+        # Clean url (remove hostname)
+        m = self.regex_host.match(url)
+        if m != None:
+            url = "/"+m.group(1)
+
+        # Ignore this hit?
+#        if self.ignore_handler:
+#            if self.ignore_handler(info)==True: return
+
+        # Page hit stat
+        if code not in [302, 404]:
+            self.hit(self.stat_page, url)
+            if referrer != "-":
+                self.hit(self.stat_referrer, referrer)
+
+    def _sort_value(self, val1, val2):
+        if val1 > val2:
+            return -1
+        elif val1 == val2:
+            return 0
+        else:
+            return 1
+
+    def _sort_stat_referrer(self, key1, key2):
+        return self._sort_value(self.stat_referrer[key1],  self.stat_referrer[key2])
+
+    def _sort_stat_page(self, key1, key2):
+        return self._sort_value(self.stat_page[key1],  self.stat_page[key2])
+
+    def getTopReferrer(self, max=30, ignores=[]):
+        return self.getTop(self.stat_referrer, self._sort_stat_referrer, max, ignores)
+        
+    def getTopPage(self, max=30, ignores=[]):
+        return self.getTop(self.stat_page, self._sort_stat_page, max, ignores)
+        
+    def getTop(self, attr, sort_func, max=30, ignores=[]):
+        keys = attr.keys()
+        keys.sort(sort_func)
+        top = []
+        cpt = 1
+        for key in keys:
+            ok = True
+            for ignore in ignores:
+                m = ignore.search(key)
+                if m != None:
+                    ok = False
+                    break
+            if ok:
+                top.append( (attr[key], key,) )
+                cpt += 1
+                if max < cpt: break
+        return top
+
+def printTopPage(r, max):
+    # Top pages
+    pages = r.getTopPage(max)
+    for page in pages:
+        print "%u hit(s): %s" % (page[0], page[1])
+
+# Regex google hosts
+def googleHosts():        
+    return ["216\.239\.59\.104", \
+        "66\.249\.93\.104", "66.102.9.104", \
+        "216.109.124.98", "(images|www)\.google\.(fr|com)"]
+
+def yahooHosts():
+    return ["[a-z]+.search.yahoo.com"]
+
+def printTopReferrer(r, max):
+    # Top pages
+    pages = r.getTopReferrer(max)
+    for page in pages:
+        print "%u hit(s): %s" % (page[0], page[1])
+
+class HaypoCALC:
+    def __init__(self):
+        hosts = ["(www\.)?haypocalc\.com"] # Haypocalc
+        hosts += googleHosts()
+        hosts += yahooHosts()
+        self.ignore_referrer = [ re.compile(r"^http://("+"|".join(hosts)+")")  ]
+
+        self.ignore_url = []
+        end = r"(\?.*)?$"
+        ignore_ext = ["css", "jpg", "JPG", "png", "js", "gif", "swf"]
+        ignore_ext = "|".join(ignore_ext)
+        self.ignore_url.append( re.compile(r"\.("+ignore_ext+r")"+end) )
+        self.ignore_url.append( re.compile(r"^/wiki/index.php\?.*&action=raw") )
+        self.ignore_url.append( re.compile(r"^/robots\.txt$") )
+
+    def ignoreHandler(self, info):
+        referrer = info["referrer"]
+        for regex in self.ignore_referrer:
+            if regex.search(referrer) != None: return True
+        return False
+
+def usage():
+    print "Usage: %s filename" % (sys.argv[0])
+
+def main():
+    try:
+        if len(sys.argv)<2:
+            usage()
+            sys.exit(1)
+        h=HaypoCALC()
+        filename = sys.argv[1]
+        r=ApacheLogParser_Stat("haypocalc.com")
+        r.ignore_handler = h.ignoreHandler
+        r.parseFile(filename)
+    #    printTopPage(r, 10)
+        printTopReferrer(r, 100)
+    except KeyboardInterrupt:
+        print "Program interrupted (CTRL+C)."
+        
+
+if __name__=="__main__": main()    

Added: haypo/evolution_set_smtp.py
===================================================================
--- haypo/evolution_set_smtp.py	2005-09-19 23:01:57 UTC (rev 214)
+++ haypo/evolution_set_smtp.py	2005-09-21 03:28:26 UTC (rev 215)
@@ -0,0 +1,102 @@
+#
+# Set SMTP server in Evolution configuration using gconftool-2 tool
+# and parser XML files (from gconf).
+# Author: Victor Stinner
+# 15 august 2005
+#
+
+import os, sys, re
+
+def getAccounts():
+	out = os.popen("gconftool-2 --get /apps/evolution/mail/accounts")
+	raw = out.read()
+	
+	data = raw[1:-3]
+	data = data.split("\n")
+
+	accounts = []
+	for i in range(0,len(data)-1,2):
+		if 0 < i:
+			accounts.append( data[i][1:] + data[i+1] )
+		else:
+			accounts.append( data[i] + data[i+1] )
+	
+	return (raw, accounts,)
+	
+def changeSmtp(content, new_smtp_url):
+	import xml.dom.minidom
+	doc = xml.dom.minidom.parseString(content)
+	transports = doc.getElementsByTagName("transport")
+	urls = transports[0].getElementsByTagName("url")
+	urls[0].childNodes[0].data = new_smtp_url
+	return doc.toxml("UTF-8")
+
+def extractXmlHeader(content):
+	r = re.compile(r'^(<\?xml version="1\.0" encoding="UTF-8"\?>)\n(.*)$')
+	m = r.match(content)
+	if m == None:
+		print "Erreur XML pour %s" % (content)
+		sys.exit(1)
+	return (m.group(1), m.group(2), )
+
+def escape(text):
+	import re
+	text = re.sub(r"([\"'\\])", r"\\\1", text)
+#	text = text.replace("\n", "\\\\n")
+#	text = text.replace("\r", "\\\\r")
+	return text 
+	
+def saveAccounts(accounts):
+	key = "/apps/evolution/mail/accounts"
+	cmd  = "/usr/bin/gconftool-2 "
+	cmd += "--type=list "
+	cmd += "--list-type=string "
+	cmd += "--set /apps/evolution/mail/accounts "
+	cmd += '"'+escape(accounts)+'"'
+	stdin, stdout, stderr = os.popen3(cmd)
+	err = stderr.read()
+	if err != "":
+		print "Erreur :\n%s" % (err)
+		sys.exit(1)
+
+def convertAccounts(accounts):
+	old_accounts = accounts
+	accounts = []
+	for account in old_accounts:
+		accounts.append( extractXmlHeader(account) )
+		
+	out = "["+accounts[0][0]+"\n"+accounts[0][1]
+	del accounts[0]
+	for account in accounts:
+		out = out + "\n,"+account[0]+"\n"+account[1]
+	out = out + "\n]"
+	return out
+
+def backupAccounts(raw):
+	f = open("/home/haypo/1backup/evolution_old_accounts.yyy", "w")
+	f.write(raw)
+	f.close()
+
+def main():
+	if len(sys.argv)<2:
+		print "Usage: %s SERVER" % sys.argv[0]
+		sys.exit(1)
+	smtp = sys.argv[1]
+    email = "victor.stinner%40utbm.fr"
+
+	try:
+		print "Set Evolution STMP to %s." % (smtp)
+		
+		url = "smtp://"+email+"@"+smtp+"/;use_ssl=never"	
+		raw, accounts = getAccounts()
+#		backupAccounts(raw)
+		for i in range(len(accounts)):
+			accounts[i] = changeSmtp(accounts[i], url)
+		raw2 = convertAccounts(accounts)
+		saveAccounts(raw2)
+		print "Done."
+		
+	except Exception, err:
+		print "Exception", err
+
+if __name__=="__main__": main()


Property changes on: haypo/evolution_set_smtp.py
___________________________________________________________________
Name: svn:executable
   + *



From haypo at berlios.de  Wed Sep 21 13:37:08 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 21 Sep 2005 13:37:08 +0200
Subject: [Happyboom-svn] r216 - haypo
Message-ID: <200509211137.j8LBb8uL007416@sheep.berlios.de>

Author: haypo
Date: 2005-09-21 13:37:07 +0200 (Wed, 21 Sep 2005)
New Revision: 216

Modified:
   haypo/apache_log.py
Log:
Corrige une regex qui faisait ramer Python, active le rejet de certains url.


Modified: haypo/apache_log.py
===================================================================
--- haypo/apache_log.py	2005-09-21 03:28:26 UTC (rev 215)
+++ haypo/apache_log.py	2005-09-21 11:37:07 UTC (rev 216)
@@ -1,4 +1,4 @@
-#
+#!/usr/bin/python
 # Python script to parse Apache log file
 # 21 septembre 2005
 # Author: Victor Stinner
@@ -9,7 +9,7 @@
 class ApacheLogParser:
     def __init__(self):
         # String like "abc" or "a\"bc" or just ""
-        match_string = r"\"((?:[^\"]+|\\\")*)\""
+        match_string = r"\"((?:[^\"]|\\\")*)\""
 
         # Regex matching one line
         regex  = r"^([^ ]+) " # Origin
@@ -24,7 +24,6 @@
         regex += match_string+"$" # Browser string
         
         self._regex = re.compile(regex)
-        print "Pattern: %s" % self._regex.pattern
         self.handler = self.processLine
 
     def processLine(self, line_number, line, info):
@@ -32,13 +31,10 @@
 
     def parseLine(self, line_number, line):
         try:
-            print "LINE %u ========= %s =======" % (line_number, line)
-            print "Regex."
             m = self._regex.search(line)
             if m == None:
                 print "Can't parse line %u:\n%s" % (line_number, line)
                 return
-            print "Assign."
             origin, host, user, date, method, url, code, size, referrer, browser = m.groups()
             kw = { \
                 "origin": origin,
@@ -51,9 +47,7 @@
                 "size": size,
                 "referrer": referrer,
                 "browser": browser}
-            print "Handler."
             self.handler(line_number, line, kw)
-            print "Done."
         except KeyboardInterrupt:
             print "Interrupt line: %s" % line
             raise
@@ -69,12 +63,12 @@
         print "Load file %s ..." % filename
         try:
             nb_lines = len(data)
-            t = time.time()
+#            t = time.time()
             for line in data:
-                if 40800<line_number: #0.3 < time.time() - t:
-                    t = time.time()
-                    progress = int( (line_number-1)*100/nb_lines )
-                    print "Progress: %s%% (%u on %u) - %s" % (progress, line_number, nb_lines, line)
+#                if 1.0 < time.time() - t:
+#                    t = time.time()
+#                    progress = int( (line_number-1)*100/nb_lines )
+#                    print "Progress: %s%%" % (progress)
                 self.parseLine(line_number, line)
                 line_number += 1
             print "File loaded."
@@ -112,8 +106,8 @@
             url = "/"+m.group(1)
 
         # Ignore this hit?
-#        if self.ignore_handler:
-#            if self.ignore_handler(info)==True: return
+        if self.ignore_handler:
+            if self.ignore_handler(info)==True: return
 
         # Page hit stat
         if code not in [302, 404]:
@@ -161,6 +155,7 @@
 
 def printTopPage(r, max):
     # Top pages
+    print "=== Top page ==="
     pages = r.getTopPage(max)
     for page in pages:
         print "%u hit(s): %s" % (page[0], page[1])
@@ -175,30 +170,37 @@
     return ["[a-z]+.search.yahoo.com"]
 
 def printTopReferrer(r, max):
-    # Top pages
+    print "=== Top referrer ==="
     pages = r.getTopReferrer(max)
     for page in pages:
         print "%u hit(s): %s" % (page[0], page[1])
 
 class HaypoCALC:
     def __init__(self):
+        # Ignore referrer regex
         hosts = ["(www\.)?haypocalc\.com"] # Haypocalc
+        hosts.append ("exoscin\.free\.fr") # Exoscin.free.fr
         hosts += googleHosts()
         hosts += yahooHosts()
         self.ignore_referrer = [ re.compile(r"^http://("+"|".join(hosts)+")")  ]
 
+        # Ignore url regex
         self.ignore_url = []
-        end = r"(\?.*)?$"
         ignore_ext = ["css", "jpg", "JPG", "png", "js", "gif", "swf"]
         ignore_ext = "|".join(ignore_ext)
-        self.ignore_url.append( re.compile(r"\.("+ignore_ext+r")"+end) )
+        self.ignore_url.append( re.compile(r"\.("+ignore_ext+r")(\?.*)?$") )
         self.ignore_url.append( re.compile(r"^/wiki/index.php\?.*&action=raw") )
         self.ignore_url.append( re.compile(r"^/robots\.txt$") )
 
     def ignoreHandler(self, info):
+        url = info["url"]
+        for regex in self.ignore_url:
+            if regex.search(url) != None: return True
+            
         referrer = info["referrer"]
         for regex in self.ignore_referrer:
             if regex.search(referrer) != None: return True
+            
         return False
 
 def usage():
@@ -214,8 +216,8 @@
         r=ApacheLogParser_Stat("haypocalc.com")
         r.ignore_handler = h.ignoreHandler
         r.parseFile(filename)
-    #    printTopPage(r, 10)
-        printTopReferrer(r, 100)
+        printTopPage(r, 10)
+        printTopReferrer(r, 10)
     except KeyboardInterrupt:
         print "Program interrupted (CTRL+C)."
         



From haypo at berlios.de  Mon Sep 19 22:14:45 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Mon, 19 Sep 2005 22:14:45 +0200
Subject: [Happyboom-svn] r209 - in happyboom/trunk/happyboom: . client common net net/io net/io_tcp net/io_udp server specification
Message-ID: <200509192014.j8JKEjOe013109@sheep.berlios.de>

Author: haypo
Date: 2005-09-19 22:14:42 +0200 (Mon, 19 Sep 2005)
New Revision: 209

Added:
   happyboom/trunk/happyboom/.project
   happyboom/trunk/happyboom/AUTHORS
   happyboom/trunk/happyboom/COPYING
   happyboom/trunk/happyboom/ChangeLog
   happyboom/trunk/happyboom/README
   happyboom/trunk/happyboom/TODO
   happyboom/trunk/happyboom/__init__.py
   happyboom/trunk/happyboom/client/
   happyboom/trunk/happyboom/client/__init__.py
   happyboom/trunk/happyboom/client/base_client.py
   happyboom/trunk/happyboom/common/
   happyboom/trunk/happyboom/common/__init__.py
   happyboom/trunk/happyboom/common/event.py
   happyboom/trunk/happyboom/common/file.py
   happyboom/trunk/happyboom/common/generic_event.py
   happyboom/trunk/happyboom/common/happyboom_protocol.py
   happyboom/trunk/happyboom/common/log.py
   happyboom/trunk/happyboom/common/packer.py
   happyboom/trunk/happyboom/common/presentation.py
   happyboom/trunk/happyboom/common/protocol.py
   happyboom/trunk/happyboom/common/thread.py
   happyboom/trunk/happyboom/makedoc.sh
   happyboom/trunk/happyboom/net/
   happyboom/trunk/happyboom/net/__init__.py
   happyboom/trunk/happyboom/net/io/
   happyboom/trunk/happyboom/net/io/__init__.py
   happyboom/trunk/happyboom/net/io/base_io.py
   happyboom/trunk/happyboom/net/io/io_client.py
   happyboom/trunk/happyboom/net/io/packet.py
   happyboom/trunk/happyboom/net/io_tcp/
   happyboom/trunk/happyboom/net/io_tcp/__init__.py
   happyboom/trunk/happyboom/net/io_tcp/server_waiter.py
   happyboom/trunk/happyboom/net/io_tcp/tcp.py
   happyboom/trunk/happyboom/net/io_tcp/tcp_client.py
   happyboom/trunk/happyboom/net/io_udp/
   happyboom/trunk/happyboom/net/io_udp/__init__.py
   happyboom/trunk/happyboom/net/io_udp/udp.py
   happyboom/trunk/happyboom/net/io_udp/udp_client.py
   happyboom/trunk/happyboom/net/io_udp/udp_ping.py
   happyboom/trunk/happyboom/net/net_buffer.py
   happyboom/trunk/happyboom/release.sh
   happyboom/trunk/happyboom/run.sh
   happyboom/trunk/happyboom/server/
   happyboom/trunk/happyboom/server/__init__.py
   happyboom/trunk/happyboom/server/agent.py
   happyboom/trunk/happyboom/server/base_server.py
   happyboom/trunk/happyboom/server/client.py
   happyboom/trunk/happyboom/server/client_manager.py
   happyboom/trunk/happyboom/server/gateway.py
   happyboom/trunk/happyboom/server/server_agent.py
   happyboom/trunk/happyboom/server/stat.py
   happyboom/trunk/happyboom/specification/
   happyboom/trunk/happyboom/specification/client.dia
   happyboom/trunk/happyboom/specification/server.dia
   happyboom/trunk/happyboom/specification/socket_at_server_side.dia
Log:
I try Subclipse ...

Added: happyboom/trunk/happyboom/.project
===================================================================
--- happyboom/trunk/happyboom/.project	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/.project	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>happyboom</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.python.pydev.PyDevBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.python.pydev.pythonNature</nature>
+	</natures>
+</projectDescription>

Added: happyboom/trunk/happyboom/AUTHORS
===================================================================
--- happyboom/trunk/happyboom/AUTHORS	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/AUTHORS	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,2 @@
+Victor STINNER <victor.stinner AT haypocalc.com>
+Damien BOUCARD <damien.boucard AT tchoy.net>
\ No newline at end of file

Added: happyboom/trunk/happyboom/COPYING
===================================================================
--- happyboom/trunk/happyboom/COPYING	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/COPYING	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: happyboom/trunk/happyboom/ChangeLog
===================================================================
--- happyboom/trunk/happyboom/ChangeLog	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/ChangeLog	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,48 @@
+2005-08-05
+	o Rewrite of the BoomBoom server (based on multi-agent-system)
+	o The server requires the PySMA library (see README)
+
+2005-08-03
+	o Rewrite of the BoomBoom client (based on event-system)
+	o The BoomBoom client source code is documented with Epydoc
+
+2005-08-02
+	o The 'net' package is documented with Epydoc
+
+2005-04-28
+	o Fix network client : use buffer to keep unfinished lines, and support
+	  wrong host name error
+	o Fix pygame : use pygame.quit() 
+	o BoomBoom have character, weapon and projectile
+
+2005-04-25
+	o Server client support socket error 11
+	o Split input, view and server into base and specific code (eg. hb_input ->
+	  base_input and console_input)
+	o Write new game : BoomBoom which will first looks like old QBasic game
+	  "gorilla"
+
+2005-04-15
+	o Clients and server well support evil disconnection (eg. broken pipe)
+	o Add network stats (in/out bytes) in view module
+	o Add server stats (uptime, number of connections) and server network 
+	  stats (in/out bytes), which can be read by ServerStatAgent in view module
+	o Support command line options like max-fps, set host, set ports, 
+	  debug mode, etc.
+	o Server, view and input have verbose and debug mode (which active or not
+	  print functions)
+	o View register himself each role for each agent in server
+	o Server ask protocol version and name to view and input
+	o Server can send text messages (eg. "Welcome to XXX client!")
+	o Add a chat agent :-D
+	
+2005-04-13 : First release
+	o Network server support multiple clients (four by default)
+	o Server don't need to wait clients anymore
+	o Send messages to a role instead of "dest"
+	o Agent have to say that it wants to get messages of a given role
+	o In the server, agents communicates together. For the example, a
+	  "follow agent" is written. It hear "number" role, and update
+	  slowly (+/- 1) its value.
+	o Agent "AgentN" can be reused : messages integrate agent ID
+	o TODO : Server should support client disconnexion

Added: happyboom/trunk/happyboom/README
===================================================================
--- happyboom/trunk/happyboom/README	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/README	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,16 @@
+HappyBoom
+=========
+
+HappyBoom is a game engine based on client-server architecture. The server is
+based ony multi-agents system.
+
+Website: http://www.happyboom.org/
+
+Documentation
+=============
+
+You can generate the API documentation of HappyBoom which this command:
+    ./makedoc.sh
+
+Documentation will be generated in HTML in the subdirectory "doc". You
+need Epydoc (version 2.1 or earlier, just tested 2.1).

Added: happyboom/trunk/happyboom/TODO
===================================================================
--- happyboom/trunk/happyboom/TODO	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/TODO	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,2 @@
+See our webpage to get the last todo list:
+   http://www.happyboom.org/HappyBoom#Todo

Added: happyboom/trunk/happyboom/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/client/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/client/base_client.py
===================================================================
--- happyboom/trunk/happyboom/client/base_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/client/base_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,180 @@
+from happyboom.common.happyboom_protocol import HappyboomProtocol
+from happyboom.common.protocol import ProtocolException
+from happyboom.common.log import log
+from happyboom.common.event import EventLauncher, EventListener
+from happyboom.net.io.packet import Packet
+from happyboom.net.io_tcp.tcp import IO_TCP
+import struct, string, thread, imp, os.path, sys
+
+class Client(object, EventListener, EventLauncher):
+    """
+    Base HappyBoom client.
+    @ivar __stopped: Stopped display client flag.
+    @type __stopped: C{bool}
+    @ivar __stoplock: Mutex for synchronizing __stopped.
+    @type __stoplock: C{thread.lock}
+    @ivar _io: Network input/output object using UDP protocole.
+    @type _io: C{net.io_udp.IO_UDP}
+    @ivar verbose: Verbose mode flag.
+    @type verbose: C{bool}
+    @ivar debug: Debug mode flag.
+    @type debug: C{bool}
+    """
+    
+    def __init__(self, args):
+        EventListener.__init__(self)
+        EventLauncher.__init__(self)
+        self.host = args.get("host", "127.0.0.1")
+        self.port = args.get("port", 12430)
+        self.verbose = args.get("verbose", False)
+        self.debug = args.get("debug", False)
+        protocol = args.get("protocol", None)
+        self._io = IO_TCP()
+        self._io.verbose = False # self.verbose
+        self._io.debug = False # self.debug
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        
+        self.signature = None
+        self.presentation = HappyboomProtocol(protocol, args)
+        self.gateway = Gateway(protocol, args)
+        self.registerEvent("happyboom")
+        
+    def evt_happyboom_stop(self):
+        self.stop()
+
+    def evt_happyboom_network(self, feature, event, *args):
+        self.launchEvent("happyboom", "event", (self._io,), feature, event, args)
+
+    def start(self):
+        """ Starts the client : connection to the server, etc. """
+        # Try to connect to server
+        if self.verbose: log.info("[HAPPYBOOM] Trying to connect to server %s:%u" % (self.host, self.port))
+        self._io.on_connect = self.onConnect
+        self._io.on_connection_fails = self.onConnectionFails
+        self._io.on_disconnect = self.onDisconnect
+        self._io.on_new_packet = self.presentation.processPacket
+        self._io.on_lost_connection = self.onLostConnection
+        self._io.connect(self.host, self.port)
+        if not self._io.is_ready: return
+        thread.start_new_thread(self._io.run_thread, ())
+        
+    def stop(self):
+        """ Stops the display client : disconnection from the server, etc. """
+        # Does not stop several times
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return False
+        self.__stopped = True
+        self.__stoplock.release()
+        
+        self._io.stop()
+        if self.verbose:
+            log.info("[HAPPYBOOM] Stopped")
+        return True
+        
+    def __isStopped(self):
+        self.__stoplock.acquire()
+        stop = self.__stopped
+        self.__stoplock.release()
+        return stop
+    stopped = property(__isStopped)
+    
+    def onConnect(self):
+        """ Handler called on network connection. """
+        if self.verbose:
+            log.info("[HAPPYBOOM] Connected to server, send presentation connection().")
+        self.launchEvent("happyboom", "connection", self._io)
+        
+    def onConnectionFails(self):
+        """ Handler called when network connection fails. """
+        log.error("[HAPPYBOOM] Fail to connect to the server.")
+
+    def onDisconnect(self):
+        """ Handler called on network disconnection. """
+        if self.stopped: return
+        log.info("[HAPPYBOOM] Connection to server closed")
+        self.launchEvent("happyboom", "stop")
+
+    def onLostConnection(self):
+        """ Handler called on losting network connection. """
+        log.warning("[HAPPYBOOM] Lost connection with server.")
+        self.launchEvent("happyboom", "stop")
+        
+class Gateway(EventLauncher, EventListener):
+    def __init__(self, protocol, args):
+        EventLauncher.__init__(self)
+        EventListener.__init__(self, "evt_")
+        self.protocol = protocol
+        self.launchEvent("happyboom", "register", "connection", self.processConnection)
+        self.launchEvent("happyboom", "register", "disconnection", self.processDisconnection)
+        self.launchEvent("happyboom", "register", "create_item", self.processCreateItem)
+        self.launchEvent("happyboom", "register", "destroy_item", self.processDestroyItem)
+        self.launchEvent("happyboom", "register", "recv_event", self.processEvent)
+        self.registerEvent("happyboom")
+        self.verbose = args.get("verbose", False)
+        self.debug = args.get("debug", False)
+        self.features = {}
+        for feat in args.get("features", ()):
+            self.features[feat] = None
+        self.items = {}
+        itemPath = args["item_path"]
+        dirs = itemPath.split(os.path.sep)
+        if dirs[-1] == "":
+            dirs = dirs[:-1]
+        packagePath = None
+        try:
+            for d in dirs:
+                #print "imp.find_module(%s, %s)" %(repr(modName), repr(modDir))
+                f, fname, desc = imp.find_module(d, packagePath)
+                self.module = imp.load_module(d, f, fname, desc)
+                packagePath = self.module.__path__
+        except:
+            raise Exception("[HAPPYBOOM] Invalid item path : %s" %itemPath)
+        import types
+        for attr in self.module.__dict__:
+            if type(self.module.__dict__[attr]) == types.ClassType:
+                itemClass = self.module.__dict__[attr]
+                if hasattr(itemClass, "feature"):
+                    feat = getattr(itemClass, "feature")
+                    if feat != None:
+                        if feat in self.features:
+                            raise Exception("[HAPPYBOOM] Duplicated feature %s in %s and %s classes" %(feat, itemClass.__name__, self.features[feat].__name__))
+                        self.features[feat] = itemClass
+        
+    def processConnection(self, ioclient, version, signature):
+        self.launchEvent("happyboom", "signature", ioclient, signature)
+        features = ""
+        for name in self.features:
+            try:
+                feature = self.protocol.getFeature(name)
+                features = features + "%c" % feature.id
+            except ProtocolException:
+                pass
+        self.launchEvent("happyboom", "features", ioclient, features)
+        
+    def processDisconnection(self, ioclient, reason):
+        self.launchEvent("happyboom", "stop", reason)
+    
+    def processCreateItem(self, ioclient, feature, id):
+        assert feature in self.features, "Unexpected feature : %s" %feature
+        itemClass = self.features[feature]
+        if itemClass != None:
+            item = itemClass(id)
+            self.items[id] = item
+            self.launchEvent(feature, "new", id)
+    
+    def processDestroyItem(self, ioclient, id):
+        assert id in self.items, "Unknown item identifier %s" %id
+        self.launchEvent(feature, "delete", id)
+        del self.items[id]
+        
+    def processEvent(self, ioclient, feature, event, args):
+        if self.debug:
+            log.info("New event: %s.%s%s" % (feature, event, args))
+        assert feature in self.features, "Unexpected feature"
+        self.launchEvent(feature, event, *args)
+
+#    def evt_happyboom_gamepath(self, path):
+#        self.gamepath = path
\ No newline at end of file

Added: happyboom/trunk/happyboom/common/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/common/event.py
===================================================================
--- happyboom/trunk/happyboom/common/event.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/event.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,72 @@
+"""
+Module to use event-system very easily.
+ at author: Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 1.0
+"""
+import generic_event as evt
+
+class EventListener(evt.EventListener):
+    """ Happyboom generic class for listening to events.
+    """
+    def __init__(self, prefix="evt_", suffix="", default="eventPerformed", silent=True):
+        """ EventListener constructor.
+        """
+        evt.EventListener.__init__(self, prefix, suffix, "happyboomEventPerformed", silent)
+        self.event_hb_default = default
+        
+    def getEventName(self, feature, event):
+        return "%s_%s" %(feature, event)
+        
+    def happyboomEventPerformed(self, event):
+        if issubclass(event.__class__, Event):
+            # Try to call event-specific handle method
+            fctname = self.event_pattern %(self.getEventName(event.type, event.event))
+            if hasattr(self, fctname):
+                function = getattr(self, fctname)
+                if callable(function):
+                    function(*event.content)
+                    return
+
+        # Try to call default handle method
+        if hasattr(self, self.event_hb_default):
+            function = getattr(self, self.event_hb_default)
+            if callable(function):
+                function(event)
+                return
+        # No handle method found, raise error ?
+        if not self.event_silent:
+            raise evt.UnhandledEventError("%s has no method to handle %s" %(self, event))
+
+class EventLauncher(evt.EventLauncher):
+    """ Happyboom generic class for launching events.
+    """
+    def __init__(self):
+        """ EventLauncher constructor. """
+        evt.EventLauncher.__init__(self)
+        
+    def launchEvent(self, feature, event, *args):
+        """ Launches a new event to the listeners.
+        """
+        e = Event(feature, event, self, args)
+        self.event_manager.dispatchEvent(e)
+
+class Event(evt.Event):
+    """ Represents an happyboom event entity.
+    """
+    def __init__(self, feature, event, source, content):
+        """ Event constructor.
+        """
+        evt.Event.__init__(self, feature, source, content)
+        self.event = event
+    
+    def __str__(self):
+        """ Converts object itself to string.
+        @return: Object converted string.
+        @rtype: C{str}
+        """
+        return "<event.Event feature=%s event=%s source=%s content=%s>" %(self.type, self.event, self.source, self.content)
+    
+    def getFeature(self): return feature
+    feature = property(getFeature)

Added: happyboom/trunk/happyboom/common/file.py
===================================================================
--- happyboom/trunk/happyboom/common/file.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/file.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,25 @@
+import os
+
+def getCreateHomeDir(subdir):
+    """
+    Get the home directory, and then create a subdirectory.
+    Example: create ~/.subdir/ in Linux.
+    
+    Returns None if fails to find home directory and/or create subdirectory.
+    """
+
+    # Get user directory 
+    if os.name=="nt":
+        home = os.environ['USERHOME']
+    else:
+        subdir = "."+subdir
+        home = os.environ['HOME']
+
+    # Create happywarry directory if needed
+    logdir = os.path.join(home, subdir)
+    try:
+        os.mkdir(logdir)
+    except OSError, err:
+        if err[0] != 17:
+            logdir = None
+    return logdir

Added: happyboom/trunk/happyboom/common/generic_event.py
===================================================================
--- happyboom/trunk/happyboom/common/generic_event.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/generic_event.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,178 @@
+"""
+Module to use event-system very easily.
+ at author: Damien Boucard
+ at license: Gnu/GPL v2 or later, see LICENSE file.
+ at contact: See U{http://developer.berlios.de/projects/happyboom/}
+ at version: 1.0
+"""
+from happyboom.common.log import log
+class EventManager:
+    """ Manages the event-system.
+    This class is instanciated on importing the module,
+    so it is not needed to use it directly but via EventLaunch and EventListener.
+    @cvar instance: The instance created on importing the module.
+    @type instance: C{L{EventManager}}
+    @ivar listeners: Dictionnary with keys of type C{str} representing a event type and with values of type C{list} representing a collection of C{EventListener}.
+    @type listeners: C{dict<str, list<L{EventListener}>>}
+    """
+    def __init__(self):
+        """ EventManager constructor. """
+        EventManager.instance = self
+        self.listeners = {}
+        
+    def addListener(self, obj, event_type):
+        """ Add a listener to a specific event.
+        @param obj: Listener to add.
+        @type obj: C{L{EventListener}}
+        @param event_type: Type of the event to listen.
+        @type event_type: C{str}
+        """
+        if event_type in self.listeners:
+            if obj not in self.listeners[event_type]:
+                self.listeners[event_type].append(obj)
+        else:
+            self.listeners[event_type] = [obj]
+    
+    def removeListener(self, obj, event_type):
+        """ Remove a listener from a specific event.
+        @param obj: Listener to remove.
+        @type obj: C{L{EventListener}}
+        @param event_type: Type of the event that was listening.
+        @type event_type: C{str}
+        """
+        if event_type in self.listeners and obj in self.listeners[event_type]:
+            self.listeners[event_type].remove(obj)
+    
+    def dispatchEvent(self, event):
+        """ Dispatch a launched event to all affected listeners.
+        @param event: Event launched.
+        @type event: C{L{Event}}
+        """
+        if event.type in self.listeners:
+            for obj in self.listeners[event.type]:
+                # Try to call event-specific handle method
+                fctname = obj.event_pattern %(event.type)
+                if hasattr(obj, fctname):
+                    function = getattr(obj, fctname)
+                    if callable(function):
+                        function(event)
+                        continue
+                # Try to call default handle method
+                if hasattr(obj, obj.event_default):
+                    function = getattr(obj, obj.event_default)
+                    if callable(function):
+                        function(event)
+                        continue
+                # No handle method found, raise error ?
+                if not obj.event_silent:
+                    raise UnhandledEventError("%s has no method to handle %s" %(obj, event))
+        else:
+            log.error("Pas de event.type %s" % event.type)
+
+EventManager()
+    
+class EventListener:
+    """ Generic class for listening to events.
+    
+    It is just needed to herite from this class and register to events to listen easily events.
+    It is also needed to write handler methods with event-specific and/or C{L{default}} function.
+    
+    Event-specific functions have name as the concatenation of the C{prefix} parameter + the listened event type + the C{suffix} parameter.
+    
+    If it does not exist, the default function is called as defined by the C{L{default}} parameter/attribute.
+    
+    If the event cannot be handled, a C{L{UnhandledEventError}} is raised, except if C{L{silent}} flag is C{True}.
+    @ivar event_manager: The event manager instance.
+    @type event_manager: C{L{EventManager}}
+    @ivar event_pattern: Event-specific handler pattern.
+    @type event_pattern: C{str}
+    @ivar event_default: Default handler function name.
+    @type event_default: C{str}
+    @ivar silent: Silent flag. If C{False}, C{L{UnhandledEventError}} is raised if an event cannot be handled. If C{True}, do nothing, listener does not handle the event.
+    @type silent: C{str}
+    """
+    def __init__(self, prefix="evt", suffix="", default="eventPerformed", silent=False):
+        """ EventListener constructor.
+        @param prefix: Prefix for all event-specific handler function name.
+        @type prefix: C{str}
+        @param suffix: Suffix for all event-specific handler function name.
+        @type suffix: C{str}
+        @param event_default: Default handler function name.
+        @type event_default: C{str}
+        @param event_silent: Silent flag.
+        @type event_silent: C{bool}
+        """
+        self.event_manager = EventManager.instance
+        self.event_pattern = prefix + "%s" + suffix
+        self.event_default = default
+        self.event_silent = silent
+        
+    def registerEvent(self, event_type):
+        """ Registers itself to a new event.
+        @param event_type: Type of the event to listen.
+        @type event_type: C{str}
+        """
+        self.event_manager.addListener(self, event_type)
+        
+    def unregisterEvent(self, event_type):
+        """ Unregisters itself from a event.
+        @param event_type: Type of the event which was listening.
+        @type event_type: C{str}
+        """
+        self.event_manager.removeListener(self, event_type)
+
+
+class EventLauncher:
+    """ Generic class for launching events.
+    It is just needed to herite from this class to launch easily events.
+    @ivar event_manager: The event manager instance.
+    @type event_manager: C{L{EventManager}}
+    """
+    def __init__(self):
+        """ EventLauncher constructor. """
+        self.event_manager = EventManager.instance
+        
+        
+    def launchEvent(self, event_type, content=None):
+        """ Launches a new event to the listeners.
+        @param event_type: Type of the event to launch.
+        @type event_type: C{str}
+        @param content: Content to attach with the event (Optional).
+        @type content: any
+        """
+        self.event_manager.dispatchEvent(Event(event_type, self, content))
+    
+    
+class Event:
+    """ Represents an event entity.
+    @ivar type: Type of the event.
+    @type type: C{str}
+    @ivar source: Instance which launched the event.
+    @type source: C{L{EventLauncher}}
+    @ivar content: Content attached to the event (C{None} if none).
+    @type content: any
+    """
+    def __init__(self, type, source, content):
+        """ Event constructor.
+        @param type: Type of the event.
+        @type type: C{str}
+        @param source: Instance which launched the event.
+        @type source: C{L{EventLauncher}}
+        @param content: Content attached to the event (C{None} if none).
+        @type content: any
+        """
+        self.type = type
+        self.source = source
+        self.content = content
+    
+    def __str__(self):
+        """ Converts object itself to string.
+        @return: Object converted string.
+        @rtype: C{str}
+        """
+        return "<generic_event.Event type=%s source=%s content=%s>" %(self.type, self.source, self.content)
+    
+    
+class UnhandledEventError(AttributeError):
+    """ Error raised when an event cannot be handled, except if C{L{silent<EventListener.silent>}} flag is C{True}. """
+    pass

Added: happyboom/trunk/happyboom/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/happyboom/common/happyboom_protocol.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/happyboom_protocol.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,126 @@
+from presentation import Presentation
+import happyboom.common.packer as packer
+from happyboom.common.log import log
+import struct
+
+class HappyboomProtocol(Presentation):
+    def __init__(self, protocol, args):
+        Presentation.__init__(self, protocol, args)
+        self._unpackFunc = { \
+            self.CONNECTION: self.unpackConnection,
+            self.DISCONNECTION: self.unpackDisconnection,
+            self.FEATURES: self.unpackFeatures,
+            self.CREATE: self.unpackCreateItem,
+            self.DESTROY: self.unpackDestroyItem,
+            self.EVENT: self.unpackEvent}
+
+    def packConnection(self, version, signature):
+        data = struct.pack("!B", self.CONNECTION)
+        data = data + packer.packBin(version)
+        return data + packer.packBin(signature)
+
+    def packDisconnection(self, reason):
+        return struct.pack("!B", self.DISCONNECTION) + packer.packUtf8(reason)
+
+    def packFeatures(self, features):
+        data = struct.pack("!B", self.FEATURES)
+        return data + packer.packBin(features)
+
+    def packCreate(self, feature, id):
+        return struct.pack("!BBI", self.CREATE, feature, id)
+
+    def packEvent(self, id):
+        return struct.pack("!BI", self.DESTROY, id)
+
+    def packEvent(self, feature, event, args):
+        f = self.protocol.getFeature(feature)
+        e = f.getEvent(event)
+        out = struct.pack("!BB", f.id, e.id)
+        types = e.getParamTypes()
+        if len(args) != len(types):
+            raise ProtocolException( \
+                "Unexpected number of parameters (%u) for the event %s.%s." \
+                % (len(args), f.name, e))
+        for i in range(len(args)):
+            if not packer.checkType(types[i], args[i]):
+                raise ProtocolException( \
+                    "Parameter %u of event %s.%s should have type %s (instead of %s)." \
+                    % (i, f.name, e, types[i], type(args[i])))
+            type = types[i]
+            data = args[i]
+            
+            if type=="int":
+                data = packer.packInt(data)
+            elif type=="bin":
+                data = packer.packBin(data)
+            elif type=="utf8":
+                data = packer.packUtf8(data)
+            else:
+                raise packer.PackerException("Wrong argument type: %s" % type)
+            out = out + data
+        return struct.pack("!B", self.EVENT) + out
+
+    def unpackPacketType(self, data):
+        # Get packet type
+        fmt = "!B"
+        i = struct.calcsize(fmt)
+        type, = struct.unpack(fmt, data[:i]) 
+        return type, data[i:]
+
+    def unpackConnection(self, ioclient, data):
+        version, data = packer.unpackBin(data)
+        signature, data = packer.unpackBin(data) 
+        if self._on_connection != None:
+            self._on_connection(ioclient, version, signature)
+        return data
+
+    def unpackDisconnection(self, ioclient, data):
+        reason, data = packer.unpackUtf8(data)
+        if self._on_disconnection != None:
+            self._on_disconnection(ioclient, reason)
+#            self.client_manager.closeClient(ioclient)
+        return data
+        
+    def unpackFeatures(self, ioclient, data):
+        features, data = packer.unpackBin(data)
+        if self._on_features != None:
+            self._on_features(ioclient, features)
+        return data
+
+    def unpackCreateItem(self, ioclient, data):
+        fmt = "!BI"
+        i = struct.calcsize(fmt)
+        typeid, itemid = struct.unpack(fmt, data)
+        type = self.protocol[typeid]
+        data = data[i:]
+        if self._on_create_item != None:
+            self._on_create_item(ioclient, type.name, itemid)
+        return data
+
+    def unpackDestroyItem(self, ioclient, data):
+        itemid,data = packer.unpackInt(data)
+        if self._on_destroy_item != None:
+            self._on_destroy_item(ioclient, itemid)
+        return data
+    
+    def unpackEvent(self, ioclient, data):
+        fmt = "!BB"
+        i = struct.calcsize(fmt)
+        feature_id, event_id = struct.unpack(fmt, data[:i])
+        feat = self.protocol[feature_id]
+        evt = feat[event_id]
+        data = data[i:]
+        args = []
+        for type in evt.getParamTypes():
+            if type=="int":
+                arg, data = packer.unpackInt(data)
+            elif type=="bin":
+                arg, data = packer.unpackBin(data)
+            elif type=="utf8":
+                arg, data = packer.unpackUtf8(data)
+            else:
+                raise packer.PackerException("Wrong argument type: %s" % type)
+            args.append(arg)
+        if self._on_recv_event != None:
+            self._on_recv_event(ioclient, feat.name, evt.name, tuple(args))
+        return ""

Added: happyboom/trunk/happyboom/common/log.py
===================================================================
--- happyboom/trunk/happyboom/common/log.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/log.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,93 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
+
+import time
+
+class Log:
+    LOG_INFO   = 0
+    LOG_WARN   = 1
+    LOG_ERROR  = 2
+
+    def __init__(self):
+        self.__buffer = {}
+        self.__file = None
+        self.use_print = True
+        self.on_new_message = None # (level, prefix, text)
+
+    def setFilename(self, filename):
+        """
+        Use a file to store all messages. The
+        UTF-8 encoding will be used. Write an informative
+        message if the file can't be created.
+
+        @param filename: C{L{string}}
+        """
+
+        try:
+            import codecs
+            self.__file = codecs.open(filename, "w", "utf-8")
+        except IOError, errno:
+            if errno[0] == 2:
+                self.__file = None
+                self.info("Log.setFilename(%s) fails : no such file." % filename)
+                return
+            raise
+
+    def getLevelPrefix(self, level):
+        """
+        String prefix which depends on message level.
+        Eg. information returns "[info]".
+        @return: C{str}
+        """
+        if level==Log.LOG_WARN: return "[warn]"
+        if level==Log.LOG_ERROR: return "[err!]"
+        return "[info]"
+
+    def new_message(self, level, str):
+        """
+        Write a new message : append it in the buffer,
+        display it to the screen (if needed), and write
+        it in the log file (if needed).
+
+        @param level: Message level.
+        @type level: C{int}
+        @param str: Message content.
+        @type str: C{str}
+        """
+
+        if not self.__buffer.has_key(level):
+            self.__buffer[level] = [str]
+        else:
+            self.__buffer[level].append(str)
+        prefix = self.getLevelPrefix(level)            
+        if self.use_print:
+            print "%s %s" % (prefix, str)
+        if self.__file:
+            self.__file.write(u"%s - %s %s\n" \
+                % (time.strftime("%Y-%M-%d %H:%M:%S"),
+                   prefix, str))
+        if self.on_new_message:
+            self.on_new_message (level, prefix, str)
+
+    def info(self, str):
+        """
+        New informative message.
+        @type str: C{str}
+        """
+        self.new_message(Log.LOG_INFO, str)
+
+    def warning(self, str):
+        """
+        New warning message.
+        @type str: C{str}
+        """
+        self.new_message(Log.LOG_WARN, str)
+
+    def error(self, str):
+        """
+        New error message.
+        @type str: C{str}
+        """
+        self.new_message(Log.LOG_WARN, str)
+
+log = Log()        

Added: happyboom/trunk/happyboom/common/packer.py
===================================================================
--- happyboom/trunk/happyboom/common/packer.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/packer.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,53 @@
+import types # maybe only used for assertions
+import struct
+
+class PackerException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+def checkType(datatype, data):
+    if datatype=="int":
+        return (type(data) == type(1)) and (data <= 2147483647) and (-2147483648 <= data)
+    elif datatype=="bin":
+        return type(data)==types.StringType and len(data) < 65535 
+    elif datatype=="utf8":
+        return type(data)==types.UnicodeType and len(data) < 65535
+    else:
+        raise PackerException("Wrong argument type: %s" % datatype)
+
+# Integer type
+def packInt(data):
+    assert checkType("int", data), "packInt argument have to be an integer"
+    return struct.pack("!i", data)
+    
+def unpackInt(data):
+    fmt = "!i"
+    i = struct.calcsize(fmt)
+    value, = struct.unpack(fmt, data[:i])
+    return value, data[i:]
+    
+# unicode string type (encoded in UTF-8)
+def packUtf8(data):
+    assert checkType("utf8", data), "packUtf8 argument have to be an unicode string"
+    return packBin(data.encode("utf-8"))
+
+def unpackUtf8(data):
+    str, data = unpackBin(data)
+    str = unicode(str, "UTF-8")
+    return str, data
+
+# Binary string type
+def packBin(data):
+    assert checkType("bin", data), "packBin argument have to be a string"
+    # TODO : verify length
+    return struct.pack("!H%us" % len(data), len(data), data)
+
+def unpackBin(data):        
+    fmt = "!H"
+    i = struct.calcsize(fmt)
+    version_len, = struct.unpack(fmt, data[:i])
+    data = data[i:]
+    fmt = "!%us" %(version_len)
+    i = struct.calcsize(fmt)
+    bin, = struct.unpack(fmt, data[:i])
+    return bin, data[i:]

Added: happyboom/trunk/happyboom/common/presentation.py
===================================================================
--- happyboom/trunk/happyboom/common/presentation.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/presentation.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,131 @@
+from happyboom.common.event import EventListener
+from happyboom.common.log import log
+from happyboom.net.io.packet import Packet
+from happyboom.server.client import Client
+import struct
+
+class PresentationException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+class Presentation(EventListener):
+    
+    CONNECTION    = 0x1
+    DISCONNECTION = 0x2
+    FEATURES      = 0x3
+    CREATE        = 0x4
+    DESTROY       = 0x5
+    EVENT         = 0x6
+    
+    def __init__(self, protocol, args):
+        EventListener.__init__(self)
+        self.protocol = protocol
+        self.items = {}
+        self._unpackFunc = {}
+        self.registerEvent("happyboom")
+        self.verbose = args.get("verbose", False)
+
+        # Event (IO_Client client, str version, str signature)
+        self._on_connection = None
+        # Event (IO_Client client, str features)
+        self._on_features = None
+        # Event (IO_Client client)
+        self._on_disconnection = None
+        # Event (IO_Client client, str feature, str event, str arguments)
+        self._on_recv_event = None
+        # Event (IO_Client client, str type, int id)
+        self._on_create_item = None
+        # Event (IO_Client client, int id)
+        self._on_destroy_item = None
+
+    def processPacket(self, packet):
+        """ Processes incomming network packets (converts and launches local event).
+        @param packet: incomming network packet.
+        @type packet: C{net.io.packet.Packet}
+        """
+        ptype, data = self.unpackPacketType(packet.data)
+        
+        # Choose process function
+        if ptype in self._unpackFunc:
+            data = self._unpackFunc[ptype] (packet.recv_from, data)
+        else:
+            log.warning("ProtocoleWarning: received unexpected packet type %s." % ptype)
+        if len(data) != 0:
+            log.warning("ProtocolWarning: Received a message with an unexpected length.")
+            log.warning(u"Rest: [%s]." % data)
+
+    def evt_happyboom_register(self, event, handler):
+        event = "_on_"+event
+        if hasattr(self, event):
+            setattr(self, event, handler)
+    
+    def evt_happyboom_closeConnection(self, ioclient, reason):
+        """
+        Close client connection.
+        @type ioclient L{IOClient}
+        @type reason Unicode
+        """
+        self.evt_happyboom_disconnection(ioclient, reason)
+
+    def evt_happyboom_connection(self, ioclient, version=None, signature=""):
+        """
+        Send a connection message to ioclient.
+        @type version ASCII string
+        @type signature string
+        """
+        if version == None:
+            version = self.protocol.version
+        if self.verbose:
+            log.info("[PRESENTATION] Send connection(\"%s\", \"%s\")" % (version, signature))
+        data = self.packConnection(version, signature)
+        ioclient.send( Packet(data) )
+
+    def evt_happyboom_disconnection(self, ioclient, reason):
+        """
+        Send a disconnection message to ioclient.
+        @type ioclient L{IOClient}
+        @type reason Unicode
+        """
+        
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send disconnection(\"%s\")" % reason)
+        data = self.packDisconnection(reason)
+        ioclient.send( Packet(data) )
+        ioclient.disconnect()
+    
+
+    def evt_happyboom_features(self, ioclient, features):
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send features(%s)" % features)
+        data = self.packFeatures(features)
+        ioclient.send( Packet(data) )
+        
+    def evt_happyboom_create(self, ioclient, feature, id):
+        if self.verbose:
+            log.info(u"[PRESENTATION] Send create(%s, %s)" % (feature, id))
+        data = self.packCreate(feature, id)
+        ioclient.send( Packet(data) )
+       
+    
+    def evt_happyboom_event(self, clients, feature, event, args):
+        data = self.packEvent(feature, event, args)
+        packet = Packet(data)
+        for client in clients: client.send(packet)
+        
+    def unpackPacketType(self, data):
+        """ returns type, data """
+        return 0, data
+        
+    def unpackConnection(self, ioclient, version, signature): return data
+    def unpackDisconnection(self, ioclient, data): return data
+    def unpackFeatures(self, ioclient, data): return data
+    def unpackCreateItem(self, data): return data
+    def unpackDestroyItem(self, data): return data
+    def unpackEvent(self, ioclient, data): return data
+
+    def packConnection(self, version, signature): return ""
+    def packDisconnect(self, reason): return ""
+    def packFeatures(self, features): return ""
+    def packCreateItem(self, feature, id): return ""
+    def packDestroyItem(self, id): return ""
+    def packEvent(self, feature, event, args): return ""
\ No newline at end of file

Added: happyboom/trunk/happyboom/common/protocol.py
===================================================================
--- happyboom/trunk/happyboom/common/protocol.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/protocol.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,188 @@
+"""
+Tools to load HappyBoom protocol in Python from an XML description file.
+"""
+
+import xml.dom.minidom
+
+class ProtocolException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+class ProtocolEventParam:
+    def __init__(self, event, name, type):
+        self.name = name.encode("ascii")
+        self.type = type
+        self.event = event
+
+    def __str__(self):
+        return "%s: %s" % (self.name, self.type)
+       
+class ProtocolEvent:
+    def __init__(self, feature, name, id):
+        self.name = name.encode("ascii")
+        self.id = id
+        self.feature = feature
+        self.__params_dict = {}
+        self.__params_array = [] 
+        
+    def addParam(self, name, id):
+        param = ProtocolEventParam(self, name, id)
+        self.__params_dict[name] = param
+        self.__params_array.append(param)
+        return param
+
+    def getParamTypes(self):
+        types = []
+        for param in self.__params_array:
+            types.append(param.type)
+        return types
+        
+    def __str__(self):
+        out = "%s(" % (self.name)
+        comma = False
+        for param in self.__params_array:
+            if comma:
+                out = out + ","
+            else:
+                comma = True
+            out = out + str(param)
+        out = out + ")"
+        return out
+
+class ProtocolFeature:
+    def __init__(self, protocol, name, id):
+        self.protocol = protocol
+        self.name = name.encode("ascii")
+        self.id = id
+        self.__evtnames = {}
+        self.__evtids = {}
+
+    def addEvent(self, name, id):
+        # Check if no other event have the same identifier
+        event = self.__evtids.get(id, None)
+        if event != None:
+            raise ProtocolException( \
+                "Events %s.%s and %s.%s have the same identifier (%s)." \
+                % (self.name, event.name, self.name, name, id))
+        # Check if no other event have the same name
+        event = self.__evtnames.get(name, None)
+        if event != None:
+            raise ProtocolException( \
+                "Events %s[%s] and %s[%s] have the same name (%s)." \
+                % (self.name, event.id, self.name, id, name))
+
+        # Add the new event 
+        event = ProtocolEvent(self, name, id)
+        self.__evtnames[name] = event
+        self.__evtids[id] = event
+        return event
+
+    def getEvent(self, name):
+        event = self.__evtnames.get(name, None)
+        if event == None:
+            raise ProtocolException( \
+                "The protocol %s has no event %s.%s(...)." 
+                % (self.protocol.name, self.name, name))
+        return self.__evtnames[name]
+
+    def __getitem__(self, id):
+        event = self.__evtids.get(id, None)
+        if event == None:
+            raise ProtocolException( \
+                "The protocol %s has no event %s[%s](...)." 
+                % (self.protocol.name, self.name, id))
+        return self.__evtids[id]
+
+    def __str__(self):
+        first = True
+        out = ""
+        for event in self.__evtnames.values():
+            if first:
+                first = False
+            else:
+                out = out + "\n"
+            out = out + "%s.%s" % (self.name, event)
+        return out
+
+class Protocol:
+    """
+    HappyBoom protocol utility.
+    version is ASCII 
+    """
+    def __init__(self, name, version):
+        self.name = name.encode("ascii")
+        self.version = version.encode("ascii")
+        self.__featnames = {}
+        self.__featids = {}
+
+    def addFeature(self, name, id):
+        # Check if no other feature have the same identifier
+        feature = self.__featnames.get(name, None)
+        if feature != None:
+            raise ProtocolException( \
+                "Features %s and %s have the same identifier (%s)." \
+                % (feature.name, name, id))
+                
+        # Check if no other feature have the same name
+        feature = self.__featids.get(id, None)
+        if feature != None:
+            raise ProtocolException( \
+                "Features %s and %s have the same name (%s)." \
+                % (feature.id, id, name))
+
+        # Add the new feature
+        feature = ProtocolFeature(self, name, id)
+        self.__featnames[name] = feature
+        self.__featids[id] = feature
+        return feature
+
+    def getFeature(self, name):
+        feature = self.__featnames.get(name, None)
+        if feature == None:
+            raise ProtocolException( \
+                "The protocol %s has no feature \"%s\"." \
+                % (self.name, name))
+        return feature
+
+    def __getitem__(self, id):
+        feature = self.__featids.get(id, None)
+        if  feature == None:
+            raise ProtocolException( \
+                "The protocol %s has no feature with \"%s\" identifier." \
+                % (self.name, id))
+        return feature
+        
+    def __str__(self):
+        out = ""
+        first = True
+        for feature in self.__featnames.values():
+            if first:
+                first = False
+            else:
+                out = out + "\n"
+            out = out + "[ %s ]\n" % feature.name
+            out = out + str(feature)
+        return out
+ 
+def loadProtocol(filename):
+    doc = xml.dom.minidom.parse(filename)
+    protocol = doc.documentElement
+    p = Protocol( \
+        protocol.getAttribute("name"),
+        protocol.getAttribute("version"))
+    features = protocol.getElementsByTagName("feature")
+    for feature in features:
+        f = p.addFeature( \
+            feature.getAttribute("name"),
+            int(feature.getAttribute("id")))
+        events = feature.getElementsByTagName("event")
+        for event in events:
+            e = f.addEvent( \
+                event.getAttribute("name"),
+                int(event.getAttribute("id")))
+            params = event.getElementsByTagName("param")
+            for param in params:
+                e.addParam( \
+                    param.getAttribute("name"),
+                    param.getAttribute("type"))
+    return p

Added: happyboom/trunk/happyboom/common/thread.py
===================================================================
--- happyboom/trunk/happyboom/common/thread.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/thread.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,6 @@
+import traceback, sys
+
+def getBacktrace():
+    bt = traceback.format_exception( \
+        sys.exc_type, sys.exc_value, sys.exc_traceback)
+    return "".join(bt)

Added: happyboom/trunk/happyboom/makedoc.sh
===================================================================
--- happyboom/trunk/happyboom/makedoc.sh	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/makedoc.sh	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,7 @@
+#!/bin/sh
+test -e doc || mkdir doc
+epydoc \
+    -o doc/api
+    -n "HappyBoom game engine 0.2" \
+    --private-css blue \
+    common net server


Property changes on: happyboom/trunk/happyboom/makedoc.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happyboom/net/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/net/io/__init__.py
===================================================================
--- happyboom/trunk/happyboom/net/io/__init__.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/__init__.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,3 @@
+from packet import Packet
+from io_client import IO_Client
+from base_io import BaseIO

Added: happyboom/trunk/happyboom/net/io/base_io.py
===================================================================
--- happyboom/trunk/happyboom/net/io/base_io.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/base_io.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,128 @@
+#!/usr/bin/python
+# -*- coding: ISO-8859-1 -*-
+
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.io_client import IO_Client
+import time
+import threading
+import socket
+import traceback
+import struct
+
+class BaseIO(object):
+    """
+    Base IO virtual class.
+
+    @ivar verbose: Is verbose ?
+    @type verbose: C{bool}
+    @ivar debug: Display debug messages ?
+    @type debug: C{bool}
+    @ivar on_connect: Event called when the IO try to connect.
+    @type on_connect: C{function()}
+    @ivar on_connection_fails: Event called when the IO fails to connect to server.
+    @type on_connection_fails: C{function()}
+    @ivar on_disconnect: Event called when the server try to disconnect.
+    @type on_disconnect: C{function()}
+    @ivar on_client_connect: Event called when a new client try to connect to the server.
+    @type on_client_connect: C{function(L{IO_Client})}
+    @ivar on_client_disconnect: Event called when a client is disconnected.
+    @type on_client_disconnect: C{function(L{IO_Client})}
+    @ivar on_new_packet: Event called when a new packet is received.
+    @type on_new_packet: C{function(L{Packet})}
+    @ivar _name: The IO name.
+    @type _name: C{str}
+    @ivar _running: Is the thread running ?
+    @type _running: C{bool}
+    """
+    
+    def __init__(self, is_server=False):
+        """
+        Constructor.
+        @type is_server: C{bool}
+        """
+        self.debug = False
+        self.verbose = False 
+        self._is_ready = False
+        self._running = False 
+
+        # Events
+        self.on_connect = None            # No argument
+        self.on_connection_fails = None   # No argument
+        self.on_lost_connection = None    # No argument
+        self.on_disconnect = None         # No argument
+        self.on_client_connect = None     # (client)
+        self.on_client_disconnect = None  # (client)
+        self.on_new_packet = None         # (packet) : client address
+        self.on_send = None               # (data)
+        self.on_receive = None            # (data)
+
+        self._name = None
+
+    def connect(self, host, port):
+        """ Connect to host:port.
+        @parameter host: Network hostname.
+        @type host: C{str}
+        @parameter port: Network port number.
+        @type port: C{int}
+        """
+        if self._name==None:
+            self._name = "%s:%u" % (host, port)
+        self._running = True
+
+    def disconnect(self):
+        """ Close connection. """
+        pass
+
+    def send(self, packet, to=None):
+        """ Send a packet to the server or to all clients. """
+        pass
+    
+    def receive(self, max_size = 1024):
+        """ Read a packet from the socket. Returns None if there is not new data.
+        @parameter max_size: Maximum packet size (in bytes).
+        @type max_size: C{int}
+        @rtype: C{L{Packet}}
+        """
+        pass
+
+    def live(self):                
+        """ Keep the connection alive. """
+        pass
+
+    def disconnectClient(self, client):
+        """ Disconnect an IO client.
+        @type client: L{IO_Client}
+        """
+        pass
+    
+    def run_thread(self):
+        """ Run the IO thread (will call L{live()} itself). """
+        pass
+    
+    def stop(self):
+        """ Stop the IO (close connections). """
+        if not self._running: return
+        self._running = False
+        self.disconnect()
+
+    def __str__(self):
+        return self.name
+    
+    def isRunning(self): return self._running
+
+    #--- Private functions ------------------------------------------------------
+
+    def _getName(self):
+        if self._name == None: return "no name"
+        return self._name
+    
+    def _setName(self, name):
+        self._name = name
+
+    def __getReady(self):
+        return self._is_ready
+
+    #--- Properties -------------------------------------------------------------
+
+    name = property(_getName, _setName, doc="The IO name.")
+    is_ready = property(__getReady, doc="Tells if the IO is ready to use.");

Added: happyboom/trunk/happyboom/net/io/io_client.py
===================================================================
--- happyboom/trunk/happyboom/net/io/io_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/io_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,55 @@
+import socket
+
+class IO_Client(object):
+    """ IO Client.
+    @ivar __addr: Client address (host, port).
+    @type __addr: C{(str,int)}
+    @ivar connected: Is client connected ?
+    @type connected: C{bool}
+    @ivar io: Main IO used by client.
+    @type io: C{L{BaseIO}}
+    @ivar name: Client name.
+    @type name: C{str}
+    """
+    
+    def __init__(self, io, addr, name=None):
+        """ Constructor.
+        @parameter io: Main IO used by client.
+        @type io: C{L{BaseIO}}
+        @parameter addr: Client address (host, port).
+        @type addr: C{(str,int)}
+        @parameter name: Client name.
+        @type name: C{str}
+        """
+        self.__addr = addr
+        self.name = name
+        self.connected = True 
+        self.io = io
+        if self.name == None:
+            self.name = "%s:%u" % (self.host, self.port)
+
+    def send(self, packet):
+        """ Send a packet to the client.
+        @type packet: C{L{Packet}}
+        """
+        pass
+
+    def disconnect(self):    
+        """ Disconnect the client. """
+        self.connected = False
+        self.io.disconnectClient(self)
+
+    def __str__(self):
+        return self.name
+
+    def __getAddr(self):
+        return self.__addr
+    def __getHost(self):
+        if self.__addr[0]=='': return 'localhost'
+        return self.__addr[0]
+    def __getPort(self):
+        return self.__addr[1]
+
+    addr = property(__getAddr, doc="Client address (host, port)")
+    host = property(__getHost, doc="Client network hostname.")
+    port = property(__getPort, doc="Client network port.")

Added: happyboom/trunk/happyboom/net/io/packet.py
===================================================================
--- happyboom/trunk/happyboom/net/io/packet.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/packet.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,173 @@
+"""
+A network packet. It can have differents types :
+1. Data
+2. Ping
+3. Pong
+4. Ack
+
+Ping, pong and ack(nowledge) are only used on transport layer.
+"""
+
+from happyboom.common.log import log
+import time
+import struct
+
+class Packet(object):
+    """ Network packet.
+    @ivar id: Packet identifier.
+    @type id: C{int}
+    @ivar __data: Data string.
+    @type __data: C{str}
+    @ivar type: Packet type (see types).
+    @type type: C{int}
+    @ivar recv_from: Packet shipper.
+    @type recv_from: C{L{IO_Client}}
+    @ivar timeout: Timeout before packet is resend.
+    @type timeout: C{float}
+    @ivar total_timeout: Timeout before packet is said to be "lost".
+    @type total_timeout: C{float}
+    @ivar max_resend: Maximum number of packet resend.
+    @type max_resend: C{int}
+    @ivar use_tcp : Does IO used TCP connection ?
+    @type use_tcp: C{bool}
+    """
+
+    timeout = 0.250
+    total_timeout = 5.000 
+    max_resend = int(total_timeout / timeout)
+    use_tcp = False
+
+    # Packet types
+    PACKET_DATA = 1
+    PACKET_PING = 2
+    PACKET_PONG = 3
+    PACKET_ACK = 4
+
+    def __str__(self):
+        txt = "Packet <type=%u, " % (self.type)
+        if self.__data:
+            txt = txt+"data=\"%s\"" % (self.__data)
+        else:
+            txt = txt+"no data"            
+        if self.skippable: txt = txt+", skippable"
+        return txt+">"
+
+    def __init__(self, str=None, skippable=False):
+        """ Constructor.
+        @parameter str: String data.
+        @type str: C{str}
+        @parameter skippable: Is the packet skippable if link quality is bad ? See skippable attribute.
+        @type skippable: C{bool}
+        """
+        self.sent = 0
+        self.__data = None
+        self.timeout = None
+        self.skippable = skippable
+        self.id = None
+        self.type = Packet.PACKET_DATA
+        self.recv_from = None
+        self.__valid = True
+        if str != None: self.writeStr(str)
+
+    def isValid(self):
+        """ After unpack, say if the packet is valid or not.
+        @rtype: C{bool}
+        """
+        if not Packet.use_tcp and self.id==None: return False
+        return self.__valid 
+        
+    def toStr(self):
+        """ For debug only, convert to string """
+        if self.type == Packet.PACKET_ACK:
+            return "ACK %u [id=%u, skippable=%u]" % (self.id, self.id, self.skippable)
+        if self.type == Packet.PACKET_PING:
+            ping = struct.unpack("!I", self.__data)
+            return "PING %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
+        if self.type == Packet.PACKET_PONG:
+            ping = struct.unpack("!I", self.__data)
+            return "PONG %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
+        else:
+            return "\"%s\" [id=%u, skippable=%u]" \
+                % (self.__data, self.id, self.skippable)
+
+    def unpack(self, binary_data):
+        """ Fill attributes from a binary data packet
+        @parameter binary_data: Binary datas which comes from network.
+        @type C{binary}
+        """
+        if binary_data==None: return
+        self.__valid = False
+
+        if Packet.use_tcp:
+            # Read data len
+            format = "!I"
+            size = struct.calcsize(format)
+            if len(binary_data) <  size:
+                log.warning("Wrong network packet size from %s!" % self.recv_from)
+                return None
+            data = struct.unpack(format, binary_data[:size])
+            data_len = data[0]
+            binary_data = binary_data[size:]
+        else:
+            # Read skippable, id, data len
+            format = "!BBII"
+            size = struct.calcsize(format)
+            if len(binary_data) <  size:
+                log.warning("Wrong network packet size from %s!" % self.recv_from)
+                return None
+            data = struct.unpack(format, binary_data[:size])
+            self.type = data[0]
+            self.skippable = (data[1]==1)
+            self.id = data[2]
+            data_len = data[3]
+            binary_data = binary_data[size:]
+
+        # Read data
+        if 0 < data_len:
+            format = "!%us" % (data_len)
+            size = struct.calcsize(format)
+            if len(binary_data) < size:
+                log.warning("Wrong network packet size from %s!" % self.recv_from)
+                return None
+            data = struct.unpack(format, binary_data[:size]) 
+            self.__data = data[0] 
+        else:
+            self.__data = None
+        self.__valid = True
+        return binary_data[size:]
+
+    def pack(self):
+        """ Pack datas to a binary string (using struct module)
+        @rtype: C{str}
+        """
+        if self.__data != None:
+            data_len = len(self.__data)
+        else:
+            data_len = 0
+        if Packet.use_tcp:
+            data = struct.pack("!I", data_len)
+        else:
+            data = struct.pack("!BBII", 
+                self.type, int(self.skippable), self.id, data_len)
+        if data_len != 0:
+            data = data + struct.pack("!%us" % data_len, self.__data)
+        return data
+        
+    def writeStr(self, str):
+        """ Write a sting into packet (still used ???) """
+        if self.__data == None:
+            self.__data = str
+        else:
+            self.__data = self.__data + str
+        
+    def prepareSend(self):
+        """ Prepare the packet before it will be send : set timeout and send counter. """
+        self.timeout = time.time()+Packet.timeout
+        self.sent = self.sent + 1
+
+    #-- Properties --------------------------------------------------------------
+
+    def getData(self): return self.__data
+    data = property(getData, doc="Packet data.")    
+
+

Added: happyboom/trunk/happyboom/net/io_tcp/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/net/io_tcp/server_waiter.py
===================================================================
--- happyboom/trunk/happyboom/net/io_tcp/server_waiter.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_tcp/server_waiter.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,125 @@
+import socket
+import thread
+import traceback
+from tcp_client import TCP_Client
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+
+class NetworkServerWaiter(object):
+    def __init__(self, server):
+        self.__server = server
+        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.__port = None
+        self.__host = ''
+        self.__max_clients = None
+        self.__nb_clients = 0
+        self.__nb_clients_sema = thread.allocate_lock()
+        self.__listening = False
+        self.__listening_sema = thread.allocate_lock()
+        self.__running = False
+
+    def isRunning(self):
+        return self.__running
+
+    def run_thread(self, port, max_connection):
+        try:
+            self.__running = True
+            self.start(port, max_connection)
+        except Exception, msg:
+            log.error("EXCEPTION IN TCP SERVER WAITER!\n%s\n%s" \
+                % (msg, getBacktrace()))
+        self.__running = False 
+        
+    def clientConnect(self, client):
+        if self.__server.debug:
+            log.info("Client %s enter server %s." \
+                % (client.name, self.__server.name))
+        self.__nb_clients_sema.acquire()
+        self.__nb_clients = self.__nb_clients + 1
+        self.__nb_clients_sema.release()
+        self.__server.clientConnect (client)
+
+    def clientDisconnect(self, client):
+        if self.__server.debug: log.info("New client : %s" % (client.getName()))
+        self.__nb_clients_sema.acquire()
+        self.__nb_clients = self.__nb_clients - 1
+        self.__nb_clients_sema.release()
+
+    def waitClient(self):
+        try:
+            (conn, addr) = self.__socket.accept()
+        except socket.error, err:
+            if err[0] == 11: # Resource temporarily unavailable
+                return None
+            raise
+        if self.__max_clients <= self.getNbClients():
+            if self.__server.debug:
+                log.info( \
+                    "Client %s refused on server %s (too many connection, %u/%u)." \
+                    % (addr, self.__server.name, self.getNbClients(), self.__max_clients))
+            conn.close()
+            return None
+        return TCP_Client(self.__server, addr, socket=conn)
+
+    def start(self, port, max_connection):
+        self.__max_clients = max_connection
+        self.__port = port
+        if self.__server.debug: 
+            log.info("Start %s on port %u." \
+                % (self.__server.name, port))
+        self.__socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        try:
+            self.__socket.bind((self.__host, self.__port))
+            self.__socket.listen(max_connection)
+        except socket.error, err:
+            if self.__server.debug:
+                log.error("Binding error for %s." % (self.__server.name))
+            if self.__server.on_binding_error != None:
+                self.__server.on_binding_error (self.__server)
+            return
+        if self.__server.debug: 
+            log.info("Server %s is listening (max=%u clients)." \
+                % (self.__server.name, max_connection))
+        self.__listening_sema.acquire()
+        self.__listening = True 
+        self.__listening_sema.release()
+
+        while 1:
+            try:
+                client = self.waitClient()
+                if client != None: self.clientConnect (client)
+                client = None
+
+            except socket.error, error:
+                # Connection reset by peer.
+                if error[0] == 104:
+                    if client != None: client.disconnect()
+                else:
+                    raise
+
+    def getNbClients(self):
+        self.__nb_clients_sema.acquire()
+        val = self.__nb_clients
+        self.__nb_clients_sema.release()
+        return val
+    nb_clients = property(getNbClients)
+    
+    def getMaxClients(self):
+        return self.__max_clients
+    max_clients = property(getMaxClients)
+        
+    def getListening(self):
+        self.__listening_sema.acquire()
+        listening = self.__listening
+        self.__listening_sema.release()
+        return listening
+    listening = property(getListening)
+
+    def getPort(self):
+        return self.__port
+    port = property(getPort)
+    
+    def getHost(self):
+        if self.__host == '': return 'localhost'
+        return self.__host
+    host = property(getHost)

Added: happyboom/trunk/happyboom/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/happyboom/net/io_tcp/tcp.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_tcp/tcp.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,211 @@
+#!/usr/bin/python
+# -*- coding: ISO-8859-1 -*-
+
+from happyboom.net.io_tcp.tcp_client import TCP_Client
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.base_io import BaseIO
+from server_waiter import NetworkServerWaiter
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+import time
+import thread
+import socket
+import traceback
+import struct
+
+class IO_TCP(BaseIO):
+    """
+    IO for TCP transport.
+    @ivar packet_timeout: Timeout of packets (in seconds)
+    @type packet_timeout: C{float}
+    @ivar thread_sleep: Sleep time used in the thread (in seconds).
+    @type thread_sleep: C{float}
+    @ivar __is_server: ??? 
+    @type __is_server: C{bool}
+    @ivar __waiter: Class which wait for clients.
+    @type __waiter: NetworkServerWaiter
+    @ivar __addr: The IO network address (host, port).
+    @type __addr: C{(string, string,)}
+    @ivar __clients: List of clients connected to this IO.
+    @type __clients: C{list<L{IO_client<io.IO_Client>}>?}
+    @ivar __clients_sema: Semaphore used to access L{__clients}.
+    @type __clients_sema: C{thread.lock}
+    """
+    
+    def __init__(self, is_server=False):
+        BaseIO.__init__(self)
+        self.packet_timeout = 1.000
+        self.thread_sleep = 0.010
+
+        self.__is_server = is_server
+
+        self.__waiter = NetworkServerWaiter(self)
+        self.__addr = None
+        self.__clients = {}
+        self.__server = None
+        self.__clients_sema = thread.allocate_lock()
+        Packet.use_tcp = True
+
+    def connect(self, host, port):
+        """ Connect to host:port """
+        max_connection = 50
+    
+        self.__addr = (host, port,)
+        if self.__is_server:
+            if self.verbose:
+                log.info("Run server at %s:%u (tcp)" % (self.host, self.port))
+            thread.start_new_thread( self.__waiter.run_thread, (port,max_connection,))
+        else:
+            if self.verbose:
+                log.info("Connect to server %s:%u" % (self.host, self.port))
+            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            try:
+                s.connect(self.__addr)
+            except socket.error, err:
+                if err[0]==111:
+                    if self.verbose:
+                        log.warning("Fail to connect to server %s:%u" % (self.host, self.port))
+                    if self.on_connection_fails:
+                        self.on_connection_fails()
+                    return
+                raise
+
+            client = TCP_Client(self, self.__addr, socket=s)
+            self.__server = client
+            self.__clients_sema.acquire()
+            self.__clients[client.addr] = client
+            self.__clients_sema.release()
+
+        BaseIO.connect(self, host, port)
+        if self.on_connect != None: self.on_connect()
+        self._is_ready = True
+
+    def disconnect(self):
+        """ Close connection """
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        for client_addr, client in clients.items():
+            client.disconnect()
+        if self.on_disconnect != None: self.on_disconnect()
+        self.stop()
+
+    def disconnectClient(self, client):
+        """ Disconnect a client. """
+        self.__clients_sema.acquire()
+        if  self.__clients.has_key(client.addr): del self.__clients[client.addr]
+        self.__clients_sema.release()
+        if self.verbose:
+            log.info("Disconnect client %s." % client)
+        if self.on_client_disconnect != None: self.on_client_disconnect (client)
+        if self.__server == client: self.disconnect()
+    
+    def send(self, packet, to=None):
+        """ Send a packet to the server or to all clients
+        @type packet: Packet
+        """
+        if not self._running: return
+        
+        # Read binary version of the packet
+        data = packet.pack()
+
+        if self.__is_server:
+            if to==None:
+                self.__clients_sema.acquire()
+                clients = self.__clients.copy()
+                self.__clients_sema.release()    
+                for client in clients:
+                    client.sendBinary(data)
+            else:
+                to.sendBinary(data)
+        else:
+            self.__server.sendBinary(data)
+
+    def live(self):                
+        """ Keep the connection alive :
+        - Get clients new packets
+        - Process packets (eg. ping/pong)
+        """
+        clients = self.clients
+        for client_addr, client in clients.items():
+            data = client.receiveNonBlocking()
+            if data != None:
+                self.__processData(client, data)
+
+    def __processData(self, client, data):
+        while data != "":
+            packet = Packet()
+            packet.recv_from = client
+            data = packet.unpack(data)
+            if not packet.isValid():
+                if self.debug:
+                    log.warning("Received buggy network packet from %s!" % client)
+                return
+            if self.debug:
+                log.info("Received %s:%u => \"%s\"" % (client.host, client.port, packet.data))
+            if self.on_new_packet: self.on_new_packet(packet)
+    
+    def run_thread(self):
+        """ Function which should be called in a thread. """
+        try:
+            while self._running:
+                self.live()                
+                time.sleep(self.thread_sleep)
+        except Exception, msg:
+            log.error( \
+                "EXCEPTION DANS LE THREAD IO :\n%s\n%s"
+                % (msg, getBacktrace()))
+        self.stop()
+
+    #--- Private functions ------------------------------------------------------
+
+    def __getPort(self):
+        if self.__addr==None: return "(no port)"
+        return self.__addr[1]
+
+    def __getHost(self):
+        if self.__addr==None: return "(no hostname)"
+        if self.__addr[0]=='': return "localhost"
+        return self.__addr[0]
+
+    def __getAddr(self): return self.__addr
+
+    def _getName(self):
+        if self._name != None: return self._name
+        if self.__addr != None: return self.host
+        return "(no name)"
+        
+    def __getClients(self):
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        return clients
+
+    def __getMaxClients(self):
+        return 0
+    
+    def clientConnect(self, client):
+        client.on_receive = self.on_receive
+        client.on_send = self.on_send
+        self.__clients_sema.acquire()
+        self.__clients[client.addr] = client
+        self.__clients_sema.release()
+        if self.on_client_connect != None: self.on_client_connect (client)
+        
+    def clientDisconnect(self, client):
+        if self.verbose:
+            log.info("Client %s leave server %s." % (client, self))
+        self.__clients_sema.acquire()
+        self.__clients.remove(client)
+        self.__clients_sema.release()
+        self.__waiter.client_disconnect(client)
+        if self.on_client_disconnect != None: self.on_client_disconnect (client)
+        
+    #--- Properties -------------------------------------------------------------
+
+    name = property(_getName, BaseIO._setName)
+    addr = property(__getAddr)
+    port = property(__getPort)
+    host = property(__getHost)
+    clients = property(__getClients)
+    max_clients = property(__getMaxClients)

Added: happyboom/trunk/happyboom/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/happyboom/net/io_tcp/tcp_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_tcp/tcp_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,87 @@
+from happyboom.net.io.io_client import IO_Client
+from happyboom.common.log import log
+import socket
+
+class TCP_Client(IO_Client):
+    """ An TCP client.
+    @ivar __socket: The TCP socket
+    @type __socket: C{socket}
+    @ivar on_send: Event called when a packet is sent to the client.
+    @type on_send: C{function}
+    @ivar on_receive: Event called when a new packet is received.
+    @type on_receive: C{function}
+    """
+    def __init__(self, io_tcp, addr, name=None, socket=None):
+        IO_Client.__init__(self, io_tcp, addr, name)
+        self.__socket = socket 
+        self.on_send = None
+        self.on_receive = None
+
+    def send(self, packet):
+        """ Send a packet to the client.
+        @type packet: Packet
+        """
+        self.sendBinary( packet.pack() )
+    
+    def sendBinary(self, data):
+        """ Send binary datas to the client.
+        @type data: str
+        """
+        if not self.connected: return
+        try:
+            self.__socket.send(data)
+        except SocketError, err:
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+
+    def receiveNonBlocking(self, max_size=1024):
+        """ Non blocking read on the socket. """
+        if not self.connected: return
+        try:
+            self.__socket.setblocking(0)
+            data = self.__socket.recv(max_size)
+        except socket.error, err:
+            if err[0] == 11: return None
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+        return self.__processRecvData(data)
+
+    def receiveBlocking(self, max_size=1024):
+        """ Blocking read on the socket. """
+        if not self.connected: return
+        try:
+            self.__socket.setblocking(1)
+            data = self.__socket.recv(max_size)
+        except socket.error, err:
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+        return self.__processRecvData(data)
+
+    def disconnect(self):
+        """ Disconned the client : close the socket. """
+        self.__socket.close()
+        IO_Client.disconnect(self)
+
+    def __processRecvData(self, data):
+        # If no data, connection is lost
+        if len(data)==0:
+            if self.io.verbose:
+                log.warning("Client %s lost connection with server!" % self)
+            self.disconnect()
+            return None
+
+        # Call user event if needed
+        if self.on_receive != None: self.on_receive(data)
+        return data

Added: happyboom/trunk/happyboom/net/io_udp/__init__.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/__init__.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/__init__.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1 @@
+from udp import IO_UDP

Added: happyboom/trunk/happyboom/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/udp.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/udp.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,363 @@
+# -*- coding: ISO-8859-1 -*-
+
+import time
+import thread
+import socket
+import traceback
+import struct
+from net.io.base_io import BaseIO
+from udp_client import UDP_Client
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+
+class IO_UDP(BaseIO):
+    """ IO for UDP transport.
+    @ivar packet_timeout: Try to send a packet until this timeout.
+    @type packet_timeout: C{float}
+    @ivar thread_sleep: Sleep time used in the thread.
+    @type thread_sleep: C{float}
+    @ivar __is_server: ??? 
+    @type __is_server: C{bool}
+    @ivar __server: The server (only used by clients, None else).
+    @type __server: ?
+    @ivar __running: Is the thread running ?
+    @type __running: C{bool}
+    @ivar __socket: The network socket.
+    @type __socket: C{socket}
+    @ivar __socket_open: Is the network socket L{__socket} opened ?
+    @type __socket_open: C{bool}
+    @ivar __addr: The IO network address (host, port).
+    @type __addr: C{(string, string,)}
+    @ivar __packet_id: ???
+    @type __packet_id: C{int}
+    @ivar __clients: List of clients connected to this IO.
+    @type __clients: C{list<L{IO_client<io.IO_Client>}>?}
+    @ivar __clients_sema: Lock used to access L{__clients}.
+    @type __clients_sema: C{thread.lock}
+    """
+    
+    def __init__(self, is_server=False):
+        """ Constructor. """
+        BaseIO.__init__(self)
+        self.packet_timeout = 1.000
+        self.thread_sleep = 0.010
+
+        self.__is_server = is_server
+        self.__server = None # only used in client mode
+        self.__running = True
+
+        self.__socket = None
+        self.__socket_open = False        
+        self.__addr = None
+        self.__packet_id = 0
+        self.__clients = {}
+        self.__clients_sema = thread.allocate_lock()
+
+    def connect(self, host, port):
+        """ Connect to host:port 
+        @type host: C{str}
+        @type port: C{int}
+        """
+        if host != "":
+            host = socket.gethostbyname(host)
+        else:
+            host = "127.0.0.1"
+        self.__addr = (host, port,)
+        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        if self.__is_server:
+            if self.verbose:
+                log.info("Run server on port %u (udp)." % self.port)
+            self.__socket.bind(("",port,))
+        else:
+            if self.verbose:
+                log.info("Connect to server %s:%u." % (self.host, self.port))
+            self.__server = UDP_Client(self, self.__addr)
+            self.__server.name = "server"
+            self.__server.send_ping = True
+            self.__clients_sema.acquire()
+            self.__clients[self.__addr] = self.__server
+            self.__clients_sema.release()
+
+        self.__socket_open = True
+        self.__socket.setblocking(0)
+
+        if not self.__is_server:
+            self.send( io.Packet("I'm here") )
+        
+        BaseIO.connect(self, host, port)
+
+        # Call user event if needed
+        if self.on_connect != None: self.on_connect()
+
+    def disconnect(self):
+        """ Close connection. """
+        if not self.__socket_open: return
+        self.__socket.close()
+        self.__socket_open = False
+        if self.on_disconnect != None: self.on_disconnect()
+        self.stop()
+
+    def disconnectClient(self, client):
+        """ Disconnect a client.
+        @type client: C{L{IO_Client<io.IO_Client>}}
+        """
+        self.__clients_sema.acquire()
+        if self.__clients.has_key(client.addr): del self.__clients[client.addr]
+        self.__clients_sema.release()
+        if self.verbose:
+            log.info("Disconnect client %s." % client)
+        if self.on_client_disconnect != None: self.on_client_disconnect(client)
+    
+    def send(self, packet, to=None):
+        """ Send a packet to the server or to all clients.
+        @type packet: C{L{Packet<io.Packet>}}
+        @type to: C{L{IO_Client<io.IO_Client>}}
+        """
+        if not self.__socket_open: return
+        first_send = (packet.sent == 0)
+        
+        # No client, exit !
+        if self.__is_server:
+            self.__clients_sema.acquire()
+            nb_clients = len(self.__clients)
+            self.__clients_sema.release()
+            if nb_clients==0: return None
+
+        # Prepare the packet
+        packet.prepareSend()
+        if first_send:
+            # First send : give an ID to the packet
+            self.__packet_id = self.__packet_id + 1
+            packet.id = self.__packet_id
+            if self.debug: packet.creation = time.time()
+        need_ack = first_send and not packet.skippable
+        
+        # Read binary version of the packet
+        data = packet.pack()
+
+        # Send data to client(s)
+        if self.__is_server:
+            if to==None:
+                for addr,client in self.clients.items(): # use internal copy for clients
+                    self.__sendDataTo(packet, data, client, need_ack)
+            else:
+                self.__sendDataTo(packet, data, to, need_ack)
+        else:
+            self.__sendDataTo(packet, data, self.__server, need_ack)
+        
+    def sendBinary(self, data, client):
+        """ Send binary data that doesn't need an acknoledge. 
+        @type data: C{str}
+        @type client: C{L{IO_Client<io.IO_Client>}}
+        """        
+        if self.debug:
+            log.info("Send data %s to %s (without ack)" % (data, client))
+        self.__socket.sendto(data, client.addr)    
+        
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+    
+    def __sendDataTo(self, packet, data, client, need_ack):
+        """ Send binary data with an acknoledge to a client.
+        @type data: C{str}
+        @type client: C{L{IO_Client<io.IO_Client>}}
+        @type need_ack: C{bool}
+        """
+        if self.debug:
+            log.info("Send packet %s to %s" % (packet.toStr(), client))
+        self.__socket.sendto(data, client.addr)
+
+        # If the packet need an ack, add it to the list
+        if need_ack: client.needAck(packet)
+        
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+    
+    def receive(self, max_size = 1024):
+        """ Read a packet from the socket.
+        Returns None if there is not new data.
+        @type max_size: C{int}
+        @rtype: C{L{Packet<io.Packet>}}
+        """
+        if not self.__socket_open: return None
+
+        # Try to read data from the socket
+        try:                        
+            data,addr = self.__socket.recvfrom(max_size)
+        except socket.error, err:
+            if err[0] == 11: return None
+            raise
+    
+        # New client ?
+        return self.__processRecvData(data, addr)
+
+    def live(self):                
+        """ Keep the connection alive. """
+        # Resend packets which don't have received their ack
+        for addr, client in self.clients.items(): # use internal copy for clients
+            client.live()                            
+                    
+        # Read data from network (if needed)
+        packet = self.receive()                
+        if packet != None: self.__processNewPacket(packet)
+                    
+
+    def clientLostConnection(self, client):
+        if self.__is_server:
+            self.__lostClient(client)
+        else:
+            self.lostConnection()
+
+    def __lostClient(self, client):
+        if not client.addr in self.__clients: return
+        client = self.__clients[client.addr]
+        if self.verbose:
+            log.warning("Lost connection with client %s !" % client)
+        self.disconnectClient(client)
+    
+    def lostConnection(self):
+        if self.verbose:
+            log.warning("Lost connection to %s:%u!" % (self.host, self.port))
+        if self.__socket_open:
+            self.__socket.close()
+            self.__socket_open = False
+        if self.on_lost_connection: self.on_lost_connection()
+        self.stop()
+    
+    def run_thread(self):
+        """ Function which should be called in a thread : call L{live()} with a sleep. """
+        try:
+            while self.__running:
+                self.live()                
+                time.sleep(self.thread_sleep)
+        except Exception, msg:
+            log.error( \
+                "EXCEPTION IN UDP SERVER:\n%s\n%s" \
+                % (msg, getBacktrace()))
+            self.stop()
+
+    def stop(self):
+        if not self.__running: return
+        self.__running = False 
+        self.disconnect()
+
+    def isRunning(self): return self.__running
+
+    #--- Private functions ------------------------------------------------------
+
+    def __processRecvData(self, data, addr):
+        if self.__is_server:
+            self.__clients_sema.acquire()
+            if addr not in self.__clients:
+                client = UDP_Client(self, addr)
+                self.__clients[addr] = client
+                self.__clients_sema.release()
+                if self.verbose: log.info("New client: %s:%u." % (addr[0], addr[1]))
+                client.send_ping = True
+                if self.on_client_connect != None: self.on_client_connect(client)
+            else:
+                client = self.__clients[addr] 
+                self.__clients_sema.release()
+        else:
+            # Drop packets which doesn't come from server
+            if self.__server.addr != addr:
+                if self.debug:
+                    log.warning("Drop packet from %s:%u (it isn't the server address)." % (addr[0], addr[1]))
+                return None
+            client = self.__server
+    
+        # Call user event if needed
+        if self.on_receive != None: self.on_receive(data)
+                    
+        # Decode data to normal packet (unpack) 
+        packet = io.Packet()
+        packet.unpack(data)
+        if not packet.isValid():
+            if self.debug:
+                log.warning("Drop invalid network packet from %s" % (data, client))
+            return None
+        
+        # Return packet
+        packet.recv_from = client 
+        return self.__processPacket(packet)
+
+    def __processPacket(self, packet):
+        client = packet.recv_from
+
+        if self.debug:
+            log.info("Received packet %s from %s:%u" % (packet.toStr(), client.host, client.port))
+        
+        # Send an ack if needed
+        if not packet.skippable: self.__sendAck(packet)
+        
+        # Is is a special packet (ack / ping / poing) ?
+        if packet.type == io.Packet.PACKET_ACK:
+            client.processAck(packet)
+            return None
+        if packet.type == io.Packet.PACKET_PING:
+            client.processPing(packet)
+            return None
+        if packet.type == io.Packet.PACKET_PONG:
+            client.processPong(packet)
+            return None
+            
+        # This packet is already received ? Drop it!
+        if client.alreadyReceived(packet.id):
+            if self.debug:
+                log.warning("Drop packet %u (already received)" % packet.id)
+            return None    
+            
+        client.receivePacket(packet)
+        
+        # Returns the new packet
+        return packet
+
+    def __sendAck(self, packet):
+        """ Send an ack for a packet.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        # Write ack to socket
+        ack = io.Packet(skippable=True)
+        ack.type = io.Packet.PACKET_ACK
+        ack.writeStr( struct.pack("!I", packet.id) )
+        #if self.debug: log.info("Send ACK %u." % ack.id)
+        packet.recv_from.send(ack)
+
+    def __processNewPacket(self, packet):
+        """ Do something with a new packet
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        if self.verbose:
+            log.info("New udp message : %s" % packet.toStr())
+        if self.on_new_packet != None: self.on_new_packet(packet)        
+
+    def __getPort(self):
+        return self.__addr[1]
+
+    def __getHost(self):
+        if self.__addr[0]=='': return "localhost"
+        return self.__addr[0]
+
+    def __getAddr(self): return self.__addr
+
+    def _getName(self):
+        if self._name != None: return self._name
+        return self.host
+        
+    def __getClients(self):
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        return clients
+
+    def __getMaxClients(self):
+        return 0
+        
+    #--- Properties -------------------------------------------------------------
+
+    name = property(_getName, BaseIO._setName, doc="The IO name")
+    addr = property(__getAddr, doc="The IO addresse (host, port).")
+    port = property(__getPort, doc="The network port number.")
+    host = property(__getHost, doc="The network hostname.")
+    clients = property(__getClients, doc="List of clients.")
+    max_clients = property(__getMaxClients, doc="Maximum number of clients connected to the server.")

Added: happyboom/trunk/happyboom/net/io_udp/udp_client.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/udp_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/udp_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,146 @@
+from net import io
+import thread
+import time
+import struct
+from happyboom.common.log import log
+from udp_ping import UDP_Pinger 
+
+class UDP_Client(io.IO_Client):
+    """ An UDP Client.
+    @ivar __waitAck: List of packets (id) which are waiting for an acknoledge.
+    @type __waitAck: C{dict<int>, L{Packet<io.Packet>}}
+    @ivar __waitAck_sema: Lock used to access L{__waitAck}.
+    @type __waitAck_sema: C{thread.lock}
+    @ivar __received: List of received packets (id). List used to remove duplicated packets.
+    @type __received: C{dict<int, L{Packet<io.Packet>}>}
+    @ivar __received_sema: Lock used to access L{__received}.
+    @type __received_sema: C{thread.lock}
+    @ivar __pinger: Send regulary ping to server.
+    @type __pinger: C{L{UDP_Pinger}}
+    """
+    def __init__(self, io_udp, addr, name=None):
+        """ Constructor.
+        @parameter io_udp: Main IO.
+        @type io_udp: C{L{IO_UDP}}
+        @parameter addr: The client network address (host, port).
+        @type addr: C{(str, int)}
+        @parameter name: The client name.
+        @type name: C{str}
+        """
+        io.IO_Client.__init__(self, io_udp, addr, name)
+        self.send_ping = False
+        self.__waitAck = {}
+        self.__received = {}
+        self.__waitAck_sema = thread.allocate_lock()
+        self.__received_sema = thread.allocate_lock()
+        self.__pinger = UDP_Pinger(self)
+
+    def alreadyReceived(self, id):
+        """ Tell if a packet (id) is already received.
+        @rtype: C{bool}
+        """
+        self.__received_sema.acquire()
+        received = id in self.__received
+        self.__received_sema.release()
+        return received
+
+    def receivePacket(self, packet):
+        """ Process a new received packet.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        if packet.skippable: return
+        
+        # Store packet to drop packet which are receive twice
+        timeout = time.time()+io.Packet.total_timeout
+        self.__received_sema.acquire()
+        self.__received[packet.id] = timeout 
+        self.__received_sema.release()    
+
+    def processPing(self, id):
+        """ Process a new received ping.
+        @type id: C{int}
+        """
+        self.__pinger.processPing(id)
+        
+    def processPong(self, id):
+        """ Process a new received pong.
+        @type id: C{int}
+        """
+        self.__pinger.processPong(id)
+        
+    def processAck(self, packet):
+        """ Process new received acknoledge.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        # Read packet ID
+        format  = "!I"
+        if len(packet.data) != struct.calcsize(format): return None
+        data = struct.unpack(format, packet.data)
+        id = data[0]
+
+        # Packet still exists ?
+        self.__waitAck_sema.acquire()
+        if not self.__waitAck.has_key(id):
+            self.__waitAck_sema.release()
+            return
+
+        # Debug message
+        if self.io.debug:
+            t = time.time() - self.__waitAck[id].creation
+            log.info("Ack %u received (time=%.1f ms)" % (id, t*1000))
+
+        # The packet don't need ack anymore
+        del self.__waitAck[id]
+        self.__waitAck_sema.release()
+
+    def disconnect(self):
+        """ Disconnect client. """
+        self.io.disconnectClient(self)
+
+    def needAck(self, packet):
+        """ Tell that a packet needs an acknoledge. """
+        self.__waitAck_sema.acquire()
+        self.__waitAck[packet.id] = packet
+        self.__waitAck_sema.release()
+
+    def live(self):
+        """ Keep the connection alive :
+        Resend packet if needed,
+        clean old received packets,
+        send ping if needed.
+        """
+        
+        # Resend packet which don't have received their ack yet
+        self.__waitAck_sema.acquire()
+        waitAckCopy = self.__waitAck.copy()
+        self.__waitAck_sema.release()
+        for id,packet in waitAckCopy.items():
+            if packet.timeout < time.time():
+                if packet.sent < io.Packet.max_resend:
+                    self.send(packet)
+                else:
+                    self.io.clientLostConnection(self)
+
+        # Clean old received packets 
+        self.__received_sema.acquire()
+        receivedCopy = self.__received.copy()
+        self.__received_sema.release()
+        for id,timeout in receivedCopy.items():
+            if timeout < time.time():
+                if self.io.debug:
+                    log.info("Remove old packet %u from %s:%u (clear cache)." \
+                        % (id, self.host, self.port))
+                self.__received_sema.acquire()
+                del self.__received[id]
+                self.__received_sema.release()
+
+        # Send ping if needed
+        if self.send_ping: self.__pinger.live()
+
+    def send(self, packet):
+        """ Send packet to the client. """
+        self.io.send(packet, to=self)
+        
+    def sendBinary(self, data):
+        """ Send binary datas the client. """
+        self.io.sendBinary(data, self)

Added: happyboom/trunk/happyboom/net/io_udp/udp_ping.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/udp_ping.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/udp_ping.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,124 @@
+import time
+import struct
+from net import io
+from happyboom.common.log import log
+
+class UDP_Ping:
+    """ One UDP ping.
+    @ivar timeout: Ping timeout (in seconds).
+    @type timeout: C{float}
+    @ivar creation: Creation time.
+    @type creation: C{float}
+    @ivar id: Ping id.
+    @type id: C{int}
+    """
+    timeout = 5.000
+    
+    def __init__(self, id):
+        """ Constuctor.
+        @type id: C{int}
+        """
+        self.creation = time.time()
+        self.timeout = self.creation+UDP_Ping.timeout
+        self.id = id
+
+    def getPacket(self):
+        """ Create a network packet containing the ping. """
+        ping = io.Packet()
+        ping.type = io.Packet.PACKET_PING
+        ping.writeStr( struct.pack("!I", self.id) )
+        return ping    
+
+class UDP_Pinger:
+    """ An UDP pinger (send ping and process pong).
+    @ivar ping_sleep: Sleep (in seconds) after sending one ping.
+    @type ping_sleep: C{float}
+    @ivar client: The UDP Client.
+    @type client: C{L{UDP_Client<udp.UDP_Client>}}
+    @ivar __sent_ping: List of sent pings (id,packet).
+    @type __sent_ping: C{dict<int, L{UDP_Ping}>}
+    @ivar __ping_id: Next ping id.
+    @type __ping_id: C{int}
+    @ivar __next_ping: Timer until next ping.
+    @type __next_ping: C{float}
+    """
+
+    ping_sleep = 1.000
+    
+    def __init__(self, client):
+        """ Constructor.
+        @type client: C{L{UDP_Client<udp.UDP_Client>}}
+        """
+        self.__next_ping = time.time()+UDP_Pinger.ping_sleep
+        self.__ping_id = 0
+        self.client = client
+        self.__sent_ping = {}
+
+    def processPong(self, id):
+        """ Process pong. """
+        pass
+
+    def sendPing(self):
+        """ Send a new ping : create the packet and send it to the client. """
+        self.__ping_id = self.__ping_id + 1
+        ping = UDP_Ping(self.__ping_id)
+        self.client.send( ping.getPacket() )
+        self.__sent_ping[ping.id] = ping
+                
+    def pingTimeout(self, id):
+        """ Function called when a ping timeout is raised.
+        @parameter id: The ping id.
+        @type id: C{int}
+        """
+        log.error("UDP ping timeout.")
+#        log.error("Disconnect client %s:%u (ping timeout)." \
+#            % (self.client.host, self.client.port))
+#        self.client.disconnect()
+
+    def live(self):
+        """ Remove old ping and send ping if needed. """
+        
+        # Remove old ping
+        for id,ping in self.__sent_ping.items():
+            if ping.timeout < time.time():
+                del self.__sent_ping[id]
+                self.pingTimeout(id)
+        
+        # Send ping if needed
+        if self.__next_ping < time.time():
+            self.__next_ping = time.time()+UDP_Pinger.ping_sleep
+            self.sendPing()
+
+    def __getPingId(self, data):
+        """ Utility used to get an ping id from binary data.
+        @type data: C{str}
+        """
+        format  = "!I"
+        if len(data) != struct.calcsize(format): return None
+        data = struct.unpack(format, data)
+        return data[0]
+
+    def processPing(self, packet):
+        """ Process ping : send pong.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        pong = io.Packet(skippable=True)
+        pong.type = io.Packet.PACKET_PONG
+        pong.writeStr( packet.data )
+        self.client.send(pong)
+        
+    def processPong(self, packet):
+        """ Process pong.
+        @type packet: C{L{Packet<io.Packet>}}
+        """
+        id = self.__getPingId(packet.data)
+        if id == None:
+            if self.debug:
+                log.warning("Received invalid udp ping packet!")
+            return
+
+        # Received too late ?
+        if not self.__sent_ping.has_key(id): return
+
+        # Remove ping from the list
+        del self.__sent_ping[id]

Added: happyboom/trunk/happyboom/net/net_buffer.py
===================================================================
--- happyboom/trunk/happyboom/net/net_buffer.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/net_buffer.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,59 @@
+import thread
+import time
+
+class NetBuffer:
+    """ Buffer used to store network packets. Support multithreading.
+    @ivar blocking_read_sleep : Sleep duration when waiting data from network.
+    @type blocking_read_sleep: C{float}
+    @ivar __buffer: Buffer which store network packets.
+    @type __buffer: C{list<L{Packet<io.Packet>}>}
+    """
+    
+    def __init__(self):
+        """ Constructor. """
+        self.blocking_read_sleep = 0.010
+        self.__buffer = {} 
+        self.__sema = thread.allocate_lock()
+
+    def clear(self, key):
+        """ Clear buffer. """
+        self.__sema.acquire()
+        self.__buffer[key] = [] 
+        self.__sema.release()
+    
+    def append(self, key, data):
+        """ Append new data to the buffer. """
+        self.__sema.acquire()
+        if self.__buffer.has_key(key):
+            self.__buffer[key].append(data)
+        else:
+            self.__buffer[key] = [data]
+        self.__sema.release()
+
+    def readNonBlocking(self, key):
+        """ Read one data. Returns None if their is no data.
+        @rtype: C{str}
+        """
+        self.__sema.acquire()
+        buffer = self.__buffer.get(key, [])
+        self.__buffer[key] = []
+        self.__sema.release()
+        return buffer
+
+    def readBlocking(self, key, timeout):
+        """ Read one data.
+        Returns None if their is no data after the timeout.
+        @type timeout: C{float}
+        @rtype: C{str}
+        """
+        data = None
+        timeout = time.time()+timeout
+        while data == None:
+            if timeout < time.time(): break
+            self.__sema.acquire()
+            if self.__buffer.has_key(key) and len(self.__buffer[key]) != 0:
+                data = self.__buffer[key][0]
+                del self.__buffer[key][0] 
+            self.__sema.release()
+            if data == None: time.sleep(self.blocking_read_sleep)
+        return data

Added: happyboom/trunk/happyboom/release.sh
===================================================================
--- happyboom/trunk/happyboom/release.sh	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/release.sh	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,22 @@
+#!/bin/sh
+PKG="happyboom"
+VERSION="0.1.4"
+FILES="AUTHORS ChangeLog README COPYING"
+OUT="$PKG-$VERSION.tar.bz2"
+TMP_DIR="$PKG-$VERSION"
+
+rm -rf $TMP_DIR
+mkdir $TMP_DIR
+
+for i in $(find . -name "*.py" -o -name "*.sh"; echo $FILES); do
+	FILE=$(echo $i | sed -e 's!\./!!')
+	SUBDIR=$(dirname "$TMP_DIR/$FILE")
+	test -d "$SUBDIR" || mkdir -p $SUBDIR
+	ln $PWD/$FILE $TMP_DIR/$FILE
+done
+
+echo "Creating archive $OUT .."
+tar --create  --bzip --dereference --file $OUT $TMP_DIR	
+rm -rf $TMP_DIR
+
+echo "Done."


Property changes on: happyboom/trunk/happyboom/release.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happyboom/run.sh
===================================================================
--- happyboom/trunk/happyboom/run.sh	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/run.sh	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,5 @@
+#!/bin/sh
+xterm -e "cd $PWD; python console_server.py" &
+sleep 1
+xterm -e "cd $PWD; python console_view.py" &
+xterm -e "cd $PWD; python console_input.py" &


Property changes on: happyboom/trunk/happyboom/run.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happyboom/server/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/server/agent.py
===================================================================
--- happyboom/trunk/happyboom/server/agent.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/agent.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,39 @@
+from pysma import ActionAgent, ActionMessage as Message
+from happyboom.common.log import log
+from happyboom.common.event import EventLauncher, EventListener
+
+class Agent(ActionAgent, EventLauncher, EventListener):
+    """
+    SMA agent in HappyBoom.
+    """
+    def __init__(self, type, gateway, **args):
+        EventLauncher.__init__(self)
+        EventListener.__init__(self)
+        ActionAgent.__init__(self, prefix="msg_")
+        self._gateway = gateway
+        self.type = type
+        self.__debug = args.get("debug", False)
+        self.sendBroadcast = self.sendBroadcastMessage
+
+    def netCreateItem(self, client):
+        if self.type in client.features:
+            self.launchEvent("happyboom", "netCreateItem", client, self)
+        elif self.__debug:
+            log.info("Client %s doesn't want item %s" % (client, self.type))
+
+    def born(self):
+        self.requestRole(self.type)
+
+    def requestActions(self, type):
+        self.requestRole("%s_listener" %type)
+        
+    def send(self, action, *arg, **kw):
+        message = Message("%s_%s" %(self.type, action), arg, kw)
+        self.sendBroadcastMessage(message, "%s_listener" %self.type)
+
+    def sendNetMsg(self, func, event, *args):
+        self.launchEvent("happyboom", "network", func, event, *args)
+
+    def messageReceived(self, msg):
+        if self.__debug:
+            log.warning("Unhandled message : %s -- %s" %(type(self), msg))

Added: happyboom/trunk/happyboom/server/base_server.py
===================================================================
--- happyboom/trunk/happyboom/server/base_server.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/base_server.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,52 @@
+# TODO: Check if it's always possible to send skippable packets
+
+from happyboom.common.log import log
+from happyboom.server.gateway import Gateway
+from happyboom.server.client_manager import ClientManager
+import random, thread, time
+
+class Server(object):
+    def __init__(self, gateway, client_manager, arg): #verbose=False, debug=False):
+        self.started = False
+        self.__debug = arg.get('debug', False)
+        self.__verbose = arg.get('verbose', False)
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        self.__gateway = gateway 
+        self.__client_manager = client_manager
+        self.__gateway.server = self
+        self.__gateway.client_manager.server = self
+        random.seed()
+        self.__items = []
+        
+    def born(self):
+        self.gateway.born()
+        
+    def start(self):
+        if self.__verbose: log.info("[*] Starting server...")
+        self.__gateway.start()
+        self.__client_manager.start()
+        log.info("[*] Server started")
+        
+        self.__stoplock.acquire()
+        running = not self.__stopped
+        self.__stoplock.release()
+        while running:
+            self.__gateway.process()
+            self.__client_manager.process()
+            time.sleep(0.01)
+            self.__stoplock.acquire()
+            running = not self.__stopped
+            self.__stoplock.release()
+
+    def stop(self):
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return
+        self.__stopped = True
+        self.__stoplock.release()
+        if self.__verbose: log.info("[*] Stopping server...")
+        self.__client_manager.stop()
+        self.__gateway.stop()
+        log.info("[*] Server stopped")

Added: happyboom/trunk/happyboom/server/client.py
===================================================================
--- happyboom/trunk/happyboom/server/client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,45 @@
+from happyboom.common.protocol import ProtocolException
+from happyboom.common.log import log
+
+class Client(object):
+    """
+    High-level class for a client in the server.
+    """
+
+    def __init__(self, io_client, gateway, client_manager):
+        self.io = io_client
+        self.__client_manager = client_manager
+        self.__gateway = gateway
+        self.signature = None
+        self.features = [] 
+
+    def __str__(self):
+        return self.io.__str__()
+
+    def disconnect(self, reason):
+        self.launchEvent("happyboom", "clientDisconnect", self.io, reason)
+
+    # Stop client: close socket.
+    def stop(self):
+        self.io.disconnect()
+
+    # Read a message from network stack
+    # Blocking function, returns None after timeout seconds (no data)
+    def read(self, timeout):
+        return self.__client_manager.readClientAnswer(self.io, timeout)
+
+    # Send a network packet the the client socket
+    def sendPacket(self, packet):
+        self.io.send(packet)
+
+    # Send a HappyBoom message to the client (see L{sendPacket})
+    def sendNetMsg(self, feature, event, *args):
+        try:
+            data = self.__protocol.createMsg(feature, event, *args)
+        except ProtocolException, err:
+            log.error(err)
+            return
+        self.launchEvent("happyboom", "event", (self,), data);
+
+    def __getAddr(self): return self.io.addr
+    addr = property(__getAddr)

Added: happyboom/trunk/happyboom/server/client_manager.py
===================================================================
--- happyboom/trunk/happyboom/server/client_manager.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/client_manager.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,152 @@
+Pfrom happyboom.net.io_tcp.tcp import IO_TCP
+from happyboom.common.packer import unpackBin
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+from happyboom.server.client import Client
+from happyboom.common.event import EventLauncher
+import thread, time
+
+class ClientManager(EventLauncher, object):
+    def __init__(self, protocol, arg): 
+        EventLauncher.__init__(self)
+        self.server = None 
+        self.__protocol = protocol
+        self.__io = IO_TCP(is_server=True)
+        self.__io.debug = arg.get("debug", False)
+        self.__io.verbose = arg.get("verbose", False)
+        self.__debug = arg.get("debug", False)
+        self.__verbose = arg.get("verbose", False)
+        self.max_clients = arg.get("max_clients", 2)
+        self.client_port = arg.get("client_port", 12430)
+        self.__supported_features = {}
+        self.__clients = {}
+        self.__clients_lock = thread.allocate_lock()
+        self.gateway = None
+        self.presentation = None
+
+    def onClientDisconnection(self, ioclient, reason):
+        log.info("Client %s leave us: %s" % (ioclient, reason))
+        self.closeClient(ioclient)
+
+    def onClientConnection(self, ioclient, version, signature):
+        # TODO: Case where signature != "" ??? (reconnection)
+        if self.__verbose: log.info("Client %s try to connect : check version." % ioclient)
+        server_version = self.__protocol.version
+        if version == server_version:
+            if self.__verbose: log.info("Client %s try to connect: version ok." % ioclient)
+            signature = self.generateSignature(ioclient)
+            self.launchEvent("happyboom", "connection", ioclient, server_version, signature)
+        else:    
+            if self.__verbose: log.warning("Client %s try to connect: wrong version (%s)." % version)
+            self.launchEvent("happyboom", "closeConnection", ioclient, u"Wrong server version (%s VS %s)" % (version, serveur_version))
+
+    def onClientFeatures(self, ioclient, features):
+        # Register client in the clients list
+        client = Client(ioclient, self.gateway, self)
+        self.__clients_lock.acquire() 
+        self.__clients[client.addr] = client
+        self.__clients_lock.release() 
+
+        # Register client to features
+        for feature in features:
+            f = self.__protocol[ord(feature)]
+            feature = f.name
+            if self.__verbose: log.info("Register feature %s for client %s" % (feature, client))
+            if feature in self.__supported_features:
+                self.__supported_features[feature].append(ioclient)
+            else:
+                self.__supported_features[feature] = [ioclient]
+            client.features.append(feature)
+      
+        # Send message to network and to the log
+        txt = u"Welcome to new (display) client : %s" % client
+        log.info("[*] Client %s connected" % client)
+        self.launchEvent("happyboom", "network", "info", "notice", txt)
+        self.launchEvent("happyboom", "newClient", client)
+
+    def stop(self):
+        for client in self.__clients.values():
+            client.stop()
+
+    def process(self):
+        if not self.__io.isRunning():
+            self.server.stop()
+
+    def start(self):
+        if self.__verbose: log.info("[*] Starting server")
+        self.__io.name = "server"
+        self.__io.on_client_connect = self.openClient
+        self.__io.on_client_disconnect = self.closeClient
+        self.__io.on_new_packet = self.presentation.processPacket
+        self.__io.connect('', self.client_port)
+        self.launchEvent("happyboom", "register", "connection", self.onClientConnection)
+        self.launchEvent("happyboom", "register", "disconnection", self.onClientDisconnection)
+        self.launchEvent("happyboom", "register", "features", self.onClientFeatures)
+        thread.start_new_thread(self.run_io_thread, ())
+
+    def registerFeature(self, client, role):
+        if role in self.__supported_features:
+            if client not in self.__supported_features[role]:
+                self.__supported_features[role].append(client)
+        else:
+            self.__supported_features[role] = [client,]
+        
+    def openClient(self, ioclient):
+        if self.__verbose: log.info("[*] Client %s try to connect ..." % ioclient)
+
+    def removeClient(self, ioclient):
+        if self.__verbose: log.info("Disconnect client %s." % ioclient)
+        self.gateway.sendText(u"Client %s leave us." % ioclient)
+
+        self.__clients_lock.acquire() 
+        del self.__clients[ioclient.addr]
+        self.__clients_lock.release() 
+    
+    def closeClient(self, ioclient):
+        # TODO: get client of type Client for the client of type ClientIO to send
+        # him bye
+#        client.sendNetMsg("presentation", "bye", "utf8", u"Lost connection")
+        client = self.getClientByAddr(ioclient.addr)
+        if client == None: return
+        log.info("[*] Client %s leave us." % client)
+        self.removeClient(client.io)
+        
+    def __clientChallenge(self, client, func):
+        try:
+            func(client)
+        except Exception, msg:
+            log.error( \
+                "EXCEPTION WHEN A CLIENT TRY TO CONNECT :\n%s\n%s" \
+                % (msg, getBacktrace()))
+            self.stop()
+
+    # Function which should be called in a thread
+    # TODO: Why is this used?
+    def run_io_thread(self):
+        try:
+            while self.__io.isRunning():
+                self.__io.live()                
+                time.sleep(0.001)
+        except Exception, msg:
+            log.error( \
+                "EXCEPTION IN IO THREAD :\n%s\n%s" \
+                % (msg, getBacktrace()))
+            self.server.stop()
+
+    def generateSignature(self, ioclient):
+        import random
+        r1 = random.randint(0,1000000)
+        r2 = random.randint(0,1000000)
+        return "%s%s%s" % (r1,ioclient.addr,r2)
+
+    def getClientByAddr(self, addr):
+        """ Returns None if no client matchs. """
+        self.__clients_lock.acquire() 
+        client = self.__clients.get(addr, None)
+        self.__clients_lock.release() 
+        return client
+        
+    def __getSupportedFeatures(self): return self.__supported_features
+    supported_features = property(__getSupportedFeatures)
+
+

Added: happyboom/trunk/happyboom/server/gateway.py
===================================================================
--- happyboom/trunk/happyboom/server/gateway.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/gateway.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,83 @@
+from happyboom.server.agent import Agent, Message
+from happyboom.common.protocol import loadProtocol, ProtocolException
+from happyboom.net.io import Packet
+from happyboom.common.log import log
+from pysma import Kernel, DummyScheduler
+from happyboom.common.event import EventListener
+import struct
+
+class Gateway(Agent, EventListener):
+    def __init__(self, protocol, presentation, client_manager, arg):
+        EventListener.__init__(self, "evt_")
+        Agent.__init__(self, self, "gateway")
+        self.__protocol = protocol
+        self.client_manager = client_manager
+        self.presentation = presentation
+        self.presentation.gateway = self 
+        self.presentation.client_manager = self.client_manager
+        self.client_manager.presentation = self.presentation
+        self.__server = None 
+        self._debug = arg.get("debug", False)
+        self._verbose = arg.get("verbose", False)
+        self.__scheduler = DummyScheduler(sleep=0.01)
+        self.registerEvent("happyboom")
+        Kernel().addAgent(self.__scheduler)
+
+    def eventPerformed(self, event):
+        p = self.pattern % self.getEventName(event.type, event.event)
+
+    def __setServer(self, server):
+        self.__server = server
+        self.client_manager.server = server
+    server = property(None, __setServer)
+
+#    def eventPerformed(self, event):
+#        print "gzzz", event
+
+    def evt_happyboom_network(self, feature, event, *args):
+        self.sendNetMsg(feature, event, *args)
+        
+    def evt_happyboom_netCreateItem(self, client, item):
+        try:
+            type = item.type
+            type = self.presentation.protocol.getFeature(type)
+            type = type.id
+        except ProtocolException, err:
+            log.error(err)
+            return
+        self.launchEvent("happyboom", "create", client.io, type, item.id);
+        
+    def start(self):
+        Kernel.instance.addAgent(self)
+        self.launchEvent("happyboom", "register", "recv_event", self.recvNetMsg)
+        
+    def stop(self):
+        self.sendNetMsg("game", "stop")
+        Kernel.instance.stopKernel()
+
+    def process(self):
+        # Stop server if the scheduler is dead
+#       TODO: Waiting for last PySMA version...        
+#        if not self.__scheduler.alive:
+#            self.__server.stop()
+        pass
+
+    def sendText(self, txt, client=None):
+        if client != None:
+            client.sendMsg("chat", "message", txt)
+        else:
+            self.sendNetMsg("chat", "message", txt)
+
+    def recvNetMsg(self, ioclient, feature, event, args):
+        if self._verbose: log.info("Received: %s.%s%s" % (feature, event, args))
+        message = Message("%s_%s" % (feature, event), args)
+        self.sendBroadcastMessage(message, "%s_listener" % feature)
+
+    def evt_happyboom_newClient(self, client):
+        self.launchEvent("gateway", "syncClientCreate", client)
+        self.launchEvent("gateway", "syncClient", client)
+
+    def sendNetMsg(self, feature, event, *args):
+        clients = self.client_manager.supported_features.get(feature, ())
+        if len(clients)==0: return
+        self.launchEvent("happyboom", "event", clients, feature, event, args);

Added: happyboom/trunk/happyboom/server/server_agent.py
===================================================================
--- happyboom/trunk/happyboom/server/server_agent.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/server_agent.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,14 @@
+from agent import *
+
+class ServerAgent(Agent):
+    def __init__(self, type):
+        Agent.__init__(self)
+        self.type = type
+        self.id = -1 
+        self.server = None
+
+    def sendMsg(self, role, type, arg=None, client=None, skippable=False):
+        if client != None:
+            self.server.sendMsgToClient(client, role, type, arg, skippable=skippable)
+        else:
+            self.server.sendMsg(role, type, arg, skippable=skippable)

Added: happyboom/trunk/happyboom/server/stat.py
===================================================================
--- happyboom/trunk/happyboom/server/stat.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/stat.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,91 @@
+import time
+import server_agent 
+
+class ServerStat:
+    def __init__(self, server):
+        self.started = time.time()
+        self.server = server
+        self.net_in = 0
+        self.net_out = 0
+
+    # Event called on new sent/read data from network
+    def onNetSend(self, data):
+        self.net_out = self.net_out + len(data)
+    def onNetReceive(self, data):
+        self.net_in = self.net_in + len(data)
+
+    # Number of seconds since server started
+    def getUptime(self):
+        return int( time.time() - self.started )
+
+    # Current/Maximum number of view/input clients
+    def getNbInputs(self):
+        return self.server.getNbInput()
+    def getNbViews(self):
+        return self.server.getNbView()
+    def getMaxViews(self):
+        return self.server.getMaxNbView()
+    def getMaxInputs(self):
+        return self.server.getMaxNbInput()
+
+class ServerStatAgent(server_agent.ServerAgent):
+    def __init__(self):
+        server_agent.ServerAgent.__init__(self, "server_stat")
+        self.uptime = None
+        self.nb_view = None
+        self.nb_input = None
+        self.net_in = None
+        self.net_out = None
+        self.max_views = None
+        self.max_inputs = None
+        self.net_time = time.time()
+        self.net_time_update = 1.0
+
+    def sync(self, client=None):
+        if self.uptime != None:
+            self.sendMsg("server_stat", "Uptime", "%u" % self.uptime, client)
+        if self.max_views != None:
+            self.sendMsg("server_stat", "MaxViews", "%u" % self.max_views, client)
+        if self.max_inputs != None:
+            self.sendMsg("server_stat", "MaxInputs", "%u" % self.max_inputs, client)
+        if self.nb_input != None:
+            self.sendMsg("server_stat", "NbInput", "%u" % self.nb_input, client)
+        if self.nb_view != None:
+            self.sendMsg("server_stat", "NbView", "%u" % self.nb_view, client)
+        if (self.net_in != None) and (self.net_out != None):
+            self.sendMsg("server_stat", "NetStat", "%u,%u" % (self.net_in, self.net_out), client)
+    
+    def update(self):
+        if self.server.stat == None: return
+        
+        if self.max_views == None:
+            self.max_views = self.server.stat.getMaxViews()
+        
+        if self.max_inputs == None:
+            self.max_inputs = self.server.stat.getMaxInputs()
+        
+        if self.net_time_update < time.time() - self.net_time:
+            self.net_time = time.time()
+            if (self.server.stat.net_in != self.net_in) \
+            or (self.server.stat.net_out != self.net_out):
+                self.net_in = self.server.stat.net_in
+                self.net_out = self.server.stat.net_out
+                self.sendMsg("server_stat", "NetStat", "%u,%u" % (self.net_in, self.net_out,))
+        
+        input = self.server.stat.getNbInputs()
+        if input != self.nb_input:
+            self.nb_input = input
+            self.sendMsg("server_stat", "NbInput", "%u" % self.nb_input)
+        
+        view = self.server.stat.getNbViews()
+        if view != self.nb_view:
+            self.nb_view = view
+            self.sendMsg("server_stat", "NbView", "%u" % self.nb_view)
+
+        uptime = self.server.stat.getUptime()
+        if uptime != self.uptime:
+            self.uptime = uptime
+            self.sendMsg("server_stat", "Uptime", "%u" % self.uptime)            
+
+    def live(self):
+        self.update()

Added: happyboom/trunk/happyboom/specification/client.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/happyboom/specification/client.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: happyboom/trunk/happyboom/specification/server.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/happyboom/specification/server.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: happyboom/trunk/happyboom/specification/socket_at_server_side.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/happyboom/specification/socket_at_server_side.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From haypo at berlios.de  Tue Sep 20 01:02:03 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 20 Sep 2005 01:02:03 +0200
Subject: [Happyboom-svn] r214 - in happyboom/trunk: net/io net/io_tcp net/io_udp specification
Message-ID: <200509192302.j8JN233L025659@sheep.berlios.de>

Author: haypo
Date: 2005-09-20 01:01:57 +0200 (Tue, 20 Sep 2005)
New Revision: 214

Added:
   happyboom/trunk/specification/happyboom_net.xmi
Modified:
   happyboom/trunk/net/io/packet.py
   happyboom/trunk/net/io_tcp/server_waiter.py
   happyboom/trunk/net/io_tcp/tcp.py
   happyboom/trunk/net/io_udp/udp.py
   happyboom/trunk/net/io_udp/udp_ping.py
Log:
La fonction Packet.toStr() est remplacee par Packet.__str__(), et la
methode NetworkServerWaiter.run_thread() devient runThread() pour respecter
la convention du code.


Modified: happyboom/trunk/net/io/packet.py
===================================================================
--- happyboom/trunk/net/io/packet.py	2005-09-19 22:53:33 UTC (rev 213)
+++ happyboom/trunk/net/io/packet.py	2005-09-19 23:01:57 UTC (rev 214)
@@ -75,19 +75,19 @@
         if not Packet.use_tcp and self.id==None: return False
         return self.__valid 
         
-    def toStr(self):
+    def __str__(self):
         """ For debug only, convert to string """
         if self.type == Packet.PACKET_ACK:
-            return "ACK %u [id=%u, skippable=%u]" % (self.id, self.id, self.skippable)
+            return "Packet ACK %u <id=%u, skippable=%u>" % (self.id, self.id, self.skippable)
         if self.type == Packet.PACKET_PING:
             ping = struct.unpack("!I", self.__data)
-            return "PING %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
+            return "Packet PING %u <id=%u, skippable=%u>" % (ping[0], self.id, self.skippable)
         if self.type == Packet.PACKET_PONG:
             ping = struct.unpack("!I", self.__data)
-            return "PONG %u [id=%u, skippable=%u]" % (ping[0], self.id, self.skippable)
+            return "Packet PONG %u <id=%u, skippable=%u>" % (ping[0], self.id, self.skippable)
         else:
-            return "\"%s\" [id=%u, skippable=%u]" \
-                % (self.__data, self.id, self.skippable)
+            return "Packet <id=%u, skippable=%u>" \
+                % (self.id, self.skippable)
 
     def unpack(self, binary_data):
         """ Fill attributes from a binary data packet
@@ -152,6 +152,8 @@
             data = data + struct.pack("!%us" % data_len, self.__data)
         return data
         
+    # TODO: Remove this function, only used in UDP
+    # code
     def prepareSend(self):
         """ Prepare the packet before it will be send : set timeout and send counter. """
         self.timeout = time.time()+Packet.timeout

Modified: happyboom/trunk/net/io_tcp/server_waiter.py
===================================================================
--- happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-19 22:53:33 UTC (rev 213)
+++ happyboom/trunk/net/io_tcp/server_waiter.py	2005-09-19 23:01:57 UTC (rev 214)
@@ -21,7 +21,7 @@
     def isRunning(self):
         return self.__running
 
-    def run_thread(self, port, max_connection):
+    def runThread(self, port, max_connection):
         try:
             self.__running = True
             self.start(port, max_connection)

Modified: happyboom/trunk/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/net/io_tcp/tcp.py	2005-09-19 22:53:33 UTC (rev 213)
+++ happyboom/trunk/net/io_tcp/tcp.py	2005-09-19 23:01:57 UTC (rev 214)
@@ -54,7 +54,7 @@
         if self.__is_server:
             if self.verbose:
                 log.info("Run server at %s:%u (tcp)" % (self.host, self.port))
-            thread.start_new_thread( self.__waiter.run_thread, (port,max_connection,))
+            thread.start_new_thread( self.__waiter.runThread, (port,max_connection,))
         else:
             if self.verbose:
                 log.info("Connect to server %s:%u" % (self.host, self.port))

Modified: happyboom/trunk/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/net/io_udp/udp.py	2005-09-19 22:53:33 UTC (rev 213)
+++ happyboom/trunk/net/io_udp/udp.py	2005-09-19 23:01:57 UTC (rev 214)
@@ -165,7 +165,7 @@
         @type need_ack: C{bool}
         """
         if self.debug:
-            log.info("Send packet %s to %s" % (packet.toStr(), client))
+            log.info("Send packet %s to %s" % (packet, client))
         self.__socket.sendto(data, client.addr)
 
         # If the packet need an ack, add it to the list
@@ -286,7 +286,7 @@
         client = packet.recv_from
 
         if self.debug:
-            log.info("Received packet %s from %s:%u" % (packet.toStr(), client.host, client.port))
+            log.info("Received packet %s from %s:%u" % (packet, client.host, client.port))
         
         # Send an ack if needed
         if not packet.skippable: self.__sendAck(packet)
@@ -329,7 +329,7 @@
         @type packet: C{L{Packet}}
         """
         if self.verbose:
-            log.info("New udp message : %s" % packet.toStr())
+            log.info("New udp message : %s" % packet)
         if self.on_new_packet != None: self.on_new_packet(packet)        
 
     def __getPort(self):

Modified: happyboom/trunk/net/io_udp/udp_ping.py
===================================================================
--- happyboom/trunk/net/io_udp/udp_ping.py	2005-09-19 22:53:33 UTC (rev 213)
+++ happyboom/trunk/net/io_udp/udp_ping.py	2005-09-19 23:01:57 UTC (rev 214)
@@ -54,10 +54,6 @@
         self.client = client
         self.__sent_ping = {}
 
-    def processPong(self, id):
-        """ Process pong. """
-        pass
-
     def sendPing(self):
         """ Send a new ping : create the packet and send it to the client. """
         self.__ping_id = self.__ping_id + 1
@@ -121,4 +117,4 @@
         if not self.__sent_ping.has_key(id): return
 
         # Remove ping from the list
-        del self.__sent_ping[id]
+        del self.__sent_ping[id]
\ No newline at end of file

Added: happyboom/trunk/specification/happyboom_net.xmi
===================================================================
--- happyboom/trunk/specification/happyboom_net.xmi	2005-09-19 22:53:33 UTC (rev 213)
+++ happyboom/trunk/specification/happyboom_net.xmi	2005-09-19 23:01:57 UTC (rev 214)
@@ -0,0 +1,6761 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<XMI xmlns:UML="http://schema.omg.org/spec/UML/1.3" verified="false" timestamp="2005-09-20T00:48:30" xmi.version="1.2" >
+ <XMI.header>
+  <XMI.documentation>
+   <XMI.exporter>umbrello uml modeller http://uml.sf.net</XMI.exporter>
+   <XMI.exporterVersion>1.4.2</XMI.exporterVersion>
+   <XMI.exporterEncoding>UnicodeUTF8</XMI.exporterEncoding>
+  </XMI.documentation>
+  <XMI.metamodel xmi.name="UML" href="UML.xml" xmi.version="1.3" />
+ </XMI.header>
+ <XMI.content>
+  <UML:Model isSpecification="false" isLeaf="false" isRoot="false" isAbstract="false" >
+   <UML:Namespace.ownedElement>
+    <UML:Stereotype isSpecification="false" isLeaf="false" visibility="public" xmi.id="3" isRoot="false" isAbstract="false" name="datatype" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="2" isRoot="false" isAbstract="false" name="int" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="4" isRoot="false" isAbstract="false" name="char" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="5" isRoot="false" isAbstract="false" name="bool" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="6" isRoot="false" isAbstract="false" name="float" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="7" isRoot="false" isAbstract="false" name="double" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="8" isRoot="false" isAbstract="false" name="long" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="9" isRoot="false" isAbstract="false" name="short" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="10" isRoot="false" isAbstract="false" name="string" />
+    <UML:DataType stereotype="3" isSpecification="false" isLeaf="false" visibility="public" xmi.id="14" isRoot="false" isAbstract="false" name="void" />
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="11" isRoot="false" isAbstract="true" name="BaseIO" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="193" isRoot="false" initialValue="" type="10" isAbstract="false" name="name" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="196" isRoot="false" initialValue="" type="5" isAbstract="false" name="is_ready" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="13" isRoot="false" isAbstract="false" name="connect" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="15" isRoot="false" value="" type="10" isAbstract="false" name="host" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="16" isRoot="false" value="" type="2" isAbstract="false" name="port" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="124" isRoot="false" isAbstract="false" name="disconnect" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="179" isRoot="false" isAbstract="false" name="disconnectClient" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="180" isRoot="false" value="" type="134" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="126" isRoot="false" isAbstract="false" name="send" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="127" isRoot="false" value="" type="17" isAbstract="false" name="packet" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="129" isRoot="false" value="None" type="2" isAbstract="false" name="to" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="167" isRoot="false" isAbstract="false" name="receive" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter kind="return" xmi.id="1430" type="17" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="168" isRoot="false" value="1024" type="2" isAbstract="false" name="max_size" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="176" isRoot="false" isAbstract="false" name="live" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="189" isRoot="false" isAbstract="false" name="stop" />
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="17" isRoot="false" isAbstract="false" name="Packet" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="235" isRoot="false" initialValue="" type="10" isAbstract="false" name="data" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="18" isRoot="false" isAbstract="false" name="pack" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter kind="return" xmi.id="1431" type="10" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="21" isRoot="false" isAbstract="false" name="unpack" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="22" isRoot="false" value="" type="10" isAbstract="false" name="data" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="207" isRoot="false" isAbstract="false" name="isValid" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter kind="return" xmi.id="1432" type="5" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="222" isRoot="false" isAbstract="false" name="__str__" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter kind="return" xmi.id="1433" type="10" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="27" isRoot="false" isAbstract="false" name="IO_TCP" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="252" isRoot="false" initialValue="" type="14" isAbstract="false" name="clients" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="261" isRoot="false" isAbstract="false" name="sendBinary" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="262" isRoot="false" value="" type="10" isAbstract="false" name="data" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="267" isRoot="false" value="" type="80" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="288" isRoot="false" isAbstract="false" name="clientLostConnection" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="289" isRoot="false" value="" type="80" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="346" isRoot="false" isAbstract="false" name="lostConnection" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="355" isRoot="false" isAbstract="false" name="isRunning" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter kind="return" xmi.id="1434" type="5" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="29" isRoot="false" isAbstract="false" name="IO_UDP" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="1063" isRoot="false" initialValue="" type="14" isAbstract="false" name="clients" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="1074" isRoot="false" initialValue="" type="2" isAbstract="false" name="max_clients" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1000" isRoot="false" isAbstract="false" name="disconnectClient" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="1001" isRoot="false" value="" type="11" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1012" isRoot="false" isAbstract="false" name="sendBinary" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="1013" isRoot="false" value="" type="10" isAbstract="false" name="data" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="1019" isRoot="false" value="" type="134" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1030" isRoot="false" isAbstract="false" name="clientLostConnection" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="1031" isRoot="false" value="" type="134" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1042" isRoot="false" isAbstract="false" name="lostConnection" />
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="31" isRoot="false" isAbstract="false" name="NetworkServerWaiter" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="973" isRoot="false" initialValue="" type="2" isAbstract="false" name="nb_clients" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="950" isRoot="false" initialValue="" type="2" isAbstract="false" name="max_clients" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="956" isRoot="false" initialValue="" type="10" isAbstract="false" name="host" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="962" isRoot="false" initialValue="" type="2" isAbstract="false" name="port" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="979" isRoot="false" initialValue="" type="5" isAbstract="false" name="listening" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="714" isRoot="false" isAbstract="false" name="runThread" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="808" isRoot="false" value="" type="2" isAbstract="false" name="port" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="814" isRoot="false" value="" type="2" isAbstract="false" name="max_connection" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="720" isRoot="false" isAbstract="false" name="clientConnect" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="721" isRoot="false" value="" type="134" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="732" isRoot="false" isAbstract="false" name="clientDisconnect" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="733" isRoot="false" value="" type="17" isAbstract="false" name="client" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="779" isRoot="false" isAbstract="false" name="waitClient" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="785" isRoot="false" isAbstract="false" name="start" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="786" isRoot="false" value="" type="2" isAbstract="false" name="port" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="792" isRoot="false" value="" type="2" isAbstract="false" name="max_connection" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="33" isRoot="false" isAbstract="false" name="TCP_Client" >
+     <UML:Classifier.feature>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="565" isRoot="false" isAbstract="false" name="receiveNonBlocking" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="566" isRoot="false" value="1024" type="2" isAbstract="false" name="max_size" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="577" isRoot="false" isAbstract="false" name="receiveBlocking" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="578" isRoot="false" value="1024" type="2" isAbstract="false" name="max_size" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="502" isRoot="false" isAbstract="false" name="sendBinary" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="503" isRoot="false" value="" type="10" isAbstract="false" name="data" />
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="509" isRoot="false" value="" type="134" isAbstract="false" name="to" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="35" isRoot="false" isAbstract="false" name="UDP_Pinger" >
+     <UML:Classifier.feature>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1347" isRoot="false" isAbstract="false" name="processPong" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="1348" isRoot="false" value="" type="2" isAbstract="false" name="id" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1359" isRoot="false" isAbstract="false" name="sendPing" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1365" isRoot="false" isAbstract="false" name="pingTimeout" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1371" isRoot="false" isAbstract="false" name="live" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1377" isRoot="false" isAbstract="false" name="processPing" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="1383" isRoot="false" value="" type="2" isAbstract="false" name="id" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="77" isRoot="false" isAbstract="false" name="UDP_Ping" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="1318" isRoot="false" initialValue="" type="2" isAbstract="false" name="creation" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="1324" isRoot="false" initialValue="" type="2" isAbstract="false" name="id" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="1330" isRoot="false" initialValue="" type="2" isAbstract="false" name="timeout" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="1399" isRoot="false" isAbstract="false" name="getPacket" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter kind="return" xmi.id="1435" type="17" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="80" isRoot="false" isAbstract="false" name="UDP_Client" >
+     <UML:Classifier.feature>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="599" isRoot="false" isAbstract="false" name="alreadyReceived" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="600" isRoot="false" value="" type="2" isAbstract="false" name="packet_id" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="611" isRoot="false" isAbstract="false" name="receivePacket" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="612" isRoot="false" value="" type="17" isAbstract="false" name="packet" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="623" isRoot="false" isAbstract="false" name="processPing" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="624" isRoot="false" value="" type="2" isAbstract="false" name="id" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="635" isRoot="false" isAbstract="false" name="processPong" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="636" isRoot="false" value="" type="2" isAbstract="false" name="id" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="647" isRoot="false" isAbstract="false" name="processAck" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="648" isRoot="false" value="" type="2" isAbstract="false" name="id" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="659" isRoot="false" isAbstract="false" name="needAck" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="660" isRoot="false" value="" type="17" isAbstract="false" name="packet" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="676" isRoot="false" isAbstract="false" name="sendBinary" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="677" isRoot="false" value="" type="10" isAbstract="false" name="data" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="134" isRoot="false" isAbstract="false" name="IO_Client" >
+     <UML:Classifier.feature>
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="141" isRoot="false" initialValue="" type="5" isAbstract="false" name="connected" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="145" isRoot="false" initialValue="" type="11" isAbstract="false" name="io" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="147" isRoot="false" initialValue="" type="9" isAbstract="false" name="name" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="137" isRoot="false" initialValue="" type="14" isAbstract="false" name="addr" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="158" isRoot="false" initialValue="" type="10" isAbstract="false" name="host" />
+      <UML:Attribute isSpecification="false" isLeaf="false" visibility="public" xmi.id="160" isRoot="false" initialValue="" type="2" isAbstract="false" name="port" />
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="151" isRoot="false" isAbstract="false" name="send" >
+       <UML:BehavioralFeature.parameter>
+        <UML:Parameter isSpecification="false" isLeaf="false" visibility="private" xmi.id="152" isRoot="false" value="" type="17" isAbstract="false" name="packet" />
+       </UML:BehavioralFeature.parameter>
+      </UML:Operation>
+      <UML:Operation isSpecification="false" isLeaf="false" visibility="public" xmi.id="155" isRoot="false" isAbstract="false" name="disconnect" />
+     </UML:Classifier.feature>
+    </UML:Class>
+    <UML:Dependency isSpecification="false" visibility="public" xmi.id="38" client="27" name="" supplier="11" />
+    <UML:Dependency isSpecification="false" visibility="public" xmi.id="43" client="29" name="" supplier="11" />
+    <UML:Association isSpecification="false" visibility="public" xmi.id="49" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="50" aggregation="shared" type="27" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="51" aggregation="none" type="31" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Association isSpecification="false" visibility="public" xmi.id="54" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="55" aggregation="shared" type="31" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="56" aggregation="none" type="27" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Association isSpecification="false" visibility="public" xmi.id="60" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="61" aggregation="shared" type="33" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="62" aggregation="none" type="27" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Association isSpecification="false" visibility="public" xmi.id="68" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="69" aggregation="shared" type="33" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="70" aggregation="none" type="27" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Association isSpecification="false" visibility="public" xmi.id="84" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="85" aggregation="shared" type="80" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="86" aggregation="none" type="29" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Association isSpecification="false" visibility="public" xmi.id="89" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="90" aggregation="shared" type="35" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="91" aggregation="none" type="29" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Association isSpecification="false" visibility="public" xmi.id="94" name="" >
+     <UML:Association.connection>
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="95" aggregation="shared" type="77" name="" />
+      <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="96" aggregation="none" type="35" name="" />
+     </UML:Association.connection>
+    </UML:Association>
+    <UML:Dependency isSpecification="false" visibility="public" xmi.id="476" client="33" name="" supplier="134" />
+    <UML:Dependency isSpecification="false" visibility="public" xmi.id="489" client="80" name="" supplier="134" />
+    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1270" client="27" name="" supplier="11" />
+   </UML:Namespace.ownedElement>
+  </UML:Model>
+ </XMI.content>
+ <XMI.extensions xmi.extender="umbrello" >
+  <docsettings viewid="1" documentation="" uniqueid="1435" />
+  <diagrams>
+   <diagram snapgrid="0" showattsig="1" fillcolor="#ffffc0" linewidth="0" zoom="100" showgrid="0" showopsig="1" usefillcolor="1" snapx="10" canvaswidth="1195" snapy="10" showatts="1" xmi.id="1" documentation="" type="402" showops="1" showpackage="0" name="class diagram" localid="900000" showstereotype="0" showscope="1" snapcsgrid="0" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="#ff0000" canvasheight="794" >
+    <widgets>
+     <classwidget usesdiagramfillcolour="0" width="315" showattsigs="601" usesdiagramusefillcolour="0" x="562" linecolour="#ff0000" y="7" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="180" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="11" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,1,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="184" showattsigs="601" usesdiagramusefillcolour="0" x="918" linecolour="#ff0000" y="59" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="108" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="17" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="357" showattsigs="601" usesdiagramusefillcolour="0" x="201" linecolour="#ff0000" y="275" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="108" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="27" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="341" showattsigs="601" usesdiagramusefillcolour="0" x="809" linecolour="#ff0000" y="280" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="126" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="29" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="340" showattsigs="601" usesdiagramusefillcolour="0" x="0" linecolour="#ff0000" y="528" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="198" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="31" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="341" showattsigs="601" usesdiagramusefillcolour="0" x="351" linecolour="#ff0000" y="528" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="81" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="33" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="182" showattsigs="601" usesdiagramusefillcolour="0" x="1009" linecolour="#ff0000" y="528" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="117" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="35" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="180" showattsigs="601" usesdiagramusefillcolour="0" x="1011" linecolour="#ff0000" y="700" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="90" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="77" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="266" showattsigs="601" usesdiagramusefillcolour="0" x="707" linecolour="#ff0000" y="527" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="153" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="80" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="191" showattsigs="601" usesdiagramusefillcolour="0" x="582" linecolour="#ff0000" y="253" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="162" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="134" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+    </widgets>
+    <messages/>
+    <associations>
+     <assocwidget totalcounta="2" indexa="1" totalcountb="3" indexb="1" widgetbid="11" widgetaid="29" xmi.id="43" >
+      <linepath>
+       <startpoint startx="979" starty="280" />
+       <endpoint endx="667" endy="187" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="2" indexa="1" totalcountb="3" indexb="1" widgetbid="27" widgetaid="31" xmi.id="54" >
+      <linepath>
+       <startpoint startx="170" starty="528" />
+       <endpoint endx="320" endy="383" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="2" widgetbid="27" widgetaid="33" xmi.id="68" >
+      <linepath>
+       <startpoint startx="464" starty="528" />
+       <endpoint endx="439" endy="383" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="1" widgetbid="29" widgetaid="80" xmi.id="84" >
+      <linepath>
+       <startpoint startx="884" starty="527" />
+       <endpoint endx="922" endy="406" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="2" indexa="1" totalcountb="3" indexb="2" widgetbid="29" widgetaid="35" xmi.id="89" >
+      <linepath>
+       <startpoint startx="1100" starty="528" />
+       <endpoint endx="1036" endy="406" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="2" indexa="1" totalcountb="2" indexb="1" widgetbid="35" widgetaid="77" xmi.id="94" >
+      <linepath>
+       <startpoint startx="1101" starty="700" />
+       <endpoint endx="1100" endy="645" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="1" widgetbid="134" widgetaid="33" xmi.id="476" >
+      <linepath>
+       <startpoint startx="578" starty="528" />
+       <endpoint endx="645" endy="415" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="2" widgetbid="134" widgetaid="80" xmi.id="489" >
+      <linepath>
+       <startpoint startx="795" starty="527" />
+       <endpoint endx="709" endy="415" />
+      </linepath>
+     </assocwidget>
+     <assocwidget totalcounta="2" indexa="1" totalcountb="3" indexb="1" widgetbid="11" widgetaid="27" xmi.id="1270" >
+      <linepath>
+       <startpoint startx="379" starty="275" />
+       <endpoint endx="667" endy="187" />
+      </linepath>
+     </assocwidget>
+    </associations>
+   </diagram>
+  </diagrams>
+  <listview>
+   <listitem open="1" type="800" label="Views" >
+    <listitem open="1" type="801" label="Logical View" >
+     <listitem open="1" type="813" id="11" >
+      <listitem open="0" type="814" id="193" />
+      <listitem open="0" type="814" id="196" />
+      <listitem open="0" type="815" id="13" />
+      <listitem open="0" type="815" id="124" />
+      <listitem open="0" type="815" id="179" />
+      <listitem open="0" type="815" id="126" />
+      <listitem open="0" type="815" id="167" />
+      <listitem open="0" type="815" id="176" />
+      <listitem open="0" type="815" id="189" />
+     </listitem>
+     <listitem open="1" type="813" id="134" >
+      <listitem open="0" type="814" id="141" />
+      <listitem open="0" type="814" id="145" />
+      <listitem open="0" type="814" id="147" />
+      <listitem open="0" type="814" id="137" />
+      <listitem open="0" type="814" id="158" />
+      <listitem open="0" type="814" id="160" />
+      <listitem open="0" type="815" id="151" />
+      <listitem open="0" type="815" id="155" />
+     </listitem>
+     <listitem open="1" type="813" id="27" >
+      <listitem open="0" type="814" id="252" />
+      <listitem open="0" type="815" id="261" />
+      <listitem open="0" type="815" id="288" />
+      <listitem open="0" type="815" id="346" />
+      <listitem open="0" type="815" id="355" />
+     </listitem>
+     <listitem open="1" type="813" id="29" >
+      <listitem open="0" type="814" id="1063" />
+      <listitem open="0" type="814" id="1074" />
+      <listitem open="0" type="815" id="1000" />
+      <listitem open="0" type="815" id="1012" />
+      <listitem open="0" type="815" id="1030" />
+      <listitem open="0" type="815" id="1042" />
+     </listitem>
+     <listitem open="1" type="813" id="31" >
+      <listitem open="0" type="814" id="973" />
+      <listitem open="0" type="814" id="950" />
+      <listitem open="0" type="814" id="956" />
+      <listitem open="0" type="814" id="962" />
+      <listitem open="0" type="814" id="979" />
+      <listitem open="0" type="815" id="714" />
+      <listitem open="0" type="815" id="720" />
+      <listitem open="0" type="815" id="732" />
+      <listitem open="0" type="815" id="779" />
+      <listitem open="0" type="815" id="785" />
+     </listitem>
+     <listitem open="1" type="813" id="17" >
+      <listitem open="0" type="814" id="235" />
+      <listitem open="0" type="815" id="18" />
+      <listitem open="0" type="815" id="21" />
+      <listitem open="0" type="815" id="207" />
+      <listitem open="0" type="815" id="222" />
+     </listitem>
+     <listitem open="1" type="813" id="33" >
+      <listitem open="0" type="815" id="565" />
+      <listitem open="0" type="815" id="577" />
+      <listitem open="0" type="815" id="502" />
+     </listitem>
+     <listitem open="1" type="813" id="80" >
+      <listitem open="0" type="815" id="599" />
+      <listitem open="0" type="815" id="611" />
+      <listitem open="0" type="815" id="623" />
+      <listitem open="0" type="815" id="635" />
+      <listitem open="0" type="815" id="647" />
+      <listitem open="0" type="815" id="659" />
+      <listitem open="0" type="815" id="676" />
+     </listitem>
+     <listitem open="1" type="813" id="77" >
+      <listitem open="0" type="814" id="1318" />
+      <listitem open="0" type="814" id="1324" />
+      <listitem open="0" type="814" id="1330" />
+      <listitem open="0" type="815" id="1399" />
+     </listitem>
+     <listitem open="1" type="813" id="35" >
+      <listitem open="0" type="815" id="1347" />
+      <listitem open="0" type="815" id="1359" />
+      <listitem open="0" type="815" id="1365" />
+      <listitem open="0" type="815" id="1371" />
+      <listitem open="0" type="815" id="1377" />
+     </listitem>
+     <listitem open="0" type="830" label="Datatypes" >
+      <listitem open="1" type="829" id="5" />
+      <listitem open="1" type="829" id="4" />
+      <listitem open="1" type="829" id="7" />
+      <listitem open="1" type="829" id="6" />
+      <listitem open="1" type="829" id="2" />
+      <listitem open="1" type="829" id="8" />
+      <listitem open="1" type="829" id="9" />
+      <listitem open="1" type="829" id="10" />
+      <listitem open="1" type="829" id="14" />
+     </listitem>
+    </listitem>
+    <listitem open="1" type="802" label="Use Case View" />
+    <listitem open="1" type="821" label="Component View" />
+    <listitem open="1" type="827" label="Deployment View" />
+    <listitem open="1" type="836" label="Entity Relationship Model" />
+   </listitem>
+  </listview>
+  <codegeneration>
+   <codegenerator language="Cpp" >
+    <classifiercodedocument writeOutCode="true" package="" id="11" parent_class="11" fileExt=".cpp" fileName="baseio" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;baseio.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeoperation parent_id="13" tag="operation_13" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="124" tag="operation_124" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="126" tag="operation_126" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="167" tag="operation_167" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="176" tag="operation_176" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="189" tag="operation_189" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeaccessormethod accessType="0" parent_id="193" tag="hblock_tag_0" canDelete="false" classfield_id="193" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="193" tag="hblock_tag_1" canDelete="false" classfield_id="193" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="196" tag="hblock_tag_2" canDelete="false" classfield_id="196" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="196" tag="hblock_tag_3" canDelete="false" classfield_id="196" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="179" tag="operation_179" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			baseio.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:21&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="193" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="193" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="193" tag="hblock_tag_0" canDelete="false" classfield_id="193" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="193" tag="hblock_tag_1" canDelete="false" classfield_id="193" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="196" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="196" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="196" tag="hblock_tag_2" canDelete="false" classfield_id="196" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="196" tag="hblock_tag_3" canDelete="false" classfield_id="196" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1270" field_type="3145777" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="17" parent_class="17" fileExt=".cpp" fileName="packet" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;packet.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeoperation parent_id="18" tag="operation_18" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="21" tag="operation_21" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="207" tag="operation_207" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="222" tag="operation_222" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeaccessormethod accessType="0" parent_id="235" tag="hblock_tag_0" canDelete="false" classfield_id="235" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="235" tag="hblock_tag_1" canDelete="false" classfield_id="235" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			packet.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:41&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="235" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="235" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="235" tag="hblock_tag_0" canDelete="false" classfield_id="235" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="235" tag="hblock_tag_1" canDelete="false" classfield_id="235" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="27" parent_class="27" fileExt=".cpp" fileName="io_tcp" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;io_tcp.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_10" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_11" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_12" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_13" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_14" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_15" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_16" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_17" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_18" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_19" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="252" tag="hblock_tag_20" canDelete="false" classfield_id="252" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="252" tag="hblock_tag_21" canDelete="false" classfield_id="252" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="261" tag="operation_261" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="288" tag="operation_288" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="346" tag="operation_346" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="355" tag="operation_355" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			io_tcp.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:16&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="49" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="49" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="54" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="54" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="60" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="60" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_10" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_11" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_12" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_13" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_14" canDelete="false" writeOutText="false" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="68" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="68" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_15" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_16" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_17" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_18" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_19" canDelete="false" writeOutText="false" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="252" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="252" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="252" tag="hblock_tag_20" canDelete="false" classfield_id="252" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="252" tag="hblock_tag_21" canDelete="false" classfield_id="252" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1270" field_type="6226000" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="1270" tag="" canDelete="false" writeOutText="false" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="29" parent_class="29" fileExt=".cpp" fileName="io_udp" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;io_udp.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="1000" tag="operation_1000" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1012" tag="operation_1012" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1030" tag="operation_1030" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1042" tag="operation_1042" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeaccessormethod accessType="0" parent_id="1063" tag="hblock_tag_10" canDelete="false" classfield_id="1063" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="1063" tag="hblock_tag_11" canDelete="false" classfield_id="1063" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="1074" tag="hblock_tag_12" canDelete="false" classfield_id="1074" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="1074" tag="hblock_tag_13" canDelete="false" classfield_id="1074" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			io_udp.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:19&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="84" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="84" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="89" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="89" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1063" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1063" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1063" tag="hblock_tag_10" canDelete="false" classfield_id="1063" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1063" tag="hblock_tag_11" canDelete="false" classfield_id="1063" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1074" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1074" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1074" tag="hblock_tag_12" canDelete="false" classfield_id="1074" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1074" tag="hblock_tag_13" canDelete="false" classfield_id="1074" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="31" parent_class="31" fileExt=".cpp" fileName="networkserverwaiter" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;networkserverwaiter.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="714" tag="operation_714" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="720" tag="operation_720" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="732" tag="operation_732" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="779" tag="operation_779" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="785" tag="operation_785" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeaccessormethod accessType="0" parent_id="950" tag="hblock_tag_10" canDelete="false" classfield_id="950" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="950" tag="hblock_tag_11" canDelete="false" classfield_id="950" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="956" tag="hblock_tag_12" canDelete="false" classfield_id="956" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="956" tag="hblock_tag_13" canDelete="false" classfield_id="956" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="962" tag="hblock_tag_14" canDelete="false" classfield_id="962" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="962" tag="hblock_tag_15" canDelete="false" classfield_id="962" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="973" tag="hblock_tag_22" canDelete="false" classfield_id="973" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="973" tag="hblock_tag_23" canDelete="false" classfield_id="973" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="979" tag="hblock_tag_24" canDelete="false" classfield_id="979" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="979" tag="hblock_tag_25" canDelete="false" classfield_id="979" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			networkserverwaiter.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If!
  you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:44:10&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="49" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="49" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="54" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="54" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="950" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="950" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="950" tag="hblock_tag_10" canDelete="false" classfield_id="950" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="950" tag="hblock_tag_11" canDelete="false" classfield_id="950" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="956" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="956" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="956" tag="hblock_tag_12" canDelete="false" classfield_id="956" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="956" tag="hblock_tag_13" canDelete="false" classfield_id="956" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="962" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="962" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="962" tag="hblock_tag_14" canDelete="false" classfield_id="962" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="962" tag="hblock_tag_15" canDelete="false" classfield_id="962" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="973" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="973" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="973" tag="hblock_tag_22" canDelete="false" classfield_id="973" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="973" tag="hblock_tag_23" canDelete="false" classfield_id="973" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="979" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="979" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="979" tag="hblock_tag_24" canDelete="false" classfield_id="979" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="979" tag="hblock_tag_25" canDelete="false" classfield_id="979" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="33" parent_class="33" fileExt=".cpp" fileName="tcp_client" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;tcp_client.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="565" tag="operation_565" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="577" tag="operation_577" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="502" tag="operation_502" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			tcp_client.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name!
  the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:44:32&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="60" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="60" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="68" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="68" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="476" field_type="655370" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="35" parent_class="35" fileExt=".cpp" fileName="udp_pinger" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;udp_pinger.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="1347" tag="operation_1347" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1359" tag="operation_1359" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1365" tag="operation_1365" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1371" tag="operation_1371" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="1377" tag="operation_1377" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			udp_pinger.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name!
  the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:47:52&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="89" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="89" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="94" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="94" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_5" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_6" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_7" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_8" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_9" canDelete="false" writeOutText="false" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="77" parent_class="77" fileExt=".cpp" fileName="udp_ping" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;udp_ping.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="1318" tag="hblock_tag_5" canDelete="false" classfield_id="1318" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="1318" tag="hblock_tag_6" canDelete="false" classfield_id="1318" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="1324" tag="hblock_tag_7" canDelete="false" classfield_id="1324" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="1324" tag="hblock_tag_8" canDelete="false" classfield_id="1324" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="1330" tag="hblock_tag_9" canDelete="false" classfield_id="1330" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="1330" tag="hblock_tag_10" canDelete="false" classfield_id="1330" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="1399" tag="operation_1399" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			udp_ping.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name t!
 he file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:48:09&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="94" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="94" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1318" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1318" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1318" tag="hblock_tag_5" canDelete="false" classfield_id="1318" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1318" tag="hblock_tag_6" canDelete="false" classfield_id="1318" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1324" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1324" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1324" tag="hblock_tag_7" canDelete="false" classfield_id="1324" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1324" tag="hblock_tag_8" canDelete="false" classfield_id="1324" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1330" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1330" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1330" tag="hblock_tag_9" canDelete="false" classfield_id="1330" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1330" tag="hblock_tag_10" canDelete="false" classfield_id="1330" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="80" parent_class="80" fileExt=".cpp" fileName="udp_client" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;udp_client.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="599" tag="operation_599" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="611" tag="operation_611" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="623" tag="operation_623" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="635" tag="operation_635" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="647" tag="operation_647" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="659" tag="operation_659" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="676" tag="operation_676" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			udp_client.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name!
  the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:44:34&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="84" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="84" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_1" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="489" field_type="6815860" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <codedocument writeOutCode="false" package="" id="Makefile_DOC" fileExt="" fileName="Makefile" >
+     <textblocks/>
+     <header>
+      <codecomment tag="" />
+     </header>
+    </codedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="134" parent_class="134" fileExt=".cpp" fileName="io_client" >
+     <textblocks>
+      <codeblockwithcomments tag="includes" text="#include &quot;io_client.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Constructors/Destructors" />
+       </header>
+       <textblocks/>
+      </hierarchicalcodeblock>
+      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" text="Methods" />
+       </header>
+       <textblocks>
+        <codeaccessormethod accessType="0" parent_id="141" tag="hblock_tag_2" canDelete="false" classfield_id="141" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="141" tag="hblock_tag_3" canDelete="false" classfield_id="141" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="145" tag="hblock_tag_4" canDelete="false" classfield_id="145" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="145" tag="hblock_tag_5" canDelete="false" classfield_id="145" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="147" tag="hblock_tag_6" canDelete="false" classfield_id="147" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="147" tag="hblock_tag_7" canDelete="false" classfield_id="147" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeoperation parent_id="151" tag="operation_151" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeoperation parent_id="155" tag="operation_155" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeoperation>
+        <codeaccessormethod accessType="0" parent_id="158" tag="hblock_tag_8" canDelete="false" classfield_id="158" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="158" tag="hblock_tag_9" canDelete="false" classfield_id="158" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="160" tag="hblock_tag_10" canDelete="false" classfield_id="160" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="160" tag="hblock_tag_11" canDelete="false" classfield_id="160" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="0" parent_id="137" tag="hblock_tag_0" canDelete="false" classfield_id="137" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+        <codeaccessormethod accessType="1" parent_id="137" tag="hblock_tag_14" canDelete="false" classfield_id="137" >
+         <header>
+          <cppcodedocumentation tag="" />
+         </header>
+        </codeaccessormethod>
+       </textblocks>
+      </hierarchicalcodeblock>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			io_client.cpp - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name !
 the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:10&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="141" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="141" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="141" tag="hblock_tag_2" canDelete="false" classfield_id="141" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="141" tag="hblock_tag_3" canDelete="false" classfield_id="141" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="145" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="145" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="145" tag="hblock_tag_4" canDelete="false" classfield_id="145" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="145" tag="hblock_tag_5" canDelete="false" classfield_id="145" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="147" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="147" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="147" tag="hblock_tag_6" canDelete="false" classfield_id="147" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="147" tag="hblock_tag_7" canDelete="false" classfield_id="147" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="158" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="158" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="158" tag="hblock_tag_8" canDelete="false" classfield_id="158" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="158" tag="hblock_tag_9" canDelete="false" classfield_id="158" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="160" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="160" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="160" tag="hblock_tag_10" canDelete="false" classfield_id="160" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="160" tag="hblock_tag_11" canDelete="false" classfield_id="160" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="137" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="137" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="137" tag="hblock_tag_0" canDelete="false" classfield_id="137" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="137" tag="hblock_tag_14" canDelete="false" classfield_id="137" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="476" field_type="6357110" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="476" tag="" canDelete="false" writeOutText="false" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="489" field_type="655370" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text="FIX ME;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="489" tag="" canDelete="false" writeOutText="false" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader11" parent_class="11" fileExt=".h" fileName="baseio" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef BASEIO_H&amp;#010;#define BASEIO_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;io_client.h&quot;&amp;#010;#include &quot;packet.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="11" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="******************************* Abstract Class ****************************&amp;#010;BaseIO does not have any pure virtual methods, but its author&amp;#010;  defined it as an abstract class, so you should not use it directly.&amp;#010;  Inherit from it instead and create only objects from the derived classes&amp;#010;*****************************************************************************" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="196" tag="tblock_2" canDelete="false" indentLevel="1" text=" bool is_ready;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="193" tag="tblock_0" canDelete="false" indentLevel="1" text=" string name;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="BaseIO ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="196" tag="hblock_tag_3" canDelete="false" indentLevel="1" classfield_id="196" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="196" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="196" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="193" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="193" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="193" tag="hblock_tag_1" canDelete="false" indentLevel="1" classfield_id="193" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="13" tag="operation_13" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param host &amp;#010;@param port " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="124" tag="operation_124" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="126" tag="operation_126" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param packet &amp;#010;@param to " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="167" tag="operation_167" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param max_size " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="176" tag="operation_176" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="189" tag="operation_189" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="179" tag="operation_179" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //BASEIO_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			baseio.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the fil!
 e &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:21&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="193" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="193" tag="tblock_0" canDelete="false" indentLevel="1" text=" string name;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="193" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="193" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="193" tag="hblock_tag_1" canDelete="false" indentLevel="1" classfield_id="193" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="196" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="196" tag="tblock_2" canDelete="false" indentLevel="1" text=" bool is_ready;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="196" tag="hblock_tag_3" canDelete="false" indentLevel="1" classfield_id="196" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="196" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="196" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1270" field_type="7602277" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" IO_TCP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader17" parent_class="17" fileExt=".h" fileName="packet" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef PACKET_H&amp;#010;#define PACKET_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="17" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class Packet&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="235" tag="tblock_0" canDelete="false" indentLevel="1" text=" string data;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="Packet ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="235" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="235" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="235" tag="hblock_tag_1" canDelete="false" indentLevel="1" classfield_id="235" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="18" tag="operation_18" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="21" tag="operation_21" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param data " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="207" tag="operation_207" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="222" tag="operation_222" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //PACKET_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			packet.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the fil!
 e &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:41&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="235" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="235" tag="tblock_0" canDelete="false" indentLevel="1" text=" string data;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="235" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="235" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="235" tag="hblock_tag_1" canDelete="false" indentLevel="1" classfield_id="235" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader27" parent_class="27" fileExt=".h" fileName="io_tcp" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef IO_TCP_H&amp;#010;#define IO_TCP_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;udp_client.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="27" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class IO_TCP&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="49" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" NetworkServerWaiter ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="54" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" NetworkServerWaiter ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="60" tag="tblock_2" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" TCP_Client ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="68" tag="tblock_3" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" TCP_Client ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="252" tag="tblock_23" canDelete="false" indentLevel="1" text=" void clients;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="IO_TCP ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_11" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_12" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_13" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_14" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_15" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_16" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_17" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_18" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_19" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_20" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_21" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_22" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="252" tag="hblock_tag_24" canDelete="false" indentLevel="1" classfield_id="252" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="252" tag="hblock_tag_25" canDelete="false" indentLevel="1" classfield_id="252" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="261" tag="operation_261" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param data &amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="288" tag="operation_288" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="346" tag="operation_346" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="355" tag="operation_355" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //IO_TCP_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			io_tcp.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the fil!
 e &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:16&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="49" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="49" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" NetworkServerWaiter ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="54" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="54" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" NetworkServerWaiter ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_11" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_12" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="60" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="60" tag="tblock_2" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" TCP_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_13" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_14" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_15" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_16" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_17" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="68" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="68" tag="tblock_3" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" TCP_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_18" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_19" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_20" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_21" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_22" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="252" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="252" tag="tblock_23" canDelete="false" indentLevel="1" text=" void clients;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="252" tag="hblock_tag_24" canDelete="false" indentLevel="1" classfield_id="252" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="252" tag="hblock_tag_25" canDelete="false" indentLevel="1" classfield_id="252" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1270" field_type="7274601" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" BaseIO ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="1270" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="1270" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader29" parent_class="29" fileExt=".h" fileName="io_udp" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef IO_UDP_H&amp;#010;#define IO_UDP_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;baseio.h&quot;&amp;#010;#include &quot;io_client.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="29" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class IO_UDP&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="84" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Client ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="89" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Pinger ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="1063" tag="tblock_11" canDelete="false" indentLevel="1" text=" void clients;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="1074" tag="tblock_14" canDelete="false" indentLevel="1" text=" int max_clients;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="IO_UDP ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="1063" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="1063" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="1063" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="1063" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="1074" tag="hblock_tag_15" canDelete="false" indentLevel="1" classfield_id="1074" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="1074" tag="hblock_tag_16" canDelete="false" indentLevel="1" classfield_id="1074" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="1000" tag="operation_1000" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1012" tag="operation_1012" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param data &amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1030" tag="operation_1030" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1042" tag="operation_1042" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //IO_UDP_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			io_udp.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the fil!
 e &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:19&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="84" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="84" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="89" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="89" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Pinger ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1063" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1063" tag="tblock_11" canDelete="false" indentLevel="1" text=" void clients;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1063" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="1063" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1063" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="1063" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1074" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1074" tag="tblock_14" canDelete="false" indentLevel="1" text=" int max_clients;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1074" tag="hblock_tag_15" canDelete="false" indentLevel="1" classfield_id="1074" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1074" tag="hblock_tag_16" canDelete="false" indentLevel="1" classfield_id="1074" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader31" parent_class="31" fileExt=".h" fileName="networkserverwaiter" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef NETWORKSERVERWAITER_H&amp;#010;#define NETWORKSERVERWAITER_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;io_client.h&quot;&amp;#010;#include &quot;packet.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="31" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class NetworkServerWaiter&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="49" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" IO_TCP ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="54" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_TCP ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="950" tag="tblock_11" canDelete="false" indentLevel="1" text=" int max_clients;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="962" tag="tblock_17" canDelete="false" indentLevel="1" text=" int port;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="956" tag="tblock_14" canDelete="false" indentLevel="1" text=" string host;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="973" tag="tblock_29" canDelete="false" indentLevel="1" text=" int nb_clients;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="979" tag="tblock_32" canDelete="false" indentLevel="1" text=" bool listening;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="NetworkServerWaiter ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="950" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="950" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="950" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="950" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="962" tag="hblock_tag_18" canDelete="false" indentLevel="1" classfield_id="962" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="962" tag="hblock_tag_19" canDelete="false" indentLevel="1" classfield_id="962" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="956" tag="hblock_tag_15" canDelete="false" indentLevel="1" classfield_id="956" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="956" tag="hblock_tag_16" canDelete="false" indentLevel="1" classfield_id="956" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="973" tag="hblock_tag_30" canDelete="false" indentLevel="1" classfield_id="973" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="973" tag="hblock_tag_31" canDelete="false" indentLevel="1" classfield_id="973" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="979" tag="hblock_tag_33" canDelete="false" indentLevel="1" classfield_id="979" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="979" tag="hblock_tag_34" canDelete="false" indentLevel="1" classfield_id="979" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="714" tag="operation_714" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param port &amp;#010;@param max_connection " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="720" tag="operation_720" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="732" tag="operation_732" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param client " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="779" tag="operation_779" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="785" tag="operation_785" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param port &amp;#010;@param max_connection " />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //NETWORKSERVERWAITER_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			networkserverwaiter.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you!
  name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:44:10&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="49" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="49" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" IO_TCP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="49" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="49" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="49" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="49" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="49" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="49" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="54" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="54" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_TCP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="54" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="54" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="54" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="54" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="54" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="54" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="950" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="950" tag="tblock_11" canDelete="false" indentLevel="1" text=" int max_clients;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="950" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="950" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="950" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="950" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="956" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="956" tag="tblock_14" canDelete="false" indentLevel="1" text=" string host;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="956" tag="hblock_tag_15" canDelete="false" indentLevel="1" classfield_id="956" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="956" tag="hblock_tag_16" canDelete="false" indentLevel="1" classfield_id="956" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="962" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="962" tag="tblock_17" canDelete="false" indentLevel="1" text=" int port;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="962" tag="hblock_tag_18" canDelete="false" indentLevel="1" classfield_id="962" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="962" tag="hblock_tag_19" canDelete="false" indentLevel="1" classfield_id="962" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="973" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="973" tag="tblock_29" canDelete="false" indentLevel="1" text=" int nb_clients;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="973" tag="hblock_tag_30" canDelete="false" indentLevel="1" classfield_id="973" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="973" tag="hblock_tag_31" canDelete="false" indentLevel="1" classfield_id="973" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="979" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="979" tag="tblock_32" canDelete="false" indentLevel="1" text=" bool listening;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="979" tag="hblock_tag_33" canDelete="false" indentLevel="1" classfield_id="979" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="979" tag="hblock_tag_34" canDelete="false" indentLevel="1" classfield_id="979" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader33" parent_class="33" fileExt=".h" fileName="tcp_client" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef TCP_CLIENT_H&amp;#010;#define TCP_CLIENT_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;io_client.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="33" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class TCP_Client&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="60" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_TCP ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="68" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_TCP ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="TCP_Client ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="565" tag="operation_565" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param max_size " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="577" tag="operation_577" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param max_size " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="502" tag="operation_502" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param data &amp;#010;@param to " />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //TCP_CLIENT_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			tcp_client.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:44:32&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="60" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="60" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_TCP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="60" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="60" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="60" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="60" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="60" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="60" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="68" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="68" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_TCP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="68" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="68" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="68" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="68" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="68" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="68" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="476" field_type="7602286" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader35" parent_class="35" fileExt=".h" fileName="udp_pinger" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef UDP_PINGER_H&amp;#010;#define UDP_PINGER_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="35" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class UDP_Pinger&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="89" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_UDP ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="94" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Ping ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="UDP_Pinger ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="1347" tag="operation_1347" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param id " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1359" tag="operation_1359" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1365" tag="operation_1365" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1371" tag="operation_1371" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="1377" tag="operation_1377" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param id " />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //UDP_PINGER_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			udp_pinger.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:47:52&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="89" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="89" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_UDP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="89" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="89" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="89" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="89" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="89" tag="hblock_tag_5" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="89" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="94" field_type="3" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="94" tag="tblock_1" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Ping ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_6" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_7" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_8" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_9" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_10" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader77" parent_class="77" fileExt=".h" fileName="udp_ping" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef UDP_PING_H&amp;#010;#define UDP_PING_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;packet.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="77" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class UDP_Ping&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="94" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" UDP_Pinger ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="1318" tag="tblock_5" canDelete="false" indentLevel="1" text=" int creation;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="1324" tag="tblock_8" canDelete="false" indentLevel="1" text=" int id;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="1330" tag="tblock_11" canDelete="false" indentLevel="1" text=" int timeout;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="UDP_Ping ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_1" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="1318" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="1318" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="1318" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="1318" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="1324" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="1324" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="1324" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="1324" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="1330" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="1330" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="1330" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="1330" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="1399" tag="operation_1399" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //UDP_PING_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			udp_ping.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the f!
 ile &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:48:09&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="94" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="94" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" UDP_Pinger ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="94" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="94" tag="hblock_tag_1" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="94" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="94" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="94" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="94" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1318" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1318" tag="tblock_5" canDelete="false" indentLevel="1" text=" int creation;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1318" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="1318" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1318" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="1318" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1324" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1324" tag="tblock_8" canDelete="false" indentLevel="1" text=" int id;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1324" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="1324" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1324" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="1324" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="1330" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="1330" tag="tblock_11" canDelete="false" indentLevel="1" text=" int timeout;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="1330" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="1330" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="1330" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="1330" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader80" parent_class="80" fileExt=".h" fileName="udp_client" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef UDP_CLIENT_H&amp;#010;#define UDP_CLIENT_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;packet.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="80" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class UDP_Client&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="84" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_UDP ;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="UDP_Client ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_1" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="599" tag="operation_599" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param packet_id " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="611" tag="operation_611" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param packet " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="623" tag="operation_623" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param id " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="635" tag="operation_635" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param id " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="647" tag="operation_647" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param id " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="659" tag="operation_659" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param packet " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="676" tag="operation_676" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param data " />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //UDP_CLIENT_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			udp_client.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the!
  file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:44:34&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="84" field_type="3" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="84" tag="tblock_0" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_UDP ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="84" tag="hblock_tag_0" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="84" tag="hblock_tag_1" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="84" tag="hblock_tag_2" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="84" tag="hblock_tag_3" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="84" tag="hblock_tag_4" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="84" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="489" field_type="30" initialValue="" role_id="1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="0" text=" IO_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="0" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+    <classifiercodedocument writeOutCode="true" package="" id="cppheader134" parent_class="134" fileExt=".h" fileName="io_client" >
+     <textblocks>
+      <codeblockwithcomments tag="hashDefBlock" text="#ifndef IO_CLIENT_H&amp;#010;#define IO_CLIENT_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;packet.h&quot;&amp;#010;#include &quot;baseio.h&quot;&amp;#010;" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <codeblockwithcomments tag="using" writeOutText="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+      <hierarchicalcodeblock tag="namespace" canDelete="false" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
+       </header>
+       <textblocks>
+        <codeblockwithcomments tag="enums" writeOutText="false" >
+         <header>
+          <cppcodedocumentation tag="" writeOutText="false" />
+         </header>
+        </codeblockwithcomments>
+        <cppheaderclassdeclarationblock parent_id="134" tag="classDeclarationBlock" canDelete="false" >
+         <header>
+          <cppcodedocumentation tag="" text="Class IO_Client&amp;#010;" />
+         </header>
+         <textblocks>
+          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Public stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks>
+              <ccfdeclarationcodeblock parent_id="141" tag="tblock_2" canDelete="false" indentLevel="1" text=" bool connected;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="145" tag="tblock_5" canDelete="false" indentLevel="1" text=" BaseIO io;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="147" tag="tblock_8" canDelete="false" indentLevel="1" text=" short name;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="158" tag="tblock_11" canDelete="false" indentLevel="1" text=" string host;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="160" tag="tblock_14" canDelete="false" indentLevel="1" text=" int port;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+              <ccfdeclarationcodeblock parent_id="137" tag="tblock_0" canDelete="false" indentLevel="1" text=" void addr;" >
+               <header>
+                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+               </header>
+              </ccfdeclarationcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks>
+                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="IO_Client ( ) { }" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
+                 </header>
+                </codeblockwithcomments>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks>
+                  <codeaccessormethod accessType="0" parent_id="141" tag="hblock_tag_3" canDelete="false" indentLevel="1" classfield_id="141" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="141" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="141" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="145" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="145" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="145" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="145" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="147" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="147" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="147" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="147" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="158" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="158" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="158" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="158" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="160" tag="hblock_tag_15" canDelete="false" indentLevel="1" classfield_id="160" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="160" tag="hblock_tag_16" canDelete="false" indentLevel="1" classfield_id="160" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="0" parent_id="137" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="137" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                  <codeaccessormethod accessType="1" parent_id="137" tag="hblock_tag_19" canDelete="false" indentLevel="1" classfield_id="137" >
+                   <header>
+                    <cppcodedocumentation tag="" indentLevel="1" />
+                   </header>
+                  </codeaccessormethod>
+                 </textblocks>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks>
+                <codeoperation parent_id="151" tag="operation_151" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" text="&amp;#010;@param packet " />
+                 </header>
+                </codeoperation>
+                <codeoperation parent_id="155" tag="operation_155" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" indentLevel="1" />
+                 </header>
+                </codeoperation>
+               </textblocks>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Protected stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
+           <header>
+            <cppcodedocumentation tag="" text="Private stuff" />
+           </header>
+           <textblocks>
+            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
+             </header>
+             <textblocks/>
+            </hierarchicalcodeblock>
+            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
+             <header>
+              <cppcodedocumentation tag="" indentLevel="1" />
+             </header>
+             <textblocks>
+              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
+               </header>
+               <textblocks>
+                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
+                 <header>
+                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+                 </header>
+                 <textblocks/>
+                </hierarchicalcodeblock>
+               </textblocks>
+              </hierarchicalcodeblock>
+              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
+               <header>
+                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
+               </header>
+               <textblocks/>
+              </hierarchicalcodeblock>
+             </textblocks>
+            </hierarchicalcodeblock>
+           </textblocks>
+          </hierarchicalcodeblock>
+         </textblocks>
+        </cppheaderclassdeclarationblock>
+       </textblocks>
+      </hierarchicalcodeblock>
+      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //IO_CLIENT_H" >
+       <header>
+        <cppcodedocumentation tag="" writeOutText="false" />
+       </header>
+      </codeblockwithcomments>
+     </textblocks>
+     <header>
+      <codecomment tag="" text="/************************************************************************&amp;#010;  			io_client.h - Copyright haypo&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the !
 file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on mar sep 20 2005 at 00:45:10&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
+     </header>
+     <classfields>
+      <codeclassfield parent_id="141" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="141" tag="tblock_2" canDelete="false" indentLevel="1" text=" bool connected;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="141" tag="hblock_tag_3" canDelete="false" indentLevel="1" classfield_id="141" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="141" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="141" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="145" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="145" tag="tblock_5" canDelete="false" indentLevel="1" text=" BaseIO io;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="145" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="145" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="145" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="145" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="147" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="147" tag="tblock_8" canDelete="false" indentLevel="1" text=" short name;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="147" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="147" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="147" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="147" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="158" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="158" tag="tblock_11" canDelete="false" indentLevel="1" text=" string host;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="158" tag="hblock_tag_12" canDelete="false" indentLevel="1" classfield_id="158" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="158" tag="hblock_tag_13" canDelete="false" indentLevel="1" classfield_id="158" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="160" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="160" tag="tblock_14" canDelete="false" indentLevel="1" text=" int port;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="160" tag="hblock_tag_15" canDelete="false" indentLevel="1" classfield_id="160" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="160" tag="hblock_tag_16" canDelete="false" indentLevel="1" classfield_id="160" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="137" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="137" tag="tblock_0" canDelete="false" indentLevel="1" text=" void addr;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="137" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="137" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="137" tag="hblock_tag_19" canDelete="false" indentLevel="1" classfield_id="137" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="476" field_type="6815860" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" TCP_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="476" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="476" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+      <codeclassfield parent_id="489" field_type="6488161" initialValue="" role_id="0" writeOutMethods="true" listClassName="" >
+       <header>
+        <cppcodedocumentation tag="" />
+       </header>
+       <ccfdeclarationcodeblock parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" role_id="1" text=" UDP_Client ;" >
+        <header>
+         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
+        </header>
+       </ccfdeclarationcodeblock>
+       <codeaccessormethod accessType="0" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="1" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="2" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="3" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+       <codeaccessormethod accessType="4" parent_id="489" tag="" canDelete="false" writeOutText="false" indentLevel="1" classfield_id="489" role_id="1" >
+        <header>
+         <cppcodedocumentation tag="" indentLevel="1" />
+        </header>
+       </codeaccessormethod>
+      </codeclassfield>
+     </classfields>
+    </classifiercodedocument>
+   </codegenerator>
+  </codegeneration>
+ </XMI.extensions>
+</XMI>



From haypo at berlios.de  Wed Sep 28 01:55:34 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 28 Sep 2005 01:55:34 +0200
Subject: [Happyboom-svn] r217 - greycstoration_gimp
Message-ID: <200509272355.j8RNtYA6019134@sheep.berlios.de>

Author: haypo
Date: 2005-09-28 01:55:30 +0200 (Wed, 28 Sep 2005)
New Revision: 217

Modified:
   greycstoration_gimp/main.cpp
Log:
Add Pedro C?\195?\180rte-Real patch (pedrocr AT gmail.com): uses nice(19).


Modified: greycstoration_gimp/main.cpp
===================================================================
--- greycstoration_gimp/main.cpp	2005-09-21 11:37:07 UTC (rev 216)
+++ greycstoration_gimp/main.cpp	2005-09-27 23:55:30 UTC (rev 217)
@@ -21,6 +21,8 @@
 #include "plug_in.h"
 #include "dialog.h"
 #include "greycstoration.h"
+#include <unistd.h>
+
 //----------------------------------------------------------------------------
 GREYCstoration greyc;
 GREYCstoration_params greyc_params;
@@ -93,6 +95,10 @@
 	static GimpParam values[1];
 	GimpPDBStatusType status = GIMP_PDB_SUCCESS;
 
+	/* Reduce the processes importance so that it doesn't make the computer 
+	   non-interactive */
+	nice(19);
+
 	/* Mise en place d'une valeur obligatoire de retour */
 	*nreturn_vals = 1;
 	*return_vals = values;



From haypo at berlios.de  Wed Sep 28 02:10:13 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 28 Sep 2005 02:10:13 +0200
Subject: [Happyboom-svn] r218 - greycstoration_gimp
Message-ID: <200509280010.j8S0ADHN025883@sheep.berlios.de>

Author: haypo
Date: 2005-09-28 02:10:04 +0200 (Wed, 28 Sep 2005)
New Revision: 218

Added:
   greycstoration_gimp/AUTHORS
   greycstoration_gimp/INSTALL
   greycstoration_gimp/README
Modified:
   greycstoration_gimp/ChangeLog
Log:
Create AUTHORS, INSTALL, README and update ChangeLog.


Added: greycstoration_gimp/AUTHORS
===================================================================
--- greycstoration_gimp/AUTHORS	2005-09-27 23:55:30 UTC (rev 217)
+++ greycstoration_gimp/AUTHORS	2005-09-28 00:10:04 UTC (rev 218)
@@ -0,0 +1,10 @@
+David Tschumperl? <David.Tschumperle AT greyc.ensicaen.fr>
+    o Author of the GREYCstoration algorithm
+David Rodr?guez Garc?a <david AT livux.com>
+    o Patch to limit progress bar updates
+Michael Schumacher <schumaml AT gmx.de>
+    o Prepared Win32 binaries
+Pedro C?rte-Real <pedrocr AT gmail.com>
+    o nice(19) patch to limit CPU use
+Victor Stinner aka haypo <vitor.stinner AT haypocalc.com>
+    o First author of the patch

Modified: greycstoration_gimp/ChangeLog
===================================================================
--- greycstoration_gimp/ChangeLog	2005-09-27 23:55:30 UTC (rev 217)
+++ greycstoration_gimp/ChangeLog	2005-09-28 00:10:04 UTC (rev 218)
@@ -1,9 +1,17 @@
-2005-03-18  Victor STINNER  <victor.stinner at haypocalc.com>
+2005-09-28 Victor Stinner
 
+        * Apply Pedro C?rte-Real patch (nice).
+
+2005-09-07 Victor Stinner
+
+        * Apply David Rodr?guez Garc?a patch (progress bar).
+
+2005-03-18  Victor Stinner
+
         * Version 0.1.2
         * Use table and notebook for dialog
 
-2005-03-12  Victor STINNER  <victor.stinner at haypocalc.com>
+2005-03-12  Victor Stinner
 
         * Version 0.1.1
         * Dialog reorganized with better parameters names.
@@ -12,7 +20,7 @@
           pthread dependencies (or Win32 dependencies)
         * Change default values (p1=0.1 and sigma=1.4)
 
-2005-03-11  Victor STINNER  <victor.stinner at haypocalc.com>
+2005-03-11  Victor Stinner
 
         * Version 0.1, first public release.
         * Support image restoration.

Added: greycstoration_gimp/INSTALL
===================================================================
--- greycstoration_gimp/INSTALL	2005-09-27 23:55:30 UTC (rev 217)
+++ greycstoration_gimp/INSTALL	2005-09-28 00:10:04 UTC (rev 218)
@@ -0,0 +1,19 @@
+The install the Gimp plugin GREYCstoration, you have to compile it first.
+For this, you will need:
+
+- Gimp 2.2.x (or greater) and headers of the Gimp library
+  http://www.gimp.org/
+- Compiler GNU g++
+  http://gcc.gnu.org/
+- GTK 2.x (version 2.6 or greater?) and development headers of GTK+
+  http://www.gtk.org/
+
+Instruction to compile
+======================
+
+make && make install
+
+That's all :-)
+
+The plugin is only tested on Linux, but Michael Schumacher
+prepared Win32 binaries.

Added: greycstoration_gimp/README
===================================================================
--- greycstoration_gimp/README	2005-09-27 23:55:30 UTC (rev 217)
+++ greycstoration_gimp/README	2005-09-28 00:10:04 UTC (rev 218)
@@ -0,0 +1,21 @@
+Introduction
+============
+
+GREYCstoration is a Gimp plugin using the algorithm written by David
+Tschumperl? from GREYC laboratory (at Caen in France). The version 0.1.x of
+the plugin only supports the restoration functionnality, but the algorithm
+can also do great picture resize or good inpainting.
+
+Install the plugin
+==================
+
+See INSTALL file.
+
+Web links
+=========
+
+More informations about the algorithm:
+  http://www.greyc.ensicaen.fr/~dtschump/greycstoration/
+  
+Plugin website:
+  http://www.haypocalc.com/wiki/GREYCstoration_in_english



From haypo at berlios.de  Wed Sep 28 02:13:39 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 28 Sep 2005 02:13:39 +0200
Subject: [Happyboom-svn] r219 - greycstoration_gimp
Message-ID: <200509280013.j8S0DdPI027488@sheep.berlios.de>

Author: haypo
Date: 2005-09-28 02:13:32 +0200 (Wed, 28 Sep 2005)
New Revision: 219

Modified:
   greycstoration_gimp/greycstoration.cpp
Log:
Oups, corrige un bug a la con.


Modified: greycstoration_gimp/greycstoration.cpp
===================================================================
--- greycstoration_gimp/greycstoration.cpp	2005-09-28 00:10:04 UTC (rev 218)
+++ greycstoration_gimp/greycstoration.cpp	2005-09-28 00:13:32 UTC (rev 219)
@@ -312,7 +312,7 @@
 			u = flow(x,y,0),
 			  v = flow(x,y,1),
 			  n = (float)std::pow(u*u+v*v,0.25f),
-			  nn = n<1e-5?1:nn;
+			  nn = n<1e-5?1:n;
 		G(x,y,0) = u*u/nn;
 		G(x,y,1) = u*v/nn;
 		G(x,y,2) = v*v/nn;



From haypo at berlios.de  Wed Sep 28 02:18:41 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 28 Sep 2005 02:18:41 +0200
Subject: [Happyboom-svn] r220 - greycstoration_gimp
Message-ID: <200509280018.j8S0IfBl030787@sheep.berlios.de>

Author: haypo
Date: 2005-09-28 02:18:34 +0200 (Wed, 28 Sep 2005)
New Revision: 220

Added:
   greycstoration_gimp/COPYING
Log:
Add license file (GNU GPL v2)


Added: greycstoration_gimp/COPYING
===================================================================
--- greycstoration_gimp/COPYING	2005-09-28 00:13:32 UTC (rev 219)
+++ greycstoration_gimp/COPYING	2005-09-28 00:18:34 UTC (rev 220)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.



