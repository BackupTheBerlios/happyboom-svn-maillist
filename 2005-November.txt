From haypo at berlios.de  Tue Nov  1 04:19:46 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 1 Nov 2005 04:19:46 +0100
Subject: [Happyboom-svn] r242 - in haypo/hachoir: . plugins
Message-ID: <200511010319.jA13Jk98031069@sheep.berlios.de>

Author: haypo
Date: 2005-11-01 04:19:43 +0100 (Tue, 01 Nov 2005)
New Revision: 242

Added:
   haypo/hachoir/id3.xml
   haypo/hachoir/id3_chunk.xml
   haypo/hachoir/log.py
   haypo/hachoir/tools.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/exe.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/ncftp.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/ui.py
   haypo/hachoir/ui_popup.py
   haypo/hachoir/ui_property.py
   haypo/hachoir/ui_window.py
   haypo/hachoir/user_filter.py
Log:
It's now possible to create a subfilter and to delete chunk.
Fix size change in a sub-filter.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/chunk.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -3,6 +3,7 @@
 import types
 import string
 from format import checkFormat
+from error import error
 
 class Chunk(object):
     def __init__(self, id, description, stream, addr, size, parent):
@@ -32,6 +33,8 @@
     def getDisplayData(self):
         return self.getData()
 
+    def setParent(self, parent):
+        self._parent = parent
     def getParent(self): return self._parent
     def _setAddr(self, addr): self._addr = addr
     def _getAddr(self): return self._addr
@@ -63,7 +66,7 @@
                 prev_chunk = chunk
                 pos = pos + 1
         except Exception, msg:
-            print "Exception while updating an array:\n%s" % msg
+            error("Exception while updating an array:\n%s" % msg)
             chunk = self._array[pos]
             addr = chunk.addr
             size = self._stream.getSize() - addr
@@ -87,20 +90,16 @@
         
 class FilterChunk(Chunk):
     def __init__(self, id, filter, parent):
-        Chunk.__init__(self, id, filter.description, filter.getStream(), filter.getAddr(), filter.getSize(), parent)
+        Chunk.__init__(self, id, filter.getDescription(), filter.getStream(), filter.getAddr(), filter.getSize(), parent)
         self._filter = filter
         self._filter.filter_chunk = self
 
     def update(self):
-        filter_class = self._filter.__class__
-        stream = self._filter.getStream()
-        parent = self._filter.getParent()
-        stream.seek(self.addr)
-        filter = filter_class(stream, parent)
-        self.setFilter(filter)
+        new = self._filter.clone()
+        if new == None: return
+        self.setFilter(new)
 
     def setFilter(self, filter):
-        print "Set filter to %s" % filter.id
         self._filter = filter
         self._filter.updateParent(self)
         
@@ -160,9 +159,6 @@
 
         # Update format
         old_size = self.size
-        if not checkFormat(format):
-            print "Wrong format: \"%s\"!" % format
-            return
         self.__format = format
         new_size = self.size
         diff_size = new_size - old_size
@@ -182,7 +178,7 @@
 #                self._parent.addRawChunk(self, old_id, -diff_size, old_description)
 #            else:
             self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description)
-        self._parent.redisplay()
+        self._parent.updateFormatChunk(self)
 
     def isArray(self):
         if self.isString(): return False

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/filter.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -9,11 +9,13 @@
 import ui
 from chunk import Chunk, FormatChunk, ArrayChunk, FilterChunk
 from format import splitFormat    
+from error import error
+from tools import getBacktrace
 
 class Filter:
     def __init__(self, id, description, stream, parent):
-        self.id = id
-        self.description = description
+        self._id = id
+        self._description = description
         self._sub_struct = {}
         self._stream = stream
         self._parent = parent
@@ -33,6 +35,33 @@
         self._chunks_dict = {}
         self._addr = self._stream.tell()
 
+    def clone(self):
+        if self.__class__ == Filter:
+            return None
+        self.getStream().seek(self.getAddr())
+        return self.__class__(self.getStream(), self.getParent())
+
+    def getId(self): return self._id
+    def setId(self, id): self._id = id
+    def getDescription(self): return self._description
+    def setDescription(self, description): self._description = description
+
+    def deleteChunk(self, chunk):
+        if len(self._chunks) < 2:
+            error("Can't not the chunk %s (there is only one chunk)." % chunk.id)
+            return            
+        chunk_size = chunk.size
+        pos = self._chunks.index(chunk)
+        assert chunk.id in self._chunks_dict and hasattr(self, chunk.id)
+        del self._chunks[pos]
+        del self._chunks_dict[chunk.id]
+        delattr(self, chunk.id)        
+        # Delete last chunk of a sub filter? It true, truncate the sub filter
+        if self.getParent() != None and pos == len(self._chunks):
+            chunk_size = 0
+        self.rescanFromPos(pos, -chunk_size)
+        self.redisplay()
+
     def getChunks(self):
         return self._chunks
 
@@ -72,25 +101,38 @@
     def rescan(self, from_chunk, diff_size, new_id=None, new_description=None):
         if from_chunk != None:
             start = self._chunks.index(from_chunk)+1
-            prev_chunk = from_chunk
         else:
             start = 0
+        self.rescanFromPos(start, diff_size, new_id, new_description)
+            
+    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None):
+        assert 0<=start and start <= len(self._chunks)
+        if 0<start:
+            prev_chunk = self._chunks[start-1]
+        else:
             prev_chunk = None
+
+        # Update last chunk size if needed
         if start == len(self._chunks):
-            print "Here"
             if diff_size < 0:
+                assert prev_chunk != None
                 if new_id != None:
                     id = new_id
                 else:
-                    id = from_chunk.id
+                    id = prev_chunk.id
                 id = self.getUniqChunkId(id)
                 if new_description != None:
                     description = new_description
                 else:
-                    description = from_chunk.description
-                self.addRawChunk(from_chunk, id, "{@end@}", description)
-            return
+                    description = prev_chunk.description
+                if self.getParent() == None:
+                    size = "{@end@}"
+                else:
+                    size = -diff_size
+                self.addRawChunk(prev_chunk, id, size, description)
+                diff_size = 0
 
+        # Update chunks address
         pos = start
         try:
             for chunk in self._chunks[start:]:
@@ -98,22 +140,30 @@
                 if prev_chunk != None:
                     chunk.addr = prev_chunk.addr + prev_chunk.size
                 else:
-                    chunk.addr = self.addr
+                    chunk.addr = self.getAddr()
                 chunk.update()
                 if pos == len(self._chunks)-1 and issubclass(chunk.__class__, FormatChunk):
                     format = splitFormat(chunk.getFormat())
-                    if format[1] != "{@end@}":
-                        chunk.convertToStringSize("{@end@}")
+                    if self.getParent() == None:
+                        if format[1] != "{@end@}":
+                            chunk.convertToStringSize("{@end@}")
+                    else:
+                        size = chunk.size - diff_size
+                        chunk.convertToStringSize(size)
                 prev_chunk = chunk
                 pos = pos + 1
         except Exception, msg:
-            print "Exception while updating a filter:\n%s" % msg
+            error("Exception while updating a filter:\n%s\n%s" \
+                % (msg,getBacktrace()))
             chunk = self._chunks[pos]
             size = self._stream.getSize() - chunk.addr
             del self._chunks[pos:]
             if size != 0:
                 chunk = FormatChunk("raw", "Raw data", chunk.getStream(), chunk.addr, "!%us" % size, self)
                 self._appendChunk(chunk)
+                
+        if self.getParent() != None:
+            self.getParent().rescan(self.filter_chunk, 0)
 
     def getAddr(self):
         return self._addr
@@ -129,19 +179,24 @@
 
     def getChunk(self, chunk_id):
         m = re.compile(r"^([^[]+)\[([0-9]+)\]$").match(chunk_id)
+        chunk = None
         if m != None:
             array = self._chunks_dict.get(m.group(1), None)
-            if array == None: return None
-            return array[int(m.group(2))]
+            if array != None:
+                chunk = array[int(m.group(2))]
         else:
-            return self._chunks_dict.get(chunk_id, None)
+            chunk = self._chunks_dict.get(chunk_id, None)
+        if chunk == None:
+            raise Exception("Filter %s has no chunk with id \"%s\"." \
+                % (self.getId(), chunk_id))
+        return chunk
 
     def displayChunk(self, chunk):
         type = chunk.__class__
         if issubclass(type, FormatChunk):
             type = chunk.getFormat()
         elif issubclass(type, FilterChunk):
-            type = chunk.getFilter().id
+            type = chunk.getFilter().getId()
         ui.window.add_table(self.table_parent, chunk.addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
 
     def redisplay(self):  
@@ -152,9 +207,9 @@
         current = self
         while current != None:
             if text != "": text = " > " + text
-            text = current.id + text
+            text = current.getId() + text
             current = current.getParent()
-        ui.window.updateStatusBar("%s: %s" % (text, self.description))
+        ui.window.updateStatusBar("%s: %s" % (text, self.getDescription()))
 
     def display(self):  
         ui.window.enableParentButton(self.getParent() != None)
@@ -197,35 +252,40 @@
         line = getattr(self, id)
         setattr(self, id, line[:-len(eol)])
 
+    def updateFormatChunk(self, chunk):
+        if chunk.id == None: return
+        data = chunk.getData()
+        setattr(self, chunk.id, data)       
+
     def _appendChunk(self, chunk, can_truncate=False, position=None):
         if position != None:
             self._chunks.insert(position, chunk)
         else:
             self._chunks.append(chunk)
         id = chunk.id
-        if id != None:
-            m = re.compile(r"^([^[]+)\[\]$").match(id)
-            if m != None:
-                id = m.group(1)
-                if hasattr(self, id):
-                    array = getattr(self, id)
-                else:
-                    array = []
-                    setattr(self, id, array)
-                assert type(array) == types.ListType
-                chunk.id = "%s[%u]" % (id, len(array))
-                array.append(chunk)
-                if id not in self._chunks_dict:
-                    self._chunks_dict[id] = array 
+        assert id != None
+        m = re.compile(r"^([^[]+)\[\]$").match(id)
+        if m != None:
+            id = m.group(1)
+            if hasattr(self, id):
+                array = getattr(self, id)
             else:
-                if hasattr(self, id):
-                    raise Exception("Chunk identifier \"%s\" already exist!" % id)
-                if can_truncate:
-                    data = chunk.getData(40)
-                else:
-                    data = chunk.getData()
-                setattr(self, id, data)
-                self._chunks_dict[id] = chunk
+                array = []
+                setattr(self, id, array)
+            assert type(array) == types.ListType
+            chunk.id = "%s[%u]" % (id, len(array))
+            array.append(chunk)
+            if id not in self._chunks_dict:
+                self._chunks_dict[id] = array 
+        else:
+            if hasattr(self, id):
+                raise Exception("Chunk identifier \"%s\" already exist!" % id)
+            if can_truncate:
+                data = chunk.getData(40)
+            else:
+                data = chunk.getData()
+            setattr(self, id, data)
+            self._chunks_dict[id] = chunk
 
     def readChild(self, id, filter_class, description): 
         filter = filter_class(self._stream, self)
@@ -264,15 +324,21 @@
 
     def __str__(self):
         return "Filter(%s) <id=%s, description=%s>" % \
-            (self.__class__, self.id, self.description)
+            (self.__class__, self.getId(), self.getDescription())
 
     def addNewFilter(self, chunk, id, size, desc):
-        chunk.setFormat("!%us" % size, "split", id, desc)
+        chunk.setFormat("!%ss" % size, "split", id, desc)
+        self.convertChunkToFilter(chunk)
 
+    def convertChunkToFilter(self, chunk):
+        # Create new filter
         stream = self.getStream()
         stream.seek(chunk.addr)
-        filter = Filter(id, desc, stream, self)
-        filter._appendChunk(chunk)
+        filter = Filter(chunk.id, chunk.description, stream, self)
+        chunk.setParent(filter)
+        filter._appendChunk(chunk, can_truncate=True)
+        
+        # Create new chunk and add it into self 
         new_chunk = FilterChunk(chunk.id, filter, self)
         pos = self._chunks.index(chunk)
         self._chunks[pos] = new_chunk

Modified: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/hachoir.glade	2005-11-01 03:19:43 UTC (rev 242)
@@ -107,6 +107,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_new">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Open new file and split it</property>
 		  <property name="stock_id">gtk-new</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
@@ -122,6 +123,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_open">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Open a filter and apply it to this level</property>
 		  <property name="stock_id">gtk-open</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
@@ -137,6 +139,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_save">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Save current filter into a XML file</property>
 		  <property name="stock_id">gtk-save</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
@@ -165,6 +168,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_parent">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Go to parent filter</property>
 		  <property name="label" translatable="yes">Parent</property>
 		  <property name="use_underline">True</property>
 		  <property name="stock_id">gtk-go-up</property>
@@ -182,6 +186,7 @@
 	      <child>
 		<widget class="GtkToolButton" id="toolbutton_property">
 		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Set filter properties</property>
 		  <property name="stock_id">gtk-properties</property>
 		  <property name="visible_horizontal">True</property>
 		  <property name="visible_vertical">True</property>
@@ -258,7 +263,7 @@
       <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image5">
+	<widget class="GtkImage" id="image20">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -279,7 +284,7 @@
       <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image6">
+	<widget class="GtkImage" id="image21">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -293,16 +298,16 @@
   </child>
 
   <child>
-    <widget class="GtkImageMenuItem" id="join_chunks">
+    <widget class="GtkImageMenuItem" id="convert_string_chunk_to_filter">
       <property name="visible">True</property>
-      <property name="label" translatable="yes">_Join chunks</property>
+      <property name="label" translatable="yes">_Convert string chunk to filter</property>
       <property name="use_underline">True</property>
-      <signal name="activate" handler="onJoinChunks" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
+      <signal name="activate" handler="onConvertToFilter" last_modification_time="Tue, 01 Nov 2005 01:30:56 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image7">
+	<widget class="GtkImage" id="image22">
 	  <property name="visible">True</property>
-	  <property name="stock">gtk-go-up</property>
+	  <property name="stock">gtk-convert</property>
 	  <property name="icon_size">1</property>
 	  <property name="xalign">0.5</property>
 	  <property name="yalign">0.5</property>
@@ -321,7 +326,7 @@
       <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image8">
+	<widget class="GtkImage" id="image23">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-edit</property>
 	  <property name="icon_size">1</property>
@@ -333,6 +338,27 @@
       </child>
     </widget>
   </child>
+
+  <child>
+    <widget class="GtkImageMenuItem" id="delete_chunk">
+      <property name="visible">True</property>
+      <property name="label" translatable="yes">Delete chunk</property>
+      <property name="use_underline">True</property>
+      <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
+
+      <child internal-child="image">
+	<widget class="GtkImage" id="image24">
+	  <property name="visible">True</property>
+	  <property name="stock">gtk-delete</property>
+	  <property name="icon_size">1</property>
+	  <property name="xalign">0.5</property>
+	  <property name="yalign">0.5</property>
+	  <property name="xpad">0</property>
+	  <property name="ypad">0</property>
+	</widget>
+      </child>
+    </widget>
+  </child>
 </widget>
 
 <widget class="GtkAboutDialog" id="about_dialog">
@@ -340,7 +366,7 @@
   <property name="destroy_with_parent">True</property>
   <property name="name" translatable="yes">Hachoir version 2005-10-30</property>
   <property name="copyright" translatable="yes">Copyright 2005 Victor Stinner</property>
-  <property name="comments" translatable="yes">Split binary stream into chunks ...</property>
+  <property name="comments" translatable="yes">Split binary stream into filters and chunks ...</property>
   <property name="license" translatable="yes">Under GNU GPL licence</property>
   <property name="website">http://www.haypocalc.com/wiki/Hachoir</property>
   <property name="website_label" translatable="yes">Website</property>

Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/hachoir.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -10,6 +10,8 @@
 import sys, os, re, traceback
 from hachoir_class import Hachoir
 from program import PROGRAM, VERSION
+from log import log
+from error import error
 
 def usage(defval):
     print "%s version %s" % (PROGRAM, VERSION)
@@ -71,7 +73,7 @@
                 module = "plugins."+m.group(1)
                 __import__(module)
                 modules.append(m.group(1))
-        print "Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules))
+        log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 
         opt = {
             "depth": 2,
@@ -85,11 +87,10 @@
             setattr(hachoir, key, opt[key])
         try:
             import ui 
-            print ui.ui
         except ImportError, err:
-            print """Error: a Python module is missing:\n%s\n
+            error("""Error: a Python module is missing:\n%s\n
 You can find PyGTK at: http://www.pygtk.org/
-and PyGlade at: http://glade.gnome.org/""" % (err)
+and PyGlade at: http://glade.gnome.org/""" % (err))
             sys.exit(1)
         ui.loadInterface(hachoir)
         hachoir.run(filename)
@@ -97,8 +98,7 @@
     except SystemExit:
         pass
     except Exception, err:
-        print "Exception:\n%s" % (err)
-        print "".join(traceback.format_exception( \
+        where = "".join(traceback.format_exception( \
             sys.exc_type, sys.exc_value, sys.exc_traceback))
-
+        error("Exception:\n%s\n%s" % (err, where))
 if __name__=="__main__": main()    

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/hachoir_class.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -3,6 +3,7 @@
 from chunk import FilterChunk
 from default import DefaultFilter, displayDefault
 from user_filter import UserFilterDescriptor, UserFilter
+from error import error
 
 class Hachoir:
     def __init__(self):
@@ -20,32 +21,39 @@
     def onRowClick(self, chunk_id):
         if chunk_id == None: return
         chunk = self.filter.getChunk(chunk_id)
-        print "Click: %s" % chunk
         if issubclass(chunk.__class__, FilterChunk):
             self.filter = chunk.getFilter()
             self.filter.display()
 
     def loadUser(self, filename):
         old_filter = self.filter
+        old_size = old_filter.getSize()
         user = UserFilterDescriptor(xml_file=filename)
         stream = self.filter.getStream()
-        stream.seek(0)
         parent = self.filter.getParent()
+        stream.seek(self.filter.getAddr())
         self.filter = UserFilter(user, stream, parent)
         if parent == None:
             self.main_filter = self.filter
         else:
             chunk = old_filter.filter_chunk
             chunk.setFilter(self.filter)
+            diff_size = self.filter.getSize() - old_size
+            print "Diff size = %s" % diff_size
+            chunk.getParent().rescan(chunk, diff_size)
         self.filter.display()
         self.ui.window.updateToolbar()
     
     def saveUser(self, filename):
-        my = UserFilterDescriptor(filter=self.main_filter)
+        my = UserFilterDescriptor(filter=self.filter)
         my.writeIntoXML(filename)
         
     def load(self, filename):
-        stream = FileStream(filename)
+        try:
+            stream = FileStream(filename)
+        except IOError, err:
+            error("Can't load file %s:\n%s" % (filename, err))
+            return
 
         # Look for a plugin
         plugin = getPlugin(filename)
@@ -53,20 +61,20 @@
             regex, plugin_name, split_func, display_func = None, "default", DefaultFilter, displayDefault 
         else:
             regex, plugin_name, split_func, display_func = plugin
-        if self.verbose:
-            print "Split file \"%s\": %s." % (filename, plugin_name)
             
         # Split 
-        if 0 < self.depth:
-            print "=== Split file %s ===" % filename
-
-        self.filter = split_func(stream)
+        try:
+            filter = split_func(stream)
+        except Exception, msg:
+            error("Exception while processing file %s with filter %s:\n%s" \
+                % (filename, plugin_name, msg))
+            raise
+            return
+        self.main_filter = self.filter = filter
         self.filter.display()
-        self.main_filter = self.filter
 
         # Display
         if self.display:
-            print "=== File %s data ===" % filename
             display_func(self.filter)
         self.ui.window.updateToolbar()
 

Added: haypo/hachoir/id3.xml
===================================================================
--- haypo/hachoir/id3.xml	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/id3.xml	2005-11-01 03:19:43 UTC (rev 242)
@@ -0,0 +1,9 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<user_filter hachoir_version='2005-10-27' id="id3_tag" description="MP3 ID3 tag">
+  <chunk format='!3s' id='header' description='Header (ID3)'/>
+  <chunk format='!1B' id='ver_major' description='Version (major)'/>
+  <chunk format='!B' id='ver_minor' description='Version (minor)'/>
+  <chunk format='!B' id='flags' description='Flags'/>
+  <chunk format='!L' id='size' description='Size'/>
+  <chunk format='!{@end@}s' id='data' description='Data'/>
+</user_filter>

Added: haypo/hachoir/id3_chunk.xml
===================================================================
--- haypo/hachoir/id3_chunk.xml	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/id3_chunk.xml	2005-11-01 03:19:43 UTC (rev 242)
@@ -0,0 +1,7 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<user_filter hachoir_version='2005-10-27' id='raw' description='raw'>
+  <chunk format='!4s' id='header' description='Header'/>
+  <chunk format='>L' id='size' description='Size'/>
+  <chunk format='>H' id='flags' description='Flags'/>
+  <chunk format='!{size}s' id='data' description='Data'/>
+</user_filter>

Added: haypo/hachoir/log.py
===================================================================
--- haypo/hachoir/log.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/log.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -0,0 +1,93 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
+
+import time
+
+class Log:
+    LOG_INFO   = 0
+    LOG_WARN   = 1
+    LOG_ERROR  = 2
+
+    def __init__(self):
+        self.__buffer = {}
+        self.__file = None
+        self.use_print = True
+        self.on_new_message = None # (level, prefix, text)
+
+    def setFilename(self, filename):
+        """
+        Use a file to store all messages. The
+        UTF-8 encoding will be used. Write an informative
+        message if the file can't be created.
+
+        @param filename: C{L{string}}
+        """
+
+        try:
+            import codecs
+            self.__file = codecs.open(filename, "w", "utf-8")
+        except IOError, errno:
+            if errno[0] == 2:
+                self.__file = None
+                self.info("Log.setFilename(%s) fails : no such file." % filename)
+                return
+            raise
+
+    def getLevelPrefix(self, level):
+        """
+        String prefix which depends on message level.
+        Eg. information returns "[info]".
+        @return: C{str}
+        """
+        if level==Log.LOG_WARN: return "[warn]"
+        if level==Log.LOG_ERROR: return "[err!]"
+        return "[info]"
+
+    def newMessage(self, level, str):
+        """
+        Write a new message : append it in the buffer,
+        display it to the screen (if needed), and write
+        it in the log file (if needed).
+
+        @param level: Message level.
+        @type level: C{int}
+        @param str: Message content.
+        @type str: C{str}
+        """
+
+        if not self.__buffer.has_key(level):
+            self.__buffer[level] = [str]
+        else:
+            self.__buffer[level].append(str)
+        prefix = self.getLevelPrefix(level)            
+        if self.use_print:
+            print "%s %s" % (prefix, str)
+        if self.__file:
+            self.__file.write(u"%s - %s %s\n" \
+                % (time.strftime("%Y-%M-%d %H:%M:%S"),
+                   prefix, str))
+        if self.on_new_message:
+            self.on_new_message (level, prefix, str)
+
+    def info(self, str):
+        """
+        New informative message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_INFO, str)
+
+    def warning(self, str):
+        """
+        New warning message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_WARN, str)
+
+    def error(self, str):
+        """
+        New error message.
+        @type str: C{str}
+        """
+        self.newMessage(Log.LOG_ERROR, str)
+
+log = Log()        

Modified: haypo/hachoir/plugins/exe.py
===================================================================
--- haypo/hachoir/plugins/exe.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/plugins/exe.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -199,11 +199,8 @@
         self.read("pe_offset", "<L", "Offset to PE header")
 
 class ExeFile(Filter):
-    def checkEndOfSections(self, stream, array, section):
-        return len(array) == self.pe.nb_sections
-
     def __init__(self, stream):
-        Filter.__init__(self, "exe_file", "EXE file", stream)
+        Filter.__init__(self, "exe_file", "EXE file", stream, None)
 
         self.readChild("ms_dos", MS_Dos, "MS-Dos header")
 
@@ -235,4 +232,7 @@
         else:
             self.pe = None
 
+    def checkEndOfSections(self, stream, array, section):
+        return len(array) == self.pe.nb_sections
+
 registerPlugin("^.*\.(exe|EXE)$", "MS-Dos / Windows executable filter", ExeFile, displayExe)

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/plugins/gif.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -97,11 +97,11 @@
         # -- End of TODO
         
         self.read("background", "<B", "Background color")
-        self.read(None, "<B", "Not used (zero)")
+        self.read("notused", "<B", "Not used (zero)")
         
 class GifFile(Filter):
     def __init__(self, stream):
-        Filter.__init__(self, "gif_file", "GIF picture file", stream)
+        Filter.__init__(self, "gif_file", "GIF picture file", stream, None)
         # Header
         self.read("header", "6s", "File header")
         assert (self.header == "GIF87a") or (self.header == "GIF89a")
@@ -114,7 +114,7 @@
             
         self.images = []
         while True:
-            code = self.read(None, "c", "Separator code")
+            code = self.read("separator[]", "c", "Separator code")
             code = code.getData()
             if code == "!":
                 self.readChild("extensions[]", GifExtension, "Extension")

Modified: haypo/hachoir/plugins/ncftp.py
===================================================================
--- haypo/hachoir/plugins/ncftp.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/plugins/ncftp.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -39,7 +39,7 @@
 
 class NcftpFile(Filter):
     def __init__(self, stream):
-        Filter.__init__(self, "ncftp_file", "NCFTP bookmark file", stream)
+        Filter.__init__(self, "ncftp_file", "NCFTP bookmark file", stream, None)
         self.readLine("header", "Header (first line")
         self.readLine("nb_bookmark", "Number of bookmarks")
         self.readArray("bookmarks", NcftpBookmark, "Bookmarks", self.checkEOF)

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/plugins/png.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -122,7 +122,7 @@
             self.readChild("chunk_data", child_filter, "Chunk data")
             assert oldpos + self.size == self._stream.tell()
         else:
-            self.read(None, "!{size}s", "Chunk data")
+            self.read("data", "!{size}s", "Chunk data")
         self.read("crc32", "!L", "Chunk CRC32")
 
     def updateParent(self, chunk):

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/plugins/tar.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -67,13 +67,12 @@
         self.gname = self.gname.strip("\0")
         self.read("devmajor", "!8s", "Dev major")
         self.read("devminor", "!8s", "Dev minor")
-        #self.read(None, "!167s", "Padding (zero)")
-        self.read(None, "!167s", "Padding (zero)")
+        self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
             self.read("filedata", "!{size}s", "File data", True)
         if stream.tell() % 512 != 0:
             padding = 512 - stream.tell() % 512
-            self.read(None, "!%ss" % padding, "Padding (512 align)")
+            self.read("padding", "!%ss" % padding, "Padding (512 align)")
 
     def isEmpty(self):
         return self.name == ""
@@ -109,12 +108,12 @@
 
 class TarFile(Filter):
     def __init__(self, stream):
-        Filter.__init__(self, "tar_file", "TAR archive file", stream)
+        Filter.__init__(self, "tar_file", "TAR archive file", stream, None)
 
         self.readArray("files", TarFileEntry, "Tar Files", self.checkEndOfChunks)
         
         padding = 4096 - stream.tell() % 4096
-        self.read(None, "!%ss" % padding, "Padding (4096 align)")
+        self.read("padding", "!%ss" % padding, "Padding (4096 align)")
 
         assert stream.eof()
 

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/plugins/zip.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -92,7 +92,7 @@
         
 class ZipFile(Filter):
     def __init__(self, stream):
-        Filter.__init__(self, "zip_file", "ZIP archive file", stream)
+        Filter.__init__(self, "zip_file", "ZIP archive file", stream, None)
         # File data
         self.signature = None
         self.central_directory = []

Added: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/tools.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -0,0 +1,6 @@
+import traceback, sys
+
+def getBacktrace():
+    bt = traceback.format_exception( \
+        sys.exc_type, sys.exc_value, sys.exc_traceback)
+    return "".join(bt)

Modified: haypo/hachoir/ui.py
===================================================================
--- haypo/hachoir/ui.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/ui.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -3,9 +3,6 @@
 pygtk.require ('2.0')
 import gtk
 import gtk.glade
-from ui_popup import TablePopup
-from ui_window import MainWindow
-from ui_property import PropertyDialog
 
 def loadInterface(hachoir):
     global ui 
@@ -38,6 +35,9 @@
         self.about_dialog.hide()
         
     def build_ui(self):
+        from ui_window import MainWindow
+        from ui_popup import TablePopup
+        from ui_property import PropertyDialog
         self.window = MainWindow(self)
         self.loadAbout()
         self.table_popup = TablePopup(self, self.glade_xml)

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/ui_popup.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -5,6 +5,7 @@
 from chunk import FormatChunk
 from ui_new_chunk import NewChunkDialog
 from format import splitFormat # TODO: remove this line
+from error import error
 
 class TablePopup:
     def __init__(self, ui, filename):
@@ -19,10 +20,18 @@
         col = path_info[0][0]
         self.chunk = self.ui.window.getTableChunk(col)
         if self.chunk == None:
-            print "Can't get chunk"
+            error("Can't get chunk")
             return
         self.popup.popup( None, None, None, event.button, event.time)
 
+    def onDeleteChunk(self, event):
+        self.chunk.getParent().deleteChunk(self.chunk)
+
+    def onConvertToFilter(self, event):
+        if not issubclass(self.chunk.__class__, FormatChunk):
+            print "Only works on format chunk"
+        self.chunk.getParent().convertChunkToFilter(self.chunk)
+        
     def onNewChunk(self, event):
         if self.new_chunk.runNewChunk() == gtk.RESPONSE_CANCEL: return
         assert issubclass(self.chunk.__class__, FormatChunk) and self.chunk.isString()
@@ -30,13 +39,14 @@
         id = self.new_chunk.getId()
         desc = self.new_chunk.getDescription()
         self.chunk.setFormat(format, "split", id, desc)
+        self.chunk.getParent().redisplay()
 
     def onNewFilter(self, event):
         if self.new_chunk.runNewChunk() == gtk.RESPONSE_CANCEL: return
         assert issubclass(self.chunk.__class__, FormatChunk) and self.chunk.isString()
         format = self.new_chunk.getFormat()
         split_format = splitFormat(format)
-        size = int(split_format[1])
+        size = split_format[1]
         id = self.new_chunk.getId()
         desc = self.new_chunk.getDescription()
         self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
@@ -47,9 +57,12 @@
             format = self.new_chunk.getFormat()
             self.chunk.id = self.new_chunk.getId()
             self.chunk.description = self.new_chunk.getDescription()
-            self.chunk.setFormat(format, "rescan")
+            try:
+                self.chunk.setFormat(format, "rescan")
+            except Exception, msg:
+                error("Exception while trying to set chunk %s format to \"%s\"." \
+                    % (self.chunk.id, format))
+                pass
+            self.chunk.getParent().redisplay()
         else:
-            print "Can't set format of chunk of type %s" % self.chunk.__class__
-
-    def onJoinChunks(self, event):
-        print "join chunk"
+            error("Can't set format of chunk of type %s" % self.chunk.__class__)

Modified: haypo/hachoir/ui_property.py
===================================================================
--- haypo/hachoir/ui_property.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/ui_property.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -21,8 +21,8 @@
         return self.desc_widget.get_text()
 
     def run(self, filter):
-        self.id_widget.set_text(filter.id)
-        self.desc_widget.set_text(filter.description)
+        self.id_widget.set_text(filter.getId())
+        self.desc_widget.set_text(filter.getDescription())
         r = self.window.run()
         self.window.hide()
         return r

Modified: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/ui_window.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -107,12 +107,11 @@
         self.on_open_activate(widget)
 
     def on_toolbutton_property(self, widget):
-        print "Property"
         filter = self.ui.hachoir.filter
         dlg = self.ui.property_dialog
         if dlg.run(filter) == gtk.RESPONSE_CANCEL: return
-        filter.id = dlg.getId() 
-        filter.description = dlg.getDescription()
+        filter.setId( dlg.getId() )
+        filter.setDescription( dlg.getDescription() )
         filter.updateStatusBar()
         
     def on_open_activate(self, widget):
@@ -136,7 +135,6 @@
         chooser.destroy()
 
     def on_toolbutton_save(self, widget):
-        print "Save"
         chooser = gtk.FileChooserDialog( \
             title="Save filter into ...",
             action=gtk.FILE_CHOOSER_ACTION_SAVE,
@@ -147,7 +145,7 @@
         chooser.destroy()
 
     def on_about_activate(self, widget):
-        self.about_dialog.show()
+        self.ui.about_dialog.show()
 
     def on_quit_activate(self, widget):
         self.ui.quit()

Modified: haypo/hachoir/user_filter.py
===================================================================
--- haypo/hachoir/user_filter.py	2005-10-31 16:40:26 UTC (rev 241)
+++ haypo/hachoir/user_filter.py	2005-11-01 03:19:43 UTC (rev 242)
@@ -96,8 +96,8 @@
 #                chunk.sub.__toXML(doc, item)
 
     def createFromFilter(self, filter):
-        self.id = filter.id 
-        self.description = filter.description
+        self.id = filter.getId()
+        self.description = filter.getDescription()
         self.chunks = []
         self.__createFromChunks(filter.getChunks())
 



From haypo at berlios.de  Tue Nov  1 04:20:26 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 1 Nov 2005 04:20:26 +0100
Subject: [Happyboom-svn] r243 - haypo/hachoir
Message-ID: <200511010320.jA13KQLw031234@sheep.berlios.de>

Author: haypo
Date: 2005-11-01 04:20:25 +0100 (Tue, 01 Nov 2005)
New Revision: 243

Added:
   haypo/hachoir/error.py
Log:
Add error.py (error managing)


Added: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-11-01 03:19:43 UTC (rev 242)
+++ haypo/hachoir/error.py	2005-11-01 03:20:25 UTC (rev 243)
@@ -0,0 +1,16 @@
+import os
+import pygtk
+pygtk.require ('2.0')
+import gtk
+from log import log
+import ui
+
+def error(message):
+    log.error(message)
+    if ui.ui != None:
+        dlg = gtk.MessageDialog( \
+            type=gtk.MESSAGE_ERROR,
+            buttons=gtk.BUTTONS_OK,
+            message_format=message)
+        dlg.run()
+        dlg.destroy()



From haypo at berlios.de  Wed Nov  2 00:30:01 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 2 Nov 2005 00:30:01 +0100
Subject: [Happyboom-svn] r244 - in haypo/hachoir: . plugins
Message-ID: <200511012330.jA1NU1Eq019582@sheep.berlios.de>

Author: haypo
Date: 2005-11-02 00:30:00 +0100 (Wed, 02 Nov 2005)
New Revision: 244

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/error.py
   haypo/hachoir/filter.py
   haypo/hachoir/format.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/ui_popup.py
   haypo/hachoir/ui_window.py
   haypo/hachoir/user_filter.py
Log:
Lot of bug fix (around create/edit/delete chunks).


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/chunk.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -48,46 +48,6 @@
     size = property(_getSize)        
     id = property(__getId, __setId)
     
-class ArrayChunk(Chunk):
-    def __init__(self, id, description, stream, array, parent):
-        Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
-        self._array = array
-
-    def update(self):
-        prev_chunk = None
-        pos = 0
-        try:
-            for chunk in self._array:
-                if prev_chunk != None:
-                    chunk.addr = prev_chunk.addr + prev_chunk.size
-                else:
-                    chunk.addr = self.addr
-                chunk.update()
-                prev_chunk = chunk
-                pos = pos + 1
-        except Exception, msg:
-            error("Exception while updating an array:\n%s" % msg)
-            chunk = self._array[pos]
-            addr = chunk.addr
-            size = self._stream.getSize() - addr
-            del self._array[pos:]
-            if size != 0:
-                chunk = FormatChunk("raw", "Raw data", chunk.getStream(), addr, "!%us" % size, self)
-                self._array.append(chunk)
-
-    def _getSize(self):
-        size = 0
-        for item in self._array:
-            size = size + item.size
-        return size
-    size = property(_getSize)        
-    
-    def getData(self, max_size=None):
-        return self._array
-
-    def __getitem__(self, index):
-        return self._array[index]
-        
 class FilterChunk(Chunk):
     def __init__(self, id, filter, parent):
         Chunk.__init__(self, id, filter.getDescription(), filter.getStream(), filter.getAddr(), filter.getSize(), parent)
@@ -102,6 +62,11 @@
     def setFilter(self, filter):
         self._filter = filter
         self._filter.updateParent(self)
+    
+    def _setAddr(self, addr):
+        self._addr = addr
+        self._filter.setAddr(addr)
+    addr = property(Chunk._getAddr, _setAddr)        
         
     def _getSize(self):
         return self._filter.getSize()
@@ -174,10 +139,10 @@
 
         # Update filter if needed
         if diff_size != 0:
-#            if method == "split" and diff_size < 0:
-#                self._parent.addRawChunk(self, old_id, -diff_size, old_description)
-#            else:
-            self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description)
+            if method == "split" and diff_size < 0:
+                self._parent.addRawChunk(self, old_id, -diff_size, old_description)
+            else:
+                self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description)
         self._parent.updateFormatChunk(self)
 
     def isArray(self):
@@ -203,7 +168,7 @@
 #        return str(getattr(self, match.group(1)))
         id = match.group(1)
         if id == "@end@":
-            size = self.__stream.getLastPos() - self.addr
+            size = self.__stream.getLastPos() - self.addr + 1
         else:
             size = getattr(self._parent, id)
         return str(size)

Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/error.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -5,6 +5,16 @@
 from log import log
 import ui
 
+def warning(message):
+    log.warning(message)
+    if ui.ui != None:
+        dlg = gtk.MessageDialog( \
+            type=gtk.MESSAGE_WARNING,
+            buttons=gtk.BUTTONS_OK,
+            message_format=message)
+        dlg.run()
+        dlg.destroy()
+
 def error(message):
     log.error(message)
     if ui.ui != None:

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/filter.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -7,7 +7,7 @@
 import string
 import types
 import ui
-from chunk import Chunk, FormatChunk, ArrayChunk, FilterChunk
+from chunk import Chunk, FormatChunk, FilterChunk
 from format import splitFormat    
 from error import error
 from tools import getBacktrace
@@ -16,21 +16,13 @@
     def __init__(self, id, description, stream, parent):
         self._id = id
         self._description = description
-        self._sub_struct = {}
         self._stream = stream
         self._parent = parent
         if self._parent:
             self.depth = self._parent.depth + 1
-            self.table_parent = self._parent.table_item
         else:
             self.depth = 1
-            self.table_item = None
-            self.table_parent = None 
         self.filter_chunk = None 
-        self.indent = " " * ((self.depth-1)*2)
-        self.child_indent = " " * (self.depth*2)
-        self.table_item = None
-        self.__last_child_stream_pos = None 
         self._chunks = []
         self._chunks_dict = {}
         self._addr = self._stream.tell()
@@ -39,27 +31,33 @@
         if self.__class__ == Filter:
             return None
         self.getStream().seek(self.getAddr())
-        return self.__class__(self.getStream(), self.getParent())
+        new = self.__class__(self.getStream(), self.getParent())
+        new.filter_chunk = self.filter_chunk
+        return new
 
     def getId(self): return self._id
     def setId(self, id): self._id = id
     def getDescription(self): return self._description
     def setDescription(self, description): self._description = description
 
+    def _deleteChunk(self, pos):
+        chunk = self._chunks[pos]
+        if chunk.id in self._chunks_dict:
+            del self._chunks_dict[chunk.id]
+        if hasattr(self, chunk.id):
+            delattr(self, chunk.id)        
+        del self._chunks[pos]
+
     def deleteChunk(self, chunk):
         if len(self._chunks) < 2:
             error("Can't not the chunk %s (there is only one chunk)." % chunk.id)
             return            
         chunk_size = chunk.size
         pos = self._chunks.index(chunk)
-        assert chunk.id in self._chunks_dict and hasattr(self, chunk.id)
-        del self._chunks[pos]
-        del self._chunks_dict[chunk.id]
-        delattr(self, chunk.id)        
+        self._deleteChunk(pos)
         # Delete last chunk of a sub filter? It true, truncate the sub filter
-        if self.getParent() != None and pos == len(self._chunks):
-            chunk_size = 0
-        self.rescanFromPos(pos, -chunk_size)
+        truncate = (self.getParent() != None and pos == len(self._chunks))
+        self.rescanFromPos(pos, -chunk_size, truncate_filter=truncate)
         self.redisplay()
 
     def getChunks(self):
@@ -93,9 +91,13 @@
         self._chunks_dict[new_id] = chunk
         
     def addRawChunk(self, prev_chunk, id, size, description):
-        addr = prev_chunk.addr + prev_chunk.size
+        if prev_chunk != None:
+            addr = prev_chunk.addr + prev_chunk.size
+            chunk_pos = self._chunks.index(prev_chunk)+1
+        else:
+            addr = self.getAddr()
+            chunk_pos = len(self._chunks)
         chunk = FormatChunk(id, description, self.getStream(), addr, "!%ss" % size, self)
-        chunk_pos = self._chunks.index(prev_chunk)+1
         self._appendChunk(chunk, can_truncate=True, position=chunk_pos)
 
     def rescan(self, from_chunk, diff_size, new_id=None, new_description=None):
@@ -105,34 +107,47 @@
             start = 0
         self.rescanFromPos(start, diff_size, new_id, new_description)
             
-    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None):
-        assert 0<=start and start <= len(self._chunks)
-        if 0<start:
-            prev_chunk = self._chunks[start-1]
+    def _rescanUpdateSize(self, diff_size, new_id=None, new_description=None):
+        # Only process diff_size < 0
+        if 0 <= diff_size: return
+
+        # Get last chunk
+        if 0 < len(self._chunks):
+            prev_chunk = self._chunks[-1]
         else:
             prev_chunk = None
+        
+        if False: #prev_chunk != None and 1<len(self._chunks) and issubclass(prev_chunk.__class__, FormatChunk):
+            # If last chunk is a FormatChunk, update it's size
+            format = splitFormat(prev_chunk.getFormat())
+            if self.getParent() == None:
+                if format[1] != "{@end@}":
+                    prev_chunk.convertToStringSize("{@end@}")
+            else:
+                size = prev_chunk.size - diff_size
+                prev_chunk.convertToStringSize(size)
+        else:
+            # Get id
+            if new_id != None:
+                id = new_id
+            else:
+                id = "raw"
+            id = self.getUniqChunkId(id)
 
-        # Update last chunk size if needed
-        if start == len(self._chunks):
-            if diff_size < 0:
-                assert prev_chunk != None
-                if new_id != None:
-                    id = new_id
-                else:
-                    id = prev_chunk.id
-                id = self.getUniqChunkId(id)
-                if new_description != None:
-                    description = new_description
-                else:
-                    description = prev_chunk.description
-                if self.getParent() == None:
-                    size = "{@end@}"
-                else:
-                    size = -diff_size
-                self.addRawChunk(prev_chunk, id, size, description)
-                diff_size = 0
+            # Get description
+            if new_description != None:
+                description = new_description
+            else:
+                description = ""
 
-        # Update chunks address
+            # Get size
+            if self.getParent() == None:
+                size = "{@end@}"
+            else:
+                size = -diff_size
+            self.addRawChunk(prev_chunk, id, size, description)
+
+    def _rescanUpdateChunks(self, start, prev_chunk):
         pos = start
         try:
             for chunk in self._chunks[start:]:
@@ -142,32 +157,47 @@
                 else:
                     chunk.addr = self.getAddr()
                 chunk.update()
-                if pos == len(self._chunks)-1 and issubclass(chunk.__class__, FormatChunk):
-                    format = splitFormat(chunk.getFormat())
-                    if self.getParent() == None:
-                        if format[1] != "{@end@}":
-                            chunk.convertToStringSize("{@end@}")
-                    else:
-                        size = chunk.size - diff_size
-                        chunk.convertToStringSize(size)
                 prev_chunk = chunk
                 pos = pos + 1
         except Exception, msg:
             error("Exception while updating a filter:\n%s\n%s" \
                 % (msg,getBacktrace()))
-            chunk = self._chunks[pos]
-            size = self._stream.getSize() - chunk.addr
-            del self._chunks[pos:]
-            if size != 0:
-                chunk = FormatChunk("raw", "Raw data", chunk.getStream(), chunk.addr, "!%us" % size, self)
-                self._appendChunk(chunk)
-                
+            iter = len(self._chunks)-1
+            while pos<=iter:
+                self._deleteChunk(iter)
+                iter = iter - 1
+
+    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate_filter=False):
+        assert 0<=start and start <= len(self._chunks)
+        if 0<start:
+            prev_chunk = self._chunks[start-1]
+        else:
+            prev_chunk = None
+
+        # Update chunks address
+        old_size = self.getSize()
+        self._rescanUpdateChunks(start, prev_chunk)
+        diff_size = diff_size + (self.getSize() - old_size)
+
+        # Update last chunk size if needed
+        if not truncate_filter:
+            self._rescanUpdateSize(diff_size, new_id, new_description)
+            diff_size = 0
+               
         if self.getParent() != None:
-            self.getParent().rescan(self.filter_chunk, 0)
+            self.getParent().rescan(self.filter_chunk, diff_size)
 
     def getAddr(self):
         return self._addr
 
+    def setAddr(self, addr):
+        self._addr = addr
+
+    def getLastPos(self):
+        if len(self._array) == 0: return self.getAddr()
+        last_chunk = self._array[-1]
+        return last_chunk.addr + last_chunk.size
+
     def getSize(self):
         size = 0
         for chunk in self._chunks:
@@ -178,16 +208,9 @@
         pass
 
     def getChunk(self, chunk_id):
-        m = re.compile(r"^([^[]+)\[([0-9]+)\]$").match(chunk_id)
-        chunk = None
-        if m != None:
-            array = self._chunks_dict.get(m.group(1), None)
-            if array != None:
-                chunk = array[int(m.group(2))]
-        else:
-            chunk = self._chunks_dict.get(chunk_id, None)
+        chunk = self._chunks_dict.get(chunk_id, None)
         if chunk == None:
-            raise Exception("Filter %s has no chunk with id \"%s\"." \
+            raise Exception("Filter \"%s\" has no chunk with id \"%s\"." \
                 % (self.getId(), chunk_id))
         return chunk
 
@@ -197,7 +220,7 @@
             type = chunk.getFormat()
         elif issubclass(type, FilterChunk):
             type = chunk.getFilter().getId()
-        ui.window.add_table(self.table_parent, chunk.addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
+        ui.window.add_table(None, chunk.addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
 
     def redisplay(self):  
         self.display()
@@ -209,7 +232,7 @@
             if text != "": text = " > " + text
             text = current.getId() + text
             current = current.getParent()
-        ui.window.updateStatusBar("%s: %s" % (text, self.getDescription()))
+        ui.window.updateStatusBar("%s: %s (size=%s)" % (text, self.getDescription(), self.getSize()))
 
     def display(self):  
         ui.window.enableParentButton(self.getParent() != None)
@@ -218,20 +241,8 @@
         # Update table
         ui.window.clear_table()
         for chunk in self._chunks:
-            if issubclass(chunk.__class__, ArrayChunk):
-                for subchunk in chunk:
-                    self.displayChunk(subchunk)
-            else:
-                self.displayChunk(chunk)
+            self.displayChunk(chunk)
 
-    def __isStrPrintable(self, str):
-        """
-        Can a string be printed on the screen?
-        """
-        for c in str:
-            if c not in string.printable: return False
-        return True
-
     def readField(self, id, description, delimiter):
         lg = self._stream.searchLength(delimiter, False)
         if lg == -1:
@@ -289,33 +300,20 @@
 
     def readChild(self, id, filter_class, description): 
         filter = filter_class(self._stream, self)
+        self.addFilter(id, filter)
+    
+    def addFilter(self, id, filter): 
         chunk = FilterChunk(id, filter, self)
         self._appendChunk(chunk)
         filter.updateParent(chunk)
         self._stream.seek(chunk.addr + chunk.size)
 
-    def readArray(self, id, filter_class, description, end_func): 
-        array = []
-        array_chunk = ArrayChunk(id, description, self._stream, array, self)
-        self._appendChunk(array_chunk)
-
-        nb = 0
-        last_filter = None
-        while not end_func(self._stream, array, last_filter):
-            filter = filter_class(self._stream, self)
-            chunk_id = "%s[%u]" % (id, nb)
-            nb = nb + 1
-            chunk = FilterChunk(chunk_id, filter, self)
-            array.append( chunk )
-            last_filter = filter
-
-        for chunk in array:
-            chunk.getFilter().updateParent(chunk)
-        self._stream.seek(array_chunk.addr + array_chunk.size)
+    def readArray(self, id, entry_class, description, end_func): 
+        filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
+        self.addFilter(id, filter)
     
     def read(self, id, format, description, can_truncate=True):
         """ Returns chunk """
-#        print "* Read chunk %s: format %s" % (id, format)
         chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
         self._stream.seek(chunk.size, 1)
         self._appendChunk(chunk, can_truncate)
@@ -351,3 +349,70 @@
 
     def getStream(self):
         return self._stream
+
+class ArrayFilter(Filter):
+    def __init__(self, id, description, stream, parent, entry_class, end_func):
+        Filter.__init__(self, id, description, stream, parent)
+        self._entry_class = entry_class
+        self._end_func = end_func
+        self._read()
+
+    def _read(self):
+        self._array = []
+        nb = 0
+        last_filter = None
+        while not self._end_func(self._stream, self._array, last_filter):
+            filter = self._entry_class(self._stream, self)
+            chunk_id = "%s[%u]" % (self.getId(), nb)
+            nb = nb + 1
+            chunk = FilterChunk(chunk_id, filter, self)
+            self._array.append( chunk )
+            self._appendChunk(chunk)
+            last_filter = filter
+
+        for chunk in self._array:
+            chunk.getFilter().updateParent(chunk)
+#        self._stream.seek(self.getAddr() + self.getSize())
+
+    def getArray(self):
+        return self._array
+    
+    def _deleteChunk(self, pos):
+        Filter._deleteChunk(self, pos)
+        if pos < len(self._array):
+            del self._array[pos]
+
+    def update(self):
+        prev_chunk = None
+        pos = 0
+        try:
+            for chunk in self._array:
+                if prev_chunk != None:
+                    chunk.addr = prev_chunk.addr + prev_chunk.size
+                else:
+                    chunk.addr = self.getAddr()
+                chunk.update()
+                prev_chunk = chunk
+                pos = pos + 1
+        except Exception, msg:
+            error("Exception while updating an ArrayFilter:\n%s" % msg)
+            chunk = self._array[pos]
+            addr = chunk.addr
+            size = self.getLastPos() - addr
+            del self._array[pos:]
+            if size != 0:
+                chunk = FormatChunk("raw", "Raw data", chunk.getStream(), addr, "!%us" % size, self)
+                self._array.append(chunk)
+
+    def __len__(self):
+        return len(self._array)
+
+    def __getitem__(self, index):
+        return self._array[index]
+
+    def clone(self):
+        self.getStream().seek(self.getAddr())
+        new = ArrayFilter( self.getId(), self.getDescription(), \
+            self.getStream(), self.getParent(), self._entry_class, self._end_func)
+        new.filter_chunk = self.filter_chunk
+        return new

Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/format.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -1,11 +1,11 @@
 import re
 
 def checkFormat(format):
-    m = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLs]$").match(format)
+    m = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLsc]$").match(format)
     return m != None
 
 def splitFormat(format):
-    m = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLs])$").match(format)
+    m = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLsc])$").match(format)
     if m == None: return None
     endian = m.group(1)
     if endian=="": endian="!"

Modified: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/hachoir.glade	2005-11-01 23:30:00 UTC (rev 244)
@@ -263,7 +263,7 @@
       <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image20">
+	<widget class="GtkImage" id="image32">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -277,14 +277,14 @@
   </child>
 
   <child>
-    <widget class="GtkImageMenuItem" id="new_filter1">
+    <widget class="GtkImageMenuItem" id="new_filter">
       <property name="visible">True</property>
       <property name="label" translatable="yes">New _filter</property>
       <property name="use_underline">True</property>
       <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image21">
+	<widget class="GtkImage" id="image33">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -298,14 +298,14 @@
   </child>
 
   <child>
-    <widget class="GtkImageMenuItem" id="convert_string_chunk_to_filter">
+    <widget class="GtkImageMenuItem" id="convert_to_filter">
       <property name="visible">True</property>
       <property name="label" translatable="yes">_Convert string chunk to filter</property>
       <property name="use_underline">True</property>
       <signal name="activate" handler="onConvertToFilter" last_modification_time="Tue, 01 Nov 2005 01:30:56 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image22">
+	<widget class="GtkImage" id="image34">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-convert</property>
 	  <property name="icon_size">1</property>
@@ -319,14 +319,14 @@
   </child>
 
   <child>
-    <widget class="GtkImageMenuItem" id="set_chunk_format">
+    <widget class="GtkImageMenuItem" id="set_format">
       <property name="visible">True</property>
       <property name="label" translatable="yes">Set chunk _format</property>
       <property name="use_underline">True</property>
       <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image23">
+	<widget class="GtkImage" id="image35">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-edit</property>
 	  <property name="icon_size">1</property>
@@ -347,7 +347,7 @@
       <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image24">
+	<widget class="GtkImage" id="image36">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-delete</property>
 	  <property name="icon_size">1</property>
@@ -500,7 +500,8 @@
 	  <child>
 	    <widget class="GtkComboBoxEntry" id="format">
 	      <property name="visible">True</property>
-	      <property name="items" translatable="yes">s
+	      <property name="items" translatable="yes">c
+s
 B
 H
 L</property>

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/plugins/gif.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -7,6 +7,7 @@
 
 from filter import Filter
 from plugin import registerPlugin
+from error import warning
 
 def displayGif(gif):
     print "Format: %s" % (gif.header)
@@ -121,7 +122,7 @@
             elif code == ",":
                 self.readChild("images[]", GifImage, "Image")
                 # TODO: Write GifImage code :-)
-                print "WARNING: GIF FILTER CAN NOT READ IMAGE CONTENT YET, SO ABORT READING!"
+                warning("GIF FILTER CAN NOT READ IMAGE CONTENT YET, SO ABORT READING!")
                 return
             elif code == ";":
                 # GIF Terminator

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/plugins/png.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -61,8 +61,10 @@
 class PngText(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "png_text", "PNG text", stream, parent)
+        max_length = parent.size
+        print "max",max_length
         old = self._stream.tell()
-        pos = self._stream.search("\0", 14)
+        pos = self._stream.search("\0", max_length)
         if pos == -1:
             raise Exception("Fails to find end of text")
         lg = (pos-old)

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/plugins/tar.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -5,6 +5,7 @@
 Author: Victor Stinner
 """
 
+import re
 from datetime import datetime
 from filter import Filter
 from plugin import registerPlugin
@@ -79,8 +80,10 @@
 
     def octal2int(self, str):
         str = str.strip("\0")
+        if str=="": return 0
+        assert re.match("^[0-7]+$", str)
         try:
-            return int(str.strip("\0"),8)
+            return int(str,8)
         except:
             return 0
 

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/ui_popup.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -14,55 +14,72 @@
         self.popup = xml.get_widget('table_popup')
         xml.signal_autoconnect(self)
         self.chunk = None
-        self.new_chunk = NewChunkDialog(self.ui.glade_xml)
+        self.new_chunk_dlg = NewChunkDialog(self.ui.glade_xml)
 
+        # Popup items
+        self.new_chunk = xml.get_widget("new_chunk")
+        self.new_filter = xml.get_widget("new_filter")
+        self.convert_to_filter = xml.get_widget("convert_to_filter")
+        self.set_format = xml.get_widget("set_format")
+        self.delete_chunk = xml.get_widget("delete_chunk")
+
     def show(self, path_info, event):
         col = path_info[0][0]
         self.chunk = self.ui.window.getTableChunk(col)
         if self.chunk == None:
             error("Can't get chunk")
             return
+
+        is_format_chunk = issubclass(self.chunk.__class__, FormatChunk)
+        self.new_chunk.set_sensitive(is_format_chunk)
+        self.new_filter.set_sensitive(is_format_chunk)
+        self.convert_to_filter.set_sensitive(is_format_chunk)
+        self.set_format.set_sensitive(is_format_chunk)
+
+        can_delete = (self.chunk.getParent().getParent() != None)
+        if not can_delete:
+            chunks = self.chunk.getParent().getChunks()
+            can_delete = (chunks.index(self.chunk) < len(chunks)-1) or not is_format_chunk
+
+        self.delete_chunk.set_sensitive(can_delete)
         self.popup.popup( None, None, None, event.button, event.time)
 
     def onDeleteChunk(self, event):
         self.chunk.getParent().deleteChunk(self.chunk)
 
     def onConvertToFilter(self, event):
-        if not issubclass(self.chunk.__class__, FormatChunk):
-            print "Only works on format chunk"
+        assert issubclass(self.chunk.__class__, FormatChunk)
         self.chunk.getParent().convertChunkToFilter(self.chunk)
         
     def onNewChunk(self, event):
-        if self.new_chunk.runNewChunk() == gtk.RESPONSE_CANCEL: return
-        assert issubclass(self.chunk.__class__, FormatChunk) and self.chunk.isString()
-        format = self.new_chunk.getFormat()
-        id = self.new_chunk.getId()
-        desc = self.new_chunk.getDescription()
+        if self.new_chunk_dlg.runNewChunk() == gtk.RESPONSE_CANCEL: return
+        assert issubclass(self.chunk.__class__, FormatChunk)
+        format = self.new_chunk_dlg.getFormat()
+        id = self.new_chunk_dlg.getId()
+        desc = self.new_chunk_dlg.getDescription()
         self.chunk.setFormat(format, "split", id, desc)
         self.chunk.getParent().redisplay()
 
     def onNewFilter(self, event):
-        if self.new_chunk.runNewChunk() == gtk.RESPONSE_CANCEL: return
+        if self.new_chunk_dlg.runNewChunk() == gtk.RESPONSE_CANCEL: return
         assert issubclass(self.chunk.__class__, FormatChunk) and self.chunk.isString()
-        format = self.new_chunk.getFormat()
+        format = self.new_chunk_dlg.getFormat()
         split_format = splitFormat(format)
         size = split_format[1]
-        id = self.new_chunk.getId()
-        desc = self.new_chunk.getDescription()
+        id = self.new_chunk_dlg.getId()
+        desc = self.new_chunk_dlg.getDescription()
         self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
 
     def onSetFormat(self, event):
-        if issubclass(self.chunk.__class__, FormatChunk):
-            if self.new_chunk.runSetFormat(self.chunk) == gtk.RESPONSE_CANCEL: return
-            format = self.new_chunk.getFormat()
-            self.chunk.id = self.new_chunk.getId()
-            self.chunk.description = self.new_chunk.getDescription()
-            try:
-                self.chunk.setFormat(format, "rescan")
-            except Exception, msg:
-                error("Exception while trying to set chunk %s format to \"%s\"." \
-                    % (self.chunk.id, format))
-                pass
-            self.chunk.getParent().redisplay()
-        else:
-            error("Can't set format of chunk of type %s" % self.chunk.__class__)
+        assert issubclass(self.chunk.__class__, FormatChunk)
+        if self.new_chunk_dlg.runSetFormat(self.chunk) == gtk.RESPONSE_CANCEL: return
+        format = self.new_chunk_dlg.getFormat()
+        self.chunk.id = self.new_chunk_dlg.getId()
+        self.chunk.description = self.new_chunk_dlg.getDescription()
+        try:
+            self.chunk.setFormat(format, "rescan")
+        except Exception, msg:
+            error("Exception while trying to set chunk %s format to \"%s\"." \
+                % (self.chunk.id, format))
+            pass
+        self.chunk.getParent().redisplay()

Modified: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/ui_window.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -22,7 +22,7 @@
         xml.signal_autoconnect(self)
         self.window.connect("key-press-event", self.onKeyUp)
         self.table.connect("button_press_event", self.on_treeview_button_press_event)
-        self.window.set_size_request(760,300)
+        self.window.set_size_request(760,500)
         self.build_table()
         
     def updateToolbar(self):

Modified: haypo/hachoir/user_filter.py
===================================================================
--- haypo/hachoir/user_filter.py	2005-11-01 03:20:25 UTC (rev 243)
+++ haypo/hachoir/user_filter.py	2005-11-01 23:30:00 UTC (rev 244)
@@ -1,5 +1,5 @@
 from filter import Filter
-from chunk import ArrayChunk, FilterChunk
+from chunk import FilterChunk
 from xml.dom.minidom import getDOMImplementation, parse
 from program import VERSION
 from xml.dom.ext import PrettyPrint
@@ -103,7 +103,8 @@
 
     def __createFromChunks(self, chunks):
         for chunk in chunks:
-            if issubclass(chunk.__class__, ArrayChunk):
+            if False: #issubclass(chunk.__class__, ArrayChunk):
+                # TODO: Fix ArrayFilter
                 self.__createFromChunks(chunk)
             else:
                 if issubclass(chunk.__class__, FilterChunk):



From haypo at berlios.de  Wed Nov  2 04:21:14 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 2 Nov 2005 04:21:14 +0100
Subject: [Happyboom-svn] r245 - in haypo/hachoir: . plugins
Message-ID: <200511020321.jA23LEYg004066@sheep.berlios.de>

Author: haypo
Date: 2005-11-02 04:21:07 +0100 (Wed, 02 Nov 2005)
New Revision: 245

Added:
   haypo/hachoir/export.template
   haypo/hachoir/plugins/gzip.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui_popup.py
   haypo/hachoir/ui_window.py
   haypo/hachoir/user_filter.py
Log:
New features :
- Export a filter to python script
- Load a python script when loading
- Each chunk can have it's post-process code (used to display)


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/chunk.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -1,9 +1,9 @@
 import struct
 import re
 import types
-import string
-from format import checkFormat
+from format import checkFormat, splitFormat
 from error import error
+from tools import convertDataToPrintableString
 
 class Chunk(object):
     def __init__(self, id, description, stream, addr, size, parent):
@@ -13,25 +13,35 @@
         self._addr = addr
         self._parent = parent
         self._stream = stream
+        self.post_process = None
+        self.display = None
 
+    def postProcess(self):        
+        if self.post_process != None:
+            self.display = self.post_process(self)
+
+    def getFormat(self):
+        return self.__class__
+
     def update(self):
-        raise Exception("Chunk of type %s doesn't implement the method update()!" % self.__class__)
+        self.display = None
+        self.postProcess()
 
     def __str__(self):
         return "Chunk(%s) <addr=%s, size=%s, id=%s, description=%s>" % \
             (self.__class__, self._addr, self.size, self.id, self.description)
         
-    def getRawData(self, max_size=None):
-        return None
-        
     def getStream(self):
         return self._stream
 
-    def getData(self, max_size=None):
+    def getValue(self, max_size=None):
         return None
 
     def getDisplayData(self):
-        return self.getData()
+        if self.display != None:
+            return self.display
+        else:
+            return self.getValue()
 
     def setParent(self, parent):
         self._parent = parent
@@ -47,17 +57,25 @@
     addr = property(_getAddr, _setAddr)        
     size = property(_getSize)        
     id = property(__getId, __setId)
+    value = property(getValue)
     
 class FilterChunk(Chunk):
     def __init__(self, id, filter, parent):
         Chunk.__init__(self, id, filter.getDescription(), filter.getStream(), filter.getAddr(), filter.getSize(), parent)
         self._filter = filter
         self._filter.filter_chunk = self
+    
+    def postProcess(self):        
+        self._filter.postProcess()
 
+    def getFormat(self):
+        return self._filter.getId()
+
     def update(self):
         new = self._filter.clone()
-        if new == None: return
-        self.setFilter(new)
+        if new != None:
+            self.setFilter(new)
+        Chunk.update(self)
 
     def setFilter(self, filter):
         self._filter = filter
@@ -75,34 +93,116 @@
     def getDisplayData(self):
         return "(...)" 
         
-    def getData(self, max_size=None):
+    def getValue(self, max_size=None):
         return self._filter
+    value = property(getValue)
 
     def getFilter(self):
         return self._filter
 
+class StringChunk(Chunk):
+    def __init__(self, id, description, stream, str_type, parent):
+        Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
+        self._str_type = str_type
+        self._read()
+
+    def getFormat(self):
+        return "c-string"
+
+    def _read(self):
+#        if self._str_type == "C": ...
+        self._stream.seek(self.addr)
+        self._size = self._stream.searchLength("\0", True)
+        assert self._size != -1
+        self.str = self._stream.getN(self._size-1)
+
+    def update(self):
+        Chunk.update(self)
+        self._read()
+
+    def getValue(self, max_size=None):
+        return self.str
+    value = property(getValue)
+
+    def getDisplayData(self):
+        return convertDataToPrintableString(self.str)
+        
+class FormatChunkCache:
+    def __init__(self, chunk):
+        self._value = {}
+        self._addr = None
+        self._format = None
+        self._size = None
+        self._chunk = chunk
+        
+    def _isArray(self, format):
+        if self._chunk.isString(): return False
+        endian, size, type = splitFormat(format)
+        return (size != "1" and size != "")
+
+    def _getRawData(self, max_size=None):
+        stream = self._chunk.getStream()
+        stream.seek(self._addr)
+        if (max_size == None or self._size<max_size) or not self._chunk.isString():
+            data = stream.getN(self._size)
+            return data, False
+        else:
+            data = stream.getN(max_size)
+            return data+"(...)", True
+
+    def update(self):
+        real_format = self._chunk.getRealFormat(self._chunk.getFormat())
+        if self._addr != self._chunk.addr or self._format != real_format:
+            # Invalidate the cache
+            self._value = {}
+            self._format = real_format
+            self._addr = self._chunk.addr
+            self._size = struct.calcsize(self._format)
+
+    def getSize(self):
+        self.update()
+        return self._size
+
+    def getValue(self, max_size=None):
+        self.update()
+        if max_size not in self._value:
+            data, truncated = self._getRawData(max_size)
+            if not truncated:
+                data = struct.unpack(self._format, data)
+                if not self._isArray(self._format):
+                    data = data[0]
+            self._value[max_size] = data               
+        return self._value[max_size]
+
 class FormatChunk(Chunk):
     def __init__(self, id, description, stream, addr, format, parent):
         Chunk.__init__(self, id, description, stream, addr, 0, parent)
-        self.__stream = stream
-        self.__addr = addr
+        if not checkFormat(format):
+            raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
         self.__format = format
-        self.value = None
+        self._cache = FormatChunkCache(self)
 
-    def update(self):
-        # Don't need to do anything
-        pass
+    def getFormat(self):
+        return self.__format
 
     def _getSize(self):
-        return struct.calcsize(self.getRealFormat())
+        return self._cache.getSize()
     size = property(_getSize)        
 
-    def __replaceFormatSize(self, format):
+    def getRealFormat(self, format):
         return re.sub(r'\{([^}]+)\}', self.__replaceFieldFormat, format)
 
-    def getRealFormat(self):
-        return self.__replaceFormatSize(self.__format)
+    def isString(self):
+        return self.__format[-1] == "s"
 
+    def __replaceFieldFormat(self, match):
+        id = match.group(1)
+        if id == "@end@":
+            size = self._stream.getLastPos() - self.addr + 1
+        else:
+            size = getattr(self._parent, id)
+        return str(size)
+
     def getFormat(self): return self.__format
     
     def convertToStringSize(self, size):
@@ -118,8 +218,8 @@
             raise Exception("Invalid FormatChunk format: \"%s\"!" % format)
         
         # Check new size
-        size = struct.calcsize(self.__replaceFormatSize(format))
-        if self.__stream.getLastPos() < self.addr + size:
+        size = struct.calcsize(self.getRealFormat(format))
+        if self._stream.getLastPos() < self.addr + size:
             raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
 
         # Update format
@@ -144,65 +244,16 @@
             else:
                 self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description)
         self._parent.updateFormatChunk(self)
-
-    def isArray(self):
-        if self.isString(): return False
-        m = re.compile("^.?([0-9]+)[^0-9]+$").match(self.__format)
-        if m == None: return False
-        return m.group(1) != "1"
-        
-    def isString(self):
-        return self.__format[-1] == "s"
-
-    def getRawData(self, max_size=None):
-        """ max_size can be None """
-        self.__stream.seek(self.addr)
-        if (max_size == None or self.size<max_size) or not self.isString():
-            data = self.__stream.getN(self.size)
-            return data, False
-        else:
-            data = self.__stream.getN(max_size)
-            return data+"(...)", True
-
-    def __replaceFieldFormat(self, match):
-#        return str(getattr(self, match.group(1)))
-        id = match.group(1)
-        if id == "@end@":
-            size = self.__stream.getLastPos() - self.addr + 1
-        else:
-            size = getattr(self._parent, id)
-        return str(size)
    
-    def getData(self, max_size=None):
-        data, truncated = self.getRawData(max_size)
-        if not truncated:
-            format = self.getRealFormat()
-            data = struct.unpack(format, data)
-            if not self.isArray():
-                data = data[0]
-        return data
+    def getValue(self, max_size=None):
+        return self._cache.getValue(max_size)
+    value = property(getValue)
 
     def getDisplayData(self):
-#        if self.id == None: return "-"
-        data = self.getData(20)
+        if self.display != None:
+            return self.display
+        data = self.getValue(20)
         if type(data)==types.StringType:
-            if len(data) == 0:
-                return "(empty)"
-            display = ""
-            for c in data:
-                if ord(c)<32:
-                    know = { \
-                        "\n": "\\n",
-                        "\r": "\\r",
-                        "\t": "\\t",
-                        "\0": "\\0"}
-                    if c in know:
-                        display = display + know[c]
-                    else:
-                        display = display + "\\x%02X" % ord(c)
-                elif c in string.printable:
-                    display = display + c
-                else:
-                    display = display + "."
-            return "\"%s\"" % display
-        return data 
+            return convertDataToPrintableString(data)
+        else:
+            return data 

Added: haypo/hachoir/export.template
===================================================================
--- haypo/hachoir/export.template	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/export.template	2005-11-02 03:21:07 UTC (rev 245)
@@ -0,0 +1,13 @@
+"""
+Exported filter.
+
+Description:
+{description}
+"""
+
+from filter import Filter
+
+class MyFilter(Filter):
+    def __init__(self, stream):
+        Filter.__init__(self, "{id}", "{description}", stream, None)
+{chunks}

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/filter.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -7,7 +7,7 @@
 import string
 import types
 import ui
-from chunk import Chunk, FormatChunk, FilterChunk
+from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
 from format import splitFormat    
 from error import error
 from tools import getBacktrace
@@ -117,7 +117,7 @@
         else:
             prev_chunk = None
         
-        if False: #prev_chunk != None and 1<len(self._chunks) and issubclass(prev_chunk.__class__, FormatChunk):
+        if prev_chunk != None and issubclass(prev_chunk.__class__, FormatChunk):
             # If last chunk is a FormatChunk, update it's size
             format = splitFormat(prev_chunk.getFormat())
             if self.getParent() == None:
@@ -215,11 +215,7 @@
         return chunk
 
     def displayChunk(self, chunk):
-        type = chunk.__class__
-        if issubclass(type, FormatChunk):
-            type = chunk.getFormat()
-        elif issubclass(type, FilterChunk):
-            type = chunk.getFilter().getId()
+        type = chunk.getFormat()
         ui.window.add_table(None, chunk.addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
 
     def redisplay(self):  
@@ -259,13 +255,13 @@
 
     def readLine(self, id, description, eol="\n", fails_if_not_found=False, can_truncate=False):
         lg = self.searchEol(eol)
-        self.read(id, "!%us" % lg, description, can_truncate)
+        self.read(id, "!%us" % lg, description, truncate=can_truncate)
         line = getattr(self, id)
         setattr(self, id, line[:-len(eol)])
 
     def updateFormatChunk(self, chunk):
         if chunk.id == None: return
-        data = chunk.getData()
+        data = chunk.getValue()
         setattr(self, chunk.id, data)       
 
     def _appendChunk(self, chunk, can_truncate=False, position=None):
@@ -292,14 +288,14 @@
             if hasattr(self, id):
                 raise Exception("Chunk identifier \"%s\" already exist!" % id)
             if can_truncate:
-                data = chunk.getData(40)
+                data = chunk.getValue(40)
             else:
-                data = chunk.getData()
+                data = chunk.getValue()
             setattr(self, id, data)
             self._chunks_dict[id] = chunk
 
-    def readChild(self, id, filter_class, description): 
-        filter = filter_class(self._stream, self)
+    def readChild(self, id, filter_class, description, *args): 
+        filter = filter_class(self._stream, self, *args)
         self.addFilter(id, filter)
     
     def addFilter(self, id, filter): 
@@ -312,14 +308,25 @@
         filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
         self.addFilter(id, filter)
     
-    def read(self, id, format, description, can_truncate=True):
+    def readString(self, id, format, description):
         """ Returns chunk """
+        chunk = StringChunk(id, description, self._stream, format, self)
+        self._appendChunk(chunk)
+        self._stream.seek(chunk.addr + chunk.size)
+        return chunk
+    
+    def read(self, id, format, description, post=None, truncate=False):
+        """ Returns chunk """
         chunk = FormatChunk(id, description, self._stream, self._stream.tell(), format, self)
-        self._stream.seek(chunk.size, 1)
-        self._appendChunk(chunk, can_truncate)
+        self._appendChunk(chunk, can_truncate=truncate)
         self._stream.seek(chunk.addr + chunk.size)
+        chunk.post_process = post
         return chunk
 
+    def postProcess(self):
+        for chunk in self._chunks:
+            chunk.postProcess()
+
     def __str__(self):
         return "Filter(%s) <id=%s, description=%s>" % \
             (self.__class__, self.getId(), self.getDescription())
@@ -328,6 +335,26 @@
         chunk.setFormat("!%ss" % size, "split", id, desc)
         self.convertChunkToFilter(chunk)
 
+    def convertFilterToChunk(self, chunk):
+        # Create new format chunk
+        filter = chunk.getFilter()
+        id = self.getUniqChunkId(filter.getId())
+        new_chunk = FormatChunk(id, filter.getDescription(), filter.getStream(), filter.getAddr(), "!%us" % filter.getSize(), self)
+
+        # Delete old chunk
+        if chunk.id in self._chunks_dict:
+            del self._chunks_dict[chunk.id]
+        if hasattr(self, chunk.id):
+            delattr(self, chunk.id)
+
+        # Assign new chunk
+        pos = self._chunks.index(chunk)
+        self._chunks[pos] = new_chunk
+        self._chunks_dict[id] = new_chunk
+        setattr(self, id, chunk.getValue(40))
+        self.redisplay()
+        return new_chunk 
+
     def convertChunkToFilter(self, chunk):
         # Create new filter
         stream = self.getStream()

Modified: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/hachoir.glade	2005-11-02 03:21:07 UTC (rev 245)
@@ -198,6 +198,22 @@
 		  <property name="homogeneous">True</property>
 		</packing>
 	      </child>
+
+	      <child>
+		<widget class="GtkToolButton" id="toolbutton_export">
+		  <property name="visible">True</property>
+		  <property name="tooltip" translatable="yes">Export current filter to python script</property>
+		  <property name="stock_id">gtk-convert</property>
+		  <property name="visible_horizontal">True</property>
+		  <property name="visible_vertical">True</property>
+		  <property name="is_important">False</property>
+		  <signal name="clicked" handler="on_toolbutton_export" last_modification_time="Wed, 02 Nov 2005 00:47:19 GMT"/>
+		</widget>
+		<packing>
+		  <property name="expand">False</property>
+		  <property name="homogeneous">True</property>
+		</packing>
+	      </child>
 	    </widget>
 	  </child>
 	</widget>
@@ -263,7 +279,7 @@
       <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image32">
+	<widget class="GtkImage" id="image40">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -284,7 +300,7 @@
       <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image33">
+	<widget class="GtkImage" id="image41">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -298,14 +314,14 @@
   </child>
 
   <child>
-    <widget class="GtkImageMenuItem" id="convert_to_filter">
+    <widget class="GtkImageMenuItem" id="convert">
       <property name="visible">True</property>
-      <property name="label" translatable="yes">_Convert string chunk to filter</property>
+      <property name="label" translatable="yes">_Convert chunk &lt;=&gt; filter</property>
       <property name="use_underline">True</property>
-      <signal name="activate" handler="onConvertToFilter" last_modification_time="Tue, 01 Nov 2005 01:30:56 GMT"/>
+      <signal name="activate" handler="onConvert" last_modification_time="Wed, 02 Nov 2005 02:32:16 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image34">
+	<widget class="GtkImage" id="image42">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-convert</property>
 	  <property name="icon_size">1</property>
@@ -326,7 +342,7 @@
       <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image35">
+	<widget class="GtkImage" id="image43">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-edit</property>
 	  <property name="icon_size">1</property>
@@ -347,7 +363,7 @@
       <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image36">
+	<widget class="GtkImage" id="image44">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-delete</property>
 	  <property name="icon_size">1</property>

Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/hachoir.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -19,11 +19,10 @@
     print "Usage: %s [options] file" % (sys.argv[0])
     print ""
     print "Options:"
-    print "\t--help            : Show this help"
+    print "\t--script file.py  : Load python script"
     print "\t--version         : Show the program version"
     print "\t--verbose         : Activate verbose mode"
-    print "\t--depth NB        : Detail depth (default %u)" % (defval["depth"])
-    print "\t--no-display      : Hide result"
+    print "\t--help            : Show this help"
 
 def parseArgs(val):
     import getopt
@@ -31,7 +30,7 @@
     
     try:
         short = ""
-        long = ["no-display", "verbose", "help", "version", "depth="]
+        long = ["verbose", "help", "version", "script="]
         opts, args = getopt.getopt(sys.argv[1:], short, long)
     except getopt.GetoptError:
         usage(def_val)
@@ -52,10 +51,8 @@
         if o == "--version":
             print "%s version %s" % (PROGRAM, VERSION)
             sys.exit()
-        if o == "--no-display":
-            val["display"] = False
-        if o == "--depth":
-            val["depth"] = int(a)
+        if o == "--script":
+            val["script"] = a
         if o == "--verbose":
             val["verbose"] = True
     return (val, filename,)
@@ -76,9 +73,8 @@
         log.info("Loaded: %u plugings (%s)" % (len(modules), ", ".join(modules)))
 
         opt = {
-            "depth": 2,
             "verbose": False,
-            "display": True
+            "script": None
         }
         opt, filename = parseArgs(opt)
 

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/hachoir_class.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -6,12 +6,16 @@
 from error import error
 
 class Hachoir:
+    instance = None
+    
     def __init__(self):
+        Hachoir.instance = self
         self.verbose = False
         self.display = True
         self.depth = 5
         self.ui = None 
         self.main_filter = None
+        self.script = None
 
     def onGoParent(self):
         if self.filter.getParent() == None: return
@@ -39,7 +43,6 @@
             chunk = old_filter.filter_chunk
             chunk.setFilter(self.filter)
             diff_size = self.filter.getSize() - old_size
-            print "Diff size = %s" % diff_size
             chunk.getParent().rescan(chunk, diff_size)
         self.filter.display()
         self.ui.window.updateToolbar()
@@ -47,6 +50,10 @@
     def saveUser(self, filename):
         my = UserFilterDescriptor(filter=self.filter)
         my.writeIntoXML(filename)
+    
+    def exportUser(self, filename):
+        my = UserFilterDescriptor(filter=self.filter)
+        my.exportPython(filename)
         
     def load(self, filename):
         try:
@@ -65,6 +72,16 @@
         # Split 
         try:
             filter = split_func(stream)
+            filter.postProcess()
+            size = filter.getSize()
+            diff_size = (size - stream.getSize())
+            if diff_size < 0:
+                chunks = filter.getChunks()
+                if len(chunks) != 0:
+                    last_chunk = chunks[-1]
+                else:
+                    last_chunk = None
+                filter.addRawChunk(last_chunk, "end", "{@end@}", "")
         except Exception, msg:
             error("Exception while processing file %s with filter %s:\n%s" \
                 % (filename, plugin_name, msg))
@@ -74,11 +91,23 @@
         self.filter.display()
 
         # Display
-        if self.display:
+        if self.display and display_func != None:
             display_func(self.filter)
         self.ui.window.updateToolbar()
 
+    def loadScript(self, filename):
+        try:
+            f = open(self.script, 'r')
+            script = f.read()
+            f.close()
+            compiled = compile(script, self.script, 'exec')
+            exec compiled
+        except Exception, msg:
+            error("Exception while loading script \"%s\":\n%s" % (filename, msg))
+
     def run(self, filename):
-        if filename != None:
+        if self.script:
+            self.loadScript(self.script)
+        elif filename != None:
             self.load(filename)
         self.ui.run()      

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/plugins/gif.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -1,7 +1,7 @@
 """
 GIF splitter.
 
-Status: only loads header, and is buggy ...
+Status: loads header, don't load image data (stop filter), and is buggy ...
 Author: Victor Stinner
 """
 
@@ -60,13 +60,13 @@
             assert issubclass(parent.__class__, GifFile)
             screen = parent.getChunk("screen").getFilter()
             self._nb_colors = (1 << screen.bits_per_pixel)
-        self.readArray("map", GifColor, "Color map", self.checkEndOfMap)
+        self.readArray("color", GifColor, "Color map", self.checkEndOfMap)
 
     def checkEndOfMap(self, stream, array, color):
         return len(array) == self._nb_colors 
 
     def __str__(self):
-        return "Gif colormap <colors=%u>" % (len(self.map))
+        return "Gif colormap <colors=%u>" % (len(self.color))
         
 class GifExtensionChunk(Filter):
     def __init__(self, stream, parent):
@@ -91,14 +91,22 @@
         self.read("height", "<H", "Height")
 
         # TODO: Fix this
-        self.read("flags", "<B", "Flags")
-        self.global_map = ((self.flags & 0x80) == 0x80) # ok
-        self.color_res = 1 + ((self.flags >> 4) & 0x7) # ??
-        self.bits_per_pixel = 1 + (self.flags & 0x7) # ok
+        self.read("flags", "<B", "Flags", post=processFlags)
         # -- End of TODO
         
         self.read("background", "<B", "Background color")
         self.read("notused", "<B", "Not used (zero)")
+
+    def processFlags(self, chunk):
+        flags = chunk.value
+        self.global_map = ((flags & 0x80) == 0x80) # ok
+        self.color_res = 1 + ((flags >> 4) & 0x7) # ??
+        self.bits_per_pixel = 1 + (flags & 0x7) # ok
+        if self.global_map:
+            text = "global map, "
+        else:
+            text = ""
+        return text + "color res=%u, bits/pixel=%u" % (self.color_res, self.bits_per_pixel)
         
 class GifFile(Filter):
     def __init__(self, stream):
@@ -116,7 +124,7 @@
         self.images = []
         while True:
             code = self.read("separator[]", "c", "Separator code")
-            code = code.getData()
+            code = code.getValue()
             if code == "!":
                 self.readChild("extensions[]", GifExtension, "Extension")
             elif code == ",":

Added: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/plugins/gzip.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -0,0 +1,77 @@
+"""
+Exported filter.
+
+Description:
+GZIP archive file
+"""
+
+import datetime
+from filter import Filter
+from plugin import registerPlugin
+
+class GzipFile(Filter):
+    def __init__(self, stream):
+        Filter.__init__(self, "gzip_file", "GZIP archive file", stream, None)
+        self.read("id", "!2B", "Identifier (31,139)")
+        assert self.id == (31, 139)
+        self.read("comp_method", "!B", "Compression method", post=self.getCompressionMethod)
+        self.read("flags", "!B", "Flags", post=self.getFlags)
+        self.read("mtime", "<1L", "Modification time", post=self.getMTime)
+        self.read("extra", "!B", "Extra flags")
+        self.read("os", "!B", "OS", post=self.getOS)
+
+        if self.extra & 4 == 4:
+            self.read("extra_length", "<2H", "Extra length")
+            self.read("extra", "!{extra_length}s", "Extra")
+        if self.flags & 8 == 8:
+            self.readString("filename", "C", "Filename")
+        if self.flags & 16 == 16:
+            self.readString("comment", "C", "Comment")
+        if self.flags & 2 == 2:
+            self.readString("crc16", "!H", "CRC16")
+
+        size = stream.getSize() - stream.tell() - 8
+        self.read("data", "!%us" % size, "Compressed data", truncate=True)
+        self.read("crc32", "<L", "CRC32")
+        self.read("size", "<L", "Uncompressed size")
+
+    def getFlags(self, chunk):
+        val = chunk.value
+        flags = []
+        if val & 1 == 1: flags.append("text")
+        if val & 2 == 2: flags.append("crc16")
+        if val & 4 == 4: flags.append("extra")
+        if val & 8 == 8: flags.append("filename")
+        if val & 16 == 16: flags.append("comment")
+        return "|".join(flags)
+        
+    def getCompressionMethod(self, chunk):
+        val = chunk.value
+        if val < 8: return "reserved"
+        if val == 8: return "deflate"
+        return "Unknow (%s)" % val
+
+    def getMTime(self, chunk):
+        dt = datetime.datetime.fromtimestamp(chunk.value)
+        return str(dt)
+
+    def getOS(self, chunk):
+        os = { \
+            0: "FAT filesystem",
+            1: "Amiga",
+            2: "VMS (or OpenVMS)",
+            3: "Unix",
+            4: "VM/CMS",
+            5: "Atari TOS",
+            6: "HPFS filesystem (OS/2, NT)",
+            7: "Macintosh",
+            8: "Z-System",
+            9: "CP/M",
+            10: "TOPS-20",
+            11: "NTFS filesystem (NT)",
+            12: "QDOS",
+            13: "Acorn RISCOS"}            
+        val = chunk.value
+        return os.get(val, "Unknow (%s)" % val)
+        
+registerPlugin("^.*\.gz$", "GZIP archive file", GzipFile, None)

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/plugins/png.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -51,26 +51,19 @@
 class PngGamma(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "png_gamma", "PNG gamma", stream, parent)
-        self.read("gamma", "!L", "Gamma (x10,000)")
-        self.gamma = float(self.gamma)
-        self.gamma = self.gamma / 10000
+        self.read("gamma", "!L", "Gamma (x10,000)", post=self.getGamma)
 
+    def getGamma(self, chunk):
+        return float(chunk.value) / 10000
+
     def __str__(self):
         return "PNG gamma <gamma=%0.2f>" % (self.gamma)
 
 class PngText(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "png_text", "PNG text", stream, parent)
-        max_length = parent.size
-        print "max",max_length
-        old = self._stream.tell()
-        pos = self._stream.search("\0", max_length)
-        if pos == -1:
-            raise Exception("Fails to find end of text")
-        lg = (pos-old)
-        self.read("keyword", "!%us" % lg, "Keyword")
-        self.read("separator", "!B", "Null byte used to separe strings")
-        lg = (self._parent.size-lg-1)
+        chunk = self.readString("keyword", "C", "Keyword")
+        lg = self._parent.size - chunk.size
         self.read("text", "!%us" % lg, "Text")
 
     def __str__(self):

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/plugins/tar.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -9,6 +9,7 @@
 from datetime import datetime
 from filter import Filter
 from plugin import registerPlugin
+from tools import convertDataToPrintableString
 
 def displayModeItem(mode):
     if mode & 4 == 4: r="r"
@@ -42,38 +43,60 @@
         displayFile(file)
 
 class TarFileEntry(Filter):
+    def stripNul(self, chunk):
+        return chunk.value.strip("\0")
+
+    def getMode(self, chunk):
+        mode = self.octal2int(chunk.value)
+        owner = self._getModeItem(mode >> 6 & 7)
+        group = self._getModeItem(mode >> 3 & 7)
+        other = self._getModeItem(mode & 7)
+        return "%04o (%s%s%s)" % (mode, owner, group, other)
+
+    def _getModeItem(mode):
+        if mode & 4 == 4: r="r"
+        else: r="-"
+        if mode & 2 == 2: w="w"
+        else: w="-"
+        if mode & 1 == 1: x="x"
+        else: x="-"
+        return "%c%c%c" % (r, w, x) 
+
+    def convertOctal(self, chunk):
+        return self.octal2int(chunk.value)
+
+    def stripNul(self, chunk):
+        val = chunk.value.strip("\0")
+        return convertDataToPrintableString(val)
+
+    def getTime(self, chunk):
+        value = self.octal2int(chunk.value) 
+        return datetime.fromtimestamp(value)
+
     def __init__(self, stream, parent):
         Filter.__init__(self, "tar_file_entry","Tar file entry", stream, parent)
-        self.read("name", "!100s", "Name", False)
+        self.read("name", "!100s", "Name", truncate=False, post=self.stripNul)
         self.name = self.name.strip("\0")
-        self.read("mode", "!8s", "Mode")
-        self.mode = self.octal2int(self.mode)
-        self.read("uid", "!8s", "User ID")
-        self.uid = self.octal2int(self.uid)
-        self.read("gid", "!8s", "Group ID")
-        self.gid = self.octal2int(self.gid)
-        self.read("size", "!12s", "Size")
+        self.read("mode", "!8s", "Mode", post=self.convertOctal)
+        self.read("uid", "!8s", "User ID", post=self.convertOctal)
+        self.read("gid", "!8s", "Group ID", post=self.convertOctal)
+        self.read("size", "!12s", "Size", post=self.convertOctal)
         self.size = self.octal2int(self.size)
-        self.read("mtime", "!12s", "Modification time")
-        self.mtime = self.octal2int(self.mtime) 
-        self.mtime = datetime.fromtimestamp(self.mtime)
+        self.read("mtime", "!12s", "Modification time", self.getTime)
         self.read("check_sum", "!8s", "Check sum")
         self.read("type", "!c", "Type")
-        self.read("lname", "!100s", "Link name", False)
-        self.read("magic", "!8s", "Magic")
-        self.magic = self.magic.strip(" \0")
-        self.read("uname", "!32s", "User name")
-        self.uname = self.uname.strip("\0")
-        self.read("gname", "!32s", "Group name")
-        self.gname = self.gname.strip("\0")
+        self.read("lname", "!100s", "Link name", post=self.stripNul, truncate=False)
+        self.read("magic", "!8s", "Magic", post=self.stripNul)
+        self.read("uname", "!32s", "User name", post=self.stripNul)
+        self.read("gname", "!32s", "Group name", post=self.stripNul)
         self.read("devmajor", "!8s", "Dev major")
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
-            self.read("filedata", "!{size}s", "File data", True)
+            self.read("filedata", "!{size}s", "File data", truncate=True)
         if stream.tell() % 512 != 0:
             padding = 512 - stream.tell() % 512
-            self.read("padding", "!%ss" % padding, "Padding (512 align)")
+            self.read("padding", "!%ss" % padding, "Padding (512 align)", truncate=True)
 
     def isEmpty(self):
         return self.name == ""
@@ -115,14 +138,13 @@
 
         self.readArray("files", TarFileEntry, "Tar Files", self.checkEndOfChunks)
         
-        padding = 4096 - stream.tell() % 4096
-        self.read("padding", "!%ss" % padding, "Padding (4096 align)")
+#        padding = 4096 - stream.tell() % 4096
+#        self.read("padding", "!%ss" % padding, "Padding (4096 align)")
+#        assert stream.eof()
 
-        assert stream.eof()
-
     def checkEndOfChunks(self, stream, array, file):
         if file != None:
             if file.isEmpty(): return True
         return stream.eof()
         
-registerPlugin("^.*\.tar$", "Tar archive", TarFile, displayTar)
+registerPlugin("^.*\.tar$", "Tar archive", TarFile, None)

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/plugins/zip.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -99,7 +99,7 @@
         self.files = []
         while not stream.eof():
             header = self.read("header[]", "<L", "Header")
-            header = header.getData()
+            header = header.getValue()
             if header == 0x04034B50:
                 self.readChild("files[]", ZipFileEntry, "File entry")
             elif header == 0x02014b50:

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/tools.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -1,5 +1,27 @@
 import traceback, sys
+import string
 
+def convertDataToPrintableString(data):
+    if len(data) == 0:
+        return "(empty)"
+    display = ""
+    for c in data:
+        if ord(c)<32:
+            know = { \
+                "\n": "\\n",
+                "\r": "\\r",
+                "\t": "\\t",
+                "\0": "\\0"}
+            if c in know:
+                display = display + know[c]
+            else:
+                display = display + "\\x%02X" % ord(c)
+        elif c in string.printable:
+            display = display + c
+        else:
+            display = display + "."
+    return "\"%s\"" % display
+
 def getBacktrace():
     bt = traceback.format_exception( \
         sys.exc_type, sys.exc_value, sys.exc_traceback)

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/ui_popup.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -2,7 +2,7 @@
 pygtk.require ('2.0')
 import gtk
 import gtk.glade
-from chunk import FormatChunk
+from chunk import FormatChunk, FilterChunk
 from ui_new_chunk import NewChunkDialog
 from format import splitFormat # TODO: remove this line
 from error import error
@@ -19,7 +19,7 @@
         # Popup items
         self.new_chunk = xml.get_widget("new_chunk")
         self.new_filter = xml.get_widget("new_filter")
-        self.convert_to_filter = xml.get_widget("convert_to_filter")
+        self.convert = xml.get_widget("convert")
         self.set_format = xml.get_widget("set_format")
         self.delete_chunk = xml.get_widget("delete_chunk")
 
@@ -31,15 +31,19 @@
             return
 
         is_format_chunk = issubclass(self.chunk.__class__, FormatChunk)
+        is_filter_chunk = issubclass(self.chunk.__class__, FilterChunk)
         self.new_chunk.set_sensitive(is_format_chunk)
         self.new_filter.set_sensitive(is_format_chunk)
-        self.convert_to_filter.set_sensitive(is_format_chunk)
+        self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
         self.set_format.set_sensitive(is_format_chunk)
 
-        can_delete = (self.chunk.getParent().getParent() != None)
-        if not can_delete:
-            chunks = self.chunk.getParent().getChunks()
-            can_delete = (chunks.index(self.chunk) < len(chunks)-1) or not is_format_chunk
+#        can_delete = ()
+#        if not can_delete:
+        chunks = self.chunk.getParent().getChunks()
+        if self.chunk.getParent().getParent() != None:
+            can_delete = (1 < len(chunks)) or not is_format_chunk
+        else:
+            can_delete = chunks.index(self.chunk) < (len(chunks)-1) or not is_format_chunk
 
         self.delete_chunk.set_sensitive(can_delete)
         self.popup.popup( None, None, None, event.button, event.time)
@@ -47,9 +51,13 @@
     def onDeleteChunk(self, event):
         self.chunk.getParent().deleteChunk(self.chunk)
 
-    def onConvertToFilter(self, event):
-        assert issubclass(self.chunk.__class__, FormatChunk)
-        self.chunk.getParent().convertChunkToFilter(self.chunk)
+    def onConvert(self, event):
+        if issubclass(self.chunk.__class__, FormatChunk):
+            self.chunk.getParent().convertChunkToFilter(self.chunk)
+        elif issubclass(self.chunk.__class__, FilterChunk):
+            self.chunk.getParent().convertFilterToChunk(self.chunk)
+        else:
+            error("Can't convert chunk %s" % self.chunk.id)
         
     def onNewChunk(self, event):
         if self.new_chunk_dlg.runNewChunk() == gtk.RESPONSE_CANCEL: return
@@ -79,7 +87,7 @@
         try:
             self.chunk.setFormat(format, "rescan")
         except Exception, msg:
-            error("Exception while trying to set chunk %s format to \"%s\"." \
-                % (self.chunk.id, format))
+            error("Exception while trying to set chunk %s format to \"%s\": %s" \
+                % (self.chunk.id, format, msg))
             pass
         self.chunk.getParent().redisplay()

Modified: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/ui_window.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -134,6 +134,16 @@
             self.ui.hachoir.loadUser(filename)
         chooser.destroy()
 
+    def on_toolbutton_export(self, widget):
+        chooser = gtk.FileChooserDialog( \
+            title="Export current filter to python script ...",
+            action=gtk.FILE_CHOOSER_ACTION_SAVE,
+            buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
+        if chooser.run() == gtk.RESPONSE_OK:
+            filename = chooser.get_filename() 
+            self.ui.hachoir.exportUser(filename)
+        chooser.destroy()
+
     def on_toolbutton_save(self, widget):
         chooser = gtk.FileChooserDialog( \
             title="Save filter into ...",

Modified: haypo/hachoir/user_filter.py
===================================================================
--- haypo/hachoir/user_filter.py	2005-11-01 23:30:00 UTC (rev 244)
+++ haypo/hachoir/user_filter.py	2005-11-02 03:21:07 UTC (rev 245)
@@ -45,6 +45,11 @@
             self.id = None 
             self.description = None 
             
+    def exportPython(self, filename):
+        file = open(filename, "w")
+        file.write(self.toPython())
+        file.close()
+            
     def writeIntoXML(self, filename):
         file = open(filename, "w")
         PrettyPrint(self.toXML(), file)
@@ -74,6 +79,20 @@
                     user_chunk = UserChunk(id, format, description)
                 self.chunks.append(user_chunk)
 
+    def toPython(self):
+        f = open('export.template', 'r')
+        tpl = f.read()
+        f.close()
+
+        chunks = ""
+        for chunk in self.chunks:
+            if chunks != "": chunks = chunks + "\n"
+            chunks = chunks \
+                + " " * 8 \
+                + "self.read(\"%s\", \"%s\", \"%s\")" \
+                  % (chunk.id, chunk.format, chunk.description)
+        return tpl.replace("{id}", self.id).replace("{description}", self.description).replace("{chunks}", chunks)
+
     def toXML(self):
         impl = getDOMImplementation()
         doc = impl.createDocument(None, "user_filter", None)



From haypo at berlios.de  Wed Nov  2 05:26:31 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 2 Nov 2005 05:26:31 +0100
Subject: [Happyboom-svn] r246 - in haypo/hachoir: . plugins
Message-ID: <200511020426.jA24QVwc017844@sheep.berlios.de>

Author: haypo
Date: 2005-11-02 05:26:28 +0100 (Wed, 02 Nov 2005)
New Revision: 246

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/default.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui_window.py
   haypo/hachoir/user_filter.py
Log:
postProcess() is call just after reading a chunk, manage user filter
differently to avoid problem of filter cloning, add padding when loading
new file or user filter and end of file is not reached.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/chunk.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -65,9 +65,6 @@
         self._filter = filter
         self._filter.filter_chunk = self
     
-    def postProcess(self):        
-        self._filter.postProcess()
-
     def getFormat(self):
         return self._filter.getId()
 
@@ -219,7 +216,7 @@
         
         # Check new size
         size = struct.calcsize(self.getRealFormat(format))
-        if self._stream.getLastPos() < self.addr + size:
+        if self._stream.getLastPos() < (self.addr + size - 1):
             raise Exception("Can't set chunk %s to format \"%s\": size too big!" % (self.id, format))
 
         # Update format
@@ -242,7 +239,7 @@
             if method == "split" and diff_size < 0:
                 self._parent.addRawChunk(self, old_id, -diff_size, old_description)
             else:
-                self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description)
+                self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description, truncate=True)
         self._parent.updateFormatChunk(self)
    
     def getValue(self, max_size=None):

Modified: haypo/hachoir/default.py
===================================================================
--- haypo/hachoir/default.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/default.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -6,4 +6,4 @@
 class DefaultFilter(Filter):
     def __init__(self, stream):
         Filter.__init__(self, "default", "Default filter", stream, None)
-        self.read("data", "!{@end@}s", "Data", True)
+        self.read("data", "!{@end@}s", "Data", truncate=True)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/filter.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -57,7 +57,7 @@
         self._deleteChunk(pos)
         # Delete last chunk of a sub filter? It true, truncate the sub filter
         truncate = (self.getParent() != None and pos == len(self._chunks))
-        self.rescanFromPos(pos, -chunk_size, truncate_filter=truncate)
+        self.rescanFromPos(pos, -chunk_size, truncate=truncate)
         self.redisplay()
 
     def getChunks(self):
@@ -100,12 +100,12 @@
         chunk = FormatChunk(id, description, self.getStream(), addr, "!%ss" % size, self)
         self._appendChunk(chunk, can_truncate=True, position=chunk_pos)
 
-    def rescan(self, from_chunk, diff_size, new_id=None, new_description=None):
+    def rescan(self, from_chunk, diff_size, new_id=None, new_description=None, truncate=False):
         if from_chunk != None:
             start = self._chunks.index(from_chunk)+1
         else:
             start = 0
-        self.rescanFromPos(start, diff_size, new_id, new_description)
+        self.rescanFromPos(start, diff_size, new_id, new_description, truncate)
             
     def _rescanUpdateSize(self, diff_size, new_id=None, new_description=None):
         # Only process diff_size < 0
@@ -167,7 +167,7 @@
                 self._deleteChunk(iter)
                 iter = iter - 1
 
-    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate_filter=False):
+    def rescanFromPos(self, start, diff_size, new_id=None, new_description=None, truncate=False):
         assert 0<=start and start <= len(self._chunks)
         if 0<start:
             prev_chunk = self._chunks[start-1]
@@ -180,7 +180,7 @@
         diff_size = diff_size + (self.getSize() - old_size)
 
         # Update last chunk size if needed
-        if not truncate_filter:
+        if not truncate:
             self._rescanUpdateSize(diff_size, new_id, new_description)
             diff_size = 0
                
@@ -261,7 +261,7 @@
 
     def updateFormatChunk(self, chunk):
         if chunk.id == None: return
-        data = chunk.getValue()
+        data = chunk.getValue(40)
         setattr(self, chunk.id, data)       
 
     def _appendChunk(self, chunk, can_truncate=False, position=None):
@@ -296,23 +296,29 @@
 
     def readChild(self, id, filter_class, description, *args): 
         filter = filter_class(self._stream, self, *args)
-        self.addFilter(id, filter)
+        chunk = self.addFilter(id, filter)
+        chunk.postProcess()
+        return chunk
     
     def addFilter(self, id, filter): 
         chunk = FilterChunk(id, filter, self)
         self._appendChunk(chunk)
         filter.updateParent(chunk)
         self._stream.seek(chunk.addr + chunk.size)
+        return chunk
 
     def readArray(self, id, entry_class, description, end_func): 
         filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
-        self.addFilter(id, filter)
+        chunk = self.addFilter(id, filter)
+        chunk.postProcess()
+        return chunk
     
     def readString(self, id, format, description):
         """ Returns chunk """
         chunk = StringChunk(id, description, self._stream, format, self)
         self._appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)
+        chunk.postProcess()
         return chunk
     
     def read(self, id, format, description, post=None, truncate=False):
@@ -321,12 +327,9 @@
         self._appendChunk(chunk, can_truncate=truncate)
         self._stream.seek(chunk.addr + chunk.size)
         chunk.post_process = post
+        chunk.postProcess()
         return chunk
 
-    def postProcess(self):
-        for chunk in self._chunks:
-            chunk.postProcess()
-
     def __str__(self):
         return "Filter(%s) <id=%s, description=%s>" % \
             (self.__class__, self.getId(), self.getDescription())
@@ -399,7 +402,10 @@
 
         for chunk in self._array:
             chunk.getFilter().updateParent(chunk)
-#        self._stream.seek(self.getAddr() + self.getSize())
+        if 1<nb:
+            self.setDescription( "%s (%s items)" % (self.getDescription(), nb))
+        else:
+            self.setDescription( "%s (%s item)" % (self.getDescription(), nb))
 
     def getArray(self):
         return self._array

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/hachoir_class.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -2,7 +2,7 @@
 from plugin import getPlugin
 from chunk import FilterChunk
 from default import DefaultFilter, displayDefault
-from user_filter import UserFilterDescriptor, UserFilter
+from user_filter import UserFilterDescriptor, loadUserFilter
 from error import error
 
 class Hachoir:
@@ -30,15 +30,21 @@
             self.filter.display()
 
     def loadUser(self, filename):
-        old_filter = self.filter
-        old_size = old_filter.getSize()
-        user = UserFilterDescriptor(xml_file=filename)
-        stream = self.filter.getStream()
-        parent = self.filter.getParent()
-        stream.seek(self.filter.getAddr())
-        self.filter = UserFilter(user, stream, parent)
+        try:
+            old_filter = self.filter
+            old_size = old_filter.getSize()
+            user = UserFilterDescriptor(xml_file=filename)
+            stream = self.filter.getStream()
+            parent = self.filter.getParent()
+            stream.seek(self.filter.getAddr())
+            new_filter = loadUserFilter(user, stream, parent)
+        except Exception, err:
+            error("Error while loading user XML filter \"%s\":\n%s" % (filename, err))
+            return
+        self.filter = new_filter           
         if parent == None:
             self.main_filter = self.filter
+            self._addPadding()
         else:
             chunk = old_filter.filter_chunk
             chunk.setFilter(self.filter)
@@ -55,6 +61,17 @@
         my = UserFilterDescriptor(filter=self.filter)
         my.exportPython(filename)
         
+    def _addPadding(self):
+        size = self.filter.getSize()
+        diff_size = (size - self.filter.getStream().getSize())
+        if diff_size < 0:
+            chunks = self.filter.getChunks()
+            if len(chunks) != 0:
+                last_chunk = chunks[-1]
+            else:
+                last_chunk = None
+            self.filter.addRawChunk(last_chunk, "end", "{@end@}", "")
+
     def load(self, filename):
         try:
             stream = FileStream(filename)
@@ -72,22 +89,13 @@
         # Split 
         try:
             filter = split_func(stream)
-            filter.postProcess()
-            size = filter.getSize()
-            diff_size = (size - stream.getSize())
-            if diff_size < 0:
-                chunks = filter.getChunks()
-                if len(chunks) != 0:
-                    last_chunk = chunks[-1]
-                else:
-                    last_chunk = None
-                filter.addRawChunk(last_chunk, "end", "{@end@}", "")
         except Exception, msg:
             error("Exception while processing file %s with filter %s:\n%s" \
                 % (filename, plugin_name, msg))
             raise
             return
         self.main_filter = self.filter = filter
+        self._addPadding()
         self.filter.display()
 
         # Display

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/plugins/gif.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -91,7 +91,7 @@
         self.read("height", "<H", "Height")
 
         # TODO: Fix this
-        self.read("flags", "<B", "Flags", post=processFlags)
+        self.read("flags", "<B", "Flags", post=self.processFlags)
         # -- End of TODO
         
         self.read("background", "<B", "Background color")

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/tools.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -23,6 +23,9 @@
     return "\"%s\"" % display
 
 def getBacktrace():
-    bt = traceback.format_exception( \
-        sys.exc_type, sys.exc_value, sys.exc_traceback)
-    return "".join(bt)
+    try:
+        bt = traceback.format_exception( \
+            sys.exc_type, sys.exc_value, sys.exc_traceback)
+        return "".join(bt)
+    except:
+        return "Error while trying to get backtrace"

Modified: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/ui_window.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -79,7 +79,7 @@
         self.ui.on_row_click(row[3])
 
     def build_table(self):
-        self.table_store = gtk.TreeStore(str, str, int, str, str, str)
+        self.table_store = gtk.TreeStore(int, str, int, str, str, str)
         self.table.set_model(self.table_store)
         self.table.connect("row-activated", self.onTableClicked)
         self.treeview_add_column(self.table, "Address", 0)
@@ -146,7 +146,7 @@
 
     def on_toolbutton_save(self, widget):
         chooser = gtk.FileChooserDialog( \
-            title="Save filter into ...",
+            title="Save XML filter into ...",
             action=gtk.FILE_CHOOSER_ACTION_SAVE,
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:

Modified: haypo/hachoir/user_filter.py
===================================================================
--- haypo/hachoir/user_filter.py	2005-11-02 03:21:07 UTC (rev 245)
+++ haypo/hachoir/user_filter.py	2005-11-02 04:26:28 UTC (rev 246)
@@ -20,19 +20,19 @@
         self.sub = sub
         self.sub_format = sub_format
 
-class UserFilter(Filter):
-    def __init__(self, desc, stream, parent):
-        Filter.__init__(self, desc.id, desc.description, stream, parent)
-        for chunk in desc.chunks:
-            if chunk.format == "sub":
-                modules = chunk.sub_format.split('.')
-                chunk_class = modules[-1]
-                module = ".".join(modules[:-1])
-                mod = __import__(module, globals(), locals(), [chunk_class])
-                chunk_class = getattr(mod, chunk_class)
-                self.readChild(chunk.id, chunk_class, chunk.description)
-            else:
-                self.read(chunk.id, chunk.format, chunk.description)
+def loadUserFilter(desc, stream, parent):
+    filter = Filter(desc.id, desc.description, stream, parent)
+    for chunk in desc.chunks:
+        if chunk.format == "sub":
+            modules = chunk.sub_format.split('.')
+            chunk_class = modules[-1]
+            module = ".".join(modules[:-1])
+            mod = __import__(module, globals(), locals(), [chunk_class])
+            chunk_class = getattr(mod, chunk_class)
+            filter.readChild(chunk.id, chunk_class, chunk.description)
+        else:
+            filter.read(chunk.id, chunk.format, chunk.description)
+    return filter            
 
 class UserFilterDescriptor:
     def __init__(self, filter=None, xml_file=None):



From haypo at berlios.de  Wed Nov  2 06:49:10 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Wed, 2 Nov 2005 06:49:10 +0100
Subject: [Happyboom-svn] r247 - in haypo/hachoir: . plugins
Message-ID: <200511020549.jA25nAuq013987@sheep.berlios.de>

Author: haypo
Date: 2005-11-02 06:48:48 +0100 (Wed, 02 Nov 2005)
New Revision: 247

Added:
   haypo/hachoir/BUGS
   haypo/hachoir/ogg_page.xml
   haypo/hachoir/plugins/jpeg.py
Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/plugins/exe.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/ui_popup.py
Log:
Add "add string" function in popup menu, add JPEG plugin (and "OGG page" user filter,
ogg_page.xml). Function Filter.readChild don't have description argument anymore
(use child description).


Added: haypo/hachoir/BUGS
===================================================================
--- haypo/hachoir/BUGS	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/BUGS	2005-11-02 05:48:48 UTC (rev 247)
@@ -0,0 +1,2 @@
+- Set format to last chunk in a sub-filter doesn't work
+  (last chunk always converted to "!%ss" % padding)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/filter.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -204,6 +204,23 @@
             size = size + chunk.size
         return size
 
+    def addString(self, str_type, before_chunk):
+        if before_chunk != None:
+            pos = self._chunks.index(before_chunk)
+            addr = before_chunk.addr
+        else:
+            pos = len(self._chunks)
+            addr = self.getAddr()
+        stream = self.getStream()
+        stream.seek(addr)
+        str_chunk = StringChunk("str", "String", stream, str_type, self)
+        self._appendChunk(str_chunk, can_truncate=True, position=pos)
+        str_chunk.postProcess()
+        before_chunk.addr = before_chunk.addr + str_chunk.size
+        before_chunk.convertToStringSize(before_chunk.size - str_chunk.size)
+        self.redisplay()
+        return str_chunk
+
     def updateParent(self, chunk):
         pass
 
@@ -294,7 +311,7 @@
             setattr(self, id, data)
             self._chunks_dict[id] = chunk
 
-    def readChild(self, id, filter_class, description, *args): 
+    def readChild(self, id, filter_class, *args): 
         filter = filter_class(self._stream, self, *args)
         chunk = self.addFilter(id, filter)
         chunk.postProcess()

Modified: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/hachoir.glade	2005-11-02 05:48:48 UTC (rev 247)
@@ -279,7 +279,7 @@
       <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image40">
+	<widget class="GtkImage" id="image44">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -300,7 +300,7 @@
       <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image41">
+	<widget class="GtkImage" id="image45">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -314,6 +314,27 @@
   </child>
 
   <child>
+    <widget class="GtkImageMenuItem" id="add_string">
+      <property name="visible">True</property>
+      <property name="label" translatable="yes">Add string</property>
+      <property name="use_underline">True</property>
+      <signal name="activate" handler="onAddString" last_modification_time="Wed, 02 Nov 2005 05:30:33 GMT"/>
+
+      <child internal-child="image">
+	<widget class="GtkImage" id="image46">
+	  <property name="visible">True</property>
+	  <property name="stock">gtk-add</property>
+	  <property name="icon_size">1</property>
+	  <property name="xalign">0.5</property>
+	  <property name="yalign">0.5</property>
+	  <property name="xpad">0</property>
+	  <property name="ypad">0</property>
+	</widget>
+      </child>
+    </widget>
+  </child>
+
+  <child>
     <widget class="GtkImageMenuItem" id="convert">
       <property name="visible">True</property>
       <property name="label" translatable="yes">_Convert chunk &lt;=&gt; filter</property>
@@ -321,7 +342,7 @@
       <signal name="activate" handler="onConvert" last_modification_time="Wed, 02 Nov 2005 02:32:16 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image42">
+	<widget class="GtkImage" id="image47">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-convert</property>
 	  <property name="icon_size">1</property>
@@ -342,7 +363,7 @@
       <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image43">
+	<widget class="GtkImage" id="image48">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-edit</property>
 	  <property name="icon_size">1</property>
@@ -363,7 +384,7 @@
       <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image44">
+	<widget class="GtkImage" id="image49">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-delete</property>
 	  <property name="icon_size">1</property>

Added: haypo/hachoir/ogg_page.xml
===================================================================
--- haypo/hachoir/ogg_page.xml	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/ogg_page.xml	2005-11-02 05:48:48 UTC (rev 247)
@@ -0,0 +1,12 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<user_filter hachoir_version='2005-10-27' id='ogg_page' description='ogg_page'>
+  <chunk format='!4s' id='header' description='Header (OggS)'/>
+  <chunk format='!1B' id='version' description='Version'/>
+  <chunk format='!1B' id='type' description='Type'/>
+  <chunk format='!8s' id='pos' description='Position'/>
+  <chunk format='!L' id='serial' description='Serial number'/>
+  <chunk format='!L' id='seq_nb' description='Sequence number'/>
+  <chunk format='!L' id='checksum' description='Checksum'/>
+  <chunk format='!1B' id='page_segm' description='Raw'/>
+  <chunk format='!31s' id='something' description='Raw'/>
+</user_filter>

Modified: haypo/hachoir/plugins/exe.py
===================================================================
--- haypo/hachoir/plugins/exe.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/plugins/exe.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -202,13 +202,13 @@
     def __init__(self, stream):
         Filter.__init__(self, "exe_file", "EXE file", stream, None)
 
-        self.readChild("ms_dos", MS_Dos, "MS-Dos header")
+        self.readChild("ms_dos", MS_Dos)
 
         if self.ms_dos.reloc_offset == 0x40:
             stream.seek(self.ms_dos.pe_offset, 0)
 
-            self.readChild("pe", PE_Filter, "PE header")
-            self.readChild("pe_opt", PE_OptionnalHeader, "PE optionnal header")
+            self.readChild("pe", PE_Filter)
+            self.readChild("pe_opt", PE_OptionnalHeader)
             self.readArray("pe_sections", PE_Section, "PE sections", self.checkEndOfSections)
 
             # Look for resource section

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/plugins/gif.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -40,7 +40,7 @@
         self.interlaced = ((self.flags & 0x40) == 0x40)
         self.bits_per_pixel = 1 + (self.flags & 0x07)
         if not self.global_map:
-            self.readChild("local_map", GifColorMap, "Local color map")
+            self.readChild("local_map", GifColorMap)
         else:
             self.local_map = None
         # -- End of TODO
@@ -115,9 +115,9 @@
         self.read("header", "6s", "File header")
         assert (self.header == "GIF87a") or (self.header == "GIF89a")
         
-        self.readChild("screen", GifScreenDescriptor, "Screen descriptor")
+        self.readChild("screen", GifScreenDescriptor)
         if self.screen.global_map:
-            self.readChild("color_map", GifColorMap, "Color map")
+            self.readChild("color_map", GifColorMap)
         else:
             self.color_map = None
             
@@ -126,9 +126,9 @@
             code = self.read("separator[]", "c", "Separator code")
             code = code.getValue()
             if code == "!":
-                self.readChild("extensions[]", GifExtension, "Extension")
+                self.readChild("extensions[]", GifExtension)
             elif code == ",":
-                self.readChild("images[]", GifImage, "Image")
+                self.readChild("images[]", GifImage)
                 # TODO: Write GifImage code :-)
                 warning("GIF FILTER CAN NOT READ IMAGE CONTENT YET, SO ABORT READING!")
                 return

Added: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/plugins/jpeg.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -0,0 +1,71 @@
+"""
+Exported filter.
+
+Description:
+Default filter
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class JpegChunkApp0(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "jpeg_chunk", "JPEG chunk App0", stream, parent)
+        self.read("jfif", "!5s", "JFIF string")
+        self.read("ver_maj", "!B", "Major version")
+        self.read("ver_min", "!B", "Minor version")
+        self.read("units", "!1B", "Units (=0)")
+        self.read("x_density", "!H", "X density")
+        self.read("y_density", "!H", "Y density")
+        self.read("thumb_w", "!B", "Thumbnail width")
+        self.read("thumb_h", "!1B", "Thumbnail height")
+        thumb = self.thumb_w * self.thumb_h
+        if thumb != 0:
+            self.read("thumb_data", "!%us" % size, "Thumbnail data", truncate=True)
+
+class JpegChunk(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
+        self.read("header", "!2B", "Header", post=self.getChunkType)
+        assert self.header[0] == (0xFF)
+        self.read("size", "!H", "Size")
+        if self.header[1] == 0xE0:
+            chunk = self.readChild("app0", JpegChunkApp0)
+            assert chunk.size == (self.size - 2)
+        else:
+            self.read("data", "!%us" % (self.size - 2), "Data")
+
+    def getChunkType(self, chunk):
+        types = {
+            0xC0: "Start Of Frame 0 (SOF0)",
+            0xC3: "Define Huffman Table (DHT)",
+            0xD8: "Start of image (SOI)",
+            0xD9: "End of image (EOI)",
+            0xDA: "Start Of Scan (SOS)",
+            0xDB: "Define Quantization Table (DQT)",
+            0xDC: "Define number of Lines (DNL)",
+            0xDD: "Define Restart Interval (DRI)",
+            0xE0: "APP0",
+            0xFE: "Comment"
+        }
+        type = chunk.value[1]
+        if type in types:
+            type = types[type]
+        else:
+            type = "Unknow type (%02X)" % type
+        self.setDescription("JPEG chunk \"%s\"" % type)
+        return type
+
+class JpegFile(Filter):
+    def checkEndOfChunks(self, stream, array, chunk):
+        if chunk != None and chunk.header[1] == 0xDA: return True
+        return stream.eof()
+
+    def __init__(self, stream):
+        Filter.__init__(self, "jpeg_file", "JPEG file", stream, None)
+        self.read("header", "!2B", "Header \"start of image\" (0xFF, 0xD8)")
+        assert self.header == (0xFF, 0xD8)
+        self.readArray("chunk", JpegChunk, "Chunks", self.checkEndOfChunks)
+        self.read("data", "!{@end@}s", "JPEG data")
+        
+registerPlugin("^.*\.(jpg|jpeg|JPG|JPEG)$", "JPEG picture", JpegFile, None)

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/plugins/png.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -114,7 +114,7 @@
         if self.type in self.chunk_splitter:
             oldpos = self._stream.tell()
             child_filter = self.chunk_splitter[self.type]
-            self.readChild("chunk_data", child_filter, "Chunk data")
+            self.readChild("chunk_data", child_filter)
             assert oldpos + self.size == self._stream.tell()
         else:
             self.read("data", "!{size}s", "Chunk data")

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/plugins/zip.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -101,11 +101,11 @@
             header = self.read("header[]", "<L", "Header")
             header = header.getValue()
             if header == 0x04034B50:
-                self.readChild("files[]", ZipFileEntry, "File entry")
+                self.readChild("files[]", ZipFileEntry)
             elif header == 0x02014b50:
-                self.readChild("central_directory[]", ZipCentralDirectory, "Central directory")
+                self.readChild("central_directory[]", ZipCentralDirectory)
             elif header == 0x06054b50:
-                self.readChild("end_central_directory", ZipEndCentralDirectory, "End of central directory")
+                self.readChild("end_central_directory", ZipEndCentralDirectory)
             elif header == 0x05054b50:
                 self.read("signature_length", "!H", "Signature length")
                 self.read("signature", "!{signature_length}s", "Signature")

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-02 04:26:28 UTC (rev 246)
+++ haypo/hachoir/ui_popup.py	2005-11-02 05:48:48 UTC (rev 247)
@@ -19,6 +19,7 @@
         # Popup items
         self.new_chunk = xml.get_widget("new_chunk")
         self.new_filter = xml.get_widget("new_filter")
+        self.add_string = xml.get_widget("add_string")
         self.convert = xml.get_widget("convert")
         self.set_format = xml.get_widget("set_format")
         self.delete_chunk = xml.get_widget("delete_chunk")
@@ -34,6 +35,7 @@
         is_filter_chunk = issubclass(self.chunk.__class__, FilterChunk)
         self.new_chunk.set_sensitive(is_format_chunk)
         self.new_filter.set_sensitive(is_format_chunk)
+        self.add_string.set_sensitive(is_format_chunk)
         self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
         self.set_format.set_sensitive(is_format_chunk)
 
@@ -78,6 +80,11 @@
         desc = self.new_chunk_dlg.getDescription()
         self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
 
+    def onAddString(self, event):
+        str_type = "C"
+        assert issubclass(self.chunk.__class__, FormatChunk)
+        self.chunk.getParent().addString(str_type, self.chunk)
+        
     def onSetFormat(self, event):
         assert issubclass(self.chunk.__class__, FormatChunk)
         if self.new_chunk_dlg.runSetFormat(self.chunk) == gtk.RESPONSE_CANCEL: return



From haypo at berlios.de  Thu Nov  3 05:26:57 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Thu, 3 Nov 2005 05:26:57 +0100
Subject: [Happyboom-svn] r248 - in haypo/hachoir: . plugins
Message-ID: <200511030426.jA34Qvpk002606@sheep.berlios.de>

Author: haypo
Date: 2005-11-03 05:26:54 +0100 (Thu, 03 Nov 2005)
New Revision: 248

Added:
   haypo/hachoir/plugins/pdf.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/jpeg.py
   haypo/hachoir/tools.py
   haypo/hachoir/ui_popup.py
Log:
StringChunk can be a file line (ended by \n, \r\n, \r or ... auto). Add PDF filter.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/chunk.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -2,7 +2,7 @@
 import re
 import types
 from format import checkFormat, splitFormat
-from error import error
+from error import warning, error
 from tools import convertDataToPrintableString
 
 class Chunk(object):
@@ -99,19 +99,48 @@
 
 class StringChunk(Chunk):
     def __init__(self, id, description, stream, str_type, parent):
+        assert str_type in ("C", "UnixLine", "WindowsLine", "MacLine", "AutoLine")
         Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
         self._str_type = str_type
         self._read()
 
     def getFormat(self):
-        return "c-string"
+        names = {
+            "C": "c-string",
+            "MacLine": "mac line",
+            "UnixLine": "unix line",
+            "AutoLine": "line",
+            "WindowsLine": "windows line"
+        }
+        assert self._str_type in names
+        return names[self._str_type]
 
     def _read(self):
-#        if self._str_type == "C": ...
         self._stream.seek(self.addr)
-        self._size = self._stream.searchLength("\0", True)
+        if self._str_type == "UnixLine":
+            end = "\n"
+        elif self._str_type == "WindowsLine":
+            end = "\r\n"
+        elif self._str_type == "MacLine":
+            end = "\r"
+        elif self._str_type == "AutoLine":
+            end = "\r"
+        else: 
+            # Type: C string
+            end = "\0"
+        self._size = self._stream.searchLength(end, True)
         assert self._size != -1
-        self.str = self._stream.getN(self._size-1)
+        if self._str_type == "AutoLine":
+            self._stream.seek(self.addr+self._size)
+            try:
+                next = self._stream.getN(1)
+                if next == '\n':
+                    self._size = self._size + 1
+                    end = end+"\n"
+            except Exception, err:
+                warning("Warning while getting end of line of \"auto line\": %s" % err)
+        self._stream.seek(self.addr)
+        self.str = self._stream.getN(self._size - len(end))
 
     def update(self):
         Chunk.update(self)
@@ -122,7 +151,10 @@
     value = property(getValue)
 
     def getDisplayData(self):
-        return convertDataToPrintableString(self.str)
+        if self.display != None:
+            return self.display
+        else:
+            return convertDataToPrintableString(self.str)
         
 class FormatChunkCache:
     def __init__(self, chunk):
@@ -199,8 +231,6 @@
         else:
             size = getattr(self._parent, id)
         return str(size)
-
-    def getFormat(self): return self.__format
     
     def convertToStringSize(self, size):
         self.__format = "!%ss" % size

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/filter.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -213,7 +213,8 @@
             addr = self.getAddr()
         stream = self.getStream()
         stream.seek(addr)
-        str_chunk = StringChunk("str", "String", stream, str_type, self)
+        id = self.getUniqChunkId("str")
+        str_chunk = StringChunk(id, "String", stream, str_type, self)
         self._appendChunk(str_chunk, can_truncate=True, position=pos)
         str_chunk.postProcess()
         before_chunk.addr = before_chunk.addr + str_chunk.size
@@ -325,16 +326,21 @@
         return chunk
 
     def readArray(self, id, entry_class, description, end_func): 
+        """
+        end_func: def isEnd(stream, array, last_filter)
+
+        """
         filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
         chunk = self.addFilter(id, filter)
         chunk.postProcess()
         return chunk
     
-    def readString(self, id, format, description):
+    def readString(self, id, format, description, post=None):
         """ Returns chunk """
         chunk = StringChunk(id, description, self._stream, format, self)
         self._appendChunk(chunk)
         self._stream.seek(chunk.addr + chunk.size)
+        chunk.post_process = post
         chunk.postProcess()
         return chunk
     

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/hachoir_class.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -4,6 +4,7 @@
 from default import DefaultFilter, displayDefault
 from user_filter import UserFilterDescriptor, loadUserFilter
 from error import error
+from tools import getBacktrace
 
 class Hachoir:
     instance = None
@@ -111,7 +112,8 @@
             compiled = compile(script, self.script, 'exec')
             exec compiled
         except Exception, msg:
-            error("Exception while loading script \"%s\":\n%s" % (filename, msg))
+            error("Exception while loading script \"%s\":\n%s\n%s" \
+                % (filename, msg, getBacktrace()))
 
     def run(self, filename):
         if self.script:

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/plugins/jpeg.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -15,8 +15,12 @@
         self.read("ver_maj", "!B", "Major version")
         self.read("ver_min", "!B", "Minor version")
         self.read("units", "!1B", "Units (=0)")
-        self.read("x_density", "!H", "X density")
-        self.read("y_density", "!H", "Y density")
+        if self.units == 0:
+            self.read("aspect_x", "!H", "Aspect ratio (X)")
+            self.read("aspect_y", "!H", "Aspect ratio (Y)")
+        else:
+            self.read("x_density", "!H", "X density")
+            self.read("y_density", "!H", "Y density")
         self.read("thumb_w", "!B", "Thumbnail width")
         self.read("thumb_h", "!1B", "Thumbnail height")
         thumb = self.thumb_w * self.thumb_h

Added: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/plugins/pdf.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -0,0 +1,51 @@
+from filter import Filter
+from plugin import registerPlugin
+import re
+from tools import convertDataToPrintableString
+
+def isEnd(stream, array, last):
+    return stream.eof()
+
+def stripLine(chunk):
+    return convertDataToPrintableString(chunk.value.strip())
+
+class PdfObject(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "value", "", stream, parent)
+        n = 0
+        while not stream.eof():
+            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+            if chunk.value.strip() == ">>":
+                break
+            n = n + 1
+
+class PdfXref(Filter):
+    def __init__(self, stream, parent, nb_items):
+        Filter.__init__(self, "id", "", stream, parent)
+        n = 0
+        while n<nb_items and not stream.eof():
+            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+            n = n + 1
+
+class PdfFile(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "id", "", stream, parent)
+        self.readString("version", "AutoLine", "PDF version")
+        while not stream.eof():
+            try:
+                chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+                value = chunk.value.strip()
+                if re.match("^\<\<", value) != None:
+                    self.readChild("data[]", PdfObject)
+                elif value == "stream":
+                    break
+                else:
+                    m = re.match("^[0-9]+ ([0-9]+)$", value)
+                    if m != None:
+                        nb_ref = int(m.group(1))
+                        self.readChild("xref", PdfXref, nb_ref)
+            except Exception, err:
+                print "Exception: %s" % err
+                break
+
+registerPlugin("^.*\.(PDF|pdf)$", "PDF document file", PdfFile, None)

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/tools.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -15,7 +15,8 @@
             if c in know:
                 display = display + know[c]
             else:
-                display = display + "\\x%02X" % ord(c)
+#                display = display + "\\x%02X" % ord(c)
+                display = display + "."
         elif c in string.printable:
             display = display + c
         else:

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-02 05:48:48 UTC (rev 247)
+++ haypo/hachoir/ui_popup.py	2005-11-03 04:26:54 UTC (rev 248)
@@ -81,7 +81,9 @@
         self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
 
     def onAddString(self, event):
-        str_type = "C"
+        # TODO: Ask string type, id and description
+        str_type = "MacLine"
+#        str_type = "C"
         assert issubclass(self.chunk.__class__, FormatChunk)
         self.chunk.getParent().addString(str_type, self.chunk)
         



From haypo at berlios.de  Sat Nov  5 02:23:25 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 5 Nov 2005 02:23:25 +0100
Subject: [Happyboom-svn] r249 - haypo/hachoir
Message-ID: <200511050123.jA51NP2a019314@sheep.berlios.de>

Author: haypo
Date: 2005-11-05 02:23:06 +0100 (Sat, 05 Nov 2005)
New Revision: 249

Modified:
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/ui_popup.py
Log:
Reprise sur erreur: utilise le filter par defaut si un filtre
echoue ...


Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-03 04:26:54 UTC (rev 248)
+++ haypo/hachoir/hachoir_class.py	2005-11-05 01:23:06 UTC (rev 249)
@@ -93,8 +93,9 @@
         except Exception, msg:
             error("Exception while processing file %s with filter %s:\n%s" \
                 % (filename, plugin_name, msg))
-            raise
-            return
+            display_func = None
+            stream.seek(0)
+            filter = DefaultFilter(stream)
         self.main_filter = self.filter = filter
         self._addPadding()
         self.filter.display()

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-03 04:26:54 UTC (rev 248)
+++ haypo/hachoir/ui_popup.py	2005-11-05 01:23:06 UTC (rev 249)
@@ -2,7 +2,7 @@
 pygtk.require ('2.0')
 import gtk
 import gtk.glade
-from chunk import FormatChunk, FilterChunk
+from chunk import FormatChunk, FilterChunk, StringChunk
 from ui_new_chunk import NewChunkDialog
 from format import splitFormat # TODO: remove this line
 from error import error
@@ -32,8 +32,9 @@
             return
 
         is_format_chunk = issubclass(self.chunk.__class__, FormatChunk)
+        is_string_chunk = issubclass(self.chunk.__class__, StringChunk)
         is_filter_chunk = issubclass(self.chunk.__class__, FilterChunk)
-        self.new_chunk.set_sensitive(is_format_chunk)
+        self.new_chunk.set_sensitive(is_format_chunk or is_string_chunk)
         self.new_filter.set_sensitive(is_format_chunk)
         self.add_string.set_sensitive(is_format_chunk)
         self.convert.set_sensitive(is_format_chunk or is_filter_chunk)



From haypo at berlios.de  Sat Nov  5 04:52:07 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 5 Nov 2005 04:52:07 +0100
Subject: [Happyboom-svn] r250 - in haypo/hachoir: . plugins
Message-ID: <200511050352.jA53q7Y9011622@sheep.berlios.de>

Author: haypo
Date: 2005-11-05 04:52:03 +0100 (Sat, 05 Nov 2005)
New Revision: 250

Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/stream.py
Log:
Improve PDF plugin => split into objects


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-05 01:23:06 UTC (rev 249)
+++ haypo/hachoir/filter.py	2005-11-05 03:52:03 UTC (rev 250)
@@ -31,7 +31,11 @@
         if self.__class__ == Filter:
             return None
         self.getStream().seek(self.getAddr())
-        new = self.__class__(self.getStream(), self.getParent())
+        try:
+            new = self.__class__(self.getStream(), self.getParent())
+        except:
+            error("Error while clone class of type %s!" % self.__class__)
+            raise
         new.filter_chunk = self.filter_chunk
         return new
 
@@ -262,7 +266,7 @@
         if lg == -1:
             raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
         self.read(id, "!%us" % lg, description) 
-        self.read(None, "!%us" % len(delimiter), "Delimiter of %s" % id) 
+        self.read(id+"_delimiter", "!%us" % len(delimiter), "Delimiter of %s" % id) 
 
     def searchEol(self, eol):
         lg = self._stream.searchLength(eol, True)

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-05 01:23:06 UTC (rev 249)
+++ haypo/hachoir/plugins/pdf.py	2005-11-05 03:52:03 UTC (rev 250)
@@ -1,7 +1,8 @@
 from filter import Filter
 from plugin import registerPlugin
 import re
-from tools import convertDataToPrintableString
+from stream import StreamError
+from tools import convertDataToPrintableString, getBacktrace
 
 def isEnd(stream, array, last):
     return stream.eof()
@@ -11,41 +12,92 @@
 
 class PdfObject(Filter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "value", "", stream, parent)
-        n = 0
-        while not stream.eof():
-            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
-            if chunk.value.strip() == ">>":
-                break
-            n = n + 1
+        Filter.__init__(self, "pdf_obj", "PDF object", stream, parent)
+        self.metadata = {}
+        chunk = self.readString("header", "AutoLine", "Object header", post=stripLine)
+        header = chunk.value 
+        assert header != ""
+        if header == "xref":
+            self.type = "xref"
+            self.readXref()
+        else: 
+            self.type = "obj"
+            m = re.match("([0-9]+) [0-9]+ obj", header)
+            if m != None:
+                id = int(m.group(1))
+                self.metadata["id"] = id
+                self.setDescription("Object (id %s)" % id)
+            else:
+                self.metadata["id"] = header
+                self.setDescription("Object (%s)" % header)
+            self.readObj()                
+        self.updateDescription()
 
-class PdfXref(Filter):
-    def __init__(self, stream, parent, nb_items):
-        Filter.__init__(self, "id", "", stream, parent)
+    def updateDescription(self):
+        if self.type == "obj":
+            info = "id %s" % self.metadata["id"]
+            if "type" in self.metadata:
+                info = info + ", %s" % self.metadata["type"]
+                if "fontname" in self.metadata:
+                    info = info + ", name: %s" % self.metadata["fontname"]
+        else:
+            info = "XREF"
+        self.setDescription("Object (%s)" % info)
+
+    def readObj(self):
+        chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+        if re.match("^\<\<", chunk.value) != None:
+            self.processLine(chunk.value)
+            while re.match("^.*\>\>$", chunk.value) == None:
+                chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+                self.processLine(chunk.value)
+        chunk = self.readString("endobj", "AutoLine", "Object end", post=stripLine)
+        if chunk.value == "stream":
+            chunk.id = "xref"
+            lg = self._stream.searchLength("endstream", False)
+            if lg == -1:
+                raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
+            self.read("data[]", "!%us" % lg, "Data")
+            self.readString("data_end[]", "AutoLine", "Data end")
+            self.readString("endobj", "AutoLine", "Object end", post=stripLine)
+        self.readString("emptyline", "AutoLine", "")
+
+    def readXref(self):
+        chunk = self.readString("xref_header", "AutoLine", "XRef header", post=stripLine)
+        m = re.match("^[0-9]+ ([0-9]+)$", chunk.value)
+        assert m != None
+        nb_ref = int(m.group(1)) - 1
         n = 0
-        while n<nb_items and not stream.eof():
-            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+        while n<nb_ref:
+            chunk = self.readString("ref[]", "AutoLine", "Reference", post=stripLine)
             n = n + 1
+        self.readString("endobj", "AutoLine", "Object end", post=stripLine)
 
+    def processLine(self, line):
+        tests = {
+            "type":  "^.*/Type /([A-Za-z]+)$",
+            "fontname":  "^.*/FontName /[BD]A+\+([A-Za-z-]+)$"
+        }
+        for field in tests:
+            m = re.match(tests[field], line)
+            if m != None:
+                self.metadata[field] = m.group(1)
+                break 
+
 class PdfFile(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "id", "", stream, parent)
         self.readString("version", "AutoLine", "PDF version")
+        self.readString("header", "AutoLine", "PDF header")
+        self.nb_ref = None
         while not stream.eof():
             try:
-                chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
-                value = chunk.value.strip()
-                if re.match("^\<\<", value) != None:
-                    self.readChild("data[]", PdfObject)
-                elif value == "stream":
-                    break
-                else:
-                    m = re.match("^[0-9]+ ([0-9]+)$", value)
-                    if m != None:
-                        nb_ref = int(m.group(1))
-                        self.readChild("xref", PdfXref, nb_ref)
+                self.readChild("obj[]", PdfObject)
+            except StreamError, err:
+                return
             except Exception, err:
-                print "Exception: %s" % err
-                break
+                print "Exception in PDF: %s" % err
+                print getBacktrace()
+                return
 
 registerPlugin("^.*\.(PDF|pdf)$", "PDF document file", PdfFile, None)

Modified: haypo/hachoir/stream.py
===================================================================
--- haypo/hachoir/stream.py	2005-11-05 01:23:06 UTC (rev 249)
+++ haypo/hachoir/stream.py	2005-11-05 03:52:03 UTC (rev 250)
@@ -1,13 +1,20 @@
 import struct
 from StringIO import StringIO
 
+class StreamError(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
 class Stream:
     def __init__(self):
         pass
+    
+    def getSize(self):
+        return 0
+    
+    def getLastPos(self):
+        return 0
 
-    def get16(self):
-        return None
-
     def eof(self):
         return self.getLastPos() <= self.tell() 
 
@@ -47,7 +54,7 @@
 
     def getN(self, size):
         if self.__start+self.__size<self.__stream.tell()+size:
-            raise Exception("Can't read outsize the stream.")
+            raise StreamError("Can't read outsize the stream.")
         return self.__stream.getN(size)
 
     def tell(self):
@@ -79,7 +86,7 @@
         """ Read file seek document to understand where. """
         self.__file.seek(pos, where)
         if self.__size < self.tell():
-            raise Exception("Error when seek to (%s,%s) in a stream." % (pos, where))
+            raise StreamError("Error when seek to (%s,%s) in a stream." % (pos, where))
 
     def tell(self):
         return self.__file.tell()
@@ -89,7 +96,7 @@
         pos_max: Position of last tested byte
         """
         if 2048<=len(binary_string):
-            raise Exception("Search string too big.")
+            raise StreamError("Search string too big.")
         size = 2048 
         doublesize = size * 2
         oldpos = self.tell()
@@ -127,7 +134,7 @@
     def getN(self, size):
         data = self.__file.read(size)
         if len(data) != size:
-            raise Exception("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
+            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
         return data
 
     def getEnd(self):



From haypo at berlios.de  Sat Nov  5 05:51:57 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Sat, 5 Nov 2005 05:51:57 +0100
Subject: [Happyboom-svn] r251 - in haypo/hachoir: . plugins
Message-ID: <200511050451.jA54pvUK022349@sheep.berlios.de>

Author: haypo
Date: 2005-11-05 05:51:54 +0100 (Sat, 05 Nov 2005)
New Revision: 251

Added:
   haypo/hachoir/gunzip_stream.py
   haypo/hachoir/ui_new_string.py
Modified:
   haypo/hachoir/Makefile
   haypo/hachoir/default.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/stream.py
   haypo/hachoir/ui_popup.py
Log:
Support deflate decompression for PDF file, and gzip decompression for gzip
file. Ask string format when adding a new string (and also id+desc. but they
aren't used yet).


Modified: haypo/hachoir/Makefile
===================================================================
--- haypo/hachoir/Makefile	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/Makefile	2005-11-05 04:51:54 UTC (rev 251)
@@ -1,2 +1,2 @@
 clean:
-	rm -f *.pyc plugins/*.pyc
+	rm -f *.pyc plugins/*.pyc hachoir.gladep *.bak

Modified: haypo/hachoir/default.py
===================================================================
--- haypo/hachoir/default.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/default.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -1,9 +1,10 @@
 from filter import Filter
 
-def displayDefault(data):
-    pass
+class EmptyFilter(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "empty", "Empty filter", stream, parent)
 
 class DefaultFilter(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "default", "Default filter", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "default", "Default filter", stream, parent)
         self.read("data", "!{@end@}s", "Data", truncate=True)

Added: haypo/hachoir/gunzip_stream.py
===================================================================
--- haypo/hachoir/gunzip_stream.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/gunzip_stream.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -0,0 +1,10 @@
+import gzip
+from StringIO import StringIO
+from stream import FileStream
+
+def GunzipStream(data):
+    io = StringIO(data)
+    io = gzip.GzipFile(None, "r", None, io)
+    data = io.read()
+    io = StringIO(data)
+    return FileStream(io)

Modified: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/hachoir.glade	2005-11-05 04:51:54 UTC (rev 251)
@@ -1201,4 +1201,257 @@
   </child>
 </widget>
 
+<widget class="GtkDialog" id="new_string">
+  <property name="visible">True</property>
+  <property name="title" translatable="yes">New string</property>
+  <property name="type">GTK_WINDOW_TOPLEVEL</property>
+  <property name="window_position">GTK_WIN_POS_NONE</property>
+  <property name="modal">False</property>
+  <property name="resizable">True</property>
+  <property name="destroy_with_parent">False</property>
+  <property name="decorated">True</property>
+  <property name="skip_taskbar_hint">False</property>
+  <property name="skip_pager_hint">False</property>
+  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
+  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
+  <property name="focus_on_map">True</property>
+  <property name="has_separator">True</property>
+
+  <child internal-child="vbox">
+    <widget class="GtkVBox" id="vbox4">
+      <property name="visible">True</property>
+      <property name="homogeneous">False</property>
+      <property name="spacing">0</property>
+
+      <child internal-child="action_area">
+	<widget class="GtkHButtonBox" id="hbuttonbox1">
+	  <property name="visible">True</property>
+	  <property name="layout_style">GTK_BUTTONBOX_END</property>
+
+	  <child>
+	    <widget class="GtkButton" id="button1">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-cancel</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-6</property>
+	    </widget>
+	  </child>
+
+	  <child>
+	    <widget class="GtkButton" id="button2">
+	      <property name="visible">True</property>
+	      <property name="can_default">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="label">gtk-ok</property>
+	      <property name="use_stock">True</property>
+	      <property name="relief">GTK_RELIEF_NORMAL</property>
+	      <property name="focus_on_click">True</property>
+	      <property name="response_id">-5</property>
+	    </widget>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">True</property>
+	  <property name="pack_type">GTK_PACK_END</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkLabel" id="label15">
+	  <property name="visible">True</property>
+	  <property name="label" translatable="yes">Choose new string format :</property>
+	  <property name="use_underline">False</property>
+	  <property name="use_markup">False</property>
+	  <property name="justify">GTK_JUSTIFY_LEFT</property>
+	  <property name="wrap">False</property>
+	  <property name="selectable">False</property>
+	  <property name="xalign">0.5</property>
+	  <property name="yalign">0.5</property>
+	  <property name="xpad">0</property>
+	  <property name="ypad">0</property>
+	  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	  <property name="width_chars">-1</property>
+	  <property name="single_line_mode">False</property>
+	  <property name="angle">0</property>
+	</widget>
+	<packing>
+	  <property name="padding">6</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkTable" id="table4">
+	  <property name="visible">True</property>
+	  <property name="n_rows">3</property>
+	  <property name="n_columns">2</property>
+	  <property name="homogeneous">False</property>
+	  <property name="row_spacing">6</property>
+	  <property name="column_spacing">6</property>
+
+	  <child>
+	    <widget class="GtkLabel" id="label16">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Format:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">0</property>
+	      <property name="bottom_attach">1</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkComboBoxEntry" id="format">
+	      <property name="visible">True</property>
+	      <property name="items" translatable="yes">C
+UnixLine
+WindowsLine
+MacLine
+AutoLine</property>
+	      <property name="add_tearoffs">False</property>
+	      <property name="has_frame">True</property>
+	      <property name="focus_on_click">True</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">0</property>
+	      <property name="bottom_attach">1</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options">fill</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label19">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Id:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">1</property>
+	      <property name="bottom_attach">2</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label20">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Desc.:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">0</property>
+	      <property name="right_attach">1</property>
+	      <property name="top_attach">2</property>
+	      <property name="bottom_attach">3</property>
+	      <property name="x_options">fill</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkEntry" id="description">
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">True</property>
+	      <property name="visibility">True</property>
+	      <property name="max_length">0</property>
+	      <property name="text" translatable="yes"></property>
+	      <property name="has_frame">True</property>
+	      <property name="invisible_char">*</property>
+	      <property name="activates_default">False</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">2</property>
+	      <property name="bottom_attach">3</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkEntry" id="id">
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">True</property>
+	      <property name="visibility">True</property>
+	      <property name="max_length">0</property>
+	      <property name="text" translatable="yes"></property>
+	      <property name="has_frame">True</property>
+	      <property name="invisible_char">*</property>
+	      <property name="activates_default">False</property>
+	    </widget>
+	    <packing>
+	      <property name="left_attach">1</property>
+	      <property name="right_attach">2</property>
+	      <property name="top_attach">1</property>
+	      <property name="bottom_attach">2</property>
+	      <property name="y_options"></property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">6</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
+    </widget>
+  </child>
+</widget>
+
 </glade-interface>

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/hachoir_class.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -1,7 +1,7 @@
 from stream import FileStream
 from plugin import getPlugin
 from chunk import FilterChunk
-from default import DefaultFilter, displayDefault
+from default import DefaultFilter
 from user_filter import UserFilterDescriptor, loadUserFilter
 from error import error
 from tools import getBacktrace
@@ -75,7 +75,8 @@
 
     def load(self, filename):
         try:
-            stream = FileStream(filename)
+            file = open(filename, 'r')
+            stream = FileStream(file, filename)
         except IOError, err:
             error("Can't load file %s:\n%s" % (filename, err))
             return
@@ -83,7 +84,7 @@
         # Look for a plugin
         plugin = getPlugin(filename)
         if plugin == None:
-            regex, plugin_name, split_func, display_func = None, "default", DefaultFilter, displayDefault 
+            regex, plugin_name, split_func, display_func = None, "default", DefaultFilter, None
         else:
             regex, plugin_name, split_func, display_func = plugin
             

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/plugins/gzip.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -8,10 +8,35 @@
 import datetime
 from filter import Filter
 from plugin import registerPlugin
+from gunzip_stream import GunzipStream
+from plugins.tar import TarFile
+   
+class GunzipFilter(Filter):
+    def __init__(self, stream, parent, start, size, filter_class):
+        # Read data
+        self._parent_stream = stream
+        self._parent_stream.seek(0)
+        data = stream.getN(self._parent_stream.getSize())
+        
+        # Create a new stream
+        stream = GunzipStream(data)
+        self._compressed_size = size 
+        self._decompressed_size = stream.getSize()
 
+        # Create filter
+        self._parent_stream.seek(start)
+        Filter.__init__(self, "deflate", "Deflate", stream, parent)
+        self._addr = self._parent_stream.tell()
+
+#        self.read("raw", "!{@end@}s", "")
+        self.readChild("tar", filter_class)
+
+    def getSize(self):
+        return self._compressed_size
+
 class GzipFile(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "gzip_file", "GZIP archive file", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "gzip_file", "GZIP archive file", stream, parent)
         self.read("id", "!2B", "Identifier (31,139)")
         assert self.id == (31, 139)
         self.read("comp_method", "!B", "Compression method", post=self.getCompressionMethod)
@@ -30,8 +55,12 @@
         if self.flags & 2 == 2:
             self.readString("crc16", "!H", "CRC16")
 
+
+
         size = stream.getSize() - stream.tell() - 8
-        self.read("data", "!%us" % size, "Compressed data", truncate=True)
+#        self.read("data", "!%us" % size, "Compressed data", truncate=True)
+        self.readChild("data", GunzipFilter, stream.tell(), size, TarFile) 
+        
         self.read("crc32", "<L", "CRC32")
         self.read("size", "<L", "Uncompressed size")
 

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/plugins/pdf.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -3,6 +3,7 @@
 import re
 from stream import StreamError
 from tools import convertDataToPrintableString, getBacktrace
+from deflate import DeflateFilter
 
 def isEnd(stream, array, last):
     return stream.eof()
@@ -53,11 +54,17 @@
                 self.processLine(chunk.value)
         chunk = self.readString("endobj", "AutoLine", "Object end", post=stripLine)
         if chunk.value == "stream":
+            start = self.getStream().tell()
             chunk.id = "xref"
-            lg = self._stream.searchLength("endstream", False)
-            if lg == -1:
+            size = self._stream.searchLength("endstream", False)
+            if size == -1:
                 raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
-            self.read("data[]", "!%us" % lg, "Data")
+
+            old = self.getStream().tell()
+            self.readChild("deflate", DeflateFilter, start, size)
+            print "%s+%s/%s" % (start, size, self.getStream().tell())
+            assert self.getStream().tell() == (start+size)
+            
             self.readString("data_end[]", "AutoLine", "Data end")
             self.readString("endobj", "AutoLine", "Object end", post=stripLine)
         self.readString("emptyline", "AutoLine", "")

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/plugins/tar.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -10,6 +10,7 @@
 from filter import Filter
 from plugin import registerPlugin
 from tools import convertDataToPrintableString
+from default import EmptyFilter
 
 def displayModeItem(mode):
     if mode & 4 == 4: r="r"
@@ -93,7 +94,9 @@
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
-            self.read("filedata", "!{size}s", "File data", truncate=True)
+            chunk = self.readChild("filedata", EmptyFilter)
+            filter = chunk.getFilter()
+            filter.read("filedata", "!%us" % self.size, "File data", truncate=True)
         if stream.tell() % 512 != 0:
             padding = 512 - stream.tell() % 512
             self.read("padding", "!%ss" % padding, "Padding (512 align)", truncate=True)
@@ -133,8 +136,8 @@
         chunk.description = self.description = text
 
 class TarFile(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "tar_file", "TAR archive file", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "tar_file", "TAR archive file", stream, parent)
 
         self.readArray("files", TarFileEntry, "Tar Files", self.checkEndOfChunks)
         

Modified: haypo/hachoir/stream.py
===================================================================
--- haypo/hachoir/stream.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/stream.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -70,13 +70,13 @@
         return self.__end
     
 class FileStream(Stream):
-    def __init__(self, filename):
+    def __init__(self, file, filename=None):
         """
         Endian: See setEndian function. 
         """
 
         Stream.__init__(self)
-        self.__file = open(filename, 'r')
+        self.__file = file 
         self.filename = filename
         self.__file.seek(0,2) # Seek to end
         self.__size = self.__file.tell()

Added: haypo/hachoir/ui_new_string.py
===================================================================
--- haypo/hachoir/ui_new_string.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/ui_new_string.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -0,0 +1,28 @@
+import pygtk
+pygtk.require ('2.0')
+import gtk
+import gtk.glade
+
+class NewStringDialog:
+    def __init__(self, filename):
+        xml = gtk.glade.XML(filename, "new_string")
+        self.window = xml.get_widget('new_string')
+        self.window.hide()
+        xml.signal_autoconnect(self)
+        self.format_widget = xml.get_widget("format")
+        self.id_widget = xml.get_widget("identifier")
+        self.desc_widget = xml.get_widget("description")
+
+    def getId(self):
+        return self.id_widget.get_text()
+
+    def getDescription(self):
+        return self.desc_widget.get_text()
+
+    def getFormat(self):
+        return self.format_widget.child.get_text()
+
+    def run(self):
+        r = self.window.run()
+        self.window.hide()
+        return r

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-05 03:52:03 UTC (rev 250)
+++ haypo/hachoir/ui_popup.py	2005-11-05 04:51:54 UTC (rev 251)
@@ -4,6 +4,7 @@
 import gtk.glade
 from chunk import FormatChunk, FilterChunk, StringChunk
 from ui_new_chunk import NewChunkDialog
+from ui_new_string import NewStringDialog
 from format import splitFormat # TODO: remove this line
 from error import error
 
@@ -15,6 +16,7 @@
         xml.signal_autoconnect(self)
         self.chunk = None
         self.new_chunk_dlg = NewChunkDialog(self.ui.glade_xml)
+        self.new_string_dlg = NewStringDialog(self.ui.glade_xml)
 
         # Popup items
         self.new_chunk = xml.get_widget("new_chunk")
@@ -82,9 +84,10 @@
         self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
 
     def onAddString(self, event):
-        # TODO: Ask string type, id and description
-        str_type = "MacLine"
-#        str_type = "C"
+        dlg = self.new_string_dlg
+        if dlg.run() == gtk.RESPONSE_CANCEL: return
+        str_type = dlg.getFormat()
+
         assert issubclass(self.chunk.__class__, FormatChunk)
         self.chunk.getParent().addString(str_type, self.chunk)
         



From haypo at berlios.de  Tue Nov 15 06:17:36 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 15 Nov 2005 06:17:36 +0100
Subject: [Happyboom-svn] r252 - in haypo/hachoir: . plugins
Message-ID: <200511150517.jAF5HaP2015409@sheep.berlios.de>

Author: haypo
Date: 2005-11-15 06:17:32 +0100 (Tue, 15 Nov 2005)
New Revision: 252

Modified:
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/zip.py
Log:
Fix zip plugin, improve pdf plugin: check header, debug font name extractor,
only decompress data if needed, support some PDF version differences.


Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-05 04:51:54 UTC (rev 251)
+++ haypo/hachoir/hachoir_class.py	2005-11-15 05:17:32 UTC (rev 252)
@@ -92,8 +92,8 @@
         try:
             filter = split_func(stream)
         except Exception, msg:
-            error("Exception while processing file %s with filter %s:\n%s" \
-                % (filename, plugin_name, msg))
+            error("Exception while processing file %s with filter %s:\n%s\n%s" \
+                % (filename, plugin_name, msg, getBacktrace()))
             display_func = None
             stream.seek(0)
             filter = DefaultFilter(stream)

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-05 04:51:54 UTC (rev 251)
+++ haypo/hachoir/plugins/pdf.py	2005-11-15 05:17:32 UTC (rev 252)
@@ -4,6 +4,7 @@
 from stream import StreamError
 from tools import convertDataToPrintableString, getBacktrace
 from deflate import DeflateFilter
+from error import warning
 
 def isEnd(stream, array, last):
     return stream.eof()
@@ -23,7 +24,7 @@
             self.readXref()
         else: 
             self.type = "obj"
-            m = re.match("([0-9]+) [0-9]+ obj", header)
+            m = re.match(r"([0-9]+) [0-9]+ obj", header)
             if m != None:
                 id = int(m.group(1))
                 self.metadata["id"] = id
@@ -45,33 +46,57 @@
             info = "XREF"
         self.setDescription("Object (%s)" % info)
 
-    def readObj(self):
+    def readContent(self):
         chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
-        if re.match("^\<\<", chunk.value) != None:
+        deflate = False
+        while chunk.value not in ("endobj", "stream"):
             self.processLine(chunk.value)
-            while re.match("^.*\>\>$", chunk.value) == None:
-                chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
-                self.processLine(chunk.value)
-        chunk = self.readString("endobj", "AutoLine", "Object end", post=stripLine)
-        if chunk.value == "stream":
+            if self.getStream().eof():
+                return "eof"
+            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+            if re.match(r"^.*/Filter /FlateDecode", chunk.value) != None:
+                deflate = True
+        if chunk.value == "endobj":
+            chunk.id = "endobj"
+            chunk.description = "Object end"
+            return "end"
+        elif deflate:
+            return "deflate"
+        else:
+            return "stream"
+    
+    def readObj(self):
+        what = self.readContent()
+        if what == "eof":
+            return
+        if what in ("stream","deflate"):
             start = self.getStream().tell()
-            chunk.id = "xref"
             size = self._stream.searchLength("endstream", False)
             if size == -1:
                 raise Exception("Delimiter \"%s\" not found for %s (%s)!" % (delimiter, id, description))
 
-            old = self.getStream().tell()
-            self.readChild("deflate", DeflateFilter, start, size)
-            print "%s+%s/%s" % (start, size, self.getStream().tell())
+            if what=="deflate":
+                try:
+                    old = self.getStream().tell()
+                    self.readChild("deflate", DeflateFilter, start, size)
+                except:
+                    warning("Error while decompressing data of an objet.")
+                    self.getStream().seek(start)
+                    self.read("data", "!%us" % size, "Data (compressed with deflate)")
+            else:
+                self.read("data", "!%us" % size, "Data")
             assert self.getStream().tell() == (start+size)
             
             self.readString("data_end[]", "AutoLine", "Data end")
             self.readString("endobj", "AutoLine", "Object end", post=stripLine)
-        self.readString("emptyline", "AutoLine", "")
+        ver = self.getParent().version
+        if ver[0] > 1 or (ver[0] == 1 and ver[1] > 0):
+            # PDF > 1.0 
+            self.readString("emptyline", "AutoLine", "")
 
     def readXref(self):
         chunk = self.readString("xref_header", "AutoLine", "XRef header", post=stripLine)
-        m = re.match("^[0-9]+ ([0-9]+)$", chunk.value)
+        m = re.match(r"^[0-9]+ ([0-9]+)$", chunk.value)
         assert m != None
         nb_ref = int(m.group(1)) - 1
         n = 0
@@ -82,8 +107,8 @@
 
     def processLine(self, line):
         tests = {
-            "type":  "^.*/Type /([A-Za-z]+)$",
-            "fontname":  "^.*/FontName /[BD]A+\+([A-Za-z-]+)$"
+            "type":  r"^.*Type /([A-Za-z]+)$",
+            "fontname":  r"^.*(?:BaseFont|FontName) /(?:[A-Z]A+\+)?([A-Za-z-]+)$"
         }
         for field in tests:
             m = re.match(tests[field], line)
@@ -94,8 +119,13 @@
 class PdfFile(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "id", "", stream, parent)
-        self.readString("version", "AutoLine", "PDF version")
-        self.readString("header", "AutoLine", "PDF header")
+        self.readString("pdf_version", "AutoLine", "PDF version")
+        m = re.match("^%PDF-([0-9]+)\.([0-9]+)$", self.pdf_version)
+        assert m != None
+        self.version = ( int(m.group(1)), int(m.group(2)) )
+        if self.version[0] == 1 and self.version[1] > 0:
+            # PDF > 1.0
+            self.readString("header", "AutoLine", "PDF header")
         self.nb_ref = None
         while not stream.eof():
             try:

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-05 04:51:54 UTC (rev 251)
+++ haypo/hachoir/plugins/zip.py	2005-11-15 05:17:32 UTC (rev 252)
@@ -84,7 +84,7 @@
         self.read("extra_length", "<H", "Extra length")
         self.read("filename", "<{filename_length}s", "Filename")
         self.read("extra", "<{extra_length}s", "Extra")
-        self.read("compressed_data", "<{compressed_size}s", "Compressed data", True)
+        self.read("compressed_data", "<{compressed_size}s", "Compressed data", truncate=True)
         if (self.flags & 4) == 4:
             self.read("file_crc32", "<L", "Checksum (CRC32)")
             self.read("file_compressed_size", "<L", "Compressed size (bytes)")



From haypo at berlios.de  Tue Nov 15 06:44:56 2005
From: haypo at berlios.de (Victor STINNER at BerliOS)
Date: Tue, 15 Nov 2005 06:44:56 +0100
Subject: [Happyboom-svn] r253 - haypo/hachoir
Message-ID: <200511150544.jAF5iu7c026606@sheep.berlios.de>

Author: haypo
Date: 2005-11-15 06:44:56 +0100 (Tue, 15 Nov 2005)
New Revision: 253

Added:
   haypo/hachoir/deflate.py
Log:
Add missing deflat.py


Added: haypo/hachoir/deflate.py
===================================================================
--- haypo/hachoir/deflate.py	2005-11-15 05:17:32 UTC (rev 252)
+++ haypo/hachoir/deflate.py	2005-11-15 05:44:56 UTC (rev 253)
@@ -0,0 +1,31 @@
+import zlib
+from StringIO import StringIO
+from stream import FileStream
+from filter import Filter
+
+class DeflateFilter(Filter):
+    def __init__(self, stream, parent, start, size):
+        # Read data
+        self._parent_stream = stream
+        self._parent_stream.seek(start)
+        data = stream.getN(size)
+        
+        # Create a new stream
+        stream = DeflateStream(data)
+        self._compressed_size = size 
+        self._decompressed_size = stream.getSize()
+
+        # Create filter
+        self._parent_stream.seek(start)
+        Filter.__init__(self, "deflate", "Deflate", stream, parent)
+        self._addr = self._parent_stream.tell()
+
+        self.read("raw", "!{@end@}s", "")
+
+    def getSize(self):
+        return self._compressed_size
+
+def DeflateStream(data):
+    data = zlib.decompress(data)
+    io = StringIO(data)
+    return FileStream(io)



From haypo at berlios.de  Wed Nov 16 02:28:41 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 16 Nov 2005 02:28:41 +0100
Subject: [Happyboom-svn] r254 - haypo/hachoir/plugins
Message-ID: <200511160128.jAG1SfDi008800@sheep.berlios.de>

Author: haypo
Date: 2005-11-16 02:28:09 +0100 (Wed, 16 Nov 2005)
New Revision: 254

Modified:
   haypo/hachoir/plugins/exe.py
Log:
Fix EXE plugin.


Modified: haypo/hachoir/plugins/exe.py
===================================================================
--- haypo/hachoir/plugins/exe.py	2005-11-15 05:44:56 UTC (rev 253)
+++ haypo/hachoir/plugins/exe.py	2005-11-16 01:28:09 UTC (rev 254)
@@ -40,9 +40,9 @@
         for section in exe.pe_sections:
             section = section.getFilter()
             displayPE_Section(section)
-        for res in exe.pe_resources:
-            res = res.getFilter()
-            displayPE_ResourceDirectory(res)
+#        for res in exe.pe_resources:
+#            res = res.getFilter()
+#            displayPE_ResourceDirectory(res)
             
 class PE_ResourceData(Filter):
     def __init__(self, stream, parent):
@@ -52,7 +52,7 @@
         self.read("page_code", "<L", "Page code (language)")
         self.read("language", "<l", "Page code (language)")
         self.language = -self.language
-        self.read(None, "!L", "Reserverd")
+        self.read("reserved", "!L", "Reserverd")
 
         oldpos = stream.tell()
         
@@ -67,23 +67,20 @@
         self.read("offset", "<L", "Offset")
         
 class PE_ResourceDirectory(Filter):
-    def __init__(self, stream, parent, offset_res_section):
+    def __init__(self, stream, parent):
         Filter.__init__(self, "pe_rsrc_dir", "PE resource directory", stream, parent)
-        self.offset_res_section = offset_res_section
+        self.offset_res_section = stream.tell()
         self.read("option", "<L", "Options")
         self.read("creation_date", "<L", "Creation date")
         self.read("maj_ver", "<H", "Major version")
         self.read("named_entries", "<H", "Named entries")
         self.read("indexed_entries", "<H", "Indexed entries")
-        nb_entries = self.named_entries + self.indexed_entries
-        self.openChild()
 
         stream.seek( stream.tell() + 0x10)
-        self.items = []
-        for i in range(nb_entries):
-            self.newChild("Resource")
-            self.items.append( PE_ResourceEntry(stream,self) )
-        self.closeChild("Resources")
+        self.readArray("item", PE_ResourceEntry, "PE resource entry", self.checkEndOfRes)
+    
+    def checkEndOfRes(self, stream, array, dir):
+        return len(array) == (self.named_entries + self.indexed_entries)
 
 class PE_Section(Filter):
     def __init__(self, stream, parent):
@@ -144,7 +141,7 @@
         self.readArray("directories", PE_Directory, "PE directories", self.checkEndOfDir)
 
     def checkEndOfDir(self, stream, array, dir):
-        return len(self.directories) == self.nb_directories
+        return len(array) == self.nb_directories
 
 class PE_Filter(Filter):
     def __init__(self, stream, parent):
@@ -192,10 +189,10 @@
         self.read("init_cs_ip", ">L", "Initial value of CS:IP registers.")
         self.read("reloc_offset", "<H", "Offset in file to relocation table.")
         self.read("overlay_number", ">H", "Overlay number")
-        self.read(None, ">4H", "Reserverd")
+        self.read("reserved", ">4H", "Reserverd")
         self.read("oem_id", ">H", "OEM id")
         self.read("oem_info", ">H", "OEM info")
-        self.read(None, "!10H", "Reserved")
+        self.read("reserved2", "!10H", "Reserved")
         self.read("pe_offset", "<L", "Offset to PE header")
 
 class ExeFile(Filter):
@@ -211,24 +208,18 @@
             self.readChild("pe_opt", PE_OptionnalHeader)
             self.readArray("pe_sections", PE_Section, "PE sections", self.checkEndOfSections)
 
-            # Look for resource section
-            self.pe_resources = []
-            return
-
             # TODO: Fix this ...
             
             offset_res_section = None
             for section in self.pe_sections:
+                section = section.getFilter()
                 if section.name == ".rsrc":
                     offset_res_section = section.file_offset
-                    self.stream.seek( offset_res_section )
+                    self.getStream().seek( offset_res_section )
                     break
             if offset_res_section != None:
-                self.openChild()
-                for i in range(1): #range(self.pe.nb_sections):
-                    self.newChild("PE resource header")            
-                    self.pe_resources.append( PE_ResourceDirectory(stream, self, offset_res_section) )
-                self.closeChild("PE resources header")            
+                #for i in range(1): #range(self.pe.nb_sections):
+                self.readChild("pe_resources", PE_ResourceDirectory)
         else:
             self.pe = None
 



From haypo at berlios.de  Thu Nov 17 21:34:49 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 17 Nov 2005 21:34:49 +0100
Subject: [Happyboom-svn] r255 - in haypo: . mediawiki
Message-ID: <200511172034.jAHKYnbc007699@sheep.berlios.de>

Author: haypo
Date: 2005-11-17 21:34:48 +0100 (Thu, 17 Nov 2005)
New Revision: 255

Added:
   haypo/mediawiki/
   haypo/mediawiki/import_pages.py
Log:
New program: python script to download pages.


Added: haypo/mediawiki/import_pages.py
===================================================================
--- haypo/mediawiki/import_pages.py	2005-11-16 01:28:09 UTC (rev 254)
+++ haypo/mediawiki/import_pages.py	2005-11-17 20:34:48 UTC (rev 255)
@@ -0,0 +1,114 @@
+#!/usr/bin/python
+# -*- coding: ISO-8859-1 -*-
+
+import sys, os, re, types
+#from elementtree.ElementTree import ElementTree
+from xml.dom.minidom import parseString
+from xml.dom.minidom import parseString
+from xml.parsers.expat import ParserCreate
+from xml import sax
+from subprocess import Popen, PIPE
+import urllib
+
+def usage():
+    print "Usage: %s import <base url>" % sys.argv[0]
+    print "    or %s export <base url>" % sys.argv[0]
+    print ""
+    print "Eg. of base url: http://www.haypocalc.com/wiki/"
+    print "    => will use http://www.haypocalc.com/wiki/Special:Allpages"
+    sys.exit(1)
+
+def escapeshellarg(arg):
+    # TODO (use os.<the right function>)
+    arg = arg.replace("\\", "\\\\").replace("'", "\\'")
+    return "'"+arg+"'"
+
+def warning(msg):
+    print msg
+
+def download(url, params={}):
+    params = urllib.urlencode(params)
+    f = urllib.urlopen(url, params)
+    return f.read()
+
+def getAllpages(url, namespace):
+    pages = download(url+"Special:Allpages", {"namespace": namespace})
+    if pages == None:
+        return None
+
+    # Work around MediaWiki 1.4 bug (don't escape "&" chararacter)
+    pages = re.sub("&([^a-zA-Z])", r"&amp;\1", pages)
+
+    xml = parseString(pages)
+    root = xml.documentElement
+    tables = root.getElementsByTagName('table')
+    assert len(tables) == 2
+    table = tables[1]
+    links = table.getElementsByTagName('a')
+    pages = []
+    for link in links:
+        page = link.getAttribute('href').encode("ASCII")
+        page = page.split("/")
+        pages.append( page[-1] )
+    return pages
+
+def cleanupUrl(url):
+    name = urllib.unquote(url)
+    if type(name) != types.UnicodeType:
+        name = unicode(name,"UTF-8")
+    return name.replace("_", " ")
+
+def importNamespace(url, dir, namespace, only_last):
+    print "Download list of pages ..."
+    pages = getAllpages(url, namespace)
+    if pages == None:
+        print "Error: Can't get list of pages."
+        sys.exit(1)
+    i = 1
+    for page in pages:
+        print "Download \"%s\" (%u/%u) ..." \
+                % (cleanupUrl(page), i, len(pages))
+        args = {"action": "submit", "pages": page}
+        if only_last:
+            args["curonly"] = "on"
+        data = download(url+"Special:Export", args)
+        if data == None:
+            error("Fail to download page \"%s\"." % page)
+            sys.exit(1)
+        filename = os.path.join(dir, page)
+        f = open(filename, 'w')
+        f.write(data)
+        f.close()
+#        print "  \--> saved into \"%s\"." % (filename) 
+        i = i + 1
+
+def importPages(url, only_last=False):
+    if url[-1] != "/":
+        url = url + "/"
+    dir = "pages"
+    try:
+      os.mkdir(dir)
+    except OSError, err:
+        if err[0] != 17:
+            raise
+    nb_namespace = 16            
+    for i in range(0,nb_namespace):    
+        print "================== Import namespace %u/%u ============== " \
+                % (i, nb_namespace-1)
+        importNamespace(url, dir, i, only_last)
+
+def exportPages(url):
+    print "TODO"
+
+def main():
+    if len(sys.argv) != 2:
+        usage()
+    url = sys.argv[1]
+    try:
+        importPages(url)
+    except KeyboardInterrupt:
+        print "Interrupted (CTRL+C): be carefull, download incomplete!"
+        sys.exit(1)
+
+if __name__=="__main__":
+    main()        


Property changes on: haypo/mediawiki/import_pages.py
___________________________________________________________________
Name: svn:executable
   + *



From haypo at berlios.de  Thu Nov 17 22:20:03 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 17 Nov 2005 22:20:03 +0100
Subject: [Happyboom-svn] r256 - haypo/mediawiki
Message-ID: <200511172120.jAHLK39D012427@sheep.berlios.de>

Author: haypo
Date: 2005-11-17 22:20:01 +0100 (Thu, 17 Nov 2005)
New Revision: 256

Modified:
   haypo/mediawiki/import_pages.py
Log:
Improve import_pages: Download all pages at same time instead of download
each page separatly.


Modified: haypo/mediawiki/import_pages.py
===================================================================
--- haypo/mediawiki/import_pages.py	2005-11-17 20:34:48 UTC (rev 255)
+++ haypo/mediawiki/import_pages.py	2005-11-17 21:20:01 UTC (rev 256)
@@ -23,6 +23,9 @@
     arg = arg.replace("\\", "\\\\").replace("'", "\\'")
     return "'"+arg+"'"
 
+def error(msg):
+    print msg
+
 def warning(msg):
     print msg
 
@@ -49,54 +52,63 @@
     for link in links:
         page = link.getAttribute('href').encode("ASCII")
         page = page.split("/")
-        pages.append( page[-1] )
+        page = urllib.unquote(page[-1])
+        if type(page) == types.UnicodeType:
+            page = page.encode("UTF-8")            
+        pages.append( page )
     return pages
 
-def cleanupUrl(url):
-    name = urllib.unquote(url)
-    if type(name) != types.UnicodeType:
-        name = unicode(name,"UTF-8")
-    return name.replace("_", " ")
-
 def importNamespace(url, dir, namespace, only_last):
-    print "Download list of pages ..."
+    print "Download document list."
     pages = getAllpages(url, namespace)
     if pages == None:
-        print "Error: Can't get list of pages."
+        print "Error: Can't get document list."
         sys.exit(1)
-    i = 1
-    for page in pages:
-        print "Download \"%s\" (%u/%u) ..." \
-                % (cleanupUrl(page), i, len(pages))
-        args = {"action": "submit", "pages": page}
-        if only_last:
-            args["curonly"] = "on"
-        data = download(url+"Special:Export", args)
-        if data == None:
-            error("Fail to download page \"%s\"." % page)
-            sys.exit(1)
-        filename = os.path.join(dir, page)
-        f = open(filename, 'w')
-        f.write(data)
-        f.close()
-#        print "  \--> saved into \"%s\"." % (filename) 
-        i = i + 1
+    if len(pages) == 0:
+        print "(empty)"
+        return
+    print "Download XML data (%u documents) ..." % len(pages)
+    args = { \
+        "action": "submit",
+        "pages": "\n".join(pages)
+    }
+    if only_last:
+        args["curonly"] = "on"
+    data = download(url+"Special:Export", args)
+    if data == None:
+        error("Fail to download namespace %s." % namespace)
+        sys.exit(1)
+    filename = os.path.join(dir, "namespace_%s.xml" % namespace)
+    f = open(filename, 'w')
+    f.write(data)
+    f.close()
 
 def importPages(url, only_last=False):
+    # Add "/" prefix to url if needed
     if url[-1] != "/":
         url = url + "/"
+
+    # Create pages/ if needed
     dir = "pages"
     try:
       os.mkdir(dir)
     except OSError, err:
         if err[0] != 17:
             raise
-    nb_namespace = 16            
-    for i in range(0,nb_namespace):    
-        print "================== Import namespace %u/%u ============== " \
-                % (i, nb_namespace-1)
-        importNamespace(url, dir, i, only_last)
 
+    # Which namespaces have to be downloaded?
+    namespaces = range(0,16)
+    namespaces.remove(8) # MediaWiki
+    namespaces.remove(9) # Talk:MediaWiki
+    
+    # Download each namespace
+    i = 1
+    for namespace in namespaces: 
+        print "================== Import namespace %u (%u/%u) ============== " \
+                % (namespace, i, len(namespaces))
+        importNamespace(url, dir, namespace, only_last)
+        i = i + 1
+
 def exportPages(url):
     print "TODO"
 



From haypo at berlios.de  Mon Nov 21 22:46:49 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 21 Nov 2005 22:46:49 +0100
Subject: [Happyboom-svn] r257 - greycstoration_gimp
Message-ID: <200511212146.jALLknvk020762@sheep.berlios.de>

Author: haypo
Date: 2005-11-21 22:46:49 +0100 (Mon, 21 Nov 2005)
New Revision: 257

Modified:
   greycstoration_gimp/dialog.cpp
   greycstoration_gimp/greycstoration.cpp
   greycstoration_gimp/image.cpp
   greycstoration_gimp/main.cpp
Log:
Commit patch of Thomas de Grenier de Latour (first part).


Modified: greycstoration_gimp/dialog.cpp
===================================================================
--- greycstoration_gimp/dialog.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ greycstoration_gimp/dialog.cpp	2005-11-21 21:46:49 UTC (rev 257)
@@ -17,17 +17,18 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "plugin-intl.h"
+
 #include <stdio.h>
 
 #include "dialog.h"
 //----------------------------------------------------------------------------
-
-// Future gettext use
-#define _(X) X
-
 #include "image.h"
 #include "greycstoration.h"
-#include "plug_in.h"
 #include <libgimp/gimp.h>
 #include <libgimp/gimpui.h>
 #include <gtk/gtk.h>
@@ -127,7 +128,7 @@
 	TABLE_SCALE(1, _("_Gradient factor (p2):"), float, params.power2, 0, 100, 0.1, 1, SCALE_DIGITS);
 	TABLE_SCALE(2, _("_Time step (dt):"), float, params.dt, 1, 300, 10, 25, SCALE_DIGITS);
 	TABLE_SCALE(3, _("_Blur (sigma):"), float, params.sigma, 0, 10, 0.2, 1, SCALE_DIGITS);
-	TABLE_SCALE(4, _("_Blur iterations (iter) :"), int, params.nb_iter, 1, 5, 1, 2, 0);
+	TABLE_SCALE(4, _("Blur _iterations (iter) :"), int, params.nb_iter, 1, 5, 1, 2, 0);
 }
 
 void dialog_page2 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
@@ -182,12 +183,12 @@
 	GtkWidget *main_vbox;
 
 	// New dialog
-	gimp_ui_init (PLUG_IN_NAME, false);
+	gimp_ui_init (PLUGIN_NAME, false);
 	dialog = gimp_dialog_new(
 			_("GREYCstoration"), 
-			PLUG_IN_NAME,
+			PLUGIN_NAME,
 			NULL, (GtkDialogFlags)0,
-			gimp_standard_help_func, "plug-in-" PLUG_IN_NAME,
+			gimp_standard_help_func, "plug-in-" PLUGIN_NAME,
 			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
 			GTK_STOCK_OK,     GTK_RESPONSE_OK,
 			NULL);

Modified: greycstoration_gimp/greycstoration.cpp
===================================================================
--- greycstoration_gimp/greycstoration.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ greycstoration_gimp/greycstoration.cpp	2005-11-21 21:46:49 UTC (rev 257)
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "greycstoration.h"
 //----------------------------------------------------------------------------
 using namespace cimg_library;

Modified: greycstoration_gimp/image.cpp
===================================================================
--- greycstoration_gimp/image.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ greycstoration_gimp/image.cpp	2005-11-21 21:46:49 UTC (rev 257)
@@ -17,6 +17,10 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "image.h"
 //----------------------------------------------------------------------------
 

Modified: greycstoration_gimp/main.cpp
===================================================================
--- greycstoration_gimp/main.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ greycstoration_gimp/main.cpp	2005-11-21 21:46:49 UTC (rev 257)
@@ -17,8 +17,12 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "plugin-intl.h"
+
 #include <libgimp/gimp.h>
-#include "plug_in.h"
 #include "dialog.h"
 #include "greycstoration.h"
 #include <unistd.h>
@@ -72,7 +76,7 @@
 	};
 	gimp_install_procedure (
 			"plug_in_hello",
-			PLUG_IN_NAME,
+			PLUGIN_NAME,
 			"Filtre Greystoration",
 			"Victor STINNER",
 			"Copyright Victor STINNER",
@@ -99,6 +103,13 @@
 	   non-interactive */
 	nice(19);
 
+	/*  Initialize i18n support  */
+	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
+#ifdef HAVE_BIND_TEXTDOMAIN_CODESET
+	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+#endif
+	textdomain (GETTEXT_PACKAGE);
+
 	/* Mise en place d'une valeur obligatoire de retour */
 	*nreturn_vals = 1;
 	*return_vals = values;
@@ -112,9 +123,9 @@
 	switch (image.run_mode)
 	{
 		case GIMP_RUN_INTERACTIVE:
-			gimp_get_data("plug_in_" PLUG_IN_NAME, &greyc_params);
+			gimp_get_data("plug_in_" PLUGIN_NAME, &greyc_params);
 			if (!dialog(greyc_params, drawable)) return;
-			gimp_set_data("plug_in_" PLUG_IN_NAME, &greyc_params, sizeof(greyc_params));
+			gimp_set_data("plug_in_" PLUGIN_NAME, &greyc_params, sizeof(greyc_params));
 			break;
 			
 		case GIMP_RUN_NONINTERACTIVE:
@@ -122,7 +133,7 @@
 			break;
 
 		case GIMP_RUN_WITH_LAST_VALS:
-			gimp_get_data("plug_in_" PLUG_IN_NAME, &greyc_params);
+			gimp_get_data("plug_in_" PLUGIN_NAME, &greyc_params);
 			break;
 		default: return;
 	}



From haypo at berlios.de  Tue Nov 22 00:03:10 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 22 Nov 2005 00:03:10 +0100
Subject: [Happyboom-svn] r259 - in greycstoration_gimp: . po src
Message-ID: <200511212303.jALN3Ao2026920@sheep.berlios.de>

Author: haypo
Date: 2005-11-22 00:03:09 +0100 (Tue, 22 Nov 2005)
New Revision: 259

Added:
   greycstoration_gimp/po/
   greycstoration_gimp/po/POTFILES.in
   greycstoration_gimp/po/fr.po
   greycstoration_gimp/src/Makefile.am
   greycstoration_gimp/src/plugin-intl.h
Removed:
   greycstoration_gimp/src/Makefile
Log:
Commit autotools patch (last part?).


Added: greycstoration_gimp/po/POTFILES.in
===================================================================
--- greycstoration_gimp/po/POTFILES.in	2005-11-21 22:57:19 UTC (rev 258)
+++ greycstoration_gimp/po/POTFILES.in	2005-11-21 23:03:09 UTC (rev 259)
@@ -0,0 +1,3 @@
+# List of source files containing translatable strings.
+
+src/dialog.cpp

Added: greycstoration_gimp/po/fr.po
===================================================================
--- greycstoration_gimp/po/fr.po	2005-11-21 22:57:19 UTC (rev 258)
+++ greycstoration_gimp/po/fr.po	2005-11-21 23:03:09 UTC (rev 259)
@@ -0,0 +1,77 @@
+# translation of GIMP GREYCstroration Plug-In.
+# Copyright (C) 2005 THE GIMP GREYCstroration Plug-In'S COPYRIGHT HOLDER
+# This file is distributed under the same license as the GIMP GREYCstroration Plug-In package.
+# <>, 2005.
+# , fuzzy
+#  <>, 2005.
+# 
+# 
+msgid ""
+msgstr ""
+"Project-Id-Version: GIMP GREYCstroration Plug-In 0.1.2\n"
+"Report-Msgid-Bugs-To: \n"
+"POT-Creation-Date: 2005-11-21 17:50+0100\n"
+"PO-Revision-Date: 2005-11-21 16:18+0100\n"
+"Last-Translator: Thomas de Grenier de Latour (TGL) <degrenier at easyconnect>\n"
+"Language-Team: French <gnomefr at traduc.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#. Insert table in a new notebook page
+#: ../src/dialog.cpp:122
+msgid "Restore"
+msgstr "Restauration"
+
+#. Power1
+#: ../src/dialog.cpp:127
+msgid "_Detail factor (p1):"
+msgstr "Facteur de _d?tails (p1) :"
+
+#: ../src/dialog.cpp:128
+msgid "_Gradient factor (p2):"
+msgstr "Facteur de _gradiant (p2) :"
+
+#: ../src/dialog.cpp:129
+msgid "_Time step (dt):"
+msgstr "Intervale de _temps (dt) :"
+
+#: ../src/dialog.cpp:130
+msgid "_Blur (sigma):"
+msgstr "_Flou (sigma) :"
+
+#: ../src/dialog.cpp:131
+msgid "Blur _iterations (iter) :"
+msgstr "_It?rations de flou (iter) :"
+
+#. New vbox
+#: ../src/dialog.cpp:141
+msgid "Quality"
+msgstr "Qualit?"
+
+#. linear checkbox
+#: ../src/dialog.cpp:147
+msgid "Use linear interpolation:"
+msgstr "Utiliser une interpolation lin?aire :"
+
+#. normalize checkbox
+#: ../src/dialog.cpp:153
+msgid "Normalize picture to [0-255]:"
+msgstr "Normaliser l'image dans [0-255] :"
+
+#. Insert parameters into the table
+#: ../src/dialog.cpp:170
+msgid "_Angular step (da):"
+msgstr "Pas _angulaire (da) :"
+
+#: ../src/dialog.cpp:171
+msgid "_Integral step (dt):"
+msgstr "Pas d'_int?gration (dt) :"
+
+#: ../src/dialog.cpp:172
+msgid "_Gaussian precision (gauss):"
+msgstr "Pr?cision _gaussienne (gauss) :"
+
+#: ../src/dialog.cpp:188
+msgid "GREYCstoration"
+msgstr "GREYCstoration"

Deleted: greycstoration_gimp/src/Makefile
===================================================================
--- greycstoration_gimp/src/Makefile	2005-11-21 22:57:19 UTC (rev 258)
+++ greycstoration_gimp/src/Makefile	2005-11-21 23:03:09 UTC (rev 259)
@@ -1,36 +0,0 @@
-# Common arguments
-CXXFLAGS=-Wall -O3 -ffast-math
-SRC=image.cpp greycstoration.cpp dialog.cpp main.cpp
-
-# C++ compiler
-CXX=g++
-
-# pkg-config modules needed
-MODULES=gimp-2.0 gimpui-2.0 gtk+-2.0
-CXXFLAGS+=$(shell pkg-config $(MODULES) --cflags)
-LIBS=$(shell pkg-config $(MODULES) --libs)
-
-# Don't use CImg interface (keyboard/mouse interaction)
-CXXFLAGS+=-Dcimg_OS=-1 -Dcimg_display_type=0 
-
-# And others variables ...
-PROG=greycstoration
-OBJECTS=$(patsubst %.cpp,%.o,$(SRC))
-GIMPTOOL=gimptool-2.0
-
-$(PROG): $(OBJECTS)
-	@echo "Linking ..."
-	@$(CXX) -o $(PROG) $(OBJECTS) $(CXXFLAGS) $(LIBS)
-	
-%.o: %.cpp
-	@echo "Compile $@"
-	@$(CXX) -c -o $@ $< $(CXXFLAGS)
-	
-install: $(PROG)
-	$(GIMPTOOL) --install-bin $(PROG)
-	
-uninstall:
-	$(GIMPTOOL) --uninstall-bin $(PROG)
-
-clean:
-	rm -f $(PROG) $(OBJECTS)

Copied: greycstoration_gimp/src/Makefile.am (from rev 258, greycstoration_gimp/src/Makefile)
===================================================================
--- greycstoration_gimp/src/Makefile	2005-11-21 22:57:19 UTC (rev 258)
+++ greycstoration_gimp/src/Makefile.am	2005-11-21 23:03:09 UTC (rev 259)
@@ -0,0 +1,27 @@
+bin_PROGRAMS = greycstoration
+
+bindir = $(GIMP_LIBDIR)/plug-ins
+
+greycstoration_SOURCES = \
+	plugin-intl.h \
+	CImg.h \
+	dialog.h \
+	dialog.cpp \
+	greycstoration.h \
+	greycstoration.cpp \
+	image.h \
+	image.cpp \
+	main.h \
+	main.cpp
+
+AM_CPPFLAGS = \
+	-Dcimg_OS=-1 \
+	-Dcimg_display_type=0 \
+	-DLOCALEDIR=\""$(LOCALEDIR)"\"
+
+INCLUDES = \
+	-I$(top_srcdir) \
+	@GIMP_CFLAGS@ \
+	-I$(includedir)
+
+LDADD = $(GIMP_LIBS)

Added: greycstoration_gimp/src/plugin-intl.h
===================================================================
--- greycstoration_gimp/src/plugin-intl.h	2005-11-21 22:57:19 UTC (rev 258)
+++ greycstoration_gimp/src/plugin-intl.h	2005-11-21 23:03:09 UTC (rev 259)
@@ -0,0 +1,45 @@
+/* plugin-intl.h
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Author of the
+ * Software shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the Author.
+ */
+
+#ifndef __PLUGIN_INTL_H__
+#define __PLUGIN_INTL_H__
+
+
+#ifndef GETTEXT_PACKAGE
+#error "config.h must be included prior to plugin-intl.h"
+#endif
+
+#include <libintl.h>
+
+#define _(String) gettext (String)
+
+#ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#else
+#    define N_(String) (String)
+#endif
+
+
+#endif /* __PLUGIN_INTL_H__ */



From haypo at berlios.de  Tue Nov 22 00:15:19 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 22 Nov 2005 00:15:19 +0100
Subject: [Happyboom-svn] r260 - haypo/mediawiki
Message-ID: <200511212315.jALNFJGd028084@sheep.berlios.de>

Author: haypo
Date: 2005-11-22 00:15:18 +0100 (Tue, 22 Nov 2005)
New Revision: 260

Modified:
   haypo/mediawiki/import_pages.py
Log:
Improve import.


Modified: haypo/mediawiki/import_pages.py
===================================================================
--- haypo/mediawiki/import_pages.py	2005-11-21 23:03:09 UTC (rev 259)
+++ haypo/mediawiki/import_pages.py	2005-11-21 23:15:18 UTC (rev 260)
@@ -4,7 +4,6 @@
 import sys, os, re, types
 #from elementtree.ElementTree import ElementTree
 from xml.dom.minidom import parseString
-from xml.dom.minidom import parseString
 from xml.parsers.expat import ParserCreate
 from xml import sax
 from subprocess import Popen, PIPE
@@ -18,109 +17,159 @@
     print "    => will use http://www.haypocalc.com/wiki/Special:Allpages"
     sys.exit(1)
 
-def escapeshellarg(arg):
-    # TODO (use os.<the right function>)
-    arg = arg.replace("\\", "\\\\").replace("'", "\\'")
-    return "'"+arg+"'"
-
 def error(msg):
     print msg
 
 def warning(msg):
     print msg
 
-def download(url, params={}):
-    params = urllib.urlencode(params)
-    f = urllib.urlopen(url, params)
-    return f.read()
+class Importer:
+    def __init__(self, base_url):
+        # Add "/" prefix to url if needed
+        if base_url[-1] != "/":
+            self.base_url = base_url+"/"
+        else:
+            self.base_url = base_url
 
-def getAllpages(url, namespace):
-    pages = download(url+"Special:Allpages", {"namespace": namespace})
-    if pages == None:
-        return None
+        self.only_last = False
+        self.dir = "pages"
+        self.use_gzip = True
+        self.max_per_file = 200 
+        
+    def download(self, page, params={}):
+        params = urllib.urlencode(params)
+        f = urllib.urlopen(self.base_url+page, params)
+        return f.read()
 
-    # Work around MediaWiki 1.4 bug (don't escape "&" chararacter)
-    pages = re.sub("&([^a-zA-Z])", r"&amp;\1", pages)
+    def getAllpages(self, namespace):
+        pages = self.download("Special:Allpages", {"namespace": namespace})
+        if pages == None:
+            return None
 
-    xml = parseString(pages)
-    root = xml.documentElement
-    tables = root.getElementsByTagName('table')
-    assert len(tables) == 2
-    table = tables[1]
-    links = table.getElementsByTagName('a')
-    pages = []
-    for link in links:
-        page = link.getAttribute('href').encode("ASCII")
-        page = page.split("/")
-        page = urllib.unquote(page[-1])
-        if type(page) == types.UnicodeType:
-            page = page.encode("UTF-8")            
-        pages.append( page )
-    return pages
+        # Work around MediaWiki 1.4 bug (don't escape "&" chararacter)
+        pages = re.sub("&([^a-zA-Z])", r"&amp;\1", pages)
 
-def importNamespace(url, dir, namespace, only_last):
-    print "Download document list."
-    pages = getAllpages(url, namespace)
-    if pages == None:
-        print "Error: Can't get document list."
-        sys.exit(1)
-    if len(pages) == 0:
-        print "(empty)"
-        return
-    print "Download XML data (%u documents) ..." % len(pages)
-    args = { \
-        "action": "submit",
-        "pages": "\n".join(pages)
-    }
-    if only_last:
-        args["curonly"] = "on"
-    data = download(url+"Special:Export", args)
-    if data == None:
-        error("Fail to download namespace %s." % namespace)
-        sys.exit(1)
-    filename = os.path.join(dir, "namespace_%s.xml" % namespace)
-    f = open(filename, 'w')
-    f.write(data)
-    f.close()
+        xml = parseString(pages)
+        root = xml.documentElement
+        tables = root.getElementsByTagName('table')
+        assert len(tables) == 2
+        table = tables[1]
+        links = table.getElementsByTagName('a')
+        pages = []
+        for link in links:
+            page = link.getAttribute('href').encode("ASCII")
+            page = page.split("/")
+            page = urllib.unquote(page[-1])
+            if type(page) == types.UnicodeType:
+                page = page.encode("UTF-8")            
+            pages.append( page )
+        return pages
 
-def importPages(url, only_last=False):
-    # Add "/" prefix to url if needed
-    if url[-1] != "/":
-        url = url + "/"
+    def savePages(self, namespace, part, content):
+        if part != None:
+            filename = "namespace_%s_part%u.xml" % (namespace, part)
+        else:
+            filename = "namespace_%s.xml" % namespace
+        filename = os.path.join(self.dir, filename)
+        if self.use_gzip:
+            filename = filename + ".gz"
+            f = GzipFile(filename, 'w')
+            f.write(content)
+            f.close()
+        else:
+            f = open(filename, 'w')
+            f.write(content)
+            f.close()
+        print "saved to %s" % (filename)
 
-    # Create pages/ if needed
-    dir = "pages"
-    try:
-      os.mkdir(dir)
-    except OSError, err:
-        if err[0] != 17:
-            raise
+    def importPages(self, namespace, pages, part):
+        args = { \
+            "action": "submit",
+            "pages": "\n".join(pages)
+        }
+        if self.only_last:
+            args["curonly"] = "on"
+        data = self.download("Special:Export", args)
+        if data == None:
+            error("Fail to download namespace %s." % namespace)
+            sys.exit(1)
+        self.savePages(namespace, part, data)
 
-    # Which namespaces have to be downloaded?
-    namespaces = range(0,16)
-    namespaces.remove(8) # MediaWiki
-    namespaces.remove(9) # Talk:MediaWiki
-    
-    # Download each namespace
-    i = 1
-    for namespace in namespaces: 
-        print "================== Import namespace %u (%u/%u) ============== " \
-                % (namespace, i, len(namespaces))
-        importNamespace(url, dir, namespace, only_last)
-        i = i + 1
+    def importNamespace(self,  namespace):
+        print "Download document list."
+        pages = self.getAllpages(namespace)
+        if pages == None:
+            print "Error: Can't get document list."
+            sys.exit(1)
+        if len(pages) == 0:
+            print "(empty)"
+            return
+        part = 1
+        position = 1
+        total = len(pages)
+        while len(pages) != 0:
+            if self.max_per_file != 0:
+                sub = pages[:self.max_per_file]
+                pages = pages[self.max_per_file:]
+            else:
+                sub = pages
+                pages = []
+            sys.stdout.write("Download document(s) %u..%u / %u ... " \
+                 % (position, position+len(sub)-1, total))
+            sys.stdout.flush()
+            try:
+                if total != len(sub):
+                    self.importPages(namespace, sub, part)
+                    part = part + 1
+                    position = position + len(sub)
+                else:
+                    part = None
+                    self.importPages(namespace, sub, part)
+            except:
+                sys.stdout.write("ERROR!\n\n")
+                raise
 
-def exportPages(url):
-    print "TODO"
+    def doImport(self):
+        # Which namespaces have to be downloaded?
+        namespaces = range(0,16)
+        namespaces.remove(8) # MediaWiki
+        namespaces.remove(9) # Talk:MediaWiki
 
-def main():
-    if len(sys.argv) != 2:
-        usage()
-    url = sys.argv[1]
-    try:
-        importPages(url)
-    except KeyboardInterrupt:
-        print "Interrupted (CTRL+C): be carefull, download incomplete!"
-        sys.exit(1)
+        # Sum up before starting
+        print "Base url: %s" % (self.base_url)
+        print "Store into gzip: %s" % (self.use_gzip)
+        print "Max documents/file: %s" % (self.max_per_file)
 
-if __name__=="__main__":
-    main()        
+        # Create pages/ if needed
+        if not os.access(self.dir, os.F_OK):
+            print "Create subdirectory %s" % (self.dir)
+            os.mkdir(self.dir)
+        print ""
+        
+        # Download each namespace
+        i = 1
+        for namespace in namespaces: 
+            namespace = 6
+            print "================== Import namespace %u (%u/%u) ============== " \
+                    % (namespace, i, len(namespaces))
+            self.importNamespace(namespace)
+            return
+            i = i + 1
+
+if len(sys.argv) != 2:
+    usage()
+base_url = sys.argv[1]
+try:
+    from gzip import GzipFile
+    use_gzip = True
+except ImportError:
+    warning("Can't load gzip module.")
+    use_gzip = False
+try:
+    my = Importer(base_url)
+    my.use_gzip = use_gzip
+    my.doImport()
+except KeyboardInterrupt:
+    print "Interrupted (CTRL+C): be carefull, download incomplete!"
+    sys.exit(1)
+print ""    



From haypo at berlios.de  Wed Nov 23 02:51:34 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 23 Nov 2005 02:51:34 +0100
Subject: [Happyboom-svn] r262 - haypo/hachoir
Message-ID: <200511230151.jAN1pYaf017841@sheep.berlios.de>

Author: haypo
Date: 2005-11-23 02:51:32 +0100 (Wed, 23 Nov 2005)
New Revision: 262

Added:
   haypo/hachoir/mime.py
Log:
Add mime.py (may be used later)


Added: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-21 23:33:10 UTC (rev 261)
+++ haypo/hachoir/mime.py	2005-11-23 01:51:32 UTC (rev 262)
@@ -0,0 +1,29 @@
+#!/usr/bin/python
+import os, stat
+
+instance = None
+
+def getInstance():
+    global instance
+    if instance == None:
+        import magic
+        instance = magic.open(magic.MAGIC_MIME)
+        instance.load()
+    return instance
+
+def getFileMime(filename):
+    mode = os.stat(filename)[stat.ST_MODE]
+    if stat.S_ISDIR(mode):
+        return "Directory"
+    if stat.S_ISLNK(mode):
+        return "Link"
+    
+    f = file(filename, "rb")
+    buffer = f.read(4096)
+    f.close()
+    return getBufferMime(buffer)
+
+def getBufferMime(buffer):
+    magic = getInstance()
+    type = magic.buffer(buffer)
+    return type



From haypo at berlios.de  Wed Nov 23 03:36:35 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 23 Nov 2005 03:36:35 +0100
Subject: [Happyboom-svn] r263 - in haypo/hachoir: . broken_plugins plugins
Message-ID: <200511230236.jAN2aZS1019388@sheep.berlios.de>

Author: haypo
Date: 2005-11-23 03:36:34 +0100 (Wed, 23 Nov 2005)
New Revision: 263

Added:
   haypo/hachoir/broken_plugins/
   haypo/hachoir/broken_plugins/ncftp.py
   haypo/hachoir/release.sh
Removed:
   haypo/hachoir/plugins/ncftp.py
Modified:
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/mime.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/exe.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/jpeg.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/plugins/zip.py
Log:
Gzip and tar begin to be able to split sub-files (file compressed in gz/tar).


Copied: haypo/hachoir/broken_plugins/ncftp.py (from rev 260, haypo/hachoir/plugins/ncftp.py)

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/hachoir_class.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -1,5 +1,5 @@
 from stream import FileStream
-from plugin import getPlugin
+from plugin import getPluginByFile
 from chunk import FilterChunk
 from default import DefaultFilter
 from user_filter import UserFilterDescriptor, loadUserFilter
@@ -82,28 +82,24 @@
             return
 
         # Look for a plugin
-        plugin = getPlugin(filename)
-        if plugin == None:
-            regex, plugin_name, split_func, display_func = None, "default", DefaultFilter, None
+        plugin = getPluginByFile(filename)
+        if plugin != None:
+            split_class = plugin
         else:
-            regex, plugin_name, split_func, display_func = plugin
+            split_class = DefaultFilter
             
         # Split 
         try:
-            filter = split_func(stream)
+            filter = split_class(stream)
         except Exception, msg:
-            error("Exception while processing file %s with filter %s:\n%s\n%s" \
-                % (filename, plugin_name, msg, getBacktrace()))
-            display_func = None
+            error("Exception while processing file %s:\n%s\n%s" \
+                % (filename, msg, getBacktrace()))
             stream.seek(0)
             filter = DefaultFilter(stream)
         self.main_filter = self.filter = filter
         self._addPadding()
         self.filter.display()
 
-        # Display
-        if self.display and display_func != None:
-            display_func(self.filter)
         self.ui.window.updateToolbar()
 
     def loadScript(self, filename):

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/mime.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -26,4 +26,4 @@
 def getBufferMime(buffer):
     magic = getInstance()
     type = magic.buffer(buffer)
-    return type
+    return type.split(",")

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugin.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -1,14 +1,42 @@
 import re
+from mime import getFileMime, getBufferMime
 
-def getPlugin(filename):
+def guessPlugin(stream):
+    oldpos = stream.tell()
+    buffer = stream.getN(4096)
+    plugin = getPluginByBuffer(buffer)
+    stream.seek(oldpos)
+    return plugin
+
+def getPluginByMime(mime):
     global hachoir_plugins
-    for plugin in hachoir_plugins:
-        if plugin[0].match(filename) != None: return plugin
-    return None
+    mime = mime[0]
+    if mime not in hachoir_plugins:
+        return None
+    plugins = hachoir_plugins[mime]
+    if 1<len(plugins):
+        warning("More than one plugin have same MIME...")
+    return plugins[0]       
     
-def registerPlugin(regex, name, splitFunc, displayFunc):
+def getPluginByBuffer(buffer):
+    mime = getBufferMime(buffer)
+    return getPluginByMime(mime)
+
+def getPluginByStream(stream):
+    stream.seek(0)
+    data = stream.getN(4096)
+    mime = getBufferMime(data)
+    return getPluginByMime(mime)
+
+def getPluginByFile(filename):
+    mime = getFileMime(filename)
+    return getPluginByMime(mime)
+    
+def registerPlugin(filter_class, mime):
     global hachoir_plugins
-    regex = re.compile(regex)
-    hachoir_plugins.append( (regex, name, splitFunc, displayFunc,) )
+    if mime in hachoir_plugins:
+        hachoir_plugins[mime].append(filter_class)
+    else:
+        hachoir_plugins[mime] = [filter_class]
 
-hachoir_plugins = [] 
+hachoir_plugins = {} 

Modified: haypo/hachoir/plugins/exe.py
===================================================================
--- haypo/hachoir/plugins/exe.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/exe.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -196,8 +196,8 @@
         self.read("pe_offset", "<L", "Offset to PE header")
 
 class ExeFile(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "exe_file", "EXE file", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "exe_file", "EXE file", stream, parent)
 
         self.readChild("ms_dos", MS_Dos)
 
@@ -226,4 +226,4 @@
     def checkEndOfSections(self, stream, array, section):
         return len(array) == self.pe.nb_sections
 
-registerPlugin("^.*\.(exe|EXE)$", "MS-Dos / Windows executable filter", ExeFile, displayExe)
+registerPlugin(ExeFile, "application/x-dosexec")

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/gif.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -9,16 +9,6 @@
 from plugin import registerPlugin
 from error import warning
 
-def displayGif(gif):
-    print "Format: %s" % (gif.header)
-    print "Size: %ux%u" % (gif.screen.width, gif.screen.height)
-    print "Colormap: %s" % (gif.color_map)
-    i = 0
-    for image in gif.images:
-        image = image.getFilter()
-        print "Image %u: %s" % (i, image)
-        i = i + 1
-
 class GifColor(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "gif_color", "GIF color (RGB)", stream, parent)
@@ -109,8 +99,8 @@
         return text + "color res=%u, bits/pixel=%u" % (self.color_res, self.bits_per_pixel)
         
 class GifFile(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "gif_file", "GIF picture file", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "gif_file", "GIF picture file", stream, parent)
         # Header
         self.read("header", "6s", "File header")
         assert (self.header == "GIF87a") or (self.header == "GIF89a")
@@ -138,4 +128,4 @@
             else:
                 raise Exception("Wrong GIF image separator: ASCII %02X." % ord(code))
 
-registerPlugin("^.*\.(gif|GIF)$", "GIF picture", GifFile, displayGif)
+registerPlugin(GifFile, "image/gif")

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/gzip.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -9,7 +9,9 @@
 from filter import Filter
 from plugin import registerPlugin
 from gunzip_stream import GunzipStream
-from plugins.tar import TarFile
+from plugin import getPluginByStream
+from error import error
+from default import DefaultFilter
    
 class GunzipFilter(Filter):
     def __init__(self, stream, parent, start, size, filter_class):
@@ -55,11 +57,22 @@
         if self.flags & 2 == 2:
             self.readString("crc16", "!H", "CRC16")
 
+        oldpos = stream.tell()
+        size = stream.getSize() - oldpos - 8
+        try:
+            # TODO: Fix this fucking GunzipStream (use something better)
+            stream.seek(0)
+            data = stream.getN(stream.getSize())
+            stream = GunzipStream(data)
+            stream.seek(oldpos)
+            plugin = getPluginByStream(stream)
+            # END OF TODO
 
-
-        size = stream.getSize() - stream.tell() - 8
-#        self.read("data", "!%us" % size, "Compressed data", truncate=True)
-        self.readChild("data", GunzipFilter, stream.tell(), size, TarFile) 
+            self.readChild("data", GunzipFilter, oldpos, size, plugin) 
+        except Exception, msg:
+            error("Error while processing file in gzip: %s" % msg)
+            stream.seek(oldpos)
+            self.read("data", "!%us" % size, "Compressed data", truncate=True)
         
         self.read("crc32", "<L", "CRC32")
         self.read("size", "<L", "Uncompressed size")
@@ -103,4 +116,4 @@
         val = chunk.value
         return os.get(val, "Unknow (%s)" % val)
         
-registerPlugin("^.*\.gz$", "GZIP archive file", GzipFile, None)
+registerPlugin(GzipFile, "application/octet-stream")

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/jpeg.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -65,11 +65,11 @@
         if chunk != None and chunk.header[1] == 0xDA: return True
         return stream.eof()
 
-    def __init__(self, stream):
-        Filter.__init__(self, "jpeg_file", "JPEG file", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "jpeg_file", "JPEG file", stream, parent)
         self.read("header", "!2B", "Header \"start of image\" (0xFF, 0xD8)")
         assert self.header == (0xFF, 0xD8)
         self.readArray("chunk", JpegChunk, "Chunks", self.checkEndOfChunks)
         self.read("data", "!{@end@}s", "JPEG data")
         
-registerPlugin("^.*\.(jpg|jpeg|JPG|JPEG)$", "JPEG picture", JpegFile, None)
+registerPlugin(JpegFile, "image/jpeg")

Deleted: haypo/hachoir/plugins/ncftp.py
===================================================================
--- haypo/hachoir/plugins/ncftp.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/ncftp.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -1,50 +0,0 @@
-"""
-Ncftp bookmarks filter.
-
-Status: Read most import fields.
-Author: Victor Stinner
-"""
-
-import re, base64
-from filter import Filter
-from plugin import registerPlugin
-from stream import LimitedFileStream
-
-def displayNcftp(data):
-    print "Ncftp saved bookmarks:"
-    for bc in data.bookmarks:
-        b = bc.getFilter()
-        print "o %s (port %s): u=%s, p=\"%s\"" % \
-            (b.server, b.port, b.username, b.password)
-
-class NcftpBookmark(Filter):
-    def __init__(self, stream, parent):
-        Filter.__init__(self, "ncftp_bookmark", "NCFTP bookmark", stream, parent)
-        self.readField("name", "Bookmark name", ",")
-        self.readField("server", "Server name/ip", ",")
-        self.readField("username", "Username", ",")
-        self.readField("password", "Password", ",")
-        self.readField("notused1", "Not used (1)", ",")
-        self.readField("last_dir", "Last directory", ",")
-        self.readField("notused", "Not used?", ",")
-        self.readField("port", "Server port", ",")
-        self.readLine("eol", "End of line", "\n")
-        self.password = self.crackPass(self.password)
-        
-    def crackPass(self, password):
-        m = re.compile("^\*encoded\*(.*)$").match(password)
-        if m == None: return password
-        password = base64.decodestring(m.group(1))
-        return password.strip("\0")
-
-class NcftpFile(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "ncftp_file", "NCFTP bookmark file", stream, None)
-        self.readLine("header", "Header (first line")
-        self.readLine("nb_bookmark", "Number of bookmarks")
-        self.readArray("bookmarks", NcftpBookmark, "Bookmarks", self.checkEOF)
-
-    def checkEOF(self, stream, array, bookmark):
-        return stream.eof()
-
-registerPlugin("^.*bookmarks$", "NcFTP bookmarks", NcftpFile, displayNcftp)

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/pdf.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -137,4 +137,4 @@
                 print getBacktrace()
                 return
 
-registerPlugin("^.*\.(PDF|pdf)$", "PDF document file", PdfFile, None)
+registerPlugin(PdfFile, "application/pdf")

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/png.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -90,8 +90,8 @@
     Split a PNG file into chunks.
     """
 
-    def __init__(self, stream):
-        Filter.__init__(self, "png_file", "PNG file", stream, None)
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "png_file", "PNG file", stream, parent)
         self.read("header", "!8s", "File header")
         assert self.header == "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"
         self.readArray("chunks", PngChunk, "Png chunks", self.checkEndOfChunks)
@@ -127,4 +127,4 @@
     def __str__(self):
         return "PngChunk <size=%u, type=%s>" % (self.size, self.type)
 
-registerPlugin("^.*\.(PNG|png)$", "PNG picture", PngFile, displayPng)
+registerPlugin(PngFile, "image/png")

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/tar.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -11,6 +11,8 @@
 from plugin import registerPlugin
 from tools import convertDataToPrintableString
 from default import EmptyFilter
+from plugin import guessPlugin 
+from error import error
 
 def displayModeItem(mode):
     if mode & 4 == 4: r="r"
@@ -94,9 +96,22 @@
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
-            chunk = self.readChild("filedata", EmptyFilter)
-            filter = chunk.getFilter()
-            filter.read("filedata", "!%us" % self.size, "File data", truncate=True)
+            plugin = guessPlugin(stream)
+            ok = False
+            if plugin != None:
+                oldpos = stream.tell()
+                try:
+                    # TODO: Fix child stream start & end (size)
+                    chunk = self.readChild("filedata", plugin)
+                    ok = True
+                except Exception, msg:
+                    error("Error while processing tar file: %s" % msg)
+                    stream.seek(oldpos)
+
+            if not ok:
+                chunk = self.readChild("filedata", EmptyFilter)
+                filter = chunk.getFilter()
+                filter.read("filedata", "!%us" % self.size, "File data", truncate=True)
         if stream.tell() % 512 != 0:
             padding = 512 - stream.tell() % 512
             self.read("padding", "!%ss" % padding, "Padding (512 align)", truncate=True)
@@ -150,4 +165,4 @@
             if file.isEmpty(): return True
         return stream.eof()
         
-registerPlugin("^.*\.tar$", "Tar archive", TarFile, None)
+registerPlugin(TarFile, "application/x-tar")

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/plugins/zip.py	2005-11-23 02:36:34 UTC (rev 263)
@@ -112,4 +112,4 @@
             else:
                 raise Exception("Error, unknow ZIP header (0x%08X)." % header)
         
-registerPlugin("^.*\.(zip|ZIP)$", "ZIP (compressed archive)", ZipFile, displayZip)
+registerPlugin(ZipFile, "application/x-zip")

Added: haypo/hachoir/release.sh
===================================================================
--- haypo/hachoir/release.sh	2005-11-23 01:51:32 UTC (rev 262)
+++ haypo/hachoir/release.sh	2005-11-23 02:36:34 UTC (rev 263)
@@ -0,0 +1,16 @@
+PACKAGE=hachoir
+VERSION=20051115
+ARCHIVE=$PACKAGE-$VERSION.tar.bz2
+TMP_DIR=/tmp
+DIR=$PWD
+if [ -e $TMP_DIR/$PACKAGE ]; then
+        rm -rf $TMP_DIR/$PACKAGE
+fi
+
+echo "* Export data"
+svn export . $TMP_DIR/$PACKAGE
+
+echo "* Create $ARCHIVE"
+(cd $TMP_DIR && tar cjf $DIR/$ARCHIVE $PACKAGE)
+
+echo "$DIR/$ARCHIVE wrote."


Property changes on: haypo/hachoir/release.sh
___________________________________________________________________
Name: svn:executable
   + *



From haypo at berlios.de  Thu Nov 24 00:24:53 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 24 Nov 2005 00:24:53 +0100
Subject: [Happyboom-svn] r264 - in haypo/hachoir: . plugins
Message-ID: <200511232324.jANNOrPD017107@sheep.berlios.de>

Author: haypo
Date: 2005-11-24 00:24:52 +0100 (Thu, 24 Nov 2005)
New Revision: 264

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/error.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/mime.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/ui.py
   haypo/hachoir/ui_new_chunk.py
   haypo/hachoir/ui_new_string.py
   haypo/hachoir/ui_popup.py
   haypo/hachoir/ui_property.py
   haypo/hachoir/ui_window.py
Log:
Also use filename to guess MIME type. New feature: copy in clipboard.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/chunk.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -34,6 +34,13 @@
     def getStream(self):
         return self._stream
 
+    def getStringValue(self):
+        value = self.getDisplayData()
+        if type(value) == types.TupleType:
+            return "(%s)" % ", ".join( map(str,value) )
+        else:
+            return "%s" % value
+
     def getValue(self, max_size=None):
         return None
 

Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/error.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,6 +1,6 @@
 import os
 import pygtk
-pygtk.require ('2.0')
+pygtk.require ('2.0') # 2.2 for Clipboard
 import gtk
 from log import log
 import ui

Modified: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/hachoir.glade	2005-11-23 23:24:52 UTC (rev 264)
@@ -279,7 +279,7 @@
       <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image44">
+	<widget class="GtkImage" id="image49">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -300,7 +300,7 @@
       <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image45">
+	<widget class="GtkImage" id="image50">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-cut</property>
 	  <property name="icon_size">1</property>
@@ -321,7 +321,7 @@
       <signal name="activate" handler="onAddString" last_modification_time="Wed, 02 Nov 2005 05:30:33 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image46">
+	<widget class="GtkImage" id="image51">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-add</property>
 	  <property name="icon_size">1</property>
@@ -342,7 +342,7 @@
       <signal name="activate" handler="onConvert" last_modification_time="Wed, 02 Nov 2005 02:32:16 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image47">
+	<widget class="GtkImage" id="image52">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-convert</property>
 	  <property name="icon_size">1</property>
@@ -363,7 +363,7 @@
       <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image48">
+	<widget class="GtkImage" id="image53">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-edit</property>
 	  <property name="icon_size">1</property>
@@ -384,7 +384,7 @@
       <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
 
       <child internal-child="image">
-	<widget class="GtkImage" id="image49">
+	<widget class="GtkImage" id="image54">
 	  <property name="visible">True</property>
 	  <property name="stock">gtk-delete</property>
 	  <property name="icon_size">1</property>
@@ -396,6 +396,27 @@
       </child>
     </widget>
   </child>
+
+  <child>
+    <widget class="GtkImageMenuItem" id="copy_clipboard">
+      <property name="visible">True</property>
+      <property name="label" translatable="yes">Copy to clipboard</property>
+      <property name="use_underline">True</property>
+      <signal name="activate" handler="onCopyClipboard" last_modification_time="Wed, 23 Nov 2005 22:09:19 GMT"/>
+
+      <child internal-child="image">
+	<widget class="GtkImage" id="image55">
+	  <property name="visible">True</property>
+	  <property name="stock">gtk-copy</property>
+	  <property name="icon_size">1</property>
+	  <property name="xalign">0.5</property>
+	  <property name="yalign">0.5</property>
+	  <property name="xpad">0</property>
+	  <property name="ypad">0</property>
+	</widget>
+      </child>
+    </widget>
+  </child>
 </widget>
 
 <widget class="GtkAboutDialog" id="about_dialog">

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/mime.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -11,19 +11,29 @@
         instance.load()
     return instance
 
-def getFileMime(filename):
+def getFileMime(realname, filename=None):
+    if filename == None:
+        filename = realname
     mode = os.stat(filename)[stat.ST_MODE]
-    if stat.S_ISDIR(mode):
-        return "Directory"
-    if stat.S_ISLNK(mode):
-        return "Link"
+    assert not stat.S_ISDIR(mode) and not stat.S_ISLNK(mode)
     
     f = file(filename, "rb")
     buffer = f.read(4096)
     f.close()
-    return getBufferMime(buffer)
+    return getBufferMime(buffer, filename)
 
-def getBufferMime(buffer):
+def getMimeByExt(ext):    
+    if ext == '.gz':
+        return 'application/x-gzip'
+    return None        
+
+def getBufferMime(buffer, filename):
     magic = getInstance()
-    type = magic.buffer(buffer)
-    return type.split(",")
+    mime = magic.buffer(buffer)
+    mime = mime.split(",")
+    if mime[0] == 'application/octet-stream' and filename != None:
+        ext = os.path.splitext(filename)[1]
+        new_mime = getMimeByExt(ext)
+        if new_mime != None:
+            mime = (new_mime,)
+    return mime            

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/plugin.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -18,18 +18,18 @@
         warning("More than one plugin have same MIME...")
     return plugins[0]       
     
-def getPluginByBuffer(buffer):
-    mime = getBufferMime(buffer)
+def getPluginByBuffer(buffer, filename):
+    mime = getBufferMime(buffer, filename)
     return getPluginByMime(mime)
 
-def getPluginByStream(stream):
+def getPluginByStream(stream, filename):
     stream.seek(0)
     data = stream.getN(4096)
-    mime = getBufferMime(data)
+    mime = getBufferMime(data, filename)
     return getPluginByMime(mime)
 
-def getPluginByFile(filename):
-    mime = getFileMime(filename)
+def getPluginByFile(filename, realname=None):
+    mime = getFileMime(filename, realname)
     return getPluginByMime(mime)
     
 def registerPlugin(filter_class, mime):

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/plugins/gzip.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -65,7 +65,7 @@
             data = stream.getN(stream.getSize())
             stream = GunzipStream(data)
             stream.seek(oldpos)
-            plugin = getPluginByStream(stream)
+            plugin = getPluginByStream(stream, self.filename)
             # END OF TODO
 
             self.readChild("data", GunzipFilter, oldpos, size, plugin) 
@@ -116,4 +116,4 @@
         val = chunk.value
         return os.get(val, "Unknow (%s)" % val)
         
-registerPlugin(GzipFile, "application/octet-stream")
+registerPlugin(GzipFile, "application/x-gzip")

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/plugins/tar.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -96,7 +96,7 @@
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
-            plugin = guessPlugin(stream)
+            plugin = guessPlugin(stream, self.name)
             ok = False
             if plugin != None:
                 oldpos = stream.tell()

Modified: haypo/hachoir/ui.py
===================================================================
--- haypo/hachoir/ui.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/ui.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,6 +1,6 @@
 import os
 import pygtk
-pygtk.require ('2.0')
+pygtk.require ('2.0') # 2.2 for Clipboard
 import gtk
 import gtk.glade
 
@@ -21,7 +21,13 @@
         self.on_row_click = None # event(chunk_id)
         self.on_go_parent = None # event(chunk_id)
         self.build_ui()
+        self._clipboard = None
         
+    def getClipboard(self):
+        if self._clipboard == None:
+            self._clipboard = gtk.Clipboard()
+        return self._clipboard
+
     def run(self):
         self.window.updateToolbar()
         try:

Modified: haypo/hachoir/ui_new_chunk.py
===================================================================
--- haypo/hachoir/ui_new_chunk.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/ui_new_chunk.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,5 +1,4 @@
 import pygtk
-pygtk.require ('2.0')
 import gtk
 import gtk.glade
 from format import splitFormat

Modified: haypo/hachoir/ui_new_string.py
===================================================================
--- haypo/hachoir/ui_new_string.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/ui_new_string.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,5 +1,4 @@
 import pygtk
-pygtk.require ('2.0')
 import gtk
 import gtk.glade
 

Modified: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/ui_popup.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,5 +1,4 @@
 import pygtk
-pygtk.require ('2.0')
 import gtk
 import gtk.glade
 from chunk import FormatChunk, FilterChunk, StringChunk
@@ -8,6 +7,8 @@
 from format import splitFormat # TODO: remove this line
 from error import error
 
+MAX_CHUNK_SIZE=1024 # When copy to clipboard
+
 class TablePopup:
     def __init__(self, ui, filename):
         self.ui = ui
@@ -25,6 +26,7 @@
         self.convert = xml.get_widget("convert")
         self.set_format = xml.get_widget("set_format")
         self.delete_chunk = xml.get_widget("delete_chunk")
+        self.copy_clipboard = xml.get_widget("copy_clipboard")
 
     def show(self, path_info, event):
         col = path_info[0][0]
@@ -42,8 +44,6 @@
         self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
         self.set_format.set_sensitive(is_format_chunk)
 
-#        can_delete = ()
-#        if not can_delete:
         chunks = self.chunk.getParent().getChunks()
         if self.chunk.getParent().getParent() != None:
             can_delete = (1 < len(chunks)) or not is_format_chunk
@@ -51,6 +51,8 @@
             can_delete = chunks.index(self.chunk) < (len(chunks)-1) or not is_format_chunk
 
         self.delete_chunk.set_sensitive(can_delete)
+        can_copy = (self.chunk.size < MAX_CHUNK_SIZE) and not is_filter_chunk
+        self.copy_clipboard.set_sensitive(can_copy)
         self.popup.popup( None, None, None, event.button, event.time)
 
     def onDeleteChunk(self, event):
@@ -83,6 +85,10 @@
         desc = self.new_chunk_dlg.getDescription()
         self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
 
+    def onCopyClipboard(self, event):
+        text = self.chunk.getStringValue()
+        self.ui.getClipboard().set_text(text)
+
     def onAddString(self, event):
         dlg = self.new_string_dlg
         if dlg.run() == gtk.RESPONSE_CANCEL: return

Modified: haypo/hachoir/ui_property.py
===================================================================
--- haypo/hachoir/ui_property.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/ui_property.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,5 +1,4 @@
 import pygtk
-pygtk.require ('2.0')
 import gtk
 import gtk.glade
 from format import splitFormat

Modified: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-11-23 02:36:34 UTC (rev 263)
+++ haypo/hachoir/ui_window.py	2005-11-23 23:24:52 UTC (rev 264)
@@ -1,6 +1,5 @@
 import os
 import pygtk
-pygtk.require ('2.0')
 import gtk
 import gtk.glade
 



From haypo at berlios.de  Thu Nov 24 03:46:15 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Thu, 24 Nov 2005 03:46:15 +0100
Subject: [Happyboom-svn] r265 - in haypo/hachoir: . plugins
Message-ID: <200511240246.jAO2kFL6008450@sheep.berlios.de>

Author: haypo
Date: 2005-11-24 03:46:05 +0100 (Thu, 24 Nov 2005)
New Revision: 265

Added:
   haypo/hachoir/plugins/asn1.py
Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/stream.py
   haypo/hachoir/ui_window.py
Log:
Add ASN1 plugin (very alpha...). Fix MIME dectection. Use limited stream
in Gzip, Tar and Png files: fix/improve LimitedStream class. Hachoir filter
and main_filter become privates.


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/filter.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -316,6 +316,15 @@
             setattr(self, id, data)
             self._chunks_dict[id] = chunk
 
+    def readLimitedChild(self, id, size, filter_class, *args):
+        start = self._stream.tell()
+        limited = self._stream.createLimited(start, size)
+        filter = filter_class(limited, self, *args)
+        chunk = self.addFilter(id, filter)
+        chunk.postProcess()
+        self._stream.seek(start+size)
+        return chunk
+        
     def readChild(self, id, filter_class, *args): 
         filter = filter_class(self._stream, self, *args)
         chunk = self.addFilter(id, filter)

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/hachoir_class.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -1,5 +1,5 @@
 from stream import FileStream
-from plugin import getPluginByFile
+from plugin import getPluginByStream
 from chunk import FilterChunk
 from default import DefaultFilter
 from user_filter import UserFilterDescriptor, loadUserFilter
@@ -15,74 +15,87 @@
         self.display = True
         self.depth = 5
         self.ui = None 
-        self.main_filter = None
+        self._main_filter = None
+        self._filter = None
         self.script = None
 
+    def getFilter(self):
+        return self._filter
+
+    def setFilter(self, filter):
+        self._main_filter = filter
+        self._filter = filter
+        self._addPadding()
+        self._filter.display()
+        self.ui.window.updateToolbar()
+
     def onGoParent(self):
-        if self.filter.getParent() == None: return
-        self.filter = self.filter.getParent()
-        self.filter.display()
+        if self._filter.getParent() == None: return
+        self._filter = self._filter.getParent()
+        self._filter.display()
         
     def onRowClick(self, chunk_id):
         if chunk_id == None: return
-        chunk = self.filter.getChunk(chunk_id)
+        chunk = self._filter.getChunk(chunk_id)
         if issubclass(chunk.__class__, FilterChunk):
-            self.filter = chunk.getFilter()
-            self.filter.display()
+            self._filter = chunk.getFilter()
+            self._filter.display()
 
     def loadUser(self, filename):
         try:
-            old_filter = self.filter
+            old_filter = self._filter
             old_size = old_filter.getSize()
             user = UserFilterDescriptor(xml_file=filename)
-            stream = self.filter.getStream()
-            parent = self.filter.getParent()
-            stream.seek(self.filter.getAddr())
+            stream = self._filter.getStream()
+            parent = self._filter.getParent()
+            stream.seek(self._filter.getAddr())
             new_filter = loadUserFilter(user, stream, parent)
         except Exception, err:
             error("Error while loading user XML filter \"%s\":\n%s" % (filename, err))
             return
-        self.filter = new_filter           
+        self._filter = new_filter           
         if parent == None:
-            self.main_filter = self.filter
+            self._main_filter = self._filter
             self._addPadding()
         else:
             chunk = old_filter.filter_chunk
-            chunk.setFilter(self.filter)
-            diff_size = self.filter.getSize() - old_size
+            chunk.setFilter(self._filter)
+            diff_size = self._filter.getSize() - old_size
             chunk.getParent().rescan(chunk, diff_size)
-        self.filter.display()
+        self._filter.display()
         self.ui.window.updateToolbar()
     
     def saveUser(self, filename):
-        my = UserFilterDescriptor(filter=self.filter)
+        my = UserFilterDescriptor(filter=self._filter)
         my.writeIntoXML(filename)
     
     def exportUser(self, filename):
-        my = UserFilterDescriptor(filter=self.filter)
+        my = UserFilterDescriptor(filter=self._filter)
         my.exportPython(filename)
         
     def _addPadding(self):
-        size = self.filter.getSize()
-        diff_size = (size - self.filter.getStream().getSize())
+        size = self._filter.getSize()
+        diff_size = (size - self._filter.getStream().getSize())
         if diff_size < 0:
-            chunks = self.filter.getChunks()
+            chunks = self._filter.getChunks()
             if len(chunks) != 0:
                 last_chunk = chunks[-1]
             else:
                 last_chunk = None
-            self.filter.addRawChunk(last_chunk, "end", "{@end@}", "")
+            self._filter.addRawChunk(last_chunk, "end", "{@end@}", "")
 
-    def load(self, filename):
+    def loadFile(self, filename):
         try:
             file = open(filename, 'r')
             stream = FileStream(file, filename)
         except IOError, err:
             error("Can't load file %s:\n%s" % (filename, err))
             return
+        self.loadStream(stream, filename)
 
+    def loadStream(self, stream, filename=None):
         # Look for a plugin
-        plugin = getPluginByFile(filename)
+        plugin = getPluginByStream(stream, filename)
         if plugin != None:
             split_class = plugin
         else:
@@ -90,18 +103,15 @@
             
         # Split 
         try:
+            stream.seek(0)
             filter = split_class(stream)
         except Exception, msg:
             error("Exception while processing file %s:\n%s\n%s" \
                 % (filename, msg, getBacktrace()))
             stream.seek(0)
             filter = DefaultFilter(stream)
-        self.main_filter = self.filter = filter
-        self._addPadding()
-        self.filter.display()
+        self.setFilter(filter)
 
-        self.ui.window.updateToolbar()
-
     def loadScript(self, filename):
         try:
             f = open(self.script, 'r')
@@ -117,5 +127,5 @@
         if self.script:
             self.loadScript(self.script)
         elif filename != None:
-            self.load(filename)
+            self.loadFile(filename)
         self.ui.run()      

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/plugin.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -1,10 +1,13 @@
 import re
 from mime import getFileMime, getBufferMime
 
-def guessPlugin(stream):
+def guessPlugin(stream, filename):
     oldpos = stream.tell()
-    buffer = stream.getN(4096)
-    plugin = getPluginByBuffer(buffer)
+    size = stream.getSize()
+    if 4096<size:
+        size = 4096
+    buffer = stream.getN(size)
+    plugin = getPluginByBuffer(buffer, filename)
     stream.seek(oldpos)
     return plugin
 
@@ -24,7 +27,10 @@
 
 def getPluginByStream(stream, filename):
     stream.seek(0)
-    data = stream.getN(4096)
+    size = stream.getSize()
+    if 4096<size:
+        size = 4096
+    data = stream.getN(size)
     mime = getBufferMime(data, filename)
     return getPluginByMime(mime)
 

Added: haypo/hachoir/plugins/asn1.py
===================================================================
--- haypo/hachoir/plugins/asn1.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/plugins/asn1.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -0,0 +1,92 @@
+"""
+ASN1 Parser
+
+Information: http://www.openssl.org/docs/apps/asn1parse.html
+
+Author: Victor Stinner
+"""
+
+from filter import Filter
+
+class ASN1_Sequence(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "asn1_seq", "ASN1 sequence", stream, parent)
+        self.readArray("item", ASN1_Object, "Items", self.checkEnd)
+
+    def checkEnd(self, stream, array, last):        
+        return stream.eof()
+
+class ASN1_Object(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "asn1_obj", "ASN1 object", stream, parent)
+        
+        import sys
+        sys.stdout.write("%s: " % stream.tell())
+        
+        self.read("type", "B", "type")
+        tag = self.type & 0x1f
+        if tag == 0x1f:
+            raise Exception("Error in ASN1 parser: TODO ...")
+        else:
+            length = stream.getFormat("B", False)[0]
+            if 128 <= length:
+                size = length & 0x7f 
+                length = 0
+                oldpos = stream.tell()
+                for i in range(0,size):
+                    stream.seek(oldpos+1+i)
+                    new = stream.getFormat("B", False)[0]
+                    length = length * 256 + new
+                    assert length < (1 << 32)
+                stream.seek(oldpos)
+                self.length = length
+                self.read("dummylength", "%uB" % (1+size), "Length")
+            else:
+                self.read("length", "B", "Length")
+            print "Length = %s" % self.length
+            self.getChunk("type").description = "type (tag=%s)" % tag
+            handler = {
+                0: self.readEOC,
+                1: self.readBoolean,
+                4: self.readOctetString,
+#                6: self.readObject,
+                10: self.readEnum,
+                12: self.readUTF8,
+                16: self.readSequence
+            }
+            if tag in handler:
+                handler[tag]()
+            else:
+                self.read("value", "%us" % length, \
+                    "Value (don't know tag %s)" % tag)
+
+    def readEnum(self):
+        self.read("value", "%us" % self.length, "Value (EOC)")
+
+    def readObject(self):
+        self.readChild("object", ASN1_Object)
+
+    def readEOC(self):
+        self.read("value", "%us" % self.length, "Value (EOC)")
+
+    def readOctetString(self):
+        self.read("value", "%us" % self.length, "Value (octet string)")
+
+    def readBoolean(self):
+        self.read("value", "B", "Value (boolean)")
+
+    def readUTF8(self):
+        self.read("value", "%us" % self.length, "Value (string)")
+        
+    def readSequence(self):
+        self.readLimitedChild("sequence", self.length, ASN1_Sequence)
+
+class ASN1_Parser(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "asn1", "ASN1 parser", stream, parent)
+        #self.readArray("item", ASN1_Object, "Items", self.checkEnd)
+        self.readChild("a", ASN1_Object)
+#        self.readChild("b", ASN1_Object)
+
+    def checkEnd(self, stream, array, last):        
+        return stream.eof()

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/plugins/png.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -5,7 +5,7 @@
 Author: Victor Stinner
 """
 
-from stream import StringStream, LimitedFileStream
+from stream import StringStream
 from filter import Filter
 from plugin import registerPlugin
 
@@ -114,7 +114,7 @@
         if self.type in self.chunk_splitter:
             oldpos = self._stream.tell()
             child_filter = self.chunk_splitter[self.type]
-            self.readChild("chunk_data", child_filter)
+            self.readLimitedChild("chunk_data", self.size, child_filter)
             assert oldpos + self.size == self._stream.tell()
         else:
             self.read("data", "!{size}s", "Chunk data")

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/plugins/tar.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -96,16 +96,16 @@
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
-            plugin = guessPlugin(stream, self.name)
+            substream = stream.createLimited(stream.tell(), self.size)
+            plugin = guessPlugin(substream, self.name)
             ok = False
             if plugin != None:
                 oldpos = stream.tell()
                 try:
-                    # TODO: Fix child stream start & end (size)
-                    chunk = self.readChild("filedata", plugin)
+                    chunk = self.readLimitedChild("filedata", self.size, plugin)
                     ok = True
                 except Exception, msg:
-                    error("Error while processing tar file: %s" % msg)
+                    error("Error while processing tar file \"%s\": %s" % (self.name, msg))
                     stream.seek(oldpos)
 
             if not ok:

Modified: haypo/hachoir/stream.py
===================================================================
--- haypo/hachoir/stream.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/stream.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -6,11 +6,14 @@
         Exception.__init__(self, msg)
 
 class Stream:
-    def __init__(self):
-        pass
+    def __init__(self, filename):
+        self.filename = filename
     
     def getSize(self):
         return 0
+
+    def clone(self):
+        return None
     
     def getLastPos(self):
         return 0
@@ -21,6 +24,17 @@
     def tell(self):
         return 0
 
+    def createLimited(self, start, size):
+        return LimitedStream(self, start, size, self.filename)
+    
+    def getN(self, size, seek=True):
+        return None
+
+    def getFormat(self, format, seek=True):
+        size = struct.calcsize(format)
+        data = self.getN(size, seek)
+        return struct.unpack(format, data)
+
     def searchLength(self, str, include_str, size_max=None):        
         pos = self.search(str, size_max)
         if pos == -1: return -1
@@ -35,11 +49,14 @@
     file = StringIO(data)
     return FileStream(file)
 
-class LimitedFileStream(Stream):
-    def __init__(self, filename, start=0, size=0):
-        self.__stream = FileStream(filename)
-        if start<0: start = 0
-        if self.__stream.getSize() < start+size: size = self.__stream.getSize()-start
+class LimitedStream(Stream):
+    def __init__(self, stream, start=0, size=0, filename=None):
+        Stream.__init__(self, filename)
+        self.__stream = stream.clone()
+        if start<0:
+            start = 0
+        if self.__stream.getLastPos() < start+size:
+            size = self.__stream.getLastPos()-start
         self.__start = start
         self.__size = size
         self.__end = self.__start + self.__size
@@ -52,10 +69,10 @@
         assert 0<=size_max  and size_max<=self.__size
         return self.__stream.search(str, size_max)
 
-    def getN(self, size):
+    def getN(self, size, seek=True):
         if self.__start+self.__size<self.__stream.tell()+size:
             raise StreamError("Can't read outsize the stream.")
-        return self.__stream.getN(size)
+        return self.__stream.getN(size, seek)
 
     def tell(self):
         return self.__stream.tell()
@@ -68,20 +85,25 @@
     
     def getLastPos(self):
         return self.__end
-    
+
+    def clone(self):
+        return LimitedStream(self.__stream, self.__start, self.__size, self.filename)
+
 class FileStream(Stream):
     def __init__(self, file, filename=None):
         """
         Endian: See setEndian function. 
         """
 
-        Stream.__init__(self)
+        Stream.__init__(self, filename)
         self.__file = file 
-        self.filename = filename
         self.__file.seek(0,2) # Seek to end
         self.__size = self.__file.tell()
         self.__file.seek(0,0) # Seel to beginning
 
+    def clone(self):
+        return FileStream(self.__file, self.filename)
+
     def seek(self, pos, where=0):
         """ Read file seek document to understand where. """
         self.__file.seek(pos, where)
@@ -131,10 +153,12 @@
         self.seek(oldpos)
         return pos
 
-    def getN(self, size):
+    def getN(self, size, seek=True):
         data = self.__file.read(size)
         if len(data) != size:
             raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
+        if not seek:
+            self.__file.seek(-size, 1)
         return data
 
     def getEnd(self):

Modified: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-11-23 23:24:52 UTC (rev 264)
+++ haypo/hachoir/ui_window.py	2005-11-24 02:46:05 UTC (rev 265)
@@ -25,7 +25,7 @@
         self.build_table()
         
     def updateToolbar(self):
-        file_present = (self.ui.hachoir.main_filter != None)
+        file_present = (self.ui.hachoir.getFilter() != None)
         self.toolbutton_open.set_sensitive(file_present)
         self.toolbutton_save.set_sensitive(file_present)
         if not file_present:
@@ -35,7 +35,7 @@
     def getTableChunk(self, col):
         chunk_id = self.table_store[col][3]
         if chunk_id == None: return None
-        return self.ui.hachoir.filter.getChunk(chunk_id)
+        return self.ui.hachoir.getFilter().getChunk(chunk_id)
 
     def on_treeview_button_press_event(self, treeview, event):
         if event.button == 3:
@@ -106,7 +106,7 @@
         self.on_open_activate(widget)
 
     def on_toolbutton_property(self, widget):
-        filter = self.ui.hachoir.filter
+        filter = self.ui.hachoir.getFilter()
         dlg = self.ui.property_dialog
         if dlg.run(filter) == gtk.RESPONSE_CANCEL: return
         filter.setId( dlg.getId() )
@@ -120,7 +120,7 @@
             buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
         if chooser.run() == gtk.RESPONSE_OK:
             filename = chooser.get_filename() 
-            self.ui.hachoir.load(filename)
+            self.ui.hachoir.loadFile(filename)
         chooser.destroy()
 
     def on_toolbutton_open(self, widget):



From haypo at berlios.de  Fri Nov 25 01:25:35 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 25 Nov 2005 01:25:35 +0100
Subject: [Happyboom-svn] r266 - in haypo/hachoir: . plugins stream ui
Message-ID: <200511250025.jAP0PZc4021060@sheep.berlios.de>

Author: haypo
Date: 2005-11-25 01:24:50 +0100 (Fri, 25 Nov 2005)
New Revision: 266

Added:
   haypo/hachoir/plugins/bzip2.py
   haypo/hachoir/stream/
   haypo/hachoir/stream/__init__.py
   haypo/hachoir/stream/deflate.py
   haypo/hachoir/stream/error.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/stream/gunzip.py
   haypo/hachoir/stream/stream.py
   haypo/hachoir/stream/string.py
   haypo/hachoir/ui/
   haypo/hachoir/ui/__init__.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui.py
   haypo/hachoir/ui/ui_new_chunk.py
   haypo/hachoir/ui/ui_new_string.py
   haypo/hachoir/ui/ui_popup.py
   haypo/hachoir/ui/ui_property.py
   haypo/hachoir/ui/ui_window.py
Removed:
   haypo/hachoir/deflate.py
   haypo/hachoir/gunzip_stream.py
   haypo/hachoir/hachoir.glade
   haypo/hachoir/stream.py
   haypo/hachoir/ui.py
   haypo/hachoir/ui_new_chunk.py
   haypo/hachoir/ui_new_string.py
   haypo/hachoir/ui_popup.py
   haypo/hachoir/ui_property.py
   haypo/hachoir/ui_window.py
Modified:
   haypo/hachoir/error.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/zip.py
Log:
Move streams classes in stream/ subdir, and ui classes in ui/


Deleted: haypo/hachoir/deflate.py
===================================================================
--- haypo/hachoir/deflate.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/deflate.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,31 +0,0 @@
-import zlib
-from StringIO import StringIO
-from stream import FileStream
-from filter import Filter
-
-class DeflateFilter(Filter):
-    def __init__(self, stream, parent, start, size):
-        # Read data
-        self._parent_stream = stream
-        self._parent_stream.seek(start)
-        data = stream.getN(size)
-        
-        # Create a new stream
-        stream = DeflateStream(data)
-        self._compressed_size = size 
-        self._decompressed_size = stream.getSize()
-
-        # Create filter
-        self._parent_stream.seek(start)
-        Filter.__init__(self, "deflate", "Deflate", stream, parent)
-        self._addr = self._parent_stream.tell()
-
-        self.read("raw", "!{@end@}s", "")
-
-    def getSize(self):
-        return self._compressed_size
-
-def DeflateStream(data):
-    data = zlib.decompress(data)
-    io = StringIO(data)
-    return FileStream(io)

Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/error.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -3,7 +3,7 @@
 pygtk.require ('2.0') # 2.2 for Clipboard
 import gtk
 from log import log
-import ui
+import ui.ui as ui
 
 def warning(message):
     log.warning(message)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/filter.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -6,7 +6,7 @@
 import re, sys
 import string
 import types
-import ui
+import ui.ui as ui
 from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
 from format import splitFormat    
 from error import error

Deleted: haypo/hachoir/gunzip_stream.py
===================================================================
--- haypo/hachoir/gunzip_stream.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/gunzip_stream.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,10 +0,0 @@
-import gzip
-from StringIO import StringIO
-from stream import FileStream
-
-def GunzipStream(data):
-    io = StringIO(data)
-    io = gzip.GzipFile(None, "r", None, io)
-    data = io.read()
-    io = StringIO(data)
-    return FileStream(io)

Deleted: haypo/hachoir/hachoir.glade
===================================================================
--- haypo/hachoir/hachoir.glade	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/hachoir.glade	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,1478 +0,0 @@
-<?xml version="1.0" standalone="no"?> <!--*- mode: xml -*-->
-<!DOCTYPE glade-interface SYSTEM "http://glade.gnome.org/glade-2.0.dtd">
-
-<glade-interface>
-
-<widget class="GtkWindow" id="main_window">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">Hachoir</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="decorated">True</property>
-  <property name="skip_taskbar_hint">False</property>
-  <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
-  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
-  <property name="focus_on_map">True</property>
-  <signal name="destroy" handler="on_window_destroy" last_modification_time="Sat, 29 Oct 2005 02:58:52 GMT"/>
-
-  <child>
-    <widget class="GtkVBox" id="vbox2">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child>
-	<widget class="GtkMenuBar" id="menubar">
-	  <property name="visible">True</property>
-
-	  <child>
-	    <widget class="GtkMenuItem" id="file">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">_File</property>
-	      <property name="use_underline">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="file_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="open">
-		      <property name="visible">True</property>
-		      <property name="label">gtk-open</property>
-		      <property name="use_stock">True</property>
-		      <signal name="activate" handler="on_open_activate" last_modification_time="Sun, 30 Oct 2005 02:16:42 GMT"/>
-		    </widget>
-		  </child>
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="quit">
-		      <property name="visible">True</property>
-		      <property name="label">gtk-quit</property>
-		      <property name="use_stock">True</property>
-		      <signal name="activate" handler="on_quit_activate" last_modification_time="Sun, 30 Oct 2005 02:19:54 GMT"/>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkImageMenuItem" id="help">
-	      <property name="visible">True</property>
-	      <property name="label">gtk-help</property>
-	      <property name="use_stock">True</property>
-
-	      <child>
-		<widget class="GtkMenu" id="help_menu">
-
-		  <child>
-		    <widget class="GtkImageMenuItem" id="about">
-		      <property name="visible">True</property>
-		      <property name="label">gtk-about</property>
-		      <property name="use_stock">True</property>
-		      <signal name="activate" handler="on_about_activate" last_modification_time="Sun, 30 Oct 2005 02:18:35 GMT"/>
-		    </widget>
-		  </child>
-		</widget>
-	      </child>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkHandleBox" id="handlebox1">
-	  <property name="visible">True</property>
-	  <property name="shadow_type">GTK_SHADOW_OUT</property>
-	  <property name="handle_position">GTK_POS_LEFT</property>
-	  <property name="snap_edge">GTK_POS_TOP</property>
-
-	  <child>
-	    <widget class="GtkToolbar" id="toolbar1">
-	      <property name="visible">True</property>
-	      <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
-	      <property name="toolbar_style">GTK_TOOLBAR_BOTH</property>
-	      <property name="tooltips">True</property>
-	      <property name="show_arrow">True</property>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_new">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Open new file and split it</property>
-		  <property name="stock_id">gtk-new</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_new" last_modification_time="Mon, 31 Oct 2005 04:36:45 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_open">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Open a filter and apply it to this level</property>
-		  <property name="stock_id">gtk-open</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_open" last_modification_time="Mon, 31 Oct 2005 04:36:36 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_save">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Save current filter into a XML file</property>
-		  <property name="stock_id">gtk-save</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_save" last_modification_time="Mon, 31 Oct 2005 04:32:02 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkSeparatorToolItem" id="separatortoolitem1">
-		  <property name="visible">True</property>
-		  <property name="draw">True</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">False</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_parent">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Go to parent filter</property>
-		  <property name="label" translatable="yes">Parent</property>
-		  <property name="use_underline">True</property>
-		  <property name="stock_id">gtk-go-up</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_parent" last_modification_time="Sun, 30 Oct 2005 01:50:12 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_property">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Set filter properties</property>
-		  <property name="stock_id">gtk-properties</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_property" last_modification_time="Mon, 31 Oct 2005 16:11:08 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkToolButton" id="toolbutton_export">
-		  <property name="visible">True</property>
-		  <property name="tooltip" translatable="yes">Export current filter to python script</property>
-		  <property name="stock_id">gtk-convert</property>
-		  <property name="visible_horizontal">True</property>
-		  <property name="visible_vertical">True</property>
-		  <property name="is_important">False</property>
-		  <signal name="clicked" handler="on_toolbutton_export" last_modification_time="Wed, 02 Nov 2005 00:47:19 GMT"/>
-		</widget>
-		<packing>
-		  <property name="expand">False</property>
-		  <property name="homogeneous">True</property>
-		</packing>
-	      </child>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkScrolledWindow" id="scrolledwindow1">
-	  <property name="visible">True</property>
-	  <property name="can_focus">True</property>
-	  <property name="hscrollbar_policy">GTK_POLICY_ALWAYS</property>
-	  <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
-	  <property name="shadow_type">GTK_SHADOW_IN</property>
-	  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
-
-	  <child>
-	    <widget class="GtkTreeView" id="table">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="headers_visible">True</property>
-	      <property name="rules_hint">False</property>
-	      <property name="reorderable">False</property>
-	      <property name="enable_search">True</property>
-	      <property name="fixed_height_mode">False</property>
-	      <property name="hover_selection">False</property>
-	      <property name="hover_expand">False</property>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkStatusbar" id="statusbar">
-	  <property name="visible">True</property>
-	  <property name="has_resize_grip">True</property>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-<widget class="GtkMenu" id="table_popup">
-
-  <child>
-    <widget class="GtkImageMenuItem" id="new_chunk">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">_New chunk</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onNewChunk" last_modification_time="Sun, 30 Oct 2005 23:08:19 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image49">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-cut</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="new_filter">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">New _filter</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onNewFilter" last_modification_time="Mon, 31 Oct 2005 06:42:27 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image50">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-cut</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="add_string">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Add string</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onAddString" last_modification_time="Wed, 02 Nov 2005 05:30:33 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image51">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-add</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="convert">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">_Convert chunk &lt;=&gt; filter</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onConvert" last_modification_time="Wed, 02 Nov 2005 02:32:16 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image52">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-convert</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="set_format">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Set chunk _format</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onSetFormat" last_modification_time="Sun, 30 Oct 2005 23:27:49 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image53">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-edit</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="delete_chunk">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Delete chunk</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onDeleteChunk" last_modification_time="Tue, 01 Nov 2005 01:54:40 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image54">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-delete</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-
-  <child>
-    <widget class="GtkImageMenuItem" id="copy_clipboard">
-      <property name="visible">True</property>
-      <property name="label" translatable="yes">Copy to clipboard</property>
-      <property name="use_underline">True</property>
-      <signal name="activate" handler="onCopyClipboard" last_modification_time="Wed, 23 Nov 2005 22:09:19 GMT"/>
-
-      <child internal-child="image">
-	<widget class="GtkImage" id="image55">
-	  <property name="visible">True</property>
-	  <property name="stock">gtk-copy</property>
-	  <property name="icon_size">1</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	</widget>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-<widget class="GtkAboutDialog" id="about_dialog">
-  <property name="visible">True</property>
-  <property name="destroy_with_parent">True</property>
-  <property name="name" translatable="yes">Hachoir version 2005-10-30</property>
-  <property name="copyright" translatable="yes">Copyright 2005 Victor Stinner</property>
-  <property name="comments" translatable="yes">Split binary stream into filters and chunks ...</property>
-  <property name="license" translatable="yes">Under GNU GPL licence</property>
-  <property name="website">http://www.haypocalc.com/wiki/Hachoir</property>
-  <property name="website_label" translatable="yes">Website</property>
-  <property name="authors">Victor Stinner &lt;victor.stinner AT haypocalc.com&gt;</property>
-  <property name="translator_credits" translatable="yes" comments="TRANSLATORS: Replace this string with your names, one name per line.">translator-credits</property>
-</widget>
-
-<widget class="GtkDialog" id="new_chunk">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">New chunk</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="decorated">True</property>
-  <property name="skip_taskbar_hint">False</property>
-  <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
-  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
-  <property name="focus_on_map">True</property>
-  <property name="has_separator">True</property>
-
-  <child internal-child="vbox">
-    <widget class="GtkVBox" id="dialog-vbox1">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child internal-child="action_area">
-	<widget class="GtkHButtonBox" id="dialog-action_area1">
-	  <property name="visible">True</property>
-	  <property name="layout_style">GTK_BUTTONBOX_END</property>
-
-	  <child>
-	    <widget class="GtkButton" id="cancelbutton1">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-cancel</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-6</property>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkButton" id="okbutton1">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-ok</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-5</property>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">True</property>
-	  <property name="pack_type">GTK_PACK_END</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkLabel" id="label">
-	  <property name="visible">True</property>
-	  <property name="label" translatable="yes">Choose new chunk format :</property>
-	  <property name="use_underline">False</property>
-	  <property name="use_markup">False</property>
-	  <property name="justify">GTK_JUSTIFY_LEFT</property>
-	  <property name="wrap">False</property>
-	  <property name="selectable">False</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	  <property name="width_chars">-1</property>
-	  <property name="single_line_mode">False</property>
-	  <property name="angle">0</property>
-	</widget>
-	<packing>
-	  <property name="padding">6</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkTable" id="table1">
-	  <property name="visible">True</property>
-	  <property name="n_rows">5</property>
-	  <property name="n_columns">2</property>
-	  <property name="homogeneous">False</property>
-	  <property name="row_spacing">6</property>
-	  <property name="column_spacing">6</property>
-
-	  <child>
-	    <widget class="GtkLabel" id="label4">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Format:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0.5</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">2</property>
-	      <property name="bottom_attach">3</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkComboBoxEntry" id="format">
-	      <property name="visible">True</property>
-	      <property name="items" translatable="yes">c
-s
-B
-H
-L</property>
-	      <property name="add_tearoffs">False</property>
-	      <property name="has_frame">True</property>
-	      <property name="focus_on_click">True</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">2</property>
-	      <property name="bottom_attach">3</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options">fill</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label6">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Size:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">1</property>
-	      <property name="bottom_attach">2</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="size">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">1</property>
-	      <property name="bottom_attach">2</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label5">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Endian:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0.5</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">0</property>
-	      <property name="bottom_attach">1</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkComboBoxEntry" id="endian">
-	      <property name="visible">True</property>
-	      <property name="items" translatable="yes">!
-&lt;
-&gt;</property>
-	      <property name="add_tearoffs">False</property>
-	      <property name="has_frame">True</property>
-	      <property name="focus_on_click">True</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">0</property>
-	      <property name="bottom_attach">1</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options">fill</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label7">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Id:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">3</property>
-	      <property name="bottom_attach">4</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label8">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Desc.:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">4</property>
-	      <property name="bottom_attach">5</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="identifier">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">3</property>
-	      <property name="bottom_attach">4</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="description">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">4</property>
-	      <property name="bottom_attach">5</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">6</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-<widget class="GtkDialog" id="new_filter">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">New filter</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="decorated">True</property>
-  <property name="skip_taskbar_hint">False</property>
-  <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
-  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
-  <property name="focus_on_map">True</property>
-  <property name="has_separator">True</property>
-
-  <child internal-child="vbox">
-    <widget class="GtkVBox" id="dialog-vbox2">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child internal-child="action_area">
-	<widget class="GtkHButtonBox" id="dialog-action_area2">
-	  <property name="visible">True</property>
-	  <property name="layout_style">GTK_BUTTONBOX_END</property>
-
-	  <child>
-	    <widget class="GtkButton" id="cancelbutton2">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-cancel</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-6</property>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkButton" id="okbutton2">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-ok</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-5</property>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">True</property>
-	  <property name="pack_type">GTK_PACK_END</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkVBox" id="vbox3">
-	  <property name="visible">True</property>
-	  <property name="homogeneous">False</property>
-	  <property name="spacing">0</property>
-
-	  <child>
-	    <widget class="GtkLabel" id="label9">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">New filter options</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0.5</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="padding">6</property>
-	      <property name="expand">False</property>
-	      <property name="fill">False</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkTable" id="table2">
-	      <property name="border_width">6</property>
-	      <property name="visible">True</property>
-	      <property name="n_rows">3</property>
-	      <property name="n_columns">2</property>
-	      <property name="homogeneous">False</property>
-	      <property name="row_spacing">6</property>
-	      <property name="column_spacing">6</property>
-
-	      <child>
-		<widget class="GtkLabel" id="label10">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Id:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="label11">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Description:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkEntry" id="entry1">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">True</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">0</property>
-		  <property name="bottom_attach">1</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkEntry" id="entry2">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="editable">True</property>
-		  <property name="visibility">True</property>
-		  <property name="max_length">0</property>
-		  <property name="text" translatable="yes"></property>
-		  <property name="has_frame">True</property>
-		  <property name="invisible_char">*</property>
-		  <property name="activates_default">False</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">1</property>
-		  <property name="bottom_attach">2</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkLabel" id="label12">
-		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Type:</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">0</property>
-		  <property name="right_attach">1</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options"></property>
-		</packing>
-	      </child>
-
-	      <child>
-		<widget class="GtkComboBoxEntry" id="comboboxentry1">
-		  <property name="visible">True</property>
-		  <property name="add_tearoffs">False</property>
-		  <property name="has_frame">True</property>
-		  <property name="focus_on_click">True</property>
-		</widget>
-		<packing>
-		  <property name="left_attach">1</property>
-		  <property name="right_attach">2</property>
-		  <property name="top_attach">2</property>
-		  <property name="bottom_attach">3</property>
-		  <property name="x_options">fill</property>
-		  <property name="y_options">fill</property>
-		</packing>
-	      </child>
-	    </widget>
-	    <packing>
-	      <property name="padding">0</property>
-	      <property name="expand">True</property>
-	      <property name="fill">True</property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-<widget class="GtkDialog" id="filter_property">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">Filter property</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="decorated">True</property>
-  <property name="skip_taskbar_hint">False</property>
-  <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
-  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
-  <property name="focus_on_map">True</property>
-  <property name="has_separator">True</property>
-
-  <child internal-child="vbox">
-    <widget class="GtkVBox" id="dialog-vbox3">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child internal-child="action_area">
-	<widget class="GtkHButtonBox" id="dialog-action_area3">
-	  <property name="visible">True</property>
-	  <property name="layout_style">GTK_BUTTONBOX_END</property>
-
-	  <child>
-	    <widget class="GtkButton" id="cancelbutton3">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-cancel</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-6</property>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkButton" id="okbutton3">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-ok</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-5</property>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">True</property>
-	  <property name="pack_type">GTK_PACK_END</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkTable" id="table3">
-	  <property name="visible">True</property>
-	  <property name="n_rows">2</property>
-	  <property name="n_columns">2</property>
-	  <property name="homogeneous">False</property>
-	  <property name="row_spacing">6</property>
-	  <property name="column_spacing">6</property>
-
-	  <child>
-	    <widget class="GtkLabel" id="label13">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Id:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">0</property>
-	      <property name="bottom_attach">1</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label14">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Description:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">1</property>
-	      <property name="bottom_attach">2</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="id">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">0</property>
-	      <property name="bottom_attach">1</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="description">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">1</property>
-	      <property name="bottom_attach">2</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-<widget class="GtkDialog" id="new_string">
-  <property name="visible">True</property>
-  <property name="title" translatable="yes">New string</property>
-  <property name="type">GTK_WINDOW_TOPLEVEL</property>
-  <property name="window_position">GTK_WIN_POS_NONE</property>
-  <property name="modal">False</property>
-  <property name="resizable">True</property>
-  <property name="destroy_with_parent">False</property>
-  <property name="decorated">True</property>
-  <property name="skip_taskbar_hint">False</property>
-  <property name="skip_pager_hint">False</property>
-  <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
-  <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
-  <property name="focus_on_map">True</property>
-  <property name="has_separator">True</property>
-
-  <child internal-child="vbox">
-    <widget class="GtkVBox" id="vbox4">
-      <property name="visible">True</property>
-      <property name="homogeneous">False</property>
-      <property name="spacing">0</property>
-
-      <child internal-child="action_area">
-	<widget class="GtkHButtonBox" id="hbuttonbox1">
-	  <property name="visible">True</property>
-	  <property name="layout_style">GTK_BUTTONBOX_END</property>
-
-	  <child>
-	    <widget class="GtkButton" id="button1">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-cancel</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-6</property>
-	    </widget>
-	  </child>
-
-	  <child>
-	    <widget class="GtkButton" id="button2">
-	      <property name="visible">True</property>
-	      <property name="can_default">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="label">gtk-ok</property>
-	      <property name="use_stock">True</property>
-	      <property name="relief">GTK_RELIEF_NORMAL</property>
-	      <property name="focus_on_click">True</property>
-	      <property name="response_id">-5</property>
-	    </widget>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">True</property>
-	  <property name="pack_type">GTK_PACK_END</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkLabel" id="label15">
-	  <property name="visible">True</property>
-	  <property name="label" translatable="yes">Choose new string format :</property>
-	  <property name="use_underline">False</property>
-	  <property name="use_markup">False</property>
-	  <property name="justify">GTK_JUSTIFY_LEFT</property>
-	  <property name="wrap">False</property>
-	  <property name="selectable">False</property>
-	  <property name="xalign">0.5</property>
-	  <property name="yalign">0.5</property>
-	  <property name="xpad">0</property>
-	  <property name="ypad">0</property>
-	  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	  <property name="width_chars">-1</property>
-	  <property name="single_line_mode">False</property>
-	  <property name="angle">0</property>
-	</widget>
-	<packing>
-	  <property name="padding">6</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
-
-      <child>
-	<widget class="GtkTable" id="table4">
-	  <property name="visible">True</property>
-	  <property name="n_rows">3</property>
-	  <property name="n_columns">2</property>
-	  <property name="homogeneous">False</property>
-	  <property name="row_spacing">6</property>
-	  <property name="column_spacing">6</property>
-
-	  <child>
-	    <widget class="GtkLabel" id="label16">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Format:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0.5</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">0</property>
-	      <property name="bottom_attach">1</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkComboBoxEntry" id="format">
-	      <property name="visible">True</property>
-	      <property name="items" translatable="yes">C
-UnixLine
-WindowsLine
-MacLine
-AutoLine</property>
-	      <property name="add_tearoffs">False</property>
-	      <property name="has_frame">True</property>
-	      <property name="focus_on_click">True</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">0</property>
-	      <property name="bottom_attach">1</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options">fill</property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label19">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Id:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">1</property>
-	      <property name="bottom_attach">2</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkLabel" id="label20">
-	      <property name="visible">True</property>
-	      <property name="label" translatable="yes">Desc.:</property>
-	      <property name="use_underline">False</property>
-	      <property name="use_markup">False</property>
-	      <property name="justify">GTK_JUSTIFY_LEFT</property>
-	      <property name="wrap">False</property>
-	      <property name="selectable">False</property>
-	      <property name="xalign">0</property>
-	      <property name="yalign">0.5</property>
-	      <property name="xpad">0</property>
-	      <property name="ypad">0</property>
-	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-	      <property name="width_chars">-1</property>
-	      <property name="single_line_mode">False</property>
-	      <property name="angle">0</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">0</property>
-	      <property name="right_attach">1</property>
-	      <property name="top_attach">2</property>
-	      <property name="bottom_attach">3</property>
-	      <property name="x_options">fill</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="description">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">2</property>
-	      <property name="bottom_attach">3</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-
-	  <child>
-	    <widget class="GtkEntry" id="id">
-	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
-	      <property name="visibility">True</property>
-	      <property name="max_length">0</property>
-	      <property name="text" translatable="yes"></property>
-	      <property name="has_frame">True</property>
-	      <property name="invisible_char">*</property>
-	      <property name="activates_default">False</property>
-	    </widget>
-	    <packing>
-	      <property name="left_attach">1</property>
-	      <property name="right_attach">2</property>
-	      <property name="top_attach">1</property>
-	      <property name="bottom_attach">2</property>
-	      <property name="y_options"></property>
-	    </packing>
-	  </child>
-	</widget>
-	<packing>
-	  <property name="padding">6</property>
-	  <property name="expand">True</property>
-	  <property name="fill">True</property>
-	</packing>
-      </child>
-    </widget>
-  </child>
-</widget>
-
-</glade-interface>

Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/hachoir.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -82,7 +82,7 @@
         for key in opt:
             setattr(hachoir, key, opt[key])
         try:
-            import ui 
+            import ui.ui as ui
         except ImportError, err:
             error("""Error: a Python module is missing:\n%s\n
 You can find PyGTK at: http://www.pygtk.org/

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/hachoir_class.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,4 +1,4 @@
-from stream import FileStream
+from stream.file import FileStream
 from plugin import getPluginByStream
 from chunk import FilterChunk
 from default import DefaultFilter
@@ -104,7 +104,7 @@
         # Split 
         try:
             stream.seek(0)
-            filter = split_class(stream)
+            filter = split_class(stream, None)
         except Exception, msg:
             error("Exception while processing file %s:\n%s\n%s" \
                 % (filename, msg, getBacktrace()))

Added: haypo/hachoir/plugins/bzip2.py
===================================================================
--- haypo/hachoir/plugins/bzip2.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/plugins/bzip2.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,35 @@
+"""
+BZIP2 archive file
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class Bzip2_File(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "bz2_file", "Bzip2 archive file", stream, parent)
+        self.read("id", "3s", "Identifier (BZh)")
+        assert self.id == "BZh"
+        self.read("blocksize", "c", "Block size")
+        assert "1" <= self.blocksize and self.blocksize <= "9"
+        # Size of memory needed to decompress (on classic mode, not "small" mode)
+        size = (ord(self.blocksize) - ord("0")) * 400
+        self.getChunk("blocksize").description = "Block size (will need %u KB of memory)" % size
+        self.read("blockheader", "B", "Block header")
+        assert self.blockheader in (0x17, 0x31)
+        if self.blockheader == 0x17:
+            self.readA()
+        else: # blockheader = 0x31 ("1")
+            self.readB()
+
+    def readB(self):
+        self.read("id2", "5s", "Identifier 2 (AY&SY)")
+        assert self.id2 == "AY&SY"
+        self.read("crc", "<L", "CRC32")
+        
+    def readA(self):
+        self.read("id2", "4s", "Identifier2 (re8P)")
+        self.read("id3", "B", "Identifier3 (0x90)")
+        self.read("crc", "<L", "CRC32")
+         
+registerPlugin(Bzip2_File, "application/x-bzip2")

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/plugins/gzip.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -8,7 +8,7 @@
 import datetime
 from filter import Filter
 from plugin import registerPlugin
-from gunzip_stream import GunzipStream
+from stream.gunzip import GunzipStream
 from plugin import getPluginByStream
 from error import error
 from default import DefaultFilter
@@ -30,8 +30,7 @@
         Filter.__init__(self, "deflate", "Deflate", stream, parent)
         self._addr = self._parent_stream.tell()
 
-#        self.read("raw", "!{@end@}s", "")
-        self.readChild("tar", filter_class)
+        self.readChild("data", filter_class)
 
     def getSize(self):
         return self._compressed_size

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/plugins/pdf.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,9 +1,9 @@
 from filter import Filter
 from plugin import registerPlugin
 import re
-from stream import StreamError
+from stream.error import StreamError
 from tools import convertDataToPrintableString, getBacktrace
-from deflate import DeflateFilter
+from stream.deflate import DeflateFilter
 from error import warning
 
 def isEnd(stream, array, last):

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/plugins/png.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -5,7 +5,6 @@
 Author: Victor Stinner
 """
 
-from stream import StringStream
 from filter import Filter
 from plugin import registerPlugin
 

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/plugins/zip.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -91,8 +91,8 @@
             self.read("file_uncompressed_size", "<L", "Uncompressed size (bytes)")
         
 class ZipFile(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "zip_file", "ZIP archive file", stream, None)
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "zip_file", "ZIP archive file", stream, parent)
         # File data
         self.signature = None
         self.central_directory = []

Added: haypo/hachoir/stream/__init__.py
===================================================================

Copied: haypo/hachoir/stream/deflate.py (from rev 260, haypo/hachoir/deflate.py)
===================================================================
--- haypo/hachoir/deflate.py	2005-11-21 23:15:18 UTC (rev 260)
+++ haypo/hachoir/stream/deflate.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,31 @@
+import zlib
+from StringIO import StringIO
+from filter import Filter
+from file import FileStream
+
+class DeflateFilter(Filter):
+    def __init__(self, stream, parent, start, size):
+        # Read data
+        self._parent_stream = stream
+        self._parent_stream.seek(start)
+        data = stream.getN(size)
+        
+        # Create a new stream
+        stream = DeflateStream(data)
+        self._compressed_size = size 
+        self._decompressed_size = stream.getSize()
+
+        # Create filter
+        self._parent_stream.seek(start)
+        Filter.__init__(self, "deflate", "Deflate", stream, parent)
+        self._addr = self._parent_stream.tell()
+
+        self.read("raw", "!{@end@}s", "")
+
+    def getSize(self):
+        return self._compressed_size
+
+def DeflateStream(data):
+    data = zlib.decompress(data)
+    io = StringIO(data)
+    return FileStream(io)

Added: haypo/hachoir/stream/error.py
===================================================================
--- haypo/hachoir/stream/error.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/stream/error.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,3 @@
+class StreamError(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)

Added: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/stream/file.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,91 @@
+from error import StreamError
+from stream import Stream
+
+class FileStream(Stream):
+    def __init__(self, file, filename=None):
+        """
+        Endian: See setEndian function. 
+        """
+
+        Stream.__init__(self, filename)
+        self.__file = file 
+        self.__file.seek(0,2) # Seek to end
+        self.__size = self.__file.tell()
+        self.__file.seek(0,0) # Seel to beginning
+
+    def clone(self):
+        return FileStream(self.__file, self.filename)
+
+    def seek(self, pos, where=0):
+        """ Read file seek document to understand where. """
+        self.__file.seek(pos, where)
+        if self.__size < self.tell():
+            raise StreamError("Error when seek to (%s,%s) in a stream." % (pos, where))
+
+    def tell(self):
+        return self.__file.tell()
+
+    def __doSearch(self, binary_string, pos_max):
+        """
+        pos_max: Position of last tested byte
+        """
+        if 2048<=len(binary_string):
+            raise StreamError("Search string too big.")
+        size = 2048 
+        doublesize = size * 2
+        oldpos = self.tell()
+        if pos_max-oldpos+1<doublesize:
+            doublesize = pos_max-oldpos
+            size = 0 
+        buffer = self.__file.read(doublesize)
+        newpos = oldpos + size
+        while len(buffer) != 0:
+            pos = buffer.find(binary_string)
+            if pos != -1: return oldpos + pos
+            oldpos = newpos
+            if pos_max < oldpos + size:
+                size = pos_max - oldpos
+            if size == 0:
+                break
+            buffer = buffer[size:] + self.__file.read(size)
+            newpos = oldpos + size 
+        return -1 
+  
+    def search(self, binary_string, size_max=None):
+        if self.__size == 0: return -1
+        if size_max != None:
+            pos_max = self.tell()+size_max
+            if self.__size <= pos_max:
+                pos_max = sel.__size-1
+        else:
+            pos_max = self.__size-1
+        assert 0<=pos_max  and pos_max<self.__size
+        oldpos = self.tell()
+        pos = self.__doSearch(binary_string, pos_max)
+        self.seek(oldpos)
+        return pos
+
+    def getN(self, size, seek=True):
+        data = self.__file.read(size)
+        if len(data) != size:
+            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
+        if not seek:
+            self.__file.seek(-size, 1)
+        return data
+
+    def getEnd(self):
+        """
+        Read everything until the end.
+        """
+        
+        data = self.__file.read()
+        return data
+
+    def destroy(self):
+        self.__file.close()
+
+    def getSize(self):
+        return self.__size
+
+    def getLastPos(self):
+        return self.__size-1

Copied: haypo/hachoir/stream/gunzip.py (from rev 260, haypo/hachoir/gunzip_stream.py)
===================================================================
--- haypo/hachoir/gunzip_stream.py	2005-11-21 23:15:18 UTC (rev 260)
+++ haypo/hachoir/stream/gunzip.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,10 @@
+import gzip
+from StringIO import StringIO
+from file import FileStream
+
+def GunzipStream(data):
+    io = StringIO(data)
+    io = gzip.GzipFile(None, "r", None, io)
+    data = io.read()
+    io = StringIO(data)
+    return FileStream(io)

Added: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/stream/stream.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,82 @@
+import struct
+from error import StreamError
+
+class Stream:
+    def __init__(self, filename):
+        self.filename = filename
+    
+    def getSize(self):
+        return 0
+
+    def clone(self):
+        return None
+    
+    def getLastPos(self):
+        return 0
+
+    def eof(self):
+        return self.getLastPos() <= self.tell() 
+
+    def tell(self):
+        return 0
+
+    def createLimited(self, start, size):
+        return LimitedStream(self, start, size, self.filename)
+    
+    def getN(self, size, seek=True):
+        return None
+
+    def getFormat(self, format, seek=True):
+        size = struct.calcsize(format)
+        data = self.getN(size, seek)
+        return struct.unpack(format, data)
+
+    def searchLength(self, str, include_str, size_max=None):        
+        pos = self.search(str, size_max)
+        if pos == -1: return -1
+        lg = pos - self.tell()
+        if include_str: lg = lg + len(str)
+        return lg
+    
+    def search(self, str, size_max=None):
+        return -1
+
+class LimitedStream(Stream):
+    def __init__(self, stream, start=0, size=0, filename=None):
+        Stream.__init__(self, filename)
+        self.__stream = stream.clone()
+        if start<0:
+            start = 0
+        if self.__stream.getLastPos() < start+size:
+            size = self.__stream.getLastPos()-start
+        self.__start = start
+        self.__size = size
+        self.__end = self.__start + self.__size
+        self.__stream.seek(self.__start)
+
+    def search(self, str, size_max=None):
+        if self.__end == 0: return -1
+        if size_max == None or self.__end-self.tell() < size_max:
+            size_max = self.__end-self.tell()
+        assert 0<=size_max  and size_max<=self.__size
+        return self.__stream.search(str, size_max)
+
+    def getN(self, size, seek=True):
+        if self.__start+self.__size<self.__stream.tell()+size:
+            raise StreamError("Can't read outsize the stream.")
+        return self.__stream.getN(size, seek)
+
+    def tell(self):
+        return self.__stream.tell()
+
+    def seek(self, pos, where=0):
+        self.__stream.seek(pos, where)
+        
+    def getSize(self):
+        return self.__size
+    
+    def getLastPos(self):
+        return self.__end
+
+    def clone(self):
+        return LimitedStream(self.__stream, self.__start, self.__size, self.filename)

Added: haypo/hachoir/stream/string.py
===================================================================
--- haypo/hachoir/stream/string.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/stream/string.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -0,0 +1,6 @@
+from stream.file import FileStream
+from StringIO import StringIO
+
+def StringStream(data):
+    file = StringIO(data)
+    return FileStream(file)

Deleted: haypo/hachoir/stream.py
===================================================================
--- haypo/hachoir/stream.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/stream.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,179 +0,0 @@
-import struct
-from StringIO import StringIO
-
-class StreamError(Exception):
-    def __init__(self, msg):
-        Exception.__init__(self, msg)
-
-class Stream:
-    def __init__(self, filename):
-        self.filename = filename
-    
-    def getSize(self):
-        return 0
-
-    def clone(self):
-        return None
-    
-    def getLastPos(self):
-        return 0
-
-    def eof(self):
-        return self.getLastPos() <= self.tell() 
-
-    def tell(self):
-        return 0
-
-    def createLimited(self, start, size):
-        return LimitedStream(self, start, size, self.filename)
-    
-    def getN(self, size, seek=True):
-        return None
-
-    def getFormat(self, format, seek=True):
-        size = struct.calcsize(format)
-        data = self.getN(size, seek)
-        return struct.unpack(format, data)
-
-    def searchLength(self, str, include_str, size_max=None):        
-        pos = self.search(str, size_max)
-        if pos == -1: return -1
-        lg = pos - self.tell()
-        if include_str: lg = lg + len(str)
-        return lg
-    
-    def search(self, str, size_max=None):
-        return -1
-
-def StringStream(data):
-    file = StringIO(data)
-    return FileStream(file)
-
-class LimitedStream(Stream):
-    def __init__(self, stream, start=0, size=0, filename=None):
-        Stream.__init__(self, filename)
-        self.__stream = stream.clone()
-        if start<0:
-            start = 0
-        if self.__stream.getLastPos() < start+size:
-            size = self.__stream.getLastPos()-start
-        self.__start = start
-        self.__size = size
-        self.__end = self.__start + self.__size
-        self.__stream.seek(self.__start)
-
-    def search(self, str, size_max=None):
-        if self.__end == 0: return -1
-        if size_max == None or self.__end-self.tell() < size_max:
-            size_max = self.__end-self.tell()
-        assert 0<=size_max  and size_max<=self.__size
-        return self.__stream.search(str, size_max)
-
-    def getN(self, size, seek=True):
-        if self.__start+self.__size<self.__stream.tell()+size:
-            raise StreamError("Can't read outsize the stream.")
-        return self.__stream.getN(size, seek)
-
-    def tell(self):
-        return self.__stream.tell()
-
-    def seek(self, pos, where=0):
-        self.__stream.seek(pos, where)
-        
-    def getSize(self):
-        return self.__size
-    
-    def getLastPos(self):
-        return self.__end
-
-    def clone(self):
-        return LimitedStream(self.__stream, self.__start, self.__size, self.filename)
-
-class FileStream(Stream):
-    def __init__(self, file, filename=None):
-        """
-        Endian: See setEndian function. 
-        """
-
-        Stream.__init__(self, filename)
-        self.__file = file 
-        self.__file.seek(0,2) # Seek to end
-        self.__size = self.__file.tell()
-        self.__file.seek(0,0) # Seel to beginning
-
-    def clone(self):
-        return FileStream(self.__file, self.filename)
-
-    def seek(self, pos, where=0):
-        """ Read file seek document to understand where. """
-        self.__file.seek(pos, where)
-        if self.__size < self.tell():
-            raise StreamError("Error when seek to (%s,%s) in a stream." % (pos, where))
-
-    def tell(self):
-        return self.__file.tell()
-
-    def __doSearch(self, binary_string, pos_max):
-        """
-        pos_max: Position of last tested byte
-        """
-        if 2048<=len(binary_string):
-            raise StreamError("Search string too big.")
-        size = 2048 
-        doublesize = size * 2
-        oldpos = self.tell()
-        if pos_max-oldpos+1<doublesize:
-            doublesize = pos_max-oldpos
-            size = 0 
-        buffer = self.__file.read(doublesize)
-        newpos = oldpos + size
-        while len(buffer) != 0:
-            pos = buffer.find(binary_string)
-            if pos != -1: return oldpos + pos
-            oldpos = newpos
-            if pos_max < oldpos + size:
-                size = pos_max - oldpos
-            if size == 0:
-                break
-            buffer = buffer[size:] + self.__file.read(size)
-            newpos = oldpos + size 
-        return -1 
-  
-    def search(self, binary_string, size_max=None):
-        if self.__size == 0: return -1
-        if size_max != None:
-            pos_max = self.tell()+size_max
-            if self.__size <= pos_max:
-                pos_max = sel.__size-1
-        else:
-            pos_max = self.__size-1
-        assert 0<=pos_max  and pos_max<self.__size
-        oldpos = self.tell()
-        pos = self.__doSearch(binary_string, pos_max)
-        self.seek(oldpos)
-        return pos
-
-    def getN(self, size, seek=True):
-        data = self.__file.read(size)
-        if len(data) != size:
-            raise StreamError("Can't read %u bytes in a stream (get %u bytes)." % (size, len(data)))
-        if not seek:
-            self.__file.seek(-size, 1)
-        return data
-
-    def getEnd(self):
-        """
-        Read everything until the end.
-        """
-        
-        data = self.__file.read()
-        return data
-
-    def destroy(self):
-        self.__file.close()
-
-    def getSize(self):
-        return self.__size
-
-    def getLastPos(self):
-        return self.__size-1

Added: haypo/hachoir/ui/__init__.py
===================================================================

Copied: haypo/hachoir/ui/hachoir.glade (from rev 264, haypo/hachoir/hachoir.glade)

Copied: haypo/hachoir/ui/ui.py (from rev 264, haypo/hachoir/ui.py)

Copied: haypo/hachoir/ui/ui_new_chunk.py (from rev 264, haypo/hachoir/ui_new_chunk.py)

Copied: haypo/hachoir/ui/ui_new_string.py (from rev 264, haypo/hachoir/ui_new_string.py)

Copied: haypo/hachoir/ui/ui_popup.py (from rev 264, haypo/hachoir/ui_popup.py)

Copied: haypo/hachoir/ui/ui_property.py (from rev 264, haypo/hachoir/ui_property.py)

Copied: haypo/hachoir/ui/ui_window.py (from rev 265, haypo/hachoir/ui_window.py)

Deleted: haypo/hachoir/ui.py
===================================================================
--- haypo/hachoir/ui.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/ui.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,57 +0,0 @@
-import os
-import pygtk
-pygtk.require ('2.0') # 2.2 for Clipboard
-import gtk
-import gtk.glade
-
-def loadInterface(hachoir):
-    global ui 
-    global window
-    glade = os.path.join(os.path.dirname(__file__), 'hachoir.glade')
-    ui = GladeInterface(glade, hachoir)
-    window = ui.window
-    hachoir.ui = ui 
-    hachoir.ui.on_row_click = hachoir.onRowClick
-    hachoir.ui.on_go_parent = hachoir.onGoParent
-
-class GladeInterface:
-    def __init__(self, filename, hachoir):
-        self.hachoir = hachoir
-        self.glade_xml = filename
-        self.on_row_click = None # event(chunk_id)
-        self.on_go_parent = None # event(chunk_id)
-        self.build_ui()
-        self._clipboard = None
-        
-    def getClipboard(self):
-        if self._clipboard == None:
-            self._clipboard = gtk.Clipboard()
-        return self._clipboard
-
-    def run(self):
-        self.window.updateToolbar()
-        try:
-            gtk.main()
-        except KeyboardInterrupt:
-            print "Interrupted (CTRL+C)."
-
-    def loadAbout(self):
-        xml = gtk.glade.XML(self.glade_xml, "about_dialog")
-        self.about_dialog = xml.get_widget('about_dialog')
-        self.about_dialog.hide()
-        
-    def build_ui(self):
-        from ui_window import MainWindow
-        from ui_popup import TablePopup
-        from ui_property import PropertyDialog
-        self.window = MainWindow(self)
-        self.loadAbout()
-        self.table_popup = TablePopup(self, self.glade_xml)
-        self.property_dialog = PropertyDialog(self)
-        
-    def quit(self):
-        print "Quit."
-        gtk.main_quit()
-
-ui = None
-window = None

Deleted: haypo/hachoir/ui_new_chunk.py
===================================================================
--- haypo/hachoir/ui_new_chunk.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/ui_new_chunk.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,58 +0,0 @@
-import pygtk
-import gtk
-import gtk.glade
-from format import splitFormat
-
-class NewChunkDialog:
-    def __init__(self, filename):
-        xml = gtk.glade.XML(filename, "new_chunk")
-        self.window = xml.get_widget('new_chunk')
-        self.window.hide()
-        xml.signal_autoconnect(self)
-        self.label_widget = xml.get_widget("label")
-        self.size_widget = xml.get_widget("size")
-        self.endian_widget = xml.get_widget("endian")
-        self.format_widget = xml.get_widget("format")
-        self.id_widget = xml.get_widget("identifier")
-        self.desc_widget = xml.get_widget("description")
-
-    def getId(self):
-        return self.id_widget.get_text()
-
-    def getDescription(self):
-        return self.desc_widget.get_text()
-
-    def getFormat(self):
-        size = self.size_widget.get_text()
-        endian = self.endian_widget.child.get_text()
-        type = self.format_widget.child.get_text()
-        return "%s%s%s" % (endian, size, type)
-
-    def runNewChunk(self):
-        # TODO: i18n the text
-        self.window.set_title("New chunk")
-        self.label_widget.set_text("Choose a chunk format for the new chunk:")
-        self.size_widget.set_text("1")
-        self.endian_widget.child.set_text("!")
-        self.format_widget.child.set_text("s")
-        self.id_widget.set_text("raw")
-        self.desc_widget.set_text("Raw")
-        r = self.window.run()
-        self.window.hide()
-        return r
-
-    def runSetFormat(self, chunk):
-        # TODO: i18n the text
-        self.window.set_title("Set chunk format")
-        self.label_widget.set_text("Set chunk %s format to:" % chunk.id)
-        format = chunk.getFormat()
-        split = splitFormat(format)
-        if split != None:
-            self.size_widget.set_text(split[1])
-            self.endian_widget.child.set_text(split[0])
-            self.format_widget.child.set_text(split[2])
-        self.id_widget.set_text(chunk.id)
-        self.desc_widget.set_text(chunk.description)
-        r = self.window.run()
-        self.window.hide()
-        return r

Deleted: haypo/hachoir/ui_new_string.py
===================================================================
--- haypo/hachoir/ui_new_string.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/ui_new_string.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,27 +0,0 @@
-import pygtk
-import gtk
-import gtk.glade
-
-class NewStringDialog:
-    def __init__(self, filename):
-        xml = gtk.glade.XML(filename, "new_string")
-        self.window = xml.get_widget('new_string')
-        self.window.hide()
-        xml.signal_autoconnect(self)
-        self.format_widget = xml.get_widget("format")
-        self.id_widget = xml.get_widget("identifier")
-        self.desc_widget = xml.get_widget("description")
-
-    def getId(self):
-        return self.id_widget.get_text()
-
-    def getDescription(self):
-        return self.desc_widget.get_text()
-
-    def getFormat(self):
-        return self.format_widget.child.get_text()
-
-    def run(self):
-        r = self.window.run()
-        self.window.hide()
-        return r

Deleted: haypo/hachoir/ui_popup.py
===================================================================
--- haypo/hachoir/ui_popup.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/ui_popup.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,112 +0,0 @@
-import pygtk
-import gtk
-import gtk.glade
-from chunk import FormatChunk, FilterChunk, StringChunk
-from ui_new_chunk import NewChunkDialog
-from ui_new_string import NewStringDialog
-from format import splitFormat # TODO: remove this line
-from error import error
-
-MAX_CHUNK_SIZE=1024 # When copy to clipboard
-
-class TablePopup:
-    def __init__(self, ui, filename):
-        self.ui = ui
-        xml = gtk.glade.XML(filename, "table_popup")
-        self.popup = xml.get_widget('table_popup')
-        xml.signal_autoconnect(self)
-        self.chunk = None
-        self.new_chunk_dlg = NewChunkDialog(self.ui.glade_xml)
-        self.new_string_dlg = NewStringDialog(self.ui.glade_xml)
-
-        # Popup items
-        self.new_chunk = xml.get_widget("new_chunk")
-        self.new_filter = xml.get_widget("new_filter")
-        self.add_string = xml.get_widget("add_string")
-        self.convert = xml.get_widget("convert")
-        self.set_format = xml.get_widget("set_format")
-        self.delete_chunk = xml.get_widget("delete_chunk")
-        self.copy_clipboard = xml.get_widget("copy_clipboard")
-
-    def show(self, path_info, event):
-        col = path_info[0][0]
-        self.chunk = self.ui.window.getTableChunk(col)
-        if self.chunk == None:
-            error("Can't get chunk")
-            return
-
-        is_format_chunk = issubclass(self.chunk.__class__, FormatChunk)
-        is_string_chunk = issubclass(self.chunk.__class__, StringChunk)
-        is_filter_chunk = issubclass(self.chunk.__class__, FilterChunk)
-        self.new_chunk.set_sensitive(is_format_chunk or is_string_chunk)
-        self.new_filter.set_sensitive(is_format_chunk)
-        self.add_string.set_sensitive(is_format_chunk)
-        self.convert.set_sensitive(is_format_chunk or is_filter_chunk)
-        self.set_format.set_sensitive(is_format_chunk)
-
-        chunks = self.chunk.getParent().getChunks()
-        if self.chunk.getParent().getParent() != None:
-            can_delete = (1 < len(chunks)) or not is_format_chunk
-        else:
-            can_delete = chunks.index(self.chunk) < (len(chunks)-1) or not is_format_chunk
-
-        self.delete_chunk.set_sensitive(can_delete)
-        can_copy = (self.chunk.size < MAX_CHUNK_SIZE) and not is_filter_chunk
-        self.copy_clipboard.set_sensitive(can_copy)
-        self.popup.popup( None, None, None, event.button, event.time)
-
-    def onDeleteChunk(self, event):
-        self.chunk.getParent().deleteChunk(self.chunk)
-
-    def onConvert(self, event):
-        if issubclass(self.chunk.__class__, FormatChunk):
-            self.chunk.getParent().convertChunkToFilter(self.chunk)
-        elif issubclass(self.chunk.__class__, FilterChunk):
-            self.chunk.getParent().convertFilterToChunk(self.chunk)
-        else:
-            error("Can't convert chunk %s" % self.chunk.id)
-        
-    def onNewChunk(self, event):
-        if self.new_chunk_dlg.runNewChunk() == gtk.RESPONSE_CANCEL: return
-        assert issubclass(self.chunk.__class__, FormatChunk)
-        format = self.new_chunk_dlg.getFormat()
-        id = self.new_chunk_dlg.getId()
-        desc = self.new_chunk_dlg.getDescription()
-        self.chunk.setFormat(format, "split", id, desc)
-        self.chunk.getParent().redisplay()
-
-    def onNewFilter(self, event):
-        if self.new_chunk_dlg.runNewChunk() == gtk.RESPONSE_CANCEL: return
-        assert issubclass(self.chunk.__class__, FormatChunk) and self.chunk.isString()
-        format = self.new_chunk_dlg.getFormat()
-        split_format = splitFormat(format)
-        size = split_format[1]
-        id = self.new_chunk_dlg.getId()
-        desc = self.new_chunk_dlg.getDescription()
-        self.chunk.getParent().addNewFilter(self.chunk, id, size, desc)
-
-    def onCopyClipboard(self, event):
-        text = self.chunk.getStringValue()
-        self.ui.getClipboard().set_text(text)
-
-    def onAddString(self, event):
-        dlg = self.new_string_dlg
-        if dlg.run() == gtk.RESPONSE_CANCEL: return
-        str_type = dlg.getFormat()
-
-        assert issubclass(self.chunk.__class__, FormatChunk)
-        self.chunk.getParent().addString(str_type, self.chunk)
-        
-    def onSetFormat(self, event):
-        assert issubclass(self.chunk.__class__, FormatChunk)
-        if self.new_chunk_dlg.runSetFormat(self.chunk) == gtk.RESPONSE_CANCEL: return
-        format = self.new_chunk_dlg.getFormat()
-        self.chunk.id = self.new_chunk_dlg.getId()
-        self.chunk.description = self.new_chunk_dlg.getDescription()
-        try:
-            self.chunk.setFormat(format, "rescan")
-        except Exception, msg:
-            error("Exception while trying to set chunk %s format to \"%s\": %s" \
-                % (self.chunk.id, format, msg))
-            pass
-        self.chunk.getParent().redisplay()

Deleted: haypo/hachoir/ui_property.py
===================================================================
--- haypo/hachoir/ui_property.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/ui_property.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,27 +0,0 @@
-import pygtk
-import gtk
-import gtk.glade
-from format import splitFormat
-
-class PropertyDialog:
-    def __init__(self, ui):
-        self.ui = ui
-        xml = gtk.glade.XML(self.ui.glade_xml, "filter_property")
-        self.window = xml.get_widget("filter_property")
-        self.window.hide()
-        xml.signal_autoconnect(self)
-        self.id_widget = xml.get_widget("id")
-        self.desc_widget = xml.get_widget("description")
-
-    def getId(self):
-        return self.id_widget.get_text()
-
-    def getDescription(self):
-        return self.desc_widget.get_text()
-
-    def run(self, filter):
-        self.id_widget.set_text(filter.getId())
-        self.desc_widget.set_text(filter.getDescription())
-        r = self.window.run()
-        self.window.hide()
-        return r

Deleted: haypo/hachoir/ui_window.py
===================================================================
--- haypo/hachoir/ui_window.py	2005-11-24 02:46:05 UTC (rev 265)
+++ haypo/hachoir/ui_window.py	2005-11-25 00:24:50 UTC (rev 266)
@@ -1,163 +0,0 @@
-import os
-import pygtk
-import gtk
-import gtk.glade
-
-class MainWindow:
-    def __init__(self, ui):
-        self.ui = ui
-        xml = gtk.glade.XML(self.ui.glade_xml, "main_window")
-        self.window = xml.get_widget('main_window')
-        self.statusbar = xml.get_widget('statusbar')
-        self.toolbar = xml.get_widget('toolbar')
-        self.toolbutton_parent = xml.get_widget('toolbutton_parent')
-        self.toolbutton_new = xml.get_widget('toolbutton_new')
-        self.toolbutton_open = xml.get_widget('toolbutton_open')
-        self.toolbutton_save = xml.get_widget('toolbutton_save')
-        self.toolbutton_property = xml.get_widget('toolbutton_property')
-        self.statusbar_state = self.statusbar.get_context_id("State")
-        self.table = xml.get_widget('table')
-        self.table_store = None
-        xml.signal_autoconnect(self)
-        self.window.connect("key-press-event", self.onKeyUp)
-        self.table.connect("button_press_event", self.on_treeview_button_press_event)
-        self.window.set_size_request(760,500)
-        self.build_table()
-        
-    def updateToolbar(self):
-        file_present = (self.ui.hachoir.getFilter() != None)
-        self.toolbutton_open.set_sensitive(file_present)
-        self.toolbutton_save.set_sensitive(file_present)
-        if not file_present:
-            self.toolbutton_parent.set_sensitive(False)
-        self.toolbutton_property.set_sensitive(file_present)
-
-    def getTableChunk(self, col):
-        chunk_id = self.table_store[col][3]
-        if chunk_id == None: return None
-        return self.ui.hachoir.getFilter().getChunk(chunk_id)
-
-    def on_treeview_button_press_event(self, treeview, event):
-        if event.button == 3:
-            x = int(event.x)
-            y = int(event.y)
-            time = event.time
-            pthinfo = treeview.get_path_at_pos(x, y)
-            if pthinfo != None:
-                path, col, cellx, celly = pthinfo
-                treeview.grab_focus()
-                treeview.set_cursor( path, col, 0)
-                self.ui.table_popup.show(pthinfo, event)
-            return 1
-
-    def updateStatusBar(self, text):
-        self.statusbar.push(self.statusbar_state, text)
-        
-    def enableParentButton(self, enable):
-        self.toolbutton_parent.set_sensitive(enable)
-
-    def clear_table(self):
-        self.table_store.clear()
-
-    def set_table_value(self, iter, column, value):
-        row = self.table_store[iter]
-        row[column] = value
-       
-    def add_table_child(self, parent, addr, size, format, id, description):
-        return self.table_store.append(parent, (addr, format, size, None, id, description, None,))
-       
-    def add_table(self, parent, addr, size, format, id, description, value):
-        self.table_store.append(parent, (addr, format, size, id, value, description, ))
-
-    def onKeyUp(self, widget, key, data=None):
-        if key.keyval == gtk.keysyms.Escape:
-            self.on_go_parent()
-        
-    def onTableClicked(self, widget, iter, data=None):
-        row = self.table_store[iter]
-        self.ui.on_row_click(row[3])
-
-    def build_table(self):
-        self.table_store = gtk.TreeStore(int, str, int, str, str, str)
-        self.table.set_model(self.table_store)
-        self.table.connect("row-activated", self.onTableClicked)
-        self.treeview_add_column(self.table, "Address", 0)
-        self.treeview_add_column(self.table, "Format", 1)
-        self.treeview_add_column(self.table, "Size", 2)
-        self.treeview_add_column(self.table, "Name", 3)
-        self.treeview_add_column(self.table, "Value", 4)
-        self.treeview_add_column(self.table, "Description", 5)
-        self.table.set_reorderable(True)
-        self.treeselection = self.table.get_selection()
-
-    def treeview_add_column(self, treeview, name, num):
-        col = gtk.TreeViewColumn(name)
-        treeview.append_column(col)
-        cell = gtk.CellRendererText()
-        col.pack_start(cell, True)
-        col.add_attribute(cell, 'text', num)
-        treeview.set_search_column(num)
-        col.set_sort_column_id(num)
- 
-    def on_toolbutton_parent(self, widget, data=None):
-        self.ui.on_go_parent()
-
-    def on_toolbutton_new(self, widget):
-        self.on_open_activate(widget)
-
-    def on_toolbutton_property(self, widget):
-        filter = self.ui.hachoir.getFilter()
-        dlg = self.ui.property_dialog
-        if dlg.run(filter) == gtk.RESPONSE_CANCEL: return
-        filter.setId( dlg.getId() )
-        filter.setDescription( dlg.getDescription() )
-        filter.updateStatusBar()
-        
-    def on_open_activate(self, widget):
-        chooser = gtk.FileChooserDialog( \
-            title="Choose file to split",
-            action=gtk.FILE_CHOOSER_ACTION_OPEN,
-            buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
-        if chooser.run() == gtk.RESPONSE_OK:
-            filename = chooser.get_filename() 
-            self.ui.hachoir.loadFile(filename)
-        chooser.destroy()
-
-    def on_toolbutton_open(self, widget):
-        chooser = gtk.FileChooserDialog( \
-            title="Choose filter",
-            action=gtk.FILE_CHOOSER_ACTION_OPEN,
-            buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
-        if chooser.run() == gtk.RESPONSE_OK:
-            filename = chooser.get_filename() 
-            self.ui.hachoir.loadUser(filename)
-        chooser.destroy()
-
-    def on_toolbutton_export(self, widget):
-        chooser = gtk.FileChooserDialog( \
-            title="Export current filter to python script ...",
-            action=gtk.FILE_CHOOSER_ACTION_SAVE,
-            buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
-        if chooser.run() == gtk.RESPONSE_OK:
-            filename = chooser.get_filename() 
-            self.ui.hachoir.exportUser(filename)
-        chooser.destroy()
-
-    def on_toolbutton_save(self, widget):
-        chooser = gtk.FileChooserDialog( \
-            title="Save XML filter into ...",
-            action=gtk.FILE_CHOOSER_ACTION_SAVE,
-            buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
-        if chooser.run() == gtk.RESPONSE_OK:
-            filename = chooser.get_filename() 
-            self.ui.hachoir.saveUser(filename)
-        chooser.destroy()
-
-    def on_about_activate(self, widget):
-        self.ui.about_dialog.show()
-
-    def on_quit_activate(self, widget):
-        self.ui.quit()
-
-    def on_window_destroy(self, widget, data=None):
-        self.ui.quit()



From haypo at berlios.de  Fri Nov 25 04:04:54 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 25 Nov 2005 04:04:54 +0100
Subject: [Happyboom-svn] r267 - in haypo/hachoir: . plugins stream
Message-ID: <200511250304.jAP34sM7019931@sheep.berlios.de>

Author: haypo
Date: 2005-11-25 04:04:27 +0100 (Fri, 25 Nov 2005)
New Revision: 267

Added:
   haypo/hachoir/stream/bunzip.py
Modified:
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/bzip2.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/stream/deflate.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/stream/gunzip.py
   haypo/hachoir/stream/string.py
Log:
Finish bzip2 plugin.


Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/filter.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -319,17 +319,19 @@
     def readLimitedChild(self, id, size, filter_class, *args):
         start = self._stream.tell()
         limited = self._stream.createLimited(start, size)
-        filter = filter_class(limited, self, *args)
+        chunk = self.readStreamChild(id, limited, filter_class, *args)
+        assert self._stream.tell() == (start+size)
+        return chunk
+        
+    def readStreamChild(self, id, stream, filter_class, *args): 
+        oldpos = self._stream.tell()
+        filter = filter_class(stream, self, *args)
         chunk = self.addFilter(id, filter)
         chunk.postProcess()
-        self._stream.seek(start+size)
         return chunk
         
     def readChild(self, id, filter_class, *args): 
-        filter = filter_class(self._stream, self, *args)
-        chunk = self.addFilter(id, filter)
-        chunk.postProcess()
-        return chunk
+        return self.readStreamChild(id, self._stream, filter_class, *args)
     
     def addFilter(self, id, filter): 
         chunk = FilterChunk(id, filter, self)

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/hachoir_class.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -95,11 +95,7 @@
 
     def loadStream(self, stream, filename=None):
         # Look for a plugin
-        plugin = getPluginByStream(stream, filename)
-        if plugin != None:
-            split_class = plugin
-        else:
-            split_class = DefaultFilter
+        split_class = getPluginByStream(stream, filename)
             
         # Split 
         try:

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/plugin.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -1,5 +1,6 @@
 import re
 from mime import getFileMime, getBufferMime
+from default import DefaultFilter
 
 def guessPlugin(stream, filename):
     oldpos = stream.tell()
@@ -15,7 +16,7 @@
     global hachoir_plugins
     mime = mime[0]
     if mime not in hachoir_plugins:
-        return None
+        return DefaultFilter
     plugins = hachoir_plugins[mime]
     if 1<len(plugins):
         warning("More than one plugin have same MIME...")

Modified: haypo/hachoir/plugins/bzip2.py
===================================================================
--- haypo/hachoir/plugins/bzip2.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/plugins/bzip2.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -2,9 +2,21 @@
 BZIP2 archive file
 """
 
+from plugin import guessPlugin
 from filter import Filter
 from plugin import registerPlugin
+from stream.bunzip import BunzipStream
 
+class BzipDataFilter(Filter):
+    def __init__(self, stream, parent, bz_stream, filter):
+        Filter.__init__(self, "deflate", "Deflate", bz_stream, parent)
+        self._addr = stream.tell()
+        self.readChild("data", filter)
+        self._compressed_size = stream.getSize() - stream.tell()
+
+    def getSize(self):
+        return self._compressed_size
+
 class Bzip2_File(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "bz2_file", "Bzip2 archive file", stream, parent)
@@ -13,7 +25,7 @@
         self.read("blocksize", "c", "Block size")
         assert "1" <= self.blocksize and self.blocksize <= "9"
         # Size of memory needed to decompress (on classic mode, not "small" mode)
-        size = (ord(self.blocksize) - ord("0")) * 400
+        size = (ord(self.blocksize) - ord("0")) * 100
         self.getChunk("blocksize").description = "Block size (will need %u KB of memory)" % size
         self.read("blockheader", "B", "Block header")
         assert self.blockheader in (0x17, 0x31)
@@ -21,6 +33,11 @@
             self.readA()
         else: # blockheader = 0x31 ("1")
             self.readB()
+        dataio = BunzipStream(stream)
+        plugin = guessPlugin(dataio, None)
+        print "Plugin = ", plugin
+        #self.readStreamChild("data", dataio, plugin)
+        self.readChild("data", BzipDataFilter, dataio, plugin)
 
     def readB(self):
         self.read("id2", "5s", "Identifier 2 (AY&SY)")

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/plugins/tar.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -98,20 +98,17 @@
         if self.type in ("\0", "0"):
             substream = stream.createLimited(stream.tell(), self.size)
             plugin = guessPlugin(substream, self.name)
-            ok = False
-            if plugin != None:
-                oldpos = stream.tell()
-                try:
-                    chunk = self.readLimitedChild("filedata", self.size, plugin)
-                    ok = True
-                except Exception, msg:
-                    error("Error while processing tar file \"%s\": %s" % (self.name, msg))
-                    stream.seek(oldpos)
 
-            if not ok:
+            oldpos = stream.tell()
+            try:
+                chunk = self.readLimitedChild("filedata", self.size, plugin)
+            except Exception, msg:
+                error("Error while processing tar file \"%s\": %s" % (self.name, msg))
+                stream.seek(oldpos)
                 chunk = self.readChild("filedata", EmptyFilter)
                 filter = chunk.getFilter()
                 filter.read("filedata", "!%us" % self.size, "File data", truncate=True)
+
         if stream.tell() % 512 != 0:
             padding = 512 - stream.tell() % 512
             self.read("padding", "!%ss" % padding, "Padding (512 align)", truncate=True)

Added: haypo/hachoir/stream/bunzip.py
===================================================================
--- haypo/hachoir/stream/bunzip.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/stream/bunzip.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -0,0 +1,41 @@
+import bz2 
+from cStringIO import StringIO
+from file import FileStream
+import os
+
+def BunzipStream(stream):
+    if True: #not isinstance(stream, FileStream):
+        filename = None
+        realname = os.tmpnam()
+        file = open(realname, 'w')
+        oldpos = stream.tell()
+        stream.seek(0)
+        file.write(stream.getN(stream.getSize()))
+        stream.seek(oldpos)
+        file.close()
+    else:
+        print "Ok."
+        filename = stream.filename
+        realname = filename
+       
+    # TODO: Is it the best value !?
+    buffersize = 4096 
+    io = bz2.BZ2File(realname, "r", buffersize)
+
+    if filename==None:
+        os.unlink(realname)
+
+    # Check data size
+    io.seek(0,2)
+    guess_size = io.tell()
+    io.seek(0)
+
+    io.seek(-1,2)
+    real_size = io.tell() + 1
+    io.seek(0)
+   
+    # Workaroud Python bug :-(
+    if real_size != guess_size:
+        io = StringIO(io.read())
+
+    return FileStream(io, filename)

Modified: haypo/hachoir/stream/deflate.py
===================================================================
--- haypo/hachoir/stream/deflate.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/stream/deflate.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -1,5 +1,5 @@
 import zlib
-from StringIO import StringIO
+from cStringIO import StringIO
 from filter import Filter
 from file import FileStream
 

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/stream/file.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -9,9 +9,11 @@
 
         Stream.__init__(self, filename)
         self.__file = file 
+        print "Get size ..."
         self.__file.seek(0,2) # Seek to end
         self.__size = self.__file.tell()
         self.__file.seek(0,0) # Seel to beginning
+        print "Done : %s" % self.__size
 
     def clone(self):
         return FileStream(self.__file, self.filename)

Modified: haypo/hachoir/stream/gunzip.py
===================================================================
--- haypo/hachoir/stream/gunzip.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/stream/gunzip.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -1,9 +1,10 @@
 import gzip
-from StringIO import StringIO
+from cStringIO import StringIO
 from file import FileStream
 
 def GunzipStream(data):
     io = StringIO(data)
+    print io
     io = gzip.GzipFile(None, "r", None, io)
     data = io.read()
     io = StringIO(data)

Modified: haypo/hachoir/stream/string.py
===================================================================
--- haypo/hachoir/stream/string.py	2005-11-25 00:24:50 UTC (rev 266)
+++ haypo/hachoir/stream/string.py	2005-11-25 03:04:27 UTC (rev 267)
@@ -1,5 +1,5 @@
 from stream.file import FileStream
-from StringIO import StringIO
+from cStringIO import StringIO
 
 def StringStream(data):
     file = StringIO(data)



From haypo at berlios.de  Fri Nov 25 06:50:50 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Fri, 25 Nov 2005 06:50:50 +0100
Subject: [Happyboom-svn] r268 - in haypo/hachoir: . plugins stream
Message-ID: <200511250550.jAP5ooQL032636@sheep.berlios.de>

Author: haypo
Date: 2005-11-25 06:49:28 +0100 (Fri, 25 Nov 2005)
New Revision: 268

Added:
   haypo/hachoir/plugins/deb.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/mime.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/bzip2.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/stream/gunzip.py
   haypo/hachoir/stream/stream.py
   haypo/hachoir/tools.py
Log:
Add support to DEB archive. Create new stream: SubStream (will replace
LimitedString?). Lot of bugfix...


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/chunk.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -234,7 +234,7 @@
     def __replaceFieldFormat(self, match):
         id = match.group(1)
         if id == "@end@":
-            size = self._stream.getLastPos() - self.addr + 1
+            size = self._stream.getLastPos() - self.addr
         else:
             size = getattr(self._parent, id)
         return str(size)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/filter.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -243,13 +243,21 @@
     def redisplay(self):  
         self.display()
     
-    def updateStatusBar(self):
+    def getPath(self):
+        """
+        Get path to the filter.
+        Example: "grandparent > parent > item"
+        """
         text = ""
         current = self
         while current != None:
             if text != "": text = " > " + text
             text = current.getId() + text
             current = current.getParent()
+        return text
+
+    def updateStatusBar(self):
+        text = self.getPath()
         ui.window.updateStatusBar("%s: %s (size=%s)" % (text, self.getDescription(), self.getSize()))
 
     def display(self):  
@@ -328,16 +336,18 @@
         filter = filter_class(stream, self, *args)
         chunk = self.addFilter(id, filter)
         chunk.postProcess()
+        self._stream.seek(chunk.addr + chunk.size)
         return chunk
         
     def readChild(self, id, filter_class, *args): 
-        return self.readStreamChild(id, self._stream, filter_class, *args)
+        chunk = self.readStreamChild(id, self._stream, filter_class, *args)
+        return chunk
     
     def addFilter(self, id, filter): 
         chunk = FilterChunk(id, filter, self)
         self._appendChunk(chunk)
         filter.updateParent(chunk)
-        self._stream.seek(chunk.addr + chunk.size)
+#        self._stream.seek(chunk.addr + chunk.size)
         return chunk
 
     def readArray(self, id, entry_class, description, end_func): 
@@ -487,3 +497,13 @@
             self.getStream(), self.getParent(), self._entry_class, self._end_func)
         new.filter_chunk = self.filter_chunk
         return new
+
+class DeflateFilter(Filter):
+    def __init__(self, stream, parent, bz_stream, size, filter):
+        Filter.__init__(self, "deflate", "Deflate", bz_stream, parent)
+        self._addr = stream.tell()
+        self.readChild("data", filter)
+        self._compressed_size = size
+
+    def getSize(self):
+        return self._compressed_size

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/hachoir_class.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -74,8 +74,9 @@
         my.exportPython(filename)
         
     def _addPadding(self):
-        size = self._filter.getSize()
-        diff_size = (size - self._filter.getStream().getSize())
+        filter_size = self._filter.getSize()
+        stream_size = self._filter.getStream().getSize()
+        diff_size = filter_size - stream_size
         if diff_size < 0:
             chunks = self._filter.getChunks()
             if len(chunks) != 0:

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/mime.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -27,13 +27,22 @@
         return 'application/x-gzip'
     return None        
 
+def _getBufferMime(buffer):    
+    if ord(buffer[0])==31 and ord(buffer[1])==139:
+        return "application/x-gzip"
+    return None        
+
 def getBufferMime(buffer, filename):
     magic = getInstance()
-    mime = magic.buffer(buffer)
-    mime = mime.split(",")
-    if mime[0] == 'application/octet-stream' and filename != None:
+    mimes = magic.buffer(buffer)
+    mimes = mimes.split(" ")
+    import string
+    mimes = map(string.split, mimes, ',')
+    if mimes[0][0] == 'application/octet-stream' and filename != None:
         ext = os.path.splitext(filename)[1]
-        new_mime = getMimeByExt(ext)
+        new_mime = _getBufferMime(buffer)
+        if new_mime == None:
+            new_mime = getMimeByExt(ext)
         if new_mime != None:
-            mime = (new_mime,)
-    return mime            
+            mimes = ((new_mime,),)
+    return mimes

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/plugin.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -12,26 +12,31 @@
     stream.seek(oldpos)
     return plugin
 
-def getPluginByMime(mime):
+def getPluginByMime(mimes):
     global hachoir_plugins
-    mime = mime[0]
-    if mime not in hachoir_plugins:
-        return DefaultFilter
-    plugins = hachoir_plugins[mime]
+    plugins = []
+    for mime in mimes:
+        mime = mime[0]
+        if mime in hachoir_plugins:
+            plugins = plugins + hachoir_plugins[mime]
+    if len(plugins)==0:
+        plugins = (DefaultFilter,)
     if 1<len(plugins):
         warning("More than one plugin have same MIME...")
-    return plugins[0]       
+    return plugins[0]
     
 def getPluginByBuffer(buffer, filename):
     mime = getBufferMime(buffer, filename)
     return getPluginByMime(mime)
 
 def getPluginByStream(stream, filename):
+    oldpos = stream.tell()
     stream.seek(0)
     size = stream.getSize()
     if 4096<size:
         size = 4096
     data = stream.getN(size)
+    stream.seek(oldpos)
     mime = getBufferMime(data, filename)
     return getPluginByMime(mime)
 

Modified: haypo/hachoir/plugins/bzip2.py
===================================================================
--- haypo/hachoir/plugins/bzip2.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/plugins/bzip2.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -3,20 +3,10 @@
 """
 
 from plugin import guessPlugin
-from filter import Filter
+from filter import Filter, DeflateFilter
 from plugin import registerPlugin
 from stream.bunzip import BunzipStream
 
-class BzipDataFilter(Filter):
-    def __init__(self, stream, parent, bz_stream, filter):
-        Filter.__init__(self, "deflate", "Deflate", bz_stream, parent)
-        self._addr = stream.tell()
-        self.readChild("data", filter)
-        self._compressed_size = stream.getSize() - stream.tell()
-
-    def getSize(self):
-        return self._compressed_size
-
 class Bzip2_File(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "bz2_file", "Bzip2 archive file", stream, parent)
@@ -37,7 +27,8 @@
         plugin = guessPlugin(dataio, None)
         print "Plugin = ", plugin
         #self.readStreamChild("data", dataio, plugin)
-        self.readChild("data", BzipDataFilter, dataio, plugin)
+        size = stream.getSize()-stream.tell()
+        self.readChild("data", DeflateFilter, dataio, size, plugin)
 
     def readB(self):
         self.read("id2", "5s", "Identifier 2 (AY&SY)")

Added: haypo/hachoir/plugins/deb.py
===================================================================
--- haypo/hachoir/plugins/deb.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/plugins/deb.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -0,0 +1,34 @@
+"""
+Debian (.deb) archive file
+"""
+
+from filter import Filter, DeflateFilter
+from plugin import registerPlugin, guessPlugin
+   
+class DebianFileEntry(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "file_entry", "File entry", stream, parent)
+        self.readString("header", "UnixLine", "Header")
+#        info = re.split(" +", self.header)
+        info = self.header.split()
+        filename = info[0]
+        size = int(info[5])
+        dataio = stream.createSub(stream.tell(), size)
+        plugin = guessPlugin(dataio, filename)
+#        self.readStreamChild("data", dataio, plugin)
+#        self.read("data", "%us" % size, "Data")
+        self.readChild("data", DeflateFilter, dataio, size, plugin)
+        
+class DebianFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "deb_file", "Debian archive file", stream, parent)
+        self.readString("id", "UnixLine", "Debian archive identifier")
+        self.readString("header", "UnixLine", "Header")
+        self.readString("version", "UnixLine", "Version")
+        self.readArray("file", DebianFileEntry, "Files", self.checkEnd)
+
+    def checkEnd(self, stream, array, last):
+#        if len(array)==1: return True
+        return stream.eof()
+        
+registerPlugin(DebianFile, "application/x-debian-package")

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/plugins/gzip.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -6,22 +6,21 @@
 """
 
 import datetime
-from filter import Filter
+from filter import Filter, DeflateFilter
 from plugin import registerPlugin
 from stream.gunzip import GunzipStream
 from plugin import getPluginByStream
 from error import error
 from default import DefaultFilter
+from tools import getBacktrace
    
 class GunzipFilter(Filter):
     def __init__(self, stream, parent, start, size, filter_class):
         # Read data
         self._parent_stream = stream
-        self._parent_stream.seek(0)
-        data = stream.getN(self._parent_stream.getSize())
         
         # Create a new stream
-        stream = GunzipStream(data)
+        stream = GunzipStream(self._parent_stream)
         self._compressed_size = size 
         self._decompressed_size = stream.getSize()
 
@@ -59,17 +58,15 @@
         oldpos = stream.tell()
         size = stream.getSize() - oldpos - 8
         try:
-            # TODO: Fix this fucking GunzipStream (use something better)
-            stream.seek(0)
-            data = stream.getN(stream.getSize())
-            stream = GunzipStream(data)
-            stream.seek(oldpos)
-            plugin = getPluginByStream(stream, self.filename)
-            # END OF TODO
+            gz_stream = GunzipStream(stream)
+            if hasattr(self, "filename"):
+                plugin = getPluginByStream(gz_stream, self.filename)
+            else:
+                plugin = getPluginByStream(gz_stream, None)
 
-            self.readChild("data", GunzipFilter, oldpos, size, plugin) 
+            self.readChild("data", DeflateFilter, gz_stream, size, plugin) 
         except Exception, msg:
-            error("Error while processing file in gzip: %s" % msg)
+            error("Error while processing file in gzip: %s\ns%s" % (msg, getBacktrace()))
             stream.seek(oldpos)
             self.read("data", "!%us" % size, "Compressed data", truncate=True)
         

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/plugins/tar.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -7,12 +7,13 @@
 
 import re
 from datetime import datetime
-from filter import Filter
+from filter import Filter, DeflateFilter
 from plugin import registerPlugin
 from tools import convertDataToPrintableString
 from default import EmptyFilter
 from plugin import guessPlugin 
 from error import error
+from tools import getBacktrace, humanFilesize
 
 def displayModeItem(mode):
     if mode & 4 == 4: r="r"
@@ -96,14 +97,15 @@
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
         if self.type in ("\0", "0"):
-            substream = stream.createLimited(stream.tell(), self.size)
+            substream = stream.createSub(stream.tell(), self.size)
             plugin = guessPlugin(substream, self.name)
 
             oldpos = stream.tell()
             try:
-                chunk = self.readLimitedChild("filedata", self.size, plugin)
+                chunk = self.readChild("filedata", DeflateFilter, substream, self.size, plugin)
+#                chunk = self.readLimitedChild("filedata", stream, self.size, plugin)
             except Exception, msg:
-                error("Error while processing tar file \"%s\": %s" % (self.name, msg))
+                error("Error while processing tar file \"%s\": %s\n%s" % (self.name, msg, getBacktrace()))
                 stream.seek(oldpos)
                 chunk = self.readChild("filedata", EmptyFilter)
                 filter = chunk.getFilter()
@@ -142,7 +144,8 @@
 
     def updateParent(self, chunk):
         if not self.isEmpty():
-            text = "Tar File (%s: %s)" % (self.name, self.getType())
+            text = "Tar File (%s: %s, %s)" \
+                % (self.name, self.getType(), humanFilesize(self.size))
         else:
             text = "Tar File (terminator, empty header)"
         chunk.description = self.description = text

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/stream/file.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -9,11 +9,9 @@
 
         Stream.__init__(self, filename)
         self.__file = file 
-        print "Get size ..."
         self.__file.seek(0,2) # Seek to end
         self.__size = self.__file.tell()
         self.__file.seek(0,0) # Seel to beginning
-        print "Done : %s" % self.__size
 
     def clone(self):
         return FileStream(self.__file, self.filename)

Modified: haypo/hachoir/stream/gunzip.py
===================================================================
--- haypo/hachoir/stream/gunzip.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/stream/gunzip.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -2,9 +2,13 @@
 from cStringIO import StringIO
 from file import FileStream
 
-def GunzipStream(data):
+def GunzipStream(stream):
+    oldpos = stream.tell()
+    stream.seek(0)
+    data = stream.getN(stream.getSize())
+    stream.seek(oldpos)
+    
     io = StringIO(data)
-    print io
     io = gzip.GzipFile(None, "r", None, io)
     data = io.read()
     io = StringIO(data)

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/stream/stream.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -20,6 +20,9 @@
     def tell(self):
         return 0
 
+    def createSub(self, start, size):
+        return SubStream(self, start, size, self.filename)
+
     def createLimited(self, start, size):
         return LimitedStream(self, start, size, self.filename)
     
@@ -44,39 +47,70 @@
 class LimitedStream(Stream):
     def __init__(self, stream, start=0, size=0, filename=None):
         Stream.__init__(self, filename)
-        self.__stream = stream.clone()
+        self._stream = stream.clone()
         if start<0:
             start = 0
-        if self.__stream.getLastPos() < start+size:
-            size = self.__stream.getLastPos()-start
-        self.__start = start
-        self.__size = size
-        self.__end = self.__start + self.__size
-        self.__stream.seek(self.__start)
+        if self._stream.getLastPos() < start+size:
+            size = self._stream.getLastPos()-start
+        self._start = start
+        self._size = size
+        self._end = self._start + self._size
+        self._stream.seek(self._start)
 
     def search(self, str, size_max=None):
-        if self.__end == 0: return -1
-        if size_max == None or self.__end-self.tell() < size_max:
-            size_max = self.__end-self.tell()
-        assert 0<=size_max  and size_max<=self.__size
-        return self.__stream.search(str, size_max)
+        if self._end == 0: return -1
+        if size_max == None or self._end-self.tell() < size_max:
+            size_max = self._end-self.tell()
+        assert 0<=size_max  and size_max<=self._size
+        return self._stream.search(str, size_max)
 
     def getN(self, size, seek=True):
-        if self.__start+self.__size<self.__stream.tell()+size:
-            raise StreamError("Can't read outsize the stream.")
-        return self.__stream.getN(size, seek)
+        if self._start+self._size<self._stream.tell()+size:
+            raise StreamError( \
+                "Can't read outsize the stream\n"
+                +"(try to read %u byte(s) from position %s, where stream in limited in [%u;%u])" \
+                % (size, self._stream.tell(), self._start, self._end))
+        return self._stream.getN(size, seek)
 
     def tell(self):
-        return self.__stream.tell()
+        return self._stream.tell()
 
     def seek(self, pos, where=0):
-        self.__stream.seek(pos, where)
+        self._stream.seek(pos, where)
         
     def getSize(self):
-        return self.__size
+        return self._size
     
     def getLastPos(self):
-        return self.__end
+        return self._end
 
     def clone(self):
-        return LimitedStream(self.__stream, self.__start, self.__size, self.filename)
+        return LimitedStream(self._stream, self._start, self._size, self.filename)
+
+class SubStream(LimitedStream):
+    def search(self, str, size_max=None):
+        if self._end == 0: return -1
+        max = self._end-self.tell()-self._start-1
+        if size_max == None or max < size_max:
+            size_max = max
+        assert 0<=size_max  and size_max<=self._size
+        pos = self._stream.search(str, size_max)
+        if pos != -1:
+            pos = pos - self._start
+        return pos
+
+    def seek(self, pos, where=0):
+        if where==2:
+            pos = pos - self._start
+        else:
+            pos = pos + self._start
+        self._stream.seek(pos, where)
+
+    def tell(self):
+        return self._stream.tell() - self._start
+    
+    def getLastPos(self):
+        return self._end - self._start
+
+    def clone(self):
+        return SubStream(self._stream, self._start, self._size, self.filename)

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-11-25 03:04:27 UTC (rev 267)
+++ haypo/hachoir/tools.py	2005-11-25 05:49:28 UTC (rev 268)
@@ -1,6 +1,20 @@
 import traceback, sys
 import string
 
+def humanFilesize(size):
+    if size < 1000:
+        return "%u bytes" % size
+    units = ["KB", "MB", "GB"]
+    size = float(size)
+    for unit in units:
+        size = size / 1024
+        if size < 100:
+            return "%.1f %s" % (size, unit)
+        if size < 1000:
+            return "%u %s" % (size, unit)
+        last_unit = unit
+    return "%u %s" % (size, unit)
+
 def convertDataToPrintableString(data):
     if len(data) == 0:
         return "(empty)"



From haypo at berlios.de  Sat Nov 26 19:43:48 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sat, 26 Nov 2005 19:43:48 +0100
Subject: [Happyboom-svn] r269 - in haypo/hachoir: . plugins stream
Message-ID: <200511261843.jAQIhm8K002274@sheep.berlios.de>

Author: haypo
Date: 2005-11-26 19:43:46 +0100 (Sat, 26 Nov 2005)
New Revision: 269

Added:
   haypo/hachoir/plugins/email.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/mime.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/stream/stream.py
   haypo/hachoir/stream/string.py
   haypo/hachoir/tools.py
Log:
Add email filter. Reorganize stream methods:
- move FileStream._doSearch in Stream
- create read() method (works like Posix read: returns 0 to size bytes)
Stream.search() and Stream.searchLength() now supports regular expression :-)

Fix StringChunk for AutoLine, it really works now.
Fix MIME type splitter.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/chunk.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -125,29 +125,26 @@
     def _read(self):
         self._stream.seek(self.addr)
         if self._str_type == "UnixLine":
-            end = "\n"
+            self._size = self._stream.searchLength("\n", True)
+            len_eol = 1
         elif self._str_type == "WindowsLine":
-            end = "\r\n"
+            self._size = self._stream.searchLength("\r\n", True)
+            len_eol = 2
         elif self._str_type == "MacLine":
-            end = "\r"
+            self._size = self._stream.searchLength("\r", True)
         elif self._str_type == "AutoLine":
-            end = "\r"
+            self._size = self._stream.searchLength(re.compile("[\n\r]"), True)
+            len_eol = 1
+            if self._size != -1:
+                self._stream.seek(self.addr + self._size-1)
+                if self._stream.getN(1) == "\r" and self._stream.read(1) == "\n":
+                    len_eol = 2
         else: 
-            # Type: C string
-            end = "\0"
-        self._size = self._stream.searchLength(end, True)
+            self._size = self._stream.searchLength("\0", True)
+            len_eol = 1
         assert self._size != -1
-        if self._str_type == "AutoLine":
-            self._stream.seek(self.addr+self._size)
-            try:
-                next = self._stream.getN(1)
-                if next == '\n':
-                    self._size = self._size + 1
-                    end = end+"\n"
-            except Exception, err:
-                warning("Warning while getting end of line of \"auto line\": %s" % err)
         self._stream.seek(self.addr)
-        self.str = self._stream.getN(self._size - len(end))
+        self.str = self._stream.getN(self._size - len_eol)
 
     def update(self):
         Chunk.update(self)

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/filter.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -69,7 +69,7 @@
 
     def getUniqChunkId(self, id):
         if id not in self._chunks_dict: return id
-        m = re.compile("^(.*)([0-9]+)$").match(id)
+        m = re.compile("^(.*?)([0-9]+)$").match(id)
         if m != None:
             root = m.group(1)
             uniq = int(m.group(2))+1

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/mime.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -35,9 +35,9 @@
 def getBufferMime(buffer, filename):
     magic = getInstance()
     mimes = magic.buffer(buffer)
-    mimes = mimes.split(" ")
+    mimes = mimes.split(", ")
     import string
-    mimes = map(string.split, mimes, ',')
+    mimes = map(string.split, mimes, ';')
     if mimes[0][0] == 'application/octet-stream' and filename != None:
         ext = os.path.splitext(filename)[1]
         new_mime = _getBufferMime(buffer)

Added: haypo/hachoir/plugins/email.py
===================================================================
--- haypo/hachoir/plugins/email.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/plugins/email.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -0,0 +1,25 @@
+"""
+Email parser
+
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class EmailFilter(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "email", "Email parser", stream, parent)
+        print "OK"
+        id = "header"
+        ok = True
+        while ok:
+            id = self.getUniqChunkId(id)
+            chunk = self.readString(id, "AutoLine", "Header line")
+            print "+ %s" % chunk.value
+            ok = (0 < len(chunk.value))
+
+#    def checkEnd(self, stream, array, last):        
+#        return stream.eof()
+
+registerPlugin(EmailFilter, "text/x-mail")

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/stream/file.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -12,6 +12,9 @@
         self.__file.seek(0,2) # Seek to end
         self.__size = self.__file.tell()
         self.__file.seek(0,0) # Seel to beginning
+        
+    def read(self, size):        
+        return self.__file.read(size)
 
     def clone(self):
         return FileStream(self.__file, self.filename)
@@ -25,46 +28,6 @@
     def tell(self):
         return self.__file.tell()
 
-    def __doSearch(self, binary_string, pos_max):
-        """
-        pos_max: Position of last tested byte
-        """
-        if 2048<=len(binary_string):
-            raise StreamError("Search string too big.")
-        size = 2048 
-        doublesize = size * 2
-        oldpos = self.tell()
-        if pos_max-oldpos+1<doublesize:
-            doublesize = pos_max-oldpos
-            size = 0 
-        buffer = self.__file.read(doublesize)
-        newpos = oldpos + size
-        while len(buffer) != 0:
-            pos = buffer.find(binary_string)
-            if pos != -1: return oldpos + pos
-            oldpos = newpos
-            if pos_max < oldpos + size:
-                size = pos_max - oldpos
-            if size == 0:
-                break
-            buffer = buffer[size:] + self.__file.read(size)
-            newpos = oldpos + size 
-        return -1 
-  
-    def search(self, binary_string, size_max=None):
-        if self.__size == 0: return -1
-        if size_max != None:
-            pos_max = self.tell()+size_max
-            if self.__size <= pos_max:
-                pos_max = sel.__size-1
-        else:
-            pos_max = self.__size-1
-        assert 0<=pos_max  and pos_max<self.__size
-        oldpos = self.tell()
-        pos = self.__doSearch(binary_string, pos_max)
-        self.seek(oldpos)
-        return pos
-
     def getN(self, size, seek=True):
         data = self.__file.read(size)
         if len(data) != size:
@@ -73,17 +36,6 @@
             self.__file.seek(-size, 1)
         return data
 
-    def getEnd(self):
-        """
-        Read everything until the end.
-        """
-        
-        data = self.__file.read()
-        return data
-
-    def destroy(self):
-        self.__file.close()
-
     def getSize(self):
         return self.__size
 

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/stream/stream.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -1,10 +1,13 @@
 import struct
 from error import StreamError
+from tools import regexMaxLength
 
 class Stream:
     def __init__(self, filename):
         self.filename = filename
     
+    #--- Virtual functions --------------------------------------------------
+    
     def getSize(self):
         return 0
 
@@ -14,36 +17,106 @@
     def getLastPos(self):
         return 0
 
+    def tell(self):
+        return 0
+    
+    def read(self, size):
+        """ Works like Posix read (can returns less than size bytes. """
+        return None
+    
+    def getN(self, size, seek=True):
+        """
+        Read size bytes. If seek=False, stay at the same position in the
+        stream. This function always returns size bytes, else it raise an
+        exception (StreamError).
+        """
+        return None
+    
+    #--- End of virtual functions -------------------------------------------    
+
     def eof(self):
         return self.getLastPos() <= self.tell() 
 
-    def tell(self):
-        return 0
-
     def createSub(self, start, size):
         return SubStream(self, start, size, self.filename)
 
     def createLimited(self, start, size):
         return LimitedStream(self, start, size, self.filename)
-    
-    def getN(self, size, seek=True):
-        return None
 
     def getFormat(self, format, seek=True):
+        """
+        Read data using struct format. Eg. getFormat("BB") returns (10, 14).
+        """
         size = struct.calcsize(format)
         data = self.getN(size, seek)
         return struct.unpack(format, data)
 
-    def searchLength(self, str, include_str, size_max=None):        
-        pos = self.search(str, size_max)
+    def searchLength(self, needle, include_str, size_max=None):        
+        pos = self.search(needle, size_max)
         if pos == -1: return -1
         lg = pos - self.tell()
-        if include_str: lg = lg + len(str)
+        if include_str:
+            if isinstance(needle, str):
+                lg = lg + len(needle)
+            else:
+                lg = lg + regexMaxLength(needle.pattern)
         return lg
-    
-    def search(self, str, size_max=None):
-        return -1
+  
+    def search(self, needle, size_max=None):
+        size = self.getSize()
+        if size == 0: return -1
+        if size_max != None:
+            pos_max = self.tell()+size_max
+            if size <= pos_max:
+                pos_max = size-1
+        else:
+            pos_max = size-1
+        assert 0<=pos_max  and pos_max<size
+        oldpos = self.tell()
+        pos = self._doSearch(needle, pos_max)
+        self.seek(oldpos)
+        return pos
 
+    def _doSearch(self, needle, pos_max):
+        """
+        Search a string between current position and pos_max (which will be
+        also tested). Returns -1 if fails.
+        """
+        is_regex =  not isinstance(needle, str)
+        if is_regex:
+            len_needle = regexMaxLength(needle.pattern)
+        else:
+            len_needle = len(needle)
+        if 2048<=len_needle:
+            raise StreamError("Search string too big.")
+        size = 2048 
+        doublesize = size * 2
+        oldpos = self.tell()
+        max = pos_max-oldpos+1
+        if max<doublesize:
+            doublesize = max 
+            size = 0 
+        buffer = self.read(doublesize)
+        newpos = oldpos + size
+        while len(buffer) != 0:
+            if is_regex:
+                match = needle.search(buffer)
+                if match != None:
+                    pos = match.start(0)
+                else:
+                    pos = -1
+            else:
+                pos = buffer.find(needle)
+            if pos != -1: return oldpos + pos
+            oldpos = newpos
+            if pos_max < oldpos + size:
+                size = pos_max - oldpos
+            if size == 0:
+                break
+            buffer = buffer[size:] + self.read(size)
+            newpos = oldpos + size 
+        return -1 
+
 class LimitedStream(Stream):
     def __init__(self, stream, start=0, size=0, filename=None):
         Stream.__init__(self, filename)

Modified: haypo/hachoir/stream/string.py
===================================================================
--- haypo/hachoir/stream/string.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/stream/string.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -1,4 +1,4 @@
-from stream.file import FileStream
+from file import FileStream
 from cStringIO import StringIO
 
 def StringStream(data):

Modified: haypo/hachoir/tools.py
===================================================================
--- haypo/hachoir/tools.py	2005-11-25 05:49:28 UTC (rev 268)
+++ haypo/hachoir/tools.py	2005-11-26 18:43:46 UTC (rev 269)
@@ -1,6 +1,93 @@
-import traceback, sys
-import string
+import traceback, sys, string, re
 
+def _regexMaxLength(pattern, in_parenthesis=False):
+    """
+    Don't use this function directly, use regexMagLength!
+    """
+
+    re_letter = re.compile( r"^[^][()|.?+*{}](.*)$")
+    re_set = re.compile( r"^\[" + r"[^]]*" + r"\](.*)$" )
+    re_min_repetition = re.compile( r"^\{([0-9]+)\}(.*)$" )
+    re_min_max_repetition = re.compile( r"^\{([0-9]+),([0-9]+)\}(.*)$" )
+
+    size = 0
+    atom_size = 0
+    state = 0 # get atom
+    is_end = len(pattern) == 0
+    if in_parenthesis and not is_end:
+        is_end = pattern[0] in ("|", ")")
+    while not is_end:
+        if state==0:
+            size = size + atom_size
+
+            # Pattern: [...] => size=1
+            if pattern[0] == '(':
+                pattern = pattern[1:]
+                atom_size = None
+                while True:
+                    tmp_atom_size, pattern = _regexMaxLength(pattern, True)
+                    if tmp_atom_size == None:
+                        return None, pattern
+                    if atom_size==None or atom_size<tmp_atom_size:
+                        atom_size = tmp_atom_size
+                    if pattern[0] == ')':
+                        break
+                    assert pattern[0] == '|'
+                    pattern = pattern[1:]
+                pattern = pattern[1:]
+            else:
+                m = re_set.match(pattern)
+                if m != None:
+                    pattern = m.group(1)
+                    atom_size = 1
+                else:
+                    m = re_letter.match(pattern)
+                    if m == None:
+                        return (-1, pattern,)
+                    atom_size = 1
+                    pattern = m.group(1)
+            state = 1                
+        else:
+            assert state==1
+
+            # Repetiton: + or * => no limit
+            if pattern[0] in ("*", "+"):
+                return (None, pattern,)
+            
+            # Repetition: {2}
+            m = re_min_repetition.match(pattern)
+            if m != None:
+                repetition = int(m.group(1))
+                print "(rep=%sx%s)" % (atom_size, repetition)
+                pattern = m.group(2)
+                atom_size = atom_size * repetition
+            else:
+                # Repetition: {1,2}
+                m = re_min_max_repetition.match(pattern)
+                if m != None:
+                    repetition = int(m.group(2))
+                    pattern = m.group(3)
+                    atom_size = atom_size * repetition
+            state = 0
+
+        is_end = len(pattern) == 0
+        if in_parenthesis and not is_end:
+            is_end = pattern[0] in ("|", ")")
+
+    return (size + atom_size, pattern,)
+
+def regexMaxLength(pattern):
+    """
+    Get maximum size of a regular expression pattern.
+    Returns (size, pattern). If size=-1, an error occurs (pattern contains
+    the buggy pattern). If size=-1, no limit does exist.
+    """
+
+    size, pattern = _regexMaxLength(pattern)
+    if size == -1:
+        raise "Can't parse regular expression: %s" % pattern 
+    return size 
+
 def humanFilesize(size):
     if size < 1000:
         return "%u bytes" % size



From haypo at berlios.de  Sun Nov 27 03:07:26 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 27 Nov 2005 03:07:26 +0100
Subject: [Happyboom-svn] r270 - in haypo/hachoir: . plugins
Message-ID: <200511270207.jAR27Q7G017539@sheep.berlios.de>

Author: haypo
Date: 2005-11-27 03:07:19 +0100 (Sun, 27 Nov 2005)
New Revision: 270

Modified:
   haypo/hachoir/mime.py
   haypo/hachoir/plugins/email.py
Log:
Email now support multipart email. Create splitMimes to parse MIME string.


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-26 18:43:46 UTC (rev 269)
+++ haypo/hachoir/mime.py	2005-11-27 02:07:19 UTC (rev 270)
@@ -1,5 +1,5 @@
 #!/usr/bin/python
-import os, stat
+import os, stat, string
 
 instance = None
 
@@ -32,12 +32,38 @@
         return "application/x-gzip"
     return None        
 
+def splitMimes(mimes):
+    """
+    Split MIME types into a list.
+    Examples:
+    - "text/plain; encoding=latin-1" => [["text/plain", {"encoding": latin-1"}]
+    - "text/plain, text/xml" => [["text/plain"],["text/xml"]]
+    - "text/plain; charset=ISO-8859-1; format=flowed"
+      => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
+    """
+
+    list = []
+    for mime in map(string.strip, mimes.split(",")):
+        parts = mime.split(";")
+        mime = parts[0]
+        parts = map(string.strip, parts[1:])
+        values = {}
+        for part in parts:
+            split_part = part.split("=", 1)             
+            values[ split_part[0] ] = split_part[1]
+        list.append([mime,values])
+    return list
+        
+    mimes = map(string.split, mimes, ';')
+    print mimes
+#    for key in mimes:
+#        mimes[key] = map(string.strip, mimes[key])    
+    return mimes
+
 def getBufferMime(buffer, filename):
     magic = getInstance()
     mimes = magic.buffer(buffer)
-    mimes = mimes.split(", ")
-    import string
-    mimes = map(string.split, mimes, ';')
+    mimes = splitMimes(mimes)
     if mimes[0][0] == 'application/octet-stream' and filename != None:
         ext = os.path.splitext(filename)[1]
         new_mime = _getBufferMime(buffer)

Modified: haypo/hachoir/plugins/email.py
===================================================================
--- haypo/hachoir/plugins/email.py	2005-11-26 18:43:46 UTC (rev 269)
+++ haypo/hachoir/plugins/email.py	2005-11-27 02:07:19 UTC (rev 270)
@@ -6,20 +6,113 @@
 
 from filter import Filter
 from plugin import registerPlugin
+from error import warning
+from mime import splitMimes
+import re
 
+class EmailHeader(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "email_hdr", "Email header", stream, parent)
+        self._dict = {}
+        regex_new = re.compile("^([A-Za-z-]+): (.*)$")
+        regex_continue = re.compile("^\t(.*)$")
+        linenb = 1
+        last_key = None
+        last_index = None
+        while True:
+            id = "header[%u]" % linenb
+            chunk = self.readString(id, "AutoLine", "Header line")
+            line = chunk.value
+            if len(line) == 0: return
+
+            m = regex_new.match(line)
+            if m != None:
+                last_key = m.group(1)
+                last_index = self._newHeader(last_key, m.group(2))
+            else:
+                m = regex_continue.match(line)
+                if m != None:
+                    assert last_key != None
+                    self._appendHeader(last_key, last_index, m.group(1))
+                else:
+                    warning("Can't parse line %u: %s" % (linenb, line))
+
+            linenb = linenb + 1
+
+    def _appendHeader(self, key, index, value):
+        key = key.lower()
+        self._dict[key][index] = self._dict[key][index] + " " + value
+        
+    def _newHeader(self, key, value):
+        key = key.lower()
+        if key in self._dict:
+            index = len(self._dict[key])
+            self._dict[key].append(value)
+        else:
+            index = 0
+            self._dict[key] = [value]
+        return index
+
+    def __getitem__(self, index):
+        index = index.lower()
+        return self._dict[index]
+
+class EmailPart(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "email_part", "Email part", stream, parent)
+        self.readChild("header", EmailHeader)
+        linenb = 1 
+        nb_empty_line = 0
+        while not stream.eof():
+            id = "header[%u]" % linenb
+            chunk = self.readString(id, "AutoLine", "Header line")
+            linenb = linenb + 1
+
 class EmailFilter(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "email", "Email parser", stream, parent)
-        print "OK"
-        id = "header"
-        ok = True
-        while ok:
-            id = self.getUniqChunkId(id)
-            chunk = self.readString(id, "AutoLine", "Header line")
-            print "+ %s" % chunk.value
-            ok = (0 < len(chunk.value))
+        self.readString("id", "AutoLine", "Email identifier")
+        self.readChild("header", EmailHeader)
+        mime = self.getMime()
+        if mime[0] == "multipart/mixed":
+            self.readMultipart(mime[1]["boundary"])
+        else:
+            # TODO :-)
+            pass
 
-#    def checkEnd(self, stream, array, last):        
-#        return stream.eof()
+    def readMultipart(self, boundary):
+        assert boundary[0] == '"' and boundary[-1] == '"'
+        boundary = "--" + boundary[1:-1]
+        end_boundary = boundary + "--"
+        count = 1
+        while True:
+            id = "multipart_space[%u]" % count
+            chunk = self.readString(id, "AutoLine", "Space before first email parts")
+            value = chunk.value
+            if value == boundary:
+                break
+            count = count + 1
 
+        part = 1
+        boundary_index = 1
+        stream = self.getStream()
+        while True:
+            start = stream.tell()
+            size = stream.searchLength(boundary, False)
+            sub = stream.createSub(start, size)
+            self.readStreamChild("part[%u]" % part, sub, EmailPart)
+            stream.seek(start+size)
+            chunk = self.readString("boundary[%u]" % boundary_index, "AutoLine", "Boundary")
+            part = part + 1
+            boundary_index = boundary_index + 1
+            if chunk.value == boundary+"--":
+                break
+    
+    def getMime(self):
+        content_type = self.header["Content-Type"]
+        assert len(content_type) == 1
+        mimes = splitMimes(content_type[0])
+        assert len(mimes) == 1
+        return mimes[0]
+
 registerPlugin(EmailFilter, "text/x-mail")



From haypo at berlios.de  Sun Nov 27 07:11:23 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 27 Nov 2005 07:11:23 +0100
Subject: [Happyboom-svn] r271 - in haypo/hachoir: . plugins stream ui
Message-ID: <200511270611.jAR6BNOU023968@sheep.berlios.de>

Author: haypo
Date: 2005-11-27 07:11:13 +0100 (Sun, 27 Nov 2005)
New Revision: 271

Added:
   haypo/hachoir/config.py
   haypo/hachoir/stream/base_64.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/bzip2.py
   haypo/hachoir/plugins/email.py
   haypo/hachoir/plugins/exe.py
   haypo/hachoir/plugins/gif.py
   haypo/hachoir/plugins/gzip.py
   haypo/hachoir/plugins/jpeg.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/zip.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/stream/stream.py
   haypo/hachoir/ui/ui_window.py
Log:
Big change in filter: now attributes have to be read like self["key"] and
not self.key. The big advantage is that we now use "read on demand", better
than "read always". So "can_truncate" argument disapears because no more
needed.

It's now possible to read email attachment ;-) Also write stream for
base64 data.

Add parent address for FilterChunk chunks, so it's correctly displayed.

String chunk don't read data on creation, but on demand, and use a cache.

UI : Auto size columns.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/chunk.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -1,6 +1,5 @@
-import struct
-import re
-import types
+import struct, re, types
+from config import config
 from format import checkFormat, splitFormat
 from error import warning, error
 from tools import convertDataToPrintableString
@@ -67,8 +66,11 @@
     value = property(getValue)
     
 class FilterChunk(Chunk):
-    def __init__(self, id, filter, parent):
-        Chunk.__init__(self, id, filter.getDescription(), filter.getStream(), filter.getAddr(), filter.getSize(), parent)
+    def __init__(self, id, filter, parent, parent_addr):
+        Chunk.__init__(self, id, \
+            filter.getDescription(), filter.getStream(), filter.getAddr(), \
+            filter.getSize(), parent)
+        self.parent_addr = parent_addr
         self._filter = filter
         self._filter.filter_chunk = self
     
@@ -105,11 +107,17 @@
         return self._filter
 
 class StringChunk(Chunk):
+    cache_hit = 0
+
     def __init__(self, id, description, stream, str_type, parent):
         assert str_type in ("C", "UnixLine", "WindowsLine", "MacLine", "AutoLine")
         Chunk.__init__(self, id, description, stream, stream.tell(), 0, parent)
         self._str_type = str_type
-        self._read()
+        self.eol = None
+        self._findSize()
+        self._cache_addr = None
+        self._cache_max_size = None
+        self._cache_value = None
 
     def getFormat(self):
         names = {
@@ -122,43 +130,62 @@
         assert self._str_type in names
         return names[self._str_type]
 
-    def _read(self):
+    def _findSize(self):
         self._stream.seek(self.addr)
+        if self._str_type == "AutoLine":
+            self._size = self._stream.searchLength(re.compile("[\n\r]"), True)
+            assert self._size != -1
+            self._stream.seek(self.addr + self._size-1)
+            self.eol = self._stream.getN(1)
+            if self.eol == "\r" and self._stream.read(1) == "\n":
+                self.eol = "\r\n"
+            self.length = self._size - len(self.eol)
+            return
+
         if self._str_type == "UnixLine":
-            self._size = self._stream.searchLength("\n", True)
-            len_eol = 1
+            self.eol = "\n"
         elif self._str_type == "WindowsLine":
-            self._size = self._stream.searchLength("\r\n", True)
-            len_eol = 2
+            self.eol = "\r\n"
         elif self._str_type == "MacLine":
-            self._size = self._stream.searchLength("\r", True)
-        elif self._str_type == "AutoLine":
-            self._size = self._stream.searchLength(re.compile("[\n\r]"), True)
-            len_eol = 1
-            if self._size != -1:
-                self._stream.seek(self.addr + self._size-1)
-                if self._stream.getN(1) == "\r" and self._stream.read(1) == "\n":
-                    len_eol = 2
+            self.eol = "\r"
         else: 
-            self._size = self._stream.searchLength("\0", True)
-            len_eol = 1
+            self.eol = "\0"
+        self._size = self._stream.searchLength(self.eol, True)
         assert self._size != -1
+        self.length = self._size - len(self.eol)
+        self._stream.seek(self.addr + self._size)
+        
+    def _read(self, max_size):
+        if self._cache_addr==self.addr and self._cache_max_size==max_size:
+            StringChunk.cache_hit = StringChunk.cache_hit + 1
+            return self._cache_value
+        self._cache_addr = self.addr
+        self._cache_max_size = max_size
+
         self._stream.seek(self.addr)
-        self.str = self._stream.getN(self._size - len_eol)
+        size = self._size - len(self.eol)
+        if max_size != None and max_size<size:
+            text = self._stream.getN(max_size)+"(...)"
+        else:
+            text = self._stream.getN(size)
+        self._stream.seek(self.addr + self._size)
+        self._cache_value = text
+        return text
 
     def update(self):
         Chunk.update(self)
-        self._read()
+        self._findSize()
 
     def getValue(self, max_size=None):
-        return self.str
+        return self._read(None)
     value = property(getValue)
 
     def getDisplayData(self):
         if self.display != None:
             return self.display
         else:
-            return convertDataToPrintableString(self.str)
+            text = self._read(config["max_string_length"])
+            return convertDataToPrintableString(text)
         
 class FormatChunkCache:
     def __init__(self, chunk):
@@ -233,7 +260,7 @@
         if id == "@end@":
             size = self._stream.getLastPos() - self.addr
         else:
-            size = getattr(self._parent, id)
+            size = self._parent[id]
         return str(size)
     
     def convertToStringSize(self, size):

Added: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/config.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -0,0 +1,3 @@
+config = { \
+    "max_string_length": 30
+}    

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/filter.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -2,10 +2,8 @@
 Base class for all splitter filters.
 """
 
-import struct
-import re, sys
-import string
-import types
+import struct, re, sys, string, types
+from config import config
 import ui.ui as ui
 from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
 from format import splitFormat    
@@ -27,6 +25,9 @@
         self._chunks_dict = {}
         self._addr = self._stream.tell()
 
+    def __getitem__(self, chunk_id):
+        return self.getChunk(chunk_id).getValue()
+
     def clone(self):
         if self.__class__ == Filter:
             return None
@@ -238,7 +239,11 @@
 
     def displayChunk(self, chunk):
         type = chunk.getFormat()
-        ui.window.add_table(None, chunk.addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
+        if isinstance(chunk, FilterChunk):
+            addr = chunk.parent_addr
+        else:
+            addr = chunk.addr
+        ui.window.add_table(None, addr, chunk.size, type, chunk.id, chunk.description, chunk.getDisplayData())
 
     def redisplay(self):  
         self.display()
@@ -291,7 +296,7 @@
 
     def updateFormatChunk(self, chunk):
         if chunk.id == None: return
-        data = chunk.getValue(40)
+        data = chunk.getValue(config["max_string_length"])
         setattr(self, chunk.id, data)       
 
     def _appendChunk(self, chunk, can_truncate=False, position=None):
@@ -315,13 +320,6 @@
             if id not in self._chunks_dict:
                 self._chunks_dict[id] = array 
         else:
-            if hasattr(self, id):
-                raise Exception("Chunk identifier \"%s\" already exist!" % id)
-            if can_truncate:
-                data = chunk.getValue(40)
-            else:
-                data = chunk.getValue()
-            setattr(self, id, data)
             self._chunks_dict[id] = chunk
 
     def readLimitedChild(self, id, size, filter_class, *args):
@@ -334,17 +332,17 @@
     def readStreamChild(self, id, stream, filter_class, *args): 
         oldpos = self._stream.tell()
         filter = filter_class(stream, self, *args)
-        chunk = self.addFilter(id, filter)
+        filter.setId(id)
+        chunk = self.addFilter(id, filter, oldpos)
         chunk.postProcess()
         self._stream.seek(chunk.addr + chunk.size)
         return chunk
         
     def readChild(self, id, filter_class, *args): 
-        chunk = self.readStreamChild(id, self._stream, filter_class, *args)
-        return chunk
+        return self.readStreamChild(id, self._stream, filter_class, *args)
     
-    def addFilter(self, id, filter): 
-        chunk = FilterChunk(id, filter, self)
+    def addFilter(self, id, filter, addr): 
+        chunk = FilterChunk(id, filter, self, addr)
         self._appendChunk(chunk)
         filter.updateParent(chunk)
 #        self._stream.seek(chunk.addr + chunk.size)
@@ -353,10 +351,10 @@
     def readArray(self, id, entry_class, description, end_func): 
         """
         end_func: def isEnd(stream, array, last_filter)
-
         """
+        addr = self._stream.tell()
         filter = ArrayFilter(id, description, self._stream, self, entry_class, end_func)
-        chunk = self.addFilter(id, filter)
+        chunk = self.addFilter(id, filter, addr)
         chunk.postProcess()
         return chunk
     
@@ -415,7 +413,7 @@
         filter._appendChunk(chunk, can_truncate=True)
         
         # Create new chunk and add it into self 
-        new_chunk = FilterChunk(chunk.id, filter, self)
+        new_chunk = FilterChunk(chunk.id, filter, self, chunk.addr)
         pos = self._chunks.index(chunk)
         self._chunks[pos] = new_chunk
         self._chunks_dict[chunk.id] = new_chunk
@@ -440,10 +438,11 @@
         nb = 0
         last_filter = None
         while not self._end_func(self._stream, self._array, last_filter):
-            filter = self._entry_class(self._stream, self)
             chunk_id = "%s[%u]" % (self.getId(), nb)
+            addr = self._stream.tell()
+            filter = self._entry_class(self._stream, self)
             nb = nb + 1
-            chunk = FilterChunk(chunk_id, filter, self)
+            chunk = FilterChunk(chunk_id, filter, self, addr)
             self._array.append( chunk )
             self._appendChunk(chunk)
             last_filter = filter

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugin.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -12,7 +12,7 @@
     stream.seek(oldpos)
     return plugin
 
-def getPluginByMime(mimes):
+def getPluginByMime(mimes, default=DefaultFilter):
     global hachoir_plugins
     plugins = []
     for mime in mimes:
@@ -20,16 +20,16 @@
         if mime in hachoir_plugins:
             plugins = plugins + hachoir_plugins[mime]
     if len(plugins)==0:
-        plugins = (DefaultFilter,)
+        plugins = (default,)
     if 1<len(plugins):
         warning("More than one plugin have same MIME...")
     return plugins[0]
     
-def getPluginByBuffer(buffer, filename):
+def getPluginByBuffer(buffer, filename, default=DefaultFilter):
     mime = getBufferMime(buffer, filename)
-    return getPluginByMime(mime)
+    return getPluginByMime(mime, default)
 
-def getPluginByStream(stream, filename):
+def getPluginByStream(stream, filename, default=DefaultFilter):
     oldpos = stream.tell()
     stream.seek(0)
     size = stream.getSize()
@@ -38,17 +38,20 @@
     data = stream.getN(size)
     stream.seek(oldpos)
     mime = getBufferMime(data, filename)
-    return getPluginByMime(mime)
+    return getPluginByMime(mime, default)
 
-def getPluginByFile(filename, realname=None):
+def getPluginByFile(filename, realname=None, default=DefaultFilter):
     mime = getFileMime(filename, realname)
-    return getPluginByMime(mime)
+    return getPluginByMime(mime, default)
     
-def registerPlugin(filter_class, mime):
+def registerPlugin(filter_class, mimes):
     global hachoir_plugins
-    if mime in hachoir_plugins:
-        hachoir_plugins[mime].append(filter_class)
-    else:
-        hachoir_plugins[mime] = [filter_class]
+    if isinstance(mimes, str):
+        mimes = [mimes]
+    for mime in mimes:
+        if mime in hachoir_plugins:
+            hachoir_plugins[mime].append(filter_class)
+        else:
+            hachoir_plugins[mime] = [filter_class]
 
 hachoir_plugins = {} 

Modified: haypo/hachoir/plugins/bzip2.py
===================================================================
--- haypo/hachoir/plugins/bzip2.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/bzip2.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -11,28 +11,26 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "bz2_file", "Bzip2 archive file", stream, parent)
         self.read("id", "3s", "Identifier (BZh)")
-        assert self.id == "BZh"
+        assert self["id"] == "BZh"
         self.read("blocksize", "c", "Block size")
-        assert "1" <= self.blocksize and self.blocksize <= "9"
+        assert "1" <= self["blocksize"] and self["blocksize"] <= "9"
         # Size of memory needed to decompress (on classic mode, not "small" mode)
-        size = (ord(self.blocksize) - ord("0")) * 100
+        size = (ord(self["blocksize"]) - ord("0")) * 100
         self.getChunk("blocksize").description = "Block size (will need %u KB of memory)" % size
         self.read("blockheader", "B", "Block header")
-        assert self.blockheader in (0x17, 0x31)
-        if self.blockheader == 0x17:
+        assert self["blockheader"] in (0x17, 0x31)
+        if self["blockheader"] == 0x17:
             self.readA()
         else: # blockheader = 0x31 ("1")
             self.readB()
         dataio = BunzipStream(stream)
         plugin = guessPlugin(dataio, None)
-        print "Plugin = ", plugin
-        #self.readStreamChild("data", dataio, plugin)
         size = stream.getSize()-stream.tell()
         self.readChild("data", DeflateFilter, dataio, size, plugin)
 
     def readB(self):
         self.read("id2", "5s", "Identifier 2 (AY&SY)")
-        assert self.id2 == "AY&SY"
+        assert self["id2"] == "AY&SY"
         self.read("crc", "<L", "CRC32")
         
     def readA(self):

Modified: haypo/hachoir/plugins/email.py
===================================================================
--- haypo/hachoir/plugins/email.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/email.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -4,10 +4,12 @@
 Author: Victor Stinner
 """
 
-from filter import Filter
-from plugin import registerPlugin
+from filter import Filter, DeflateFilter
+from plugin import registerPlugin, getPluginByMime
 from error import warning
 from mime import splitMimes
+from error import warning
+from stream.base_64 import Base64Stream
 import re
 
 class EmailHeader(Filter):
@@ -22,8 +24,8 @@
         while True:
             id = "header[%u]" % linenb
             chunk = self.readString(id, "AutoLine", "Header line")
+            if chunk.length == 0: return
             line = chunk.value
-            if len(line) == 0: return
 
             m = regex_new.match(line)
             if m != None:
@@ -35,7 +37,7 @@
                     assert last_key != None
                     self._appendHeader(last_key, last_index, m.group(1))
                 else:
-                    warning("Can't parse line %u: %s" % (linenb, line))
+                    warning("Can't parse email header: %s" % line)
 
             linenb = linenb + 1
 
@@ -61,58 +63,96 @@
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "email_part", "Email part", stream, parent)
         self.readChild("header", EmailHeader)
+        readEmailContent(self, stream.createSub(), True)
+
+class EmailBody(Filter):
+    def __init__(self, stream, parent=None, in_multipart=True):
+        Filter.__init__(self, "email_body", "Email body", stream, parent)
         linenb = 1 
-        nb_empty_line = 0
+        empty_line = 0
         while not stream.eof():
-            id = "header[%u]" % linenb
-            chunk = self.readString(id, "AutoLine", "Header line")
+            id = "body[%u]" % linenb
+            chunk = self.readString(id, "AutoLine", "Body text")
+            if not in_multipart:
+                if chunk.length == 0:
+                    empty_line = empty_line + 1
+                    if empty_line == 2:
+                        break
+                else:
+                    empty_line = 0
             linenb = linenb + 1
 
-class EmailFilter(Filter):
-    def __init__(self, stream, parent=None):
-        Filter.__init__(self, "email", "Email parser", stream, parent)
+def readEmailContent(self, stream, in_multipart):
+    mime = getEmailMime(self)
+    if re.match("^multipart/", mime[0]) != None:
+        readMultipartEmail(self, stream, mime[1]["boundary"])
+    else:
+        plugin = getPluginByMime((mime,), EmailBody)
+#        plugin = EmailBody
+        encoding = self["header"]["Content-Transfer-Encoding"]
+        assert len(encoding) == 1
+        if encoding[0] == "base64":
+            assert in_multipart
+            size = stream.getSize() - stream.tell()
+            data = stream.getN(size, False)
+            substream = Base64Stream(data)
+            self.readChild("body", DeflateFilter, substream, size, plugin) 
+        else:
+            substream = stream
+#            self.readStreamChild("body", io, plugin)
+#            self.read("body", "%us" % (stream.getSize() - stream.tell()), "Body")
+            chunk = self.readStreamChild("body", substream, plugin)
+
+def readMultipartEmail(self, stream, boundary):
+    assert boundary[0] == '"' and boundary[-1] == '"'
+    boundary = "--" + boundary[1:-1]
+    end_boundary = boundary + "--"
+    count = 1
+    while True:
+        id = "multipart_space[%u]" % count
+        chunk = self.readString(id, "AutoLine", "Space before first email parts")
+        value = chunk.value
+        if value == boundary:
+            break
+        count = count + 1
+
+    part = 1
+    boundary_index = 1
+    while True:
+        start = stream.tell()
+        size = stream.searchLength(boundary, False)
+        sub = stream.createSub(start, size)
+        self.readStreamChild("part[%u]" % part, sub, EmailPart)
+        stream.seek(start+size)
+        chunk = self.readString("boundary[%u]" % boundary_index, "AutoLine", "Boundary")
+        part = part + 1
+        boundary_index = boundary_index + 1
+        if chunk.value == boundary+"--":
+            break
+
+def getEmailMime(self):
+    content_type = self["header"]["Content-Type"]
+    assert len(content_type) == 1
+    mimes = splitMimes(content_type[0])
+    assert len(mimes) == 1
+    return mimes[0]
+
+class Email(Filter):
+    def __init__(self, stream, parent, in_multipart=True):
+        Filter.__init__(self, "email", "Email", stream, parent)
         self.readString("id", "AutoLine", "Email identifier")
         self.readChild("header", EmailHeader)
-        mime = self.getMime()
-        if mime[0] == "multipart/mixed":
-            self.readMultipart(mime[1]["boundary"])
-        else:
-            # TODO :-)
-            pass
+        readEmailContent(self, stream.createSub(), in_multipart)
 
-    def readMultipart(self, boundary):
-        assert boundary[0] == '"' and boundary[-1] == '"'
-        boundary = "--" + boundary[1:-1]
-        end_boundary = boundary + "--"
-        count = 1
-        while True:
-            id = "multipart_space[%u]" % count
-            chunk = self.readString(id, "AutoLine", "Space before first email parts")
-            value = chunk.value
-            if value == boundary:
+class EmailFilter(Filter):
+    def __init__(self, stream, parent=None):
+        Filter.__init__(self, "email", "Email maildir parser", stream, parent)
+        cpt = 1
+        while not stream.eof():
+            chunk = self.readChild("email[%u]" % cpt, Email, False)
+            end = stream.read(4, seek=False)
+            if len(end.strip()) == 0:
                 break
-            count = count + 1
+            cpt = cpt + 1
 
-        part = 1
-        boundary_index = 1
-        stream = self.getStream()
-        while True:
-            start = stream.tell()
-            size = stream.searchLength(boundary, False)
-            sub = stream.createSub(start, size)
-            self.readStreamChild("part[%u]" % part, sub, EmailPart)
-            stream.seek(start+size)
-            chunk = self.readString("boundary[%u]" % boundary_index, "AutoLine", "Boundary")
-            part = part + 1
-            boundary_index = boundary_index + 1
-            if chunk.value == boundary+"--":
-                break
-    
-    def getMime(self):
-        content_type = self.header["Content-Type"]
-        assert len(content_type) == 1
-        mimes = splitMimes(content_type[0])
-        assert len(mimes) == 1
-        return mimes[0]
-
-registerPlugin(EmailFilter, "text/x-mail")
+registerPlugin(EmailFilter, ["message/rfc822", "text/x-mail"])

Modified: haypo/hachoir/plugins/exe.py
===================================================================
--- haypo/hachoir/plugins/exe.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/exe.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -9,41 +9,6 @@
 from filter import Filter
 from plugin import registerPlugin
 
-def displayPE(pe):
-    print "[ PE HEADER ]"
-    print "Architecture: %s" % pe.getCpuType()
-            
-def displayPE_Section(section):
-    print "-> Section %- 8s: size=%u, rva=%08X" % \
-        (section.name, section.size, section.rva)
-
-def displayPE_Resource(res):
-    print "Resource: id=%u" % \
-        (res.id)
-        
-def displayPE_ResourceDirectory(res):
-    print "Resources: nb_entries = %u + %s" % \
-        (res.named_entries, res.indexed_entries)
-    for item in res.items:
-        displayPE_Resource(item)
-
-def displayMS_Dos(exe):        
-    print "[ MS-DOS HEADER ]"
-    print "Init. SS:SP: %04X:%04X" % \
-        (exe.init_ss_sp & 0xFFFF,
-         exe.init_ss_sp >> 16 & 0xFFFF)
-
-def displayExe(exe):
-    displayMS_Dos(exe.ms_dos)
-    if exe.pe:
-#        displayPE(exe.pe)
-        for section in exe.pe_sections:
-            section = section.getFilter()
-            displayPE_Section(section)
-#        for res in exe.pe_resources:
-#            res = res.getFilter()
-#            displayPE_ResourceDirectory(res)
-            
 class PE_ResourceData(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "pe_rsrc_data", "PE resource data", stream, parent)
@@ -51,13 +16,13 @@
         self.read("size", "<L", "Size")
         self.read("page_code", "<L", "Page code (language)")
         self.read("language", "<l", "Page code (language)")
-        self.language = -self.language
+#        self.language = -self["language"]
         self.read("reserved", "!L", "Reserverd")
 
         oldpos = stream.tell()
         
         #stream.seek(XXX + self.offset - self.offset_res_section)
-        stream.seek(self.offset)
+        stream.seek(self["offset"])
         stream.seek(oldpos)
 
 class PE_ResourceEntry(Filter):
@@ -80,13 +45,14 @@
         self.readArray("item", PE_ResourceEntry, "PE resource entry", self.checkEndOfRes)
     
     def checkEndOfRes(self, stream, array, dir):
-        return len(array) == (self.named_entries + self.indexed_entries)
+        return len(array) == (self["named_entries"] + self["indexed_entries"])
 
 class PE_Section(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "pe_section", "PE section", stream, parent)
         self.read("name", "8s", "Name")
-        self.name = self.name.strip(" \0")
+        # TODO: use chunk post proces
+        self.name = self["name"].strip(" \0")
         self.read("rva", "<L", "RVA")
         self.read("size", "<L", "Size")
         self.read("file_size", "<L", "File size")
@@ -107,7 +73,7 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "pe_opt_hdr", "PE optionnal header", stream, parent)
         self.read("header", "<H", "Header")
-        assert self.header == 0x010B
+        assert self["header"] == 0x010B
         self.read("linker_maj_ver", "B", "Linker major version")
         self.read("linker_min_ver", "B", "Linker minor version")
         self.read("code_size", "<L", "Code size (bytes)")
@@ -137,7 +103,7 @@
         self.read("common_heap_size", "<L", "Common heap size")
         self.read("loader_options", "<L", "Loader options")
         self.read("nb_directories", "<L", "Number of directories (16)")
-        assert self.nb_directories == 16
+        assert self["nb_directories"] == 16
         self.readArray("directories", PE_Directory, "PE directories", self.checkEndOfDir)
 
     def checkEndOfDir(self, stream, array, dir):
@@ -147,7 +113,7 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "pe_header", "PE header", stream, parent)
         self.read("header", "4s", "File header")
-        assert self.header == "PE\0\0"
+        assert self["header"] == "PE\0\0"
         self.read("cpu_type", "<H", "CPU type")
         self.read("nb_sections", "<H", "Number of sections")
         self.read("creation_date", "<L", "Creation date")
@@ -167,23 +133,23 @@
             0x0168: "R10000 (MIPS), little endian",
             0x0184: "DEC Alpha AXP",
             0x01F0: "IBM Power PC, little endian"}
-        return cpu_name.get(self.cpu_type, "unknow")
+        return cpu_name.get(self["cpu_type"], "unknow")
 
 class MS_Dos(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "msdos_header", "MS-Dos executable header", stream, parent)
         self.read("header", "2s", "File header")
-        assert self.header == "MZ"
+        assert self["header"] == "MZ"
         self.read("filesize_mod_512", ">H", "Filesize mod 512")
         self.read("filesize_div_512", ">H", "Filesize div 512")
-        self.filesize = self.filesize_div_512 * 512 + self.filesize_mod_512
+        self.filesize = self["filesize_div_512"] * 512 + self["filesize_mod_512"]
         self.read("reloc_entries", ">H", "Number of relocation entries")
         self.read("code_offset", "<H", "Offset to the code in the file (div 16)")
-        self.code_offset = self.code_offset * 16
+        self.code_offset = self["code_offset"] * 16
         self.read("needed_memory", ">H", "Memory needed to run (div 16)")
-        self.needed_memory = self.needed_memory * 16
+        self.needed_memory = self["needed_memory"] * 16
         self.read("max_memory", ">H", "Maximum memory needed to run (div 16)")
-        self.max_memory = self.max_memory * 16
+        self.max_memory = self["max_memory"] * 16
         self.read("init_ss_sp", ">L", "Initial value of SP:SS registers.")
         self.read("checksum", ">H", "Checksum")
         self.read("init_cs_ip", ">L", "Initial value of CS:IP registers.")
@@ -201,17 +167,18 @@
 
         self.readChild("ms_dos", MS_Dos)
 
-        if self.ms_dos.reloc_offset == 0x40:
-            stream.seek(self.ms_dos.pe_offset, 0)
+        if self["ms_dos"]["reloc_offset"] == 0x40:
+            stream.seek(self["ms_dos"]["pe_offset"], 0)
 
             self.readChild("pe", PE_Filter)
+            self.pe = self["pe"]
             self.readChild("pe_opt", PE_OptionnalHeader)
             self.readArray("pe_sections", PE_Section, "PE sections", self.checkEndOfSections)
 
             # TODO: Fix this ...
             
             offset_res_section = None
-            for section in self.pe_sections:
+            for section in self["pe_sections"]:
                 section = section.getFilter()
                 if section.name == ".rsrc":
                     offset_res_section = section.file_offset
@@ -224,6 +191,6 @@
             self.pe = None
 
     def checkEndOfSections(self, stream, array, section):
-        return len(array) == self.pe.nb_sections
+        return len(array) == self["pe"]["nb_sections"]
 
 registerPlugin(ExeFile, "application/x-dosexec")

Modified: haypo/hachoir/plugins/gif.py
===================================================================
--- haypo/hachoir/plugins/gif.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/gif.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -26,21 +26,16 @@
 
         # TODO: Fix this ...
         self.read("flags", "<H", "Flags")
-        self.global_map = ((self.flags & 0x80) == 0x80)
-        self.interlaced = ((self.flags & 0x40) == 0x40)
-        self.bits_per_pixel = 1 + (self.flags & 0x07)
+        self.global_map = ((self["flags"] & 0x80) == 0x80)
+        self.interlaced = ((self["flags"] & 0x40) == 0x40)
+        self.bits_per_pixel = 1 + (self["flags"] & 0x07)
         if not self.global_map:
             self.readChild("local_map", GifColorMap)
+            self.local_map = self["local_map"]
         else:
             self.local_map = None
         # -- End of TODO
 
-    def __str__(self):
-        return "Gif image <position=(%u,%u), size=%ux%u, bits/pixel=%u>" % \
-            (self.left, self.top,
-             self.width, self.height,
-             self.bits_per_pixel)
-     
 class GifColorMap(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "gif_colormap", "GIF color map", stream, parent)
@@ -55,9 +50,6 @@
     def checkEndOfMap(self, stream, array, color):
         return len(array) == self._nb_colors 
 
-    def __str__(self):
-        return "Gif colormap <colors=%u>" % (len(self.color))
-        
 class GifExtensionChunk(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "gif_ext_data", "GIF extension data", stream, parent)
@@ -72,7 +64,7 @@
 
     def checkEnd(self, stream, array, chunk):
         if chunk == None: return False
-        return chunk.size == 0 
+        return chunk["size"] == 0 
         
 class GifScreenDescriptor(Filter):
     def __init__(self, stream, parent):
@@ -103,11 +95,12 @@
         Filter.__init__(self, "gif_file", "GIF picture file", stream, parent)
         # Header
         self.read("header", "6s", "File header")
-        assert (self.header == "GIF87a") or (self.header == "GIF89a")
+        assert (self["header"] == "GIF87a") or (self["header"] == "GIF89a")
         
         self.readChild("screen", GifScreenDescriptor)
-        if self.screen.global_map:
+        if self["screen"].global_map:
             self.readChild("color_map", GifColorMap)
+            self.color_map = self["color_map"]
         else:
             self.color_map = None
             
@@ -120,6 +113,7 @@
             elif code == ",":
                 self.readChild("images[]", GifImage)
                 # TODO: Write GifImage code :-)
+                self.readImage(stream)
                 warning("GIF FILTER CAN NOT READ IMAGE CONTENT YET, SO ABORT READING!")
                 return
             elif code == ";":
@@ -128,4 +122,8 @@
             else:
                 raise Exception("Wrong GIF image separator: ASCII %02X." % ord(code))
 
+    def readImage(self, stream):              
+        size = stream.getSize() - stream.tell()
+        self.read("data", "%us" % size, "Image data")
+
 registerPlugin(GifFile, "image/gif")

Modified: haypo/hachoir/plugins/gzip.py
===================================================================
--- haypo/hachoir/plugins/gzip.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/gzip.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -38,29 +38,29 @@
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "gzip_file", "GZIP archive file", stream, parent)
         self.read("id", "!2B", "Identifier (31,139)")
-        assert self.id == (31, 139)
+        assert self["id"] == (31, 139)
         self.read("comp_method", "!B", "Compression method", post=self.getCompressionMethod)
         self.read("flags", "!B", "Flags", post=self.getFlags)
         self.read("mtime", "<1L", "Modification time", post=self.getMTime)
         self.read("extra", "!B", "Extra flags")
         self.read("os", "!B", "OS", post=self.getOS)
 
-        if self.extra & 4 == 4:
+        if self["extra"] & 4 == 4:
             self.read("extra_length", "<2H", "Extra length")
             self.read("extra", "!{extra_length}s", "Extra")
-        if self.flags & 8 == 8:
+        if self["flags"] & 8 == 8:
             self.readString("filename", "C", "Filename")
-        if self.flags & 16 == 16:
+        if self["flags"] & 16 == 16:
             self.readString("comment", "C", "Comment")
-        if self.flags & 2 == 2:
-            self.readString("crc16", "!H", "CRC16")
+        if self["flags"] & 2 == 2:
+            self.read("crc16", "!H", "CRC16")
 
         oldpos = stream.tell()
         size = stream.getSize() - oldpos - 8
         try:
             gz_stream = GunzipStream(stream)
             if hasattr(self, "filename"):
-                plugin = getPluginByStream(gz_stream, self.filename)
+                plugin = getPluginByStream(gz_stream, self["filename"])
             else:
                 plugin = getPluginByStream(gz_stream, None)
 

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/jpeg.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -11,33 +11,34 @@
 class JpegChunkApp0(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "jpeg_chunk", "JPEG chunk App0", stream, parent)
-        self.read("jfif", "!5s", "JFIF string")
-        self.read("ver_maj", "!B", "Major version")
-        self.read("ver_min", "!B", "Minor version")
-        self.read("units", "!1B", "Units (=0)")
-        if self.units == 0:
+        self.read("size", "!H", "Size")
+        self.read("jfif", "5s", "JFIF string")
+        self.read("ver_maj", "B", "Major version")
+        self.read("ver_min", "B", "Minor version")
+        self.read("units", "B", "Units (=0)")
+        if self["units"] == 0:
             self.read("aspect_x", "!H", "Aspect ratio (X)")
             self.read("aspect_y", "!H", "Aspect ratio (Y)")
         else:
             self.read("x_density", "!H", "X density")
             self.read("y_density", "!H", "Y density")
-        self.read("thumb_w", "!B", "Thumbnail width")
-        self.read("thumb_h", "!1B", "Thumbnail height")
-        thumb = self.thumb_w * self.thumb_h
+        self.read("thumb_w", "B", "Thumbnail width")
+        self.read("thumb_h", "B", "Thumbnail height")
+        thumb = self["thumb_w"] * self["thumb_h"]
         if thumb != 0:
-            self.read("thumb_data", "!%us" % size, "Thumbnail data", truncate=True)
+            self.read("thumb_data", "%us" % size, "Thumbnail data", truncate=True)
+        assert self["size"] == self.getSize()
 
 class JpegChunk(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
-        self.read("header", "!2B", "Header", post=self.getChunkType)
-        assert self.header[0] == (0xFF)
-        self.read("size", "!H", "Size")
-        if self.header[1] == 0xE0:
-            chunk = self.readChild("app0", JpegChunkApp0)
-            assert chunk.size == (self.size - 2)
+        chunk = self.read("header", "!2B", "Header", post=self.getChunkType)
+        assert self["header"][0] == 0xFF
+        if self["header"][1] == 0xE0:
+            self.readChild("app0", JpegChunkApp0)
         else:
-            self.read("data", "!%us" % (self.size - 2), "Data")
+            self.read("size", "!H", "Size")
+            self.read("data", "!%us" % (self["size"] - 2), "Data")
 
     def getChunkType(self, chunk):
         types = {
@@ -62,13 +63,13 @@
 
 class JpegFile(Filter):
     def checkEndOfChunks(self, stream, array, chunk):
-        if chunk != None and chunk.header[1] == 0xDA: return True
+        if chunk != None and chunk["header"][1] == 0xDA: return True
         return stream.eof()
 
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "jpeg_file", "JPEG file", stream, parent)
         self.read("header", "!2B", "Header \"start of image\" (0xFF, 0xD8)")
-        assert self.header == (0xFF, 0xD8)
+        assert self["header"] == (0xFF, 0xD8)
         self.readArray("chunk", JpegChunk, "Chunks", self.checkEndOfChunks)
         self.read("data", "!{@end@}s", "JPEG data")
         

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/png.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -8,14 +8,6 @@
 from filter import Filter
 from plugin import registerPlugin
 
-def displayPng(png):
-    for chunk in png.chunks:
-        chunk = chunk.getFilter()
-        if hasattr(chunk, "chunk_data"):
-            print chunk.chunk_data
-        else:
-            print "(unknow chunk type \"%s\")" % chunk.type
-
 class PngHeader(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "png_header", "PNG header", stream, parent)
@@ -29,8 +21,8 @@
 
     def __str__(self):
         return "PNG header <size=%ux%u, depth=%u bits/pixel>" % \
-            (self.width, self.height,
-             self.bit_depth)
+            (self["width"], self["height"],
+             self["bit_depth"])
 
 class PngPhysical(Filter):
     def __init__(self, stream, parent):
@@ -40,12 +32,12 @@
         self.read("unit_type", "!B", "Unit type")
 
     def __str__(self):
-        if self.unit_type=="0":
+        if self["unit_type"] == 0:
             unit = "unknow"
         else:
             unit = "meter"
         return "PNG physical chunk <pixel per unit=(%u,%u), unit=%s>" % \
-            (self.pixel_per_unit_x, self.pixel_per_unit_y, unit)
+            (self["pixel_per_unit_x"], self["pixel_per_unit_y"], unit)
 
 class PngGamma(Filter):
     def __init__(self, stream, parent):
@@ -56,7 +48,7 @@
         return float(chunk.value) / 10000
 
     def __str__(self):
-        return "PNG gamma <gamma=%0.2f>" % (self.gamma)
+        return "PNG gamma <gamma=%0.2f>" % (self["gamma"])
 
 class PngText(Filter):
     def __init__(self, stream, parent):
@@ -67,7 +59,7 @@
 
     def __str__(self):
         return "PNG text <keyword=\"%s\", text=\"%s\">" % \
-            (self.keyword, self.text)
+            (self["keyword"], self["text"])
 
 class PngTime(Filter):
     def __init__(self, stream, parent):
@@ -81,8 +73,8 @@
 
     def __str__(self):
         return "PNG time chunk <%04u-%02u-%02u %02u:%02u:%02u>" % \
-            (self.year, self.month, self.day,
-             self.hour, self.minute, self.second)
+            (self["year"], self["month"], self["day"],
+             self["hour"], self["minute"], self["second"])
 
 class PngFile(Filter):
     """
@@ -92,7 +84,7 @@
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "png_file", "PNG file", stream, parent)
         self.read("header", "!8s", "File header")
-        assert self.header == "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"
+        assert self["header"] == "\x89\x50\x4E\x47\x0D\x0A\x1A\x0A"
         self.readArray("chunks", PngChunk, "Png chunks", self.checkEndOfChunks)
 
     def checkEndOfChunks(self, stream, array, png_chunk):
@@ -110,20 +102,21 @@
             "gAMA": PngGamma,
             "tEXt": PngText
         }
-        if self.type in self.chunk_splitter:
+        if self["type"] in self.chunk_splitter:
             oldpos = self._stream.tell()
-            child_filter = self.chunk_splitter[self.type]
-            self.readLimitedChild("chunk_data", self.size, child_filter)
-            assert oldpos + self.size == self._stream.tell()
+            child_filter = self.chunk_splitter[self["type"]]
+            sub = stream.createSub(stream.tell(), self["size"])
+            self.readStreamChild("chunk_data", sub, child_filter)
+            stream.seek(oldpos + self["size"])
         else:
             self.read("data", "!{size}s", "Chunk data")
         self.read("crc32", "!L", "Chunk CRC32")
 
     def updateParent(self, chunk):
-        self.description = "PNG chunk (type %s)" % self.type
-        chunk.description = "PNG chunk (type %s)" % self.type
+        self.description = "PNG chunk (type %s)" % self["type"]
+        chunk.description = "PNG chunk (type %s)" % self["type"]
 
     def __str__(self):
-        return "PngChunk <size=%u, type=%s>" % (self.size, self.type)
+        return "PngChunk <size=%u, type=%s>" % (self["size"], self["type"])
 
 registerPlugin(PngFile, "image/png")

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/plugins/zip.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -9,18 +9,6 @@
 from plugin import registerPlugin
 import sys
 
-def displayZip(zip):    
-    print "[ Zip archive ]"
-    for file in zip.files:
-        file = file.getFilter()
-        sys.stdout.write ("* File %s (size=%0.1f KB" %
-            (file.filename, file.uncompressed_size / 1024))
-        if file.uncompressed_size != 0:
-            sys.stdout.write (" - %0.1f%%" % \
-                (100 - file.compressed_size * 100 / file.uncompressed_size))
-        sys.stdout.write (")\n")
-    print "[ End of the zip archive ]"
-
 class ZipCentralDirectory(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "zip_central_dir", "ZIP central directory", stream, parent)
@@ -85,7 +73,7 @@
         self.read("filename", "<{filename_length}s", "Filename")
         self.read("extra", "<{extra_length}s", "Extra")
         self.read("compressed_data", "<{compressed_size}s", "Compressed data", truncate=True)
-        if (self.flags & 4) == 4:
+        if (self["flags"] & 4) == 4:
             self.read("file_crc32", "<L", "Checksum (CRC32)")
             self.read("file_compressed_size", "<L", "Compressed size (bytes)")
             self.read("file_uncompressed_size", "<L", "Uncompressed size (bytes)")

Added: haypo/hachoir/stream/base_64.py
===================================================================
--- haypo/hachoir/stream/base_64.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/stream/base_64.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -0,0 +1,14 @@
+from base64 import decodestring
+from cStringIO import StringIO
+from file import FileStream
+
+def Base64Stream(lines):
+    data = ""
+    for line in lines:
+        data = data + line.strip()
+    data = "".join(data)
+    data = decodestring(data)
+    io = StringIO(data)
+    io = FileStream(io, None)
+    io.seek(0)
+    return io

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/stream/file.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -13,8 +13,11 @@
         self.__size = self.__file.tell()
         self.__file.seek(0,0) # Seel to beginning
         
-    def read(self, size):        
-        return self.__file.read(size)
+    def read(self, size, seek=True):
+        data = self.__file.read(size)
+        if seek==False:
+            self.seek(-len(data), 1)
+        return data            
 
     def clone(self):
         return FileStream(self.__file, self.filename)

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/stream/stream.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -20,7 +20,7 @@
     def tell(self):
         return 0
     
-    def read(self, size):
+    def read(self, size, seek=True):
         """ Works like Posix read (can returns less than size bytes. """
         return None
     
@@ -37,7 +37,11 @@
     def eof(self):
         return self.getLastPos() <= self.tell() 
 
-    def createSub(self, start, size):
+    def createSub(self, start=None, size=None):
+        if start==None:
+            start = self.tell()
+        if size == None:
+            size = self.getSize()-start
         return SubStream(self, start, size, self.filename)
 
     def createLimited(self, start, size):
@@ -136,6 +140,10 @@
             size_max = self._end-self.tell()
         assert 0<=size_max  and size_max<=self._size
         return self._stream.search(str, size_max)
+        
+    def read(self, size, seek=True):
+        """ Works like Posix read (can returns less than size bytes. """
+        return self._stream.read(size, seek)
 
     def getN(self, size, seek=True):
         if self._start+self._size<self._stream.tell()+size:
@@ -171,7 +179,11 @@
         if pos != -1:
             pos = pos - self._start
         return pos
-
+        
+    def read(self, size, seek=True):
+        """ Works like Posix read (can returns less than size bytes. """
+        return self._stream.read(size, seek)
+ 
     def seek(self, pos, where=0):
         if where==2:
             pos = pos - self._start

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-11-27 02:07:19 UTC (rev 270)
+++ haypo/hachoir/ui/ui_window.py	2005-11-27 06:11:13 UTC (rev 271)
@@ -58,6 +58,7 @@
 
     def clear_table(self):
         self.table_store.clear()
+        self.table.columns_autosize()
 
     def set_table_value(self, iter, column, value):
         row = self.table_store[iter]
@@ -89,6 +90,7 @@
         self.treeview_add_column(self.table, "Description", 5)
         self.table.set_reorderable(True)
         self.treeselection = self.table.get_selection()
+        self.table.columns_autosize()
 
     def treeview_add_column(self, treeview, name, num):
         col = gtk.TreeViewColumn(name)



From haypo at berlios.de  Sun Nov 27 07:16:56 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 27 Nov 2005 07:16:56 +0100
Subject: [Happyboom-svn] r272 - in haypo/hachoir: . plugins
Message-ID: <200511270616.jAR6GuYo024953@sheep.berlios.de>

Author: haypo
Date: 2005-11-27 07:16:51 +0100 (Sun, 27 Nov 2005)
New Revision: 272

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/plugins/pdf.py
Log:
Fix "AutoLine" format of StringChunk.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-27 06:11:13 UTC (rev 271)
+++ haypo/hachoir/chunk.py	2005-11-27 06:16:51 UTC (rev 272)
@@ -139,6 +139,7 @@
             self.eol = self._stream.getN(1)
             if self.eol == "\r" and self._stream.read(1) == "\n":
                 self.eol = "\r\n"
+                self._size = self._size + 1
             self.length = self._size - len(self.eol)
             return
 

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-27 06:11:13 UTC (rev 271)
+++ haypo/hachoir/plugins/pdf.py	2005-11-27 06:16:51 UTC (rev 272)
@@ -120,7 +120,7 @@
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "id", "", stream, parent)
         self.readString("pdf_version", "AutoLine", "PDF version")
-        m = re.match("^%PDF-([0-9]+)\.([0-9]+)$", self.pdf_version)
+        m = re.match("^%PDF-([0-9]+)\.([0-9]+)$", self["pdf_version"])
         assert m != None
         self.version = ( int(m.group(1)), int(m.group(2)) )
         if self.version[0] == 1 and self.version[1] > 0:



From haypo at berlios.de  Sun Nov 27 07:51:49 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 27 Nov 2005 07:51:49 +0100
Subject: [Happyboom-svn] r273 - in haypo/hachoir: . plugins
Message-ID: <200511270651.jAR6pnFE005100@sheep.berlios.de>

Author: haypo
Date: 2005-11-27 07:51:34 +0100 (Sun, 27 Nov 2005)
New Revision: 273

Modified:
   haypo/hachoir/mime.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/email.py
Log:
Some fix to allow EmailFilter to parse PDF attachments.


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-27 06:16:51 UTC (rev 272)
+++ haypo/hachoir/mime.py	2005-11-27 06:51:34 UTC (rev 273)
@@ -30,6 +30,8 @@
 def _getBufferMime(buffer):    
     if ord(buffer[0])==31 and ord(buffer[1])==139:
         return "application/x-gzip"
+    if buffer[:4] == "%PDF":
+        return "application/pdf"
     return None        
 
 def splitMimes(mimes):

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-27 06:16:51 UTC (rev 272)
+++ haypo/hachoir/plugin.py	2005-11-27 06:51:34 UTC (rev 273)
@@ -2,13 +2,13 @@
 from mime import getFileMime, getBufferMime
 from default import DefaultFilter
 
-def guessPlugin(stream, filename):
+def guessPlugin(stream, filename, default=DefaultFilter):
     oldpos = stream.tell()
     size = stream.getSize()
     if 4096<size:
         size = 4096
     buffer = stream.getN(size)
-    plugin = getPluginByBuffer(buffer, filename)
+    plugin = getPluginByBuffer(buffer, filename, default)
     stream.seek(oldpos)
     return plugin
 

Modified: haypo/hachoir/plugins/email.py
===================================================================
--- haypo/hachoir/plugins/email.py	2005-11-27 06:16:51 UTC (rev 272)
+++ haypo/hachoir/plugins/email.py	2005-11-27 06:51:34 UTC (rev 273)
@@ -5,7 +5,7 @@
 """
 
 from filter import Filter, DeflateFilter
-from plugin import registerPlugin, getPluginByMime
+from plugin import registerPlugin, guessPlugin, getPluginByMime
 from error import warning
 from mime import splitMimes
 from error import warning
@@ -41,6 +41,9 @@
 
             linenb = linenb + 1
 
+    def __contains__(self, key):
+        return key.lower() in self._dict
+
     def _appendHeader(self, key, index, value):
         key = key.lower()
         self._dict[key][index] = self._dict[key][index] + " " + value
@@ -87,21 +90,58 @@
     if re.match("^multipart/", mime[0]) != None:
         readMultipartEmail(self, stream, mime[1]["boundary"])
     else:
-        plugin = getPluginByMime((mime,), EmailBody)
-#        plugin = EmailBody
-        encoding = self["header"]["Content-Transfer-Encoding"]
-        assert len(encoding) == 1
-        if encoding[0] == "base64":
-            assert in_multipart
-            size = stream.getSize() - stream.tell()
-            data = stream.getN(size, False)
-            substream = Base64Stream(data)
+        readBody(self, stream, mime, in_multipart)
+
+def readBody(self, stream, mime, in_multipart):
+    # Read encoding
+    header = self["header"]
+    if "Content-Transfer-Encoding" in header:
+        encoding = header["Content-Transfer-Encoding"][0]
+    else:
+        encoding = None
+
+    # Get filename
+    filename = mime[1].get("name", None)
+    if filename == None:
+        if "Content-Disposition" in header:
+            disp = header["Content-Disposition"][0].split(";")
+            regex = re.compile("filename=\"([^\"]+)\"")
+            for item in disp:
+                m = regex.match(item.strip())
+                if m != None:
+                    filename = m.group(1)
+                    break
+    elif filename[0] == '"':
+        filename = filename[1:-1]
+
+    # Handler base64 encodocing
+    if encoding == "base64":
+        size = stream.getSize() - stream.tell()
+        data = stream.getN(size, False)
+        substream = Base64Stream(data)
+        deflate = True
+    else:
+        substream = stream
+        deflate = False
+
+    # Guess plugin
+    plugin = getPluginByMime((mime,), None)
+    if plugin == None:
+        plugin = guessPlugin(substream, filename, None)
+    if plugin == None:
+        plugin = EmailBody
+
+    # Finally read data
+    if plugin != EmailBody:
+        if deflate:
             self.readChild("body", DeflateFilter, substream, size, plugin) 
         else:
-            substream = stream
-#            self.readStreamChild("body", io, plugin)
-#            self.read("body", "%us" % (stream.getSize() - stream.tell()), "Body")
             chunk = self.readStreamChild("body", substream, plugin)
+    else:
+        if deflate:
+            self.readChild("body", DeflateFilter, substream, size, plugin, in_multipart) 
+        else:
+            chunk = self.readStreamChild("body", substream, plugin, in_multipart)
 
 def readMultipartEmail(self, stream, boundary):
     assert boundary[0] == '"' and boundary[-1] == '"'



From dboucard at berlios.de  Sun Nov 27 21:57:46 2005
From: dboucard at berlios.de (dboucard at BerliOS)
Date: Sun, 27 Nov 2005 21:57:46 +0100
Subject: [Happyboom-svn] r274 - haypo
Message-ID: <200511272057.jARKvkO2019106@sheep.berlios.de>

Author: dboucard
Date: 2005-11-27 21:57:46 +0100 (Sun, 27 Nov 2005)
New Revision: 274

Added:
   haypo/haypo.txt
Log:
la verite vraie !


Added: haypo/haypo.txt
===================================================================
--- haypo/haypo.txt	2005-11-27 06:51:34 UTC (rev 273)
+++ haypo/haypo.txt	2005-11-27 20:57:46 UTC (rev 274)
@@ -0,0 +1 @@
+je suis un gros con !



From dboucard at berlios.de  Sun Nov 27 21:58:27 2005
From: dboucard at berlios.de (dboucard at BerliOS)
Date: Sun, 27 Nov 2005 21:58:27 +0100
Subject: [Happyboom-svn] r275 - haypo
Message-ID: <200511272058.jARKwRZE019173@sheep.berlios.de>

Author: dboucard
Date: 2005-11-27 21:58:27 +0100 (Sun, 27 Nov 2005)
New Revision: 275

Removed:
   haypo/haypo.txt
Log:
oups


Deleted: haypo/haypo.txt
===================================================================
--- haypo/haypo.txt	2005-11-27 20:57:46 UTC (rev 274)
+++ haypo/haypo.txt	2005-11-27 20:58:27 UTC (rev 275)
@@ -1 +0,0 @@
-je suis un gros con !



From haypo at berlios.de  Sun Nov 27 22:09:52 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 27 Nov 2005 22:09:52 +0100
Subject: [Happyboom-svn] r276 - in haypo/hachoir: . plugins
Message-ID: <200511272109.jARL9qfZ019846@sheep.berlios.de>

Author: haypo
Date: 2005-11-27 22:09:52 +0100 (Sun, 27 Nov 2005)
New Revision: 276

Modified:
   haypo/hachoir/mime.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/email.py
   haypo/hachoir/plugins/zip.py
Log:
A lot of good things in email


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-27 20:58:27 UTC (rev 275)
+++ haypo/hachoir/mime.py	2005-11-27 21:09:52 UTC (rev 276)
@@ -43,7 +43,8 @@
     - "text/plain; charset=ISO-8859-1; format=flowed"
       => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
     """
-
+    
+    print mimes
     list = []
     for mime in map(string.strip, mimes.split(",")):
         parts = mime.split(";")
@@ -51,16 +52,11 @@
         parts = map(string.strip, parts[1:])
         values = {}
         for part in parts:
-            split_part = part.split("=", 1)             
-            values[ split_part[0] ] = split_part[1]
+            if part != "":
+                split_part = part.split("=", 1)             
+                values[ split_part[0] ] = split_part[1]
         list.append([mime,values])
     return list
-        
-    mimes = map(string.split, mimes, ';')
-    print mimes
-#    for key in mimes:
-#        mimes[key] = map(string.strip, mimes[key])    
-    return mimes
 
 def getBufferMime(buffer, filename):
     magic = getInstance()

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-27 20:58:27 UTC (rev 275)
+++ haypo/hachoir/plugin.py	2005-11-27 21:09:52 UTC (rev 276)
@@ -20,7 +20,7 @@
         if mime in hachoir_plugins:
             plugins = plugins + hachoir_plugins[mime]
     if len(plugins)==0:
-        plugins = (default,)
+        return default
     if 1<len(plugins):
         warning("More than one plugin have same MIME...")
     return plugins[0]

Modified: haypo/hachoir/plugins/email.py
===================================================================
--- haypo/hachoir/plugins/email.py	2005-11-27 20:58:27 UTC (rev 275)
+++ haypo/hachoir/plugins/email.py	2005-11-27 21:09:52 UTC (rev 276)
@@ -6,9 +6,9 @@
 
 from filter import Filter, DeflateFilter
 from plugin import registerPlugin, guessPlugin, getPluginByMime
-from error import warning
+from default import DefaultFilter
 from mime import splitMimes
-from error import warning
+from error import warning, error
 from stream.base_64 import Base64Stream
 import re
 
@@ -16,8 +16,8 @@
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "email_hdr", "Email header", stream, parent)
         self._dict = {}
-        regex_new = re.compile("^([A-Za-z-]+): (.*)$")
-        regex_continue = re.compile("^\t(.*)$")
+        regex_new = re.compile("^([A-Za-z][A-Za-z0-9-]*): (.*)$")
+        regex_continue = re.compile("^[\t ]+(.*)$")
         linenb = 1
         last_key = None
         last_index = None
@@ -42,7 +42,8 @@
             linenb = linenb + 1
 
     def __contains__(self, key):
-        return key.lower() in self._dict
+        key = key.lower()
+        return key in self._dict
 
     def _appendHeader(self, key, index, value):
         key = key.lower()
@@ -66,33 +67,30 @@
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "email_part", "Email part", stream, parent)
         self.readChild("header", EmailHeader)
-        readEmailContent(self, stream.createSub(), True)
+        readEmailContent(self, stream.createSub())
 
 class EmailBody(Filter):
-    def __init__(self, stream, parent=None, in_multipart=True):
+    def __init__(self, stream, parent=None):
         Filter.__init__(self, "email_body", "Email body", stream, parent)
         linenb = 1 
-        empty_line = 0
         while not stream.eof():
+            guess = stream.read(5, False)
+            if guess=="From ":
+                break
             id = "body[%u]" % linenb
             chunk = self.readString(id, "AutoLine", "Body text")
-            if not in_multipart:
-                if chunk.length == 0:
-                    empty_line = empty_line + 1
-                    if empty_line == 2:
-                        break
-                else:
-                    empty_line = 0
             linenb = linenb + 1
 
-def readEmailContent(self, stream, in_multipart):
+def readEmailContent(self, stream):
     mime = getEmailMime(self)
-    if re.match("^multipart/", mime[0]) != None:
+    if mime != None and re.match("^multipart/", mime[0]) != None:
         readMultipartEmail(self, stream, mime[1]["boundary"])
     else:
-        readBody(self, stream, mime, in_multipart)
+        if mime == None:
+            warning("Can't get MIME type for email %s" % self)
+        readBody(self, stream, mime)
 
-def readBody(self, stream, mime, in_multipart):
+def readBody(self, stream, mime):
     # Read encoding
     header = self["header"]
     if "Content-Transfer-Encoding" in header:
@@ -101,7 +99,11 @@
         encoding = None
 
     # Get filename
-    filename = mime[1].get("name", None)
+    if mime != None:
+        filename = mime[1].get("name", None)
+    else:
+        raise Exception("No MIME in readBody()")
+        filename = None
     if filename == None:
         if "Content-Disposition" in header:
             disp = header["Content-Disposition"][0].split(";")
@@ -121,27 +123,35 @@
         substream = Base64Stream(data)
         deflate = True
     else:
-        substream = stream
+#        regex_new_mail = re.compile("[\r\n]From ")
+#        pos = stream.search(regex_new_mail)
+#        if pos != -1:
+#            substream = stream.createSub(size=pos)
+#        else:
+#            substream = stream
+        substream = stream.createSub()
         deflate = False
 
     # Guess plugin
-    plugin = getPluginByMime((mime,), None)
+    if mime != None:
+        plugin = getPluginByMime((mime,), None)
+    else:
+        plugin = None
     if plugin == None:
         plugin = guessPlugin(substream, filename, None)
-    if plugin == None:
+    if plugin == None or plugin == EmailFilter:
         plugin = EmailBody
 
     # Finally read data
-    if plugin != EmailBody:
+    try:
         if deflate:
             self.readChild("body", DeflateFilter, substream, size, plugin) 
         else:
-            chunk = self.readStreamChild("body", substream, plugin)
-    else:
-        if deflate:
-            self.readChild("body", DeflateFilter, substream, size, plugin, in_multipart) 
-        else:
-            chunk = self.readStreamChild("body", substream, plugin, in_multipart)
+            self.readStreamChild("body", substream, plugin)
+    except Exception, msg:
+        error("Error while parsing email body: %s" % msg)
+        substream.seek(0)
+        self.readStreamChild("body", substream, DefaultFilter)
 
 def readMultipartEmail(self, stream, boundary):
     assert boundary[0] == '"' and boundary[-1] == '"'
@@ -171,28 +181,43 @@
             break
 
 def getEmailMime(self):
-    content_type = self["header"]["Content-Type"]
+    header = self["header"]
+    if not("Content-Type" in header):
+        raise Exception("No mime")
+        return None
+    content_type = header["Content-Type"]
     assert len(content_type) == 1
     mimes = splitMimes(content_type[0])
     assert len(mimes) == 1
     return mimes[0]
 
 class Email(Filter):
-    def __init__(self, stream, parent, in_multipart=True):
+    def __init__(self, stream, parent):
         Filter.__init__(self, "email", "Email", stream, parent)
         self.readString("id", "AutoLine", "Email identifier")
         self.readChild("header", EmailHeader)
-        readEmailContent(self, stream.createSub(), in_multipart)
+        readEmailContent(self, stream.createSub())
 
+    def __str__(self):
+        header = self["header"]
+        text = "Email"
+        if "From" in header:
+            text = text + " from %s" % header["From"]
+        if "Date" in header:
+            text = text + " (date %s)" % header["Date"]
+        return text
+
 class EmailFilter(Filter):
     def __init__(self, stream, parent=None):
         Filter.__init__(self, "email", "Email maildir parser", stream, parent)
-        cpt = 1
         while not stream.eof():
-            chunk = self.readChild("email[%u]" % cpt, Email, False)
-            end = stream.read(4, seek=False)
-            if len(end.strip()) == 0:
+            chunk = self.readChild("email[]", Email)
+            if stream.eof():
                 break
-            cpt = cpt + 1
+            while not stream.eof():
+                guess = stream.read(5, False)
+                if guess == "From ":
+                    break
+                self.readString("space[]", "AutoLine", "Space")
 
 registerPlugin(EmailFilter, ["message/rfc822", "text/x-mail"])

Modified: haypo/hachoir/plugins/zip.py
===================================================================
--- haypo/hachoir/plugins/zip.py	2005-11-27 20:58:27 UTC (rev 275)
+++ haypo/hachoir/plugins/zip.py	2005-11-27 21:09:52 UTC (rev 276)
@@ -5,9 +5,10 @@
 Author: Victor Stinner
 """
 
+import sys
 from filter import Filter
 from plugin import registerPlugin
-import sys
+from error import error
 
 class ZipCentralDirectory(Filter):
     def __init__(self, stream, parent):
@@ -98,6 +99,7 @@
                 self.read("signature_length", "!H", "Signature length")
                 self.read("signature", "!{signature_length}s", "Signature")
             else:
-                raise Exception("Error, unknow ZIP header (0x%08X)." % header)
+                error("Error, unknow ZIP header (0x%08X)." % header)
+                self.read("raw", "{@end@}s", "Raw")
         
 registerPlugin(ZipFile, "application/x-zip")



From haypo at berlios.de  Sun Nov 27 22:13:34 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Sun, 27 Nov 2005 22:13:34 +0100
Subject: [Happyboom-svn] r277 - haypo/hachoir
Message-ID: <200511272113.jARLDYlT020092@sheep.berlios.de>

Author: haypo
Date: 2005-11-27 22:13:34 +0100 (Sun, 27 Nov 2005)
New Revision: 277

Modified:
   haypo/hachoir/hachoir.py
Log:
69


Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-11-27 21:09:52 UTC (rev 276)
+++ haypo/hachoir/hachoir.py	2005-11-27 21:13:34 UTC (rev 277)
@@ -1,6 +1,6 @@
 #!/usr/bin/python
 """
-Splitter: tool to split a binary file into human readable data.
+Hachoir: tool to split a binary file into human readable data.
 Because it's written in Python, it would be easy to write new plugins
 (supports new file format).
 



From haypo at berlios.de  Mon Nov 21 23:57:20 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 21 Nov 2005 23:57:20 +0100
Subject: [Happyboom-svn] r258 - in greycstoration_gimp: . src
Message-ID: <200511212257.jALMvKvG025993@sheep.berlios.de>

Author: haypo
Date: 2005-11-21 23:57:19 +0100 (Mon, 21 Nov 2005)
New Revision: 258

Added:
   greycstoration_gimp/Makefile.am
   greycstoration_gimp/autogen.sh
   greycstoration_gimp/configure.in
   greycstoration_gimp/src/
   greycstoration_gimp/src/CImg.h
   greycstoration_gimp/src/Makefile
   greycstoration_gimp/src/dialog.cpp
   greycstoration_gimp/src/dialog.h
   greycstoration_gimp/src/greycstoration.cpp
   greycstoration_gimp/src/greycstoration.h
   greycstoration_gimp/src/image.cpp
   greycstoration_gimp/src/image.h
   greycstoration_gimp/src/main.cpp
Removed:
   greycstoration_gimp/CImg.h
   greycstoration_gimp/Makefile
   greycstoration_gimp/dialog.cpp
   greycstoration_gimp/dialog.h
   greycstoration_gimp/greycstoration.cpp
   greycstoration_gimp/greycstoration.h
   greycstoration_gimp/image.cpp
   greycstoration_gimp/image.h
   greycstoration_gimp/main.cpp
   greycstoration_gimp/plug_in.h
Modified:
   greycstoration_gimp/INSTALL
Log:
Commit autotools patch (part two).


Deleted: greycstoration_gimp/CImg.h
===================================================================
--- greycstoration_gimp/CImg.h	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/CImg.h	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,9655 +0,0 @@
-/*------------------------------------------------------------------------------------------------------
-  
-  File        : CImg.h
-  
-  Description : The C++ Template Image Processing Library
-
-  Author      : David Tschumperl?
-   
-  This software is governed by the CeCILL  license under French law and
-  abiding by the rules of distribution of free software.  You can  use, 
-  modify and/ or redistribute the software under the terms of the CeCILL
-  license as circulated by CEA, CNRS and INRIA at the following URL
-  "http://www.cecill.info". 
-  
-  As a counterpart to the access to the source code and  rights to copy,
-  modify and redistribute granted by the license, users are provided only
-  with a limited warranty  and the software's author,  the holder of the
-  economic rights,  and the successive licensors  have only  limited
-  liability. 
-  
-  In this respect, the user's attention is drawn to the risks associated
-  with loading,  using,  modifying and/or developing or reproducing the
-  software by the user in light of its specific status of free software,
-  that may mean  that it is complicated to manipulate,  and  that  also
-  therefore means  that it is reserved for developers  and  experienced
-  professionals having in-depth computer knowledge. Users are therefore
-  encouraged to load and test the software's suitability as regards their
-  requirements in conditions enabling the security of their systems and/or 
-  data to be ensured and,  more generally, to use and operate it in the 
-  same conditions as regards security. 
-  
-  The fact that you are presently reading this means that you have had
-  knowledge of the CeCILL license and that you accept its terms.
-  
-  ----------------------------------------------------------------------------------------------------*/
-
-#ifndef cimg_version
-#define cimg_version 1.08
-#include <cstdio>
-#include <cstdlib>
-#include <cstdarg>
-#include <cmath>
-#include <cstring>
-#include <ctime>
-
-// Overcome VisualC++ 6.0 and DMC compilers namespace 'std::' bug
-#if ( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__)
-#define std
-#endif
-
-/*-------------------------------------------------------------
-  
-
-  Auto-detect and set CImg Library configuration flags.
-  
-  
-  If compilation flags are not adapted to your system,
-  you may override their values, before including
-  the header file "CImg.h" (use the #define directive).
-  
-  -------------------------------------------------------------*/
-
-#ifndef cimg_OS
-#if defined(sun) || defined(__sun)        
-// Sun/Solaris configuration
-#define cimg_OS            0
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#elif defined(linux) || defined(__linux) || defined(__CYGWIN__)
-// PC Linux configuration
-#define cimg_OS            1
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#elif defined(_WIN32) || defined(__WIN32__)
-// PC Windows configuration
-#define cimg_OS            2
-#ifndef cimg_display_type
-#define cimg_display_type  2
-#endif
-#elif defined(__MACOSX__) || defined(__APPLE__)
-// Mac OS X configuration
-#define cimg_OS            3
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#elif defined(__FreeBSD__)
-// FreeBSD configuration
-#define cimg_OS            4
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#else
-// Unknown configuration : minimal dependencies.
-#define cimg_OS           -1
-#ifndef cimg_display_type
-#define cimg_display_type  0
-#endif
-#endif
-#endif
-
-// Debug configuration.
-//--------------------
-// Define 'cimg_debug' to : 0 to remove dynamic debug messages (exceptions are still thrown)
-//                          1 to display dynamic debug messages (default behavior).
-//                          2 to add extra memory access controls (may slow down the code)
-#ifndef cimg_debug
-#define cimg_debug         1
-#endif
-
-// Architecture-dependent includes
-//---------------------------------
-#if cimg_OS!=2
-#include <sys/time.h>
-#include <unistd.h>
-#else
-#include <windows.h>
-// Discard annoying macro definitions in windows.h
-#ifdef min
-#undef min
-#undef max
-#undef abs
-#endif
-#endif
-#if cimg_display_type==1
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <X11/keysym.h>
-#include <pthread.h>
-#endif
-
-/*-----------------------------------------------------------------------------------
-  
-
-
-   Define some macros. Macros of the CImg Library are prefixed by 'cimg_'
-   Documented macros below may be safely used in your own code.
-   
-   
-   ---------------------------------------------------------------------------------*/
-
-// Macros used to describe the program usage, and retrieve command line arguments
-// (See corresponding module 'Retrieving command line arguments' in the generated documentation).
-#define cimg_usage(usage) cimg_library::cimg::option((char*)NULL,(unsigned int)argc,(char**)argv,(char*)NULL,(char*)usage)
-#define cimg_option(name,defaut,usage) cimg_library::cimg::option((char*)name,(unsigned int)argc,(char**)argv,defaut,(char*)usage)
-
-// Macros used for dynamic debug messages. Shouldn't be used in your own source code.
-#define cimg_test(x,func)						\
-  if(!(x).width || !(x).height || !(x).depth || !(x).dim || !(x).data)	\
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is empty", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimgl_test(x,func) \
-  if(!(x).size || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImgl<%s> %s = (%d,%p) is empty", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).size,(x).data)
-#define cimg_test_scalar(x,func) \
-  if(!(x).width || !(x).height || !(x).depth || (x).dim!=1 || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not scalar", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimg_test_matrix(x,func) \
-  if(!(x).width || !(x).height || (x).depth!=1 || (x).dim!=1 || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not a matrix", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimg_test_square(x,func) \
-  if(!(x).width || !(x).height || (x).depth!=1 || (x).dim!=1 || (x).width!=(x).height || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not a square matrix", \
-                                func,__FILE__,__LINE__,(x).pixel_type,#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimg_test_display(x,func) \
-  if (!(x).width || !(x).height) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', l.%d), CImgDisplay %s = (%d,%d) is not a valid display", \
-                                func,__FILE__,__LINE__,#x,(x).width,(x).height)
-  
-// Macros used for neighborhood definitions and manipulations (see module 'Using Image Loops' in the generated documentation).
-#define CImg_2x2(I,T)     T I##cc,I##nc=0,I##cn,I##nn=0
-#define CImg_3x3(I,T)     T I##pp,I##cp,I##np=0,I##pc,I##cc,I##nc=0,I##pn,I##cn,I##nn=0
-#define CImg_4x4(I,T)     T I##pp,I##cp,I##np=0,I##ap=0, \
-                            I##pc,I##cc,I##nc=0,I##ac=0, \
-                            I##pn,I##cn,I##nn=0,I##an=0, \
-                            I##pa,I##ca,I##na=0,I##aa=0
-#define CImg_5x5(I,T)     T I##bb,I##pb,I##cb,I##nb=0,I##ab=0, \
-                            I##bp,I##pp,I##cp,I##np=0,I##ap=0, \
-                            I##bc,I##pc,I##cc,I##nc=0,I##ac=0, \
-                            I##bn,I##pn,I##cn,I##nn=0,I##an=0, \
-                            I##ba,I##pa,I##ca,I##na=0,I##aa=0
-#define CImg_2x2x2(I,T)   T I##ccc,I##ncc=0,I##cnc,I##nnc=0, \
-                            I##ccn,I##ncn=0,I##cnn,I##nnn=0
-#define CImg_3x3x3(I,T)   T I##ppp,I##cpp,I##npp=0,I##pcp,I##ccp,I##ncp=0,I##pnp,I##cnp,I##nnp=0, \
-                            I##ppc,I##cpc,I##npc=0,I##pcc,I##ccc,I##ncc=0,I##pnc,I##cnc,I##nnc=0, \
-                            I##ppn,I##cpn,I##npn=0,I##pcn,I##ccn,I##ncn=0,I##pnn,I##cnn,I##nnn=0
-
-#define CImg_2x2_ref(I,T,tab)   T &I##cc=(tab)[0],&I##nc=(tab)[1],&I##cn=(tab)[2],&I##nn=(tab)[3];
-#define CImg_3x3_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2], \
-                                  &I##pc=(tab)[3],&I##cc=(tab)[4],&I##nc=(tab)[5], \
-                                  &I##pn=(tab)[6],&I##cn=(tab)[7],&I##nn=(tab)[8]
-#define CImg_4x4_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2],&I##ap=(tab)[3], \
-                                  &I##pc=(tab)[4],&I##cc=(tab)[5],&I##nc=(tab)[6],&I##ap=(tab)[7], \
-                                  &I##pn=(tab)[8],&I##cn=(tab)[9],&I##nn=(tab)[10],&I##aa=(tab)[11], \
-                                  &I##pa=(tab)[12],&I##ca=(tab)[13],&I##na=(tab)[14],&I##aa=(tab)[15]
-#define CImg_5x5_ref(I,T,tab)   T &I##bb=(tab)[0],&I##pb=(tab)[1],&I##cb=(tab)[2],&I##nb=(tab)[3],&I##ab=(tab)[4], \
-                                  &I##bp=(tab)[5],&I##pp=(tab)[6],&I##cp=(tab)[7],&I##np=(tab)[8],&I##ap=(tab)[9], \
-                                  &I##bc=(tab)[10],&I##pc=(tab)[11],&I##cc=(tab)[12],&I##nc=(tab)[13],&I##ac=(tab)[14], \
-                                  &I##bn=(tab)[15],&I##pn=(tab)[16],&I##cn=(tab)[17],&I##nn=(tab)[18],&I##an=(tab)[19], \
-                                  &I##ba=(tab)[20],&I##pa=(tab)[21],&I##ca=(tab)[22],&I##na=(tab)[23],&I##aa=(tab)[24]
-#define CImg_2x2x2_ref(I,T,tab) T &I##ccc=(tab)[0],&I##ncc=(tab)[1],&I##cnc=(tab)[2],&I##nnc=(tab)[3], \
-                                  &I##ccn=(tab)[4],&I##ncn=(tab)[5],&I##cnn=(tab)[6],&I##nnn=(tab)[7]
-#define CImg_3x3x3_ref(I,T,tab) T &I##ppp=(tab)[0],&I##cpp=(tab)[1],&I##npp=(tab)[2], \
-                                  &I##pcp=(tab)[3],&I##ccp=(tab)[4],&I##ncp=(tab)[5], \
-                                  &I##pnp=(tab)[6],&I##cnp=(tab)[7],&I##nnp=(tab)[8], \
-                                  &I##ppc=(tab)[9],&I##cpc=(tab)[10],&I##npc=(tab)[11], \
-                                  &I##pcc=(tab)[12],&I##ccc=(tab)[13],&I##ncc=(tab)[14], \
-                                  &I##pnc=(tab)[15],&I##cnc=(tab)[16],&I##nnc=(tab)[17], \
-                                  &I##ppn=(tab)[18],&I##cpn=(tab)[19],&I##npn=(tab)[20], \
-                                  &I##pcn=(tab)[21],&I##ccn=(tab)[22],&I##ncn=(tab)[23], \
-                                  &I##pnn=(tab)[24],&I##cnn=(tab)[25],&I##nnn=(tab)[26]
-
-#define cimg_squaresum2x2(I) ( I##cc*I##cc + I##nc*I##nc + I##cn*I##cn + I##nn*I##nn )
-#define cimg_squaresum3x3(I) ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + \
-                               I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + \
-                               I##pn*I##pn + I##cn*I##cn + I##nn*I##nn )
-#define cimg_squaresum4x4(I) ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
-                               I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
-                               I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
-                               I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
-#define cimg_squaresum5x5(I) ( I##bb*I##bb + I##pb*I##pb + I##cb*I##cb + I##nb*I##nb + I##ab*I##ab + \
-                               I##bp*I##bp + I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
-                               I##bc*I##bc + I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
-                               I##bn*I##bn + I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
-                               I##ba*I##ba + I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
-#define cimg_squaresum2x2x2(I) ( I##ccc*I##ccc + I##ncc*I##ncc + I##cnc*I##cnc + I##nnc*I##nnc + \
-                                 I##ccn*I##ccn + I##ncn*I##ncn + I##cnn*I##cnn + I##nnn*I##nnn )
-#define cimg_squaresum3x3x3(I) ( I##ppp*I##ppp + I##cpp*I##cpp + I##npp*I##npp + \
-                                 I##pcp*I##pcp + I##ccp*I##ccp + I##ncp*I##ncp + \
-                                 I##pnp*I##pnp + I##cnp*I##cnp + I##nnp*I##nnp + \
-                                 I##ppc*I##ppc + I##cpc*I##cpc + I##npc*I##npc + \
-                                 I##pcc*I##pcc + I##ccc*I##ccc + I##ncc*I##ncc + \
-                                 I##pnc*I##pnc + I##cnc*I##cnc + I##nnc*I##nnc + \
-                                 I##ppn*I##ppn + I##cpn*I##cpn + I##npn*I##npn + \
-                                 I##pcn*I##pcn + I##ccn*I##ccn + I##ncn*I##ncn + \
-                                 I##pnn*I##pnn + I##cnn*I##cnn + I##nnn*I##nnn )
-
-#define cimg_corr2x2(I,m) ( I##cc*(m)(0,0)+I##nc*(m)(1,0)+I##cn*(m)(0,1)+I##nn*(m)(1,1) )
-#define cimg_corr3x3(I,m) ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0) + \
-                            I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1) + \
-                            I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2) )
-#define cimg_corr4x4(I,m) ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0)+I##ap*(m)(3,0) + \
-                            I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1)+I##ac*(m)(3,1) + \
-                            I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2)+I##an*(m)(3,2) + \
-                            I##pa*(m)(0,3)+I##ca*(m)(1,3)+I##na*(m)(2,3)+I##aa*(m)(3,3) )
-#define cimg_corr5x5(I,m) ( I##bb*(m)(0,0)+I##pb*(m)(1,0)+I##cb*(m)(2,0)+I##nb*(m)(3,0)+I##ab*(m)(4,0) + \
-                            I##bp*(m)(0,1)+I##pp*(m)(1,1)+I##cp*(m)(2,1)+I##np*(m)(3,1)+I##ap*(m)(4,1) + \
-                            I##bc*(m)(0,2)+I##pc*(m)(1,2)+I##cc*(m)(2,2)+I##nc*(m)(3,2)+I##ac*(m)(4,2) + \
-                            I##bn*(m)(0,3)+I##pn*(m)(1,3)+I##cn*(m)(2,3)+I##nn*(m)(3,3)+I##an*(m)(4,3) + \
-                            I##ba*(m)(0,4)+I##pa*(m)(1,4)+I##ca*(m)(2,4)+I##na*(m)(3,4)+I##aa*(m)(4,4) )
-#define cimg_corr2x2x2(I,m) ( I##ccc*(m)(0,0,0)+I##ncc*(m)(1,0,0)+I##cnc*(m)(0,1,0)+I##nnc*(m)(1,1,0) + \
-                              I##ccn*(m)(0,0,1)+I##ncn*(m)(1,0,1)+I##cnn*(m)(0,1,1)+I##nnn*(m)(1,1,1) )
-#define cimg_corr3x3x3(I,m) ( I##ppp*(m)(0,0,0)+I##cpp*(m)(1,0,0)+I##npp*(m)(2,0,0) + \
-                              I##pcp*(m)(0,1,0)+I##ccp*(m)(1,1,0)+I##ncp*(m)(2,1,0) + \
-                              I##pnp*(m)(0,2,0)+I##cnp*(m)(1,2,0)+I##nnp*(m)(2,2,0) + \
-                              I##ppc*(m)(0,0,1)+I##cpc*(m)(1,0,1)+I##npc*(m)(2,0,1) + \
-                              I##pcc*(m)(0,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(2,1,1) + \
-                              I##pnc*(m)(0,2,1)+I##cnc*(m)(1,2,1)+I##nnc*(m)(2,2,1) + \
-                              I##ppn*(m)(0,0,2)+I##cpn*(m)(1,0,2)+I##npn*(m)(2,0,2) + \
-                              I##pcn*(m)(0,1,2)+I##ccn*(m)(1,1,2)+I##ncn*(m)(2,1,2) + \
-                              I##pnn*(m)(0,2,2)+I##cnn*(m)(1,2,2)+I##nnn*(m)(2,2,2) )
-
-#define cimg_conv2x2(I,m) ( I##cc*(m)(1,1)+I##nc*(m)(0,1)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
-#define cimg_conv3x3(I,m) ( I##pp*(m)(2,2)+I##cp*(m)(1,2)+I##np*(m)(0,2) + \
-                            I##pc*(m)(2,1)+I##cc*(m)(1,1)+I##nc*(m)(0,1) + \
-                            I##pn*(m)(2,0)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
-#define cimg_conv4x4(I,m) ( I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
-                            I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
-                            I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
-                            I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
-#define cimg_conv5x5(I,m) ( I##bb*(m)(4,4)+I##pb*(m)(3,4)+I##cb*(m)(2,4)+I##nb*(m)(1,4)+I##ab*(m)(0,4) + \
-                            I##bp*(m)(4,3)+I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
-                            I##bc*(m)(4,2)+I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
-                            I##bn*(m)(4,1)+I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
-                            I##ba*(m)(4,0)+I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
-#define cimg_conv2x2x2(I,m) ( I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
-                              I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
-#define cimg_conv3x3x3(I,m) ( I##ppp*(m)(2,2,2)+I##cpp*(m)(1,2,2)+I##npp*(m)(0,2,2) + \
-                              I##pcp*(m)(2,1,2)+I##ccp*(m)(1,1,2)+I##ncp*(m)(0,1,2) + \
-                              I##pnp*(m)(2,0,2)+I##cnp*(m)(1,0,2)+I##nnp*(m)(0,0,2) + \
-                              I##ppc*(m)(2,2,1)+I##cpc*(m)(1,2,1)+I##npc*(m)(0,2,1) + \
-                              I##pcc*(m)(2,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1) + \
-                              I##pnc*(m)(2,0,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
-                              I##ppn*(m)(2,2,0)+I##cpn*(m)(1,2,0)+I##npn*(m)(0,2,0) + \
-                              I##pcn*(m)(2,1,0)+I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0) + \
-                              I##pnn*(m)(2,0,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
-
-#define cimg_get2x2(img,x,y,z,v,I) I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
-    I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
-#define cimg_get3x3(img,x,y,z,v,I) I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), \
-    I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
-    I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
-#define cimg_get4x4(img,x,y,z,v,I)                                      \
-  I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
-    I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
-    I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
-    I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
-#define cimg_get5x5(img,x,y,z,v,I)                                      \
-  I##bb=(img)(_b##x,_b##y,z,v), I##pb=(img)(_p##x,_b##y,z,v), I##cb=(img)(x,_b##y,z,v), I##nb=(img)(_n##x,_b##y,z,v), I##ab=(img)(_a##x,_b##y,z,v), \
-    I##bp=(img)(_b##x,_p##y,z,v), I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
-    I##bc=(img)(_b##x,    y,z,v), I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
-    I##bn=(img)(_b##x,_n##y,z,v), I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
-    I##ba=(img)(_b##x,_a##y,z,v), I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
-#define cimg_get2x2x2(img,x,y,z,v,I)                                    \
-  I##ccc=(img)(x,y,    z,v), I##ncc=(img)(_n##x,y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
-    I##ccc=(img)(x,y,_n##z,v), I##ncc=(img)(_n##x,y,_n##z,v), I##cnc=(img)(x,_n##y,_n##z,v), I##nnc=(img)(_n##x,_n##y,_n##z,v)
-#define cimg_get3x3x3(img,x,y,z,v,I)                                    \
-  I##ppp=(img)(_p##x,_p##y,_p##z,v), I##cpp=(img)(x,_p##y,_p##z,v), I##npp=(img)(_n##x,_p##y,_p##z,v), \
-    I##pcp=(img)(_p##x,    y,_p##z,v), I##ccp=(img)(x,    y,_p##z,v), I##ncp=(img)(_n##x,    y,_p##z,v), \
-    I##pnp=(img)(_p##x,_n##y,_p##z,v), I##cnp=(img)(x,_n##y,_p##z,v), I##nnp=(img)(_n##x,_n##y,_p##z,v), \
-    I##ppc=(img)(_p##x,_p##y,    z,v), I##cpc=(img)(x,_p##y,    z,v), I##npc=(img)(_n##x,_p##y,    z,v), \
-    I##pcc=(img)(_p##x,    y,    z,v), I##ccc=(img)(x,    y,    z,v), I##ncc=(img)(_n##x,    y,    z,v), \
-    I##pnc=(img)(_p##x,_n##y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
-    I##ppn=(img)(_p##x,_p##y,_n##z,v), I##cpn=(img)(x,_p##y,_n##z,v), I##npn=(img)(_n##x,_p##y,_n##z,v), \
-    I##pcn=(img)(_p##x,    y,_n##z,v), I##ccn=(img)(x,    y,_n##z,v), I##ncn=(img)(_n##x,    y,_n##z,v), \
-    I##pnn=(img)(_p##x,_n##y,_n##z,v), I##cnn=(img)(x,_n##y,_n##z,v), I##nnn=(img)(_n##x,_n##y,_n##z,v)
-
-#define cimg_3x3to5x5(I,u) u##bb=I##pp,u##cb=I##cp,u##ab=I##np,u##bc=I##pc,u##cc=I##cc,u##ac=I##nc,u##ba=I##pn,u##ca=I##cn,u##aa=I##nn, \
-    u##pb=0.5*(u##bb+u##cb),u##nb=0.5*(u##cb+u##ab),u##pc=0.5*(u##bc+u##cc),u##nc=0.5*(u##cc+u##ac),u##pa=0.5*(u##ba+u##ca),u##na=0.5*(u##ca+u##aa), \
-    u##bp=0.5*(u##bb+u##bc),u##bn=0.5*(u##bc+u##ba),u##cp=0.5*(u##cb+u##cc),u##cn=0.5*(u##cc+u##ca),u##ap=0.5*(u##ab+u##ac),u##an=0.5*(u##ac+u##aa), \
-    u##pp=0.5*(u##bp+u##cp),u##np=0.5*(u##cp+u##ap),u##pn=0.5*(u##bn+u##cn),u##nn=0.5*(u##cn+u##an)
-
-// Macros used to define special image loops (see module 'Using Image Loops' in the generated documentation).
-#define cimg_map(img,ptr,T_ptr)   for (T_ptr *ptr=(img).data+(img).size()-1; ptr>=(img).data; ptr--)
-#define cimgl_map(list,l)         for (unsigned int l=0; l<(list).size; l++)
-#define cimg_mapoff(img,off)      for (unsigned int off=0; off<(img).size(); off++)
-#define cimg_mapX(img,x)          for (int x=0; x<(int)((img).width); x++)
-#define cimg_mapY(img,y)          for (int y=0; y<(int)((img).height);y++)
-#define cimg_mapZ(img,z)          for (int z=0; z<(int)((img).depth); z++)
-#define cimg_mapV(img,v)          for (int v=0; v<(int)((img).dim);   v++)
-#define cimg_mapXY(img,x,y)       cimg_mapY(img,y) cimg_mapX(img,x)
-#define cimg_mapXZ(img,x,z)       cimg_mapZ(img,z) cimg_mapX(img,x)
-#define cimg_mapYZ(img,y,z)       cimg_mapZ(img,z) cimg_mapY(img,y)
-#define cimg_mapXV(img,x,v)       cimg_mapV(img,v) cimg_mapX(img,x)
-#define cimg_mapYV(img,y,v)       cimg_mapV(img,v) cimg_mapY(img,y)
-#define cimg_mapZV(img,z,v)       cimg_mapV(img,v) cimg_mapZ(img,z)
-#define cimg_mapXYZ(img,x,y,z)    cimg_mapZ(img,z) cimg_mapXY(img,x,y)
-#define cimg_mapXYV(img,x,y,v)    cimg_mapV(img,v) cimg_mapXY(img,x,y)
-#define cimg_mapXZV(img,x,z,v)    cimg_mapV(img,v) cimg_mapXZ(img,x,z)
-#define cimg_mapYZV(img,y,z,v)    cimg_mapV(img,v) cimg_mapYZ(img,y,z)
-#define cimg_mapXYZV(img,x,y,z,v) cimg_mapV(img,v) cimg_mapXYZ(img,x,y,z)
-#define cimg_imapX(img,x,n)       for (int x=n; x<(int)((img).width-n); x++)
-#define cimg_imapY(img,y,n)       for (int y=n; y<(int)((img).height-n); y++)
-#define cimg_imapZ(img,z,n)       for (int z=n; z<(int)((img).depth-n); z++)
-#define cimg_imapV(img,v,n)       for (int v=n; v<(int)((img).dim-n); v++)
-#define cimg_imapXY(img,x,y,n)    cimg_imapY(img,y,n) cimg_imapX(img,x,n)
-#define cimg_imapXYZ(img,x,y,z,n) cimg_imapZ(img,z,n) cimg_imapXY(img,x,y,n)
-#define cimg_bmapX(img,x,n)       for (int x=0; x<(int)((img).width);  x==(n)-1?(x=(img).width-(n)): x++)
-#define cimg_bmapY(img,y,n)       for (int y=0; y<(int)((img).height); y==(n)-1?(x=(img).height-(n)):y++)
-#define cimg_bmapZ(img,z,n)       for (int z=0; z<(int)((img).depth);  z==(n)-1?(x=(img).depth-(n)): z++)
-#define cimg_bmapV(img,v,n)       for (int v=0; v<(int)((img).dim);    v==(n)-1?(x=(img).dim-(n)):   v++)
-#define cimg_bmapXY(img,x,y,n)    cimg_mapY(img,y) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n))?x++: \
-                                                          ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
-#define cimg_bmapXYZ(img,x,y,z,n) cimg_mapYZ(img,y,z) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n) || z<(n) || z>=(int)((img).depth)-(n))?x++: \
-                                                             ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
-#define cimg_2mapX(img,x)         for (int x=0,_n##x=1; _n##x<(int)((img).width)   || x==--_n##x; x++, _n##x++)
-#define cimg_2mapY(img,y)         for (int y=0,_n##y=1; _n##y<(int)((img).height)  || y==--_n##y; y++, _n##y++)
-#define cimg_2mapZ(img,z)         for (int z=0,_n##z=1; _n##z<(int)((img).depth)   || z==--_n##z; z++, _n##z++)
-#define cimg_2mapXY(img,x,y)      cimg_2mapY(img,y) cimg_2mapX(img,x)
-#define cimg_2mapXZ(img,x,z)      cimg_2mapZ(img,z) cimg_2mapX(img,x)
-#define cimg_2mapYZ(img,y,z)      cimg_2mapZ(img,z) cimg_2mapY(img,y)
-#define cimg_2mapXYZ(img,x,y,z)   cimg_2mapZ(img,z) cimg_2mapXY(img,x,y)
-#define cimg_3mapX(img,x)         for (int x=0,_p##x=0,_n##x=1; _n##x<(int)((img).width)  || x==--_n##x;  _p##x=x++,_n##x++)
-#define cimg_3mapY(img,y)         for (int y=0,_p##y=0,_n##y=1; _n##y<(int)((img).height) || y==--_n##y;  _p##y=y++,_n##y++)
-#define cimg_3mapZ(img,z)         for (int z=0,_p##z=0,_n##z=1; _n##z<(int)((img).depth)  || z==--_n##z;  _p##z=z++,_n##z++)
-#define cimg_3mapXY(img,x,y)      cimg_3mapY(img,y) cimg_3mapX(img,x)
-#define cimg_3mapXZ(img,x,z)      cimg_3mapZ(img,z) cimg_3mapX(img,x)
-#define cimg_3mapYZ(img,y,z)      cimg_3mapZ(img,z) cimg_3mapY(img,y)
-#define cimg_3mapXYZ(img,x,y,z)   cimg_3mapZ(img,z) cimg_3mapXY(img,x,y)
-#define cimg_4mapX(img,x)         for (int _p##x=0,x=0,_n##x=1,_a##x=2; \
-                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
-                                       _p##x=x++,_n##x++,_a##x++)
-#define cimg_4mapY(img,y)         for (int _p##y=0,y=0,_n##y=1,_a##y=2; \
-                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
-                                       _p##y=y++,_n##y++,_a##y++)
-#define cimg_4mapZ(img,z)         for (int _p##z=0,z=0,_n##z=1,_a##z=2; \
-                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
-                                       _p##z=z++,_n##z++,_a##z++)
-#define cimg_4mapXY(img,x,y)      cimg_4mapY(img,y) cimg_4mapX(img,x)
-#define cimg_4mapXZ(img,x,z)      cimg_4mapZ(img,z) cimg_4mapX(img,x)
-#define cimg_4mapYZ(img,y,z)      cimg_4mapZ(img,z) cimg_4mapY(img,y)
-#define cimg_4mapXYZ(img,x,y,z)   cimg_4mapZ(img,z) cimg_4mapXY(img,x,y)
-#define cimg_5mapX(img,x)         for (int _b##x=0,_p##x=0,x=0,_n##x=1,_a##x=2; \
-                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
-                                       _b##x=_p##x,_p##x=x++,_n##x++,_a##x++)
-#define cimg_5mapY(img,y)         for (int _b##y=0,_p##y=0,y=0,_n##y=1,_a##y=2; \
-                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
-                                       _b##y=_p##y,_p##y=y++,_n##y++,_a##y++)
-#define cimg_5mapZ(img,z)         for (int _b##z=0,_p##z=0,z=0,_n##z=1,_a##z=2; \
-                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
-                                       _b##z=_p##z,_p##z=z++,_n##z++,_a##z++)
-#define cimg_5mapXY(img,x,y)      cimg_5mapY(img,y) cimg_5mapX(img,x)
-#define cimg_5mapXZ(img,x,z)      cimg_5mapZ(img,z) cimg_5mapX(img,x)
-#define cimg_5mapYZ(img,y,z)      cimg_5mapZ(img,z) cimg_5mapY(img,y)
-#define cimg_5mapXYZ(img,x,y,z)   cimg_5mapZ(img,z) cimg_5mapXY(img,x,y)
-
-#define cimg_map2x2(img,x,y,z,v,I) cimg_2mapY(img,y)                    \
-       for (int _n##x=1, x=((int)(I##cc=(img)(0,  y,z,v),               \
-                                  I##cn=(img)(0,_n##y,z,v)),0);         \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##nc=(img)(_n##x,    y,z,v), \
-                                          I##nn=(img)(_n##x,_n##y,z,v), \
-                                          1)) || x==--_n##x;            \
-            I##cc=I##nc, I##cn=I##nn,                                   \
-              x++,_n##x++ )
-
-#define cimg_map3x3(img,x,y,z,v,I) cimg_3mapY(img,y)                    \
-       for (int _n##x=1, _p##x=(int)(I##cp=I##pp=(img)(0,_p##y,z,v),    \
-                                     I##cc=I##pc=(img)(0,  y,z,v),      \
-                                     I##cn=I##pn=(img)(0,_n##y,z,v)     \
-                                     ), x=_p##x=0;                      \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##np=(img)(_n##x,_p##y,z,v), \
-                                          I##nc=(img)(_n##x,    y,z,v), \
-                                          I##nn=(img)(_n##x,_n##y,z,v), \
-                                          1)) || x==--_n##x;            \
-            I##pp=I##cp, I##pc=I##cc, I##pn=I##cn,                      \
-              I##cp=I##np, I##cc=I##nc, I##cn=I##nn,                    \
-              _p##x=x++,_n##x++ )
-
-#define cimg_map4x4(img,x,y,z,v,I) cimg_4mapY(img,y)                    \
-       for (int _a##x=2, _n##x=1, x=((int)(I##cp=I##pp=(img)(0,_p##y,z,v), \
-                                           I##cc=I##pc=(img)(0,    y,z,v), \
-                                           I##cn=I##pn=(img)(0,_n##y,z,v), \
-                                           I##ca=I##pa=(img)(0,_a##y,z,v), \
-                                           I##np=(img)(_n##x,_p##y,z,v), \
-                                           I##nc=(img)(_n##x,    y,z,v), \
-                                           I##nn=(img)(_n##x,_n##y,z,v), \
-                                           I##na=(img)(_n##x,_a##y,z,v)),0), \
-              _p##x=0;                                                  \
-            (_a##x<(int)((img).width) && (                              \
-                                          I##ap=(img)(_a##x,_p##y,z,v), \
-                                          I##ac=(img)(_a##x,    y,z,v), \
-                                          I##an=(img)(_a##x,_n##y,z,v), \
-                                          I##aa=(img)(_a##x,_a##y,z,v), \
-                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
-            I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca,         \
-              I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na,       \
-              I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa,       \
-              _p##x=x++, _n##x++, _a##x++ )
-
-#define cimg_map5x5(img,x,y,z,v,I) cimg_5mapY(img,y)                    \
-       for (int _a##x=2, _n##x=1, _b##x=(int)(I##cb=I##pb=I##bb=(img)(0,_b##y,z,v), \
-                                              I##cp=I##pp=I##bp=(img)(0,_p##y,z,v), \
-                                              I##cc=I##pc=I##bc=(img)(0,    y,z,v), \
-                                              I##cn=I##pn=I##bn=(img)(0,_n##y,z,v), \
-                                              I##ca=I##pa=I##ba=(img)(0,_a##y,z,v), \
-                                              I##nb=(img)(_n##x,_b##y,z,v), \
-                                              I##np=(img)(_n##x,_p##y,z,v), \
-                                              I##nc=(img)(_n##x,   y,z,v), \
-                                              I##nn=(img)(_n##x,_n##y,z,v), \
-                                              I##na=(img)(_n##x,_a##y,z,v)), \
-              x=0, _p##x=_b##x=0;                                       \
-            (_a##x<(int)((img).width) && (                              \
-                                          I##ab=(img)(_a##x,_b##y,z,v), \
-                                          I##ap=(img)(_a##x,_p##y,z,v), \
-                                          I##ac=(img)(_a##x,    y,z,v), \
-                                          I##an=(img)(_a##x,_n##y,z,v), \
-                                          I##aa=(img)(_a##x,_a##y,z,v), \
-                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
-            I##bb=I##pb, I##bp=I##pp, I##bc=I##pc, I##bn=I##pn, I##ba=I##pa, \
-              I##pb=I##cb, I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca, \
-              I##cb=I##nb, I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na, \
-              I##nb=I##ab, I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa, \
-              _b##x=_p##x, _p##x=x++, _n##x++, _a##x++ )
-
-#define cimg_map2x2x2(img,x,y,z,v,I) cimg_2mapYZ(img,y,z)               \
-       for (int _n##x=1, x=((int)(I##ccc=(img)(0,    y,    z,v),        \
-                                  I##cnc=(img)(0,_n##y,    z,v),        \
-                                  I##ccn=(img)(0,    y,_n##z,v),        \
-                                  I##cnn=(img)(0,_n##y,_n##z,v)),0);    \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##ncc=(img)(_n##x,    y,    z,v), \
-                                          I##nnc=(img)(_n##x,_n##y,    z,v), \
-                                          I##ncn=(img)(_n##x,    y,_n##z,v), \
-                                          I##nnn=(img)(_n##x,_n##y,_n##z,v), \
-                                          1)) || x==--_n##x;            \
-            I##ccc=I##ncc, I##cnc=I##nnc,                               \
-              I##ccn=I##ncn, I##cnn=I##nnn,                             \
-              x++, _n##x++ )
-
-#define cimg_map3x3x3(img,x,y,z,v,I) cimg_3mapYZ(img,y,z)               \
-       for (int _n##x=1, _p##x=(int)(I##cpp=I##ppp=(img)(0,_p##y,_p##z,v), \
-                                     I##ccp=I##pcp=(img)(0,    y,_p##z,v), \
-                                     I##cnp=I##pnp=(img)(0,_n##y,_p##z,v), \
-                                     I##cpc=I##ppc=(img)(0,_p##y,    z,v), \
-                                     I##ccc=I##pcc=(img)(0,    y,    z,v), \
-                                     I##cnc=I##pnc=(img)(0,_n##y,    z,v), \
-                                     I##cpn=I##ppn=(img)(0,_p##y,_n##z,v), \
-                                     I##ccn=I##pcn=(img)(0,    y,_n##z,v), \
-                                     I##cnn=I##pnn=(img)(0,_n##y,_n##z,v)),\
-              x=_p##x=0;                                                \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##npp=(img)(_n##x,_p##y,_p##z,v), \
-                                          I##ncp=(img)(_n##x,    y,_p##z,v), \
-                                          I##nnp=(img)(_n##x,_n##y,_p##z,v), \
-                                          I##npc=(img)(_n##x,_p##y,    z,v), \
-                                          I##ncc=(img)(_n##x,    y,    z,v), \
-                                          I##nnc=(img)(_n##x,_n##y,    z,v), \
-                                          I##npn=(img)(_n##x,_p##y,_n##z,v), \
-                                          I##ncn=(img)(_n##x,    y,_n##z,v), \
-                                          I##nnn=(img)(_n##x,_n##y,_n##z,v), \
-                                          1)) || x==--_n##x;            \
-            I##ppp=I##cpp, I##pcp=I##ccp, I##pnp=I##cnp,                \
-              I##cpp=I##npp, I##ccp=I##ncp, I##cnp=I##nnp,              \
-              I##ppc=I##cpc, I##pcc=I##ccc, I##pnc=I##cnc,              \
-              I##cpc=I##npc, I##ccc=I##ncc, I##cnc=I##nnc,              \
-              I##ppn=I##cpn, I##pcn=I##ccn, I##pnn=I##cnn,              \
-              I##cpn=I##npn, I##ccn=I##ncn, I##cnn=I##nnn,              \
-              _p##x=x++, _n##x++ )
-
-/*-------------------------------------------------
-  -------------------------------------------------
-  
-
-
-    Definition of the cimg_library:: namespace
-  
- 
-  -------------------------------------------------
-  -------------------------------------------------*/
-
-//! The <tt>\ref cimg_library::</tt> namespace encompasses all classes and functions of the CImg library.
-/**
-   This namespace is defined to avoid class names collisions that could happen
-   with the include of other C++ header files. Anyway, it shouldn't happen
-   very often and you may start most of your programs with
-   \code
-   #include "CImg.h"
-   using namespace cimg_library;
-   \endcode
-   to simplify the declaration of CImg class variables afterward.
-**/
-namespace cimg_library {
-  struct CImgStats;
-  struct CImgDisplay;
-  struct CImgException;
-  template<typename T=float> struct CImg;
-  template<typename T=float> struct CImgl;
-  template<typename T=float> struct CImgROI;
-   
-  /*----------------------------------------------------
-    
-  
-  
-  Definition of the CImgException structures
-  
-  
-  
-  -------------------------------------------------*/
-  
-#if cimg_debug>=1
-#if cimg_display_type!=2
-#define cimg_exception_print(str) std::fprintf(stderr,"<CImg Error> %s",str);
-#else
-#define cimg_exception_print(str) MessageBox(NULL,(LPCTSTR)str,"<CImg Error>",MB_OK);
-#endif
-#else
-#define cimg_exception_print(str)
-#endif
-#define cimg_exception_err(etype)                                 \
-  char tmp[1024];                                                 \
-  va_list ap;                                                     \
-  va_start(ap,format);                                            \
-  std::vsprintf(message,format,ap);                               \
-  va_end(ap);                                                     \
-  std::sprintf(tmp,"==> %s \n\nGeneral : %s\n\n", message,etype); \
-  cimg_exception_print(tmp)
-  
-  //! The \ref CImgException class is used to throw general exceptions when an error occurs in a library call.
-  /** 
-      The \ref CImgException class is the base class of all CImg exceptions.
-      Exceptions are thrown by the CImg Library when an error occurs during the execution of a CImg function.
-      The CImgException is seldom thrown itself, children classes (that specify the type of error)
-      are generally used instead.
-      It may be thrown anyway for non-specialized exception types.
-
-      \see CImgInstanceException, CImgArgumentException, CImgIOException and CImgDisplayException.
-
-      By default, when an error occurs, the CImg Library displays an error message on the standart error output \e stderr
-      (on Unix), or opens a pop-up window displaying the error message (on Windows).
-      Then, it throws an instance of an exception class, generally leading the program to stop (this is the
-      default behavior of the C++ exception mechanism).
-      You can always bypass this behavior by handling the exceptions by yourself (using a code block <tt>try { ... } catch() { ... }</tt>).
-      Then, if you don't want the CImg Library to display error messages, you can define the environment variable
-      <tt>cimg_debug</tt> to 0 before including the header file <tt>CImg.h</tt> (see \ref cimg_environment).
-      
-      The <tt>CImgException</tt> class owns a member variable <tt>char* message</tt> that contains the exception message
-      describing precisely the error that occured.
-
-      The example above shows how to manually handle CImg Library errors properly :
-      \code
-      #define cimg_debug 0    // Disable error message display by CImg.
-      #define "CImg.h"
-      int main() {  
-        try {
-          ...; // Here, do what you want.
-        }
-        catch (CImgException &e) {
-          std::fprintf(stderr,"CImg Library Error : %s",e.message);  // Display error message
-          ...                                                        // Do what you want to save the ship !
-        }
-      }
-      \endcode      
-  **/
-  struct CImgException {
-    char message[1024]; //!< Error message
-    CImgException() { message[0]='\0'; }
-    CImgException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgException' throw,"
-			 "corresponding to a general exception problem."); 
-    }
-  };
-
-  //! The \ref CImgInstanceException class is used to throw an exception related
-  //! to a non suitable instance encountered in a library function call.  
-  /**
-     This class will be thrown when trying to call a class function from an
-     instance which is \e empty, or \e badly \e defined.
-     Typically, this exception occurs when using empty images :
-     \code
-     CImg<float> img; // define an empty image
-     img.blur(10);    // trying to blur an empty image will generate a CImgInstanceException.
-     \endcode
-     
-     \see CImgException, CImgArgumentException, CImgIOException and CImgDisplayException.
-  **/
-  struct CImgInstanceException : CImgException { 
-    CImgInstanceException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgInstanceException' throw.\n"
-			 "The instance passed through the function above has a bad structure"
-			 "(perhaps an empty image, list or display object ?)");
-    }};
-
-  //! The \ref CImgArgumentException class is used to throw an exception related
-  //! to invalid arguments encountered in a library function call.
-  /**
-     This class will be thrown when one passes one or several invalid arguments to
-     a library function. This may happen for instance in the following case :
-     \code
-     CImg<float> img(100,100); // define a 100x100 scalar image with float pixels
-     img.get_channel(1);       // trying to retrieve the vector channel v=1, will generate a CImgArgumentException.
-     \endcode
-     As the image <tt>img</tt> is scalar, it has only one vector channel (<tt>img.dim=1</tt>), and one cannot
-     retrieve the channel 1, (only the channel 0).
-     \see CImgException, CImgInstanceException, CImgIOException and CImgDisplayException.
-  **/
-  struct CImgArgumentException : CImgException { 
-    CImgArgumentException(const char *format,...) { 
-      cimg_exception_err("This error has been generated by a 'CImgArgumentException' throw.\n"
-			 "At least one argument passed to the function above has been considered as not valid.");
-    }};
-
-  //! The \ref CImgIOException class is used to throw an exception related 
-  //! to Input/Output file problems encountered in a library function call.
-  /**
-     This class will be thrown when one Input/Output problem has been encountered
-     during the execution of a library function. This may particularly happen when using <tt>load()</tt> and <tt>save()</tt>
-     functions, with invalid files :
-     \code
-     CImg<float> img("not_here.jpg");
-     \endcode
-     This code will throw a \c CImgIOException instance if the file <tt>not_here.jpg</tt> is not in the current directory.
-     \see CImgException, CImgInstanceException, CImgArgumentException and CImgDisplayException.
-  **/
-  struct CImgIOException : CImgException { 
-    CImgIOException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgIOException' throw.\n"
-			 "When trying to load or save a file, the function above has encountered a problem.");
-    }};
-
-  //! The CImgDisplayException class is used to throw an exception related to display problems
-  //! encountered in a library function call.
-  /**
-     This class will be thrown when a library function encounters a problem
-     when trying to open or close a display window. This shouldn't happen very much if your display is 
-     detected properly. This happens for instance when trying to open a display window on a 8bits screen
-     depth, under Unix/X11.
-
-     \see CImgException, CImgInstanceException, CImgArgumentException and CImgIOException.
-  **/
-  struct CImgDisplayException : CImgException {
-    CImgDisplayException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgDisplayException' throw.\n"
-			 "When trying to operate on a CImgDisplay instance, the function above encountered a problem."); 
-    }};
-  
-
-  /*-------------------------------------------------------------------------
-
-    Add LAPACK support to the library.
-  
-    Define the macro 'cimg_lapack' before including 'CImg.h' 
-    will activate the support of LAPACK. You'll have then to link
-    your code with the Lapack library to get it working.
-  
-    -----------------------------------------------------------------------*/
-#ifdef cimg_lapack
-  extern "C" {
-    extern void dgeev_(char*,char*, int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*);
-    extern void dsyev_(char*,char*,int*,double*,int*,double*,double*,int*,int*);
-    extern void dgetrf_(int*,int*,double*,int*,int*,int*);
-    extern void dgetri_(int*,double*,int*,int*,double*,int*,int*);
-  }
-#else
-  inline void cimg_nolapack() { 
-    throw CImgException("a LAPACK call : A LAPACK function has been required, but the LAPACK library"
-			"hasn't been linked.\nPlease define the compilation flag '#define cimg_lapack'"
-			"before including 'CImg.h' and link your code with LAPACK.");
-  }
-  inline void dgeev_ (char*,char*, int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*) { cimg_nolapack(); }
-  inline void dsyev_ (char*, char*, int*, double*, int*, double*, double*, int*, int*) { cimg_nolapack(); }
-  inline void dgetrf_(int*,int*,double*,int*,int*,int*) { cimg_nolapack(); }
-  inline void dgetri_(int*,double*,int*,int*,double*,int*,int*) { cimg_nolapack(); }
-#endif
-  
-
-  /*----------------------------------------
-    
-  
-  
-    Definition of the namespace 'cimg'
-  
-  
-  
-  --------------------------------------*/
-  
-  //! The <tt>\ref cimg::</tt> namespace encompasses \e low-level functions and variables of the CImg Library.
-  /**
-     Most of the functions and variables within this namespace are used by the library for low-level purposes.
-     Nevertheless, documented variables and functions below may be used by the user in its own source code.
-     \warning Never write <tt>"using namespace cimg_library::cimg;"</tt> in your source, since a lot of functions of the
-     \ref cimg:: namespace have the same name than standart C functions defined in the global namespace <tt>::</tt>.
-     
-     \see CImg, CImgl, CImgDisplay, CImgStats and CImgException.
-  **/
-  namespace cimg {
-
-    // Define internal library variables.
-    const unsigned int lblock=1024;
-#if cimg_display_type==1
-    static pthread_mutex_t*      X11_mutex = NULL;
-    static pthread_t*            X11_event_thread = NULL;
-    static CImgDisplay*          X11_wins[1024];
-    static Display*              X11_display = NULL;
-    static volatile unsigned int X11_nb_wins = 0;
-    static volatile bool         X11_thread_finished = false;
-    static unsigned int          X11_nb_bits = 0;
-    static GC*                   X11_gc = NULL;
-    static bool                  X11_colors_endian = false;
-#endif
-#ifdef cimg_color_terminal
-    const char t_normal[9]  = {0x1b,'[','0',';','0',';','0','m','\0'};
-    const char t_red[11]    = {0x1b,'[','4',';','3','1',';','5','9','m','\0'};
-    const char t_bold[5]    = {0x1b,'[','1','m','\0'};
-    const char t_purple[11] = {0x1b,'[','0',';','3','5',';','5','9','m','\0'};
-#else
-    const char t_normal[1]  = {'\0'};
-    static const char *t_red = t_normal, *t_bold = t_normal, *t_purple = t_normal;
-#endif
-    
-#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3
-    // Keycodes for X11-based graphical systems
-    const unsigned int keyESC        = XK_Escape;
-    const unsigned int keyF1         = XK_F1;
-    const unsigned int keyF2         = XK_F2;
-    const unsigned int keyF3         = XK_F3;
-    const unsigned int keyF4         = XK_F4;
-    const unsigned int keyF5         = XK_F5;
-    const unsigned int keyF6         = XK_F6;
-    const unsigned int keyF7         = XK_F7;
-    const unsigned int keyF8         = XK_F8;
-    const unsigned int keyF9         = XK_F9;
-    const unsigned int keyF10        = XK_F10;
-    const unsigned int keyF11        = XK_F11;
-    const unsigned int keyF12        = XK_F12;
-    const unsigned int keyPAUSE      = XK_Pause;
-    const unsigned int key1          = XK_1;
-    const unsigned int key2          = XK_2;
-    const unsigned int key3          = XK_3;
-    const unsigned int key4          = XK_4;
-    const unsigned int key5          = XK_5;
-    const unsigned int key6          = XK_6;
-    const unsigned int key7          = XK_7;
-    const unsigned int key8          = XK_8;
-    const unsigned int key9          = XK_9;
-    const unsigned int key0          = XK_0;
-    const unsigned int keyBACKSPACE  = XK_BackSpace;
-    const unsigned int keyINSERT     = XK_Insert;
-    const unsigned int keyHOME       = XK_Home;
-    const unsigned int keyPAGEUP     = XK_Page_Up;
-    const unsigned int keyTAB        = XK_Tab;
-    const unsigned int keyQ          = XK_q;
-    const unsigned int keyW          = XK_w;
-    const unsigned int keyE          = XK_e;
-    const unsigned int keyR          = XK_r;
-    const unsigned int keyT          = XK_t;
-    const unsigned int keyY          = XK_y;
-    const unsigned int keyU          = XK_u;
-    const unsigned int keyI          = XK_i;
-    const unsigned int keyO          = XK_o;
-    const unsigned int keyP          = XK_p;
-    const unsigned int keyDELETE     = XK_Delete;
-    const unsigned int keyEND        = XK_End;
-    const unsigned int keyPAGEDOWN   = XK_Page_Down;
-    const unsigned int keyCAPSLOCK   = XK_Caps_Lock;
-    const unsigned int keyA          = XK_a;
-    const unsigned int keyS          = XK_s;
-    const unsigned int keyD          = XK_d;
-    const unsigned int keyF          = XK_f;
-    const unsigned int keyG          = XK_g;
-    const unsigned int keyH          = XK_h;
-    const unsigned int keyJ          = XK_j;
-    const unsigned int keyK          = XK_k;
-    const unsigned int keyL          = XK_l;
-    const unsigned int keyENTER      = XK_Return;
-    const unsigned int keySHIFTLEFT  = XK_Shift_L;
-    const unsigned int keyZ          = XK_z;
-    const unsigned int keyX          = XK_x;
-    const unsigned int keyC          = XK_c;
-    const unsigned int keyV          = XK_v;
-    const unsigned int keyB          = XK_b;
-    const unsigned int keyN          = XK_n;
-    const unsigned int keyM          = XK_m;
-    const unsigned int keySHIFTRIGHT = XK_Shift_R;
-    const unsigned int keyARROWUP    = XK_Up;
-    const unsigned int keyCTRLLEFT   = XK_Control_L;
-    const unsigned int keyAPPLEFT    = XK_Super_L;
-    const unsigned int keySPACE      = XK_space;
-    const unsigned int keyALTGR      = XK_Alt_R;
-    const unsigned int keyAPPRIGHT   = XK_Super_R;
-    const unsigned int keyMENU       = XK_Menu;
-    const unsigned int keyCTRLRIGHT  = XK_Control_R;
-    const unsigned int keyARROWLEFT  = XK_Left;
-    const unsigned int keyARROWDOWN  = XK_Down;
-    const unsigned int keyARROWRIGHT = XK_Right;  
-#else
-    // Keycodes for Windows-OS
-    //@{
-    //!\name Keycodes.
-    /** 
-	Keycodes are used to detect keyboard events occuring on display windows \c CImgDisplay.
-	The field \c key of the \c CImgDisplay structure is updated at real-time with the corresponding keycode
-	of the pressed key (or 0 if no keys have been pressed). The keycodes values are given by the variables
-	whose names are of the form <tt>cimg::key*</tt>. Above is the keycode for the 'ESC' key, but
-	almost all keycodes are thus defined.
-        Using CImg-defined keycodes ensures a better portability of your program for other architectures.
-    **/
-    const unsigned int keyESC        = 27;
-    const unsigned int keyF1         = 112;
-    const unsigned int keyF2         = 113;
-    const unsigned int keyF3         = 114;
-    const unsigned int keyF4         = 115;
-    const unsigned int keyF5         = 116;
-    const unsigned int keyF6         = 117;
-    const unsigned int keyF7         = 118;
-    const unsigned int keyF8         = 119;
-    const unsigned int keyF9         = 120;
-    const unsigned int keyF10        = 121;
-    const unsigned int keyF11        = 122;
-    const unsigned int keyF12        = 123;
-    const unsigned int keyPAUSE      = 19;
-    const unsigned int key1          = 49;
-    const unsigned int key2          = 50;
-    const unsigned int key3          = 51;
-    const unsigned int key4          = 52;
-    const unsigned int key5          = 53;
-    const unsigned int key6          = 54;
-    const unsigned int key7          = 55;
-    const unsigned int key8          = 56;
-    const unsigned int key9          = 57;
-    const unsigned int key0          = 48;
-    const unsigned int keyBACKSPACE  = 8;
-    const unsigned int keyINSERT     = 45;
-    const unsigned int keyHOME       = 36;
-    const unsigned int keyPAGEUP     = 33;
-    const unsigned int keyTAB        = 9;
-    const unsigned int keyQ          = 81;
-    const unsigned int keyW          = 87;
-    const unsigned int keyE          = 69;
-    const unsigned int keyR          = 82;
-    const unsigned int keyT          = 84;
-    const unsigned int keyY          = 89;
-    const unsigned int keyU          = 85;
-    const unsigned int keyI          = 73;
-    const unsigned int keyO          = 79;
-    const unsigned int keyP          = 80;
-    const unsigned int keyDELETE     = 8;
-    const unsigned int keyEND        = 35;
-    const unsigned int keyPAGEDOWN   = 34;
-    const unsigned int keyCAPSLOCK   = 20;
-    const unsigned int keyA          = 65;
-    const unsigned int keyS          = 83;
-    const unsigned int keyD          = 68;
-    const unsigned int keyF          = 70;
-    const unsigned int keyG          = 71;
-    const unsigned int keyH          = 72;
-    const unsigned int keyJ          = 74;
-    const unsigned int keyK          = 75;
-    const unsigned int keyL          = 76;
-    const unsigned int keyENTER      = 13;
-    const unsigned int keySHIFTLEFT  = 16;
-    const unsigned int keyZ          = 90;
-    const unsigned int keyX          = 88;
-    const unsigned int keyC          = 67;
-    const unsigned int keyV          = 86;
-    const unsigned int keyB          = 66;
-    const unsigned int keyN          = 78;
-    const unsigned int keyM          = 77;
-    const unsigned int keySHIFTRIGHT = 16;
-    const unsigned int keyARROWUP    = 38;
-    const unsigned int keyCTRLLEFT   = 17;
-    const unsigned int keyAPPLEFT    = 91;
-    const unsigned int keySPACE      = 32;
-    const unsigned int keyALTGR      = 17;
-    const unsigned int keyAPPRIGHT   = 92;
-    const unsigned int keyMENU       = 93;
-    const unsigned int keyCTRLRIGHT  = 17;
-    const unsigned int keyARROWLEFT  = 37;
-    const unsigned int keyARROWDOWN  = 40;
-    const unsigned int keyARROWRIGHT = 39;
-#endif
-    //@}
-
-#ifdef PI
-#undef PI
-#endif
-    const double PI = 3.14159265358979323846;   //!< Definition of the mathematical constant PI
-
-    // Definition of a 7x11x1x3 font, used to return a default font for drawing text.
-    const unsigned int font7x11[7*11*256/8] = 
-      {0x00000000,
-       0x00000000,0x00000000,0x00000002,0x04081020,0x00800000,0x24489000,0x00000000,0x000000a1,
-       0x4f8a7e50,0xa0000002,0x0f287030,0x50a78200,0x00008695,0x454552c2,0x00000002,0x0a143193,
-       0x19f00000,0x04081000,0x00000000,0x00001841,0x02040810,0x20203006,0x02020408,0x1020410c,
-       0x000010d8,0xc1400000,0x00000000,0x01021f08,0x10200000,0x00000000,0x00018302,0x08000000,
-       0x0007c000,0x00000000,0x00000000,0x0060c000,0x0000820c,0x1040820c,0x10400000,0xe2244891,
-       0x22380000,0x00061408,0x102043e0,0x00000070,0x10208208,0x1e000000,0x03c0810c,0x0408e000,
-       0x0000020c,0x2891f040,0x80000000,0xf1020701,0x02380000,0x0001c410,0x2c6488e0,0x0000003e,
-       0x08104102,0x08000000,0x00e22487,0x11223800,0x00000711,0x223c0823,0x80000000,0x0060c000,
-       0x060c0000,0x00000306,0x00003060,0x41000000,0x0218c180,0xc0400000,0x000007f0,0x1fc00000,
-       0x00000010,0x180c18c2,0x00000000,0x3c440820,0x80020000,0x0000f229,0xd4afa038,0x00000002,
-       0x0a1444f9,0x14100000,0x00788913,0xc4489e00,0x000001e4,0x10204040,0x78000000,0x1e224489,
-       0x12278000,0x0000f902,0x0788103e,0x00000007,0xc8103c40,0x81000000,0x001e4102,0x34244780,
-       0x00000112,0x244f9122,0x44000000,0x0f840810,0x2043e000,0x00003810,0x2040811c,0x00000002,
-       0x248a1828,0x48880000,0x00102040,0x810207c0,0x0000019b,0x36ab56a9,0x42000000,0x044c9d2a,
-       0x4c991000,0x00003c85,0x0a14284f,0x00000001,0xe2244f10,0x20400000,0x000f2142,0x850a13c0,
-       0xc0c000f1,0x12278911,0x21000000,0x01e4080e,0x0204f000,0x00003f88,0x10204081,0x00000000,
-       0x89122448,0x911c0000,0x00082891,0x22285040,0x00000041,0x9325ab64,0xc8800000,0x020a2282,
-       0x0a228200,0x00001051,0x14102040,0x80000000,0xfc082082,0x083f0000,0x00e10204,0x08102040,
-       0x81c01010,0x20202040,0x40808080,0x70204081,0x02040810,0xe0008105,0x1b228200,0x00000000,
-       0x00000000,0x00003f80,0x20200000,0x00000000,0x00000000,0x0e023c89,0x11f00000,0x2040b192,
-       0x24489e00,0x00000003,0xc8102040,0x78000000,0x811e4489,0x1223c000,0x000000e2,0x27c8101e,
-       0x00000071,0x0fc40810,0x20400000,0x00003c89,0x12244781,0x1c008102,0xe6489122,0x44000001,
-       0x001c0810,0x20408000,0x00040070,0x20408102,0x04700102,0x04491c28,0x48880000,0x0e040810,
-       0x20408100,0x00000002,0xded93264,0xc9000000,0x000b9922,0x44891000,0x00000038,0x89122447,
-       0x00000000,0x02c64891,0x22788100,0x00000f22,0x448911e0,0x40800000,0xb9920408,0x10000000,
-       0x00078818,0x0c08e000,0x0000083e,0x20408101,0xc0000000,0x01122448,0x933a0000,0x00001051,
-       0x22285040,0x00000000,0x8326ad56,0xc8800000,0x00042486,0x0c248400,0x00000020,0xa24450a0,
-       0x831c0000,0x00f81041,0x041f0000,0x00308102,0x0c081020,0x40600204,0x08102040,0x81020400,
-       0x60204081,0x82040810,0xe0000000,0x00399c00,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x04001020,
-       0x40810000,0x00107142,0x85070400,0x000000c2,0x041c1020,0xf0000000,0x213c4891,0xe4200000,
-       0x00010511,0x47c21f08,0x00000081,0x02000000,0x00408100,0x001c40c1,0x62428302,0x38480000,
-       0x00000000,0x00000000,0x0f215aa5,0x6a13c000,0x00007871,0x23e00000,0x00000000,0x00028a28,
-       0x28280000,0x00000001,0xf8102000,0x00000000,0x0007c000,0x00000000,0x07113a44,0x70000000,
-       0x1fc00000,0x00000000,0x00000000,0x41410000,0x00000000,0x00000408,0x7c2043e0,0x0000003c,
-       0x30f00000,0x00000000,0x01c10700,0x00000000,0x00820000,0x00000000,0x00000000,0x01122448,
-       0x933a4080,0x0007ce9d,0x1a142850,0xa1400000,0x0000c180,0x00000000,0x00000000,0x00000010,
-       0x60000604,0x08000000,0x00000000,0x30912180,0x00000000,0x0000000a,0x0a0a28a0,0x00000032,
-       0x28505952,0xf8400000,0x01914282,0xe8514700,0x00000e38,0xba0e34be,0x10000000,0x00100040,
-       0x8208111e,0x40404142,0x889f2282,0x00004102,0x0a1444f9,0x1410000c,0x241050a2,0x27c8a080,
-       0x0028a082,0x85113e45,0x04000480,0x04142889,0xf2282000,0x082820a1,0x444f9141,0x00000001,
-       0xc60c2c50,0xe2700000,0x001e4102,0x04040782,0x0c2021f2,0x040f1020,0x7c000020,0x8f902078,
-       0x8103e000,0x0c247c81,0x03c4081f,0x00009003,0xe4081e20,0x40f80002,0x021f0810,0x204087c0,
-       0x000410f8,0x40810204,0x3e0000c2,0x47c20408,0x1021f000,0x09003e10,0x2040810f,0x80000001,
-       0xe2245c91,0x22780000,0xa288993a,0x54993220,0x00080879,0x0a142850,0x9e000010,0x43c850a1,
-       0x4284f000,0x03091e42,0x850a1427,0x80000a28,0xf2142850,0xa13c0001,0x200790a1,0x428509e0,
-       0x00000000,0x8490c184,0x90800000,0x01f66954,0xa966f800,0x01010891,0x22448911,0xc0000104,
-       0x44891224,0x488e0000,0x61222448,0x91224470,0x00048011,0x22448912,0x23800002,0x09051141,
-       0x02040800,0x0000040f,0x112244f1,0x0000000e,0x2448a142,0x444b8000,0x202001c0,0x4791223e,
-       0x00004100,0x0e023c89,0x11f0000c,0x24007011,0xe4488f80,0x0028a003,0x808f2244,0x7c000005,
-       0x001c0479,0x1223e000,0x082820e0,0x23c8911f,0x00000000,0x1d853e91,0x21b00000,0x00003c81,
-       0x02040782,0x0c202001,0xc44f9020,0x3c000041,0x000e227c,0x8101e000,0x0c240071,0x13e4080f,
-       0x000000a0,0x03889f20,0x40780002,0x02003810,0x20408100,0x00041001,0xc0810204,0x080000c2,
-       0x400e0408,0x10204000,0x000a0070,0x20408102,0x000000e1,0x21c44891,0x22380000,0xa2801732,
-       0x44891220,0x00080800,0x71122448,0x8e000020,0x80038891,0x22447000,0x0309001c,0x44891223,
-       0x80000a28,0x00e22448,0x911c0000,0x01400711,0x224488e0,0x00000000,0x2003f000,0x04000000,
-       0x0001e4ca,0x99327800,0x01010011,0x22448933,0xa0000410,0x00891224,0x499d0000,0x61200448,
-       0x91224ce8,0x00000500,0x22448912,0x67400004,0x10020a24,0x450a0831,0xc002040b,0x19224489,
-       0xe204000a,0x00828911,0x42820c70,0x00000000,0x00000000,0x00000002,0x04081020,0x00800000,
-       0x24489000,0x00000000,0x000000a1,0x4f8a7e50,0xa0000002,0x0f287030,0x50a78200,0x00008695,
-       0x454552c2,0x00000002,0x0a143193,0x19f00000,0x04081000,0x00000000,0x00001841,0x02040810,
-       0x20203006,0x02020408,0x1020410c,0x000010d8,0xc1400000,0x00000000,0x01021f08,0x10200000,
-       0x00000000,0x00018302,0x08000000,0x0007c000,0x00000000,0x00000000,0x0060c000,0x0000820c,
-       0x1040820c,0x10400000,0xe2244891,0x22380000,0x00061408,0x102043e0,0x00000070,0x10208208,
-       0x1e000000,0x03c0810c,0x0408e000,0x0000020c,0x2891f040,0x80000000,0xf1020701,0x02380000,
-       0x0001c410,0x2c6488e0,0x0000003e,0x08104102,0x08000000,0x00e22487,0x11223800,0x00000711,
-       0x223c0823,0x80000000,0x0060c000,0x060c0000,0x00000306,0x00003060,0x41000000,0x0218c180,
-       0xc0400000,0x000007f0,0x1fc00000,0x00000010,0x180c18c2,0x00000000,0x3c440820,0x80020000,
-       0x0000f229,0xd4afa038,0x00000002,0x0a1444f9,0x14100000,0x00788913,0xc4489e00,0x000001e4,
-       0x10204040,0x78000000,0x1e224489,0x12278000,0x0000f902,0x0788103e,0x00000007,0xc8103c40,
-       0x81000000,0x001e4102,0x34244780,0x00000112,0x244f9122,0x44000000,0x0f840810,0x2043e000,
-       0x00003810,0x2040811c,0x00000002,0x248a1828,0x48880000,0x00102040,0x810207c0,0x0000019b,
-       0x36ab56a9,0x42000000,0x044c9d2a,0x4c991000,0x00003c85,0x0a14284f,0x00000001,0xe2244f10,
-       0x20400000,0x000f2142,0x850a13c0,0xc0c000f1,0x12278911,0x21000000,0x01e4080e,0x0204f000,
-       0x00003f88,0x10204081,0x00000000,0x89122448,0x911c0000,0x00082891,0x22285040,0x00000041,
-       0x9325ab64,0xc8800000,0x020a2282,0x0a228200,0x00001051,0x14102040,0x80000000,0xfc082082,
-       0x083f0000,0x00e10204,0x08102040,0x81c01010,0x20202040,0x40808080,0x70204081,0x02040810,
-       0xe0008105,0x1b228200,0x00000000,0x00000000,0x00003f80,0x20200000,0x00000000,0x00000000,
-       0x0e023c89,0x11f00000,0x2040b192,0x24489e00,0x00000003,0xc8102040,0x78000000,0x811e4489,
-       0x1223c000,0x000000e2,0x27c8101e,0x00000071,0x0fc40810,0x20400000,0x00003c89,0x12244781,
-       0x1c008102,0xe6489122,0x44000001,0x001c0810,0x20408000,0x00040070,0x20408102,0x04700102,
-       0x04491c28,0x48880000,0x0e040810,0x20408100,0x00000002,0xded93264,0xc9000000,0x000b9922,
-       0x44891000,0x00000038,0x89122447,0x00000000,0x02c64891,0x22788100,0x00000f22,0x448911e0,
-       0x40800000,0xb9920408,0x10000000,0x00078818,0x0c08e000,0x0000083e,0x20408101,0xc0000000,
-       0x01122448,0x933a0000,0x00001051,0x22285040,0x00000000,0x8326ad56,0xc8800000,0x00042486,
-       0x0c248400,0x00000020,0xa24450a0,0x831c0000,0x00f81041,0x041f0000,0x00308102,0x0c081020,
-       0x40600204,0x08102040,0x81020400,0x60204081,0x82040810,0xe0000000,0x00399c00,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x04001020,0x40810000,0x00107142,0x85070400,0x000000c2,0x041c1020,
-       0xf0000000,0x213c4891,0xe4200000,0x00010511,0x47c21f08,0x00000081,0x02000000,0x00408100,
-       0x001c40c1,0x62428302,0x38480000,0x00000000,0x00000000,0x0f215aa5,0x6a13c000,0x00007871,
-       0x23e00000,0x00000000,0x00028a28,0x28280000,0x00000001,0xf8102000,0x00000000,0x0007c000,
-       0x00000000,0x07113a44,0x70000000,0x1fc00000,0x00000000,0x00000000,0x41410000,0x00000000,
-       0x00000408,0x7c2043e0,0x0000003c,0x30f00000,0x00000000,0x01c10700,0x00000000,0x00820000,
-       0x00000000,0x00000000,0x01122448,0x933a4080,0x0007ce9d,0x1a142850,0xa1400000,0x0000c180,
-       0x00000000,0x00000000,0x00000010,0x60000604,0x08000000,0x00000000,0x30912180,0x00000000,
-       0x0000000a,0x0a0a28a0,0x00000032,0x28505952,0xf8400000,0x01914282,0xe8514700,0x00000e38,
-       0xba0e34be,0x10000000,0x00100040,0x8208111e,0x40404142,0x889f2282,0x00004102,0x0a1444f9,
-       0x1410000c,0x241050a2,0x27c8a080,0x0028a082,0x85113e45,0x04000480,0x04142889,0xf2282000,
-       0x082820a1,0x444f9141,0x00000001,0xc60c2c50,0xe2700000,0x001e4102,0x04040782,0x0c2021f2,
-       0x040f1020,0x7c000020,0x8f902078,0x8103e000,0x0c247c81,0x03c4081f,0x00009003,0xe4081e20,
-       0x40f80002,0x021f0810,0x204087c0,0x000410f8,0x40810204,0x3e0000c2,0x47c20408,0x1021f000,
-       0x09003e10,0x2040810f,0x80000001,0xe2245c91,0x22780000,0xa288993a,0x54993220,0x00080879,
-       0x0a142850,0x9e000010,0x43c850a1,0x4284f000,0x03091e42,0x850a1427,0x80000a28,0xf2142850,
-       0xa13c0001,0x200790a1,0x428509e0,0x00000000,0x8490c184,0x90800000,0x01f66954,0xa966f800,
-       0x01010891,0x22448911,0xc0000104,0x44891224,0x488e0000,0x61222448,0x91224470,0x00048011,
-       0x22448912,0x23800002,0x09051141,0x02040800,0x0000040f,0x112244f1,0x0000000e,0x2448a142,
-       0x444b8000,0x202001c0,0x4791223e,0x00004100,0x0e023c89,0x11f0000c,0x24007011,0xe4488f80,
-       0x0028a003,0x808f2244,0x7c000005,0x001c0479,0x1223e000,0x082820e0,0x23c8911f,0x00000000,
-       0x1d853e91,0x21b00000,0x00003c81,0x02040782,0x0c202001,0xc44f9020,0x3c000041,0x000e227c,
-       0x8101e000,0x0c240071,0x13e4080f,0x000000a0,0x03889f20,0x40780002,0x02003810,0x20408100,
-       0x00041001,0xc0810204,0x080000c2,0x400e0408,0x10204000,0x000a0070,0x20408102,0x000000e1,
-       0x21c44891,0x22380000,0xa2801732,0x44891220,0x00080800,0x71122448,0x8e000020,0x80038891,
-       0x22447000,0x0309001c,0x44891223,0x80000a28,0x00e22448,0x911c0000,0x01400711,0x224488e0,
-       0x00000000,0x2003f000,0x04000000,0x0001e4ca,0x99327800,0x01010011,0x22448933,0xa0000410,
-       0x00891224,0x499d0000,0x61200448,0x91224ce8,0x00000500,0x22448912,0x67400004,0x10020a24,
-       0x450a0831,0xc002040b,0x19224489,0xe204000a,0x00828911,0x42820c70,0x00000000,0x00000000,
-       0x00000002,0x04081020,0x00800000,0x24489000,0x00000000,0x000000a1,0x4f8a7e50,0xa0000002,
-       0x0f287030,0x50a78200,0x00008695,0x454552c2,0x00000002,0x0a143193,0x19f00000,0x04081000,
-       0x00000000,0x00001841,0x02040810,0x20203006,0x02020408,0x1020410c,0x000010d8,0xc1400000,
-       0x00000000,0x01021f08,0x10200000,0x00000000,0x00018302,0x08000000,0x0007c000,0x00000000,
-       0x00000000,0x0060c000,0x0000820c,0x1040820c,0x10400000,0xe2244891,0x22380000,0x00061408,
-       0x102043e0,0x00000070,0x10208208,0x1e000000,0x03c0810c,0x0408e000,0x0000020c,0x2891f040,
-       0x80000000,0xf1020701,0x02380000,0x0001c410,0x2c6488e0,0x0000003e,0x08104102,0x08000000,
-       0x00e22487,0x11223800,0x00000711,0x223c0823,0x80000000,0x0060c000,0x060c0000,0x00000306,
-       0x00003060,0x41000000,0x0218c180,0xc0400000,0x000007f0,0x1fc00000,0x00000010,0x180c18c2,
-       0x00000000,0x3c440820,0x80020000,0x0000f229,0xd4afa038,0x00000002,0x0a1444f9,0x14100000,
-       0x00788913,0xc4489e00,0x000001e4,0x10204040,0x78000000,0x1e224489,0x12278000,0x0000f902,
-       0x0788103e,0x00000007,0xc8103c40,0x81000000,0x001e4102,0x34244780,0x00000112,0x244f9122,
-       0x44000000,0x0f840810,0x2043e000,0x00003810,0x2040811c,0x00000002,0x248a1828,0x48880000,
-       0x00102040,0x810207c0,0x0000019b,0x36ab56a9,0x42000000,0x044c9d2a,0x4c991000,0x00003c85,
-       0x0a14284f,0x00000001,0xe2244f10,0x20400000,0x000f2142,0x850a13c0,0xc0c000f1,0x12278911,
-       0x21000000,0x01e4080e,0x0204f000,0x00003f88,0x10204081,0x00000000,0x89122448,0x911c0000,
-       0x00082891,0x22285040,0x00000041,0x9325ab64,0xc8800000,0x020a2282,0x0a228200,0x00001051,
-       0x14102040,0x80000000,0xfc082082,0x083f0000,0x00e10204,0x08102040,0x81c01010,0x20202040,
-       0x40808080,0x70204081,0x02040810,0xe0008105,0x1b228200,0x00000000,0x00000000,0x00003f80,
-       0x20200000,0x00000000,0x00000000,0x0e023c89,0x11f00000,0x2040b192,0x24489e00,0x00000003,
-       0xc8102040,0x78000000,0x811e4489,0x1223c000,0x000000e2,0x27c8101e,0x00000071,0x0fc40810,
-       0x20400000,0x00003c89,0x12244781,0x1c008102,0xe6489122,0x44000001,0x001c0810,0x20408000,
-       0x00040070,0x20408102,0x04700102,0x04491c28,0x48880000,0x0e040810,0x20408100,0x00000002,
-       0xded93264,0xc9000000,0x000b9922,0x44891000,0x00000038,0x89122447,0x00000000,0x02c64891,
-       0x22788100,0x00000f22,0x448911e0,0x40800000,0xb9920408,0x10000000,0x00078818,0x0c08e000,
-       0x0000083e,0x20408101,0xc0000000,0x01122448,0x933a0000,0x00001051,0x22285040,0x00000000,
-       0x8326ad56,0xc8800000,0x00042486,0x0c248400,0x00000020,0xa24450a0,0x831c0000,0x00f81041,
-       0x041f0000,0x00308102,0x0c081020,0x40600204,0x08102040,0x81020400,0x60204081,0x82040810,
-       0xe0000000,0x00399c00,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x04001020,0x40810000,0x00107142,
-       0x85070400,0x000000c2,0x041c1020,0xf0000000,0x213c4891,0xe4200000,0x00010511,0x47c21f08,
-       0x00000081,0x02000000,0x00408100,0x001c40c1,0x62428302,0x38480000,0x00000000,0x00000000,
-       0x0f215aa5,0x6a13c000,0x00007871,0x23e00000,0x00000000,0x00028a28,0x28280000,0x00000001,
-       0xf8102000,0x00000000,0x0007c000,0x00000000,0x07113a44,0x70000000,0x1fc00000,0x00000000,
-       0x00000000,0x41410000,0x00000000,0x00000408,0x7c2043e0,0x0000003c,0x30f00000,0x00000000,
-       0x01c10700,0x00000000,0x00820000,0x00000000,0x00000000,0x01122448,0x933a4080,0x0007ce9d,
-       0x1a142850,0xa1400000,0x0000c180,0x00000000,0x00000000,0x00000010,0x60000604,0x08000000,
-       0x00000000,0x30912180,0x00000000,0x0000000a,0x0a0a28a0,0x00000032,0x28505952,0xf8400000,
-       0x01914282,0xe8514700,0x00000e38,0xba0e34be,0x10000000,0x00100040,0x8208111e,0x40404142,
-       0x889f2282,0x00004102,0x0a1444f9,0x1410000c,0x241050a2,0x27c8a080,0x0028a082,0x85113e45,
-       0x04000480,0x04142889,0xf2282000,0x082820a1,0x444f9141,0x00000001,0xc60c2c50,0xe2700000,
-       0x001e4102,0x04040782,0x0c2021f2,0x040f1020,0x7c000020,0x8f902078,0x8103e000,0x0c247c81,
-       0x03c4081f,0x00009003,0xe4081e20,0x40f80002,0x021f0810,0x204087c0,0x000410f8,0x40810204,
-       0x3e0000c2,0x47c20408,0x1021f000,0x09003e10,0x2040810f,0x80000001,0xe2245c91,0x22780000,
-       0xa288993a,0x54993220,0x00080879,0x0a142850,0x9e000010,0x43c850a1,0x4284f000,0x03091e42,
-       0x850a1427,0x80000a28,0xf2142850,0xa13c0001,0x200790a1,0x428509e0,0x00000000,0x8490c184,
-       0x90800000,0x01f66954,0xa966f800,0x01010891,0x22448911,0xc0000104,0x44891224,0x488e0000,
-       0x61222448,0x91224470,0x00048011,0x22448912,0x23800002,0x09051141,0x02040800,0x0000040f,
-       0x112244f1,0x0000000e,0x2448a142,0x444b8000,0x202001c0,0x4791223e,0x00004100,0x0e023c89,
-       0x11f0000c,0x24007011,0xe4488f80,0x0028a003,0x808f2244,0x7c000005,0x001c0479,0x1223e000,
-       0x082820e0,0x23c8911f,0x00000000,0x1d853e91,0x21b00000,0x00003c81,0x02040782,0x0c202001,
-       0xc44f9020,0x3c000041,0x000e227c,0x8101e000,0x0c240071,0x13e4080f,0x000000a0,0x03889f20,
-       0x40780002,0x02003810,0x20408100,0x00041001,0xc0810204,0x080000c2,0x400e0408,0x10204000,
-       0x000a0070,0x20408102,0x000000e1,0x21c44891,0x22380000,0xa2801732,0x44891220,0x00080800,
-       0x71122448,0x8e000020,0x80038891,0x22447000,0x0309001c,0x44891223,0x80000a28,0x00e22448,
-       0x911c0000,0x01400711,0x224488e0,0x00000000,0x2003f000,0x04000000,0x0001e4ca,0x99327800,
-       0x01010011,0x22448933,0xa0000410,0x00891224,0x499d0000,0x61200448,0x91224ce8,0x00000500,
-       0x22448912,0x67400004,0x10020a24,0x450a0831,0xc002040b,0x19224489,0xe204000a,0x00828911,
-       0x42820c70};
-
-    // Return a 'stringification' of standart integral types.
-    const char* const bool_st    = "bool";
-    const char* const uchar_st   = "unsigned char";
-    const char* const char_st    = "char";
-    const char* const ushort_st  = "unsigned short";
-    const char* const short_st   = "short";
-    const char* const uint_st    = "unsigned int";
-    const char* const int_st     = "int";
-    const char* const ulong_st   = "unsigned long";
-    const char* const long_st    = "long";
-    const char* const float_st   = "float";
-    const char* const double_st  = "double";
-    const char* const unknown_st = "unknown";
-    template<typename t> inline const char* get_type(const t&) { return unknown_st; }
-    inline const char* get_type(const bool&          ) { return bool_st;   }
-    inline const char* get_type(const unsigned char& ) { return uchar_st;  }
-    inline const char* get_type(const char&          ) { return char_st;   }
-    inline const char* get_type(const unsigned short&) { return ushort_st; }
-    inline const char* get_type(const short&         ) { return short_st;  }
-    inline const char* get_type(const unsigned int&  ) { return uint_st;   }
-    inline const char* get_type(const int&           ) { return int_st;    }
-    inline const char* get_type(const unsigned long& ) { return ulong_st;  }
-    inline const char* get_type(const long&          ) { return long_st;   }
-    inline const char* get_type(const float&         ) { return float_st;  }
-    inline const char* get_type(const double&        ) { return double_st; }
-    
-    // Display a warning message
-#if cimg_debug>=1    
-    static void warn(const bool cond,const char *format,...) {
-      if (cond) {
-        va_list ap;
-        va_start(ap,format);
-        std::fprintf(stderr,"<CImg Warning> ");
-        std::vfprintf(stderr,format,ap);
-        std::fputc('\n',stderr);
-        va_end(ap);
-      }
-    }
-#else
-    inline void warn(const bool cond,const char *format,...) {}
-#endif
-
-    inline int xln(const int x) { return x>0?(int)(1+std::log10((double)x)):1; }
-    inline char uncase(const char x) { return (char)((x<'A'||x>'Z')?x:x-'A'+'a'); }
-    inline float atof(const char *str) {
-      float x=0,y=1;
-      if (!str) return 0; else { std::sscanf(str,"%g/%g",&x,&y); return x/y; }
-    }
-    inline int strlen(const char *s) { if (s) { int k; for (k=0; s[k]; k++) ; return k; } return -1; }
-    inline int strncmp(const char *s1,const char *s2,const int l) {
-      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=abs(s1[k] - s2[k]); return n; }
-      return 0;
-    }
-    inline int strncasecmp(const char *s1,const char *s2,const int l) {
-      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=abs(uncase(s1[k])-uncase(s2[k])); return n; }
-      return 0;
-    }
-    inline int strcmp(const char *s1,const char *s2)     { 
-      const int l1 = strlen(s1), l2 = strlen(s2);
-      return strncmp(s1,s2,1+(l1<l2?l1:l2));
-    }
-    inline int strcasecmp(const char *s1,const char *s2) { 
-      const int l1 = strlen(s1), l2 = strlen(s2);
-      return strncasecmp(s1,s2,1+(l1<l2?l1:l2));
-    }
-    inline int strfind(const char *s,const char c) {
-      if (s) { 
-        int l; for (l=strlen(s); l>=0 && s[l]!=c; l--) ;
-        return l; 
-      }
-      return -1; 
-    }
-    inline const char* basename(const char *s)  {
-      return (cimg_OS!=2)?(s?s+1+strfind(s,'/'):NULL):(s?s+1+strfind(s,'\\'):NULL); 
-    }
-
-    inline void system(const char *command) {
-#if cimg_OS==2
-      PROCESS_INFORMATION pi;
-      STARTUPINFO si;
-      GetStartupInfo(&si);
-      si.wShowWindow = SW_HIDE;
-      si.dwFlags |= SW_HIDE;
-      BOOL res = CreateProcess(NULL,(LPTSTR)command,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi);
-      if (res) {
-        WaitForSingleObject(pi.hProcess, INFINITE);
-        CloseHandle(pi.hThread);
-        CloseHandle(pi.hProcess);
-      }
-#else
-      ::system(command);
-#endif
-    }
-    
-    //! Return the path of the ImageMagick <tt>convert</tt> tool.
-    /**
-       If you have installed the <a href="http://www.imagemagick.org">ImageMagick package</a>
-       in a standart directory, this function returns the correct path of the \c convert tool
-       used to load and save compressed image formats.
-       Conversely, if the \c convert executable is not auto-detected by the function,
-       you can define the macro \c cimg_convert_path with the correct path
-       of the \c convert executable, before including <tt>"CImg.h"</tt> in your program :
-       \code
-       #define cimg_convert_path "/users/thatsme/local/bin/convert"
-       #include "CImg.h"
-       
-       int main() {
-         CImg<> img("my_image.jpg");
-	 return 0;
-       }
-       \endcode
-       \note \c convert is needed to read and write compressed image formats. Other formats do not need \c convert.
-       \see temporary_path, CImg::load_convert, CImg::save_convert.
-    **/
-    inline const char* convert_path() {
-      static char *convert_path = NULL;
-      if (!convert_path) {
-#if cimg_OS==2 || defined(cimg_convert_path)
-        bool stopflag = false;
-        std::FILE *file;
-#endif
-        convert_path = new char[1024];
-#ifdef cimg_convert_path
-        std::strcpy(convert_path,cimg_convert_path);
-        if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
-#endif
-#if cimg_OS==2
-        for (unsigned int k=0; k<=9 && !stopflag; k++) {
-          std::sprintf(convert_path,"C:\\PROGRA~1\\IMAGEM~1.%u-Q\\convert.exe",k);
-          if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
-        }
-        if (!stopflag) for (unsigned int k=0; k<=9 && !stopflag; k++) {
-          std::sprintf(convert_path,"C:\\PROGRA~1\\IMAGEM~1.%u\\convert.exe",k);
-          if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
-        }
-        if (!stopflag) std::strcpy(convert_path,"convert.exe");
-#else
-        std::strcpy(convert_path,"convert");
-#endif
-      }
-      return convert_path;
-    }
-    
-    //! Return a path to store temporary files.
-    /**
-       If you are running on a standart Unix or Windows system, this function should return a correct path
-       where temporary files can be stored.
-       If the path is not auto-detected, you need to define the macro \c cimg_temporary_path,
-       before including <tt>"CImg.h"</tt> in your program :
-       \code
-       #define cimg_temporary_path "/users/toto/tmp"
-       #include "CImg.h"
-
-       int main() {
-         CImg<> img("my_image.jpg");
-	 return 0;
-       }
-       \endcode
-       \note A temporary path is necessary to load and save compressed image formats, using \c convert.
-       \see convert_path, CImg::load_convert, CImg::save_convert.
-    **/
-    inline const char* temporary_path() {
-      static char *temporary_path = NULL;
-      if (!temporary_path) {
-        temporary_path = new char[1024];
-#ifdef cimg_temporary_path
-        std::strcpy(temporary_path,cimg_temporary_path);
-        const char* testing_path[7] = { temporary_path, "/tmp","C:\\WINNT\\Temp", "C:\\WINDOWS\\Temp","","C:",NULL };
-#else
-        const char* testing_path[6] = { "/tmp","C:\\WINNT\\Temp", "C:\\WINDOWS\\Temp","","C:",NULL };
-#endif
-        char filetmp[1024];
-        std::FILE *file=NULL;
-        int i=-1;
-        while (!file && testing_path[++i]) {
-          std::sprintf(filetmp,"%s/CImg%.4d.ppm",testing_path[i],std::rand()%10000);
-          if ((file=std::fopen(filetmp,"w"))!=NULL) { std::fclose(file); std::remove(filetmp); }
-        }
-        if (!file) 
-	  throw CImgIOException("cimg::temporary_path() : Unable to find a temporary path accessible for writing\n"
-				"you have to set the macro 'cimg_temporary_path' to a valid path where you have writing access :\n"
-				"#define cimg_temporary_path \"path\" (before including 'CImg.h')");
-        std::strcpy(temporary_path,testing_path[i]);
-      }
-      return temporary_path;
-    }
-    
-    inline const char *filename_split(const char *const filename, char *const body=NULL) {
-      if (!filename) throw CImgArgumentException("cimg::filename_split() : Can't split the (null) filename");
-      int l=strfind(filename,'.');
-      if (l>=0) { if (body) { std::strncpy(body,filename,l); body[l]='\0'; }}
-      else { if (body) std::strcpy(body,filename); l=(int)std::strlen(filename)-1; }
-      return filename+l+1;
-    }
-    
-    inline char* file_number(const char *filename,const int number,const unsigned int n,char *const string) {
-      char format[1024],body[1024];
-      const char *ext = filename_split(filename,body);
-      if (n>0) std::sprintf(format,"%s_%%.%ud.%s",body,n,ext);
-      else std::sprintf(format,"%s_%%d.%s",body,ext);
-      std::sprintf(string,format,number);
-      return string;
-    }
-    inline std::FILE *fopen(const char *const path,const char *const mode) {
-      if(!path || !mode) throw CImgArgumentException("cimg::fopen() : Can't open file '%s' with mode '%s'",path,mode);
-      if (path[0]=='-') return (mode[0]=='r')?stdin:stdout; else {
-        std::FILE *dest=std::fopen(path,mode);
-        if(!dest) throw CImgIOException("cimg::fopen() : File '%s' cannot be opened %s",
-                                        path,mode[0]=='r'?"for reading":(mode[0]=='w'?"for writing":""),path);
-        return dest;
-      }
-    }
-    inline int fclose(std::FILE *file) {
-      warn(!file,"cimg::fclose() : Can't close (null) file");
-      if (!file || file==stdin || file==stdout) return 0;
-      const int errn=std::fclose(file);
-      warn(errn!=0,"cimg::fclose() : Error %d during file closing",errn);
-      return errn;
-    }
-    template<typename T> inline int fread(T *ptr,const unsigned int size,const unsigned int nmemb,std::FILE *stream) {
-      if (!ptr || size<=0 || nmemb<=0 || !stream)
-        throw CImgArgumentException("cimg::fread() : Can't read %u x %u bytes of file pointer '%p' in buffer '%p'",
-				    nmemb,size,stream,ptr);
-      const unsigned int errn = (unsigned int)std::fread((void*)ptr,size,nmemb,stream);
-      warn(errn!=nmemb,"cimg::fread() : File reading problems, only %u/%u elements read",errn,nmemb);
-      return errn;
-    }
-    inline int fwrite(const void *ptr,const unsigned int size,const unsigned int nmemb,std::FILE *stream) {
-      if (!ptr || size<=0 || nmemb<=0 || !stream)
-        throw CImgArgumentException("cimg::fwrite() : Can't write %u x %u bytes of file pointer '%p' from buffer '%p'",
-				    nmemb,size,stream,ptr);
-      const unsigned int errn = (unsigned int)std::fwrite(ptr,size,nmemb,stream);
-      if(errn!=nmemb)
-        throw CImgIOException("cimg::fwrite() : File writing problems, only %u/%u elements written",errn,nmemb);
-      return errn;
-    }
-    
-    // Exchange the values of variables \p a and \p b
-    template<typename T> inline void swap(T& a,T& b) { T t=a; a=b; b=t; }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2) { swap(a1,b1); swap(a2,b2); }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3) { swap(a1,b1,a2,b2); swap(a3,b3); }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4) { swap(a1,b1,a2,b2,a3,b3); swap(a4,b4); }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4,T& a5,T& b5) {
-      swap(a1,b1,a2,b2,a3,b3,a4,b4); swap(a5,b5); 
-    }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4,T& a5,T& b5,T& a6,T& b6) {
-      swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5); swap(a6,b6);
-    }
-    
-    template<typename T> inline T& endian_swap(T& a) {  
-      if (sizeof(a)!=1) {
-	unsigned char *pb=(unsigned char*)&a, *pe=pb+sizeof(a);
-	for (int i=0; i<(int)sizeof(a)/2; i++) swap(*(pb++),*(--pe));
-      }
-      return a;
-    }
-
-    template<typename T> inline void endian_swap(T *const buffer,const unsigned int size) {
-      T *ptr = buffer;
-      for (unsigned int i=0; i<size; i++) endian_swap(*(ptr++));
-    }
-
-    inline const char* option(const char *const name,const unsigned int argc,char **argv,const char *const defaut,
-                              const char *const usage=NULL) {
-      static bool first=true, visu=false;
-      const char *res = NULL;
-      if (first) { first=false; visu = option("-h",argc,argv,(const char*)NULL)!=NULL; }
-      if (!name && visu) {
-        std::fprintf(stderr,"\n %s%s%s",t_red,basename(argv[0]),t_normal);
-        if (usage) std::fprintf(stderr," : %s",usage);
-        std::fprintf(stderr," (%s, %s)\n\n",__DATE__,__TIME__);
-      }
-      if (name) {
-        if (argc>0) {
-          unsigned int k=0,i;
-          while (k<argc && strcmp(argv[k],name)) k++;
-          i=k;
-          res=(k++==argc?defaut:(k==argc?argv[--k]:argv[k]));
-        } else res = defaut;
-        if (visu && usage) std::fprintf(stderr,"    %s%-8s%s = %-12s : %s%s%s\n",
-                                        t_bold,name,t_normal,res?res:"NULL",t_purple,usage,t_normal);
-      }
-      return res;
-    }
-    inline bool option(const char *const name,const unsigned int argc,char **argv,
-                       const bool defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const bool res = s?(strcasecmp(s,"false") && strcasecmp(s,"off") && strcasecmp(s,"0")):defaut;
-      option(name,0,NULL,res?"true":"false",usage);
-      return res;
-    }
-    inline int option(const char *const name,const unsigned int argc,char **argv,
-                      const int defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const int res = s?atoi(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%d",res);
-      option(name,0,NULL,tmp,usage);
-      return res;
-    }
-    inline char option(const char *const name,const unsigned int argc,char **argv,
-		       const char defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const char res = s?s[0]:defaut;
-      char tmp[8];
-      tmp[0] = res;
-      tmp[1] ='\0';
-      option(name,0,NULL,tmp,usage);
-      return res;
-    }
-    inline double option(const char *const name,const unsigned int argc,char **argv,
-                         const double defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const double res = s?atof(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%g",res);
-      option(name,0,NULL,tmp,usage);
-      return res;
-    }
-    
-    //! Return \c false for little endian CPUs, \c true for big endian CPUs.
-    inline const bool endian() { const int x=1; return ((unsigned char*)&x)[0]?false:true; }
-
-    //! Display informations about CImg compilation variables, on the standart error output \e stderr.
-    inline void info() {
-      std::fprintf(stderr,"\n %sCImg Library %g%s, compiled %s ( %s ) with the following flags :\n\n",
-                   t_red,cimg_version,t_normal,__DATE__,__TIME__);
-      std::fprintf(stderr,"  > Architecture   : %s%-12s%s %s(cimg_OS=%d)\n%s",
-                   t_bold,
-                   cimg_OS==0?"Solaris":(cimg_OS==1?"Linux":(cimg_OS==2?"Windows":(cimg_OS==3?"Mac OS X":(cimg_OS==4?"FreeBSD":"Unknown")))),
-                   t_normal,t_purple,cimg_OS,t_normal);
-      std::fprintf(stderr,"  > Display type   : %s%-12s%s %s(cimg_display_type=%d)%s\n",
-                   t_bold,cimg_display_type==0?"No":(cimg_display_type==1?"X11":(cimg_display_type==2?"WindowsGDI":"Unknown")),t_normal,t_purple,cimg_display_type,t_normal);
-#ifdef cimg_color_terminal
-      std::fprintf(stderr,"  > Color terminal : %s%-12s%s %s(cimg_color_terminal defined)%s\n",t_bold,"Yes",t_normal,t_purple,t_normal);
-#else
-      std::fprintf(stderr,"  > Color terminal : %-12s (cimg_color_terminal undefined)\n","No");
-#endif
-#ifdef cimg_lapack
-      std::fprintf(stderr,"  > Using LAPACK   : %s%-12s%s %s(cimg_lapack defined)%s\n",t_bold,"Yes",t_normal,t_purple,t_normal);
-#else
-      std::fprintf(stderr,"  > Using LAPACK   : %s%-12s%s %s(cimg_lapack undefined)%s\n",t_bold,"No",t_normal,t_purple,t_normal);
-#endif
-      std::fprintf(stderr,"  > Debug messages : %s%-12s%s %s(cimg_debug=%d)%s\n",t_bold,cimg_debug==2?"High":(cimg_debug==1?"Yes":"No"),
-                   t_normal,t_purple,cimg_debug,t_normal);
-      std::fprintf(stderr,"\n");
-    }
-    
-    //! Get the value of a system timer with a millisecond precision.
-    inline long int time() {
-#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3 || cimg_OS==4
-      struct timeval st_time;
-      gettimeofday(&st_time,NULL);
-      return (long int)(st_time.tv_usec/1000 + st_time.tv_sec*1000);
-#elif cimg_OS==2
-      static SYSTEMTIME st_time;
-      GetSystemTime(&st_time);
-      return (long int)(st_time.wMilliseconds + 1000*(st_time.wSecond + 60*(st_time.wMinute + 60*st_time.wHour)));
-#else 
-      return 0;
-#endif
-    }
-
-    //! Sleep for a certain numbers of milliseconds.
-    /**
-       This function frees the CPU ressources during the sleeping time.
-       May be used to temporize your program properly.
-       \see wait, time.
-    **/
-    inline void sleep(const int milliseconds) {
-#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3 || cimg_OS==4
-      struct timespec tv;
-      tv.tv_sec = milliseconds/1000;
-      tv.tv_nsec = (milliseconds%1000)*1000000;
-      nanosleep(&tv,NULL);
-#elif cimg_OS==2
-      Sleep(milliseconds);
-#endif
-    }
-    //! Wait for a certain number of milliseconds since the last call of \ref wait().
-    /**
-       If the desired delay has expired, this function returns immediately else it sleeps till the correct time.
-       May be used to temporize your program properly.
-       \see sleep, time.
-    **/
-    inline long int wait(const int milliseconds=20,long int reference_time=-1) {
-      static long int latest_time = time();
-      if (reference_time>=0) latest_time = reference_time;
-      const long int current_time = time(), time_diff = milliseconds + latest_time - current_time;
-      if (time_diff>0) { sleep(time_diff); return (latest_time = current_time + time_diff); }
-      else return (latest_time = current_time);
-    }
-    //! Bitwise rotation on the left
-    template<typename T> inline const T rol(const T& a,const unsigned int n=1) { return (a<<n)|(a>>((sizeof(T)<<3)-n)); }
-    //! Bitwise rotation on the right
-    template<typename T> inline const T ror(const T& a,const unsigned int n=1) { return (a>>n)|(a<<((sizeof(T)<<3)-n)); }
-
-#if ( !defined(_MSC_VER) || _MSC_VER>1200 )
-    //! Return the absolute value of \p a
-    template<typename T> inline const T abs(const T& a) { return a>=0?a:-a; }
-    //! Return the minimum between \p a and \p b.
-    template<typename T> inline const T& min(const T& a,const T& b) { return a<=b?a:b; }
-    //! Return the minimum between \p a,\p b and \a c.
-    template<typename T> inline const T& min(const T& a,const T& b,const T& c) { return min(min(a,b),c); }
-    //! Return the minimum between \p a,\p b,\p c and \p d.
-    template<typename T> inline const T& min(const T& a,const T& b,const T& c,const T& d) { return min(min(min(a,b),c),d); }
-    //! Return the maximum between \p a and \p b.
-    template<typename T> inline const T& max(const T& a,const T& b) { return a>=b?a:b; }
-    //! Return the maximum between \p a,\p b and \p c.
-    template<typename T> inline const T& max(const T& a,const T& b,const T& c) { return max(max(a,b),c); }
-    //! Return the maximum between \p a,\p b,\p c and \p d.
-    template<typename T> inline const T& max(const T& a,const T& b,const T& c,const T& d) { return max(max(a,b,c),d); }
-    //! Return the sign of \p x.
-    template<typename T> inline char sign(const T& x) { return (x<0)?-1:(x==0?0:1); }
-#else
-    // Special versions due to object reference bug in VisualC++ 6.0.
-    template<typename T> inline const T abs(const T a) { return a>=0?a:-a; }
-    template<typename T> inline const T min(const T a,const T b) { return a<=b?a:b; }
-    template<typename T> inline const T min(const T a,const T b,const T c) { return min(min(a,b),c); }
-    template<typename T> inline const T min(const T a,const T b,const T c,const T& d) { return min(min(min(a,b),c),d); }
-    template<typename T> inline const T max(const T a,const T b) { return a>=b?a:b; }
-    template<typename T> inline const T max(const T a,const T b,const T c) { return max(max(a,b),c); }
-    template<typename T> inline const T max(const T a,const T b,const T c,const T& d) { return max(max(max(a,b),c),d); }
-    template<typename T> inline char sign(const T x) { return (x<0)?-1:(x==0?0:1); }
-#endif
-
-    //! Return \p x modulo \p m (generic modulo).
-    /**
-       This modulo function accepts negative and floating-points modulo numbers \p m.
-    **/
-    inline double mod(const double& x,const double& m) { return x-m*std::floor(x/m); }
-	inline float  mod(const float& x,const float& m)   { return (float)(x-m*std::floor((double)x/m)); }
-    inline int    mod(const int x,const int m)         { return x>=0?x%m:(x%m?m+x%m:0); }
-
-    //! Return minmod(\p a,\p b).
-    /**
-       The operator minmod(\p a,\p b) is defined to be :
-       - minmod(\p a,\p b) = min(\p a,\p b), if (\p a * \p b)>0.
-       - minmod(\p a,\p b) = 0,              if (\p a * \p b)<=0
-    **/
-    template<typename T> inline T minmod(const T& a,const T& b) { return a*b<=0?0:(a>0?(a<b?a:b):(a<b?b:a)); }
-    //! Return a random variable between [0,1] (uniform distribution).
-    inline double rand() { return (double)std::rand()/RAND_MAX; }
-    //! Return a random variable between [-1,1] (uniform distribution).
-    inline double crand() { return 1-2*rand(); }
-    //! Return a random variable using a gaussian distribution and a variance of 1.
-    inline double grand() { return std::sqrt(-2*std::log((double)(1e-10 + (1-2e-10)*rand())))*std::cos((double)(2*PI*rand())); }
-  }
-
-  /*-------------------------------------------------------
-    
-  
-  
-  
-    Definition of the CImgStats structure
-  
-  
-  
-    
-    ------------------------------------------------------*/
-  //! This class is used to compute basics statistics of a <tt>CImg<T></tt> image.
-  /** 
-      Constructing a CImgStats instance by passing an image CImg<T> or an image list CImgl<T> as a parameter,
-      will compute the minimum, the maximum and the average pixel values of the given object, and optionally
-      the variance of the pixel values. Use it to retrieve basic statistics of an image, or an image list,
-      like this :
-      \code 
-      const CImg<float> img("my_image.jpg");
-      const CImgStats stats(img);
-      stats.print("My statistics");
-      std::printf("Max-Min = %lf",stats.max-stats.min);
-      \endcode
-      Note that statistics are computed for all scalar values of a CImg<T> or a CImgl<T>. No vector-valued
-      statistics are performed.
-  **/
-  struct CImgStats {
-    double min;                 //!< Minimum of the pixel values after statistics computation.
-    double max;                 //!< Maximum of the pixel values after statistics computation.
-    double mean;                //!< Mean of the pixel values after statistics computation.
-    double variance;            //!< Variance of the pixel values after statistics computation.
-
-    //! Default constructor.
-    CImgStats():min(0),max(0),mean(0),variance(0) {}
-    //! Copy constructor.
-    CImgStats(const CImgStats& stats):min(stats.min),max(stats.max),mean(stats.mean),variance(stats.variance) {};
-
-    //! Constructor that compute statistics of an image \p img.
-    /** 
-        If \p compute_variance = true, the variance field of the CImgStats structure is computed, else it is set to 0.
-    **/
-    template<typename T> CImgStats(const CImg<T>& img,const bool compute_variance=true):mean(0),variance(0) {
-      cimg_test(img,"CImgStats::CImgStats");
-      T pmin=img[0], pmax=pmin;
-      cimg_map(img,ptr,T) { const T& a=*ptr; mean+=(double)a; if (a<pmin) pmin=a; if (a>pmax) pmax=a; }
-      mean/=img.size();
-      min=(double)pmin;
-      max=(double)pmax;
-      if (compute_variance) {
-        cimg_map(img,ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
-        variance = std::sqrt(variance/img.size());
-      }
-    }
-    //! Constructor that compute statistics of an image list \p list.
-    /**
-       Statistics are computed for all pixels of all images of the list.
-       If \p compute_variance = true, the variance field of the CImgStats structure is computed, else it is undefined.
-    **/
-    template<typename T> CImgStats(const CImgl<T>& list,const bool compute_variance=true):mean(0),variance(0) {
-      cimgl_test(list,"CImgStats::CImgStats");
-      T pmin=list[0][0], pmax=pmin;
-      int psize=0;
-      cimgl_map(list,l) {
-        cimg_map(list[l],ptr,T) {
-          const T& a=*ptr;
-          mean+=(double)a;
-          if (a<pmin) pmin=a;
-          if (a>pmax) pmax=a;
-        }
-        psize+=list[l].size();
-      }
-      mean/=psize;
-      min=(double)pmin;
-      max=(double)pmax;
-      if (compute_variance) {
-        cimgl_map(list,l) cimg_map(list[l],ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
-        variance = std::sqrt(variance/psize);
-      }
-    }
-    //! Assignement operator.
-    CImgStats& operator=(const CImgStats stats) {
-      min = stats.min;
-      max = stats.max;
-      mean = stats.mean;
-      variance = stats.variance;
-      return *this;
-    }
-    //! Print the current statistics on the standart error output.
-    const CImgStats& print(const char* title=NULL) const {
-      std::fprintf(stderr,"%-8s = { %g, %g [%g], %g }\n",title?title:"CImgStats",min,mean,variance,max);
-      return *this;
-    }
-
-#ifdef cimgstats_plugin
-#include cimgstats_plugin
-#endif
-
-  };
-
-  /*-------------------------------------------------------
-  
-
-
-
-    Definition of the CImgDisplay structure
-
-
-
-
-  ------------------------------------------------------*/
-  //! This class is used to create a display window, draw images into it and handle mouse and keyboard events.
-  /**
-     Creating a \c CImgDisplay instance opens a window that can be used to display a \c CImg<T> image
-     of a \c CImgl<T> image list inside. When a display is created, associated window events
-     (such as mouse motion, keyboard and window size changes) are handled and can be easily
-     detected by testing specific \c CImgDisplay data fields.
-     See \ref cimg_displays for a complete tutorial on using the \c CImgDisplay class.
-  **/
-
-  struct CImgDisplay {
-
-    //------------------------
-    //
-    // CImgDisplay variables
-    //
-    //------------------------
-
-    //! Variable representing the width of the display.
-    /**
-       Prefer using CImgDisplay::dimx() to get the width of the display.
-       
-       \note Using CImgDisplay::dimx() instead of \p width is more safe when doing arithmetics
-       involving the value of \p width, since it returns a \e signed int. Arithmetics with
-       \e unsigned types needs a lot of attention.
-
-       \note The variable \c width should be considered as read-only.
-       Setting a new value for \p CImgDisplay::width is done through CImgDisplay::resize().
-       Modifying directly \p width would probably result in a crash.
-
-       \see CImgDisplay::height, CImgDisplay::resize()
-    **/
-    unsigned int width;
-
-    //! Variable representing the height of the display.
-    /**
-       Prefer using CImgDisplay::dimy() to get the height of the display.
- 
-       \note Using CImgDisplay::dimy() instead of \p height is more safe when doing arithmetics
-       involving the value of \p height, since it returns a \e signed int. Artihmetics with
-       \e unsigned types needs a lot of attention.
-
-       \note The variable \c height should be considered as read-only.
-       Setting a new value for \p CImgDisplay::height is done through CImgDisplay::resize().
-       Modifying directly \p height would probably result in a crash.
-       
-       \see CImgDisplay::width, CImgDisplay::resize()
-    **/
-    unsigned int height;
-
-    //! Variable representing the width of the window associated to
-    //! the current display (should be considered as read-only)
-    /**
-       \note This is not the width of the display, but the width of the underlying system window.
-       This variable is updated when an user resized the window associated to the display.
-       When it occurs, \c width and \c window_width will be probably different.       
-       \see CImgDisplay::window_height, CImgDisplay::resized, CImgDisplay::resize().
-    **/
-    volatile unsigned int window_width;
-
-    //! Variable representing the height of the window associated to
-    //! the current display (should be considered as read-only)
-    /**
-       \note This is not the height of the display, but the height of the underlying system window.
-       This variable is updated when an user resized the window associated to the display.
-       When it occurs, \c height and \c window_height will be probably different.
-       \see CImgDisplay::window_width, CImgDisplay::resized, CImgDisplay::resize().
-    **/
-    volatile unsigned int window_height;
-
-    //! Variable defining the pixel normalization behavior of the display window (can be modified on the fly).
-    /**
-       It represents the way the pixel values are normalized for display purposes.
-       Its value can be set to :
-       - \c 0 : No pixel value normalization are performed (fastest). Be sure your image data are bounded in [0,255].
-       - \c 1 : Pixel value renormalization between [0,255] is done at each display request (default).
-       - \c 2 : Pixel value renormalization between [0,255] is done at the first display request. Then the
-       normalization parameters are kept and used for the next image display requests.
-       \note \c normalization is preferably set by invoking constructors CImgDisplay::CImgDisplay().
-       \see CImgDisplay::CImgDisplay(), CImgDisplay::display().
-    **/
-    unsigned int normalization;
-
-    //! Variable representing the type of events handled by the display window (should be considered as read-only).
-    /**
-       It represents what events are handled by the display. Its value can be set to :
-       - \c 0 : No events are handled by the display.
-       - \c 1 : Display closing and resizing are handled by the display.
-       - \c 2 : Display closing, resizing, mouse motion and buttons press, as well as key press are handled by the display.
-       - \c 3 : Display closing, resizing, mouse motion and buttons press/release, as well as key press/release
-       are handled by the display.
-       \note \c events if preferably set by invoking constructors CImgDisplay::CImgDisplay().
-       \see CImgDisplay::CImgDisplay(), CImgDisplay::mousex, CImgDisplay::mousey, CImgDisplay::key,
-       CImgDisplay::button, CImgDisplay::resized, CImgDisplay::closed.
-    **/
-    unsigned int events;
-
-    //! Variable indicating if the display is fullscreen (should be considered as read-only).
-    /**
-       If the display has been specified to be fullscreen at the construction, this variable is set to \c true.
-       \note This is only useful for Windows-based OS. Fullscreen is not yet supported on X11-based systems
-       and \c fullscreen will always be equal to \e false in this case.
-    **/
-    const bool fullscreen;
-
-    //! Variable representing the current x-coordinate of the mouse pointer over the display window
-    //! (should be considered as read-only).
-    /**
-       If CImgDisplay::events>=2, \p mousex represents the current x-coordinate of the mouse pointer.
-       - If the mouse pointer is outside the display window, \p mousex is equal to \p -1.
-       - If the mouse pointer is over the display window, \p mousex falls in the range [0,CImgDisplay::width-1],
-       where \p 0 corresponds to the far left coordinate and \p CImgDisplay::width-1 to the far right coordinate.
-       \note \p mousex is updated every 25 milliseconds, through an internal thread.
-       \see CImgDisplay::mousey, CImgDisplay::button
-    **/
-    volatile int mousex;
-
-    //! Variable representing the current y-coordinate of the mouse pointer over the display window.
-    //! (should be considered as read only).
-    /**
-       If CImgDisplay::events>=2, \p mousey represents the current y-coordinate of the mouse pointer.
-       - If the mouse pointer is outside the display window, \p mousey is equal to \p -1.
-       - If the mouse pointer is over the display window, \p mousey falls in the range [0,CImgDisplay::height-1],
-       where \p 0 corresponds to the far top coordinate and \p CImgDisplay::height-1 to the far bottom coordinate.
-       \note \p mousey is updated every 25 milliseconds, through an internal thread.
-       \see CImgDisplay::mousex, CImgDisplay::button
-    **/
-    volatile int mousey;
-
-    //! Variable representing the state of the mouse buttons when the mouse pointer is over the display window.
-    //! (should be considered as read only)
-    /**
-       If CImgDisplay::events>=2, \c button represents the current state of the mouse buttons.
-       - If the mouse pointer is outside the display window, \c button is equal to \c 0.
-       - If the mouse pointer is over the display window, \c button is a combination of the following bits :
-       - bit 0 : State of the left mouse button.
-       - bit 1 : State of the right mouse button.
-       - bit 2 : State of the middle mouse button.
-       - Other bits are unused.
-       \note
-       - \c button is updated every 25 milliseconds, through an internal thread.
-       - If CImgDisplay::events==2, you should re-init \p button to \p 0 after catching the
-       mouse button events, since it will NOT be done automatically (\p Mouse \p button \p Release event is
-       not handled in this case).
-       \see CImgDisplay::mousex, CImgDisplay::mousey
-    **/
-    volatile unsigned int button;
-
-    //! Variable representing the key pressed when mouse pointer is over the display window.
-    /**
-       If CImgDisplay::events>=2, \c key represents a raw integer value corresponding 
-       to the current pressed key.
-       - If no keys are pressed, \c key is equal to \p 0.
-       - If a key is pressed, \p key is a value representing the key. This raw value is \e OS-dependent.
-       Testing the \p key value directly with a raw integer will mostly result in incompabilities
-       between different plateforms. 
-       To bypass this problem, \b OS-independent \b keycodes are defined in the \p cimg:: namespace.
-       They are named as \p cimg::key*, where * stands for the key name :
-       \p cimg::keyESC, \p cimg::keyF1, \p cimg::key0, \p cimg::keyA, \p cimg::keySPACE, \p cimg::keySHIFTLEFT, etc...
-       \code
-       CImgDisplay disp(320,200,"Display");        // Create a display window with full events handling
-       ...
-       if (disp.key==cimg::keyESC) exit(0);        // Exit when pressing the ESC key.
-       ...
-       \endcode
-
-       \note 
-       - \p key is updated every 25 milliseconds, through an internal thread.
-       - If CImgDisplay::events==2, You should re-init the \c key variable to \c 0 after catching
-       the \p Key \p Pressed event, since it will NOT be done automatically (Key Release event is handled
-       only when \c CImgDisplay::events>=3).
- 
-       \see CImgDisplay::button, CImgDisplay::mousex, CImgDisplay::mousey
-    **/
-    volatile unsigned int key;
-
-    //! Variable representing the visibility state of the display window (should be read only).
-    /**
-       \p closed can be either true or false :
-       - \p false : The window is visible.
-       - \p true  : The window is hidden.
-     
-       If CImgDisplay::events>=1, \p closed is set to \p true when the user try to close the display window.
-       The way to set a value for \p closed is to use the functions :
-       - CImgDisplay::show(), to set \p closed to \p false.
-       - CImgDisplay::close(), to set \p closed to \p true.
-
-       Closing a display window DO NOT destroy the instance object. It simply \e hides the display window
-       and set the variable \p closed to true. You are then free to decide what to do
-       when this event occurs. For instance, the following code will re-open the window indefinitely 
-       when the user tries to close it :
-       \code
-       CImgDisplay disp(320,200,"Try to close me !");
-       for (;; disp.wait()) if (disp.closed) disp.show();
-       \endcode
-
-       \note - \p closed is updated every 25 milliseconds, through an internal thread.
-
-       \see CImgDisplay::show(), CImgDisplay::close().
-    **/
-    volatile bool closed;
-
-    //! Event-variable
-    volatile bool resized;
-
-    // Not documented, internal use only.
-    double min,max;
-
-    //------------------------
-    //
-    // CImgDisplay functions
-    //
-    //------------------------
-
-    //! Return the width of the display window, as a signed integer.
-    /** \note When working with resizing window, \p dimx() does not necessarily return the width of the resized window,
-        but the width of the internal data structure that can be used to display image.
-        Resizing a display window can be done with the function CImgDisplay::resize().
-      
-        \see CImgDisplay::width, CImgDisplay::dimy(), CImgDisplay::resize()     
-    **/
-    const int dimx() const { return (int)width; }
-
-    //! Return the height of the display window, as a signed integer.
-    /** \note When working with resizing window, \p dimy() does not necessarily return the height of the resized window,
-        but the height of the internal data structure that can be used to display image.
-        Resizing a display window can be done with the function CImgDisplay::resize().
-      
-        \see CImgDisplay::height, CImgDisplay::dimx(), CImgDisplay::resize()     
-    **/
-    const int dimy() const { return (int)height; }
-
-    // operator=(). It is actually defined to avoid its use, and throw a CImgDisplay exception.
-    CImgDisplay& operator=(const CImgDisplay&) {
-      throw CImgDisplayException("CImgDisplay()::operator=() : Assignement of CImgDisplay is not allowed. Use pointers instead !");
-      return *this;
-    }
-    
-    //! Synchronized waiting function. Same as cimg::wait().
-    /** \see cimg::wait()
-     **/
-      const CImgDisplay& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this; }
-
-    //! Display an image list CImgl<T> into a display window.
-    /** First, all images of the list are appended into a single image used for visualization,
-        then this image is displayed in the current display window.
-        \param list     : The list of images to display.
-        \param axe      : The axe used to append the image for visualization. Can be 'x' (default),'y','z' or 'v'.
-        \param align : Defines the relative alignment of images when displaying images of different sizes.
-        Can be '\p c' (centered, which is the default), '\p p' (top alignment) and '\p n' (bottom aligment).
-
-        \see CImg::append()
-    **/
-    template<typename T> CImgDisplay& display(const CImgl<T>& list,const char axe='x',const char align='c') { 
-      return display(list.get_append(axe,align)); 
-    } 
-
-    //! Resize a display window with the size of an image.
-    /** \param img    : Input image. \p image.width and \p image.height give the new dimensions of the display window.
-        \param redraw : If \p true (default), the current displayed image in the display window will
-        be bloc-interpolated to fit the new dimensions. If \p false, a black image will be drawn in the resized window.
-        \param force  : If \p true, the window size is effectively set to the specified dimensions (default).
-        If \p false, only internal data buffer to display images is resized, not the window itself.
-      
-        \see CImgDisplay::resized, CImgDisplay::resizedimx(), CImgDisplay::resizedimy()
-    **/
-    template<typename T> CImgDisplay& resize(const CImg<T>& img,const bool redraw=false,const bool force=true) { 
-      return resize(img.width,img.height,redraw,force); 
-    }
-
-    CImgDisplay& resize(const CImgDisplay& disp,const bool redraw=false,const bool force=true) {
-      return resize(disp.width,disp.height,redraw,force);
-    }
-
-    CImgDisplay& resize(const bool redraw=false,const bool force=false) {
-      resize(window_width,window_height,redraw,force);
-      return *this;
-    }
-
-    // When no display available
-    //---------------------------
-#if cimg_display_type==0
-    void nodisplay_available() {
-      static bool first = true;
-      if (first) {
-        cimg::warn(true,"CImgDisplay() : Display has been required but is not available (cimg_display_type=0)");
-        first = false;
-      }    
-    }  
-    //! Create a display window with a specified size \p pwidth x \p height.
-    /** \param width      : Width of the display window.
-        \param height     : Height of the display window.
-        \param title      : Title of the display window.
-        \param normalization_type  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param attributes : Attributes of the display window (see CImgDisplay::attributes).
-      
-        A black image will be initially displayed in the display window.
-    **/
-    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
-      nodisplay_available(); 
-    }
-
-    //! Create a display window from an image.
-    /** \param img        : Image that will be used to create the display window.
-        \param title      : Title of the display window
-        \param normalize  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param attributes : Attributes of the display window (see CImgDisplay::attributes).    
-    **/
-    template<typename T> 
-    CImgDisplay(const CImg<T>& img,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
-      nodisplay_available(); 
-    }
-
-    //! Create a display window from an image list.
-    /** \param list       : The list of images to display.
-        \param title      : Title of the display window
-        \param normalize  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param attributes : Attributes of the display window (see CImgDisplay::attributes).     
-    **/
-    template<typename T> 
-    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
-      nodisplay_available(); 
-    }
-  
-    //! Create a display window by copying another one.
-    /** \param win   : Display window to copy.
-        \param title : Title of the new display window.
-    **/
-    CImgDisplay(const CImgDisplay& win, char *title=NULL):fullscreen(false) { nodisplay_available(); }
-
-    //! Resize a display window with new dimensions \p width and \p height.
-    CImgDisplay& resize(const int width, const int height,const bool redraw=false,const bool force=true) {
-      return *this; 
-    }
-    //! Destructor. Close and destroy a display.
-    ~CImgDisplay() {}
-    //! Fill the pixel data of the window buffer according to the image \p pimg.
-    template<typename T> void render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {}
-    //! Display an image in a window.
-    template<typename T> CImgDisplay& display(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=-1) { return *this; }
-    //! Wait for a window event
-    CImgDisplay& wait()  { return *this; }
-    //! Show a closed display
-    CImgDisplay& show()  { return *this; }
-    //! Close a visible display
-    CImgDisplay& close() { return *this; }
-  
-    // X11-based display
-    //------------------
-#elif cimg_display_type==1
-    unsigned long *data;
-    XImage *image;
-    Window window;
-  
-    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      width(dimw),height(dimh),window_width(dimw),window_height(dimh),
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      new_lowlevel(title);
-      std::memset(data,0,sizeof(unsigned long)*width*height);
-      pthread_mutex_lock(cimg::X11_mutex);
-      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-      XFlush(cimg::X11_display);
-      pthread_mutex_unlock(cimg::X11_mutex);
-    }
-
-    template<typename T> 
-    CImgDisplay(const CImg<T>& img,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimg_test(img,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_3dplanes(img.width/2,img.height/2,img.depth/2));
-      window_width  = width  = nimg.width;
-      window_height = height = nimg.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(nimg);
-    }
-
-    template<typename T> 
-    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimgl_test(list,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T> img0 = list.get_append('x'), 
-        &img = (img0.depth==1)?img0:(tmp=img0.get_3dplanes(img0.width/2,img0.height/2,img0.depth/2));
-      window_width  = width  = img.width; 
-      window_height = height = img.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(img);
-    }
-
-    CImgDisplay(const CImgDisplay& win, char *title="[Copy]"):
-      width(win.width),height(win.height),window_width(width),window_height(height),
-      normalization(win.normalization),events(win.events),fullscreen(win.fullscreen),
-      mousex(-1),mousey(-1),button(0),key(0),closed(win.closed),resized(false),min(win.min),max(win.max) {
-      new_lowlevel(title);
-      std::memcpy(data,win.data,sizeof(unsigned long)*width*height);
-      pthread_mutex_lock(cimg::X11_mutex);
-      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-      XFlush(cimg::X11_display);
-      pthread_mutex_unlock(cimg::X11_mutex);
-    }
-
-    CImgDisplay& resize(const int nwidth, const int nheight,const bool redraw=false,const bool force=true) {
-      const unsigned int
-        dimx=nwidth>0?nwidth:-width*nwidth/100,
-        dimy=nheight>0?nheight:-height*nheight/100;
-      if (!dimx || !dimy) return *this;
-      pthread_mutex_lock(cimg::X11_mutex);
-      if (dimx!=width || dimy!=height) {
-        unsigned long *ndata = new unsigned long[dimx*dimy];
-        if (redraw)
-          for (unsigned int y=0; y<dimy; y++) for (unsigned int x=0; x<dimx; x++) ndata[x+y*dimx] = data[x*width/dimx + width*(y*height/dimy)];
-        else std::memset(ndata,0,sizeof(unsigned long)*dimx*dimy);
-        data = ndata;
-        XDestroyImage(image);
-        image = XCreateImage(cimg::X11_display,DefaultVisual(cimg::X11_display,DefaultScreen(cimg::X11_display)),
-                             cimg::X11_nb_bits,ZPixmap,0,(char*)data,dimx,dimy,8,0);
-      }
-      width  = dimx;
-      height = dimy;
-      if (force && (window_width!=width || window_height!=height)) {
-        XResizeWindow(cimg::X11_display,window,width,height);
-        window_width  = width;
-        window_height = height;
-      }
-      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-      XFlush(cimg::X11_display);
-      resized = false;
-      pthread_mutex_unlock(cimg::X11_mutex);
-      return *this;
-    }
-  
-    ~CImgDisplay() {
-      unsigned int i;
-      pthread_mutex_lock(cimg::X11_mutex);
-      for (i=0; i<cimg::X11_nb_wins && cimg::X11_wins[i]!=this; i++) i++;
-      for (; i<cimg::X11_nb_wins-1; i++) cimg::X11_wins[i]=cimg::X11_wins[i+1];
-      cimg::X11_nb_wins--;
-      XDestroyWindow(cimg::X11_display,window);
-      XDestroyImage(image);
-      if (!cimg::X11_nb_wins) {
-        pthread_cancel(*cimg::X11_event_thread);
-        pthread_join(*cimg::X11_event_thread,NULL);
-        XCloseDisplay(cimg::X11_display);
-        cimg::X11_display=NULL;
-        pthread_mutex_unlock(cimg::X11_mutex);
-        pthread_mutex_destroy(cimg::X11_mutex);
-        delete cimg::X11_event_thread;
-        delete cimg::X11_mutex;
-        delete cimg::X11_gc;
-      } else pthread_mutex_unlock(cimg::X11_mutex);
-    }
-  
-    void new_lowlevel(const char *title=NULL) {
-      cimg::warn(fullscreen,"CImgDisplay::new_lowlevel() : Fullscreen mode requested, but not supported on X11 Displays");
-      if (!cimg::X11_display) {
-        cimg::X11_nb_wins = 0;
-        cimg::X11_thread_finished = false;
-        cimg::X11_mutex = new pthread_mutex_t;
-        pthread_mutex_init(cimg::X11_mutex,NULL);
-        pthread_mutex_lock(cimg::X11_mutex);
-        cimg::X11_display = XOpenDisplay((getenv("DISPLAY") ? getenv("DISPLAY") : ":0.0"));
-        if (!cimg::X11_display) throw CImgDisplayException("CImgDisplay::new_lowlevel() : Can't open X11 display");
-        cimg::X11_nb_bits = DefaultDepth(cimg::X11_display, DefaultScreen(cimg::X11_display));
-        if (cimg::X11_nb_bits!=16 && cimg::X11_nb_bits!=24)
-          throw CImgDisplayException("CImgDisplay::new_lowlevel() : %u bits mode is not supported (only 16 and 24 bits are supported)",
-                                     cimg::X11_nb_bits);
-        cimg::X11_gc = new GC;
-        *cimg::X11_gc = DefaultGC(cimg::X11_display,DefaultScreen(cimg::X11_display));
-        Visual *visual = DefaultVisual(cimg::X11_display,0);
-	XVisualInfo vtemplate;
-	vtemplate.visualid = XVisualIDFromVisual(visual);
-	int nb_visuals;
-	XVisualInfo *vinfo = XGetVisualInfo(cimg::X11_display,VisualIDMask,&vtemplate,&nb_visuals);
-	if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11_colors_endian = true;
-        cimg::X11_event_thread = new pthread_t;
-        pthread_create(cimg::X11_event_thread,NULL,thread_lowlevel,NULL);
-      } else pthread_mutex_lock(cimg::X11_mutex);
-      window = XCreateSimpleWindow(cimg::X11_display,RootWindow(cimg::X11_display,DefaultScreen(cimg::X11_display)),0,0,width,height,2,0,0x0L);
-      data   = new unsigned long[width*height];
-      image  = XCreateImage(cimg::X11_display,DefaultVisual(cimg::X11_display,DefaultScreen(cimg::X11_display)),cimg::X11_nb_bits,ZPixmap,0,(char*)data,width,height,8,0);
-      XStoreName(cimg::X11_display,window,title?title:"");
-      if (!closed) {
-        XEvent event;
-        XSelectInput(cimg::X11_display,window,StructureNotifyMask);
-        XMapWindow(cimg::X11_display,window);
-        do XWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event); while (event.type!=MapNotify);
-      }
-      if (events) { 
-        Atom atom = XInternAtom(cimg::X11_display, "WM_DELETE_WINDOW", False); 
-        XSetWMProtocols(cimg::X11_display, window, &atom, 1); 
-      }
-      cimg::X11_wins[cimg::X11_nb_wins++]=this;
-      pthread_mutex_unlock(cimg::X11_mutex);
-    }
-  
-    void proc_lowlevel(XEvent *pevent) {
-      const unsigned int buttoncode[3] = { 1,4,2 };
-      XEvent event=*pevent;
-      switch (event.type) {
-      case ClientMessage:
-        XUnmapWindow(cimg::X11_display,window);
-        mousex=mousey=-1; 
-	button=key=0;
-	closed=true; 
-        break;
-     case ConfigureNotify: {
-        while (XCheckWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event));
-        const unsigned int nw = event.xconfigure.width, nh = event.xconfigure.height;
-        if (nw && nh && (nw!=window_width || nh!=window_height)) { 
-          window_width = nw; 
-          window_height = nh; 
-	  mousex = mousey = -1;
-	  //button = key=0;
-          XResizeWindow(cimg::X11_display,window,window_width,window_height);
-          resized = true;
-        }
-      } break;
-      case Expose:
-        while (XCheckWindowEvent(cimg::X11_display,window,ExposureMask,&event));
-        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-        break;
-      case ButtonPress:
-        while (XCheckWindowEvent(cimg::X11_display,window,ButtonPressMask,&event));
-        button |= buttoncode[event.xbutton.button-1];
-        break;
-      case ButtonRelease:
-        while (XCheckWindowEvent(cimg::X11_display,window,ButtonReleaseMask,&event));
-        button &= ~buttoncode[event.xbutton.button-1];
-        break;
-      case KeyPress: {
-        while (XCheckWindowEvent(cimg::X11_display,window,KeyPressMask,&event));
-	char tmp;
-	KeySym ksym;
-	XLookupString(&event.xkey,&tmp,1,&ksym,NULL);
-	key = (unsigned int)ksym;
-      }
-        break;
-      case KeyRelease:
-        while (XCheckWindowEvent(cimg::X11_display,window,KeyReleaseMask,&event));
-        key = 0;
-        break;
-      case LeaveNotify:
-        while (XCheckWindowEvent(cimg::X11_display,window,LeaveWindowMask,&event));
-        mousex = mousey =-1; 
-        break;
-      case MotionNotify:
-        while (XCheckWindowEvent(cimg::X11_display,window,PointerMotionMask,&event));
-        mousex = event.xmotion.x; 
-        mousey = event.xmotion.y;
-        if (mousex<0 || mousey<0 || mousex>=dimx() || mousey>=dimy()) mousex=mousey=-1; 
-        break;
-      }
-    }
-  
-    static void* thread_lowlevel(void *arg) {
-      XEvent event;
-      pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL);
-      for (;;) {
-        pthread_mutex_lock(cimg::X11_mutex);
-        for (unsigned int i=0; i<cimg::X11_nb_wins; i++) {
-          const unsigned int xevent_type = (cimg::X11_wins[i]->events)&3;
-          const unsigned int emask =
-            ((xevent_type>=1)?ExposureMask|StructureNotifyMask:0)|
-            ((xevent_type>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
-            ((xevent_type>=3)?ButtonReleaseMask|KeyReleaseMask:0);
-          XSelectInput(cimg::X11_display,cimg::X11_wins[i]->window,emask);
-        }
-        bool event_flag = XCheckTypedEvent(cimg::X11_display, ClientMessage, &event);
-        if (!event_flag) event_flag = XCheckMaskEvent(cimg::X11_display,
-                                                      ExposureMask|StructureNotifyMask|ButtonPressMask|
-                                                      KeyPressMask|PointerMotionMask|LeaveWindowMask|ButtonReleaseMask|
-                                                      KeyReleaseMask,&event);
-        if (event_flag) {
-          for (unsigned int i=0; i<cimg::X11_nb_wins; i++)
-            if (!cimg::X11_wins[i]->closed && event.xany.window==cimg::X11_wins[i]->window) cimg::X11_wins[i]->proc_lowlevel(&event);
-          cimg::X11_thread_finished = true;
-        }
-        pthread_mutex_unlock(cimg::X11_mutex);
-        cimg::wait(25);
-      }
-      return NULL;
-    }
-
-    template<typename T> XImage* render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {
-      cimg_test(img,"CImgDisplay::render");
-      if (img.depth!=1) return render(img.get_3dplanes(img.width/2,img.height/2,img.depth/2),0,~0);
-      if (img.width!=width || img.height!=height) return render(img.get_resize(width,height,1,-100,1),0,~0);
-      const bool by=(ymin<=ymax);
-      const unsigned int nymin = by?ymin:ymax, nymax = by?(ymax>=height?height-1:ymax):(ymin>=height?height-1:ymin), w=width;
-      const T 
-        *data1 = img.ptr(0,nymin,0,0),
-        *data2 = (img.dim>=2)?img.ptr(0,nymin,0,1):data1,
-        *data3 = (img.dim>=3)?img.ptr(0,nymin,0,2):data1;
-      if (cimg::X11_colors_endian) cimg::swap(data1,data3);
-      pthread_mutex_lock(cimg::X11_mutex);
-      XImage *ximg = image;
-      if (!normalization) {
-        switch (cimg::X11_nb_bits) {
-        case 16: 
-          for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            XPutPixel(ximg,x,y,(((unsigned char)*(data1++)>>3)<<11) | (((unsigned char)*(data2++)>>2)<<5) | ((unsigned char)*(data3++)>>3)); 
-          }
-          break;
-        case 24: 
-          for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            XPutPixel(ximg,x,y,((unsigned char)*(data1++)<<16)      | ((unsigned char)*(data2++)<<8)      | (unsigned char)*(data3++)     ); 
-          }
-          break;
-        };
-      } else {
-        if (normalization==1) { CImgStats st(img,false); min=st.min; max=st.max; }
-        const T nmin = (T)min, delta = (T)max-nmin, mm=delta?delta:(T)1;
-        switch (cimg::X11_nb_bits) {
-        case 16: for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            const unsigned char
-              val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
-              val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
-              val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
-            XPutPixel(ximg,x,y,((val1>>3)<<11) | ((val2>>2)<<5) | (val3>>3));
-          }
-          break;
-        case 24: for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            const unsigned char
-              val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
-              val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
-              val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
-            XPutPixel(ximg,x,y,(val1<<16) | (val2<<8) | val3);
-          }
-          break;
-        } 
-      }
-      pthread_mutex_unlock(cimg::X11_mutex);
-      return image;
-    }
-
-    template<typename T> CImgDisplay& display(const CImg<T>& pimg,const unsigned int pymin=0,const unsigned int pymax=~0) {
-      const unsigned int
-        ymin = pymin<pymax?pymin:pymax,
-        ymax = pymin<pymax?(pymax>=height?height-1:pymax):(pymin>=height?height-1:pymin);
-      render(pimg,ymin,ymax);
-      if (!closed) {      
-        pthread_mutex_lock(cimg::X11_mutex);
-        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,ymin,0,ymin,width,ymax-ymin+1);
-        XFlush(cimg::X11_display);
-        pthread_mutex_unlock(cimg::X11_mutex);
-      }
-      return *this;
-    }
-  
-    CImgDisplay& wait() {
-      if (!closed && events) {
-        XEvent event;
-        do {
-          pthread_mutex_lock(cimg::X11_mutex);
-          const unsigned int 
-            emask = ExposureMask|StructureNotifyMask|
-            ((events>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
-            ((events>=3)?ButtonReleaseMask|KeyReleaseMask:0);
-          XSelectInput(cimg::X11_display,window,emask);
-          XPeekEvent(cimg::X11_display,&event);
-          cimg::X11_thread_finished = false;
-          pthread_mutex_unlock(cimg::X11_mutex);
-        } while (event.xany.window!=window);
-        while (!cimg::X11_thread_finished) cimg::wait(25);
-      }
-      return *this;
-    }
-
-    CImgDisplay& show() {
-      if (closed) {
-        pthread_mutex_lock(cimg::X11_mutex);
-        XEvent event;
-        XSelectInput(cimg::X11_display,window,StructureNotifyMask);
-        XMapWindow(cimg::X11_display,window);
-        do XWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event);
-        while (event.type!=MapNotify);
-        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-        XFlush(cimg::X11_display);
-        closed = false;
-        pthread_mutex_unlock(cimg::X11_mutex);
-      }
-      return *this;
-    }
-    CImgDisplay& close() {
-      if (!closed) {
-        pthread_mutex_lock(cimg::X11_mutex);
-        XUnmapWindow(cimg::X11_display,window);
-        XFlush(cimg::X11_display);
-        closed = true;
-        pthread_mutex_unlock(cimg::X11_mutex);
-      }
-      return *this;
-    }
-  
-    // Windows-based display
-    //-----------------------
-#elif cimg_display_type==2
-    CLIENTCREATESTRUCT ccs;
-    BITMAPINFO bmi;
-    unsigned int *data;
-    DEVMODE curr_mode;
-    HWND window;
-    HDC hdc;
-    HANDLE thread;
-    HANDLE wait_disp;
-    HANDLE created;
-    HANDLE mutex;
-
-    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      width(dimw),height(dimh),window_width(dimw),window_height(dimh),
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      new_lowlevel(title);
-      std::memset(data,0,sizeof(unsigned int)*width*height);
-      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-    }
-
-    template<typename T>
-    CImgDisplay(const CImg<T>& img,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimg_test(img,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_3dplanes(img.width/2,img.height/2,img.depth/2));
-      window_width  = width  = nimg.width;
-      window_height = height = nimg.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(nimg);
-    }
-
-    template<typename T>
-    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimgl_test(list,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T> img0 = list.get_append('x'),
-        &img = (img0.depth==1)?img0:(tmp=img0.get_3dplanes(img0.width/2,img0.height/2,img0.depth/2));
-      window_width  = width  = img.width;
-      window_height = height = img.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(img);
-    }
-
-    CImgDisplay(const CImgDisplay& win, char *title="[Copy]"):
-      width(win.width),height(win.height),window_width(win.width),window_height(win.height),
-      normalization(win.normalization),events(win.events),fullscreen(win.fullscreen),
-      mousex(-1),mousey(-1),button(0),key(0),closed(win.closed),resized(false),min(win.min),max(win.max) {
-      new_lowlevel(title);
-      std::memcpy(data,win.data,sizeof(unsigned int)*width*height);
-      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-    }
-
-    CImgDisplay& resize(const int nwidth, const int nheight,const bool redraw=false,const bool force=true) {
-      const unsigned int
-        dimx=nwidth>0?nwidth:(-nwidth)*width/100,
-        dimy=nheight>0?nheight:(-nheight)*height/100;
-      if (!dimx || !dimy) return *this;
-      if (dimx!=width || dimy!=height) {
-        unsigned int *ndata = new unsigned int[dimx*dimy];
-        if (redraw) 
-          for (unsigned int y=0; y<dimy; y++) for (unsigned int x=0; x<dimx; x++) ndata[x+y*dimx] = data[x*width/dimx + width*(y*height/dimy)];
-        else std::memset(ndata,0x80,sizeof(unsigned int)*dimx*dimy);
-        delete[] data;
-        data = ndata;
-        bmi.bmiHeader.biWidth=dimx;
-        bmi.bmiHeader.biHeight=-(int)dimy;
-      }
-      width  = dimx;
-      height = dimy;
-      if (force && (window_width!=width || window_height!=height)) {
-        int cwidth,cheight;
-        RECT rect;
-        rect.left=rect.top=0; rect.right=width-1; rect.bottom=height-1;
-        if (AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false)) {
-          cwidth = rect.right-rect.left+1; cheight = rect.bottom-rect.top+1;
-        } else { cwidth = width+9; cheight = height+28; }
-        SetWindowPos(window,0,0,0,cwidth,cheight,SWP_NOMOVE | SWP_NOZORDER | SWP_NOCOPYBITS);
-        window_width  = dimx;
-        window_height = dimy;
-      }
-      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-      resized = false;
-      return *this;
-    }
-
-    ~CImgDisplay() {
-      DestroyWindow(window);
-      if (events) TerminateThread(thread,0);
-      delete[] data;
-      if (curr_mode.dmSize) ChangeDisplaySettings(&curr_mode,0);
-    }
-  
-    void new_lowlevel(const char *title=NULL) {
-      unsigned long ThreadID;
-      DEVMODE mode;
-      unsigned int imode=0,ibest=0,bestbpp=0;
-      void *arg = (void*)(new void*[2]);
-      ((void**)arg)[0]=(void*)this;
-      ((void**)arg)[1]=(void*)title;
-      if (fullscreen) {
-        for (mode.dmSize = sizeof(DEVMODE), mode.dmDriverExtra = 0; EnumDisplaySettings(NULL,imode,&mode); imode++)
-          if (mode.dmPelsWidth==width && mode.dmPelsHeight==height && mode.dmBitsPerPel>bestbpp) {
-            bestbpp = mode.dmBitsPerPel;
-            ibest=imode; 
-          }
-        cimg::warn(!bestbpp,"CImgDisplay::new_lowlevel() : Could not initialize fullscreen mode %ux%u\n",width,height);
-        if (bestbpp) {
-          curr_mode.dmSize = sizeof(DEVMODE); curr_mode.dmDriverExtra = 0;
-          EnumDisplaySettings(NULL,ENUM_CURRENT_SETTINGS,&curr_mode);
-          EnumDisplaySettings(NULL,ibest,&mode);
-          ChangeDisplaySettings(&mode,0);
-        }
-        else curr_mode.dmSize = 0;
-      }
-      else curr_mode.dmSize = 0;
-      if (events) {
-        mutex     = CreateMutex(NULL,FALSE,NULL);
-        created   = CreateEvent(NULL,FALSE,FALSE,NULL);
-        wait_disp = CreateEvent(NULL,FALSE,FALSE,NULL);
-        thread    = CreateThread(NULL,0,thread_lowlevel,arg,0,&ThreadID);
-        WaitForSingleObject(created,INFINITE);
-      } else thread_lowlevel(arg);
-    }
-  
-    static LRESULT APIENTRY proc_lowlevel(HWND window,UINT msg,WPARAM wParam,LPARAM lParam) {
-      CImgDisplay* disp = (CImgDisplay*)GetWindowLong(window,GWL_USERDATA);
-      MSG st_msg;
-
-      switch(msg) {
-      case WM_CLOSE:
-	disp->mousex=disp->mousey=-1;
-	disp->key=disp->button=0;
-        disp->closed=true;
-        ReleaseMutex(disp->mutex);
-        ShowWindow(disp->window,SW_HIDE);
-        return 0;
-      case WM_SIZE: {
-        while (PeekMessage(&st_msg,window,WM_SIZE,WM_SIZE,PM_REMOVE));
-        WaitForSingleObject(disp->mutex,INFINITE);
-        const unsigned int nw = LOWORD(lParam), nh = HIWORD(lParam);
-        if (nw && nh && (nw!=disp->width || nh!=disp->height)) { 
-          disp->window_width  = nw; 
-          disp->window_height = nh;
-	  disp->mousex = disp->mousey = -1;
-          disp->resized = true;
-        }
-        ReleaseMutex(disp->mutex);
-      }
-        break;
-      case WM_PAINT:
-        WaitForSingleObject(disp->mutex,INFINITE);
-        SetDIBitsToDevice(disp->hdc,0,0,disp->width,disp->height,0,0,0,disp->height,disp->data,&(disp->bmi),DIB_RGB_COLORS);
-        ReleaseMutex(disp->mutex);
-        break;
-      }
-      if (disp->events>=2) switch(msg) {
-      case WM_KEYDOWN:
-        while (PeekMessage(&st_msg,window,WM_KEYDOWN,WM_KEYDOWN,PM_REMOVE)); 
-        disp->key=(int)wParam;
-        break;
-      case WM_MOUSEMOVE: {
-        while (PeekMessage(&st_msg,window,WM_MOUSEMOVE,WM_MOUSEMOVE,PM_REMOVE));
-        disp->mousex = LOWORD(lParam);
-        disp->mousey = HIWORD(lParam);
-        if (disp->mousex<0 || disp->mousey<0 ||	disp->mousex>=disp->dimx() || disp->mousey>=disp->dimy())
-	  disp->mousex=disp->mousey=-1;
-      }
-        break;
-      case WM_LBUTTONDOWN: 
-        while (PeekMessage(&st_msg,window,WM_LBUTTONDOWN,WM_LBUTTONDOWN,PM_REMOVE));
-        disp->button |= 1; 
-        break;
-      case WM_RBUTTONDOWN: 
-        while (PeekMessage(&st_msg,window,WM_RBUTTONDOWN,WM_RBUTTONDOWN,PM_REMOVE));
-        disp->button |= 2; 
-        break;
-      case WM_MBUTTONDOWN: 
-        while (PeekMessage(&st_msg,window,WM_MBUTTONDOWN,WM_MBUTTONDOWN,PM_REMOVE));
-        disp->button |= 4; 
-        break;
-      }
-      if (disp->events>=3) switch(msg) {
-      case WM_KEYUP:
-        while (PeekMessage(&st_msg,window,WM_KEYUP,WM_KEYUP,PM_REMOVE));
-        disp->key=0;
-        break;
-      case WM_LBUTTONUP:
-        while (PeekMessage(&st_msg,window,WM_LBUTTONUP,WM_LBUTTONUP,PM_REMOVE));
-        disp->button &= ~1; 
-        break;
-      case WM_RBUTTONUP:
-        while (PeekMessage(&st_msg,window,WM_RBUTTONUP,WM_RBUTTONUP,PM_REMOVE)); 
-        disp->button &= ~2;
-        break;
-      case WM_MBUTTONUP:
-        while (PeekMessage(&st_msg,window,WM_MBUTTONUP,WM_MBUTTONUP,PM_REMOVE)); 
-        disp->button &= ~4;
-        break;
-      }
-      return DefWindowProc(window,msg,wParam,lParam);
-    }
-  
-    static DWORD WINAPI thread_lowlevel(void* arg) {
-      CImgDisplay *disp  = (CImgDisplay*)(((void**)arg)[0]);
-      const char *title = (const char*)(((void**)arg)[1]);
-      MSG msg;
-      delete[] (void**)arg;
-      disp->bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
-      disp->bmi.bmiHeader.biWidth=disp->width;
-      disp->bmi.bmiHeader.biHeight=-(int)disp->height;
-      disp->bmi.bmiHeader.biPlanes=1;
-      disp->bmi.bmiHeader.biBitCount=32;
-      disp->bmi.bmiHeader.biCompression=BI_RGB;
-      disp->bmi.bmiHeader.biSizeImage=0;
-      disp->bmi.bmiHeader.biXPelsPerMeter=1;
-      disp->bmi.bmiHeader.biYPelsPerMeter=1;
-      disp->bmi.bmiHeader.biClrUsed=0;
-      disp->bmi.bmiHeader.biClrImportant=0;
-      disp->data = new unsigned int[disp->width*disp->height];
-      if (!disp->curr_mode.dmSize) {
-        int cwidth,cheight;
-        RECT rect;
-        rect.left=rect.top=0; rect.right=disp->width-1; rect.bottom=disp->height-1;
-        if (AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false)) {
-          cwidth = rect.right-rect.left+1; cheight = rect.bottom-rect.top+1;
-        } else { cwidth = disp->width+9; cheight = disp->height+28; }
-        disp->window = CreateWindow("MDICLIENT",title?title:"",
-                                    WS_OVERLAPPEDWINDOW | WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,
-                                    cwidth,cheight,NULL,NULL,NULL,&(disp->ccs));
-      }
-      else disp->window = CreateWindow("MDICLIENT",title?title:"",
-                                       WS_POPUP | WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,
-                                       disp->width,disp->height,NULL,NULL,NULL,&(disp->ccs));
-      SetForegroundWindow(disp->window);
-      disp->hdc = GetDC(disp->window);
-      if (disp->events) {
-        SetWindowLong(disp->window,GWL_USERDATA,(LONG)disp);
-        SetWindowLong(disp->window,GWL_WNDPROC,(LONG)proc_lowlevel);
-        SetEvent(disp->created);
-        while( GetMessage( &msg, NULL, 0, 0 ) ) { DispatchMessage( &msg ); SetEvent(disp->wait_disp); }
-      }
-      return 0;
-    }
-
-    template<typename T> BITMAPINFO* render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {
-      cimg_test(img,"CImgDisplay::render");
-      if (img.depth!=1) return render(img.get_3dplanes(img.width/2,img.height/2,img.depth/2),(unsigned int)0,~(unsigned int)0);
-      if (img.width!=width || img.height!=height) return render(img.get_resize(width,height,1,-100,1),(unsigned int)0,~(unsigned int)0);
-      const bool by=(ymin<=ymax);
-      const unsigned int nymin = by?ymin:ymax, nymax = by?(ymax>=height?height-1:ymax):(ymin>=height?height-1:ymin), w=width;
-      const T 
-        *data1 = img.ptr(0,nymin,0,0),
-        *data2 = (img.dim>=2)?img.ptr(0,nymin,0,1):data1,
-        *data3 = (img.dim>=3)?img.ptr(0,nymin,0,2):data1;
-      unsigned int *ximg = data + nymin*width;
-      WaitForSingleObject(mutex,INFINITE);
-      if (!normalization)
-        for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++)
-          *(ximg++) = ((unsigned char)*(data1++)<<16) | ((unsigned char)*(data2++)<<8) | (unsigned char)*(data3++);
-      else {
-        if (normalization==1) { CImgStats st(img,false); min=st.min; max=st.max; }
-        const T nmin = (T)min, delta = (T)(max-nmin), mm = delta?delta:(T)1;
-        for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-          const unsigned char
-            val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
-            val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
-            val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
-          *(ximg++) = (val1<<16) | (val2<<8) | (val3);
-        }
-      }
-      ReleaseMutex(mutex);
-      return &bmi;
-    }
-
-    template<typename T> CImgDisplay& display(const CImg<T>& img,const unsigned int pymin=0,const unsigned int pymax=~0) {
-      cimg_test(img,"CImgDisplay::display");
-      const unsigned int 
-        ymin = pymin<pymax?pymin:pymax,
-        ymax = pymin<pymax?(pymax>=height?height-1:pymax):(pymin>=height?height-1:pymin);
-      render(img,ymin,ymax);
-      if (!closed) {
-        WaitForSingleObject(mutex,INFINITE);
-        SetDIBitsToDevice(hdc,0,ymin,width,ymax-ymin+1,0,0,0,ymax-ymin+1,data+ymin*width,&bmi,DIB_RGB_COLORS);
-        ReleaseMutex(mutex);
-      }
-      return *this;
-    }
-  
-    CImgDisplay& wait() {
-      if (!closed && events) WaitForSingleObject(wait_disp,INFINITE);
-      return *this;
-    }
-
-    CImgDisplay& show() {
-      if (closed) {
-        ShowWindow(window,SW_SHOW);
-        SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-        closed = false;
-      }
-      return *this;
-    }
-
-    CImgDisplay& close() {
-      if (!closed) {
-        ShowWindow(window,SW_HIDE);
-        closed = true;
-      }
-      return *this;
-    }
-#endif
-
-#ifdef cimgdisplay_plugin
-#include cimgdisplay_plugin
-#endif
- 
-  };
-
-
-  /*-------------------------------------------------------
-
-
-
-  
-    Definition of the CImg<T> structure
-	
-	
-	
-	
-  ------------------------------------------------------*/
-
-  //! This structure represents an image (up to 4 dimensions wide), with pixels of type \c T.
-  /**
-     This is the main structure of the CImg Library. It allows to define an image,
-     access its pixel values, and perform various operations on it.
-
-     <b>* Image structure</b>
-
-     A \ref CImg<\c T> structure contains only five fields :
-     - \ref width defines the number of columns of the image.
-     - \ref height defines the number of rows of the image.
-     - \ref depth defines the number of slices of the image.
-     - \ref dim defines the number of channels of the image.
-     - \ref data defines a pointer to the pixel data (of type \c T).
-     
-     You can access these fields publicly although it is recommended to use dedicated functions
-     dimx(), dimy(), dimz(), dimv() and ptr() to do so.     
-     Image dimensions are not limited to a specific range (as long as you got enough RAM).
-     A value of \e 1 usually means that the corresponding dimension is 'flat'.
-     If one dimension is \e 0, the image is considered as an \e empty image.
-     Empty images do not contain pixel data and thus, are not processed by most of CImg member functions.
-     Most of the CImg<T> member functions are designed to work on images with general dimensions.     
-
-     <b>* Image declaration</b>
-
-     Declaration of an image uses one of the several available constructors. Below is a list of
-     the most used :
-     - Construct images from dimensions :
-         - <tt>CImg<char> img;</tt> constructs an empty image.
-         - <tt>CImg<unsigned char> img(128,128);</tt> constructs a 128x128 greyscale image with \c unsigned \c char pixel values.
-         - <tt>CImg<double> img(3,3);</tt> constructs  a 3x3 matrix with \c double coefficients.
-         - <tt>CImg<unsigned char> img(256,256,1,3);</tt> for a 256x256x1x3 (color) image (colors are stored as three channels).
-         - <tt>CImg<double> img(128,128,128);</tt> for a 128x128x128 volumetric (greyscale) image (with \c double pixel values).
-         - <tT>CImg<> img(128,128,128,3);</tt> for a 128x128x128 volumetric color image (with \c float pixels, which is
-	 the default value of the template parameter \c T).
-	 - \b Note : images pixels are <b>not automatically initialized to 0</b>. You may use the function \ref fill() to
-	 do it.
-     - Construct images from filenames :
-         - <tt>CImg<unsigned char> img("image.jpg");</tt> reads a color image from the disk.
-	 - <tt>CImg<float> img("analyze.hdr");</tt> reads a volumetric image with float pixel (ANALYZE7.5 format).
-	 - \b Note : You will need to install ImageMagick to be able to read compressed image formats (JPG,PNG,...)
-     - Construct images from C-arrays :
-         - <tt>CImg<int> img(data_buffer,256,256);</tt> convert a \c int buffer \c data_buffer to a 256x256 greyscale image.     
-
-     More constructors are available (copy constructor,...). Please look at the constructor list for more
-     informations.
-
-  
-  A CImg image is defined as a template class CImg<T> containing a pixel data field with a maximum of 4 dimensions :
-  the 3 first dimensions are usually used to describe the spatial coordinates <tt>(x,y,z)</tt> in the image, while the last one
-  is often used as a vector-valued pixel dimension (color channel for instance). Then, this class can handle the case of 3D volumes
-  of vector-valued pixels, and all images that requires less dimensions (gray-valued or color 2D images for instance). 
-  It also means that (almost) all member functions of the class CImg<T> are designed to handle the maximum case of these (3+1) dimensions.
-
-  Moreover, the pixel type is given by the template parameter T, which means that you can define images with different pixel types T.
-  Fully supported template types are the basic C++ types : <tt>unsigned char, char, short, unsigned int, int, float, double, ... </tt>
-  Using your own template types is possible however, but you will have to redefine the complete set of arithmetic and logical operators.
-  Typically, fast image display would be done using <tt>CImg<unsigned char></tt> images, while complex image processing algorithms would be coded
-  using <tt>CImg<float></tt> or <tt>CImg<double></tt> images which have floating-point pixel values. Only two others classes are defined
-  in the <tt>CImg.h</tt> file : <tt>CImgStats</tt> that is used to represent image statistics, and <tt>CImgDisplay</tt> used to open 
-  windows where images are displayed, and handle keyboard and mouse events.
-
-  CImg has been designed to be 'user-friendly', meaning that the underlying structure of the classes is always quite basic to understand.
-  For instance, the <tt>CImg<T></tt> class members (which are defined as public) are only the dimensions
-  <tt>width, height, depth, dim</tt>, and the pixel data <tt>data</tt>. Very useful when you want to access the raw pixel buffer
-  for calling with functions of other libraries, or when you want to convert your raw data buffer into a <tt>CImg</tt>,
-  in order to visualize it for instance. Moreover, most of the classical arithmetic and logical operators have been redefined
-  in the <tt>CImg<T> class</tt>, which means that accessing a pixel is as simple as <tt>image(x,y)</tt> or <tt>image(x,y,z,v)</tt> (in 4D),
-  and beautiful things are possible such as <tt>(img1+3*img2).display();</tt>
-
-
-     \see \ref cimg_structure
-  **/
-  template<typename T> struct CImg {
-    
-    //! Number of columns in the instance image (size along the X-axis).
-    /**
-       \note
-       - Prefer using CImg<T>::dimx() to get the width of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::width would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::width==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int width;       
-    
-    //! Number of rows in the instance image (size along the Y-axis).
-    /**
-       \note 
-       - Prefer using CImg<T>::dimy() to get the height of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::height would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::height==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int height;
-    
-    //! Number of slices in the instance image (size along the Z-axis).
-    /**
-       \note 
-       - Prefer using CImg<T>::dimz() to get the depth of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::depth would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::depth==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int depth;
-    
-    //! Number of vector channels in the instance image (size along the V-axis).
-    /**
-       \note 
-       - Prefer using CImg<T>::dimv() to get the depth of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::dim would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::dim==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int dim;
-    
-    //! Pointer to pixel values (array of elements \c T).
-    /**
-       \note
-       - Prefer using CImg<T>::ptr() to get a pointer to the pixel buffer.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::data would probably
-       result in a crash.
-       - If CImg<T>::data==NULL, the image is empty and contains no pixel data.
-       \see \ref cimg_storage
-    **/
-    T *data;
-
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Constructors - Destructor - Copy
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-  
-    //! Create an image of size (\c dx,\c dy,\c dz,\c dv) with pixels of type \c T.
-    /**
-       \param dx = number of columns of the created image (size along the X-axis).
-       \param dy = number of rows of the created image (size along the Y-axis).
-       \param dz = number of slices of the created image (size along the Z-axis).
-       \param dv = number of vector channels of the created image (size along the V-axis).
-       \note 
-       - Pixel values are \e not \e initialized by this constructor.
-       - If invoked without parameters, this constructor creates an \e empty image (default constructor).
-    **/
-    explicit CImg(const unsigned int dx=0,const unsigned int dy=1,const unsigned int dz=1,const unsigned int dv=1):
-      width(dx),height(dy),depth(dz),dim(dv) {
-      const unsigned int siz = size();
-      if (siz) data = new T[siz]; else { data=NULL; width=height=depth=dim=0; }
-    }
-
-    //! Create an image of size (\c dx,\c dy,\c dz,\c dv) with pixels of type \c T,
-    //! and set the image pixels to the value \c val.
-    /**
-       \param dx = number of columns of the created image (size along the X-axis).
-       \param dy = number of rows of the created image (size along the Y-axis).
-       \param dz = number of slices of the created image (size along the Z-axis).
-       \param dv = number of vector channels of the created image (size along the V-axis).
-    **/    
-    explicit CImg(const unsigned int dx,const unsigned int dy,const unsigned int dz,const unsigned int dv,const T& val):
-      width(dx),height(dy),depth(dz),dim(dv) {
-      const unsigned int siz = size();
-      if (siz) { data = new T[siz]; fill(val); } else { data=NULL; width=height=depth=dim=0; }
-    }
-
-    //! Copy constructor.
-    /**
-       \param img = the image to copy.
-    **/
-    template<typename t> CImg(const CImg<t>& img):width(img.width),height(img.height),depth(img.depth),dim(img.dim) {
-      const unsigned int siz = size();
-      if (siz) {
-        data = new T[siz];
-        const t *ptrs = img.data + siz;
-        cimg_map(*this,ptrd,T) (*ptrd)=(T)*(--ptrs);
-      } else data = NULL;
-    }
-    CImg(const CImg<T>& img):width(img.width),height(img.height),depth(img.depth),dim(img.dim) {
-      const unsigned siz = size();
-      if (siz) {
-	data = new T[width*height*depth*dim];
-	std::memcpy(data,img.data,siz*sizeof(T));
-      } else data = NULL;
-    }
-
-
-    //! Copy constructor.
-    /**
-       \param img = the image to copy.
-       \param pixel_copy = tells the constructor if the pixel data of the original image are copied into the created image.
-       This may be useful when one wants to create an image with same size than other image, but without same pixel data :
-       \code
-       CImg<float> source("image.jpg");
-       CImg<unsigned char> destination(source,false);
-       \endcode
-       is equivalent to
-       \code
-       CImg<float> source("image.jpg");
-       CImg<unsigned char> destination(source.dimx(),source.dimy(),source.dimz(),source.dimv());
-       \endcode
-    **/
-    template<typename t> CImg(const CImg<t>& img,const bool pixel_copy):width(0),height(0),depth(0),dim(0),data(NULL) {
-      if (pixel_copy) CImg<T>(img).swap(*this);
-      CImg<T>(img.width,img.height,img.depth,img.dim).swap(*this);
-    }
-
-    //! Create an image by loading a file.
-    /**
-       \param filename = the filename of the image file. filename extension is used to guess the image type.
-       \see CImg<T>::load().
-    **/
-    CImg(const char *filename):width(0),height(0),depth(0),dim(0),data(NULL) { load(filename).swap(*this); }
-
-    //! Create an image from a data buffer.
-    /**
-       \param data_buffer = pointer \c T* to a buffer of pixel values T.
-       \param dx = number of columns of the created image (size along the X-axis).
-       \param dy = number of rows of the created image (size along the Y-axis).
-       \param dz = number of slices of the created image (size along the Z-axis).
-       \param dv = number of vector channels of the created image (size along the V-axis).
-       \see \ref cimg_storage
-    **/
-    CImg(const T *const data_buffer,unsigned int dx,unsigned int dy=1,unsigned int dz=1,unsigned int dv=1):
-      width(dx),height(dy),depth(dz),dim(dv) {
-      const unsigned int siz = size();
-      if (data_buffer && siz) {
-        data = new T[siz];
-        std::memcpy(data,data_buffer,siz*sizeof(T));
-      } else { width=height=depth=dim=0; data = NULL; }
-    }
-
-    //! Destructor.
-    /**
-       \note The destructor frees the memory eventually used by the image pixels.
-    **/
-    ~CImg() { if (data) delete[] data; }
-
-    //! Empty image
-    CImg& empty() { return CImg<T>().swap(*this); }
-
-    //@}
-    //-----------------------------------------------------
-    //-----------------------------------------------------
-    //
-    //! \name Access to image dimensions and pixel values
-    //@{
-    //-----------------------------------------------------
-    //-----------------------------------------------------
-  
-    //! Return the type of the pixel values
-    /**
-       \return a string describing the type of the image pixels (template parameter \p T).
-    **/
-    static const char* pixel_type() { T val; return cimg::get_type(val); }
-
-    //! Return the number of pixels of an image.
-    /**
-       \return dimx()*dimy()*dimz()*dimv()
-       \see dimx(), dimy(), dimz(), dimv()
-    **/
-    const unsigned int size() const { return width*height*depth*dim; }  
-
-    //! Return the number of columns of the instance image (size along the X-axis).
-    /**
-       \return this->width
-       \see dimy(),dimz(),dimv(),size()
-    **/
-    const int dimx() const { return (int)width; }  
-
-    //! Return the number of rows of the instance image (size along the Y-axis).
-    /**
-       \return this->height
-       \see dimx(),dimz(),dimv(),size()
-    **/
-    const int dimy() const { return (int)height; }
-  
-    //! Return the number of slices of the instance image (size along the Z-axis).
-    /**
-       \return this->depth
-       \see dimx(),dimy(),dimv(),size()
-    **/
-    const int dimz() const { return (int)depth; }
-  
-    //! Return the number of vector channels of the instance image (size along the V-axis).
-    /**
-       \return this->dim
-       \see dimx(),dimy(),dimz(),size()
-    **/
-    const int dimv() const { return (int)dim; }
-  
-    //! Return the offset corresponding to the location of the pixel value located at (\p x,\p y,\p z,\p v)
-    // with respect to the pixel data pointer \ref data.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const int offset(const int x=0, const int y=0, const int z=0, const int v=0) const { return x+width*(y+height*(z+depth*v)); }
-  
-    //! Return a pointer to the pixel value located at (\p x,\p y,\p z,\p v).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    T* ptr(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) const {
-#if cimg_debug>1
-      const int off = offset(x,y,z,v);
-      if (off<0 || off>=(int)size()) {
-        cimg::warn(true,"CImg<%s>::ptr() : Trying to get a pointer at (%u,%u,%u,%u) (offset=%d) which is outside the data of the image (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-        return data;
-      }
-#endif
-      return data+offset(x,y,z,v);
-    }
-
-    //! Access to pixel value for reading or writing, without boundary checking.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel       
-       \note if \c cimg_debug==2, a boundary checking is performed (also slow down the code considerably).
-    **/
-    T& operator()(const unsigned int x,const unsigned int y=0,const unsigned int z=0,const unsigned int v=0) const {
-      const int off = offset(x,y,z,v);
-#if cimg_debug>1
-      if (!data || off>=(int)size()) {
-        cimg::warn(true,
-                   "CImg<%s>::operator() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) outside the image range (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,offset(x,y,z,v),width,height,depth,dim,data,size());			
-        return *data;
-      }
-#endif
-      return data[off];
-    }
-    
-    //! Access to pixel buffer value for reading or writing.
-    /**
-       \param off = offset in the pixel buffer
-       \note if \c cimg_debug==2, a out-of-buffer checking is performed (also slow down the code considerably).
-    **/    
-    T& operator[](const unsigned int off) const {
-#if cimg_debug>1
-      if (!data || off>=(int)size()) {
-        cimg::warn(true,
-                   "CImg<%s>::operator[] : Trying to get a pixel at offset=%d, outside the range of the image (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),off,width,height,depth,dim,data,size());			
-        return *data;
-      }
-#endif
-      return data[off];
-    }
-
-    //! Pixel access with Dirichlet boundary conditions for all coordinates (x,y,z,v).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix4d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || y<0 || z<0 || v<0 || x>=dimx() || y>=dimy() || z>=dimz() || v>=dimv())?out_val:(*this)(x,y,z,v);
-    }
-
-    //! Pixel access with Dirichlet boundary conditions for the three first coordinates (x,y,z).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix3d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || y<0 || z<0 || x>=dimx() || y>=dimy() || z>=dimz())?out_val:(*this)(x,y,z,v);
-    }
-    //! Pixel access with Dirichlet boundary conditions for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix2d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || y<0 || x>=dimx() || y>=dimy())?out_val:(*this)(x,y,z,v);
-    }
-
-    //! Pixel access with Dirichlet boundary conditions for the first coordinate x.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix1d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || x>=dimx())?out_val:(*this)(x,y,z,v);
-    }
-
-    //! Pixel access with Neumann boundary conditions for all coordinates (x,y,z,v).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix4d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
-                     y<0?0:(y>=dimy()?dimy()-1:y),
-                     z<0?0:(z>=dimz()?dimz()-1:z),
-                     v<0?0:(v>=dimv()?dimv()-1:v));
-    }
-    //! Pixel access with Neumann boundary conditions for the three first coordinates (x,y,z).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix3d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
-                     y<0?0:(y>=dimy()?dimy()-1:y),
-                     z<0?0:(z>=dimz()?dimz()-1:z),v);
-    }
-
-    //! Pixel access with Neumann boundary conditions for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix2d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
-                     y<0?0:(y>=dimy()?dimy()-1:y),z,v);
-    }
-    //! Pixel access with Neumann boundary conditions for the first coordinate x.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix1d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),y,z,v);
-    }
-    
-    //! Pixel access with Neumann boundary conditions and linear interpolation for all coordinates (x,y,z,v).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (float value)
-       \param v = v-coordinate of the pixel (float value)
-    **/
-    double linear_pix4d(const float ffx,const float ffy=0,const float ffz=0,const float ffv=0) const {
-      double valx0,valx1,valy0,valy1,valz0,valz1;
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy),
-        fz = ffz<0?0:(ffz>depth-1?depth-1:ffz), fv = ffv<0?0:(ffv>dim-1?dim-1:ffv);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy,  z = (unsigned int)fz, v = (unsigned int)fv;
-      const float dx = fx-x, dy = fy-y, dz = fz-z, dv = fv-v;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y,  nz = dz>0?z+1:z, nv = dv>0?v+1:v;
-      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
-      valy0 = (1-dy)*valx0 + (dy)*valx1;
-      valx0 = (1-dx)*(*this)(x,y,nz,v)  + (dx)*(*this)(nx,y,nz,v);
-      valx1 = (1-dx)*(*this)(x,ny,nz,v) + (dx)*(*this)(nx,ny,nz,v);
-      valy1 = (1-dy)*valx0 + (dy)*valx1;
-      valz0 = (1-dz)*valy0 + (dz)*valy1;
-      valx0 = (1-dx)*(*this)(x,y,z,nv)  + (dx)*(*this)(nx,y,z,nv);
-      valx1 = (1-dx)*(*this)(x,ny,z,nv) + (dx)*(*this)(nx,ny,z,nv);
-      valy0 = (1-dy)*valx0 + (dy)*valx1;
-      valx0 = (1-dx)*(*this)(x,y,nz,nv)  + (dx)*(*this)(nx,y,nz,nv);
-      valx1 = (1-dx)*(*this)(x,ny,nz,nv) + (dx)*(*this)(nx,ny,nz,nv);
-      valy1 = (1-dy)*valx0 + (dy)*valx1;
-      valz1 = (1-dz)*valy0 + (dz)*valy1;
-      return (1-dv)*valz0 + (dv)*valz1;
-    }
-
-    //! Pixel access with Neumann boundary conditions and linear interpolation for the three first coordinates (x,y,z).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (float value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double linear_pix3d(const float ffx,const float ffy=0,const float ffz=0,const int v=0) const {
-      double valx0,valx1,valy0,valy1;
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy), fz = ffz<0?0:(ffz>depth-1?depth-1:ffz);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy, z = (unsigned int)fz;
-      const float dx = fx-x, dy = fy-y, dz = fz-z;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y, nz = dz>0?z+1:z;
-      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
-      valy0 = (1-dy)*valx0 + (dy)*valx1;
-      valx0 = (1-dx)*(*this)(x,y,nz,v)  + (dx)*(*this)(nx,y,nz,v);
-      valx1 = (1-dx)*(*this)(x,ny,nz,v) + (dx)*(*this)(nx,ny,nz,v);
-      valy1 = (1-dy)*valx0 + (dy)*valx1;
-      return (1-dz)*valy0 + (dz)*valy1;
-    }
-
-    //! Pixel access with Neumann boundary conditions and linear interpolation for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double linear_pix2d(const float ffx,const float ffy=0,const int z=0,int v=0) const {
-      double valx0,valx1;
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy;
-      const float dx = fx-x, dy = fy-y;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y;
-      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
-      return (1-dy)*valx0 + (dy)*valx1;
-    }
-
-    //! Pixel access with Neumann boundary conditions and linear interpolation for the first coordinate x.
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (integer value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double linear_pix1d(const float ffx,const int y=0,const int z=0,int v=0) const {
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx);
-      const unsigned int x = (unsigned int)fx;
-      const float dx = fx-x;
-      const unsigned int nx = dx>0?x+1:x;
-      return (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-    }
-
-    //! Pixel access with Neumann boundary conditions and cubic interpolation for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double cubic_pix2d(const float pfx,const float pfy=0,const int z=0,int v=0) const {
-      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx), fy = pfy<0?0:(pfy>height-1?height-1:pfy);
-      const unsigned int 
-        x = (unsigned int)fx,  px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1,
-        y = (unsigned int)fy,  py = (int)y-1>=0?y-1:0, ny = y+1<height?y+1:height-1, ay = ny+1<height?ny+1:height-1;
-      const float dx = fx-x, dy = fy-y;
-      const T& 
-        a = (*this)(px,py,z,v), b = (*this)(x,py,z,v), c = (*this)(nx,py,z,v), d = (*this)(ax,py,z,v),
-        e = (*this)(px, y,z,v), f = (*this)(x, y,z,v), g = (*this)(nx, y,z,v), h = (*this)(ax, y,z,v),
-        i = (*this)(px,ny,z,v), j = (*this)(x,ny,z,v), k = (*this)(nx,ny,z,v), l = (*this)(ax,ny,z,v),
-        m = (*this)(px,ay,z,v), n = (*this)(x,ay,z,v), o = (*this)(nx,ay,z,v), p = (*this)(ax,ay,z,v);
-      const double 
-        A = dx*dx*dx*(2*(b-c)+0.5*(c-a+d-b)) + dx*dx*(2*c-2.5*b+a-0.5*d) + dx*0.5*(c-a) + b,
-        B = dx*dx*dx*(2*(f-g)+0.5*(g-e+h-f)) + dx*dx*(2*g-2.5*f+e-0.5*h) + dx*0.5*(g-e) + f,
-        C = dx*dx*dx*(2*(j-k)+0.5*(k-i+l-j)) + dx*dx*(2*k-2.5*j+i-0.5*l) + dx*0.5*(k-i) + j,
-        D = dx*dx*dx*(2*(n-o)+0.5*(o-m+p-n)) + dx*dx*(2*o-2.5*n+m-0.5*p) + dx*0.5*(o-m) + n;
-      return dy*dy*dy*(2*(B-C)+0.5*(C-A+D-B)) + dy*dy*(2*C-2.5*B+A-0.5*D) + dy*0.5*(C-A) + B;
-    }
-
-    //! Pixel access with Neumann boundary conditions and cubic interpolation for all coordinates x.
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (integer value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double cubic_pix1d(const float pfx,const int y=0,const int z=0,int v=0) const {
-      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx);
-      const unsigned int x = (unsigned int)fx, px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1;
-      const float dx = fx-x;
-      const T& a = (*this)(px,y,z,v), b = (*this)(x,y,z,v), c = (*this)(nx,y,z,v), d = (*this)(ax,y,z,v);
-      return dx*dx*dx*(2*(b-c)+0.5*(c-a+d-b)) + dx*dx*(2*c-2.5*b+a-0.5*d) + dx*0.5*(c-a) + b;
-    }
-  
-    //! Compute and return statistics on the image.
-    /**
-       \param compute_variance = - \true : compute complete statistics, including the variance of the pixel values.
-                                 - \false : compute only minimum, maximum and average value of the pixel values (faster).
-       \return a CImgStats instance representing statistics of the instance image.
-    **/
-    CImgStats get_stats(const bool compute_variance=true) const { return CImgStats(*this,compute_variance); }
-  
-    //! Print image information on the standart error output
-    /**
-       \param title = name of your printed variable.
-       \param print_flag = - 0 : print only informations about image size and pixel buffer.
-                           - 1 : print also statistics on the image pixels.
-			   - 2 : print also the pixel buffer content, in a matlab-style.
-    **/
-    const CImg& print(const char *title=NULL,const unsigned int print_flag=1) const {
-      std::fprintf(stderr,"%-8s(%p) : '%s'(%u,%u,%u,%u,%p) : ",title?title:"CImg",(void*)this,
-		   pixel_type(),width,height,depth,dim,(void*)data);
-      if (size()==0 || !data) { std::fprintf(stderr,"Undefined pixel data\n"); return *this; }
-      if (print_flag>=1) { 
-        CImgStats st(*this);
-        std::fprintf(stderr,"stats = { %g, %g [%g], %g } : ",st.min,st.mean,st.variance,st.max); 
-      }
-      if (print_flag>=2 || size()<=16) {
-        std::fprintf(stderr,"%s = [ ",title?title:"data");
-        cimg_mapXYZV(*this,x,y,z,k) std::fprintf(stderr,"%g%s",(double)(*this)(x,y,z,k),((x+1)*(y+1)*(z+1)*(k+1)==(int)size()?" ]":(((x+1)%width==0)?" ; ":" ")));
-      }
-      std::fputc('\n',stderr);
-      return *this;
-    }
-    //! Print image information on the standart error output
-    /**
-      \param print_flag = - 0 : print only informations about image size and pixel buffer.
-                           - 1 : print also statistics on the image pixels.
-			   - 2 : print also the pixel buffer content, in a matlab-style.       
-    **/
-    const CImg& print(const unsigned int print_flag) const { return print(NULL,print_flag); }
-  
-    //@}
-    //--------------------------------------------------
-    //--------------------------------------------------
-    //
-    //! \name Common arithmetics and boolean operators
-    //@{
-    //--------------------------------------------------
-    //--------------------------------------------------
-  
-    //! Copy an image to the instance image.
-    /**
-       \param img = image to copy.
-       \note If pixel types are different, a type cast is performed.
-    **/
-    template<typename t> CImg<T>& operator=(const CImg<t>& img) { return CImg<T>(img).swap(*this); }
-    CImg& operator=(const CImg& img) { if (&img==this) return *this; return CImg<T>(img).swap(*this); }
-      
-    //! Assign a scalar value to all pixels of the instance image
-    /**
-       \param val = the value to assign.
-    **/
-    CImg& operator=(const T& val) { return fill(val); }
-
-    //! Copy the content of a C-array to the pixel buffer of the instance image
-    /**
-       \param buf = pointer to a C-array, with a size of (at least) this->size().
-    **/
-    CImg& operator=(const T *buf) {
-      if (buf) std::memcpy(data,buf,size()*sizeof(T));
-      else throw CImgArgumentException("CImg<T>::operator=() : Given array pointer 'ptr' is NULL");
-      return *this; 
-    }
-       
-    //! Operator+=
-    /**
-       \param val = value to add to each pixel value of the instance image.
-    **/
-    CImg& operator+=(const T& val) { cimg_map(*this,ptr,T) (*ptr)+=val; return *this; }
-
-    //! Operator-=
-    /**
-       \param val = value to sub to each pixel value of the instance image.
-    **/
-    CImg& operator-=(const T& val) { cimg_map(*this,ptr,T) (*ptr)-=val; return *this; }
-
-    //! Operator%=
-    /**
-       \param val = value of the modulo applied to each pixel value of the instance image.
-    **/
-    CImg& operator%=(const T& val) { cimg_map(*this,ptr,T) (*ptr)%=val; return *this; }
-
-    //! Operator&=
-    /**
-       \param val = value of the bitwise AND applied to each pixel value of the instance image.
-     **/
-    CImg& operator&=(const T& val) { cimg_map(*this,ptr,T) (*ptr)&=val; return *this; }
-
-    //! Operator|=
-    /**
-       \param 
-    **/
-    CImg& operator|=(const T& val) { cimg_map(*this,ptr,T) (*ptr)|=val; return *this; }
-
-    //! Operator^=
-    CImg& operator^=(const T& val) { cimg_map(*this,ptr,T) (*ptr)^=val; return *this; }
-
-    //! Operator+
-    CImg operator+(const T& val) const { return CImg<T>(*this)+=val; }
-
-    //! Operator-
-    CImg operator-(const T& val) const { return CImg<T>(*this)-=val; }
-
-    //! Operator%
-    CImg operator%(const T& val) const { return CImg<T>(*this)%=val; }  
-
-    //! Operator&
-    CImg operator&(const T& val) const { return CImg<T>(*this)&=val; }
-
-    //! Operator|
-    CImg operator|(const T& val) const { return CImg<T>(*this)|=val; }
-
-    //! Operator^
-    CImg operator^(const T& val) const { return CImg<T>(*this)^=val; }
-
-    //! Operator!
-    CImg operator!() const {
-      CImg<T> res(*this,false);
-      const T *ptrs = ptr() + size();
-      cimg_map(res,ptrd,T) *ptrd=!(*(--ptrs));
-      return res;
-    }
-
-    //! Operator~
-    CImg operator~() const {
-      CImg<T> res(*this,false);
-      const T *ptrs = ptr() + size();
-      cimg_map(res,ptrd,T) *ptrd=~(*(--ptrs));
-      return res;
-    }
-    
-    //! Operator+=
-    template<typename t> CImg& operator+=(const CImg<t>& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      t *ptrs = img.data+smin;
-      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)+(*(--ptrs))));
-      return *this;
-    }
-    //! Operator-=
-    template<typename t> CImg& operator-=(const CImg<t>& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      t *ptrs = img.data+smin;
-      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)-(*(--ptrs))));
-      return *this;
-    }
-    //! Operator%=
-    CImg& operator%=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)%=*(--ptrs));
-      return *this;
-    }
-    //! Operator&=
-    CImg& operator&=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)&=*(--ptrs));
-      return *this;
-    }
-    //! Operator|=
-    CImg& operator|=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)|=*(--ptrs));
-      return *this;
-    }
-    //! Operator^=
-    CImg& operator^=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)^=*(--ptrs));
-      return *this;
-    }
-
-    //! Operator+
-    template<typename t> CImg operator+(const CImg<t>& img)  const { return CImg<T>(*this)+=img; }
-
-    //! Operator-
-    template<typename t> CImg operator-(const CImg<t>& img)  const { return CImg<T>(*this)-=img; }
-
-    //! Operator%
-    CImg operator%(const CImg& img) const { return CImg<T>(*this)%=img; }
-
-    //! Operator&
-    CImg operator&(const CImg& img) const { return CImg<T>(*this)&=img; } 
-
-    //! Operator|
-    CImg operator|(const CImg& img) const { return CImg<T>(*this)|=img; }
-
-    //! Operator^
-    CImg operator^(const CImg& img) const { return CImg<T>(*this)^=img; }  
-
-    //! Operator*=
-    CImg& operator*=(const double val) { cimg_map(*this,ptr,T) (*ptr)=(T)((*ptr)*val); return *this; }
-
-    //! Operator/=
-    CImg& operator/=(const double val) { cimg_map(*this,ptr,T) (*ptr)=(T)((*ptr)/val); return *this; }
-
-    //! Operator*
-    CImg operator*(const double val) const { return CImg<T>(*this)*=val; }
-
-    //! Operator/
-    CImg operator/(const double val) const { return CImg<T>(*this)/=val; }
-
-    //! Operator+
-    friend CImg operator+(const T& val, const CImg& img) { return CImg<T>(img)+=val; }
-
-    //! Operator*
-    friend CImg operator*(const double val,const CImg &img) { return CImg<T>(img)*=val; }
-
-    //! Operator-
-    friend CImg operator-(const T& val, const CImg& img) { return CImg<T>(img.width,img.height,img.depth,img.dim,val)-=img; }
-
-    //! Operator==
-    template<typename t> const bool operator==(const CImg<t>& img) const {
-      const unsigned int siz = size();
-      bool vequal = true;
-      if (siz!=img.size()) return false;
-      t *ptrs=img.data+siz;
-      for (T *ptrd=data+siz; vequal && ptrd>data; vequal=vequal&&((*(--ptrd))==(*(--ptrs))));
-      return vequal;
-    }
-    //! Operator!=
-    template<typename t> const bool operator!=(const CImg<t>& img) const { return !((*this)==img); }
-
-    //@}
-    //--------------------------------------------------
-    //--------------------------------------------------
-    //
-    //! \name Usual mathematical operations
-    //@{
-    //--------------------------------------------------
-    //--------------------------------------------------
-     
-    //! Replace the image by the pointwise multiplication between \p *this and \p img.
-    /**
-       \param img = argument of the multiplication.
-       \note if \c *this and \c img have different size, the multiplication is applied
-       only on possible values.
-       \see div(),get_mul(),get_div().
-    **/
-    template<typename t> CImg& mul(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd*(*(ptrs++)));
-      return *this;
-    }
-
-    //! Return the image corresponding to the pointwise multiplication between \p *this and \p img.
-    /**
-       \param img = argument of the multiplication.
-       \note if \c *this and \c img have different size, the multiplication is applied
-       only on possible values.
-       \see get_div(),mul(),div()
-    **/
-    template<typename t> CImg get_mul(const CImg<t>& img) const { return CImg<T>(*this).mul(img); }
-  
-    //! Replace the image by the pointwise division between \p *this and \p img.
-    /**
-       \param img = argument of the division.
-       \note if \c *this and \c img have different size, the division is applied
-       only on possible values.
-       \see mul(),get_mul(),get_div().
-    **/
-    template<typename t> CImg& div(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd/(*(ptrs++)));
-      return *this;
-    }
-
-    //! Return an image from a pointwise division between \p *this and \p img.
-    /**
-       \param img = argument of the division.
-       \note if \c *this and \c img have different size, the division is applied
-       only on possible values.
-       \see get_mul(),mul(),div()
-    **/
-    template<typename t> CImg get_div(const CImg<t>& img) const { return CImg<T>(*this).div(img); }
-  
-    //! Replace the image by the pointwise max operator between \p *this and \p img
-    /**
-       \param img = second argument of the max operator (the first one is *this).
-       \see get_max(), min(), get_min()
-    **/
-    template<typename t> CImg& max(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::max((T)(*(ptrs++)),*ptrd);
-      return *this;
-    }
-    //! Return the image corresponding to the max value for each pixel.
-    /**
-       \param img = second argument of the max operator (the first one is *this).
-       \see max(), min(), get_min()
-    **/
-    template<typename t> CImg get_max(const CImg<t>& img) const { return CImg<T>(*this).max(img); }
-  
-    //! Replace the image by the pointwise min operator between \p *this and \p img
-    /**
-       \param img = second argument of the min operator (the first one is *this).
-       \see get_min(), max(), get_max()
-    **/
-    template<typename t> CImg& min(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::min((T)(*(ptrs++)),*ptrd);
-      return *this;
-    }
-    //! Return the image corresponding to the min value for each pixel.
-    /**
-       \param img = second argument of the min operator (the first one is *this).
-       \see min(), max(), get_max()
-    **/
-    template<typename t> CImg get_min(const CImg<t>& img) const { return CImg<T>(*this).min(img); }
-
-    //! Replace each image pixel by its square root.
-    /**
-       \see get_sqrt()
-    **/
-    CImg& sqrt() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::sqrt((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the square root of the pixel values.
-    /**
-       \see sqrt()
-    **/
-    CImg get_sqrt() const { return CImg<T>(*this).sqrt(); }
-  
-    //! Replace each image pixel by its log.
-    /**
-       \see get_log(), log10(), get_log10()
-    **/
-    CImg& log() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::log((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the log of the pixel values.
-    /**
-       \see log(), log10(), get_log10()
-    **/
-    CImg get_log() const { return CImg<T>(*this).log(); }
-
-    //! Replace each image pixel by its log10.
-    /**
-       \see get_log10(), log(), get_log()
-    **/
-    CImg& log10() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::log10((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the log10 of the pixel values.
-    /**
-       \see log10(), log(), get_log()
-    **/
-    CImg get_log10() const { return CImg<T>(*this).log10(); }
-
-    //! Replace each image pixel by its power by \p p.
-    /**
-       \param p = power
-       \see get_pow(), sqrt(), get_sqrt()
-    **/
-    CImg& pow(const double p) {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::pow((double)(*ptr),p);
-      return *this;
-    }
-
-    //! Return the image of the square root of the pixel values.
-    /**
-       \param p = power
-       \see pow(), sqrt(), get_sqrt()
-    **/
-    CImg get_pow(const double p) const { return CImg<T>(*this).pow(p); }
-  
-    //! Replace each pixel value by its absolute value.
-    /**
-       \see get_abs()
-    **/
-    CImg& abs() {
-      cimg_map(*this,ptr,T) (*ptr)=cimg::abs(*ptr);
-      return *this;
-    }
-
-    //! Return the image of the absolute value of the pixel values.
-    /**
-       \see abs()
-    **/
-    CImg get_abs() const { return CImg<T>(*this).abs(); }
-  
-    //! Replace each image pixel by its cosinus.
-    /**
-       \see get_cos(), sin(), get_sin(), tan(), get_tan()
-    **/
-    CImg& cos() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::cos((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the cosinus of the pixel values.
-    /**
-       \see cos(), sin(), get_sin(), tan(), get_tan()
-    **/
-    CImg get_cos() const { return CImg<T>(*this).cos(); }
- 
-    //! Replace each image pixel by its sinus.
-    /**
-       \see get_sin(), cos(), get_cos(), tan(), get_tan()
-    **/
-    CImg& sin() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::sin((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the sinus of the pixel values.
-    /**
-       \see sin(), cos(), get_cos(), tan(), get_tan()
-    **/
-    CImg get_sin() const { return CImg<T>(*this).sin(); }
-  
-    //! Replace each image pixel by its tangent.
-    /**
-       \see get_tan(), cos(), get_cos(), sin(), get_sin()
-    **/
-    CImg& tan() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::tan((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the tangent of the pixel values.
-    /**
-       \see tan(), cos(), get_cos(), sin(), get_sin()
-    **/
-    CImg get_tan() const { return CImg<T>(*this).tan(); }
-  
-
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Usual image transformation
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Fill all pixel values with value \a val.
-    /**
-       \param val = fill value
-       \see operator=()
-    **/
-    CImg& fill(const T& val) {
-      cimg_test(*this,"CImg<T>::fill");      
-      if (val!=0 && sizeof(T)!=1) cimg_map(*this,ptr,T) *ptr=val; 
-      else std::memset(data,(int)val,size()*sizeof(T));
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-    **/
-    CImg& fill(const T& val0,const T& val1) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-1; ) { *(ptr++)=val0; *(ptr++)=val1; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      return *this;
-    }
-    
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-2; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; }     
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      return *this;
-    }
-    
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-3; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-4; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      return *this;
-    }
-    
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4 and \a val5
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size(); 
-      for (ptr=data; ptr<ptr_end-5; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val7.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,const T& val7) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-7; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val8.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,const T& val7,const T& val8) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-8; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val9.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,
-	       const T& val5,const T& val6,const T& val7,const T& val8,const T& val9) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-9; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      if (ptr!=ptr_end) *(ptr++)=val8;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val11.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,
-               const T& val7,const T& val8,const T& val9,const T& val10,const T& val11) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-11; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      if (ptr!=ptr_end) *(ptr++)=val8;
-      if (ptr!=ptr_end) *(ptr++)=val9;
-      if (ptr!=ptr_end) *(ptr++)=val10;
-      return *this;
-    }
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val15.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-       \param val12 = fill value 13
-       \param val13 = fill value 14
-       \param val14 = fill value 15
-       \param val15 = fill value 16
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-	       const T& val4,const T& val5,const T& val6,const T& val7,
-               const T& val8,const T& val9,const T& val10,const T& val11,
-	       const T& val12,const T& val13,const T& val14,const T& val15) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-15; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-	*(ptr++)=val12; *(ptr++)=val13; *(ptr++)=val14; *(ptr++)=val15;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      if (ptr!=ptr_end) *(ptr++)=val8;
-      if (ptr!=ptr_end) *(ptr++)=val9;
-      if (ptr!=ptr_end) *(ptr++)=val10;
-      if (ptr!=ptr_end) *(ptr++)=val11;
-      if (ptr!=ptr_end) *(ptr++)=val12;
-      if (ptr!=ptr_end) *(ptr++)=val13;
-      if (ptr!=ptr_end) *(ptr++)=val14;
-      return *this;
-    }
-  
-    //! Linear normalization of the pixel values between \a a and \a b.
-    /**
-       \param a = minimum pixel value after normalization.
-       \param b = maximum pixel value after normalization.
-       \see get_normalize(), cut(), get_cut().
-    **/
-    CImg& normalize(const T& a,const T& b) {
-      cimg_test(*this,"CImg<T>::normalize");
-      const CImgStats st(*this,false);
-      if (st.min==st.max) fill(0);
-      else cimg_map(*this,ptr,T) *ptr=(T)((*ptr-st.min)/(st.max-st.min)*(b-a)+a);
-      return *this;
-    }
-
-    //! Return the image of normalized values.
-    /**
-       \param a = minimum pixel value after normalization.
-       \param b = maximum pixel value after normalization.
-       \see normalize(), cut(), get_cut().
-    **/
-    CImg get_normalize(const T& a,const T& b) const { return CImg<T>(*this).normalize(a,b); }
-  
-    //! Cut pixel values between \a a and \a b.
-    /**
-       \param a = minimum pixel value after cut.
-       \param b = maximum pixel value after cut.
-       \see get_cut(), normalize(), get_normalize().
-    **/
-    CImg& cut(const T& a, const T& b) {
-      cimg_test(*this,"CImg<T>::cut");
-      cimg_map(*this,ptr,T) *ptr = (*ptr<a)?a:((*ptr>b)?b:*ptr);
-      return *this;
-    }
-
-    //! Return the image of cutted values.
-    /**
-       \param a = minimum pixel value after cut.
-       \param b = maximum pixel value after cut.
-       \see cut(), normalize(), get_normalize().
-    **/
-    CImg get_cut(const T& a, const T& b) const { return CImg<T>(*this).cut(a,b); }
-
-    //! Quantify pixel values into \n levels.
-    /**
-       \param n = number of quantification levels
-       \see get_quantify().
-    **/
-    CImg& quantify(const unsigned int n=256) {
-      cimg_test(*this,"CImg<T>::quantify");
-      const CImgStats st(*this,false);
-      const double range = st.max-st.min;
-      cimg_map(*this,ptr,T) *ptr = (T)(st.min + range*(int)((*ptr-st.min)*(int)n/range)/n);
-      return *this;
-    }
-
-    //! Return a quantified image, with \n levels.
-    /**
-       \param n = number of quantification levels
-       \see quantify().
-    **/
-    CImg get_quantify(const unsigned int n=256) const { return CImg<T>(*this).quantify(n); }
-
-    //! Threshold the image.
-    /**
-       \param thres = threshold
-       \see get_threshold().
-    **/	
-    CImg& threshold(const T& thres) {
-      cimg_test(*this,"CImg<T>::threshold");
-      cimg_map(*this,ptr,T) *ptr = *ptr<=thres?(T)0:(T)1;
-      return *this;
-    }
-
-    //! Return a thresholded image.
-    /**
-       \param thres = threshold.
-       \see threshold().
-    **/
-    CImg get_threshold(const T& thres) const { return CImg<T>(*this).threshold(thres); }
-  
-    //! Return a rotated image.
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \note Returned image will probably have a different size than the instance image *this.
-       \see rotate()
-    **/
-    CImg get_rotate(const float angle,const unsigned int cond=2) const {
-      cimg_test(*this,"CImg<T>::get_rotate");
-      CImg dest;
-      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
-        ca=(float)std::cos(rad), sa=(float)std::sin(rad);
-    
-      if (cond!=1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
-        const int iangle = (int)nangle/90;
-        switch (iangle) {
-        case 1: {
-          dest = CImg<T>(height,width,depth,dim); 
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(y,height-1-x,z,v); 
-        } break; 
-        case 2: {
-          dest = CImg<T>(width,height,depth,dim);
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v); 
-        } break;
-        case 3: {
-          dest = CImg<T>(height,width,depth,dim); 
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-y,x,z,v); 
-        } break;
-        default: 
-          return *this;        
-        }
-      } else { // generic version
-        const float 
-          ux  = (float)(std::fabs(width*ca)),  uy  = (float)(std::fabs(width*sa)),
-          vx  = (float)(std::fabs(height*sa)), vy  = (float)(std::fabs(height*ca)),
-          w2  = 0.5f*width,           h2  = 0.5f*height,
-          dw2 = 0.5f*(ux+vx),         dh2 = 0.5f*(uy+vy);
-        dest = CImg<T>((int)(ux+vx), (int)(uy+vy),depth,dim);
-
-        switch (cond) {
-        case 0: { 
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = dirichlet_pix2d((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),(int)(h2 - (x-dw2)*sa + (y-dh2)*ca),z,v);
-        } break;
-        case 1: {
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = (*this)(cimg::mod((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),width),
-                                    cimg::mod((int)(h2 - (x-dw2)*sa + (y-dh2)*ca),height),z,v);
-        } break;
-        default: {
-          cimg_mapXY(dest,x,y) {
-            const float X = w2 + (x-dw2)*ca + (y-dh2)*sa, Y = h2 - (x-dw2)*sa + (y-dh2)*ca;
-            const int ix = (int)X, iy = (int)Y;
-            if (ix<0 || ix>=dimx() || iy<0 || iy>=dimy()) cimg_mapZV(*this,z,v) dest(x,y,z,v) = 0;
-            else cimg_mapZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v);
-          }
-        } break; 
-        }
-      }
-      return dest;
-    }
-  
-    //! Rotate the image 
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \see get_rotate()
-    **/
-    CImg& rotate(const float angle,const unsigned int cond=2) { return get_rotate(angle,cond).swap(*this); }
-  
-    //! Return a rotated image around the point (\c cx,\c cy).
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cx = X-coordinate of the rotation center.
-       \param cy = Y-coordinate of the rotation center.
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \see rotate()
-    **/
-    CImg get_rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=2) const {
-      cimg_test(*this,"CImg<T>::get_rotate");
-      CImg dest(*this,false);
-      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
-        ca=(float)std::cos(rad)/zoom, sa=(float)std::sin(rad)/zoom;
-    
-      if (cond!=1 && zoom==1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
-        const int iangle = (int)nangle/90;
-        switch (iangle) {
-        case 1: {
-          dest.fill(0);
-          const unsigned int
-            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
-            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
-            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
-            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
-          cimg_mapZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
-            dest(x,y,z,v) = (*this)(y-yoff,height-1-x+xoff,z,v);
-        } break;
-        case 2: {
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v); 
-        } break;
-        case 3: {
-          dest.fill(0);
-          const unsigned int
-            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
-            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
-            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
-            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
-          cimg_mapZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
-            dest(x,y,z,v) = (*this)(width-1-y+yoff,x-xoff,z,v);
-        } break;
-        default: 
-          return *this;        
-        }
-      } else 
-        switch (cond) { // generic version
-        case 0: { 
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = dirichlet_pix2d((int)(cx + (x-cx)*ca + (y-cy)*sa),(int)(cy - (x-cx)*sa + (y-cy)*ca),z,v);
-        } break;
-        case 1: {
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = (*this)(cimg::mod((int)(cx + (x-cx)*ca + (y-cy)*sa),width),
-                                    cimg::mod((int)(cy - (x-cx)*sa + (y-cy)*ca),height),z,v);
-        } break;
-        default: {
-          cimg_mapXY(dest,x,y) {
-            const float X = cx + (x-cx)*ca + (y-cy)*sa, Y = cy - (x-cx)*sa + (y-cy)*ca;
-            const int ix = (int)X, iy = (int)Y;
-            if (ix<0 || ix>=dimx() || iy<0 || iy>=dimy()) cimg_mapZV(*this,z,v) dest(x,y,z,v) = 0;
-            else cimg_mapZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v);
-          }
-        } break; 
-        }
-      return dest;
-    }
-  
-    //! Rotate the image around the point (\c cx,\c cy).
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cx = X-coordinate of the rotation center.
-       \param cy = Y-coordinate of the rotation center.
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \note Rotation does not change the image size. If you want to get an image with a new size, use get_rotate() instead.
-       \see get_rotate()
-    **/
-    CImg& rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=2) {
-      return get_rotate(angle,cx,cy,zoom,cond).swap(*this);
-    }
- 
-    //! Return a resized image.
-    /**
-       \param pdx = Number of columns (new size along the X-axis).
-       \param pdy = Number of rows (new size along the Y-axis).
-       \param pdz = Number of slices (new size along the Z-axis).
-       \param pdv = Number of vector-channels (new size along the V-axis).
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg get_resize(const int pdx=-100,const int pdy=-100,const int pdz=-100,const int pdv=-100,const unsigned int interp=1) const {
-      cimg_test(*this,"CImg<T>::get_resize");
-      const unsigned int 
-	dx = pdx<0?-pdx*width/100:pdx,
-	dy = pdy<0?-pdy*height/100:pdy,
-	dz = pdz<0?-pdz*depth/100:pdz, 
-	dv = pdv<0?-pdv*dim/100:pdv;
-      CImg res(dx?dx:1,dy?dy:1,dz?dz:1,dv?dv:1);
-      if (width==res.width && height==res.height && depth==res.depth && dim==res.dim) return *this;
-      switch (interp) {
-      case 0:                 // 0 filling
-        {
-          unsigned int w = cimg::min(dx,width), h = cimg::min(dy,height), d = cimg::min(dz,depth), v = cimg::min(dv,dim);
-          T *ptr = data;
-          w*=sizeof(T);
-          res.fill(0);
-          for (unsigned int k=0; k<v; k++) for (unsigned int z=0; z<d; z++) for (unsigned int y=0; y<h; y++) {
-            std::memcpy(res.ptr(0,y,z,k),ptr,w); ptr+=width; 
-          }
-        }
-        break;
-      case 1:               // bloc interpolation
-        {
-          const float sx = (float)width/res.width, sy = (float)height/res.height, sz = (float)depth/res.depth, sk = (float)dim/res.dim;
-          float cx,cy,cz,ck=0;
-          cimg_mapV(res,k) { cz = 0; 
-            cimg_mapZ(res,z) { cy = 0; 
-              cimg_mapY(res,y) { cx = 0; 
-                cimg_mapX(res,x) { res(x,y,z,k) = (*this)((unsigned int)cx,(unsigned int)cy,(unsigned int)cz,(unsigned int)ck); cx+=sx;
-                } cy+=sy;
-              } cz+=sz;
-            } ck+=sk;
-          }
-        }
-        break;
-      case 2:               // mosaic filling
-        {
-          cimg_mapXYZV(res,x,y,z,k) res(x,y,z,k) = (*this)(x%width,y%height,z%depth,k%dim);
-        }
-        break;
-      case 3:               // linear interpolation
-        {
-          const float
-            sx = res.width>1?(float)(width-1)/(res.width-1):0,
-            sy = res.height>1?(float)(height-1)/(res.height-1):0,
-            sz = res.depth>1?(float)(depth-1)/(res.depth-1):0,
-            sk = res.dim>1?(float)(dim-1)/(res.dim-1):0;
-          float cx,cy,cz,ck = 0;
-          cimg_mapV(res,k) { cz = 0; 
-            cimg_mapZ(res,z) { cy = 0;
-              cimg_mapY(res,y) { cx = 0; 
-                cimg_mapX(res,x) { res(x,y,z,k) = (T)linear_pix4d(cx,cy,cz,ck); cx+=sx;
-                } cy+=sy;
-              } cz+=sz;
-            } ck+=sk;
-          }
-        }
-        break;
-      case 4:              // grid filling
-        {
-          const float sx = (float)width/res.width, sy = (float)height/res.height, sz = (float)depth/res.depth, sk = (float)dim/res.dim;
-          res.fill(0);
-          cimg_mapXYZV(*this,x,y,z,k) res((int)(x/sx),(int)(y/sy),(int)(z/sz),(int)(k/sk)) = (*this)(x,y,z,k);
-        }
-        break;
-      case 5:             // cubic interpolation
-        {
-          const float
-            sx = res.width>1?(float)(width-1)/(res.width-1):0,
-            sy = res.height>1?(float)(height-1)/(res.height-1):0,
-            sz = res.depth>1?(float)(depth-1)/(res.depth-1):0,
-            sk = res.dim>1?(float)(dim-1)/(res.dim-1):0;
-          float cx,cy,cz,ck = 0;
-          cimg_mapV(res,k) { cz = 0;
-            cimg_mapZ(res,z) { cy = 0;
-              cimg_mapY(res,y) { cx = 0;
-                cimg_mapX(res,x) { res(x,y,z,k) = (T)cubic_pix2d(cx,cy,(int)cz,(int)ck); cx+=sx;
-                } cy+=sy;
-              } cz+=sz;
-            } ck+=sk;
-          }
-        }
-        break;      
-      }
-      return res;
-    }
-    //! Return a resized image.
-    /**
-       \param src = Image giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    template<typename t> CImg get_resize(const CImg<t>& src,const unsigned int interp=1) const {
-      return get_resize(src.width,src.height,src.depth,src.dim,interp); 
-    }  
-
-    //! Return a resized image.
-    /**
-       \param disp = Display giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg get_resize(const CImgDisplay& disp,const unsigned int interp=1) const {
-      return get_resize(disp.width,disp.height,depth,dim,interp);
-    }
-
-    //! Resize the image.
-    /**
-       \param pdx = Number of columns (new size along the X-axis).
-       \param pdy = Number of rows (new size along the Y-axis).
-       \param pdz = Number of slices (new size along the Z-axis).
-       \param pdv = Number of vector-channels (new size along the V-axis).
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).       
-    **/
-    CImg& resize(const int pdx=-100,const int pdy=-100,const int pdz=-100,const int pdv=-100,const unsigned int interp=1) {
-      const unsigned int
-        dx = pdx<0?-pdx*width/100 :(pdx==0?1:pdx),
-        dy = pdy<0?-pdy*height/100:(pdy==0?1:pdy),
-        dz = pdz<0?-pdz*depth/100 :(pdz==0?1:pdz),
-        dv = pdv<0?-pdv*dim/100   :(pdv==0?1:pdv);
-      if (width==dx && height==dy && depth==dz && dim==dv) return *this;
-      else return get_resize(dx,dy,dz,dv,interp).swap(*this);
-    }
-
-    //! Resize the image.
-    /**
-       \param src = Image giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    template<typename t> CImg& resize(const CImg<t>& src,const unsigned int interp=1) { 
-      return resize(src.width,src.height,src.depth,src.dim,interp); 
-    }
-
-    //! Resize the image
-    /**
-       \param disp = Display giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg& resize(const CImgDisplay& disp,const unsigned int interp=1) {
-      return resize(disp.width,disp.height,depth,dim,interp);
-    }
-
-    //! Return an half-resized image, using a special filter.
-    /**
-       \see resize_halfXY(), resize(), get_resize().
-    **/
-    CImg get_resize_halfXY() const {
-      cimg_test(*this,"CImg<T>::get_resize_halfXY");
-      const CImg<float> mask(3,3);
-      mask.fill(0.07842776544f, 0.1231940459f, 0.07842776544f,
-                0.1231940459f,  0.1935127547f, 0.1231940459f,
-                0.07842776544f, 0.1231940459f, 0.07842776544f);
-      CImg_3x3(I,float);
-      CImg dest(width/2,height/2,depth,dim);
-      cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) dest(x/2,y/2,z,k) = (T)cimg_conv3x3(I,mask);
-      return dest;
-    }
-
-    //! Half-resize the image, using a special filter
-    /**
-       \see get_resize_halfXY(), resize(), get_resize().
-    **/
-    CImg& resize_halfXY() {	return get_resize_halfXY().swap(*this); }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param v0 = V-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param v1 = V-coordinate of the lower-right crop rectangle corner.
-       \see crop()
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
-		  const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1) const {
-      cimg_test(*this,"CImg<T>::get_crop");
-      if (x0>=width || x1>=width || y0>=height || y1>=height || z0>=depth || z1>=depth || v0>=dim || v1>=dim || x1<x0 || y1<y0 || z1<z0 || v1<v0)
-        throw CImgArgumentException("CImg<%s>::get_crop() : Bad crop coordinates (%u,%u,%u,%u)-(%u,%u,%u,%u) in image (%u,%u,%u,%u)",
-                                    pixel_type(),x0,y0,z0,v0,x1,y1,z1,v1,width,height,depth,dim);
-      const unsigned int dx=x1-x0+1, dy=y1-y0+1, dz=z1-z0+1, dv=v1-v0+1;
-      CImg dest(dx,dy,dz,dv);
-      T *psrc = ptr(x0,y0,z0,v0), *pdest = dest.ptr(0,0,0,0);
-      if (dx!=width)
-        for (unsigned int k=0; k<dv; k++) {
-          for (unsigned int z=0; z<dz; z++) {
-            for (unsigned int y=0; y<dy; y++) {
-              std::memcpy(pdest,psrc,dx*sizeof(T));
-              pdest+=dx;
-              psrc+=width;
-            }
-            psrc+=width*(height-dy);
-          }
-          psrc+=width*height*(depth-dz);
-        }
-      else {
-        if (dy!=height)         
-          for (unsigned int k=0; k<dv; k++) {
-            for (unsigned int z=0; z<dz; z++) {
-              std::memcpy(pdest,psrc,dx*dy*sizeof(T));
-              pdest+=dx*dy;
-              psrc+=width*height;
-            }
-            psrc+=width*height*(depth-dz);
-          }
-        else {
-          if (dz!=depth)
-            for (unsigned int k=0; k<dv; k++) {
-              std::memcpy(pdest,psrc,dx*dy*dz*sizeof(T));
-              pdest+=dx*dy*dz;
-              psrc+=width*height*depth;
-            }
-          else std::memcpy(pdest,psrc,dx*dy*dz*dv*sizeof(T));
-        }
-      }
-      return dest;
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \see crop()   
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
-		  const unsigned int x1,const unsigned int y1,const unsigned int z1) const {
-      return get_crop(x0,y0,z0,0,x1,y1,z1,dim-1);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \see crop()   
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,
-		  const unsigned int x1,const unsigned int y1) const {
-      return get_crop(x0,y0,0,0,x1,y1,depth-1,dim-1);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \see crop()   
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int x1) const { return get_crop(x0,0,0,0,x1,height-1,depth-1,dim-1); }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param v0 = V-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param v1 = V-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
-	       const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1) {
-      return get_crop(x0,y0,z0,v0,x1,y1,z1,v1).swap(*this);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
-	       const unsigned int x1,const unsigned int y1,const unsigned int z1) {
-      return crop(x0,y0,z0,0,x1,y1,z1,dim-1);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,
-	       const unsigned int x1,const unsigned int y1) { return crop(x0,y0,0,0,x1,y1,depth-1,dim-1); }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int x1) { return crop(x0,0,0,0,x1,height-1,depth-1,dim-1); }
-
-    //! Get the channel \a v of the current image, as a new image.
-    /**
-       \param v0 = vector-channel to return.
-       \see channel(), get_slice(), slice(), get_plane(), plane().
-    **/
-    CImg get_channel(const unsigned int v0=0) const { return get_crop(0,0,0,v0,width-1,height-1,depth-1,v0); }
-
-    //! Get the z-slice \a z of *this, as a new image.
-    /**
-       \param z0 = Z-slice to return.
-       \see slice(), get_channel(), channel(), get_plane(), plane().
-    **/
-    CImg get_slice(const unsigned int z0=0) const { return get_crop(0,0,z0,0,width-1,height-1,z0,dim-1); }
-
-    //! Get the z-slice \a z of the channel \a v of the current image, as a new image.
-    /**
-       \param z0 = Z-slice of the plane to return.
-       \param v0 = V-channel of the plane to return.
-       \see plane(), get_channel(), channel(), get_slice(), slice().
-    **/
-    CImg get_plane(const unsigned int z0=0,const unsigned int v0=0) const { return get_crop(0,0,z0,v0,width-1,height-1,z0,v0); }
-
-    //! Return a reference to a set of points (x0->x1,y0,z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_pointset(const unsigned int xmin,const unsigned int xmax,const unsigned int y0=0,const unsigned int z0=0,const unsigned int v0=0) const {
-      cimg_test(*this,"CImg<T>::ref_pointset");
-      if (xmax<xmin || xmax>=width || y0>=height || z0>=depth || v0>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_pointset() : Cannot return a reference (%u->%u,%u,%u,%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),xmin,xmax,y0,z0,v0,width,height,depth,dim);
-      return CImgROI<T>(1+xmax-xmin,1,1,1,ptr(xmin,y0,z0,v0));
-    }
-
-    //! Return a reference to a set of lines (y0->y1,z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_lineset(const unsigned int ymin,const unsigned int ymax,const unsigned int z0=0,const unsigned int v0=0) const {
-      cimg_test(*this,"CImg<T>::ref_lineset");
-      if (ymax<ymin || ymax>=height || z0>=depth || v0>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_lineset() : Cannot return a reference (0->%u,%u->%u,%u,%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),width-1,ymin,ymax,z0,v0,width,height,depth,dim);
-      return CImgROI<T>(width,1+ymax-ymin,1,1,ptr(0,ymin,z0,v0));
-    }
-  
-    //! Return a reference to a set of planes (z0->z1,v0) of the image. Use it carefully !
-    CImgROI<T> ref_planeset(const unsigned int zmin,const unsigned int zmax,const unsigned int v0=0) const {
-      cimg_test(*this,"CImg<T>::ref_planeset");
-      if(zmax<zmin || zmax>=depth || v0>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_planeset() : Cannot return a reference (0->%u,0->%u,%u->%u,%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),width-1,height-1,zmin,zmax,v0,width,height,depth,dim);
-      return CImgROI<T>(width,height,1+zmax-zmin,1,ptr(0,0,zmin,v0));
-    }
-
-    //! Return a reference to a set of channels (v0->v1) of the image. Use it carefully !
-    CImgROI<T> ref_channelset(const unsigned int vmin,const unsigned int vmax) const {
-      cimg_test(*this,"CImg<T>::ref_channelset");
-      if (vmax<vmin || vmax>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_channelset() : Cannot return a reference (0->%u,0->%u,0->%u,%u->%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),width-1,height-1,depth-1,vmin,vmax,width,height,depth,dim);
-      return CImgROI<T>(width,height,depth,1+vmax-vmin,ptr(0,0,0,vmin));
-    }
-  
-    //! Return a reference to a line (y0,z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_line(const unsigned int y0,const unsigned int z0=0,const unsigned int v0=0) const { return ref_pointset(0,width-1,y0,z0,v0); }
-
-    //! Return a reference to a plane (z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_plane(const unsigned int z0,const unsigned int v0=0) const { return ref_lineset(0,height-1,z0,v0); }
-
-    //! Return a reference to a channel (v0) of the image. Use it carefully !
-    CImgROI<T> ref_channel(const unsigned int v0) const { return ref_planeset(0,depth-1,v0); }
-
-    //! Replace the image by one of its channel
-    CImg& channel(const unsigned int v0=0) { return get_channel(v0).swap(*this); }
-
-    //! Replace the image by one of its z-slice
-    CImg& slice(const unsigned int z0=0) { return get_slice(z0).swap(*this); }
-
-    //! Replace the image by one of its plane
-    CImg& plane(const unsigned int z0=0, const unsigned int v0=0) { return get_plane(z0,v0).swap(*this); }
-  
-    //! Flip an image along the specified axis
-    CImg& flip(const char axe='x') {
-      cimg_test(*this,"CImg<T>::flip");
-      T *pf,*pb,*buf=NULL;
-      switch (axe) {
-      case 'x':
-        {
-          pf = ptr(); pb = ptr(width-1);
-          for (unsigned int yzv=0; yzv<height*depth*dim; yzv++) { 
-            for (unsigned int x=0; x<width/2; x++) { const T val = *pf; *(pf++)=*pb; *(pb--)=val; }
-            pf+=width-width/2;
-            pb+=width+width/2;
-          }
-        }
-        break;
-      case 'y':
-        {
-          buf = new T[width];
-          pf = ptr(); pb = ptr(0,height-1);
-          for (unsigned int zv=0; zv<depth*dim; zv++) {
-            for (unsigned int y=0; y<height/2; y++) {
-              std::memcpy(buf,pf,width*sizeof(T));
-              std::memcpy(pf,pb,width*sizeof(T));
-              std::memcpy(pb,buf,width*sizeof(T));
-              pf+=width;
-              pb-=width;
-            }
-            pf+=width*(height-height/2);
-            pb+=width*(height+height/2);
-          }
-        }
-        break;
-      case 'z':
-        {
-          buf = new T[width*height];
-          pf = ptr(); pb = ptr(0,0,depth-1);
-          cimg_mapV(*this,v) {
-            for (unsigned int z=0; z<depth/2; z++) {
-              std::memcpy(buf,pf,width*height*sizeof(T));
-              std::memcpy(pf,pb,width*height*sizeof(T));
-              std::memcpy(pb,buf,width*height*sizeof(T));
-              pf+=width*height;
-              pb-=width*height;
-            }
-            pf+=width*height*(depth-depth/2);
-            pb+=width*height*(depth+depth/2);
-          }
-        }
-        break;
-      case 'v':
-        {
-          buf = new T[width*height*depth];
-          pf = ptr(); pb = ptr(0,0,0,dim-1);
-          for (unsigned int v=0; v<dim/2; v++) {
-            std::memcpy(buf,pf,width*height*depth*sizeof(T));
-            std::memcpy(pf,pb,width*height*depth*sizeof(T));
-            std::memcpy(pb,buf,width*height*depth*sizeof(T));
-            pf+=width*height*depth;
-            pb-=width*height*depth;
-          }
-        }
-        break;
-      default: cimg::warn(true,"CImg<%s>::flip() : unknow axe '%c', should be 'x','y','z' or 'v'",pixel_type(),axe);
-      }
-      if (buf) delete[] buf;
-      return *this;
-    }
-    //! Get a flipped version of the image, along the specified axis
-    CImg get_flip(const char axe='x') { return CImg<T>(*this).flip(axe); }
-    
-    //! Return a 2D representation of a 3D image, with three slices.
-    CImg get_3dplanes(const unsigned int px0,const unsigned int py0,const unsigned int pz0) const {
-      cimg_test(*this,"CImg<T>::get_3dplanes");
-      const unsigned int
-        x0=(px0>=width)?width-1:px0,
-        y0=(py0>=height)?height-1:py0,
-        z0=(pz0>=depth)?depth-1:pz0;
-      CImg res(width+depth,height+depth,1,dim);
-      res.fill((*this)[0]);
-      { cimg_mapXYV(*this,x,y,k) res(x,y,0,k)        = (*this)(x,y,z0,k); }
-      { cimg_mapYZV(*this,y,z,k) res(width+z,y,0,k)  = (*this)(x0,y,z,k); }
-      { cimg_mapXZV(*this,x,z,k) res(x,height+z,0,k) = (*this)(x,y0,z,k); }
-      return res;
-    }
-
-    //! Return the histogram of the image
-    CImg<float> get_histogram(const unsigned int nblevels=256,const T val_min=(T)0,const T val_max=(T)0) const {
-      cimg_test(*this,"CImg<T>::get_histogram");
-      if (nblevels<1) {
-        throw CImgArgumentException("CImg<%s>::get_histogram() : Can't compute an histogram with %u levels",
-                                    pixel_type(),nblevels);
-      }
-      T vmin=val_min,vmax=val_max;
-      CImg<float> res(nblevels,1,1,1,0);
-      if (vmin==vmax && vmin==0) { CImgStats st(*this,false); vmin = (T)st.min; vmax = (T)st.max; }
-      cimg_map(*this,ptr,T) { const int pos = (int)((*ptr-vmin)*(nblevels-1)/(vmax-vmin)); if (pos>=0 && pos<(int)nblevels) res[pos]++; }
-      return res;
-    }
-
-    //! Equalize the image histogram
-    CImg& equalize_histogram(const unsigned int nblevels=256) {
-      cimg_test(*this,"CImg<T>::equalize_histogram");
-      CImgStats st(*this,false);
-      CImg<float> hist = get_histogram(nblevels,(T)st.min,(T)st.max);
-      float cumul=0;
-      cimg_mapX(hist,pos) { cumul+=hist[pos]; hist[pos]=cumul; }
-      cimg_map(*this,ptr,T) {
-        unsigned int pos = (unsigned int)((*ptr-st.min)*nblevels/(1+st.max-st.min));
-        *ptr = (T)(st.min + (st.max-st.min)*hist[pos]/size());
-      }
-      return *this;
-    }
-    //! Return the histogram-equalized version of the current image.
-    CImg get_equalize_histogram(const unsigned int nblevels=256) const { return CImg<T>(*this).equalize_histogram(nblevels); }
-
-    //! Return the image of the vector norms of the current image.
-    CImg<float> get_norm_pointwise(int ntype=2) const {
-      cimg_test(*this,"CImg<T>::get_norm_pointwise");
-      CImg<float> res(width,height,depth);
-      switch(ntype) {
-      case -1:                // Linf norm
-        {
-          cimg_mapXYZ(*this,x,y,z) {
-            float n=0; cimg_mapV(*this,v) if (std::fabs((double)((*this)(x,y,z,v)))>n) n=(float)(*this)(x,y,z,v); res(x,y,z) = n;
-          }
-        } break;
-      case 1:               // L1 norm
-        {
-          cimg_mapXYZ(*this,x,y,z) {
-            float n=0; cimg_mapV(*this,v) n+=(float)std::fabs((double)((*this)(x,y,z,v))); res(x,y,z) = n;
-          }
-        } break;
-      default:              // L2 norm
-        {
-          cimg_mapXYZ(*this,x,y,z) {
-            float n=0; cimg_mapV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v)); res(x,y,z) = (float)std::sqrt((double)n);
-          }
-        } break;
-      }
-      return res;
-    }
-
-    //! Replace each pixel value with its vector norm
-    CImg& norm_pointwise() { return CImg<T>(get_norm_pointwise()).swap(*this); }
-
-    //! Return an image of the normalized vectors
-    CImg get_orientation_pointwise() const {
-      cimg_test(*this,"CImg<T>::get_orientation_pointwise");
-      CImg dest(width,height,depth,dim);
-      cimg_mapXYZ(dest,x,y,z) {
-        float n = 0;
-        cimg_mapV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v));
-        n = (float)std::sqrt((double)n);
-        if (n>0) cimg_mapV(dest,v) dest(x,y,z,v)=(T)((*this)(x,y,z,v)/n); else cimg_mapV(dest,v) dest(x,y,z,v)=0;
-      }
-      return dest;
-    }
-
-    //! Replace each pixel value with its normalized vector component
-    CImg& orientation_pointwise() { return get_orientation_pointwise().swap(*this); }
-
-    //! Split current image into a list.
-    /**
-       - Splitting process is done along the specified dimension \c Axe.
-    **/
-    CImgl<T> get_split(const char axe='v',const unsigned int nb=0) const {
-      cimg_test(*this,"CImg<T>::get_split");
-      const char naxe = cimg::uncase(axe);
-      if (naxe!='x' && naxe!='y' && naxe!='z' && naxe!='v')
-	throw CImgArgumentException("CImg<%s>::get_split() : Unknow axe '%c', use rather 'x','y','z' or 'v'",pixel_type(),axe);
-      CImgl<T> res;
-      switch (naxe) {
-      case 'x':
-	res = CImgl<T>(nb?nb:width);
-	cimgl_map(res,l) res[l] = get_crop(l*width/res.size,0,0,0,(l+1)*width/res.size-1,height-1,depth-1,dim-1);
-	break;
-      case 'y':
-	res = CImgl<T>(nb?nb:height);
-	cimgl_map(res,l) res[l] = get_crop(0,l*height/res.size,0,0,width-1,(l+1)*height/res.size-1,depth-1,dim-1);
-	break;
-      case 'z':
-	res = CImgl<T>(nb?nb:depth);
-	cimgl_map(res,l) res[l] = get_crop(0,0,l*depth/res.size,0,width-1,height-1,(l+1)*depth/res.size-1,dim-1);
-	break;
-      case 'v':
-	res = CImgl<T>(nb?nb:dim);
-	cimgl_map(res,l) res[l] = get_crop(0,0,0,l*dim/res.size,width-1,height-1,depth-1,(l+1)*dim/res.size-1);
-	break;
-      }
-      return res;
-    }
-
-    //! Return a list of images, corresponding to the XY-gradients of an image.
-    CImgl<T> get_gradientXY(const int scheme=0) const {
-      cimg_test(*this,"CImg<T>::get_gradientXY");
-      CImgl<T> res(2,width,height,depth,dim);
-      CImg_3x3(I,T);
-      switch(scheme) {
-      case -1: { // backward finite differences
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) { res[0](x,y,z,k) = Icc-Ipc; res[1](x,y,z,k) = Icc-Icp; } 
-      } break;
-      case 1: { // forward finite differences
-        cimg_mapZV(*this,z,k) cimg_map2x2(*this,x,y,z,k,I) { res[0](x,y,0,k) = Inc-Icc; res[1](x,y,z,k) = Icn-Icc; }
-      } break;
-      case 2: { // using Sobel mask
-        const float a = 1, b = 2;
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = (T)(-a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn);
-          res[1](x,y,z,k) = (T)(-a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn);
-        }
-      } break;
-      case 3: { // using rotation invariant mask
-        const float a = (float)(0.25*(2-std::sqrt(2.0))), b = (float)(0.5f*(std::sqrt(2.0)-1));
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = (T)(-a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn);
-          res[1](x,y,z,k) = (T)(-a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn);
-        }
-      } break;
-      case 0:   
-      default: { // central finite differences
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) { 
-          res[0](x,y,z,k) = (T)(0.5*(Inc-Ipc));
-          res[1](x,y,z,k) = (T)(0.5*(Icn-Icp)); 
-        } 
-      } break;
-      }
-      return res;
-    }
-
-    //! Return a list of images, corresponding to the XYZ-gradients of an image.
-    CImgl<T> get_gradientXYZ(const int scheme=0) const {
-      cimg_test(*this,"CImg<T>::get_gradientXYZ");
-      CImgl<T> res(3,width,height,depth,dim);
-      CImg_3x3x3(I,T);
-      switch(scheme) {
-      case -1: { // backward finite differences
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) { 
-          res[0](x,y,z,k) = Iccc-Ipcc;
-          res[1](x,y,z,k) = Iccc-Icpc;
-          res[2](x,y,z,k) = Iccc-Iccp; 
-        }
-      } break;
-      case 1: { // forward finite differences
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = Incc-Iccc; 
-          res[1](x,y,z,k) = Icnc-Iccc;
-          res[2](x,y,z,k) = Iccn-Iccc; 
-        } 
-      } break;
-      case 0: 
-      default: { // central finite differences
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = (T)(0.5*(Incc-Ipcc));
-          res[1](x,y,z,k) = (T)(0.5*(Icnc-Icpc)); 
-          res[2](x,y,z,k) = (T)(0.5*(Iccn-Iccp)); 
-        } 
-      } break;
-      }
-      return res;
-    }
-
-    //@}
-    //--------------------------------------
-    //--------------------------------------
-    //
-    //! \name Color conversion functions
-    //@{
-    //--------------------------------------
-    //--------------------------------------
-  
-    //! Convert color pixels from (R,G,B) to (X,Y,Z)_709.
-    CImg& RGBtoXYZ() {
-      cimg_test(*this,"CImg<T>::RGBtoXYZ");
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoXYZ() : Input image dimension is dim=%u, should be a (R,G,B) image (dim=3)",
-                                              pixel_type(),dim);
-      cimg_mapXYZ(*this,x,y,z) {
-        const T R = (*this)(x,y,z,0), G = (*this)(x,y,z,1), B = (*this)(x,y,z,2);
-        (*this)(x,y,z,0) = (T)(0.412453*R + 0.357580*G + 0.180423*B);
-        (*this)(x,y,z,1) = (T)(0.212671*R + 0.715160*G + 0.072169*B);
-        (*this)(x,y,z,2) = (T)(0.019334*R + 0.119193*G + 0.950227*B);
-      }
-      return *this;
-    }
-    //! Get a new image with (X,Y,Z) color-based pixels from a (R,G,B) image.
-    CImg get_RGBtoXYZ() const { return CImg<T>(*this).RGBtoXYZ(); }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (R,G,B) color space.
-    CImg& XYZtoRGB() {
-      cimg_test(*this,"CImg<T>::XYZtoRGB");
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoRGB() : Input image dimension is dim=%u, should be a (X,Y,Z) image (dim=3)",
-                                              pixel_type(),dim);
-      cimg_mapXYZ(*this,x,y,z) {
-        const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
-        (*this)(x,y,z,0) = (T)(3.240479*X  - 1.537150*Y - 0.498535*Z);
-        (*this)(x,y,z,1) = (T)(-0.969256*X + 1.875992*Y + 0.041556*Z);
-        (*this)(x,y,z,2) = (T)(0.055648*X  - 0.204043*Y + 1.057311*Z);
-      }
-      return *this;
-    }
-    //! Get a new image with (R,G,B) color-based pixels from a (X,Y,Z) image.
-    CImg get_XYZtoRGB() const { return CImg<T>(*this).XYZtoRGB(); }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (L*,a*,b*) color space.
-    CImg& XYZtoLab() {
-      cimg_test(*this,"CImg<T>::XYZtoLab");
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoLab() : Input image dimension is dim=%u, should be a (X,Y,Z) image (dim=3)",
-                                              pixel_type(),dim);
-      CImg<double> white = CImg<double>(1,1,1,3).fill(1,1,1).RGBtoXYZ();
-      const double Xn = white(0), Yn = white(1), Zn = white(2);
-    
-      cimg_mapXYZ(*this,x,y,z) {
-        const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
-        const double L = (T)(116*std::pow(Y/Yn,1/3.0)-16);
-        (*this)(x,y,z,0) = (T)(L>=0?L:0);
-        (*this)(x,y,z,1) = (T)(500*(std::pow(X/Xn,1/3.0)-std::pow(Y/Yn,1/3.0)));
-        (*this)(x,y,z,2) = (T)(200*(std::pow(Y/Yn,1/3.0)-std::pow(Z/Zn,1/3.0)));
-      }
-      return *this;
-    }
-    //! Get a new image with (L,a,b) color-based pixels from a (X,Y,Z) image.
-    CImg get_XYZtoLab() const { return CImg<T>(*this).XYZtoLab(); }
-
-    //@}
-    //--------------------------------------
-    //--------------------------------------
-    //
-    //! \name Drawing functions
-    //@{
-    //--------------------------------------
-    //--------------------------------------
-  
-    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0,\c z0).
-    /**
-       \param x0 = X-coordinate of the vector-valued pixel to plot.
-       \param y0 = Y-coordinate of the vector-valued pixel to plot.
-       \param z0 = Z-coordinate of the vector-valued pixel to plot.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_point(const int x0,const int y0,const int z0,
-                     const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_point");
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_point() : specified color is (null)",pixel_type());
-      if (x0>=0 && y0>=0 && z0>=0 && x0<dimx() && y0<dimy() && z0<dimz()) {
-        const T *col=color;
-        const unsigned int whz = width*height*depth;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        T *ptrd = ptr(x0,y0,z0,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = *(col++); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd=(T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whz; }
-      }
-      return *this;
-    }
-
-    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0).
-    /**
-       \param x0 = X-coordinate of the vector-valued pixel to plot.
-       \param y0 = Y-coordinate of the vector-valued pixel to plot.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_point(const int x0,const int y0,const T *const color,const float opacity=1) { 
-      return draw_point(x0,y0,0,color,opacity); 
-    }
-
-    //! Draw a 2D colored line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = A long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
-                    const T *const color,const unsigned long pattern=~0L,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_line"); 
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : specified color is (null)",pixel_type());
-      const T* col=color;
-      unsigned long hatch=1;     
-      int nx0=x0, nx1=x1, ny0=y0, ny1=y1;
-      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (nx1<0 || nx0>=dimx()) return *this;
-      if (nx0<0) { ny0-=nx0*(ny1-ny0)/(nx1-nx0); nx0=0; }
-      if (nx1>=dimx()) { ny1+=(nx1-dimx())*(ny0-ny1)/(nx1-nx0); nx1=dimx()-1;}
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (ny1<0 || ny0>=dimy()) return *this;
-      if (ny0<0) { nx0-=ny0*(nx1-nx0)/(ny1-ny0); ny0=0; }
-      if (ny1>=dimy()) { nx1+=(ny1-dimy())*(nx0-nx1)/(ny1-ny0); ny1=dimy()-1;}
-      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),ny1-ny0), whz = width*height*depth;
-      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0;
-      float x = (float)nx0, y = (float)ny0;
-      if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) {
-        if (!(~pattern) || (~pattern && pattern&hatch)) {
-          T* ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);      
-          cimg_mapV(*this,k) { *ptrd=*(col++); ptrd+=whz; }
-          col-=dim;
-        }
-        x+=px; y+=py; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
-      } else {
-        const float nopacity = cimg::abs(opacity), copacity=1-cimg::max(opacity,0.0f);
-        for (unsigned int t=0; t<=dmax; t++) {
-          if (!(~pattern) || (~pattern && pattern&hatch)) {
-            T* ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-            cimg_mapV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
-            col-=dim;
-          }
-          x+=px; y+=py; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
-        }
-      }
-      return *this;
-    }
-  
-    //! Draw a 3D colored line in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param z0 = Z-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param Z1 = Z-coordinate of the ending point of the line.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = A long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_line(const int x0,const int y0,const int z0,const int x1,const int y1,const int z1,
-                    const T *const color,const unsigned long pattern=~0L,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_line"); 
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : specified color is (null)",pixel_type());
-      const T* col=color;
-      unsigned long hatch=1;
-      int nx0=x0, ny0=y0, nz0=z0, nx1=x1, ny1=y1, nz1=z1;
-      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-      if (nx1<0 || nx0>=dimx()) return *this;
-      if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; nz0-=nx0*(nz1-nz0)/D; nx0=0; }
-      if (nx1>=dimx()) { const int d=nx1-dimx(), D=nx1-nx0; ny1+=d*(ny0-ny1)/D; nz1+=d*(nz0-nz1)/D; nx1=dimx()-1;}
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-      if (ny1<0 || ny0>=dimy()) return *this;
-      if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; nz0-=ny0*(nz1-nz0)/D; ny0=0; }
-      if (ny1>=dimy()) { const int d=ny1-dimy(), D=ny1-ny0; nx1+=d*(nx0-nx1)/D; nz1+=d*(nz0-nz1)/D; ny1=dimy()-1;}
-      if (nz0>nz1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-      if (nz1<0 || nz0>=dimz()) return *this;
-      if (nz0<0) { const int D=nz1-nz0; nx0-=nz0*(nx1-nx0)/D; ny0-=nz0*(ny1-ny0)/D; nz0=0; }
-      if (nz1>=dimz()) { const int d=nz1-dimz(), D=nz1-nz0; nx1+=d*(nx0-nx1)/D; ny1+=d*(ny0-ny1)/D; nz1=dimz()-1;}
-      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),std::abs(ny1-ny0),nz1-nz0), whz = width*height*depth;
-      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0, pz = dmax?(nz1-nz0)/(float)dmax:0;
-      float x = (float)nx0, y = (float)ny0, z = (float)nz0;
-      if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) { 
-        if (!(~pattern) || (~pattern && pattern&hatch)) {
-          T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
-          cimg_mapV(*this,k) { *ptrd=*(col++); ptrd+=whz; }        
-          col-=dim; 
-        }
-        x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
-      } else {
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        for (unsigned int t=0; t<=dmax; t++) { 
-          if (!(~pattern) || (~pattern && pattern&hatch)) {
-            T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
-            cimg_mapV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
-            col-=dim; 
-          }
-          x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));        
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D textured line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param texture = a colored texture image used to draw the line color.
-       \param tx0 = X-coordinate of the starting point of the texture.
-       \param ty0 = Y-coordinate of the starting point of the texture.
-       \param tx1 = X-coordinate of the ending point of the texture.
-       \param ty1 = Y-coordinate of the ending point of the texture.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = a long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
-                                         const CImg<t>& texture,
-                                         const int tx0,const int ty0,const int tx1,const int ty1,
-                                         const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_line"); cimg_test(texture,"CImg<T>::draw_line");
-      if (texture.dim<dim)
-        throw CImgArgumentException("CImg<%s>::draw_line() : texture has %u channel while image has %u channels",texture.dim,dim);
-      int nx0=x0, ny0=y0, nx1=x1, ny1=y1, ntx0=tx0, nty0=ty0, ntx1=tx1, nty1=ty1;
-      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-      if (nx1<0 || nx0>=dimx()) return *this;
-      if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; ntx0-=nx0*(ntx1-ntx0)/D; nty0-=nx0*(nty1-nty0)/D; nx0=0; }
-      if (nx1>=dimx()) { const int d=nx1-dimx(),D=nx1-nx0; ny1+=d*(ny0-ny1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; nx1=dimx()-1; }
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-      if (ny1<0 || ny0>=dimy()) return *this;
-      if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; ntx0-=ny0*(ntx1-ntx0)/D; nty0-=ny0*(nty1-nty0)/D; ny0=0; }
-      if (ny1>=dimy()) { const int d=ny1-dimy(),D=ny1-ny0; nx1+=d*(nx0-nx1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; ny1=dimy()-1; }
-      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),ny1-ny0), 
-        whz = width*height*depth, twhz = texture.width*texture.height*texture.depth;
-      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0,
-        tpx = dmax?(ntx1-ntx0)/(float)dmax:0, tpy = dmax?(nty1-nty0)/(float)dmax:0;
-      float x = (float)nx0, y = (float)ny0, tx = (float)ntx0, ty = (float)nty0;
-      if (opacity>=1) for (unsigned int tt=0; tt<=dmax; tt++) { 
-        T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-        t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
-        cimg_mapV(*this,k) { *ptrd = (T)(*ptrs); ptrd+=whz; ptrs+=twhz; }
-        x+=px; y+=py; tx+=tpx; ty+=tpy;
-      } else {
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        for (unsigned int tt=0; tt<=dmax; tt++) { 
-          T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-          t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
-          cimg_mapV(*this,k) { *ptrd = (T)(nopacity*(*ptrs) + copacity*(*ptrd)); ptrd+=whz; ptrs+=twhz; }
-          x+=px; y+=py; tx+=tpx; ty+=tpy;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D colored arrow in the instance image, at coordinates (\c x0,\c y0)->(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the arrow (tail).
-       \param y0 = Y-coordinate of the starting point of the arrow (tail).
-       \param x1 = X-coordinate of the ending point of the arrow (head).
-       \param y1 = Y-coordinate of the ending point of the arrow (head).
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param angle = aperture angle of the arrow head
-       \param length = length of the arrow head. If <0, described as a percentage of the arrow length.
-       \param pattern = a long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_arrow(const int x0,const int y0,const int x1,const int y1,
-                     const T *const color,
-                     const float angle=30,const float length=-10,const unsigned long pattern=~0L,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_arrow");
-      const float u = (float)(x0-x1), v = (float)(y0-y1), sq = u*u+v*v,
-        deg = (float)(angle*cimg::PI/180), ang = (sq>0)?(float)std::atan2(v,u):0.0f,
-        l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
-      if (sq>0) {
-        const double cl = std::cos(ang-deg), sl = std::sin(ang-deg), cr = std::cos(ang+deg), sr = std::sin(ang+deg);        
-        const int 
-          xl = x1+(int)(l*cl), yl = y1+(int)(l*sl),
-          xr = x1+(int)(l*cr), yr = y1+(int)(l*sr),
-          xc = x1+(int)((l+1)*(cl+cr))/2, yc = y1+(int)((l+1)*(sl+sr))/2;
-        draw_line(x0,y0,xc,yc,color,pattern,opacity).draw_triangle(x1,y1,xl,yl,xr,yr,color,opacity);
-      } else draw_point(x0,y0,color,opacity);
-      return *this;
-    }
-
-    //! Draw a sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
-    /**
-       \param sprite = sprite image.
-       \param x0 = X-coordinate of the sprite position in the instance image.
-       \param y0 = Y-coordinate of the sprite position in the instance image.
-       \param z0 = Z-coordinate of the sprite position in the instance image.
-       \param v0 = V-coordinate of the sprite position in the instance image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t> CImg& draw_image(const CImg<t>& sprite,
-                                          const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image");
-      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-      const int 
-        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-      const t *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
-        (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
-      const unsigned int
-        offX = width-lX, soffX = sprite.width-lX,
-        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          for (int z=0; z<lZ; z++) {
-            for (int y=0; y<lY; y++) {
-              if (opacity>=1) for (int x=0; x<lX; x++) *(ptrd++) = (T)(*(ptrs++));
-              else for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
-              ptrd+=offX; ptrs+=soffX;
-            }
-            ptrd+=offY; ptrs+=soffY;
-          }
-          ptrd+=offZ; ptrs+=soffZ;
-        }
-      return *this;
-    }
-
-#if ( !defined(_MSC_VER) || _MSC_VER>1200 )
-    CImg& draw_image(const CImg<T>& sprite,const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image");
-      if (this==&sprite) return draw_image(CImg<T>(sprite),x0,y0,z0,v0,opacity);
-      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-      const int 
-        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-      const T *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
-        (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
-      const unsigned int
-        offX = width-lX, soffX = sprite.width-lX,
-        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ),
-        slX = lX*sizeof(T);    
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          for (int z=0; z<lZ; z++) {
-            if (opacity>=1) for (int y=0; y<lY; y++) { std::memcpy(ptrd,ptrs,slX); ptrd+=width; ptrs+=sprite.width; }
-            else for (int y=0; y<lY; y++) {
-              for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
-              ptrd+=offX; ptrs+=soffX;
-            }
-            ptrd+=offY; ptrs+=soffY;
-          }
-          ptrd+=offZ; ptrs+=soffZ;
-        }
-      return *this;
-    }
-#endif
-
-    //! Draw a masked sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
-    /**
-       \param sprite = sprite image.
-       \param mask = mask image.
-       \param x0 = X-coordinate of the sprite position in the instance image.
-       \param y0 = Y-coordinate of the sprite position in the instance image.
-       \param z0 = Z-coordinate of the sprite position in the instance image.
-       \param v0 = V-coordinate of the sprite position in the instance image.
-       \param mask_valmax = Maximum pixel value of the mask image \c mask.
-       \param opacity = opacity of the drawing.
-       \note Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
-       \note Clipping is supported.
-       \note Dimensions along x,y and z of \c sprite and \c mask must be the same.
-    **/
-    template<typename ti,typename tm> CImg& draw_image(const CImg<ti>& sprite,const CImg<tm>& mask,
-                                                       const int x0=0,const int y0=0,const int z0=0,const int v0=0,
-                                                       const tm mask_valmax=1,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image"); cimg_test(mask,"CImg<T>::draw_image");
-      if ((void*)this==(void*)&sprite) return draw_image(CImg<T>(sprite),mask,x0,y0,z0,v0);
-      if(mask.width!=sprite.width || mask.height!=sprite.height || mask.depth!=sprite.depth)
-        throw CImgArgumentException("CImg<%s>::draw_image() : mask dimension is (%u,%u,%u,%u), while sprite is (%u,%u,%u,%u)",
-                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,sprite.width,sprite.height,sprite.depth,sprite.dim);
-      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-      const int
-        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),      
-        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);    
-      const int coff = -(bx?x0:0)-(by?y0*mask.dimx():0)-(bz?z0*mask.dimx()*mask.dimy():0)-
-        (bv?v0*mask.dimx()*mask.dimy()*mask.dimz():0),
-        ssize = mask.dimx()*mask.dimy()*mask.dimz();
-      const ti *ptrs = sprite.ptr() + coff;
-      const tm *ptrm = mask.ptr() + coff;
-      const unsigned int
-        offX = width-lX, soffX = sprite.width-lX,
-        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
-      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          ptrm = mask.data + (ptrm - mask.data)%ssize;
-          for (int z=0; z<lZ; z++) {
-            for (int y=0; y<lY; y++) {
-              for (int x=0; x<lX; x++) {
-                const float mopacity = *(ptrm++)*opacity,
-                  nopacity = cimg::abs(mopacity), copacity = mask_valmax-cimg::max(mopacity,0.0f);
-                *(ptrd++) = (T)((nopacity*(*(ptrs++))+copacity*(*ptrd))/mask_valmax);
-              }
-              ptrd+=offX; ptrs+=soffX; ptrm+=soffX;
-            }
-            ptrd+=offY; ptrs+=soffY; ptrm+=soffY;
-          }
-          ptrd+=offZ; ptrs+=soffZ; ptrm+=soffZ;
-        }
-      return *this;
-    }
-
-    //! Draw a 4D filled rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0)-(\c x1,\c y1,\c z1,\c v1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
-       \param v0 = V-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
-       \param v1 = V-coordinate of the lower-right rectangle corner in the instance image.
-       \param val = scalar value used to fill the rectangle area.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int z0,const int v0,
-                         const int x1,const int y1,const int z1,const int v1,
-                         const T& val,float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_rectangle");
-      const bool bx=(x0<x1), by=(y0<y1), bz=(z0<z1), bv=(v0<v1);
-      const int nx0=bx?x0:x1, nx1=bx?x1:x0, ny0=by?y0:y1, ny1=by?y1:y0, nz0=bz?z0:z1, nz1=bz?z1:z0, nv0=bv?v0:v1, nv1=bv?v1:v0;
-      const int 
-        lX = (1+nx1-nx0) + (nx1>=dimx()?dimx()-1-nx1:0) + (nx0<0?nx0:0),
-        lY = (1+ny1-ny0) + (ny1>=dimy()?dimy()-1-ny1:0) + (ny0<0?ny0:0),
-        lZ = (1+nz1-nz0) + (nz1>=dimz()?dimz()-1-nz1:0) + (nz0<0?nz0:0),
-        lV = (1+nv1-nv0) + (nv1>=dimv()?dimv()-1-nv1:0) + (nv0<0?nv0:0);
-      const unsigned int offX = width-lX, offY = width*(height-lY), offZ = width*height*(depth-lZ);
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      T *ptrd = ptr(nx0<0?0:nx0,ny0<0?0:ny0,nz0<0?0:nz0,nv0<0?0:nv0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          for (int z=0; z<lZ; z++) {
-            for (int y=0; y<lY; y++) {
-              if (opacity>=1) {
-                if (sizeof(T)!=1) { for (int x=0; x<lX; x++) *(ptrd++) = val; ptrd+=offX; }
-                else { std::memset(ptrd,(int)val,lX); ptrd+=width; }
-              } else { for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*val+copacity*(*ptrd)); ptrd++; } ptrd+=offX; }
-            }
-            ptrd+=offY;
-          }
-          ptrd+=offZ;
-        }  
-      return *this;
-    }
-
-    //! Draw a 3D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int z0,
-                         const int x1,const int y1,const int z1,
-                         const T *const color,const float opacity=1) {
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_rectangle : specified color is (null)",pixel_type());
-      cimg_mapV(*this,k) draw_rectangle(x0,y0,z0,k,x1,y1,z1,k,color[k],opacity);
-      return *this;
-    }
-
-    //! Draw a 2D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int x1,const int y1,
-                         const T *const color,const float opacity=1) {
-      draw_rectangle(x0,y0,0,x1,y1,depth-1,color,opacity);
-      return *this;
-    }
-  
-    //! Draw a 2D filled colored triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_triangle(const int x0,const int y0,
-                        const int x1,const int y1,
-                        const int x2,const int y2,
-                        const T *const color, const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_triangle"); 
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_triangle : specified color is (null).");
-      const T* col = color;
-      int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,whz=width*height*depth;
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2);
-      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2);
-      if (ny0>=dimy() || ny2<0) return *this;
-      const float 
-        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1);
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      float xleft = (float)nx0, xright = xleft, pleft = (p1<p2)?p1:p2, pright = (p1<p2)?p2:p1;
-      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; }
-
-      const int ya = ny1>dimy()?height:ny1;
-      for (int y=ny0<0?0:ny0; y<ya; y++) {
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<width)?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx = whz-xmax+xmin-1;
-          T *ptrd = ptr(xmin,y,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) { 
-            if (sizeof(T)!=1) { const T& cval=*(col++); for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval; ptrd+=offx; }
-            else { std::memset(ptrd,(int)*(col++),xmax-xmin+1); ptrd+=whz; }
-          } else cimg_mapV(*this,k) {
-            const T& cval=*(col++); 
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity + copacity*(*ptrd)); ptrd++; } 
-            ptrd+=offx;
-          }
-          col-=dim;
-        }
-        xleft+=pleft; xright+=pright;
-      }    
-
-      if (p1<p2) { xleft=(float)nx1;  pleft=p3;  if (ny1<0) xleft-=ny1*pleft; } 
-      else       { xright=(float)nx1; pright=p3; if (ny1<0) xright-=ny1*pright; }
-
-      const int yb = ny2>=dimy()?height-1:ny2;
-      for (int yy=ny1<0?0:ny1; yy<=yb; yy++) {
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<width)?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx=whz-xmax+xmin-1;
-          T *ptrd = ptr(xmin,yy,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) { 
-            if (sizeof(T)!=1) { const T& cval=*(col++); for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval; ptrd+=offx; }
-            else { std::memset(ptrd,(int)*(col++),xmax-xmin+1); ptrd+=whz; }
-          } else cimg_mapV(*this,k) { 
-            const T& cval=*(col++);
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity + copacity*(*ptrd)); ptrd++; }
-            ptrd+=offx; 
-          }
-          col-=dim;
-        }
-        xleft+=pleft; xright+=pright;
-      }    
-      return *this;
-    }
-  
-    //! Draw a 2D textured triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param texture = texture image used to fill the triangle.
-       \param tx0 = X-coordinate of the first corner in the texture image.
-       \param ty0 = Y-coordinate of the first corner in the texture image.
-       \param tx1 = X-coordinate of the second corner in the texture image.
-       \param ty1 = Y-coordinate of the second corner in the texture image.
-       \param tx2 = X-coordinate of the third corner in the texture image.
-       \param ty2 = Y-coordinate of the third corner in the texture image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_triangle(const int x0,const int y0,
-                                             const int x1,const int y1,
-                                             const int x2,const int y2,
-                                             const CImg<t>& texture,
-                                             const int tx0,const int ty0,
-                                             const int tx1,const int ty1,
-                                             const int tx2,const int ty2,
-                                             const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_triangle"); cimg_test(texture,"CImg<T>::draw_triangle");
-      int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,ntx0=tx0,nty0=ty0,ntx1=tx1,nty1=ty1,ntx2=tx2,nty2=ty2,whz=width*height*depth;
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2);
-      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2);
-      if (ny0>=dimy() || ny2<0) return *this;
-      const float 
-        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-        tpx1 = (ny1-ny0)?(ntx1-ntx0)/(float)(ny1-ny0):0,
-        tpy1 = (ny1-ny0)?(nty1-nty0)/(float)(ny1-ny0):0,
-        tpx2 = (ny2-ny0)?(ntx2-ntx0)/(float)(ny2-ny0):0,
-        tpy2 = (ny2-ny0)?(nty2-nty0)/(float)(ny2-ny0):0,
-        tpx3 = (ny2-ny1)?(ntx2-ntx1)/(float)(ny2-ny1):0,
-        tpy3 = (ny2-ny1)?(nty2-nty1)/(float)(ny2-ny1):0;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      float pleft,pright,tpxleft,tpyleft,tpxright,tpyright,
-        xleft=(float)nx0,xright=xleft,txleft=(float)ntx0,tyleft=(float)nty0,txright=txleft,tyright=tyleft;
-      if (p1<p2) { pleft=p1; pright=p2; tpxleft=tpx1; tpyleft=tpy1; tpxright=tpx2; tpyright=tpy2; } 
-      else       { pleft=p2; pright=p1; tpxleft=tpx2; tpyleft=tpy2; tpxright=tpx1; tpyright=tpy1; }
-      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; txleft-=ny0*tpxleft; tyleft-=ny0*tpyleft;
-        txright-=ny0*tpxright; tyright-=ny0*tpyright; }
-      const int ya = ny1<dimy()?ny1:height;
-      for (int y=(ny0<0?0:ny0); y<ya; y++) {
-        const int dx = (int)xright-(int)xleft;
-        const float
-          tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-          tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,        
-          txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-          tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx=whz-xmax+xmin-1;
-          T* ptrd = ptr(xmin,y,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) {
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)texture((unsigned int)tx,(unsigned int)ty,0,k); tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          } else cimg_mapV(*this,k) {
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          }
-        }
-        xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-      }
-
-      if (p1<p2) {
-        xleft=(float)nx1; pleft=p3; txleft=(float)ntx1; tyleft=(float)nty1; tpxleft=tpx3; tpyleft=tpy3;
-        if (ny1<0) { xleft-=ny1*pleft; txleft-=ny1*tpxleft; tyleft-=ny1*tpyleft; }
-      } else { 
-        xright=(float)nx1; pright=p3; txright=(float)ntx1; tyright=(float)nty1; tpxright=tpx3; tpyright=tpy3;
-        if (ny1<0) { xright-=ny1*pright; txright-=ny1*tpxright; tyright-=ny1*tpyright; }
-      }    
-      const int yb = ny2>=dimy()?(height-1):ny2;
-      for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-        const int dx = (int)xright-(int)xleft;
-        const float
-          tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-          tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,        
-          txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-          tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx=whz-xmax+xmin-1;
-          T* ptrd = ptr(xmin,yy,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) { 
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)texture((unsigned int)tx,(unsigned int)ty,0,k); tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          } else cimg_mapV(*this,k) { 
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          }
-        }
-        xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-      }
-      return *this;
-    }
-
-    //! Draw a filled ellipse on the instance image
-    /**
-       \param x0 = X-coordinate of the ellipse center.
-       \param y0 = Y-coordinate of the ellipse center.
-       \param r1 = First radius of the ellipse.
-       \param r2 = Second radius of the ellipse.
-       \param ru = X-coordinate of the orientation vector related to the first radius.
-       \param rv = Y-coordinate of the orientation vector related to the first radius.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_ellipse(const int x0,const int y0,const float r1,const float r2,const float ru,const float rv,
-                       const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_ellipse");
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_ellipse : specified color is (null).",pixel_type());
-      const T* col = color;
-      const float
-        norm = (float)std::sqrt(ru*ru+rv*rv),
-        u = norm>0?ru/norm:1,
-        v = norm>0?rv/norm:0,
-        rmax = cimg::max(r1,r2),
-        l1 = (float)std::pow(rmax/(r1>0?r1:1e-6),2),
-        l2 = (float)std::pow(rmax/(r2>0?r2:1e-6),2),
-        a = l1*u*u + l2*v*v,
-        b = u*v*(l1-l2),
-        c = l1*v*v + l2*u*u,
-        nopacity = cimg::abs(opacity),
-        copacity = 1-cimg::max(opacity,0.0f);
-      const int
-        yb = (int)std::sqrt(a*rmax*rmax/(a*c-b*b)),
-        ymin = (y0-yb<0)?0:(y0-yb),
-        ymax = (1+y0+yb>=dimy())?height-1:(1+y0+yb),
-        whz = width*height*depth;
-      for (int y=ymin; y<=ymax; y++) {
-        const float
-          Y = (float)(y-y0),
-          delta = b*b*Y*Y-a*(c*Y*Y-rmax*rmax);
-        if (delta>=0) {
-          int xmin = (int)(x0-(b*Y+std::sqrt(delta))/a), xmax = (int)(x0-(b*Y-std::sqrt(delta))/a);
-          if (xmin<0) xmin=0;
-          if (xmax>=dimx()) xmax=dimx()-1;
-          if (xmin<=xmax) {
-            const int offx = whz-xmax+xmin-1;
-            T *ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) {
-              if (sizeof(T)!=1) cimg_mapV(*this,k) {
-                const T& cval=*(col++); 
-                for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval;
-                ptrd+=offx;
-              } else cimg_mapV(*this,k) {
-                std::memset(ptrd,(int)*(col++),xmax-xmin+1);
-                ptrd+=whz; 
-              }
-            } else cimg_mapV(*this,k) {
-              const T& cval=*(col++);
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity+copacity*(*ptrd)); ptrd++; }
-              ptrd+=offx;
-            }
-            col-=dim;
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a filled circle on the instance image
-    /**
-       \param x0 = X-coordinate of the circle center.
-       \param y0 = Y-coordinate of the circle center.
-       \param r = radius of the circle.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_circle(const int x0,const int y0,float r,const T *const color,const float opacity=1) {
-      return draw_ellipse(x0,y0,r,r,1,0,color,opacity);
-    }
-  
-    // Create an auto-cropped font (along the X axis) from a input font \p font.
-    static CImgl<T> get_cropfont(const CImgl<T>& font,const unsigned int padding=2) {
-      CImgl<T> res;
-      cimgl_map(font,l) {
-        int xmin=font[l].width, xmax = 0;
-        cimg_mapXY(font[l],x,y) if (font[l](x,y)) { if (x<xmin) xmin=x; if (x>xmax) xmax=x; }
-        if (xmin>xmax) res.insert(font[l]);
-        else {
-          res.insert(CImg<T>(xmax-xmin+1+padding,font[l].height,1,font[l].dim,0));
-          cimg_mapYV(res[l],y,k) for (int x=xmin; x<=xmax; x++) res[l](x-xmin,y,0,k) = font[l](x,y,0,k);
-        }
-      }
-      return res;
-    }
-  
-    //! Return a copy of the default 7x11 CImg font as a list of images and masks.
-    /**
-       \param fixed_size = compute fixed or variable character size
-    **/
-    static CImgl<T> get_font7x11(const bool fixed_size = false) {
-      CImgl<T> font(32,1,1,1,3);
-      font.insert(CImgl<T>(224,7,11,1,3)).insert(CImgl<T>(32,1,1,1,1)).insert(CImgl<T>(224,7,11,1,1));
-      for (unsigned int i=0, off=0, boff=(unsigned int)(1<<31); i<256; i++) for (unsigned int j=0; j<font[i].width*font[i].height; j++) {
-        font[256+i](j) = font[i](j,0,0) = font[i](j,0,1) = font[i](j,0,2) = (cimg::font7x11[off]&boff)?(T)1:(T)0;
-        if (!(boff>>=1)) { boff=(unsigned int)(1<<31); off++; }
-      }
-      if (!fixed_size) return get_cropfont(font,2);
-      return font;
-    }
-
-    //! Draw a text into the instance image.
-    /**
-       \param text = a C-string containing the text to display.
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
-       \param font = List of font characters used for the drawing.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-       \see get_font7x11().
-    **/
-    template<typename t> CImg& draw_text(const char *const text,
-                                         const int x0,const int y0,
-                                         const T *const fgcolor,const T *const bgcolor,
-                                         const CImgl<t>& font,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_text");
-      int x=x0, y=y0;
-      CImg letter;
-      for (int i=0; i<cimg::strlen(text); i++) {
-        const unsigned char c = text[i];
-        switch (c) {
-        case '\n': y+=font[' '].height; x=x0; break;
-        case '\t': x+=4*font[' '].width; break;
-        default: if (c<font.size) {
-            letter = font[c];
-            const CImg& mask = (c+256)<(int)font.size?font[c+256]:font[c];
-            if (fgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++) if (mask(p)) cimg_mapV(*this,k) letter(p,0,0,k)=(T)(letter(p,0,0,k)*fgcolor[k]);
-            if (bgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++) if (!mask(p)) cimg_mapV(*this,k) letter(p,0,0,k)=bgcolor[k];
-            if (!bgcolor && font.size>=512) draw_image(letter,mask,x,y,0,0,(T)1,opacity); else draw_image(letter,x,y,0,0,opacity);
-            x+=letter.width;
-          }
-          break;
-        }
-      }
-      return *this;
-    }
-
-
-    //! Draw a text into the instance image.
-    /**
-       \param text = a C-string containing the text to display.
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-       \see get_font7x11().
-    **/
-    CImg& draw_text(const char *const text,
-                    const int x0,const int y0,
-                    const T *const fgcolor=NULL,const T *const bgcolor=NULL,
-                    const float opacity=1) {
-      static bool first = true;
-      static CImgl<T> default_font;
-      if (first) { default_font = get_font7x11(); first = false; }
-      return draw_text(text,x0,y0,fgcolor,bgcolor,default_font,opacity);
-    }
-  
-    //! Draw a text into the instance image.
-    /**
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
-       \param opacity = opacity of the drawing.
-       \param format = a 'printf'-style format, followed by arguments.
-       \note Clipping is supported.
-       \see get_font7x11().
-    **/
-    CImg& draw_text(const int x0,const int y0,
-                    const T *const fgcolor,const T *const bgcolor,
-                    const float opacity,const char *format,...) {
-      char tmp[2048]; 
-      va_list ap;
-      va_start(ap,format);
-      std::vsprintf(tmp,format,ap);
-      va_end(ap);
-      return draw_text(tmp,x0,y0,fgcolor,bgcolor,opacity);
-    }
-    template<typename t> CImg& draw_text(const int x0,const int y0,
-                                         const T *const fgcolor,const T *const bgcolor,
-                                         const CImgl<t>& font, const float opacity, const char *format,...) {
-      char tmp[2048]; va_list ap; va_start(ap,format); std::vsprintf(tmp,format,ap); va_end(ap);
-      return draw_text(tmp,x0,y0,fgcolor,bgcolor,font);
-    }
-  
-    //! Draw a vector field in the instance image.
-    /**
-       \param flow = a 2d image of 2d vectors used as input data.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sampling = length (in pixels) between each arrow.
-       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
-       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t> 
-    CImg& draw_quiver(const CImg<t>& flow,const T *const color,const unsigned int sampling=25,const float factor=-20,
-                      const int quiver_type=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_quiver"); cimg_test(flow,"CImg<T>::draw_quiver");
-      if (!color) 
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified color is (null)",pixel_type());
-      if (sampling<=0)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : incorrect sampling value = %g",pixel_type(),sampling);
-      if (flow.dim!=2)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified flow has invalid dimensions (%u,%u,%u,%u)",
-                                    pixel_type(),flow.width,flow.height,flow.depth,flow.dim);
-      float vmax,fact;
-      if (factor<=0) {
-        CImgStats st(flow.get_norm_pointwise(2),false);
-        vmax = (float)cimg::max(std::fabs(st.min),std::fabs(st.max));
-        fact = -factor;
-      } else { fact = factor; vmax = 1; }
-
-      for (unsigned int y=sampling/2; y<height; y+=sampling)
-        for (unsigned int x=sampling/2; x<width; x+=sampling) {
-          const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
-          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
-          if (!quiver_type) {
-            const int xx = x+(int)u, yy = y+(int)v;
-            draw_arrow(x,y,xx,yy,color,45.0f,sampling/5.0f,~0L,opacity);
-          } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color,~0L,opacity);
-        }
-      return *this; 
-    }
-
-    //! Draw a vector field in the instance image, using a colormap.
-    /**
-       \param flow = a 2d image of 2d vectors used as input data.
-       \param color = a 2d image of dimv()-D vectors corresponding to the color of each arrow.
-       \param sampling = length (in pixels) between each arrow.
-       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
-       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t1,typename t2>
-      CImg& draw_quiver(const CImg<t1>& flow,const CImg<t2>& color,const unsigned int sampling=25,const float factor=-20,
-                        const int quiver_type=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_quiver"); cimg_test(flow,"CImg<T>::draw_quiver"); cimg_test(color,"CImg<T>::draw_quiver");
-      if (sampling<=0)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : incorrect sampling value = %g",pixel_type(),sampling);
-      if (flow.dim!=2)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified flow has invalid dimensions (%u,%u,%u,%u)",
-                                    pixel_type(),flow.width,flow.height,flow.depth,flow.dim);
-      if (color.width!=flow.width || color.height!=flow.height)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : input color data map=(%u,%u,%u,%u)\
- and data flow=(%u,%u,%u,%u) must have same dimension.",
-                                    color.width,color.height,color.depth,color.data,
-                                    flow.width,flow.height,flow.depth,flow.data);
-      float vmax,fact;
-      if (factor<=0) {
-        CImgStats st(flow.get_norm_pointwise(2),false);
-        vmax = (float)cimg::max(std::fabs(st.min),std::fabs(st.max));
-        fact = -factor;
-      } else { fact = factor; vmax = 1; }
-
-      for (unsigned int y=sampling/2; y<height; y+=sampling)
-        for (unsigned int x=sampling/2; x<width; x+=sampling) {
-          const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
-          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
-          if (!quiver_type) {
-            const int xx = x+(int)u, yy = y+(int)v;
-            draw_arrow(x,y,xx,yy,color.get_vector(X,Y).data,45,sampling/5,~0L,opacity);
-          } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color(X,Y),~0L,opacity);
-        }
-      return *this; 
-    }
-
-    //! Draw a 1D graph on the instance image.
-    /**
-       \param data = an image containing the graph values I = f(x).
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param gtype = define the type of the plot :
-                      - 0 = Plot using linear interpolation (segments).
-		      - 1 = Plot with bars.
-		      - 2 = Plot using cubic interpolation (3-polynomials).
-       \param ymin = lower bound of the y-range.
-       \param ymax = upper bound of the y-range.
-       \param opacity = opacity of the drawing.
-       \note
-         - if \c ymin==ymax==0, the y-range is computed automatically from the input sample.
-       \see draw_axeX(), draw_axeY(), draw_axeXY().
-    **/
-    template<typename t>
-    CImg& draw_graph(const CImg<t>& data,const T *const color,const unsigned int gtype=0,
-                     const double ymin=0,const double ymax=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_graph");
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_graph() : specified color is (null)",pixel_type());
-      T *color1 = new T[dim], *color2 = new T[dim];
-      cimg_mapV(*this,k) { color1[k]=(T)(color[k]*0.6f); color2[k]=(T)(color[k]*0.3f); }
-      CImgStats st;
-      if (ymin==ymax) { st = CImgStats(data,false); cimg::swap(st.min,st.max); } else { st.min = ymin; st.max = ymax; }
-      if (st.min==st.max) { st.min--; st.max++; }
-      const float ca = height>1?(st.max-st.min)/(height-1):0, cb = st.min;
-      const int Y0 = (int)(-cb/ca);
-      int pY=0;
-      cimg_mapoff(data,off) {     
-        const int Y = (int)((data[off]-cb)/ca);
-        switch (gtype) {
-        case 0: // plot with segments
-          if (off>0) draw_line((int)((off-1)*width/data.size()),pY,(int)(off*width/data.size()),Y,color,~0L,opacity);
-          break;
-        case 1: { // plot with bars
-          const unsigned int X = off*width/data.size(), nX = (off+1)*width/data.size()-1;
-          draw_rectangle(X,(int)Y0,nX,Y,color1,opacity);
-	  draw_line(X,Y,X,(int)Y0,color2,~0L,opacity);
-	  draw_line(X,(int)Y0,nX,(int)Y0,Y<=Y0?color2:color,~0L,opacity);
-	  draw_line(nX,Y,nX,(int)Y0,color,~0L,opacity);
-	  draw_line(X,Y,nX,Y,Y<=Y0?color:color2,~0L,opacity);
-        } break;
-        }        
-        pY=Y;
-      }
-      if (gtype==2) { // plot with cubic interpolation
-	const CImgROI<t> ndata(data.size(),1,1,1,data.ptr());
-        cimg_mapX(*this,x) {
-          const int Y = (int)((ndata.cubic_pix1d((float)x*ndata.width/width)-cb)/ca);
-          if (x>0) draw_line(x,pY,x+1,Y,color,~0L,opacity);
-          pY=Y;
-        }
-      }
-      delete[] color1; delete[] color2;
-      return *this;     
-    }
-
-    //! Draw a labelled horizontal axis on the instance image.
-    /** 
-       \param x0 = lower bound of the x-range.
-       \param x1 = upper bound of the x-range.
-       \param y = Y-coordinate of the horizontal axis in the instance image.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precision = precision of the labels.
-       \param opacity = opacity of the drawing.
-       \note if \c precision==0, precision of the labels is automatically computed.
-       \see draw_graph(), draw_axeY(), draw_axeXY().
-    **/
-    CImg& draw_axeX(const double x0,const double x1,const int y,const T *const color,
-		    const double precision=0,const float opacity=1) {
-      if (x0==x1) return *this;
-      if (x0<x1) draw_arrow(0,y,width-1,y,color,30,5,~0L,opacity);
-      else draw_arrow(width-1,y,0,y,color,30,5,~0L,opacity);
-      const int yt = (y+14)<dimy()?(y+3):(y-14);
-      double nprecision=precision;
-      if (precision<=0) { 
-	const double nb_pow = std::floor(std::log10(std::fabs(x1-x0)))-1;
-	nprecision = std::pow(10.0,nb_pow);
-	while ((std::fabs(x1-x0)/nprecision)>(dimx()/40)) nprecision*=2;
-      }
-      const double xmin=x0<x1?x0:x1, xmax=x0<x1?x1:x0,
-	tx0 = cimg::mod(xmin,nprecision)==0?xmin:((xmin+nprecision)-cimg::mod(xmin+nprecision,nprecision)),
-	tx1 = cimg::mod(xmax,nprecision)==0?xmax:((xmax+nprecision)-cimg::mod(xmax+nprecision,nprecision));
-      char txt[32];
-      for (double x=tx0; x<=tx1; x+=nprecision) {
-	std::sprintf(txt,"%g",x);       	
-	const int xi=(int)((x-x0)*(width-1)/(x1-x0)), xt = xi-(int)std::strlen(txt)*3;
-	draw_point(xi,y-1,color,opacity).draw_point(xi,y+1,color,opacity).
-	  draw_text(txt,xt<0?0:xt,yt,color,NULL,opacity);
-      }
-      return *this;
-    }
-
-    //! Draw a labelled vertical axis on the instance image.
-    /** 
-       \param x = X-coordinate of the vertical axis in the instance image.
-       \param y0 = lower bound of the y-range.
-       \param y1 = upper bound of the y-range.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precision = precision of the labels.
-       \param opacity = opacity of the drawing.
-       \note if \c precision==0, precision of the labels is automatically computed.
-       \see draw_graph(), draw_axeX(), draw_axeXY().
-    **/
-    CImg& draw_axeY(const int x,const double y0,const double y1,const T *const color,
-		    const double precision=0,const float opacity=1) {
-      if (y0==y1) return *this;
-      if (y0<y1) draw_arrow(x,0,x,height-1,color,30,5,~0L,opacity);
-      else draw_arrow(x,height-1,x,0,color,30,5,~0L,opacity);
-      double nprecision=precision;
-      if (precision<=0) {
-	const double nb_pow = std::floor(std::log10(std::fabs(y1-y0)))-1;
-	nprecision = std::pow(10.0,nb_pow);
-	while ((std::fabs(y1-y0)/nprecision)>(dimy()/40)) nprecision*=2;
-      }
-      const double ymin=y0<y1?y0:y1, ymax=y0<y1?y1:y0,
-	ty0 = cimg::mod(ymin,nprecision)==0?ymin:((ymin+nprecision)-cimg::mod(ymin+nprecision,nprecision)),
-	ty1 = cimg::mod(ymax,nprecision)==0?ymax:((ymax+nprecision)-cimg::mod(ymax+nprecision,nprecision));
-      char txt[32];
-      for (double y=ty0; y<=ty1; y+=nprecision) {
-	std::sprintf(txt,"%g",y);
-	const int yi = (int)((y-y0)*(height-1)/(y1-y0)), xt = x-(int)std::strlen(txt)*7;
-	draw_point(x-1,yi,color,opacity).draw_point(x+1,yi,color,opacity);
-	if (xt>0) draw_text(txt,xt,yi-5,color,NULL,opacity);
-	else draw_text(txt,x+3,yi-5,color,NULL,opacity);
-      }
-      return *this;
-    }
-
-    //! Draw a labelled coordinate system (X,Y) on the instance image.
-    /** 
-       \param x0 = lower bound of the x-range.
-       \param x1 = upper bound of the x-range.
-       \param y0 = lower bound of the y-range.
-       \param y1 = upper bound of the y-range.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precisionx = precision of the labels along the X-axis.
-       \param precisiony = precision of the labels along the Y-axis.
-       \param opacity = opacity of the drawing.
-       \note if precision==0, precision of the labels along the specified axix is automatically computed.
-       \see draw_graph(), draw_axeX(), draw_axeY().
-    **/
-    CImg& draw_axeXY(const double x0,const double x1,const double y0,const double y1,const T *const color,
-		     const double precisionx=0,const double precisiony=0,const float opacity=1) {
-      if (x0*x1<=0) {
-        const int xz = (int)(-x0*(width-1)/(x1-x0));
-        if (xz>=0 && xz<dimx()) draw_axeY(xz,y0,y1,color,precisiony,opacity);
-      }
-      if (y0*y1<=0) {
-        const int yz = (int)(-y0*(height-1)/(y1-y0));
-        if (yz>=0 && yz<dimy()) draw_axeX(x0,x1,yz,color,precisionx,opacity);
-      }
-      return *this;
-    }
-  
-    // Local class used by function CImg<>::draw_fill()
-    template<typename T1,typename T2> struct _draw_fill {
-      const T1 *const color;
-      const float sigma,opacity;
-      const CImg<T1> value;
-      CImg<T2> region;
-
-      _draw_fill(const CImg<T1>& img,const int x,const int y,const int z,
-                 const T *const pcolor,const float psigma,const float popacity):
-        color(pcolor),sigma(psigma),opacity(popacity),
-        value(img.get_vector(x,y,z)), region(CImg<T2>(img.width,img.height,img.depth).fill((T2)false)) {
-        cimg_test(img,"CImg<T>::draw_fill");
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_fill() : specified color is (null)",img.pixel_type());
-      }
-
-	   _draw_fill& operator=(const _draw_fill& d) {
-			color = d.color;
-			sigma = d.sigma;
-			opacity = d.opacity;
-			value = d.value;
-			region = d.region;
-		}
-
-      bool comp(const CImg<T1>& A,const CImg<T1>& B) const {
-        bool res=true;
-        const T *pA=A.data+A.size();
-        for (const T *pB=B.data+B.size(); res && pA>A.data; res=(cimg::abs(*(--pA)-(*(--pB)))<=sigma) );
-        return res;
-      }
-
-      void fill(CImg<T1>& img,const int x,const int y,const int z) {
-        if (x<0 || x>=img.dimx() || y<0 || y>=img.dimy() || z<0 || z>=img.dimz()) return;
-        if (!region(x,y,z) && comp(value,img.get_vector(x,y,z))) {
-          const T *col=color;
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          int xmin,xmax;
-          if (opacity>=1) cimg_mapV(img,k) img(x,y,z,k)=*(col++);
-          else cimg_mapV(img,k) img(x,y,z,k)=(T1)(*(col++)*opacity+copacity*img(x,y,z,k));
-          col-=img.dim;
-          region(x,y,z) = (T2)true;
-          for (xmin=x-1; xmin>=0 && comp(value,img.get_vector(xmin,y,z)); xmin--) {
-            if (opacity>=1) cimg_mapV(img,k) img(xmin,y,z,k) = *(col++);
-            else cimg_mapV(img,k) img(xmin,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmin,y,z,k)); 
-            col-=img.dim;
-            region(xmin,y,z)=(T2)true;
-          }
-          for (xmax=x+1; xmax<img.dimx() && comp(value,img.get_vector(xmax,y,z)); xmax++) {
-            if (opacity>=1) cimg_mapV(img,k) img(xmax,y,z,k) = *(col++);
-            else cimg_mapV(img,k) img(xmax,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmax,y,z,k));
-            col-=img.dim;
-            region(xmax,y,z)=(T2)true; 
-          }
-          xmin++; xmax--;
-          for (; xmin<=xmax; xmin++) { 
-            fill(img,xmin,y-1,z); 
-            fill(img,xmin,y+1,z);
-            fill(img,xmin,y,z-1); 
-            fill(img,xmin,y,z+1);
-          }
-        }
-      }        
-    };
-
-    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param z = Z-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param region = image that will contain the mask of the filled region mask, as an output.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    template<typename t> CImg& draw_fill(const int x,const int y,const int z,
-                                         const T *const color,CImg<t>& region,const float sigma=0,
-                                         const float opacity=1) {
-      _draw_fill<T,t> F(*this,x,y,z,color,sigma,opacity);
-      F.fill(*this,x,y,z);
-      region = F.region;
-      return *this;
-    }
-
-    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param z = Z-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_fill(const int x,const int y,const int z,const T *const color,const float sigma=0,const float opacity=1) {
-      CImg<bool> tmp;
-      return draw_fill(x,y,z,color,tmp,sigma,opacity);
-    }
-
-    //! Draw a 2D filled region starting from a point (\c x,\c y) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_fill(const int x,const int y,const T *const color,const float sigma=0,const float opacity=1) {
-      CImg<bool> tmp;
-      return draw_fill(x,y,0,color,tmp,sigma,opacity);
-    }
-
-    //! Draw a plasma square in the instance image.
-    /**
-       \param x0 = X-coordinate of the upper-left corner of the plasma.
-       \param y0 = Y-coordinate of the upper-left corner of the plasma.
-       \param x1 = X-coordinate of the lower-right corner of the plasma.
-       \param y1 = Y-coordinate of the lower-right corner of the plasma.
-       \param alpha = Alpha-parameter of the plasma.
-       \param beta = Beta-parameter of the plasma.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_plasma(const int x0,const int y0,const int x1,const int y1,
-                      const double alpha=1.0,const double beta=1.0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_plasma");
-      int nx0=x0,nx1=x1,ny0=y0,ny1=y1;
-      if (nx1<nx0) cimg::swap(nx0,nx1);
-      if (ny1<ny0) cimg::swap(ny0,ny1);
-      if (nx0<0) nx0=0;
-      if (nx1>=dimx()) nx1=width-1;
-      if (ny0<0) ny0=0;
-      if (ny1>=dimy()) ny1=height-1;
-      const int xc = (nx0+nx1)/2, yc = (ny0+ny1)/2, dx=(xc-nx0), dy=(yc-ny0);
-      const double dc = std::sqrt((double)(dx*dx+dy*dy))*alpha + beta;
-      cimg_mapV(*this,k) {
-        if (opacity>=1) {
-          (*this)(xc,ny0,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k)));
-          (*this)(xc,ny1,0,k) = (T)(0.5*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k)));
-          (*this)(nx0,yc,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k)));
-          (*this)(nx1,yc,0,k) = (T)(0.5*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k)));
-          (*this)(xc,yc,0,k)  = (T)(0.25*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
-                                          (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand());
-        } else {
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          (*this)(xc,ny0,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k))*nopacity + copacity*(*this)(xc,ny0,0,k));
-          (*this)(xc,ny1,0,k) = (T)(0.5*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(xc,ny1,0,k));
-          (*this)(nx0,yc,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k))*nopacity + copacity*(*this)(nx0,yc,0,k));
-          (*this)(nx1,yc,0,k) = (T)(0.5*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(nx1,yc,0,k));
-          (*this)(xc,yc,0,k)  = (T)(0.25*(((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
-                                           (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand())*nopacity
-                                    + copacity*(*this)(xc,yc,0,k));
-        }
-      }
-      if (xc!=nx0 || yc!=ny0) { 
-        draw_plasma(nx0,ny0,xc,yc,alpha,beta,opacity);
-        draw_plasma(xc,ny0,nx1,yc,alpha,beta,opacity);
-        draw_plasma(nx0,yc,xc,ny1,alpha,beta,opacity);
-        draw_plasma(xc,yc,nx1,ny1,alpha,beta,opacity); 
-      }
-      return *this;
-    }
-
-    //! Draw a plasma in the instance image.
-    /**
-       \param alpha = Alpha-parameter of the plasma.
-       \param beta = Beta-parameter of the plasma.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_plasma(const double alpha=1.0,const double beta=1.0,const float opacity=1) {
-      return draw_plasma(0,0,width-1,height-1,alpha,beta,opacity);
-    }
-  
-    //! Draw a 1D gaussian kernel in the instance image.
-    template<typename t> CImg& draw_gaussian(const float xc,const double sigma,const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_gaussian");
-      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
-      const double sigma2 = -2*sigma*sigma;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      const T *col = color;
-      const unsigned int whz = width*height*depth;
-      cimg_mapX(*this,x) {
-        const float dx = (x-xc);
-        const double val = std::exp( dx*dx/sigma2 );
-        T *ptrd = ptr(x,0,0,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; } 
-        col-=dim;
-      }
-      return *this;
-    }
-
-    //! Draw a gaussian in a 2d image.
-    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const double sigma,
-                                             const CImg<t> tensor,const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_gaussian"); cimg_test_square(tensor,"CImg<T>::draw_gaussian");
-      if (tensor.width!=2) throw CImgArgumentException("CImg<%s>::draw_gaussian() : gaussian tensor must be a 2x2 matrix, given is (%u,%u,%u,%u)",
-                                                       pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim);
-      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
-      const CImg<t> invT = tensor.get_inverse();
-      const t a=invT(0,0), b=2*invT(1,0), c=invT(1,1);
-      const double sigma2 = -2*sigma*sigma;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      const T *col = color;
-      const unsigned int whz = width*height*depth;
-      cimg_mapXY(*this,x,y) {
-        const float dx = (x-xc), dy = (y-yc);
-        const double val = std::exp( ( a*dx*dx + b*dx*dy + c*dy*dy )/sigma2 );
-        T *ptrd = ptr(x,y,0,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-        col-=dim;
-      }
-      return *this;
-    }
-
-    CImg& draw_gaussian(const float xc,const float yc,const double sigma,const T *const color,const float opacity=1) {
-      return draw_gaussian(xc,yc,sigma,CImg<float>::get_identity_matrix(2),color,opacity);
-    }
-
-    //! Draw a gaussian in a 3d image
-    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const float zc,const double sigma,
-                                             const CImg<t> tensor,const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_gaussian"); cimg_test_square(tensor,"CImg<T>::draw_gaussian");
-      if (tensor.width!=3) throw CImgArgumentException("CImg<%s>::draw_gaussian() : gaussian tensor must be a 3x3 matrix, given is (%u,%u,%u,%u)",
-                                                       pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim);
-      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
-      const CImg<t> invT = tensor.get_inverse();
-      const t a=invT(0,0), b=2*invT(1,0), c=2*invT(2,0), d=invT(1,1), e=2*invT(2,1), f=invT(2,2);
-      const double sigma2 = -2*sigma*sigma;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      const T *col = color;
-      const unsigned int whz = width*height*depth;    
-      cimg_mapXYZ(*this,x,y,z) {
-        const float dx = (x-xc), dy = (y-yc), dz = (z-zc);
-        const double val = std::exp( ( a*dx*dx + b*dx*dy + c*dx*dz + d*dy*dy + e*dy*dz + f*dz*dz )/sigma2 );
-        T *ptrd = ptr(x,y,z,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-        col-=dim;
-      }
-      return *this;
-    }
-
-    CImg& draw_gaussian(const float xc,const float yc,const float zc,const double sigma,const T *const color,const float opacity=1) {
-      return draw_gaussian(xc,yc,zc,sigma,CImg<float>::get_identity_matrix(3),color,opacity);
-    }
-
-    //@}
-    //---------------------------------------
-    //---------------------------------------
-    //
-    //! \name Filtering functions
-    //@{
-    //---------------------------------------
-    //---------------------------------------
-  
-    //! Return the correlation of the image by a mask.
-    template<typename t> CImg get_correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) const {
-      cimg_test_scalar(mask,"CImg<T>::get_correlate");
-      CImg dest(*this,false);
-      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) {
-        // A special optimization is done for 2x2,3x3,4x4,5x5,2x2x2 and 3x3x3 mask (with cond=1)
-        switch (mask.depth) {
-        case 3: {
-          CImg_3x3x3(I,T);
-          if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr3x3x3(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum3x3x3(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr3x3x3(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        case 2: {
-          CImg_2x2x2(I,T);
-          if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr2x2x2(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum2x2x2(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr2x2x2(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        default:
-        case 1:
-          switch (mask.width) {
-          case 5: {
-            CImg_5x5(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr5x5(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum5x5(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr5x5(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;          
-          case 4: {
-            CImg_4x4(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr4x4(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum4x4(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr4x4(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;              
-          case 3: {
-            CImg_3x3(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr3x3(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum3x3(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr3x3(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;   
-          case 2: {
-            CImg_2x2(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr2x2(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum2x2(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr2x2(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;  
-          case 1: dest = mask(0)*(*this); break;
-          }
-        }
-      } else { 
-        // Generic version for other masks      
-        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-        cimg_mapV(*this,v) 
-          if (!weighted_correl) {	// Classical correlation
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                val+= (*this)(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-              dest(x,y,z,v)=(T)val;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= neumann_pix3d(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= dirichlet_pix3d(x+xm,y+ym,z+zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-          } else {	// Weighted correlation
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0, norm = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                const T cval = (*this)(x+xm,y+ym,z+zm,v);
-                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                norm+= cval*cval;
-              }
-              dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = neumann_pix3d(x+xm,y+ym,z+zm,v);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+=cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = dirichlet_pix3d(x+xm,y+ym,z+zm,v,0);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+= cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
-              }
-          }
-      }
-      return dest;
-    }
-    //! Correlate the image by a mask
-    template<typename t> CImg& correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) { 
-      return get_correlate(mask,cond,weighted_correl).swap(*this); 
-    }
-  
-    //! Return the convolution of the image by a mask
-    template<typename t> CImg get_convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) const {
-      cimg_test_scalar(mask,"CImg<T>::get_convolve");
-      CImg dest(*this,false);
-      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) { // optimized version
-        switch (mask.depth) {
-        case 3: {
-          CImg_3x3x3(I,T);
-          if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3x3(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum3x3x3(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv3x3x3(I,mask)/std::sqrt(norm)):(T)0;
-          }
-        } break;
-        case 2: {
-          CImg_2x2x2(I,T);
-          if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2x2(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum2x2x2(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv2x2x2(I,mask)/std::sqrt(norm)):(T)0;
-          }
-        } break;
-        default:
-        case 1:
-          switch (mask.width) {
-          case 5: {
-            CImg_5x5(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv5x5(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum5x5(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv5x5(I,mask)/std::sqrt(norm)):(T)0;
-            }            
-          } break;          
-          case 4: {
-            CImg_4x4(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv4x4(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum4x4(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv4x4(I,mask)/std::sqrt(norm)):(T)0;
-            }
-          } break;              
-          case 3: {
-            CImg_3x3(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum3x3(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv3x3(I,mask)/std::sqrt(norm)):(T)0;
-            }            
-          } break;   
-          case 2: {
-            CImg_2x2(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum2x2(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv2x2(I,mask)/std::sqrt(norm)):(T)0;
-            } 
-          } break;  
-          case 1: dest = mask(0)*(*this); break;
-          }
-        }
-      } else { // generic version
-          
-        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-        cimg_mapV(*this,v) 
-          if (!weighted_convol) {	// Classical convolution
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                val+= (*this)(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-              dest(x,y,z,v)=(T)val;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= neumann_pix3d(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= dirichlet_pix3d(x-xm,y-ym,z-zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-          } else {	// Weighted convolution
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0, norm = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                const T cval = (*this)(x-xm,y-ym,z-zm,v);
-                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                norm+= cval*cval;
-              }
-              dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = neumann_pix3d(x-xm,y-ym,z-zm,v);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+=cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = dirichlet_pix3d(x-xm,y-ym,z-zm,v,0);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+= cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
-              }
-          }
-      }
-      return dest;
-    }
-  
-    //! Convolve the image by a mask
-    template<typename t> CImg& convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) {
-      return get_convolve(mask,cond,weighted_convol).swap(*this); 
-    }
-
-    //! Add noise to the image
-    CImg& noise(const double psigma=-20,const unsigned int ntype=0) {
-      cimg_test(*this,"CImg<T>::noise");
-      double sigma = psigma;
-      static bool first_time = true;
-      if (first_time) { std::srand((unsigned int)::time(NULL)); first_time = false; }
-      CImgStats st;
-      if (sigma==0) return *this;
-      if (sigma<0 || ntype==2) st = CImgStats(*this,false);
-      if (sigma<0) sigma = -sigma*(st.max-st.min)/100.0;
-      switch (ntype) {
-      case 0: { cimg_map(*this,ptr,T) *ptr=(T)(*ptr+sigma*cimg::grand()); } break;    // Gaussian noise
-      case 1: { cimg_map(*this,ptr,T) *ptr=(T)(*ptr+sigma*cimg::crand()); } break;    // Uniform noise
-      case 2: {                                                                       // Salt & Pepper
-        if (st.max==st.min) { st.min=0; st.max=255; }
-        cimg_map(*this,ptr,T) if (cimg::rand()*100<sigma) *ptr=(T)(cimg::rand()<0.5?st.max:st.min);
-      } break;
-      }
-      return *this;
-    }
-    //! Return a noisy image
-    CImg get_noise(const double sigma=-20,const unsigned int ntype=0) const { return CImg<T>(*this).noise(sigma,ntype); }
-
-    //! Apply a deriche filter on the image
-#define cimg_deriche_map(x0,y0,z0,k0,nb,offset,T) {                           \
-    ima = ptr(x0,y0,z0,k0);                                                   \
-    I2 = *ima; ima+=offset; I1 = *ima; ima+=offset;                           \
-    Y2 = *(Y++) = sumg0*I2; Y1 = *(Y++) = g0*I1 + sumg1*I2;                   \
-    for (i=2; i<(nb); i++) { I1 = *ima; ima+=offset;                          \
-        Y0 = *(Y++) = a1*I1 + a2*I2 + b1*Y1 + b2*Y2;                          \
-        I2=I1; Y2=Y1; Y1=Y0; }                                                \
-    ima-=offset; I2 = *ima; Y2 = Y1 = parity*sumg1*I2; *ima = (T)(*(--Y)+Y2); \
-    ima-=offset; I1 = *ima; *ima = (T)(*(--Y)+Y1);                            \
-    for (i=(nb)-3; i>=0; i--) { Y0=a3*I1+a4*I2+b1*Y1+b2*Y2; ima-=offset;      \
-      I2=I1; I1=*ima; *ima=(T)(*(--Y)+Y0); Y2=Y1; Y1=Y0; }                    \
-  }
-
-    CImg& deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) {
-      cimg_test(*this,"CImg<T>::deriche");
-      if (sigma<0 || order<0 || order>2) throw CImgArgumentException("CImg<%s>::deriche() : Bad arguments (sigma=%g, order=%d)",pixel_type(),sigma,order);
-      if (sigma<0.01f) return *this;
-      const float alpha=sigma>0?1.695f/sigma:0,ea=(float)std::exp(alpha),ema=(float)std::exp(-alpha),em2a=ema*ema,b1=2*ema,b2=-em2a;
-      float ek,ekn,parity,a1,a2,a3,a4,g0,sumg1,sumg0;
-      double *Y,Y0,Y1,Y2;
-      int i,offset,nb;
-      T *ima,I1,I2;
-      switch(order) {
-      case 1:                 // first derivative
-        ek = -(1-ema)*(1-ema)*(1-ema)/(2*(ema+1)*ema); a1 = a4 = 0;  a2 = ek*ema; a3 = -ek*ema; parity =-1;\
-        if (cond) { sumg1 = (ek*ea) / ((ea-1)*(ea-1)); g0 = 0; sumg0 = g0+sumg1; } \
-        else g0 = sumg0 = sumg1 = 0;
-        break;
-      case 2:               // second derivative
-        ekn = ( -2*(-1+3*ea-3*ea*ea+ea*ea*ea)/(3*ea+1+3*ea*ea+ea*ea*ea) );
-        ek = -(em2a-1)/(2*alpha*ema); a1 = ekn;  a2 = -ekn*(1+ek*alpha)*ema; a3 = ekn*(1-ek*alpha)*ema; a4 = -ekn*em2a; parity =1;
-        if (cond) { sumg1 = ekn/2; g0 = ekn; sumg0 = g0+sumg1; }
-        else g0=sumg0=sumg1=0;
-        break;
-      default:              // smoothing
-        ek = (1-ema)*(1-ema) / (1+2*alpha*ema - em2a); a1 = ek;  a2 = ek*ema*(alpha-1); a3 = ek*ema*(alpha+1); a4 = -ek*em2a; parity = 1;
-        if (cond) { sumg1 = ek*(alpha*ea+ea-1) / ((ea-1)*(ea-1)); g0 = ek; sumg0 = g0+sumg1; }
-        else  g0=sumg0=sumg1=0;
-        break;
-      }
-      // filter init
-      Y = new double[cimg::max(width,height,depth)];
-      switch(cimg::uncase(axe)) {
-      case 'x': if (width>1)  { offset = 1;            nb = width;  cimg_mapYZV(*this,y,z,k) cimg_deriche_map(0,y,z,k,nb,offset,T); }	break;
-      case 'y': if (height>1) { offset = width;        nb = height; cimg_mapXZV(*this,x,z,k) cimg_deriche_map(x,0,z,k,nb,offset,T); }	break;
-      case 'z': if (depth>1)  { offset = width*height; nb = depth;  cimg_mapXYV(*this,x,y,k) cimg_deriche_map(x,y,0,k,nb,offset,T); }	break;
-      default : cimg::warn(true,"CImg<%s>::deriche() : Unknown axe '%c'",pixel_type(),axe); break;
-      }
-      delete[] Y;
-      return *this;
-    }
-    //! Return the result of the Deriche filter
-    CImg get_deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) const {
-      return CImg<T>(*this).deriche(sigma,order,axe,cond);
-    }
-    //! Blur the image with a Deriche filter (quasi-gaussian filter)
-    CImg& blur(const float sigma=1,const unsigned int cond=1) {
-      cimg_test(*this,"CImg<T>::blur");
-      if (width>1)  deriche(sigma,0,'x',cond);
-      if (height>1) deriche(sigma,0,'y',cond);
-      if (depth>1)  deriche(sigma,0,'z',cond);
-      return *this;
-    }
-    //! Return a blurred version of the image, using a Deriche filter (quasi gaussian filter)
-    CImg get_blur(const float sigma=1,const unsigned int cond=1) const { return CImg<T>(*this).blur(sigma,cond); }
-
-    //! Return a eroded image (\p times erosion).
-    CImg get_erode(const unsigned int n=1) {
-      CImg_3x3x3(I,T);
-      if (n==1) {
-        CImg dest(*this);
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) 
-	  if (Iccc && (!Incc || !Ipcc || !Icnc || !Icpc || !Iccn || !Iccp)) dest(x,y,z,k) = 0;
-        return dest;
-      }
-      CImg img1(*this),img2(*this,false);
-      CImg *src = &img1, *dest = &img2, *tmp = NULL;
-      for (unsigned int iter=0; iter<n; iter++) {
-        *dest = *src;
-        cimg_mapV(*src,k) cimg_map3x3x3(*src,x,y,z,k,I) 
-	  if (Iccc && (!Incc || !Ipcc || !Icnc || !Icpc || !Iccn || !Iccp)) (*dest)(x,y,z,k) = 0;
-        tmp = src;
-        src = dest;
-        dest = tmp;
-      }
-      return *src;      
-    }
-    //! Erode the image \p n times.
-    CImg& erode(const unsigned int n=1) { return get_erode(n).swap(*this); }
-
-    //! Return an dilated image (\p times dilatation).
-    CImg get_dilate(const unsigned int n=1) {
-      CImgStats stats(*this);
-      const T tmax = stats.max!=0?(T)stats.max:(T)1;
-      CImg_3x3x3(I,T);
-      if (n==1) {
-        CImg dest(*this);
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) 
-	  if (!Iccc && (Incc || Ipcc || Icnc || Icpc || Iccn || Iccp)) dest(x,y,z,k) = tmax;
-        return dest;
-      }
-      CImg img1(*this),img2(*this,false);
-      CImg *src = &img1, *dest = &img2, *tmp = NULL;
-      for (unsigned int iter=0; iter<n; iter++) {
-        *dest = *src;
-        cimg_mapV(*src,k) cimg_map3x3x3(*src,x,y,z,k,I) 
-	  if (!Iccc && (Incc || Ipcc || Icnc || Icpc || Iccn || Iccp)) (*dest)(x,y,z,k) = tmax;
-        tmp = src;
-        src = dest;
-        dest = tmp;
-      }
-      return *src;      
-    }
-    //! Dilate the image \p n times.
-    CImg& dilate(const unsigned int n=1) { return get_dilate(n).swap(*this); }
-
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Matrix and vector computation
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1) { return CImg<T>(1,1).fill(a1); }
-    static CImg vector(const T& a1,const T& a2) { return CImg<T>(1,2).fill(a1,a2); }
-    static CImg vector(const T& a1,const T& a2,const T& a3) { return CImg<T>(1,3).fill(a1,a2,a3); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4) { return CImg<T>(1,4).fill(a1,a2,a3,a4); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5) { return CImg<T>(1,5).fill(a1,a2,a3,a4,a5); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) { return CImg<T>(1,6).fill(a1,a2,a3,a4,a5,a6); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7) { return CImg<T>(1,7).fill(a1,a2,a3,a4,a5,a6,a7); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7,const T& a8) { return CImg<T>(1,8).fill(a1,a2,a3,a4,a5,a6,a7,a8); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7,const T& a8,const T& a9) { return CImg<T>(1,9).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9); }
-
-    //! Return a square matrix with specified coefficients
-    static CImg matrix(const T& a1) { return vector(a1); }
-    static CImg matrix(const T& a1,const T& a2,
-		       const T& a3,const T& a4) { return CImg<T>(2,2).fill(a1,a2,a3,a4); }
-    static CImg matrix(const T& a1,const T& a2,const T& a3,
-		       const T& a4,const T& a5,const T& a6,
-		       const T& a7,const T& a8,const T& a9) { return CImg<T>(3,3).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9); }
-    static CImg matrix(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7,const T& a8,
-		       const T& a9,const T& a10,const T& a11,const T& a12,
-		       const T& a13,const T& a14,const T& a15,const T& a16) {
-      return CImg<T>(4,4).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);
-    }
-
-    //! Return a diffusion tensor with specified coefficients
-    static CImg tensor(const T& a1) { return matrix(a1); }
-    static CImg tensor(const T& a1,const T& a2,const T& a3) { return matrix(a1,a2,a2,a3); }
-    static CImg tensor(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) {
-      return matrix(a1,a2,a3,a2,a4,a5,a3,a5,a6);
-    }
-
-    //! Return a diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1) { return matrix(a1); }
-    static CImg diagonal(const T& a1,const T& a2) { return matrix(a1,0,0,a2); }
-    static CImg diagonal(const T& a1,const T& a2,const T& a3) { return matrix(a1,0,0,0,a2,0,0,0,a3); }
-    static CImg diagonal(const T& a1,const T& a2,const T& a3,const T& a4) { return matrix(a1,0,0,0,0,a2,0,0,0,0,a3,0,0,0,0,a4); }
-
-    //! Operator* (matrix product)
-    template<typename t> CImg operator*(const CImg<t>& img) const {
-      cimg_test_matrix(*this,"CImg<T>::operator*");
-      cimg_test_matrix(img,"CImg<T>::operator*");
-      if (width!=img.height) 
-        throw CImgArgumentException("CImg<%s>::operator*() : can't multiply a matrix *this = (%ux%u) by a matrix (%ux%u)",
-                                    pixel_type(),width,height,img.width,img.height);
-      CImg res(img.width,height);
-      double val;
-      cimg_mapXY(res,i,j) { val=0; cimg_mapX(*this,k) val+=(*this)(k,j)*img(i,k); res(i,j) = (T)val; }
-      return res;
-    }
-    //! Operator*= (matrix product)
-    template<typename t> CImg& operator*=(const CImg<t>& img) { return ((*this)*img).swap(*this); }
-  
-    //! Return a new image corresponding to the vector located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_vector(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
-      CImg dest(dim);
-      cimg_mapV(*this,k) dest[k]=(*this)(x,y,z,k);
-      return dest;
-    }
-  
-    //! Return a new image corresponding to the \a square \a matrix located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_matrix(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
-      const int n = (int)std::sqrt((double)dim);
-      CImg dest(n,n);
-      cimg_mapV(*this,k) dest[k]=(*this)(x,y,z,k);
-      return dest;
-    }
-  
-    //! Return a new image corresponding to the \a diffusion \a tensor located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_tensor(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {      
-      if (dim==6) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2),
-				(*this)(x,y,z,3),(*this)(x,y,z,4),(*this)(x,y,z,5));
-      if (dim==3) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2));
-      return tensor((*this)(x,y,z,0));
-    }
-
-    //! Set the image \p vec as the \a vector \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_vector(const CImg& vec,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      return draw_point(x,y,z,vec.data,1);
-    }
-    //! Set the image \p vec as the \a square \a matrix-valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_matrix(const CImg& mat,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      return set_vector(mat,x,y,z);
-    }
-    //! Set the image \p vec as the \a tensor \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_tensor(const CImg& ten,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      if (ten.height==2) {
-        (*this)(x,y,z,0)=ten[0];
-        (*this)(x,y,z,1)=ten[1];
-        (*this)(x,y,z,2)=ten[3];
-      }
-      else {
-        (*this)(x,y,z,0)=ten[0];
-        (*this)(x,y,z,1)=ten[1];
-        (*this)(x,y,z,2)=ten[2];
-        (*this)(x,y,z,3)=ten[4];
-        (*this)(x,y,z,4)=ten[5];
-        (*this)(x,y,z,5)=ten[8];
-      }
-      return *this;
-    }
-    //! Set the current matrix to be the identity matrix.
-    CImg& identity_matrix() {    
-      cimg_test_square(*this,"CImg<T>::identity_matrix");
-      fill(0);
-      cimg_mapX(*this,x) (*this)(x,x) = (T)1;
-      return *this;
-    }
-    //! Return a matrix \p dim * \p dim equal to \p factor * \a Identity.
-    static CImg get_identity_matrix(const unsigned int dim) {
-      return CImg<T>(dim,dim).identity_matrix();
-    }
-  
-    //! Return the transpose version of the current matrix.
-    CImg get_transpose() const {
-      cimg_test_matrix(*this,"CImg<T>::get_transpose");
-      CImg res(height,width);
-      cimg_mapXY(res,x,y) res(x,y) = (*this)(y,x);
-      return res;
-    }
-    //! Replace the current matrix by its transpose.
-    CImg& transpose() { return get_transpose().swap(*this); }
-
-    //! Get a diagonal matrix, whose diagonal coefficients are the coefficients of the input image
-    CImg get_diagonal() const {
-      cimg_test(*this,"CImg<T>::get_diagonal");
-      CImg res(size(),size(),1,1,0);
-      cimg_mapoff(*this,off) res(off,off)=(*this)(off);
-      return res;
-    }
-    //! Replace a vector by a diagonal matrix containing the original vector coefficients.
-    CImg& diagonal() { return get_diagonal().swap(*this); }
-
-    //! Inverse the current matrix.
-    CImg& inverse() {
-      cimg_test_square(*this,"CImg<T>::inverse");
-      switch (width) {
-      case 2:
-        {
-          const double 
-            a = data[0], c = data[1],
-            b = data[2], d = data[3],
-            dete = det();
-          if (dete) { 
-            data[0] = (T)(d/dete);  data[1] = (T)(-c/dete);
-            data[2] = (T)(-b/dete), data[3] = (T)(a/dete); 
-          } else {
-            cimg::warn(true,"CImg<%s>::inverse() : Matrix determinant is 0, can't invert matrix",pixel_type());
-            fill(0);
-          }
-        }
-        break;
-      case 3:
-        {
-          const double
-            a = data[0], d = data[1], g = data[2],
-            b = data[3], e = data[4], h = data[5],
-            c = data[6], f = data[7], i = data[8],
-            dete = det();
-          if (dete) {
-            data[0] = (T)((i*e-f*h)/dete), data[1] = (T)((g*f-i*d)/dete), data[2] = (T)((d*h-g*e)/dete);
-            data[3] = (T)((h*c-i*b)/dete), data[4] = (T)((i*a-c*g)/dete), data[5] = (T)((g*b-a*h)/dete);
-            data[6] = (T)((b*f-e*c)/dete), data[7] = (T)((d*c-a*f)/dete), data[8] = (T)((a*e-d*b)/dete);
-          } else {
-            cimg::warn(true,"CImg<%s>::inverse() : Matrix determinant is 0, can't invert matrix",pixel_type());
-            fill(0);
-          }
-        }
-        break;
-      default:
-        {        
-          int N = width, LWORK = 4*N, *IPIV = new int[N], INFO;
-          double *A = new double[N*N], *WORK = new double[LWORK];
-          for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) A[k*N+l] = (*this)(k,l);
-          dgetrf_(&N,&N,A,&N,IPIV,&INFO);
-          cimg::warn(INFO!=0,"CImg<%s>::inverse() : LAPACK Error code = %d, from dgetrf_()",pixel_type(),INFO);
-          if (!INFO) {
-            dgetri_(&N,A,&N,IPIV,WORK,&LWORK,&INFO);
-            cimg::warn(INFO!=0,"CImg<%s>::inverse() : LAPACK Error code = %d, from dgetri_()",pixel_type(),INFO);
-          }
-          if (!INFO) for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) (*this)(k,l) = (T)(A[k*N+l]);
-          else fill(0);
-          delete[] IPIV; delete[] A; delete[] WORK;        
-        }
-      }
-      return *this;
-    }
-    //! Return the inverse of the current matrix.
-    CImg get_inverse() const { return CImg<T>(*this).inverse(); }
-
-    //! Return the trace of the current matrix.
-    double trace() const {
-      cimg_test_square(*this,"CImg<T>::trace");
-      double res=0;
-      cimg_mapX(*this,k) res+=(*this)(k,k);
-      return res;
-    }
-    //! Return the dot product of the current vector/matrix with the vector/matrix \p img.
-    double dot(const CImg& img) const {
-      cimg_test(*this,"CImg<T>::dot"); cimg_test(img,"CImg<T>::dot");
-      const unsigned int nb = cimg::min(size(),img.size());
-      double res=0;
-      for (unsigned int off=0; off<nb; off++) res+=data[off]*img[off];
-      return res;
-    }
-	
-    //! Return the cross product between two 3d vectors
-    CImg& cross(const CImg& img) {
-      if (width!=1 || height<3 || img.width!=1 || img.height<3)
-        throw CImgInstanceException("CImg<%s>::cross() : cannot get cross product between two matrices (%u,%u) and (%u,%u)",
-                                    pixel_type(),width,height,img.width,img.height);
-      const T x = (*this)[0], y = (*this)[1], z = (*this)[2];
-      (*this)[0] = y*img[2]-z*img[1];
-      (*this)[1] = z*img[0]-x*img[2];
-      (*this)[2] = x*img[1]-y*img[0];
-      return *this;
-    }
-    //! Return the cross product between two 3d vectors
-    CImg get_cross(const CImg& img) const { return CImg<T>(*this).cross(img); }
-
-    //! Return the determinant of the current matrix.
-    double det() const {
-      cimg_test_square(*this,"CImg<T>::det");
-      switch (width) {
-      case 1: return (*this)(0,0);
-      case 2: return (*this)(0,0)*(*this)(1,1)-(*this)(0,1)*(*this)(1,0);
-      case 3: 
-        {
-          const double
-            a = data[0], d = data[1], g = data[2],
-            b = data[3], e = data[4], h = data[5],
-            c = data[6], f = data[7], i = data[8];
-          return i*a*e-a*h*f-i*b*d+b*g*f+c*d*h-c*g*e;
-        }
-      }
-      return 0;
-    }
-    //! Return the norm of the current vector/matrix. \p ntype = norm type (0=L2, 1=L1, -1=Linf).
-    double norm(const int ntype=2) const {
-      cimg_test(*this,"CImg<T>::norm");
-      double res = 0;
-      switch (ntype) {
-      case -1: { cimg_mapoff(*this,off) if (std::fabs((double)data[off])>res) res = std::fabs((double)data[off]); return res; }
-      case 1 : { cimg_mapoff(*this,off) res+=std::fabs((double)data[off]); return res; }
-      default: { return std::sqrt(dot(*this)); }
-      }
-      return 0;
-    }
-    //! Return the sum of all the pixel values in an image.
-    double sum() const {
-      cimg_test(*this,"CImg<T>::sum");		
-      double res=0;
-      cimg_map(*this,ptr,T) res+=*ptr;
-      return res;
-    }
-    //! Compute the eigenvalues and eigenvectors of a general matrix.
-    template<typename t> const CImg<T>& eigen(CImg<t>& val, CImg<t> &vec) const {
-      cimg_test_square(*this,"CImg<T>::eigen");
-      if (val.size()<width) 
-        throw CImgArgumentException("CImg<%s>::eigen() : Argument 'val' is not large enough to be filled with eigenvalues (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width);
-      if (vec.data && vec.size()<width*width) 
-        throw CImgArgumentException("CImg<%s>::eigen() : Argument 'vec' is not large enough to be filled with eigenvectors (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width*width);
-      switch(width) {
-      case 1:
-        val[0]=(t)(*this)[0]; 
-        if (vec.data) vec[0]=(t)1;
-        break;
-      case 2:
-        {
-          const double
-            a = (*this)[0], b = (*this)[1],
-            c = (*this)[2], d = (*this)[3],
-            e = a+d;
-          double f = e*e-4*(a*d-b*c);
-          cimg::warn(f<0,"CImg<%s>::eigen() : Complex eigenvalues",pixel_type());
-          f = std::sqrt(f);
-          const double l1 = 0.5*(e-f), l2 = 0.5*(e+f);
-          val[0]=(t)l1; val[1]=(t)l2;
-          if (vec.data) {
-            double u,v,n;
-            if (std::fabs(b)>std::fabs(a-l1)) { u = 1; v = (l1-a)/b; }
-            else { if (a-l1!=0) { u = -b/(a-l1); v = 1; } else { u = 1; v = 0; } }
-            n = std::sqrt(u*u+v*v); u/=n; v/=n; vec[0] = (t)u; vec[1] = (t)v;
-            if (std::fabs(b)>std::fabs(a-l2)) { u = 1; v = (l2-a)/b; }
-            else { if (a-l2!=0) { u = -b/(a-l2); v = 1; } else { u = 0; v = 1; } }
-            n = std::sqrt(u*u+v*v); u/=n; v/=n; vec[2] = (t)u; vec[3] = (t)v;
-          }
-        }
-        break;
-      default: 
-        throw CImgInstanceException("CImg<%s>::eigen() : Eigenvalues computation of general matrices is limited to 2x2 matrices (given is %ux%u)",
-                                    pixel_type(),width,height);
-      }
-      return *this;
-    }
-
-    //! Compute the eigenvalues of a general matrix.
-    template<typename t> const CImg<T>& eigen(CImg<t>& val) const { CImg foo; return eigen(val,foo); }
-    CImgl<T> get_eigen(const bool compute_vectors=true) const {
-      cimg_test_square(*this,"CImg<T>::get_eigen");
-      CImgl<T> res(1,1,width);
-      if (compute_vectors) res.insert(CImg<T>(width,width));
-      eigen(res[0],res[1]);
-      return res;
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a symmetric matrix.
-    template<typename t> const CImg<T>& symeigen(CImg<t>& val, CImg<t>& vec) const {
-      cimg_test_square(*this,"CImg<T>::symeigen");
-      if (val.size()<width) 
-        throw CImgArgumentException("CImg<%s>::symeigen() : Argument 'val' is not large enough to be filled with eigenvalues (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width);
-      if (vec.data && vec.size()<width*width) 
-        throw CImgArgumentException("CImg<%s>::symeigen() : Argument 'vec' is not large enough to be filled with eigenvectors (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width*width);
-      char JOBZ=vec.data?'V':'N', UPLO='U';
-      int N,INFO=0,LWORK;
-      double *WORK,*A,*VAL;
-      if (width<3) return eigen(val,vec);
-      N = width;
-      LWORK = 5*N;
-      A    = new double[N*N];
-      WORK = new double[LWORK];
-      VAL  = new double[width];
-      for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) A[k*N+l] = (*this)(k,l);
-      dsyev_(&JOBZ,&UPLO,&N,A,&N,VAL,WORK,&LWORK,&INFO);
-      cimg::warn(INFO!=0,"CImg<%s>::symeigen() : LAPACK Error code = %d, from ssyev_()",pixel_type(),INFO);
-      cimg_mapX(*this,x) val(x) = (t)VAL[x];
-      if (vec.data) cimg_mapXY(*this,x,y) vec(x,y) = (t)A[x+y*N];
-      delete[] A; 
-      delete[] WORK;
-      delete[] VAL;
-      return *this;
-    }
-    //! Compute the eigenvalues of a symmetric matrix.
-    template<typename t> const CImg<T>& symeigen(CImg<t>& val) const { CImg foo; return symeigen(val,foo); }
-    CImgl<T> get_symeigen(const bool compute_vectors=true) const {
-      cimg_test_square(*this,"CImg<T>::symeigen");
-      CImgl<T> res(1,1,width);
-      if (compute_vectors) res.insert(CImg<T>(width,width));
-      symeigen(res[0],res[1]);
-      return res;
-    }
-
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Display functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-  
-    //! Display an image into a CImgDisplay window.
-    const CImg& display(CImgDisplay& disp,const unsigned int ymin=0,const unsigned int ymax=~0) const { disp.display(*this,ymin,ymax); return *this; }
-
-    //! Same as \ref cimg::wait()
-    const CImg& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this;  }
-  
-    //! Display an image in a window with a title \p title, and wait a 'closed' or 'keyboard' event.\n
-    //! Parameters \p min_size and \p max_size set the minimum and maximum dimensions of the display window.
-    //! If negative, they corresponds to a percentage of the original image size.
-    const CImg& display(const char* title,const int min_size=128,const int max_size=1024) const {
-      cimg_test(*this,"CImg<T>::display");
-      CImgDisplay *disp;
-      unsigned int w = width+(depth>1?depth:0), h = height+(depth>1?depth:0), XYZ[3];
-      print(title);
-      const unsigned int dmin = cimg::min(w,h), minsiz = min_size>=0?min_size:(-min_size)*dmin/100;
-      if (dmin<minsiz) { w=w*minsiz/dmin; w+=(w==0); h=h*minsiz/dmin; h+=(h==0); }
-      const unsigned int dmax = cimg::max(w,h), maxsiz = max_size>=0?max_size:(-max_size)*dmax/100;
-      if (dmax>maxsiz) { w=w*maxsiz/dmax; w+=(w==0); h=h*maxsiz/dmax; h+=(h==0); }
-      disp = new CImgDisplay(CImg<unsigned char>(w,h,1,1,0),title,0,3);
-      XYZ[0] = width/2; XYZ[1] = height/2; XYZ[2] = depth/2;
-      while (!disp->closed && !disp->key) feature_selection(NULL,1,*disp,XYZ);
-      delete disp;
-      return *this;
-    }
-
-    //! Display an image in a window, with a default title. See also \see display() for details on parameters.
-    const CImg& display(const int min_size=128,const int max_size=1024) const { return display("",min_size,max_size); }
-  
-    //! High-level interface to select features from images
-    const CImg& feature_selection(int *const selection, const int feature_type,CImgDisplay &disp,
-                                  unsigned int *const XYZ=NULL,const unsigned char *const color=NULL) const {
-      cimg_test(*this,"CImg<T>::feature_selection");
-      if (disp.events<3) 
-        throw CImgArgumentException("CImg<%s>::feature_selection() : Input display must be able to catch keyboard and mouse events (events>=3). Given display has 'events = %s'.",pixel_type(),disp.events);
-      unsigned char fgcolor[3]={255,255,105},bgcolor[3]={0,0,0};
-      if (color) std::memcpy(fgcolor,color,sizeof(unsigned char)*cimg::min(3,dimv()));
-      int carea=0,area=0,phase=0,
-        X0=(XYZ?XYZ[0]:width/2)%width, Y0=(XYZ?XYZ[1]:height/2)%height, Z0=(XYZ?XYZ[2]:depth/2)%depth, 
-        X=-1,Y=-1,Z=-1,oX=-1,oY=-1,oZ=-1,X1=-1,Y1=-1,Z1=-1;
-      unsigned long hatch=feature_type?0xF0F0F0F0:~0L;
-      bool feature_selected = false, ytext = false;
-      CImg<unsigned char> visu, visu0;
-      char text[1024];
-    
-      while (!disp.key && !disp.closed && !feature_selected) {
-
-        // Init visu0 if necessary
-        if (disp.resized || !visu0.data) { 
-          if (disp.resized) disp.resize();
-          if (depth==1) visu0=get_normalize(0,(T)255); else visu0=get_3dplanes(X0,Y0,Z0).get_normalize(0,(T)255);
-          visu0.resize(disp.width,disp.height,1,cimg::min(3,dimv()));
-        }
-        visu = visu0;      
-      
-        // Handle motion and selection
-        const int mx = disp.mousex, my = disp.mousey, b = disp.button;
-        if (mx>=0 && my>=0) {
-          const int mX = mx*(width+(depth>1?depth:0))/disp.width, mY = my*(height+(depth>1?depth:0))/disp.height;
-          if (mX<dimx() && mY<dimy())   { area=1; X=mX; Y=mY; Z=phase?Z1:Z0; }
-          if (mX<dimx() && mY>=dimy())  { area=2; X=mX; Y=phase?Y1:Y0; Z=mY-height; }
-          if (mX>=dimx() && mY<dimy())  { area=3; X=phase?X1:X0; Y=mY; Z=mX-width;  }
-          if (mX>=dimx() && mY>=dimy()) { X=X0; Y=Y0; Z=Z0; }
-          if ((!(phase%2) && (b&1)) || (phase%2 && !(b&1))) { 
-            if (!carea) carea=area;
-            if (!(phase++)) { X0=X; Y0=Y; Z0=Z; }
-          }
-          if (b&2) { if (!phase) { X0=X; Y0=Y; Z0=Z; } else { X1=Y1=Z1=-1; phase=carea=0; }}
-          if ((b&2 || phase) && depth>1) 
-            visu0 = get_3dplanes(X,Y,Z).normalize(0,(T)255).resize(disp.width,disp.height,1,cimg::min(3,dimv()));
-          if (phase) {
-            if (!feature_type) feature_selected = phase?true:false;
-            else {
-              if (depth>1) feature_selected = (phase==3)?true:false;
-              else feature_selected = (phase==2)?true:false;
-            }   
-            if (!feature_selected) {
-              if (phase<2) { X1=X; Y1=Y; Z1=Z; }
-              else switch(carea) {
-              case 1: Z1=Z; break;
-              case 2: Y1=Y; break;
-              case 3: X1=X; break;
-              }
-            }
-          }
-          if (!phase || !feature_type) {
-            if (depth>1) std::sprintf(text,"Coords (%d,%d,%d)={ ",X,Y,Z); else std::sprintf(text,"Coords (%d,%d)={ ",X,Y);
-            cimg_mapV(*this,k) std::sprintf(text+cimg::strlen(text),"%g ",(double)(*this)(X,Y,Z,k));
-            std::sprintf(text+cimg::strlen(text),"}");
-            if (!feature_type) { X1=X0; Y1=Y0; Z1=Z0; }
-          } else
-            switch (feature_type) {
-            case 1:
-              {
-                const double dX=(double)(X0-X1), dY=(double)(Y0-Y1), dZ=(double)(Z0-Z1), norm = std::sqrt(dX*dX+dY*dY+dZ*dZ);
-                if (depth>1) std::sprintf(text,"Vect (%d,%d,%d)-(%d,%d,%d), norm=%g",X0,Y0,Z0,X1,Y1,Z1,norm);
-                else std::sprintf(text,"Vect (%d,%d)-(%d,%d), norm=%g",X0,Y0,X1,Y1,norm);
-              }
-              break;
-            case 2:
-              if (depth>1) std::sprintf(text,"Box (%d,%d,%d)-(%d,%d,%d), Size=(%d,%d,%d)",
-                                        X0<X1?X0:X1,Y0<Y1?Y0:Y1,Z0<Z1?Z0:Z1,
-                                        X0<X1?X1:X0,Y0<Y1?Y1:Y0,Z0<Z1?Z1:Z0,
-                                        1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
-              else  std::sprintf(text,"Box (%d,%d)-(%d,%d), Size=(%d,%d)",
-                                 X0<X1?X0:X1,Y0<Y1?Y0:Y1,X0<X1?X1:X0,Y0<Y1?Y1:Y0,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
-              break;
-            }
-          if (my<12) ytext=true;
-          if (my>=visu.dimy()-11) ytext=false;
-          visu.draw_text(text,0,ytext?visu.dimy()-11:0,fgcolor,bgcolor,0.7f);
-        } else { X=Y=Z=-1; if (phase) disp.button=phase%2; }
-      
-        // Draw image + selection on display window
-        if (X>=0 && Y>=0 && Z>=0) {
-          hatch=cimg::ror(hatch);
-          if (feature_type==1 && phase) {
-            const int d=(depth>1)?depth:0,
-              x0=(int)((X0+0.5f)*disp.width/(width+d)), y0=(int)((Y0+0.5f)*disp.height/(height+d)),
-              x1=(int)((X1+0.5f)*disp.width/(width+d)), y1=(int)((Y1+0.5f)*disp.height/(height+d));
-            visu.draw_arrow(x0,y0,x1,y1,fgcolor,30.0f,5.0f,hatch);
-            if (d) {
-              const int zx0=(int)((width+Z0+0.5f)*disp.width/(width+d)), zx1=(int)((width+Z1+0.5f)*disp.width/(width+d)),
-                zy0=(int)((height+Z0+0.5f)*disp.height/(height+d)), zy1=(int)((height+Z1+0.5f)*disp.height/(height+d));
-              visu.draw_arrow(zx0,y0,zx1,y1,fgcolor,30.0f,5.0f,hatch).draw_arrow(x0,zy0,x1,zy1,fgcolor,30.0f,5.0f,hatch);
-            }
-          } else {
-            const bool cond=(phase&&feature_type);
-            const int d=(depth>1)?depth:0,
-              nX0=cond?X0:X, nY0=cond?Y0:Y, nZ0=cond?Z0:Z,
-              nX1=cond?X1:X, nY1=cond?Y1:Y, nZ1=cond?Z1:Z,
-              x0=(nX0<nX1?nX0:nX1)*disp.width/(width+d),
-              y0=(nY0<nY1?nY0:nY1)*disp.height/(height+d),
-              x1=((nX0<nX1?nX1:nX0)+1)*disp.width/(width+d)-1,
-              y1=((nY0<nY1?nY1:nY0)+1)*disp.height/(height+d)-1;
-            const unsigned long nhatch=phase?hatch:~0L;
-            visu.draw_rectangle(x0,y0,x1,y1,fgcolor,0.2f).draw_line(x0,y0,x1,y0,fgcolor,nhatch).
-              draw_line(x1,y0,x1,y1,fgcolor,nhatch).draw_line(x1,y1,x0,y1,fgcolor,nhatch).draw_line(x0,y1,x0,y0,fgcolor,nhatch);
-            if (d) {
-              const int
-                zx0=(int)((width+(nZ0<nZ1?nZ0:nZ1))*disp.width/(width+d)),
-                zy0=(int)((height+(nZ0<nZ1?nZ0:nZ1))*disp.height/(height+d)),
-                zx1=(int)((width+(nZ0<nZ1?nZ1:nZ0)+1)*disp.width/(width+d))-1,
-                zy1=(int)((height+(nZ0<nZ1?nZ1:nZ0)+1)*disp.height/(height+d))-1;
-              visu.draw_rectangle(zx0,y0,zx1,y1,fgcolor,0.2f).draw_line(zx0,y0,zx1,y0,fgcolor,nhatch).
-                draw_line(zx1,y0,zx1,y1,fgcolor,nhatch).draw_line(zx1,y1,zx0,y1,fgcolor,nhatch).draw_line(zx0,y1,zx0,y0,fgcolor,nhatch);
-              visu.draw_rectangle(x0,zy0,x1,zy1,fgcolor,0.2f).draw_line(x0,zy0,x1,zy0,fgcolor,nhatch).
-                draw_line(x1,zy0,x1,zy1,fgcolor,nhatch).draw_line(x1,zy1,x0,zy1,fgcolor,nhatch).draw_line(x0,zy1,x0,zy0,fgcolor,nhatch);
-            }
-          }
-        }
-        visu.display(disp).wait(32);
-        if (!feature_selected && (!phase && oX==X && oY==Y && oZ==Z) || (X<0 || Y<0 || Z<0)) disp.wait();
-        oX=X; oY=Y; oZ=Z;
-      }
-
-      // Return result
-      if (XYZ) { XYZ[0] = X; XYZ[1] = Y; XYZ[2] = Z; }
-      if (feature_selected) {
-        if (feature_type==2) {
-          if (X0>X1) cimg::swap(X0,X1);
-          if (Y0>Y1) cimg::swap(Y0,Y1);
-          if (Z0>Z1) cimg::swap(Z0,Z1);
-        }
-        if (selection) {
-          if (X1<0 || Y1<0 || Z1<0) X0=Y0=Z0=X1=Y1=Z1=-1;
-          switch(feature_type) {
-          case 1:
-          case 2:  selection[3] = X1; selection[4] = Y1; selection[5] = Z1;
-          default: selection[0] = X0; selection[1] = Y0; selection[2] = Z0;
-          }
-        }
-      } else if (selection) selection[0]=selection[1]=selection[2]=selection[3]=selection[4]=selection[5]=-1;
-      disp.button=0;
-      return *this;
-    }
-
-    //! High-level interface to select features in images
-    const CImg& feature_selection(int *const selection, const int feature_type,
-                                  unsigned int *const XYZ=NULL,const unsigned char *const color=NULL) const {
-      unsigned int w = width + (depth>1?depth:0), h = height + (depth>1?depth:0);
-      const unsigned int dmin = cimg::min(w,h), minsiz = 256;
-      if (dmin<minsiz) { w=w*minsiz/dmin; h=h*minsiz/dmin; }
-      const unsigned int dmax = cimg::max(w,h), maxsiz = 1024;
-      if (dmax>maxsiz) { w=w*maxsiz/dmax; h=h*maxsiz/dmax; }
-      CImgDisplay disp(w,h,"",0,3);
-      return feature_selection(selection,feature_type,disp,XYZ,color);
-    }
-  
- 
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Input-Output functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-
-    //! Load an image from a file.
-    /**
-       \note The extension of \c filename defines the file format.
-    **/
-    static CImg load(const char *filename) {
-      const char *ext = cimg::filename_split(filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::load() : Can't load (null) filename",pixel_type());
-      if (!cimg::strcasecmp(ext,"asc")) return load_ascii(filename);
-      if (!cimg::strcasecmp(ext,"dlm")) return load_dlm(filename);
-      if (!cimg::strcasecmp(ext,"inr")) return load_inr(filename);
-      if (!cimg::strcasecmp(ext,"hdr")) return load_analyze(filename);
-      if (!cimg::strcasecmp(ext,"pan")) return load_pandore(filename);
-      if (!cimg::strcasecmp(ext,"bmp")) return load_bmp(filename);
-      if (!cimg::strcasecmp(ext,"ppm") || 
-	  !cimg::strcasecmp(ext,"pgm") ||
-	  !cimg::strcasecmp(ext,"pnm")) return load_pnm(filename);
-      if (!cimg::strcasecmp(ext,"raw") || ext[0]=='\0') return load_raw(filename);      
-      return load_convert(filename);
-    }
-
-    //! Load an image from an ASCII file
-    static CImg load_ascii(const char *filename) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-      char line[256] = {0};
-      std::fscanf(file,"%255[^\n]",line);
-      unsigned int off;
-	  int err=1, dx=0, dy=1, dz=1, dv=1;
-      std::sscanf(line,"%d %d %d %d",&dx,&dy,&dz,&dv);
-      if (!dx || !dy || !dz || !dv)
-	throw CImgIOException("CImg<%s>::load_ascii() : File '%s' does not appear to be a valid ASC file.\n"
-			      "Specified image dimensions are (%d,%d,%d,%d)",pixel_type(),filename,dx,dy,dz,dv);
-      CImg dest(dx,dy,dz,dv);
-      double val;
-      T *ptr = dest.data;
-      for (off=0; off<dest.size() && err==1; off++) {
-	err = fscanf(file,"%lf%*[^0-9.eE+-]",&val); 
-	*(ptr++)=(T)val; 
-      }
-      cimg::warn(off<dest.size(),"CImg<%s>::load_ascii() : File '%s', only %u values read, instead of %u",
-		 pixel_type(),filename,off,dest.size());
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a DLM file
-    static CImg load_dlm(const char *filename) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-      unsigned int cdx=0,dx=0,dy=0;
-      double val;
-      char c, delimiter[256]={0};
-      int err;
-      while ((err = std::fscanf(file,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
-	if (err>0) cdx++;
-	if (std::sscanf(delimiter,"%*[^\n]%c",&c)>0 && c=='\n') { dx = cimg::max(cdx,dx); dy++; cdx=0; }
-      }
-      if (!dx || !dy) throw CImgIOException("CImg<%s>::load_dlm() : File '%s' does not appear to be a "
-					    "valid DLM file.\n",pixel_type(),filename);
-      std::rewind(file);
-      CImg<T> dest(dx,dy,1,1,0);
-      unsigned int x = 0, y = 0;
-      while ((err = std::fscanf(file,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
-	if (err>0) dest(x++,y) = (T)val;
-	if (std::sscanf(delimiter,"%*[^\n]%c",&c)>0 && c=='\n') { x=0; y++; }
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a PNM file
-    static CImg load_pnm(const char *filename) {
-      std::FILE *file=cimg::fopen(filename,"rb");
-      char item[1024]={0};
-      unsigned int ppm_type,width,height,colormax=255;
-      int err;
-      
-      while ((err=std::fscanf(file,"%1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
-      if(std::sscanf(item," P%u",&ppm_type)!=1) 
-        throw CImgIOException("CImg<%s>::load_pnm() : file '%s',PPM header 'P?' not found",pixel_type(),filename);
-      while ((err=std::fscanf(file," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
-      if (std::sscanf(item," %u %u",&width,&height)!=2)
-        throw CImgIOException("CImg<%s>::load_pnm() : file '%s',WIDTH and HEIGHT not defined",pixel_type(),filename);
-      while ((err=std::fscanf(file," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
-      std::fgetc(file);
-      cimg::warn(std::sscanf(item,"%u",&colormax)!=1,"CImg<%s>::load_pnm() : file '%s',COLORMAX not defined",pixel_type(),filename);
-      cimg::warn(colormax!=255,"CImg<%s>::load_pnm() : file '%s', COLORMAX=%u mode is not supported",pixel_type(),filename,colormax);
-
-      CImg dest;
-      int rval,gval,bval;
-
-      switch (ppm_type) {
-      case 2: { // Grey Ascii
-	dest = CImg<T>(width,height,1,1);
-	T* rdata = dest.ptr();
-	cimg_mapoff(dest,off) { std::fscanf(file,"%d",&rval); *(rdata++)=(T)rval; }
-      } break;
-      case 3: { // Color Ascii
-	dest = CImg<T>(width,height,1,3);
-	T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-	cimg_mapXY(dest,x,y) { 
-	  std::fscanf(file,"%d %d %d",&rval,&gval,&bval);
-	  *(rdata++)=(T)rval; 
-	  *(gdata++)=(T)gval; 
-	  *(bdata++)=(T)bval; }
-      } break;
-      case 5: { // Grey Binary
-	unsigned char *raw = new unsigned char[width*height], *raw2 = raw;
-	cimg::fread(raw,sizeof(unsigned char),width*height,file);
-	dest = CImg<T>(width,height,1,1);
-	T *rdata = dest.ptr();
-	cimg_mapoff(dest,off) *(rdata++)=(T)*(raw2++);
-	delete[] raw;
-      } break;
-      case 6: { // Color Binary
-	unsigned char *raw = new unsigned char[width*height*3], *raw2 = raw;
-	cimg::fread(raw,sizeof(unsigned char),width*height*3,file);
-	dest = CImg<T>(width,height,1,3);
-	T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-	cimg_mapXY(dest,x,y) {
-	  *(rdata++)=(T)*(raw2++);
-	  *(gdata++)=(T)*(raw2++);
-	  *(bdata++)=(T)*(raw2++); 
-	}
-	delete[] raw;
-      } break;
-      default:
-	cimg::fclose(file);
-	throw CImgIOException("CImg<%s>::load_pnm() : file '%s', PPM type 'P%d' not supported",pixel_type(),filename,ppm_type);
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a BMP file.
-    static CImg load_bmp(const char *filename) {
-      unsigned char header[64];
-      std::FILE *file = cimg::fopen(filename,"rb");
-      cimg::fread(header,sizeof(unsigned char),54,file);
-      if (header[0]!='B' || header[1]!='M')
-	throw CImgIOException("CImg<%s>::load_bmp() : filename '%s' does not appear to be a valid BMP file",
-			      pixel_type(),filename);
-      
-      // Read header and pixel buffer
-      int
-	file_size   = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24),
-	offset      = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24),
-	dx          = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24),
-	dy          = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24),
-	compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24),
-	nb_colors   = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24),
-	bpp         = header[0x1C] + (header[0x1D]<<8),
-	*palette    = NULL;
-      const int 
-	dx_bytes   = (bpp==1)?(dx/8+(dx%8?1:0)):((bpp==4)?(dx/2+(dx%2?1:0)):(dx*bpp/8)),
-	align      = (4-dx_bytes%4)%4,
-	buf_size   = cimg::min(cimg::abs(dy)*(dx_bytes+align),file_size-offset);
-
-      if (bpp<16) { if (!nb_colors) nb_colors=1<<bpp; } else nb_colors=0;
-      if (nb_colors) { palette = new int[nb_colors]; cimg::fread(palette,sizeof(int),nb_colors,file); }
-      const int	xoffset = offset-54-4*nb_colors;      
-      if (xoffset>0) std::fseek(file,xoffset,SEEK_CUR);
-      const unsigned char *buffer  = new unsigned char[buf_size], *ptrs = buffer;
-      cimg::fread(buffer,sizeof(unsigned char),buf_size,file);
-      cimg::fclose(file);
-
-      // Decompress buffer (if necessary)
-      if (compression) return load_convert(filename);
-      
-      // Read pixel data
-      CImg res(dx,cimg::abs(dy),1,3);
-      switch (bpp) {
-      case 1: { // Monochrome
-	for (int y=res.height-1; y>=0; y--) { 
-	  unsigned char mask = 0x80, val = 0;
-	  cimg_mapX(res,x) {
-	    if (mask==0x80) val = *(ptrs++);
-	    const unsigned char *col = (unsigned char*)(palette+(val&mask?1:0));
-	    res(x,y,2) = (T)*(col++);
-	    res(x,y,1) = (T)*(col++);
-	    res(x,y,0) = (T)*(col++);
-	    mask = cimg::ror(mask);
-	  } ptrs+=align; }
-      } break;
-      case 4: { // 16 colors
-	for (int y=res.height-1; y>=0; y--) { 
-	  unsigned char mask = 0xF0, val = 0;
-	  cimg_mapX(res,x) {
-	    if (mask==0xF0) val = *(ptrs++);
-	    const unsigned char color = (mask<16)?(val&mask):((val&mask)>>4);
-	    unsigned char *col = (unsigned char*)(palette+color);
-	    res(x,y,2) = (T)*(col++);
-	    res(x,y,1) = (T)*(col++);
-	    res(x,y,0) = (T)*(col++);
-	    mask = cimg::ror(mask,4);
-	  } ptrs+=align; }
-      } break;
-      case 8: { //  256 colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  const unsigned char *col = (unsigned char*)(palette+*(ptrs++));
-	  res(x,y,2) = (T)*(col++);
-	  res(x,y,1) = (T)*(col++);
-	  res(x,y,0) = (T)*(col++);
-	} ptrs+=align; }
-      } break;
-      case 16: { // 16 bits colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  const unsigned char c1 = *(ptrs++), c2 = *(ptrs++);
-	  const unsigned short col = c1+(c2<<8);
-	  res(x,y,2) = (T)(col&0x1F);
-	  res(x,y,1) = (T)((col>>5)&0x1F);
-	  res(x,y,0) = (T)((col>>10)&0x1F);
-	} ptrs+=align; }
-      } break;	
-      case 24: { // 24 bits colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  res(x,y,2) = (T)*(ptrs++);
-	  res(x,y,1) = (T)*(ptrs++);
-	  res(x,y,0) = (T)*(ptrs++);
-	} ptrs+=align; }
-      } break;
-      case 32: { // 32 bits colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  res(x,y,2) = (T)*(ptrs++);
-	  res(x,y,1) = (T)*(ptrs++);
-	  res(x,y,0) = (T)*(ptrs++);
-	  ptrs++;
-	} ptrs+=align; }
-      } break;
-      }
-
-      if (palette) delete[] palette;
-      if (dy<0) res.flip('y');
-      return res;
-    }
-
-
-    //! Load an image from an INRIMAGE-4 file.
-#define cimg_load_inr_case(Tf,sign,pixsize,Ts)                            \
-  if (!loaded && fopt[6]==pixsize && fopt[4]==Tf && fopt[5]==sign) {      \
-      Ts *xval, *val = new Ts[fopt[0]*fopt[3]];                           \
-      cimg_mapYZ(dest,y,z) {                                              \
-          cimg::fread(val,pixsize/8,fopt[0]*fopt[3],file);                \
-          if (fopt[7]!=endian) cimg::endian_swap(val,fopt[0]*fopt[3]);    \
-          xval = val; cimg_mapX(dest,x) cimg_mapV(dest,k)                 \
-                          dest(x,y,z,k) = (T)*(xval++);                   \
-        }                                                                 \
-      delete[] val;                                                       \
-      loaded = true;                                                      \
-    }
-    
-    static void _load_inr(std::FILE *file,int out[8],float *voxsize=NULL) {
-      char item[1024],tmp1[64],tmp2[64];
-      out[0]=out[1]=out[2]=out[3]=out[5]=1; out[4]=out[6]=out[7]=-1;
-      std::fscanf(file,"%63s",item);
-      if(cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0) 
-	throw CImgIOException("CImg<%s>::load_inr() : File does not appear to be a valid INR file.\n"
-			      "(INRIMAGE-4 identifier not found)",pixel_type());
-      while (std::fscanf(file," %63[^\n]%*c",item)!=EOF && cimg::strncmp(item,"##}",3)) {
-        std::sscanf(item," XDIM%*[^0-9]%d",out);
-        std::sscanf(item," YDIM%*[^0-9]%d",out+1);
-        std::sscanf(item," ZDIM%*[^0-9]%d",out+2);
-        std::sscanf(item," VDIM%*[^0-9]%d",out+3);
-        std::sscanf(item," PIXSIZE%*[^0-9]%d",out+6);
-        if (voxsize) {
-          std::sscanf(item," VX%*[^0-9.eE+-]%f",voxsize);
-          std::sscanf(item," VY%*[^0-9.eE+-]%f",voxsize+1);
-          std::sscanf(item," VZ%*[^0-9.eE+-]%f",voxsize+2);
-        }
-        if (std::sscanf(item," CPU%*[ =]%s",tmp1)) out[7]=cimg::strncasecmp(tmp1,"sun",3)?0:1;
-        switch(std::sscanf(item," TYPE%*[ =]%s %s",tmp1,tmp2)) {
-        case 0: break;
-        case 2: out[5] = cimg::strncasecmp(tmp1,"unsigned",8)?1:0; std::strcpy(tmp1,tmp2);
-        case 1:
-          if (!cimg::strncasecmp(tmp1,"int",3)   || !cimg::strncasecmp(tmp1,"fixed",5))  out[4]=0;
-          if (!cimg::strncasecmp(tmp1,"float",5) || !cimg::strncasecmp(tmp1,"double",6)) out[4]=1;
-          if (!cimg::strncasecmp(tmp1,"packed",6))                                       out[4]=2;
-          if (out[4]>=0) break;
-        default: throw CImgIOException("cimg::inr_header_read() : Invalid TYPE '%s'",tmp2);
-        }
-      }
-      if(out[0]<0 || out[1]<0 || out[2]<0 || out[3]<0)
-        throw CImgIOException("CImg<%s>::load_inr() : Bad dimensions in .inr file = ( %d , %d , %d , %d )",
-                              pixel_type(),out[0],out[1],out[2],out[3]);
-      if(out[4]<0 || out[5]<0) throw CImgIOException("CImg<%s>::load_inr() : TYPE is not fully defined",pixel_type());
-      if(out[6]<0) throw CImgIOException("CImg<%s>::load_inr() : PIXSIZE is not fully defined",pixel_type());
-      if(out[7]<0) throw CImgIOException("CImg<%s>::load_inr() : Big/Little Endian coding type is not defined",pixel_type());
-    }
-    
-    static CImg load_inr(const char *filename, float *voxsize = NULL) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-	  int fopt[8], endian=cimg::endian()?1:0;
-      bool loaded = false;
-      if (voxsize) voxsize[0]=voxsize[1]=voxsize[2]=1;
-      _load_inr(file,fopt,voxsize);
-      CImg<T> dest = CImg<T>(fopt[0],fopt[1],fopt[2],fopt[3]);
-      cimg_load_inr_case(0,0,8, unsigned char);
-      cimg_load_inr_case(0,1,8, char);
-      cimg_load_inr_case(0,0,16,unsigned short);
-      cimg_load_inr_case(0,1,16,short);
-      cimg_load_inr_case(0,0,32,unsigned int);
-      cimg_load_inr_case(0,1,32,int);
-      cimg_load_inr_case(1,0,32,float);
-      cimg_load_inr_case(1,1,32,float);
-      cimg_load_inr_case(1,0,64,double);
-      cimg_load_inr_case(1,1,64,double);
-      if (!loaded) throw CImgIOException("CImg<%s>::load_inr() : File '%s', can't read images of the type specified in the file",
-					 pixel_type(),filename);
-      cimg::fclose(file);
-      return dest;
-    }
-   
-    //! Load an image from a PANDORE file
-
-#define cimg_load_pandore_case(nid,nbdim,nwidth,nheight,ndepth,ndim,stype)  \
-  case nid: {                                                         \
-    cimg::fread(dims,sizeof(unsigned int),nbdim,file);                \
-    if (endian) cimg::endian_swap(dims,nbdim);                        \
-    dest = CImg<T>(nwidth,nheight,ndepth,ndim);                       \
-    stype *buffer = new stype[dest.size()];                           \
-    cimg::fread(buffer,sizeof(stype),dest.size(),file);               \
-    if (endian) cimg::endian_swap(buffer,dest.size());                \
-    T *ptrd = dest.ptr();                                             \
-    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));               \
-    buffer-=dest.size();                                              \
-    delete[] buffer;                                                  \
-   }                                                                  \
-   break;
-    
-    static CImg load_pandore(const char *filename) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-      typedef unsigned char uchar;
-      typedef unsigned short ushort;
-      typedef unsigned int uint;  
-      typedef unsigned long ulong; 
-      CImg dest;
-      char tmp[16];
-      cimg::fread(tmp,sizeof(char),12,file);
-      if (cimg::strncasecmp("PANDORE",tmp,7)) 
-	throw CImgIOException("CImg<%s>::load_pandore() : File '%s' does not appear to be a valid PANDORE file.\n"
-			      "(PANDORE identifier not found)",pixel_type(),filename);
-      unsigned int id,dims[8];
-      long ptbuf[4];
-      cimg::fread(&id,sizeof(int),1,file);
-      const bool endian = (id>255);
-      if (endian) cimg::endian_swap(id);
-      cimg::fread(tmp,sizeof(char),20,file);
-      switch (id) {
-	cimg_load_pandore_case(2,2,dims[1],1,1,1,uchar);
-	cimg_load_pandore_case(3,2,dims[1],1,1,1,long);
-	cimg_load_pandore_case(4,2,dims[1],1,1,1,float);
-	cimg_load_pandore_case(5,3,dims[2],dims[1],1,1,uchar);
-	cimg_load_pandore_case(6,3,dims[2],dims[1],1,1,long);
-	cimg_load_pandore_case(7,3,dims[2],dims[1],1,1,float);
-	cimg_load_pandore_case(8,4,dims[3],dims[2],dims[1],1,uchar);
-	cimg_load_pandore_case(9,4,dims[3],dims[2],dims[1],1,long);
-	cimg_load_pandore_case(10,4,dims[3],dims[2],dims[1],1,float);
-      case 11: { // Region 1D
-	cimg::fread(dims,sizeof(unsigned int),3,file);
-	if (endian) cimg::endian_swap(dims,3);
-	dest = CImg<T>(dims[1],1,1,1);
-	if (dims[2]<256) {
-	  unsigned char *buffer = new unsigned char[dest.size()];
-	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
-	  T *ptrd = dest.ptr();
-	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	  buffer-=dest.size();
-	  delete[] buffer;
-	} else {
-	  if (dims[2]<65536) {
-	    unsigned short *buffer = new unsigned short[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  } else {
-	    unsigned long *buffer = new unsigned long[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  }
-	}	
-      }
-	break;
-      case 12: { // Region 2D
-	cimg::fread(dims,sizeof(unsigned int),4,file);
-	if (endian) cimg::endian_swap(dims,4);
-	dest = CImg<T>(dims[2],dims[1],1,1);
-	if (dims[3]<256) {
-	  unsigned char *buffer = new unsigned char[dest.size()];
-	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
-	  T *ptrd = dest.ptr();
-	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	  buffer-=dest.size();
-	  delete[] buffer;
-	} else {
-	  if (dims[3]<65536) {
-	    unsigned short *buffer = new unsigned short[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  } else {
-	    unsigned long *buffer = new unsigned long[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  }
-	}	
-      }
-	break;
-      case 13: { // Region 3D
-	cimg::fread(dims,sizeof(unsigned int),5,file);
-	if (endian) cimg::endian_swap(dims,5);
-	dest = CImg<T>(dims[3],dims[2],dims[1],1);
-	if (dims[4]<256) {
-	  unsigned char *buffer = new unsigned char[dest.size()];
-	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
-	  T *ptrd = dest.ptr();
-	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	  buffer-=dest.size();
-	  delete[] buffer;
-	} else {
-	  if (dims[4]<65536) {
-	    unsigned short *buffer = new unsigned short[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  } else {
-	    unsigned long *buffer = new unsigned long[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  }
-	}	
-      }
-	break;
-	cimg_load_pandore_case(16,4,dims[2],dims[1],1,3,uchar);
-	cimg_load_pandore_case(17,4,dims[2],dims[1],1,3,long);
-	cimg_load_pandore_case(18,4,dims[2],dims[1],1,3,float);
-	cimg_load_pandore_case(19,5,dims[3],dims[2],dims[1],3,uchar);
-	cimg_load_pandore_case(20,5,dims[3],dims[2],dims[1],3,long);
-	cimg_load_pandore_case(21,5,dims[3],dims[2],dims[1],3,float);
-	cimg_load_pandore_case(22,2,dims[1],1,1,dims[0],uchar);
-	cimg_load_pandore_case(23,2,dims[1],1,1,dims[0],long);
-	cimg_load_pandore_case(24,2,dims[1],1,1,dims[0],ulong);
-	cimg_load_pandore_case(25,2,dims[1],1,1,dims[0],float);
-	cimg_load_pandore_case(26,3,dims[2],dims[1],1,dims[0],uchar);
-	cimg_load_pandore_case(27,3,dims[2],dims[1],1,dims[0],long);
-	cimg_load_pandore_case(28,3,dims[2],dims[1],1,dims[0],ulong);
-	cimg_load_pandore_case(29,3,dims[2],dims[1],1,dims[0],float);
-	cimg_load_pandore_case(30,4,dims[3],dims[2],dims[1],dims[0],uchar);
-	cimg_load_pandore_case(31,4,dims[3],dims[2],dims[1],dims[0],long);
-	cimg_load_pandore_case(32,4,dims[3],dims[2],dims[1],dims[0],ulong);
-	cimg_load_pandore_case(33,4,dims[3],dims[2],dims[1],dims[0],float);	
-      case 34: // Points 1D	
-	cimg::fread(ptbuf,sizeof(long),1,file);
-	if (endian) cimg::endian_swap(ptbuf,1);
-	dest = CImg<T>(1); dest[0]=(T)ptbuf[0];
-	break;
-      case 35: // Points 2D
-	cimg::fread(ptbuf,sizeof(long),2,file);
-	if (endian) cimg::endian_swap(ptbuf,2);
-	dest = CImg<T>(2); dest[0]=(T)ptbuf[1]; dest[1]=(T)ptbuf[0];
-	break;
-      case 36: // Points 3D
-	cimg::fread(ptbuf,sizeof(long),3,file);
-	if (endian) cimg::endian_swap(ptbuf,3);
-	dest = CImg<T>(3); dest[0]=(T)ptbuf[2]; dest[1]=(T)ptbuf[1]; dest[2]=(T)ptbuf[0];
-	break;
-      default:
-	throw CImgIOException("CImg<%s>::load_pandore() : File '%s', can't read images with ID_type=%d",pixel_type(),filename,id);
-      }
-      return dest;
-    }
-
-
-    //! Load an image from an ANALYZE7.5 file
-    static CImg load_analyze(const char *filename, float *voxsize = NULL) {
-      
-      // Open header and data files
-      std::FILE *file_header=NULL, *file=NULL;
-      char body[1024];
-      const char *ext = cimg::filename_split(filename,body);
-      if (!cimg::strcasecmp(ext,"hdr") || !cimg::strcasecmp(ext,"img")) {
-	std::sprintf(body+cimg::strlen(body),".hdr");
-	file_header = cimg::fopen(body,"rb");
-	std::sprintf(body+cimg::strlen(body)-3,"img");
-	file = cimg::fopen(body,"rb");
-      } else throw CImgIOException("CImg<%s>::load_analyze() : Cannot load filename '%s' as an analyze format",pixel_type(),filename);
-
-      // Read header
-      bool endian = false;
-      unsigned int header_size;
-      cimg::fread(&header_size,sizeof(int),1,file_header);
-      if (header_size>=4096) { endian = true; cimg::endian_swap(header_size); }
-      unsigned char *header = new unsigned char[header_size];
-      cimg::fread(header+sizeof(int),sizeof(char),header_size-sizeof(int),file_header);
-      cimg::fclose(file_header);
-      if (endian) {
-	cimg::endian_swap((short*)(header+40),5);
-        cimg::endian_swap((short*)(header+70),1);
-        cimg::endian_swap((short*)(header+72),1);
-        cimg::endian_swap((float*)(header+76),4);
-        cimg::endian_swap((float*)(header+112),1);
-      }
-      unsigned short *dim = (unsigned short*)(header+40), dimx=1, dimy=1, dimz=1, dimv=1;
-      cimg::warn(!dim[0],"CImg<%s>::load_analyze() : Specified image has zero dimensions.",pixel_type());
-      cimg::warn(dim[0]>4,"CImg<%s>::load_analyze() : Number of image dimension is %d, reading only the 4 first dimensions",
-		 pixel_type(),dim[0]);
-      if (dim[0]>=1) dimx = dim[1];
-      if (dim[0]>=2) dimy = dim[2];
-      if (dim[0]>=3) dimz = dim[3];
-      if (dim[0]>=4) dimv = dim[4];
-      
-      float scalefactor = *(float*)(header+112); if (scalefactor==0) scalefactor=1;
-      const unsigned short datatype = *(short*)(header+70);
-      if (voxsize) { const float *vsize = (float*)(header+76); voxsize[0] = vsize[1]; voxsize[1] = vsize[2]; voxsize[2] = vsize[3]; }
-      delete[] header;
-
-      // Read pixel data
-      CImg dest(dimx,dimy,dimz,dimv);
-      switch (datatype) {
-      case 2: {
-	unsigned char *buffer = new unsigned char[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(unsigned char),dimx*dimy*dimz*dimv,file);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 4: {
-	short *buffer = new short[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(short),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 8: {
-	int *buffer = new int[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(int),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 16: {
-	float *buffer = new float[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(float),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 64: {
-	double *buffer = new double[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(double),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      default: throw CImgIOException("CImg<%s>::load_analyze() : Cannot read images width 'datatype = %d'",pixel_type(),datatype);
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a RAW file
-    static CImg load_raw(const char *filename,const char axe='v',const char align='p') { 
-      return CImgl<T>(filename).get_append(axe,align); 
-    }
-
-    //! Function that loads the image for other file formats that are not natively handled by CImg, using the tool 'convert' from the ImageMagick package.\n
-    //! This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install the ImageMagick package in order to get
-    //! this function working properly (see http://www.imagemagick.org ).
-    static CImg load_convert(const char *filename) {
-      srand((unsigned int)::time(NULL));
-      char command[512], filetmp[512];
-      std::sprintf(filetmp,"%s/CImg%.4d.ppm",cimg::temporary_path(),::rand()%10000);
-      std::sprintf(command,"\"%s\" \"%s\" %s",cimg::convert_path(),filename,filetmp);
-      cimg::system(command);
-      std::FILE *file = std::fopen(filetmp,"rb");
-      if (!file) {
-        std::fclose(cimg::fopen(filename,"r"));
-        throw CImgIOException("CImg<%s>::load_convert() : Failed to open image '%s' with 'convert'.\n"
-			      "Check that you have installed the ImageMagick package in a standart directory.",
-			      pixel_type(),filename);
-      } else cimg::fclose(file);
-      const CImg dest(filetmp);
-      std::remove(filetmp);
-      return dest;
-    }
-
-
-    //! Save the image as a file. 
-    /**
-       The used file format is defined by the file extension in the filename \p filename.\n
-       Parameter \p number can be used to add a 6-digit number to the filename before saving.\n
-       If \p normalize is true, a normalized version of the image (between [0,255]) is saved.
-    **/
-    const CImg& save(const char *filename,const int number=-1) const {
-      cimg_test(*this,"CImg<T>::save");
-      const char *ext = cimg::filename_split(filename);
-      char nfilename[1024];
-      if (number>=0) filename = cimg::file_number(filename,number,6,nfilename);
-      if (!cimg::strcasecmp(ext,"asc")) return save_ascii(filename);
-      if (!cimg::strcasecmp(ext,"dlm")) return save_dlm(filename);
-      if (!cimg::strcasecmp(ext,"inr")) return save_inr(filename);
-      if (!cimg::strcasecmp(ext,"hdr")) return save_analyze(filename);
-      if (!cimg::strcasecmp(ext,"pan")) return save_pandore(filename);
-      if (!cimg::strcasecmp(ext,"bmp")) return save_bmp(filename);
-      if (!cimg::strcasecmp(ext,"raw") || ext[0]=='\0') return save_raw(filename);
-      if (!cimg::strcasecmp(ext,"pgm") || 
-	  !cimg::strcasecmp(ext,"ppm") || 
-	  !cimg::strcasecmp(ext,"pnm")) return save_pnm(filename);
-      return save_convert(filename);
-    }
-  
-    //! Save the image as an ASCII file.
-    const CImg& save_ascii(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_ascii");
-      std::FILE *file = cimg::fopen(filename,"w");
-      std::fprintf(file,"%u %u %u %u\n",width,height,depth,dim);
-      const T* ptrs = data;
-      cimg_mapYZV(*this,y,z,v) {
-	cimg_mapX(*this,x) std::fprintf(file,"%g ",(double)*(ptrs++));
-	std::fputc('\n',file);
-      }
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a DLM file.
-    const CImg& save_dlm(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_dlm");
-      std::FILE *file = cimg::fopen(filename,"w");
-      const T* ptrs = data;
-      cimg_mapYZV(*this,y,z,v) {
-	cimg_mapX(*this,x) std::fprintf(file,"%g%s",(double)*(ptrs++),(x==(int)width-1)?"":",");
-	std::fputc('\n',file);
-      }
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a PNM file.
-    const CImg& save_pnm(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_pnm");
-      const char *ext = cimg::filename_split(filename);
-      if (dim>1 && !cimg::strcasecmp(ext,"pgm")) { get_norm_pointwise().normalize(0,255).save_pnm(filename); return *this; }
-      std::FILE *file = cimg::fopen(filename,"wb");
-      const T 
-	*ptrR = ptr(0,0,0,0),
-	*ptrG = (dim>=2)?ptr(0,0,0,1):ptrR,
-	*ptrB = (dim>=3)?ptr(0,0,0,2):ptrR;
-      const unsigned int buf_size = width*height*(dim==1?1:3);
-      unsigned char *ptrd = new unsigned char[buf_size], *xptrd = ptrd;
-      switch(dim) {
-      case 1: { // Binary PGM
-	std::fprintf(file,"P5\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n255\n",width,height,depth,dim,width,height);
-	cimg_mapXY(*this,x,y) *(xptrd++) = (unsigned char)*(ptrR++);
-      } break;
-      default: { // Binary PPM
-	std::fprintf(file,"P6\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n255\n",width,height,depth,dim,width,height);
-	cimg_mapXY(*this,x,y) {
-	  *(xptrd++) = (unsigned char)*(ptrR++);
-	  *(xptrd++) = (unsigned char)*(ptrG++);
-	  *(xptrd++) = (unsigned char)*(ptrB++);
-	}
-      } break;
-      }
-      cimg::fwrite(ptrd,sizeof(unsigned char),buf_size,file);
-      cimg::fclose(file);
-      delete[] ptrd;
-      return *this;
-    }
-
-    //! Save the image as an ANALYZE7.5 file.
-    const CImg& save_analyze(const char *filename,const float *const voxsize=NULL) const {
-      cimg_test(*this,"CImg<T>::save_analyze");
-      std::FILE *file;
-      char header[348],hname[1024],iname[1024];
-      const char *ext = cimg::filename_split(filename);
-      short datatype=-1;
-      std::memset(header,0,348);
-      if (!ext[0]) { std::sprintf(hname,"%s.hdr",filename); std::sprintf(iname,"%s.img",filename); }
-      if (!cimg::strncasecmp(ext,"hdr",3)) { 
-	std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(iname+cimg::strlen(iname)-3,"img"); 
-      }
-      if (!cimg::strncasecmp(ext,"img",3)) {
-	std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(hname+cimg::strlen(iname)-3,"hdr"); 
-      }
-      ((int*)(header))[0] = 348;
-      std::sprintf(header+4,"CImg");
-      std::sprintf(header+14," ");
-      ((short*)(header+36))[0] = 4096;
-      ((char*)(header+38))[0] = 114;
-      ((short*)(header+40))[0] = 4;
-      ((short*)(header+40))[1] = width;
-      ((short*)(header+40))[2] = height;
-      ((short*)(header+40))[3] = depth;
-      ((short*)(header+40))[4] = dim;
-      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  datatype = 2;
-      if (!cimg::strcasecmp(pixel_type(),"short"))          datatype = 4;
-      if (!cimg::strcasecmp(pixel_type(),"int"))            datatype = 8;
-      if (!cimg::strcasecmp(pixel_type(),"float"))          datatype = 16;
-      if (!cimg::strcasecmp(pixel_type(),"double"))         datatype = 64;
-      ((short*)(header+70))[0] = datatype;
-      ((short*)(header+72))[0] = sizeof(T);
-      ((float*)(header+112))[0] = 1;
-      ((float*)(header+76))[0] = 0;
-      if (voxsize) {
-        ((float*)(header+76))[1] = voxsize[0];
-        ((float*)(header+76))[2] = voxsize[1];
-        ((float*)(header+76))[3] = voxsize[2];
-      } else ((float*)(header+76))[1] = ((float*)(header+76))[2] = ((float*)(header+76))[3] = 1;
-      file = cimg::fopen(hname,"wb");
-      cimg::fwrite(header,sizeof(char),348,file);
-      cimg::fclose(file);
-      file = cimg::fopen(iname,"wb");
-      cimg::fwrite(data,sizeof(T),size(),file);
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a RAW file
-    const CImg& save_raw(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_raw");      
-      CImgl<T> shared(1);
-      shared[0].width = width;
-      shared[0].height = height;
-      shared[0].depth = depth;
-      shared[0].dim = dim;
-      shared[0].data = data;
-      shared.save_raw(filename);
-      shared[0].width = shared[0].height = shared[0].depth = shared[0].dim = 0;
-      shared[0].data = NULL;
-      return *this;
-    }
- 
-    //! Save the image using ImageMagick's convert.    
-    /** Function that saves the image for other file formats that are not natively handled by CImg,
-	using the tool 'convert' from the ImageMagick package.\n
-	This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install 
-	the ImageMagick package in order to get
-	this function working properly (see http://www.imagemagick.org ).
-    **/
-    const CImg& save_convert(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_convert");
-      srand((unsigned int)::time(NULL));
-      char command[512],filetmp[512];
-      std::sprintf(filetmp,"%s/CImg%.4d.ppm",cimg::temporary_path(),::rand()%10000);
-      save_pnm(filetmp);
-      std::sprintf(command,"\"%s\" -quality 100%% \"%s\" %s",cimg::convert_path(),filetmp,filename);
-      cimg::system(command);
-      std::FILE *file = std::fopen(filename,"rb");
-      if (!file) throw CImgIOException("CImg<%s>::save_convert() : Failed to save image '%s' with 'convert'.\n"
-				       "Check that you have installed the ImageMagick package in a standart directory.",
-				       pixel_type(),filename);
-      if (file) cimg::fclose(file);
-      std::remove(filetmp);
-      return *this;
-    }
-  
-    //! Save the image as an INRIMAGE-4 file.
-    const CImg& save_inr(const char *filename,const float *const voxsize = NULL) const {
-      cimg_test(*this,"CImg<T>::save_inr");
-      int inrpixsize=-1;
-      const char *inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0";
-      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  { inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
-      if (!cimg::strcasecmp(pixel_type(),"char"))           { inrtype = "fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
-      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) { inrtype = "unsigned fixed\nPIXSIZE=16 bits\nSCALE=2**0";inrpixsize = 2; }
-      if (!cimg::strcasecmp(pixel_type(),"short"))          { inrtype = "fixed\nPIXSIZE=16 bits\nSCALE=2**0"; inrpixsize = 2; }
-      if (!cimg::strcasecmp(pixel_type(),"unsigned int"))   { inrtype = "unsigned fixed\nPIXSIZE=32 bits\nSCALE=2**0";inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"int"))            { inrtype = "fixed\nPIXSIZE=32 bits\nSCALE=2**0"; inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"float"))          { inrtype = "float\nPIXSIZE=32 bits"; inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"double"))         { inrtype = "float\nPIXSIZE=64 bits"; inrpixsize = 8; }
-      if (inrpixsize<=0) throw CImgIOException("CImg<%s>::save_inr() : Don't know how to save images of '%s'",pixel_type(),pixel_type());
-      std::FILE *file = cimg::fopen(filename,"wb");
-      char header[257];      
-      int err = std::sprintf(header,"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",width,height,depth,dim);
-      if (voxsize) err += std::sprintf(header+err,"VX=%g\nVY=%g\nVZ=%g\n",voxsize[0],voxsize[1],voxsize[2]);
-      err += std::sprintf(header+err,"TYPE=%s\nCPU=%s\n",inrtype,cimg::endian()?"sun":"decm");
-      std::memset(header+err,'\n',252-err);
-      std::memcpy(header+252,"##}\n",4);
-      cimg::fwrite(header,sizeof(char),256,file);
-      cimg_mapXYZ(*this,x,y,z) cimg_mapV(*this,k) cimg::fwrite(&((*this)(x,y,z,k)),inrpixsize,1,file);
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a PANDORE-5 file
-
-#define cimg_save_pandore_case(sy,sz,sv,stype,id)                           \
-   if (!saved && (sy?(sy==height):true) && (sz?(sz==depth):true) && (sv?(sv==dim):true) && !strcmp(stype,pixel_type())) { \
-      unsigned int *iheader = (unsigned int*)(header+12);                   \
-      nbdims = _save_pandore_header_length((*iheader=id),dims);             \
-      cimg::fwrite(header,sizeof(unsigned char),36,file);                   \
-      cimg::fwrite(dims,sizeof(unsigned int),nbdims,file);                  \
-      if (id==2 || id==5 || id==8 || id==16 || id==19 || id==22 || id==26 || id==30) { \
-	unsigned char *buffer = new unsigned char[size()];                  \
-	T *ptrs = ptr();                                                    \
-	cimg_mapoff(*this,off) *(buffer++)=(unsigned char)(*(ptrs++));      \
-	buffer-=size();                                                     \
-	cimg::fwrite(buffer,sizeof(unsigned char),size(),file);             \
-	delete[] buffer;                                                    \
-      }                                                                     \
-      if (id==3 || id==6 || id==9 || id==17 || id==20 || id==23 || id==27 || id==31) { \
-	unsigned long *buffer = new unsigned long[size()];                  \
-	T *ptrs = ptr();                                                    \
-	cimg_mapoff(*this,off) *(buffer++)=(long)(*(ptrs++));               \
-	buffer-=size();                                                     \
-	cimg::fwrite(buffer,sizeof(long),size(),file);                      \
-	delete[] buffer;                                                    \
-      }                                                                     \
-      if (id==4 || id==7 || id==10 || id==18 || id==21 || id==25 || id==29 || id==33) { \
-	float *buffer = new float[size()];                                  \
-	T *ptrs = ptr();                                                    \
-	cimg_mapoff(*this,off) *(buffer++)=(float)(*(ptrs++));              \
-	buffer-=size();                                                     \
-	cimg::fwrite(buffer,sizeof(float),size(),file);                     \
-	delete[] buffer;                                                    \
-      }                                                                     \
-      saved = true;                                                         \
-    }
-
-    unsigned int _save_pandore_header_length(unsigned int id,unsigned int *dims) const {
-      unsigned int nbdims=0;
-      if (id==2 || id==3 || id==4)    { dims[0]=1; dims[1]=width; nbdims=2; }
-      if (id==5 || id==6 || id==7)    { dims[0]=1; dims[1]=height; dims[2]=width; nbdims=3; }
-      if (id==8 || id==9 || id==10)   { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
-      if (id==16 || id==17 || id==18) { dims[0]=3; dims[1]=height; dims[2]=width; dims[3]=1; nbdims=4; }
-      if (id==19 || id==20 || id==21) { dims[0]=3; dims[1]=depth; dims[2]=height; dims[3]=width; dims[4]=0; nbdims=5; }
-      if (id==22 || id==23 || id==25) { dims[0]=dim; dims[1]=width; nbdims=2; }
-      if (id==26 || id==27 || id==29) { dims[0]=dim; dims[1]=height; dims[2]=width; nbdims=3; }
-      if (id==30 || id==31 || id==33) { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
-      return nbdims;
-    }    
-
-    const CImg& save_pandore(const char* filename) const {
-      cimg_test(*this,"CImg<T>::save_pandore");
-      std::FILE *file = cimg::fopen(filename,"wb");
-      unsigned char header[36] = { 'P','A','N','D','O','R','E','0','4',0,0,0,
-				   0,0,0,0,'C','I','m','g',0,0,0,0,0,
-				   '2','0','0','0','/','0','1','/','0','1',
-				   0 };
-      unsigned int nbdims,dims[5];
-      bool saved=false;
-      cimg_save_pandore_case(1,1,1,"unsigned char",2);
-      cimg_save_pandore_case(1,1,1,"char",3);
-      cimg_save_pandore_case(1,1,1,"short",3);
-      cimg_save_pandore_case(1,1,1,"unsigned short",3);
-      cimg_save_pandore_case(1,1,1,"unsigned int",3);
-      cimg_save_pandore_case(1,1,1,"int",3);
-      cimg_save_pandore_case(1,1,1,"unsigned long",4);
-      cimg_save_pandore_case(1,1,1,"long",3);
-      cimg_save_pandore_case(1,1,1,"float",4);
-      cimg_save_pandore_case(1,1,1,"double",4);
- 
-      cimg_save_pandore_case(0,1,1,"unsigned char",5);
-      cimg_save_pandore_case(0,1,1,"char",6);
-      cimg_save_pandore_case(0,1,1,"short",6);
-      cimg_save_pandore_case(0,1,1,"unsigned short",6);
-      cimg_save_pandore_case(0,1,1,"unsigned int",6);
-      cimg_save_pandore_case(0,1,1,"int",6);
-      cimg_save_pandore_case(0,1,1,"unsigned long",7);
-      cimg_save_pandore_case(0,1,1,"long",6);
-      cimg_save_pandore_case(0,1,1,"float",7);
-      cimg_save_pandore_case(0,1,1,"double",7);
-
-      cimg_save_pandore_case(0,0,1,"unsigned char",8);
-      cimg_save_pandore_case(0,0,1,"char",9);
-      cimg_save_pandore_case(0,0,1,"short",9);
-      cimg_save_pandore_case(0,0,1,"unsigned short",9);
-      cimg_save_pandore_case(0,0,1,"unsigned int",9);
-      cimg_save_pandore_case(0,0,1,"int",9);
-      cimg_save_pandore_case(0,0,1,"unsigned long",10);
-      cimg_save_pandore_case(0,0,1,"long",9);
-      cimg_save_pandore_case(0,0,1,"float",10);
-      cimg_save_pandore_case(0,0,1,"double",10);
-      
-      cimg_save_pandore_case(0,1,3,"unsigned char",16);
-      cimg_save_pandore_case(0,1,3,"char",17);
-      cimg_save_pandore_case(0,1,3,"short",17);
-      cimg_save_pandore_case(0,1,3,"unsigned short",17);
-      cimg_save_pandore_case(0,1,3,"unsigned int",17);
-      cimg_save_pandore_case(0,1,3,"int",17);
-      cimg_save_pandore_case(0,1,3,"unsigned long",18);
-      cimg_save_pandore_case(0,1,3,"long",17);
-      cimg_save_pandore_case(0,1,3,"float",18);
-      cimg_save_pandore_case(0,1,3,"double",18);
-
-      cimg_save_pandore_case(0,0,3,"unsigned char",19);
-      cimg_save_pandore_case(0,0,3,"char",20);
-      cimg_save_pandore_case(0,0,3,"short",20);
-      cimg_save_pandore_case(0,0,3,"unsigned short",20);
-      cimg_save_pandore_case(0,0,3,"unsigned int",20);
-      cimg_save_pandore_case(0,0,3,"int",20);
-      cimg_save_pandore_case(0,0,3,"unsigned long",21);
-      cimg_save_pandore_case(0,0,3,"long",20);
-      cimg_save_pandore_case(0,0,3,"float",21);
-      cimg_save_pandore_case(0,0,3,"double",21);
-     
-      cimg_save_pandore_case(1,1,0,"unsigned char",22);
-      cimg_save_pandore_case(1,1,0,"char",23);
-      cimg_save_pandore_case(1,1,0,"short",23);
-      cimg_save_pandore_case(1,1,0,"unsigned short",23);
-      cimg_save_pandore_case(1,1,0,"unsigned int",23);
-      cimg_save_pandore_case(1,1,0,"int",23);
-      cimg_save_pandore_case(1,1,0,"unsigned long",25);
-      cimg_save_pandore_case(1,1,0,"long",23);
-      cimg_save_pandore_case(1,1,0,"float",25);
-      cimg_save_pandore_case(1,1,0,"double",25);
- 
-      cimg_save_pandore_case(0,1,0,"unsigned char",26);
-      cimg_save_pandore_case(0,1,0,"char",27);
-      cimg_save_pandore_case(0,1,0,"short",27);
-      cimg_save_pandore_case(0,1,0,"unsigned short",27);
-      cimg_save_pandore_case(0,1,0,"unsigned int",27);
-      cimg_save_pandore_case(0,1,0,"int",27);
-      cimg_save_pandore_case(0,1,0,"unsigned long",29);
-      cimg_save_pandore_case(0,1,0,"long",27);
-      cimg_save_pandore_case(0,1,0,"float",29);
-      cimg_save_pandore_case(0,1,0,"double",29);
-
-      cimg_save_pandore_case(0,0,0,"unsigned char",30);
-      cimg_save_pandore_case(0,0,0,"char",31);
-      cimg_save_pandore_case(0,0,0,"short",31);
-      cimg_save_pandore_case(0,0,0,"unsigned short",31);
-      cimg_save_pandore_case(0,0,0,"unsigned int",31);
-      cimg_save_pandore_case(0,0,0,"int",31);
-      cimg_save_pandore_case(0,0,0,"unsigned long",33);
-      cimg_save_pandore_case(0,0,0,"long",31);
-      cimg_save_pandore_case(0,0,0,"float",33);
-      cimg_save_pandore_case(0,0,0,"double",33);
-
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a BMP file
-    const CImg& save_bmp(const char* filename) const {
-      cimg_test(*this,"CImg<T>::save_bmp");
-      std::FILE *file = cimg::fopen(filename,"wb");
-
-      unsigned char header[54]={0}, align_buf[4]={0};
-      const unsigned int 
-	align     = (4-(3*width)%4)%4,
-	buf_size  = (3*width+align)*dimy(),
-	file_size = 54+buf_size;
-      header[0] = 'B'; header[1] = 'M';
-      header[0x02]=file_size&0xFF; header[0x03]=(file_size>>8)&0xFF;
-      header[0x04]=(file_size>>16)&0xFF; header[0x05]=(file_size>>24)&0xFF;
-      header[0x0A]=0x36;
-      header[0x0E]=0x28;
-      header[0x12]=width&0xFF; header[0x13]=(width>>8)&0xFF;
-      header[0x14]=(width>>16)&0xFF; header[0x15]=(width>>24)&0xFF;
-      header[0x16]=height&0xFF; header[0x17]=(height>>8)&0xFF;
-      header[0x18]=(height>>16)&0xFF; header[0x19]=(height>>24)&0xFF;
-      header[0x1A]=1;  header[0x1B]=0;
-      header[0x1C]=24; header[0x1D]=0;
-      header[0x22]=buf_size&0xFF; header[0x23]=(buf_size>>8)&0xFF;
-      header[0x24]=(buf_size>>16)&0xFF; header[0x25]=(buf_size>>24)&0xFF;
-      header[0x27]=0x1; header[0x2B]=0x1;
-      cimg::fwrite(header,sizeof(unsigned char),54,file);
-
-      const T
-	*pR = ptr(0,height-1,0,0),
-	*pG = (dim>=2)?ptr(0,height-1,0,1):pR, 
-	*pB = (dim>=3)?ptr(0,height-1,0,2):pR;
-
-      cimg_mapY(*this,y) {
-	cimg_mapX(*this,x) {
-	  std::fputc((unsigned char)(*(pB++)),file);
-	  std::fputc((unsigned char)(*(pG++)),file);
-	  std::fputc((unsigned char)(*(pR++)),file);
-	}
-	std::fwrite(align_buf,sizeof(unsigned char),align,file);
-	pR-=2*width; pG-=2*width; pB-=2*width;	
-      }      
-      cimg::fclose(file);
-      return *this;
-    }
-
-    
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Other functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    CImg& swap(CImg& img) {
-      cimg::swap(width,img.width);
-      cimg::swap(height,img.height);
-      cimg::swap(depth,img.depth);
-      cimg::swap(dim,img.dim);
-      cimg::swap(data,img.data);
-      return img;
-    }
-
-#ifdef cimg_plugin
-#include cimg_plugin
-#endif
-    
-    //@}
-  };
-
-
-  /*-------------------------------------------------------
-    
-
-
-
-  Definition of the CImgl<> structure
-
-
-
-
-  ------------------------------------------------------*/
-
-  //! This class represents list of images CImg<T>.
-  template<typename T> struct CImgl {       
-    //! This variable represents the number of images in the image list.
-    /**
-       \note if \c size==0, the image list is empty.
-    **/
-    unsigned int size;
-    
-    //! This variable represents a pointer to the first \c CImg<T> image of the list.
-    /**
-       \note the images are stored continuously in memory.
-       \note If the list is empty, \c data=NULL.
-    **/
-    CImg<T> *data;                      //!< Pointer to the first image of the image list.
-    
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Constructors - Destructor - Copy
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Return a string describing the type of the image pixels in the list (template parameter \p T).
-    static const char* pixel_type() { T val; return cimg::get_type(val); }
-    
-    //! Create a list of \p n new images, each having size (\p width,\p height,\p depth,\p dim).
-    CImgl(const unsigned int n=0,const unsigned int width=0,const unsigned int height=1,
-	  const unsigned int depth=1, const unsigned int dim=1):size(n) {
-      if (n) {
-	data = new CImg<T>[(n/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l]=CImg<T>(width,height,depth,dim);
-      } else data = NULL;
-    }
-    
-    // ! Create a list of \p n copy of the input image.
-    template<typename t> CImgl(const unsigned int n, const CImg<t>& img):size(n) {
-      if (n) {
-	data = new CImg<T>[(n/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l]=img;
-      } else data = NULL;
-    }
-    
-    //! Copy constructor.
-    template<typename t> CImgl(const CImgl<t>& list):size(list.size) {
-      if (size) {
-	data = new CImg<T>[(size/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l] = list[l];
-      } else data = NULL;
-    }
-    CImgl(const CImgl<T>& list):size(list.size) {
-      if (size>0) {
-	data = new CImg<T>[(size/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l] = list[l];
-      } else data = NULL;
-    }
-
-    //! Create a list by loading a file.
-    CImgl(const char* filename):size(0),data(NULL) { load(filename).swap(*this); }
-    
-    //! Create a list from a single image \p img.
-    CImgl(const CImg<T>& img):size(0),data(NULL) { CImgl<T>(1,img).swap(*this); }
-
-    //! Create a list from two images \p img1 and \p img2 (images are copied).
-    CImgl(const CImg<T>& img1,const CImg<T>& img2):size(2) {
-      data = new CImg<T>[cimg::lblock];
-      data[0] = img1;
-      data[1] = img2;
-    }
-
-    //! Create a list from three images \p img1,\p img2 and \p img3 (images are copied).
-    CImgl(const CImg<T>& img1,const CImg<T>& img2,const CImg<T>& img3):size(3) {
-      data = new CImg<T>[cimg::lblock];
-      data[0] = img1;
-      data[1] = img2;
-      data[2] = img3;
-    }
-
-    //! Create a list from four images \p img1,\p img2,\p img3 and \p img4 (images are copied).
-    CImgl(const CImg<T>& img1,const CImg<T>& img2,const CImg<T>& img3,const CImg<T>& img4):size(4) {
-      data = new CImg<T>[cimg::lblock];
-      data[0] = img1;
-      data[1] = img2;
-      data[2] = img3;
-      data[3] = img4;
-    }
-    
-    //! Copy a list into another one.
-    template<typename t> CImgl& operator=(const CImgl<t>& list) { return CImgl<T>(list).swap(*this); }
-    CImgl& operator=(const CImgl<T>& list) { if (&list==this) return *this; return CImgl<T>(list).swap(*this); }
-    
-    //! Destructor
-    ~CImgl() { if (data) delete[] data; }
-    
-    //! Empty list
-    CImgl& empty() { return CImgl<T>().swap(*this); }
-    
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Arithmetics operators
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Add each image of the current list with the corresponding image in the list \p list.
-    template<typename t> CImgl& operator+=(const CImgl<t>& list) {
-      const unsigned int sizemax = min(size,list.size);
-      for (unsigned int l=0; l<sizemax; l++) (*this)[l]+=list[l];
-      return *this;
-    }
-    
-    //! Subtract each image of the current list with the corresponding image in the list \p list.
-    template<typename t> CImgl& operator-=(const CImgl<t>& list) {
-      const unsigned int sizemax = min(size,list.size);
-      for (unsigned int l=0; l<sizemax; l++) (*this)[l]-=list[l];
-      return *this;
-    }
-    
-    //! Add each image of the current list with a value \p val.
-    CImgl& operator+=(const T& val) { cimgl_map(*this,l) (*this)[l]+=val; return *this; }
-    
-    //! Substract each image of the current list with a value \p val.
-    CImgl& operator-=(const T& val) { cimgl_map(*this,l) (*this)[l]-=val; return *this; }
-    
-    //! Multiply each image of the current list by a value \p val.
-    CImgl& operator*=(const double val) { cimgl_map(*this,l) (*this)[l]*=val; return *this; }
-    
-    //! Divide each image of the current list by a value \p val.
-    CImgl& operator/=(const double val) { cimgl_map(*this,l) (*this)[l]/=val; return *this; }
-    
-    //! Return a new image list corresponding to the addition of each image of the current list with a value \p val.
-    CImgl operator+(const T& val) const { return CImgl<T>(*this)+=val;  }
-    
-    //! Return a new image list corresponding to the multiplication of each image of the current list by a value \p val.
-    CImgl operator*(const double val) const { return CImgl<T>(*this)*=val;  }
-    
-    //! Return a new image list corresponding to the substraction of each image of the current list with a value \p val.
-    CImgl operator-(const T& val) const { return CImgl<T>(*this)-=val;  }
-    
-    //! Return a new image list corresponding to the division of each image of the current list by a value \p val.
-    CImgl operator/(const double val) const { return CImgl<T>(*this)/=val;  }
-    
-    //! Return a new image list corresponding to the addition of each image of the current list with the corresponding image in the list \p list.
-    CImgl operator+(const CImgl& list) const { return CImgl<T>(*this)+=list; }
-
-    //! Return a new image list corresponding to the substraction of each image of the current list with the corresponding image in the list \p list.
-    CImgl operator-(const CImgl& list) const { return CImgl<T>(*this)-=list; }
-    
-    //! Return a new image list corresponding to the addition of each image of the current list with a value \p val;
-    friend CImgl operator+(const T& val, const CImgl& list) { return CImgl<T>(list)+=val; }
-    
-    //! Return a new image list corresponding to the scalar multiplication of each image of the current list by a value \p val.
-    friend CImgl operator*(const double val, const CImgl& list) { return CImgl<T>(list)*=val; }
-  
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name List operations
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Return a reference to the i-th element of the image list.
-    CImg<T>& operator[](const unsigned int pos) const {
-#if cimg_debug>1
-      if (pos>=size) {
-	cimg::warn(true,"CImgl<%s>::operator[] : bad list position %u, in a list of %u images",pixel_type(),pos,size);
-	return *data;
-      }
-#endif
-      return data[pos];
-    }
-    
-    //! Equivalent to CImgl<T>::operator[]
-    CImg<T>& operator()(const unsigned int pos) const { return (*this)[pos]; }
-    
-    //! Insert a copy of the image \p img into the current image list, at position \p pos.
-    CImgl& insert(const CImg<T>& img,const unsigned int pos) {
-      if (pos>size) throw CImgArgumentException("CImgl<%s>::insert() : Can't insert at position %u into a list with %u elements",pixel_type(),pos,size);
-      CImg<T> *new_data = (!((++size)%cimg::lblock) || !data)?new CImg<T>[(size/cimg::lblock+1)*cimg::lblock]:NULL;
-      if (!data) { data=new_data; *data=img; }
-      else {
-	if (new_data) {
-	  std::memcpy(new_data,data,sizeof(CImg<T>)*pos);
-	  if (pos!=size-1) std::memcpy(new_data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-	  std::memset(data,0,sizeof(CImg<T>)*(size-1));
-	  delete[] data;
-	  data = new_data;
-	}
-	else if (pos!=size-1) memmove(data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-	data[pos].data = NULL;
-	data[pos] = img;
-      }
-      return *this;
-    }
-    
-    //! Append a copy of the image \p img at the current image list.
-    CImgl& insert(const CImg<T>& img) { return insert(img,size); }
-    
-    //! Insert a copy of the image list \p list into the current image list, starting from position \p pos.
-    CImgl& insert(const CImgl<T>& list,const unsigned int pos) { cimgl_map(list,l) insert(list[l],pos+l); return *this; }
-    
-    //! Append a copy of the image list \p list at the current image list.
-    CImgl& insert(const CImgl<T>& list) { return insert(list,size); }
-    
-    //! Remove the image at position \p pos from the image list.
-    CImgl& remove(const unsigned int pos) {
-      if (pos>=size) { 
-	cimg::warn(true,"CImgl<%s>::remove() : Can't remove an image from a list (%p,%u), at position %u",pixel_type(),data,size,pos);
-	return *this;
-      }
-      CImg<T> tmp; tmp.swap(data[pos]); // the image to remove will be freed
-      size--;
-      if (pos!=size) { 
-	memmove(data+pos,data+pos+1,sizeof(CImg<T>)*(size-pos));
-	CImg<T> &tmp = data[size];
-	tmp.width = tmp.height = tmp.depth = tmp.dim = 0;
-	tmp.data = NULL;
-      }
-      return *this;
-    }
-
-    //! Remove the last image from the image list.
-    CImgl& remove() { return remove(size); }  
-
-    //! Reverse list order
-    CImgl& reverse() {
-      for (unsigned int l=0; l<size/2; l++) (*this)[l].swap((*this)[size-1-l]);
-      return *this;
-    }
-    
-    CImgl& get_reverse() { return CImgl<T>(*this).reverse(); }
-    
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name IO and display functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Print informations about the list on the standart error stream.
-    const CImgl& print(const char* title=NULL,const int print_flag=1) const { 
-      char tmp[1024];
-      std::fprintf(stderr,"%-8s(%p) : (%u,%p)\n",title?title:"CImgl",(void*)this,size,(void*)data);
-      if (print_flag>0)	cimgl_map(*this,l) {
-	std::sprintf(tmp,"%s[%d]",title?title:"CImgl",l);
-	data[l].print(tmp,print_flag);
-      }
-      return *this;
-    }
-    //! Load an image list from a file (.raw format).
-
-#define cimg_load_raw_case(Ts,Tss)					 	 \
-  if (!loaded && !cimg::strcasecmp(Ts,tmp2)) for (unsigned int l=0; l<n; l++) {  \
-      Tss *buf;                                                         \
-      const bool endian = cimg::endian();                               \
-      j=0; while((i=fgetc(file))!='\n') tmp[j++]=(char)i; tmp[j]='\0';  \
-      std::sscanf(tmp,"%u %u %u %u",&w,&h,&z,&k);                       \
-      buf = new Tss[w*h*z*k]; cimg::fread(buf,sizeof(Tss),w*h*z*k,file);\
-      if (endian) cimg::endian_swap(buf,w*h*z*k);	   	        \
-      CImg<T> idest(w,h,z,k); cimg_mapoff(idest,off)                    \
-                        idest[off] = (T)(buf[off]); idest.swap(res[l]); \
-      delete[] buf;                                                     \
-      loaded = true;                                                    \
-    }
-
-    static CImgl load_raw(const char *filename) {
-      typedef unsigned char uchar;
-      typedef unsigned short ushort;
-      typedef unsigned int uint;  
-      typedef unsigned long ulong; 
-      std::FILE *file = cimg::fopen(filename,"rb");
-      char tmp[256],tmp2[256];
-      int i;
-      bool loaded = false;
-      unsigned int n,j,w,h,z,k,err;
-      j=0; while((i=fgetc(file))!='\n' && i!=EOF) tmp[j++]=i; tmp[j]='\0';
-      err=std::sscanf(tmp,"%u#%255[A-Za-z ]",&n,tmp2);
-      if (err!=2) throw CImgIOException("CImgl<%s>::load_raw() : file '%s', Unknow .raw header",pixel_type(),filename);
-      CImgl<T> res(n);
-      cimg_load_raw_case("unsigned char",uchar);
-      cimg_load_raw_case("uchar",uchar);
-      cimg_load_raw_case("char",char);
-      cimg_load_raw_case("unsigned short",ushort);
-      cimg_load_raw_case("ushort",ushort);
-      cimg_load_raw_case("short",short);
-      cimg_load_raw_case("unsigned int",uint);
-      cimg_load_raw_case("uint",uint);
-      cimg_load_raw_case("int",int);
-      cimg_load_raw_case("unsigned long",ulong);
-      cimg_load_raw_case("ulong",ulong);
-      cimg_load_raw_case("long",long);
-      cimg_load_raw_case("float",float);
-      cimg_load_raw_case("double",double);
-      if (!loaded) throw CImgIOException("CImgl<%s>::load_raw() : file '%s', can't read images of %s",pixel_type(),filename,tmp2);
-      cimg::fclose(file);
-      return res;
-    }
-
-    //! Load an image list from a file. The file should be a '.raw' format, else only one image will be loaded into the list.
-    static CImgl load(const char *filename) {
-      CImgl res;
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strcasecmp(ext,"raw") || !ext[0]) return load_raw(filename); else return CImg<T>(filename);
-    }
-
-
-    //! Save an image list into a file.
-    /**
-       Depending on the extension of the given filename, a file format is chosen for the output file.       
-    **/    
-    const CImgl& save(const char *filename) const {
-      cimgl_test(*this,"CImgl<T>::save");
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strcasecmp(ext,"raw") || !ext[0]) return save_raw(filename);
-      else {
-	if (size==1) data[0].save(filename,-1);
-	else cimgl_map(*this,l) data[l].save(filename,l);
-      }
-      return *this;
-    }
-
-    //! Save an image list into a RAW file.
-    /**
-       A RAW file is a simple uncompressed binary file that may be used to save list of CImg<T> images.
-       \param filename : name of the output file.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& save_raw(const char *filename) const {
-      cimgl_test(*this,"CImgl<T>::save_raw");
-      std::FILE *file = cimg::fopen(filename,"wb");
-      std::fprintf(file,"%u#%s\n",size,pixel_type());
-      cimgl_map(*this,l) {
-	const CImg<T>& img = data[l];
-	std::fprintf(file,"%u %u %u %u\n",img.width,img.height,img.depth,img.dim);
-	if (cimg::endian()) {
-	  CImg<T> tmp(img);
-	  cimg::endian_swap(tmp.data,tmp.size());
-	  cimg::fwrite(tmp.data,sizeof(T),img.width*img.height*img.depth*img.dim,file);
-	} else cimg::fwrite(img.data,sizeof(T),img.width*img.height*img.depth*img.dim,file);
-      }
-      cimg::fclose(file);
-      return *this;
-    }    
-
-    //! Return a single image which is the concatenation of all images of the current CImgl instance.
-    /**
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \return A CImg<T> image corresponding to the concatenation is returned.
-    **/
-    CImg<T> get_append(const char axe='x',const char align='c') const {
-      cimgl_test(*this,"CImgl<T>::get_append");
-      unsigned int dx=0,dy=0,dz=0,dv=0,pos=0;
-      CImg<T> res;
-      switch(cimg::uncase(axe)) {
-      case 'x': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx += img.width;
-	  dy = cimg::max(dy,img.height);
-	  dz = cimg::max(dz,img.depth);
-	  dv = cimg::max(dv,img.dim);
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p' : { cimgl_map(*this,ll) { res.draw_image((*this)[ll],pos,0,0,0); pos+=(*this)[ll].width; }} break;
-	case 'n' : { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],pos,dy-(*this)[ll].height,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].width;
-	    }} break;
-	default  : { cimgl_map(*this,ll) {
-	      res.draw_image((*this)[ll],pos,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
-	      pos+=(*this)[ll].width; 
-	    }} break;
-	}
-      }	break;
-      case 'y': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx = cimg::max(dx,img.width);
-	  dy += img.height;
-	  dz = cimg::max(dz,img.depth);
-	  dv = cimg::max(dv,img.dim);
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,pos,0,0); pos+=(*this)[ll].height; }} break;
-	case 'n': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],dx-(*this)[ll].width,pos,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].height;
-	    }} break;
-	default : { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,pos,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
-	      pos+=(*this)[ll].height; 
-	    }} break;
-	}
-      }	break;
-      case 'z': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx = cimg::max(dx,img.width);
-	  dy = cimg::max(dy,img.height);
-	  dz += img.depth;
-	  dv = cimg::max(dv,img.dim);
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,0,pos,0); pos+=(*this)[ll].depth; }} break;
-	case 'n': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,pos,dv-(*this)[ll].dim); pos+=(*this)[ll].depth;
-	    }} break;
-	case 'c': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,pos,(dv-(*this)[ll].dim)/2);
-	      pos+=(*this)[ll].depth; 
-	    }} break;
-	}
-      }	break;
-      case 'v': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx = cimg::max(dx,img.width);
-	  dy = cimg::max(dy,img.height);
-	  dz = cimg::max(dz,img.depth);
-	  dv += img.dim;
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,0,0,pos); pos+=(*this)[ll].dim; }} break;
-	case 'n': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,dz-(*this)[ll].depth,pos); pos+=(*this)[ll].dim;
-	    }} break;
-	case 'c': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,pos);
-	      pos+=(*this)[ll].dim; 
-	    }} break;
-	}
-      } break;
-      }
-      return res;
-    }
-    
-    //! Display the current CImgl instance in an existing CImgDisplay window (by reference).
-    /**
-       This function displays the list images of the current CImgl instance into an existing CImgDisplay window.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns immediately.
-       \param disp : reference to an existing CImgDisplay instance, where the current image list will be displayed.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(CImgDisplay& disp,const char axe='x',const char align='c') const { 
-      get_append(axe,align).display(disp); return *this; 
-    }
-
-    //! Display the current CImgl instance in an existing CImgDisplay window (by pointer).
-    /**
-       This function displays the list images of the current CImgl instance into an existing CImgDisplay window.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns immediately.
-       \param disp : pointer to an existing CImgDisplay instance, where the current image list will be displayed.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(CImgDisplay* disp,const char axe='x',const char align='c') const { 
-      if (!disp) throw CImgArgumentException("CImgl<%s>::display() : given display pointer is (null)",pixel_type());
-      else display(*disp,axe,align);
-      return *this;
-    }
-
-    //! Display the current CImgl instance in a new display window.
-    /**
-       This function opens a new window with a specific title and displays the list images of the current CImgl instance into it.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns when a key is pressed or the display window is closed by the user.
-       \param title : specify the title of the opening display window.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(const char* title,const char axe='x',const char align='c',
-			 const int min_size=128,const int max_size=1024) const {
-      get_append(axe,align).display(title,min_size,max_size);
-      return *this;
-    }
-
-    //! Display the current CImgl instance in a new display window.
-    /**
-       This function opens a new window and displays the list images of the current CImgl instance into it.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns when a key is pressed or the display window is closed by the user.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(const char axe='x',const char align='c',
-			 const int min_size=128,const int max_size=1024) const {
-      return display("",axe,align,min_size,max_size); 
-    }
-
-    //! Same as \ref cimg::wait()
-    /**
-       \see cimg::wait().
-    **/
-    const CImgl& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this;  }
-    
-    // Swap fields of two CImgl instances.
-    CImgl& swap(CImgl& list) {
-      cimg::swap(size,list.size);
-      cimg::swap(data,list.data);
-      return list;
-    }
-
-#ifdef cimgl_plugin
-#include cimgl_plugin
-#endif
-   
-    //@}
-  };
-
-
-  //! This class represents a region of interest of a CImg<T> image.
-  /**
-     When using the functions CImg<T>::ref_*(), an instance of a CImgROI<T> is returned, corresponding
-     to a sub-image of the original image. Acting on the CImgROI<T> instance allows to modify only a
-     part of the original image.
-     CImgROI<T> instances should be handled with care.  
-  **/
-  template<typename T> struct CImgROI : public CImg<T> {
-    CImgROI(const unsigned int dx,const unsigned int dy,const unsigned int dz,const unsigned int dv,T *const pdata) {
-      CImg<T>::width = dx; CImg<T>::height = dy; CImg<T>::depth = dz; CImg<T>::dim = dv; CImg<T>::data = pdata;
-    }
-    CImgROI(const CImgROI& roi) {
-      CImg<T>::width = roi.width; CImg<T>::height = roi.height; CImg<T>::depth = roi.depth; CImg<T>::dim = roi.dim; 
-      CImg<T>::data = roi.data;
-    }
-    ~CImgROI() { CImg<T>::width=CImg<T>::height=CImg<T>::depth=CImg<T>::dim=0; CImg<T>::data=NULL;}
-  };
-  
-}
-
-// Overcome VisualC++ 6.0 and DMC compilers namespace bug
-#if ( defined(_MSC_VER) || defined(__DMC__) ) && defined(std)
-#undef std
-#endif
-
-/*--------------------------------------------------------------------------------------
-
-
-
-  Additional documentation for the generation of the reference page (using doxygen)
-
-
-
-  -------------------------------------------------------------------------------------*/
-/**
-   \mainpage
-   
-   This is the reference documentation of <a href="http://cimg.sourceforge.net">the CImg Library</a>.
-   This documentation has been automatically generated from the header file CImg.h, using the tool
-   <a href="http://www.doxygen.org">doxygen</a>.
-   It contains a detailed description of all classes and functions of <a href="http://cimg.sourceforge.net">the CImg Library</a>.
-   If you don't know what the CImg Library is, you should go to <a href="http://cimg.sourceforge.net">the project web page</a>
-   first.
-   
-   You can easily navigate through the documentation pages, using the menu above.
-
-   To get started, you may first check the list of <a href="modules.html">available modules</a>.
-
-*/
-
-//---------------------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_structure Introduction to the CImg Library */
-/*@{
-  \page foo2
-
-  The CImg Library consists in a \b single \b header \b file \ref CImg.h providing a set of C++ classes that
-  can be used in your own sources, to load/save, process and display images. Very portable 
-  (Unix/X11,Windows, MacOS X, FreeBSD,..), efficient, simple to use, it's a pleasant toolkit
-  for coding image processing stuffs in C++.
-
-  \section s1 Library structure
-
-  The file \ref CImg.h contains all the classes and functions that compose the library itself.
-  It is organized as follows :
-  
-  - All library classes and functions are defined in the namespace cimg_library. This namespace
-  encapsulates all library functionalities and avoid any class name collision that could happen with
-  other includes. Generally, one uses this namespace as a default namespace :
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-  \endcode
-
-  - The namespace cimg_library::cimg defines a set of \e low-level functions and variables used by the library.
-  Documented functions in this namespace can be safely used in your own program. But, \b never use the
-  cimg_library::cimg namespace as a default namespace, since it contains functions whose names are already
-  used in the standart C library.
-
-  - The class \ref cimg_library::CImg represents images up to 4-dimensions wide, containing pixels of type \c T.
-  This is actually the main class of the library.
-
-  - The class cimg_library::CImgl represents lists of cimg_library::CImg images. It can be used for instance
-  to store different frames of an image sequence.
-
-  - The class cimg_library::CImgDisplay is able to display images or image lists into graphical windows.
-  As you may guess, the code of this class is highly system-dependant (see \c cimg_display_type in \ref cimg_environment ).
-
-  - The class cimg_library::CImgStats represents simple image statistics. Use it to compute the
-  minimum, maximum, mean and variance of pixel values of images.
-
-  - The class cimg_library::CImgException (and its subclasses) are used by the library to throw exceptions
-  when errors occur. Those exceptions can be catched with a bloc <tt>try { ..} catch (CImgException) { .. }</tt>.
-  Subclasses define more precisely the type of the encountered error.
-
-  Knowing these five classes is enough to get benefit of most of the CImg Library functionalities.
-
-  As you can see, all the library functions and classes are defined in a single header file CImg.h.
-  This may sound strange, but it is actually one major advantage of the CImg library :
-
-  - The compilation is done on the fly : Only functions \e really \e used in your program are compiled and appear in the final
-  program. This leads to very compact executables, without any unused functions code.
-  - Class members and functions are inlined, leading to better performance during execution.
-  - No complex dependancies have to be handled : Just include the CImg.h file, and you get a working toolkit that processes images.
-
-  \section s2 CImg version of "Hello world".
-
-  Below is a very simple code that creates a "Hello World" image. This shows you basically how a CImg program looks like.
-
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-
-  int main() {
-    CImg<unsigned char> img(640,400,1,3);        // Define a 640x400 color image
-    img.fill(0);                                 // Set pixel values to 0 (color : black)
-    unsigned char purple[3]={255,0,255};         // Define a purple color
-    img.draw_text("Hello World",100,100,purple); // Draw a purple "Hello world" at coordinates (100,100).
-    img.display("Hello World");                  // Display the image
-    return 0;
-  }
-  \endcode
-
-  Which can be also written in a more compact way as :
-
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-
-  int main() {
-    const unsigned char purple[3]={255,0,255};
-    CImg<unsigned char>(640,400,1,3,0).draw_text("Hello World",100,100,purple).display("Hello World");
-    return 0;
-  }
-  \endcode
-
-  Generally, you can write very small code that performs complex image tasks. The CImg Library is very simple
-  to use but provide a lot of interesting algorithms for image manipulation.
-  
-  \section s3 How to compile ?
-
-  The CImg library is a very light and user-friendly library : only standart system libraries are used.
-  this avoid to handle complex dependancies and problems with library compatibility.
-  The only thing you need is a (quite modern) C++ compiler. Before each release, the CImg library
-  is successfully compiled with the following compilers :
-  
-  - <b>Microsoft Visual C++ 6.0 and Visual Studio.NET</b> : Use project files and solution files provided in the 
-  CImg Library package to see how it works.
-  - <b>Intel ICL compiler</b> : Use the following command to compile a CImg-based program with ICL :
-  \code
-  icl /Ox hello_world.cpp user32.lib gdi32.lib
-  \endcode
-  - <b>Digital Mars Compiler</b> : Use the following command to compile a CImg-based program with DMC :
-  \code
-  dmc -Ae hello_world.cpp gdi32.lib
-  \endcode
-  - <b>g++ (MingW windows version)</b> : Use the following command to compile a CImg-based program with g++, on Windows :
-  \code
-  g++ -o hello_word.exe hello_word.cpp -O2 -lgdi32
-  \endcode
-  - <b>g++ (Linux version)</b> : Use the following command to compile a CImg-based program with g++, on Linux :
-  \code
-  g++ -o hello_word.exe hello_world.cpp -O2 -Wl,-rpath /usr/X11R6/lib -lm -lpthread -lX11
-  \endcode
-  - <b>g++ (Solaris version)</b> : Use the following command to compile a CImg-based program with g++, on Solaris :
-  \code
-  g++ -o hello_word.exe hello_world.cpp -O2 -lm -lpthread -R/usr/X11R6/lib -lrt -lnsl -lsocket
-  \endcode
-  - <b>g++ (Mac OS X version)</b> : Use the following command to compile a CImg-based program with g++, on Mac OS X :
-  \code
-  g++ -o hello_word.exe hello_world.cpp -O2 -lm -lpthread -L/usr/X11R6/lib -lm -lpthread -lX11
-  \endcode
-  - <b>Dev-Cpp</b> : Use the project file provided in the CImg library package to see how it works.
-
-  If you are using another compilers and encounter problems, please
-  <a href="http://www.greyc.ensicaen.fr/~dtschump">write me</a> since maintaining compatibility is one
-  of my priority.
-
-  \section s4 What's next ?
-
-  If you are ready to get more, and to start writing more serious programs
-  with CImg, you are invited to go to the \ref cimg_tutorial section.
-
-**/
-/*@}*/
-
-//--------------------------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_environment Setting Environment Variables */
-/*@{
-  \page foo1
-  
-  The CImg library is a multiplatform library, working on a wide variety of systems.
-  This implies the existence of some \e environment \e variables that must be correctly defined
-  depending on your current system.
-  Most of the time, the CImg Library defines these variables automatically
-  (for popular systems). Anyway, if your system is not recognized, you will have to set the environment
-  variables by hand. Here is a quick explanations of environment variables.\n
-  
-  Setting the environment variables is done with the <tt>#define</tt> keyword.
-  This setting must be done <i>before including the file CImg.h</i> in your source code.
-  For instance,
-  defining the environment variable \c cimg_display_type would be done like this :
-  \code
-  #define cimg_display_type 0
-  #include "CImg.h"
-  ...
-  \endcode
-
-  Here are the different environment variables used by the CImg Library :
-  
-  - \b \c cimg_OS : This variable defines the type of your Operating System. It can be set to \b 0 (\e Solaris),
-  \b 1 (\e Linux),
-  \b 2 (\e Windows), \b 3 (\e Mac \ OS X), \b 4 (\e FreeBSD) or \b -1 (\e Other \e configuration).
-  It should be actually auto-detected by the CImg library. If this is not the case (<tt>cimg_OS=-1</tt>), you
-  will probably have to tune the environment variables described below.
-
-  - \b \c cimg_display_type : This variable defines the type of graphical library used to
-  display images in windows. It can be set to 0 (no display library available), \b 1 (X11-based display) or
-  \b 2 (Windows-GDI display).
-  If you are running on a system without X11 or Windows-GDI ability, please set this variable to \c 0.
-  This will disable the display support, since the CImg Library doesn't contain the necessary code to display
-  images on systems other than X11 or Windows GDI.
-
-  - \b \c cimg_color_terminal : This variable tells the library if the system terminal has VT100 color capabilities.
-  It can be \e defined or \e not \e defined. Define this variable to get colored output on your terminal, 
-  when using the CImg Library.
-  
-  - \b \c cimg_debug : This variable defines the level of run-time debug messages that will be displayed by
-  the CImg Library. It can be set to 0 (no debug messages), 1 (normal debug messages, which is
-  the default value), or 2 (high debug messages). Note that setting this value to 2 may slow down your
-  program since more debug tests are made by the library (particularly to check if pixel access is made outside
-  image boundaries). See also \ref CImgException to better understand how debug messages are working.
-  
-  - \b \c cimg_lapack : This variable tells the library to use the LAPACK library.
-  It can be \e defined or \e not \e defined (default). Define this variable if you want to use CImg-specific functions
-  based on the LAPACK library. You will have to link your code with the LAPACK library to be able to run
-  your program.
-
-  - \b \c cimg_convert_path : This variables tells the library where the ImageMagick's \e convert tool is located.
-  Setting this variable should not be necessary if ImageMagick is installed on a standart directory, or
-  if \e convert is in your system PATH variable. This macro should be defined only if the ImageMagick's 
-  \e convert tool is not found automatically, when trying to read compressed image format (GIF,PNG,...). 
-  See also cimg_library::CImg::load_convert() and cimg_library::CImg::save_convert() for more informations.
-
-  - \b \c cimg_temporary_path : This variable tells the library where it can find a directory to store
-  temporary files. Setting this variable should not be necessary if you are running on a standart system.
-  This macro should be defined only when troubles are encountered when trying to read
-  compressed image format (GIF,PNG,...).
-  See also cimg_library::CImg::load_convert() and cimg_library::CImg::save_convert() for more informations.
-
-  - \b \c cimg_plugin : This variable tells the library to use a plugin file to add features to the CImg<T> class.
-  Define it with the path of your plugin file, if you want to add member functions to the CImg<T> class,
-  without having to modify directly the \c "CImg.h" file. An include of the plugin file is performed in the CImg<T>
-  class. If \c cimg_plugin if not specified (default), no include is done.
-  
-  - \b \c cimgl_plugin : Same as \c cimg_plugin, but to add features to the CImgl<T> class.
-  
-  - \b \c cimgdisplay_plugin : Same as \c cimg_plugin, but to add features to the CImgDisplay<T> class.
-
-  - \b \c cimgstats_plugin : Same as \c cimg_plugin, but to add features to the CImgStats<T> class.
-
-  All these compilation variables can be checked, using the function cimg_library::cimg::info(), which
-  displays a list of the different configuration variables and their values on the standart error output.
-**/
-/*@}*/
-
-//--------------------------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_tutorial Tutorial : Getting Started. */
-/*@{
-  \page foo3
-  
-  Let's start to write our first program to get the idea. This will demonstrate how to load and create images, as well as handle image 
-  display and mouse events.
-  Assume we want to load a color image <tt>lena.jpg</tt>, smooth it, display it in a windows, and enter an event loop so that clicking a
-  point in the image with the mouse will draw the intensity profiles of (R,G,B) of the corresponding image line (in another window).
-  Yes, that sounds quite complex for a first code, but don't worry, it will be very simple using the CImg library ! Well, just look
-  at the code below, it does the task :
-
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-
-  int main() {
-    CImg<unsigned char> image("lena.jpg"), visu(500,400,1,3,0);
-    const unsigned char red[3]={255,0,0}, green[3]={0,255,0}, blue[3]={0,0,255};
-    image.blur(2.5);
-    CImgDisplay main_disp(image,"Click a point"), draw_disp(visu,"Intensity profile");
-    while (!main_disp.closed && !draw_disp.closed) {
-      main_disp.wait();
-      if (main_disp.button && main_disp.mousey>=0) {
-        const int y = main_disp.mousey;
-	visu.fill(0).draw_graph(image.get_crop(0,y,0,0,image.dimx()-1,y,0,0),red,0,256,0);
-	visu.draw_graph(image.get_crop(0,y,0,1,image.dimx()-1,y,0,1),green,0,256,0);
-	visu.draw_graph(image.get_crop(0,y,0,2,image.dimx()-1,y,0,2),blue,0,256,0).display(draw_disp);
-	}
-      }
-    return 0;
-  }
-  \endcode
-  
-  Here is a screenshot of the resulting program :
-
-  <img SRC="../img/tutorial.jpg">
-
-  And here is the detailled explanation of the source, line by line :
-
-  \code #include "CImg.h" \endcode
-  Include the main and only header file of the CImg library.
-  \code using namespace cimg_library; \endcode
-  Use the library namespace to ease the declarations afterward.
-  \code int main() { \endcode
-  Definition of the main function.
-  \code CImg<unsigned char> image("lena.jpg"), visu(500,400,1,3,0); \endcode
-  Creation of two instances of images of \c unsigned \c char pixels.
-  The first image \c image is initialized by reading an image file from the disk. 
-  Here, <tt>lena.jpg</tt> must be in the same directory than the current program.
-  Note that you must also have installed the \e ImageMagick package in order to be able to read JPG images.
-  The second image \c visu is initialized as a black color image with dimension <tt>dx=500</tt>, <tt>dy=400</tt>, 
-  <tt>dz=1</tt> (here, it is a 2D image, not a 3D one), and <tt>dv=3</tt> (each pixel has 3 'vector' channels R,G,B).
-  The last argument in the constructor defines the default value of the pixel values
-  (here \c 0, which means that \c visu will be initially black).
-  \code const unsigned char red[3]={255,0,0}, green[3]={0,255,0}, blue[3]={0,0,255}; \endcode
-  Definition of three different colors as array of unsigned char. This will be used to draw plots with different colors.
-  \code image.blur(2.5); \endcode
-  Blur the image, with a gaussian blur and a variance of 2.5. Note that most of the CImg functions have two versions :
-  one that acts in-place (which is the case of blur), and one that returns the result as a new image (the name of the function 
-  begins then with <tt>get_</tt>&nbsp;). In this case, one could have also written <tt>image = image.get_blur(2.5);</tt>
-  (more expensive, since it needs an additional copy operation).
-  \code CImgDisplay main_disp(image,"Click a point"), draw_disp(visu,"Intensity profile"); \endcode
-  Creation of two display windows, one for the input image image, and one for the image visu which will be display intensity profiles.
-  By default, CImg displays handles events (mouse,keyboard,..). On Windows, there is a way to create fullscreen displays.
-  \code while (!main_disp.closed && !draw_disp.closed) { \endcode
-  Enter the event loop, the code will exit when one of the two display windows is closed.
-  \code main_disp.wait(); \endcode
-  Wait for an event (mouse, keyboard,..) in the display window \c main_disp.
-  \code if (main_disp.button && main_disp.mousey>=0) { \endcode
-  Test if the mouse button has been clicked on the image area.
-  One may distinguish between the 3 different mouse buttons,
-  but in this case it is not necessary
-  \code const int y = main_disp.mousey; \endcode
-  Get the image line y-coordinate that has been clicked.
-  \code visu.fill(0).draw_graph(image.get_crop(0,y,0,0,image.dimx()-1,y,0,0),red,0,256,0); \endcode
-  This line illustrates the pipeline property of most of the CImg class functions. The first function <tt>fill(0)</tt> simply sets
-  all pixel values with 0 (i.e. clear the image \c visu). The interesting thing is that it returns a reference to
-  \c visu and then, can be pipelined with the function \c draw_graph() which draws a plot in the image \c visu.
-  The plot data are given by another image (the first argument of \c draw_graph()). In this case, the given image is 
-  the red-component of the line y of the original image, retrieved by the function \c get_crop() which returns a
-  sub-image of the image \c image. Remember that images coordinates are 4D (x,y,z,v) and for color images,
-  the R,G,B channels are respectively given by <tt>v=0, v=1</tt> and <tt>v=2</tt>.
-  \code visu.draw_graph(image.get_crop(0,y,0,1,image.dimx()-1,y,0,1),green,0,256,0); \endcode
-  Plot the intensity profile for the green channel of the clicked line.
-  \code visu.draw_graph(image.get_crop(0,y,0,2,image.dimx()-1,y,0,2),blue,0,256,0).display(draw_disp); \endcode
-  Same thing for the blue channel. Note how the function (which return a reference to \c visu) is pipelined with the function
-  \c display() that just paints the image visu in the corresponding display window.
-  \code ...till the end \endcode
-  I don't think you need more explanations !
-
-  As you have noticed, the CImg library allows to write very small and intuitive code. Note also that this source will perfectly 
-  work on Unix and Windows systems. Take also a look to the examples provided in the CImg package (
-  directory \c examples/ ). It will show you how CImg-based code can be surprisingly small. 
-  Moreover, there is surely one example close to what you want to do.
-  A good start will be to look at the file <tt>CImg_test.cpp</tt> which contains small and various examples of what you can do
-  with the CImg Library. All CImg classes are used in this source, and the code can be easily modified to see what happens. 
-
-**/
-/*@}*/
-
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_drawing Using Drawing Functions. */
-/*@{
-  \page foo5
-
-  \section s5 Using Drawing Functions.
-
-  This section tells more about drawing features in CImg images.
-  Drawing functions list can be found in <a href="structCImg.html">the CImg functions list</a>
-  (section \b Drawing Functions),
-  and are all defined on a common basis. Here are the important points to understand before using
-  drawing functions :
-  
-  - Drawing is performed on the instance image. Drawing functions parameters
-  are defined as \e const variables and return a reference to the current instance <tt>(*this)</tt>,
-  so that drawing functions can be pipelined (see examples below).
-  Drawing is usually done in 2D color images but can be performed in 3D images with any vector-valued dimension,
-  and with any possible pixel type.
-
-  - A color parameter is always needed to draw features in an image. The color must be defined as a C-style array
-  whose dimension is at least
-
-*/
-/*@}*/
-
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_loops Using Image Loops. */
-/*@{
-  \page foo_lo
-  The CImg Library provides different macros that define useful iterative loops over an image.
-  Basically, it can be used to replace one or several <tt>for(..)</tt> instructions, but it also proposes
-  interesting extensions to classical loops.
-  Below is a list of all existing loop macros, classified in four different categories :
-  - \ref lo1
-  - \ref lo4
-  - \ref lo5
-  - \ref lo6
-
-  \section lo1 Loops over the pixel buffer
-
-  Loops over the pixel buffer are really basic loops that iterate a pointer on the pixel data buffer
-  of a \c cimg_library::CImg image. Two macros are defined for this purpose :
-  
-  - \b cimg_map(img,ptr,T) :
-  This macro loops over the pixel data buffer of the image \c img, using a pointer <tt>T* ptr</tt>,
-  starting from the end of the buffer (last pixel) till the beginning of the buffer (first pixel).
-      - \c img must be a (non empty) \c cimg_library::CImg image of pixels \c T.
-      - \c ptr is a pointer of type \c T*.
-  This kind of loop should not appear a lot in your own source code, since this is a low-level loop
-  and many functions of the CImg class may be used instead. Here is an example of use :
-  \code
-  CImg<float> img(320,200);
-  cimg_map(img,ptr,float) { *ptr=0; }      // Equivalent to 'img.fill(0);'
-  \endcode
-
-  - \b cimg_mapoff(img,off) :
-  This macro loops over the pixel data buffer of the image \c img, using an offset \c ,
-  starting from the beginning of the buffer (first pixel, \c off=0)
-  till the end of the buffer (last pixel value, <tt>off = img.size()-1</tt>).
-      - \c img must be a (non empty) cimg_library::CImg<T> image of pixels \c T.
-      - \c off is an inner-loop variable, only defined inside the scope of the loop.
-
-  Here is an example of use :
-  \code
-  CImg<float> img(320,200);
-  cimg_mapoff(img,off) { img[off]=0; }  // Equivalent to 'img.fill(0);'
-  \endcode
-
-  \section lo4 Loops over image dimensions
-
-  The following loops are probably the most used loops in image processing programs.
-  They allow to loop over the image along one or several dimensions, along a raster scan course.
-  Here is the list of such loop macros for a single dimension :
-  - \b cimg_mapX(img,x) : equivalent to : <tt>for (int x=0; x<img.dimx(); x++)</tt>.
-  - \b cimg_mapY(img,y) : equivalent to : <tt>for (int y=0; y<img.dimy(); y++)</tt>.
-  - \b cimg_mapZ(img,z) : equivalent to : <tt>for (int z=0; z<img.dimz(); z++)</tt>.
-  - \b cimg_mapV(img,v) : equivalent to : <tt>for (int v=0; v<img.dimv(); v++)</tt>.
-
-  Combinations of these macros are also defined as other loop macros, allowing to loop directly over 2D, 3D or 4D images :
-  - \b cimg_mapXY(img,x,y) : equivalent to : \c cimg_mapY(img,y) \c cimg_mapX(img,x).
-  - \b cimg_mapXZ(img,x,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapX(img,x).
-  - \b cimg_mapYZ(img,y,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapY(img,y).
-  - \b cimg_mapXV(img,x,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapX(img,x).
-  - \b cimg_mapYV(img,y,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapY(img,y).
-  - \b cimg_mapZV(img,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapZ(img,z).
-  - \b cimg_mapXYZ(img,x,y,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapXY(img,x,y).
-  - \b cimg_mapXYV(img,x,y,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXY(img,x,y).
-  - \b cimg_mapXZV(img,x,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXZ(img,x,z).
-  - \b cimg_mapYZV(img,y,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapYZ(img,y,z).
-  - \b cimg_mapXYZV(img,x,y,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXYZ(img,x,y,z).
-
-  - For all these loops, \c x,\c y,\c z and \c v are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  - \c img must be a (non empty) cimg_library::CImg image.
-
-  Here is an example of use that creates an image with a smooth color gradient :
-  \code
-  CImg<unsigned char> img(256,256,1,3);       // Define a 256x256 color image
-  cimg_mapXYV(img,x,y,v) { img(x,y,v) = (x+y)*(v+1)/6; }
-  img.display("Color gradient");
-  \endcode
-
-  \section lo5 Loops over interior regions and borders.
-
-  Similar macros are also defined to loop only on the border of an image, or inside the image (excluding the border).
-  The border may be several pixel wide :
-
-  - \b cimg_imapX(img,x,n) : Loop along the x-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapY(img,y,n) : Loop along the y-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapZ(img,z,n) : Loop along the z-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapV(img,v,n) : Loop along the v-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapXY(img,x,y,n) : Loop along the (x,y)-axes, excepted for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapXYZ(img,x,y,z,n) : Loop along the (x,y,z)-axes, excepted for pixels inside a border of \p n pixels wide.
-
-  And also :
-
-  - \b cimg_bmapX(img,x,n) : Loop along the x-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapY(img,y,n) : Loop along the y-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapZ(img,z,n) : Loop along the z-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapV(img,v,n) : Loop along the z-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapXY(img,x,y,n) : Loop along the (x,y)-axes, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapXYZ(img,x,y,z,n) : Loop along the (x,y,z)-axes, only for pixels inside a border of \p n pixels wide.
-
-  - For all these loops, \c x,\c y,\c z and \c v are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  - \c img must be a (non empty) cimg_library::CImg image.
-  - The constant \c n stands for the size of the border.
-
-  Here is an example of use, to create a 2d grayscale image with two different intensity gradients :
-  \code
-  CImg<> img(256,256);
-  cimg_imapXY(img,x,y,50) img(x,y) = x+y;
-  cimg_bmapXY(img,x,y,50) img(x,y) = x-y;
-  img.display();
-  \endcode
-
-  \section lo6 Loops using neighborhoods.
-  
-  Inside an image loop, it is often useful to get values of neighborhood pixels of the
-  current pixel at the loop location.
-  The CImg Library provides a very smart and fast mechanism for this purpose, with the definition
-  of several loop macros that remember the neighborhood values of the pixels.
-  The use of these macros can highly optimize your code, and also simplify your program.
-
-  \subsection lo7 Neighborhood-based loops for 2D images
-
-  For 2D images, the neighborhood-based loop macros are : 
-
-  - \b cimg_map2x2(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 2x2 neighborhood.
-  - \b cimg_map3x3(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 3x3 neighborhood.
-  - \b cimg_map4x4(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 4x4 neighborhood.
-  - \b cimg_map5x5(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 5x5 neighborhood.
-
-  For all these loops, \c x and \c y are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  \c img is a non empty CImg<T> image. \c z and \c v are constants that define on which image slice and
-  vector channel the loop must apply (usually both 0 for grayscale 2D images).
-  Finally, \c I is the 2x2, 3x3, 4x4 or 5x5 neighborhood that will be updated with the correct pixel values
-  during the loop (see \ref lo9).
-
-  \subsection lo8 Neighborhood-based loops for 3D images
-
-  For 3D images, the neighborhood-based loop macros are : 
-
-  - \b cimg_map2x2x2(img,x,y,z,v,I) : Loop along the (x,y,z)-axes using a centered 2x2x2 neighborhood.
-  - \b cimg_map3x3x3(img,x,y,z,v,I) : Loop along the (x,y,z)-axes using a centered 3x3x3 neighborhood.
-
-  For all these loops, \c x, \c y and \c z are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  \c img is a non empty CImg<T> image. \c v is a constant that defines on which image channel
-  the loop must apply (usually 0 for grayscale 3D images).
-  Finally, \c I is the 2x2x2 or 3x3x3 neighborhood that will be updated with the correct pixel values
-  during the loop (see \ref lo9).
-
-  \subsection lo9 Defining neighborhoods
-
-  The CImg library defines a neighborhood as a set of named \e variables or \e references, declared
-  using specific CImg macros :
-
-  - \b CImg_2x2(I,type) : Define a 2x2 neighborhood named \c I, of type \c type.
-  - \b CImg_3x3(I,type) : Define a 3x3 neighborhood named \c I, of type \c type.
-  - \b CImg_4x4(I,type) : Define a 4x4 neighborhood named \c I, of type \c type.
-  - \b CImg_5x5(I,type) : Define a 5x5 neighborhood named \c I, of type \c type.
-  - \b CImg_2x2x2(I,type) : Define a 2x2x2 neighborhood named \c I, of type \c type.
-  - \b CImg_3x3x3(I,type) : Define a 3x3x3 neighborhood named \c I, of type \c type.
-
-  Actually, \c I is a \e generic \e name for the neighborhood. In fact, these macros declare
-  a \e set of new variables.
-  For instance, defining a 3x3 neighborhood \c CImg_3x3(I,float) declares 9 different float variables
-  \c Ipp,\c Icp,\c Inp,\c Ipc,\c Icc,\c Inc,\c Ipn,\c Icn,\c Inn which correspond to each pixel value of
-  a 3x3 neighborhood.
-  Variable indices are \c p,\c c or \c n, and stand respectively for \e 'previous', \e 'current' and \e 'next'.
-  First indice denotes the \c x-axis, second indice denotes the \c y-axis.
-  Then, the names of the variables are directly related to the position of the corresponding pixels
-  in the neighborhood. For 3D neighborhoods, a third indice denotes the \c z-axis.
-  Then, inside a neighborhood loop, you will have the following equivalence :
-  - <tt>Ipp = img(x-1,y-1)</tt>
-  - <tt>Icn = img(x,y+1)</tt>
-  - <tt>Inp = img(x+1,y-1)</tt>
-  - <tt>Inpc = img(x+1,y-1,z)</tt>
-  - <tt>Ippn = img(x-1,y-1,z+1)</tt>
-  - and so on...
-
-  For bigger neighborhoods, such as 4x4 or 5x5 neighborhoods, two additionnal indices are introduced :
-  \c a (stands for \e 'after') and \c b (stands for \e 'before'), so that :
-  - <tt>Ibb = img(x-2,y-2)</tt>
-  - <tt>Ina = img(x+1,y+2)</tt>
-  - and so on...
-
-  The value of a neighborhood pixel outside the image range (image border problem) is automatically set to the same
-  values than the nearest valid pixel in the image (this is also called the \e Neumann \e border \e condition).
-
-  \subsection lo10 Neighborhood as a reference
-  It is also possible to define neighborhood variables as references to classical C-arrays or CImg<T> images, instead of
-  allocating new variables. This is done by adding \c _ref to the macro names used for the neighborhood definition :
-
-  - \b CImg_2x2_ref(I,type,tab) : Define a 2x2 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_3x3_ref(I,type,tab) : Define a 3x3 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_4x4_ref(I,type,tab) : Define a 4x4 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_5x5_ref(I,type,tab) : Define a 5x5 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_2x2x2_ref(I,type,tab) : Define a 2x2x2 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_3x3x3_ref(I,type,tab) : Define a 3x3x3 neighborhood named \c I, of type \c type, as a reference to \c tab.
-
-  \c tab can be a one-dimensionnal C-style array, or a non empty \c CImg<T> image. Both objects must have
-  same sizes as the considered neighborhoods.
-
-  \subsection lo11 Example codes
-  More than a long discussion, the above example will demonstrate how to compute the gradient norm of a 3D volume
-  using the \c cimg_map3x3x3() loop macro :
-
-  \code
-  CImg<float> volume("IRM.hdr");        // Load an IRM volume from an Analyze7.5 file
-  CImg_3x3x3(I,float);                  // Define a 3x3x3 neighborhood
-  CImg<float> gradnorm(volume,false);   // Create an image with same size as 'volume'
-  cimg_map3x3x3(volume,x,y,z,0,I) {     // Loop over the volume, using the neighborhood I
-    const float ix = 0.5f*(Incc-Ipcc);  // Compute the derivative along the x-axis.
-    const float iy = 0.5f*(Icnc-Icpc);  // Compute the derivative along the y-axis.
-    const float iz = 0.5f*(Iccn-Iccp);  // Compute the derivative along the z-axis.
-    gradnorm(x,y,z) = std::sqrt(ix*ix+iy*iy+iz*iz);  // Set the gradient norm in the destination image
-  }
-  gradnorm.display("Gradient norm");
-  \endcode
-  
-  And the following example shows how to deal with neighborhood references to blur a color image by averaging
-  pixel values on a 5x5 neighborhood.
-
-  \code
-  CImg<unsigned char> src("image_color.jpg"), dest(src,false), neighbor(5,5);  // Image definitions.
-  typedef unsigned char uchar;             // Avoid space in the second parameter of the macro CImg_5x5 below.
-  CImg_5x5_ref(N,uchar,neighbor);          // Define a 5x5 neighborhood as a reference to the 5x5 image neighbor.
-  cimg_mapV(src,k)                         // Standart loop on color channels
-     cimg_map5x5(src,x,y,0,k,N)            // 5x5 neighborhood loop.
-       dest(x,y,k) = neighbor.sum()/(5*5); // Averaging pixels to filter the color image.
-  CImgl<unsigned char> visu(src,dest);
-  visu.display("Original + Filtered");     // Display both original and filtered image.
-  \endcode
-  
-  Note that in this example, we didn't use directly the variables Nbb,Nbp,..,Ncc,... since
-  there are only references to the neighborhood image \c neighbor. We rather used a member function of \c neighbor.
-
-  As you can see, explaining the use of the CImg neighborhood macros is actually more difficult than using them !
-*/
-/*@}*/
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_displays Using Display Windows. */
-/*@{
-  \page foo_di
-
-  When opening a display window, you can choose the way the pixel values will be normalized
-  before being displayed on the screen. Screen displays only support color values between [0,255],
-  and some
-  
-  When displaying an image into the display window using CImgDisplay::display(), values of
-  the image pixels can be eventually linearly normalized between [0,255] for visualization purposes.
-  This may be useful for instance when displaying \p CImg<double> images with pixel values
-  between [0,1].
-  The normalization behavior depends on the value of \p normalize which can be either \p 0,\p 1 or \p 2 :
-  - \p 0 : No pixel normalization is performed when displaying an image. This is the fastest
-  process, but you must be sure your displayed image have pixel values inside the range [0,255].
-  - \p 1 : Pixel value normalization is done for each new image display. Image pixels are
-  not modified themselves, only displayed pixels are normalized.
-  - \p 2 : Pixel value normalization is done for the first image display, then the
-  normalization parameters are kept and used for all the next image displays.
-  
-*/
-/*@}*/
-
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_options Retrieving Command Line Arguments. */
-/*@{
-  \page foo_so
-
-   The CImg library offers facilities to retrieve command line arguments in a console-based
-   program, as it is a commonly needed operation.
-   Two macros \c cimg_usage() and \c cimg_option() are defined for this purpose.
-   Using these macros allows to easily retrieve options values from the command line.
-   Moreover, invoking the corresponding executable with the option \c -h or \c --help will
-   automatically display the program usage, followed by the list of requested options.
-
-   \section so1 The cimg_usage() macro
-
-   The macro \c cimg_usage(usage) may be used to describe the program goal and usage.
-   It is generally inserted one time after the <tt>int main(int argc,char **argv)</tt> definition.
-  
-   \param usage : A string describing the program goal and usage.
-   \pre The function where \c cimg_usage() is used must have correctly defined \c argc and \c argv variables.
-
-   \section so2 The cimg_option() macro
-
-   The macro \c cimg_option(name,default,usage) may be used to retrieve an option value from the command line.
-
-   \param name    : The name of the option to be retrieved from the command line.
-   \param default : The default value returned by the macro if no options \p name has been specified when running the program.
-   \param usage   : A brief explanation of the option. If \c usage==NULL, the option won't appear on the option list
-                    when invoking the executable with options \c -h or \c --help (hidden option).
-                  
-   \return \c cimg_option() returns an object that has the \e same \e type than the default value \c default.
-   The return value is equal to the one specified on the command line. If no such option have been specified,
-   the return value is equal to the default value \c default.
-   Warning, this can be confusing in some situations (look at the end of the next section).
-   \pre The function where \c cimg_option() is used must have correctly defined \c argc and \c argv variables.
-
-   \section so3 Example of use
-
-   The code below uses the macros \c cimg_usage() and \c cimg_option().
-   It loads an image, smoothes it an quantifies it with a specified number of values.
-   \code
-   #include "CImg.h"
-   using namespace cimg_library;
-   int main(int argc,char **argv) {
-     cimg_usage("Retrieve command line arguments");
-     const char* filename = cimg_option("-i","image.gif","Input image file");
-     const char* output   = cimg_option("-o",(const char*)NULL,"Output image file");
-     const double sigma   = cimg_option("-s",1.0,"Variance of the gaussian smoothing");
-     const  int nblevels  = cimg_option("-n",16,"Number of quantification levels");
-     const bool hidden    = cimg_option("-hidden",false,NULL);      // This is a hidden option
-
-     CImg<unsigned char> img(filename);
-     img.blur(sigma).quantify(nblevels);
-     if (output) img.save(output); else img.display("Output image");
-     if (hidden) std::fprintf(stderr,"You found me !\n");
-     return 0;
-   }
-   \endcode
-
-   Invoking the corresponding executable with <tt>test -h -hidden -n 20 -i foo.jpg</tt> will display :
-   \verbatim
-$ ./test -h -hidden -n 20 -i foo.jpg
-
- test : Retrieve command line arguments (Oct 16 2004, 12:34:26)
-
-    -i       = foo.jpg      : Input image file
-    -o       = NULL         : Output image file
-    -s       = 1            : Variance of the gaussian smoothing
-    -n       = 20           : Number of quantification levels
-
-   You found me !
-\endverbatim
-
-   \warning As the type of object returned by the macro \c cimg_option(option,default,usage) 
-   is defined by the type of \c default, undesired casts may appear when writting code such as :
-   \code
-   const double sigma = cimg_option("-val",0,"A floating point value");
-   \endcode
-   In this case, \c sigma will always be equal to an integer (since the default value \c 0 is an integer).
-   When passing a float value on the command line, a \e float \e to \e integer cast is then done,
-   truncating the given parameter to an integer value (this is surely not a desired behavior).
-   You must specify <tt>0.0</tt> as the default value in this case.
-
-   \section so4 How to learn more about command line options ?
-   You should take a look at the examples <tt>examples/inrcast.cpp</tt> provided in the CImg Library package.
-   This is a command line based image converter which intensively uses the \c cimg_option() and \c cimg_usage()
-   macros to retrieve command line parameters.
-*/
-/*@}*/
-//----------------------------------------------------------------------------------------------------
-#endif

Modified: greycstoration_gimp/INSTALL
===================================================================
--- greycstoration_gimp/INSTALL	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/INSTALL	2005-11-21 22:57:19 UTC (rev 258)
@@ -11,7 +11,10 @@
 Instruction to compile
 ======================
 
-make && make install
+./autogen.sh
+./configure
+make
+make install
 
 That's all :-)
 

Deleted: greycstoration_gimp/Makefile
===================================================================
--- greycstoration_gimp/Makefile	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/Makefile	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,36 +0,0 @@
-# Common arguments
-CXXFLAGS=-Wall -O3 -ffast-math
-SRC=image.cpp greycstoration.cpp dialog.cpp main.cpp
-
-# C++ compiler
-CXX=g++
-
-# pkg-config modules needed
-MODULES=gimp-2.0 gimpui-2.0 gtk+-2.0
-CXXFLAGS+=$(shell pkg-config $(MODULES) --cflags)
-LIBS=$(shell pkg-config $(MODULES) --libs)
-
-# Don't use CImg interface (keyboard/mouse interaction)
-CXXFLAGS+=-Dcimg_OS=-1 -Dcimg_display_type=0 
-
-# And others variables ...
-PROG=greycstoration
-OBJECTS=$(patsubst %.cpp,%.o,$(SRC))
-GIMPTOOL=gimptool-2.0
-
-$(PROG): $(OBJECTS)
-	@echo "Linking ..."
-	@$(CXX) -o $(PROG) $(OBJECTS) $(CXXFLAGS) $(LIBS)
-	
-%.o: %.cpp
-	@echo "Compile $@"
-	@$(CXX) -c -o $@ $< $(CXXFLAGS)
-	
-install: $(PROG)
-	$(GIMPTOOL) --install-bin $(PROG)
-	
-uninstall:
-	$(GIMPTOOL) --uninstall-bin $(PROG)
-
-clean:
-	rm -f $(PROG) $(OBJECTS)

Added: greycstoration_gimp/Makefile.am
===================================================================
--- greycstoration_gimp/Makefile.am	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/Makefile.am	2005-11-21 22:57:19 UTC (rev 258)
@@ -0,0 +1,14 @@
+AUTOMAKE_OPTIONS = foreign
+
+SUBDIRS = po src
+
+EXTRA_DIST = \
+	autogen.sh \
+	intltool-extract.in \
+	intltool-merge.in \
+	intltool-update.in
+
+DISTCLEANFILES = \
+	intltool-extract \
+	intltool-merge \
+	intltool-update

Added: greycstoration_gimp/autogen.sh
===================================================================
--- greycstoration_gimp/autogen.sh	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/autogen.sh	2005-11-21 22:57:19 UTC (rev 258)
@@ -0,0 +1,186 @@
+#!/bin/sh
+
+# This script does all the magic calls to automake/autoconf and
+# friends that are needed to configure a cvs checkout.  You need a
+# couple of extra tools to run this script successfully.
+#
+# If you are compiling from a released tarball you don't need these
+# tools and you shouldn't use this script.  Just call ./configure
+# directly.
+
+PROJECT="GIMP GREYCstoration plugin"
+TEST_TYPE=-f
+FILE=src/main.cpp
+
+AUTOCONF_REQUIRED_VERSION=2.54
+AUTOMAKE_REQUIRED_VERSION=1.6
+GLIB_REQUIRED_VERSION=2.0.0
+INTLTOOL_REQUIRED_VERSION=0.17
+
+srcdir=`dirname $0`
+test -z "$srcdir" && srcdir=.
+ORIGDIR=`pwd`
+cd $srcdir
+
+check_version ()
+{
+    if expr $1 \>= $2 > /dev/null; then
+	echo "yes (version $1)"
+    else
+	echo "Too old (found version $1)!"
+	DIE=1
+    fi
+}
+
+echo
+echo "I am testing that you have the required versions of autoconf," 
+echo "automake, glib-gettextize and intltoolize..."
+echo
+
+DIE=0
+
+echo -n "checking for autoconf >= $AUTOCONF_REQUIRED_VERSION ... "
+if (autoconf --version) < /dev/null > /dev/null 2>&1; then
+    VER=`autoconf --version \
+         | grep -iw autoconf | sed "s/.* \([0-9.]*\)[-a-z0-9]*$/\1/"`
+    check_version $VER $AUTOCONF_REQUIRED_VERSION
+else
+    echo
+    echo "  You must have autoconf installed to compile $PROJECT."
+    echo "  Download the appropriate package for your distribution,"
+    echo "  or get the source tarball at ftp://ftp.gnu.org/pub/gnu/"
+    DIE=1;
+fi
+
+echo -n "checking for automake >= $AUTOMAKE_REQUIRED_VERSION ... "
+if (automake-1.7 --version) < /dev/null > /dev/null 2>&1; then
+   AUTOMAKE=automake-1.7
+   ACLOCAL=aclocal-1.7
+elif (automake-1.8 --version) < /dev/null > /dev/null 2>&1; then
+   AUTOMAKE=automake-1.8
+   ACLOCAL=aclocal-1.8
+elif (automake-1.9 --version) < /dev/null > /dev/null 2>&1; then
+   AUTOMAKE=automake-1.9
+   ACLOCAL=aclocal-1.9
+elif (automake-1.6 --version) < /dev/null > /dev/null 2>&1; then
+   AUTOMAKE=automake-1.6
+   ACLOCAL=aclocal-1.6
+else
+    echo
+    echo "  You must have automake 1.6 or newer installed to compile $PROJECT."
+    echo "  Download the appropriate package for your distribution,"
+    echo "  or get the source tarball at ftp://ftp.gnu.org/pub/gnu/automake/"
+    DIE=1
+fi
+
+if test x$AUTOMAKE != x; then
+    VER=`$AUTOMAKE --version \
+         | grep automake | sed "s/.* \([0-9.]*\)[-a-z0-9]*$/\1/"`
+    check_version $VER $AUTOMAKE_REQUIRED_VERSION
+fi
+
+echo -n "checking for glib-gettextize >= $GLIB_REQUIRED_VERSION ... "
+if (glib-gettextize --version) < /dev/null > /dev/null 2>&1; then
+    VER=`glib-gettextize --version \
+         | grep glib-gettextize | sed "s/.* \([0-9.]*\)/\1/"`
+    check_version $VER $GLIB_REQUIRED_VERSION
+else
+    echo
+    echo "  You must have glib-gettextize installed to compile $PROJECT."
+    echo "  glib-gettextize is part of glib-2.0, so you should already"
+    echo "  have it. Make sure it is in your PATH."
+    DIE=1
+fi
+
+echo -n "checking for intltool >= $INTLTOOL_REQUIRED_VERSION ... "
+if (intltoolize --version) < /dev/null > /dev/null 2>&1; then
+    VER=`intltoolize --version \
+         | grep intltoolize | sed "s/.* \([0-9.]*\)/\1/"`
+    check_version $VER $INTLTOOL_REQUIRED_VERSION
+else
+    echo
+    echo "  You must have intltool installed to compile $PROJECT."
+    echo "  Get the latest version from"
+    echo "  ftp://ftp.gnome.org/pub/GNOME/sources/intltool/"
+    DIE=1
+fi
+
+if test "$DIE" -eq 1; then
+    echo
+    echo "Please install/upgrade the missing tools and call me again."
+    echo	
+    exit 1
+fi
+
+
+test $TEST_TYPE $FILE || {
+    echo
+    echo "You must run this script in the top-level $PROJECT directory."
+    echo
+    exit 1
+}
+
+
+echo
+echo "I am going to run ./configure with the following arguments:"
+echo
+echo "  --enable-maintainer-mode $AUTOGEN_CONFIGURE_ARGS $@"
+echo
+
+if test -z "$*"; then
+    echo "If you wish to pass additional arguments, please specify them "
+    echo "on the $0 command line or set the AUTOGEN_CONFIGURE_ARGS "
+    echo "environment variable."
+    echo
+fi
+
+if test -z "$ACLOCAL_FLAGS"; then
+
+    acdir=`$ACLOCAL --print-ac-dir`
+    m4list="glib-gettext.m4 intltool.m4"
+
+    for file in $m4list
+    do
+	if [ ! -f "$acdir/$file" ]; then
+	    echo
+	    echo "WARNING: aclocal's directory is $acdir, but..."
+            echo "         no file $acdir/$file"
+            echo "         You may see fatal macro warnings below."
+            echo "         If these files are installed in /some/dir, set the ACLOCAL_FLAGS "
+            echo "         environment variable to \"-I /some/dir\", or install"
+            echo "         $acdir/$file."
+            echo
+        fi
+    done
+fi
+
+rm -rf autom4te.cache
+
+$ACLOCAL $ACLOCAL_FLAGS
+RC=$?
+if test $RC -ne 0; then
+   echo "$ACLOCAL gave errors. Please fix the error conditions and try again."
+   exit 1
+fi
+
+# optionally feature autoheader
+(autoheader --version)  < /dev/null > /dev/null 2>&1 && autoheader || exit 1
+
+$AUTOMAKE --add-missing || exit 1
+autoconf || exit 1
+
+glib-gettextize --force || exit 1
+intltoolize --force --automake || exit 1
+
+cd $ORIGDIR
+
+$srcdir/configure --enable-maintainer-mode $AUTOGEN_CONFIGURE_ARGS "$@"
+RC=$?
+if test $RC -ne 0; then
+  echo
+  echo "Configure failed or did not finish!"
+  exit $RC
+fi
+
+echo
+echo "Now type 'make' to compile $PROJECT."


Property changes on: greycstoration_gimp/autogen.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: greycstoration_gimp/configure.in
===================================================================
--- greycstoration_gimp/configure.in	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/configure.in	2005-11-21 22:57:19 UTC (rev 258)
@@ -0,0 +1,85 @@
+AC_PREREQ(2.54)
+
+m4_define([plugin_name], [greycstoration])
+
+m4_define([plugin_major_version], [0])
+m4_define([plugin_minor_version], [1])
+m4_define([plugin_micro_version], [2])
+m4_define([plugin_version],
+          [plugin_major_version.plugin_minor_version.plugin_micro_version])
+
+AC_INIT([plugin_name], [plugin_version])
+
+AC_DEFINE(PLUGIN_NAME, PACKAGE_NAME, [Plug-In name])
+AC_DEFINE(PLUGIN_VERSION, PACKAGE_VERSION, [Plug-In version])
+AC_DEFINE(PLUGIN_MAJOR_VERSION, plugin_major_version, [Plug-In major version])
+AC_DEFINE(PLUGIN_MINOR_VERSION, plugin_minor_version, [Plug-In minor version])
+AC_DEFINE(PLUGIN_MICRO_VERSION, plugin_micro_version, [Plug-In micro version])
+
+AC_CONFIG_SRCDIR([src/main.cpp])
+AM_CONFIG_HEADER(config.h)
+AM_INIT_AUTOMAKE(no-define)
+ACLOCAL="$ACLOCAL $ACLOCAL_FLAGS"
+
+dnl Add --enable-maintainer-mode option
+AM_MAINTAINER_MODE
+
+dnl Check for C++ compiler, and turn on optimizations if we have gcc.
+if test "x$CXXFLAGS" = "x" ; then
+	CXXFLAGS=""
+fi
+AC_PROG_CXX
+if test "x$CXXFLAGS" = "x" && test "x$GXX" = "xyes" ; then
+	CXXFLAGS="-O3 -ffast-math"
+fi
+
+dnl Use -Wall if we have gcc.
+changequote(,)dnl
+if test "x$GXX" = "xyes"; then
+	case " $CXXFLAGS " in
+		*[\ \	]-Wall[\ \	]*) ;;
+		*) CXXFLAGS="$CXXFLAGS -Wall" ;;
+	esac
+fi
+changequote([,])dnl
+
+dnl Check for Gimp 2.x
+GIMP_REQUIRED_VERSION=2.2.0
+PKG_CHECK_MODULES(GIMP,
+	[gimp-2.0 >= $GIMP_REQUIRED_VERSION,
+	 gimpui-2.0 >= $GIMP_REQUIRED_VERSION])
+AC_SUBST(GIMP_CFLAGS)
+AC_SUBST(GIMP_LIBS)
+GIMP_LIBDIR=`$PKG_CONFIG --variable=gimplibdir gimp-2.0`
+AC_SUBST(GIMP_LIBDIR)
+
+dnl Check for GTK+ 2.x
+GTK_REQUIRED_VERSION=2.6.0
+PKG_CHECK_MODULES(GTK,
+	[gtk+-2.0 >= $GTK_REQUIRED_VERSION])
+AC_SUBST(GTK_CFLAGS)
+AC_SUBST(GTK_LIBS)
+
+dnl i18n stuff
+ALL_LINGUAS="fr"
+GETTEXT_PACKAGE=gimp20-greycstoration
+AC_SUBST(GETTEXT_PACKAGE)
+AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,
+	"$GETTEXT_PACKAGE",
+	[The gettext translation domain.])
+AC_PROG_INTLTOOL
+AM_GLIB_GNU_GETTEXT
+AC_CHECK_FUNCS(bind_textdomain_codeset)
+LOCALEDIR="${datadir}/locale"
+if test "$DATADIRNAME" = "lib"; then
+	LOCALEDIR="$libdir/locale"
+fi
+AC_SUBST(LOCALEDIR)
+
+dnl Output files
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+po/Makefile.in
+])
+AC_OUTPUT

Deleted: greycstoration_gimp/dialog.cpp
===================================================================
--- greycstoration_gimp/dialog.cpp	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/dialog.cpp	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,276 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "plugin-intl.h"
-
-#include <stdio.h>
-
-#include "dialog.h"
-//----------------------------------------------------------------------------
-#include "image.h"
-#include "greycstoration.h"
-#include <libgimp/gimp.h>
-#include <libgimp/gimpui.h>
-#include <gtk/gtk.h>
-//----------------------------------------------------------------------------
-#define SCALE_WIDTH 125
-#define SCALE_DIGITS 3
-#define BOX_SPACING 6
-//----------------------------------------------------------------------------
-
-#define TABLE_SCALE(ROW, LABEL,TYPE,VALUE,MIN,MAX,DELTA1,DELTA2,DIGITS) \
-    { GtkObject *scale = gimp_scale_entry_new ( \
-			GTK_TABLE (table), 0, ROW, \
-			LABEL, SCALE_WIDTH, 0, \
-			VALUE, MIN, MAX, DELTA1, DELTA2, DIGITS, \
-			TRUE, 0, 0, \
-			NULL, NULL); \
-	g_signal_connect (scale, "value_changed", \
-			G_CALLBACK(gimp_##TYPE##_adjustment_update), &VALUE); \
-	g_signal_connect_swapped (scale, "value_changed", \
-			G_CALLBACK(gimp_preview_invalidate), preview); }
-
-//----------------------------------------------------------------------------
-
-GREYCstoration_params::GREYCstoration_params()
-{
-	nb_iter        = 1;
-	dt             = 20.0f;
-	sigma          = 1.4f;
-	dlength        = 0.8;
-	dtheta         = 45.0;
-	onormalize     = false;
-	power1         = 0.1;
-	power2         = 0.9;
-	gauss_prec     = 3.0f;
-	linear         = true;
-	onormalize     = false;
-	preview        = true;
-}
-
-//----------------------------------------------------------------------------
-
-GtkWidget* ajoute_param(
-		GtkObject *spinbutton_adj, 
-		GtkWidget *dst_box, 
-		const char *label_string,
-		int digits=0)
-{
-	GtkWidget *main_hbox;
-	GtkWidget *param_label;
-	GtkWidget *spinbutton;
-
-	/* Bo?te horizontale */
-	main_hbox = gtk_hbox_new (FALSE, BOX_SPACING);
-	gtk_widget_show (main_hbox);
-	gtk_container_add (GTK_CONTAINER(dst_box), main_hbox);
-
-	/* Param?tre : Texte */
-	param_label = gtk_label_new_with_mnemonic(label_string);
-	gtk_widget_show (param_label);
-	gtk_box_pack_start(GTK_BOX(main_hbox), param_label, FALSE, FALSE, 6);
-	gtk_label_set_justify (GTK_LABEL(param_label), GTK_JUSTIFY_RIGHT);
-
-	/* Param?tre : SpinButton */	
-	if (0 <= digits)
-	{
-		spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT(spinbutton_adj), 1, digits);
-		gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(spinbutton), TRUE);
-	} else {
-		spinbutton = gtk_check_button_new();
-	}
-	gtk_widget_show (spinbutton);
-	gtk_box_pack_start (GTK_BOX(main_hbox), spinbutton, FALSE, FALSE, 6);
-	if (digits < 0) return spinbutton; else return NULL;
-}
-
-//----------------------------------------------------------------------------
-
-void dialog_page1 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
-{
-	GtkWidget *page_label;   
-	GtkWidget *table;
-
-	// Create the table
-	table = gtk_table_new (5, 3, FALSE);
-	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
-	gtk_table_set_row_spacings (GTK_TABLE (table), 6);
-	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
-	gtk_widget_show (table);
-
-	// Insert table in a new notebook page
-	page_label = gtk_label_new (_("Restore"));
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), table, page_label);
-	gtk_widget_show (table);
-	
-	// Power1
-	TABLE_SCALE(0, _("_Detail factor (p1):"), float, params.power1, 0, 2, 0.1, 0.3, SCALE_DIGITS);
-	TABLE_SCALE(1, _("_Gradient factor (p2):"), float, params.power2, 0, 100, 0.1, 1, SCALE_DIGITS);
-	TABLE_SCALE(2, _("_Time step (dt):"), float, params.dt, 1, 300, 10, 25, SCALE_DIGITS);
-	TABLE_SCALE(3, _("_Blur (sigma):"), float, params.sigma, 0, 10, 0.2, 1, SCALE_DIGITS);
-	TABLE_SCALE(4, _("Blur _iterations (iter) :"), int, params.nb_iter, 1, 5, 1, 2, 0);
-}
-
-void dialog_page2 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
-{
-	GtkWidget *page_label;   
-	GtkWidget *vbox;
-	GtkWidget *table;
-
-	// New vbox
-	page_label = gtk_label_new (_("Quality"));
-	vbox = gtk_vbox_new (FALSE, BOX_SPACING);
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), vbox, page_label);
-	gtk_widget_show (vbox);
-
-	// linear checkbox
-	GtkWidget* check = ajoute_param(NULL, vbox, _("Use linear interpolation:"), -1);
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), params.linear);
-	g_signal_connect (check, "toggled",
-			G_CALLBACK(gimp_toggle_button_update), &params.linear);
-
-	// normalize checkbox
-	check = ajoute_param(NULL, vbox, _("Normalize picture to [0-255]:"), -1);
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), params.onormalize);
-	g_signal_connect (check, "toggled",
-			G_CALLBACK(gimp_toggle_button_update), &params.onormalize);	
-
-	// Create the table
-	table = gtk_table_new (3, 3, FALSE);
-	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
-	gtk_table_set_row_spacings (GTK_TABLE (table), 6);
-	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
-	gtk_widget_show (table);
-
-	// Insert table in the container
-	gtk_container_add (GTK_CONTAINER(vbox), table);
-	gtk_widget_show (table);
-
-	// Insert parameters into the table
-	TABLE_SCALE(0, _("_Angular step (da):"), float, params.dtheta, 5, 90, 5, 15, SCALE_DIGITS);
-	TABLE_SCALE(1, _("_Integral step (dt):"), float, params.dlength, 0.1, 10, 0.1, 0.5, SCALE_DIGITS);
-	TABLE_SCALE(2, _("_Gaussian precision (gauss):"), float, params.gauss_prec, 0.1, 10, 0.1, 0.5, SCALE_DIGITS);	
-}
-
-
-//----------------------------------------------------------------------------
-
-bool dialog(GREYCstoration_params &params, GimpDrawable *preview_src)
-{
-	GtkWidget *dialog;
-	GtkWidget *notebook;
-	GtkWidget *preview;
-	GtkWidget *main_vbox;
-
-	// New dialog
-	gimp_ui_init (PLUGIN_NAME, false);
-	dialog = gimp_dialog_new(
-			_("GREYCstoration"), 
-			PLUGIN_NAME,
-			NULL, (GtkDialogFlags)0,
-			gimp_standard_help_func, "plug-in-" PLUGIN_NAME,
-			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-			GTK_STOCK_OK,     GTK_RESPONSE_OK,
-			NULL);
-
-	// Main vbox	
-	main_vbox = gtk_vbox_new (false, BOX_SPACING);
-	gtk_container_add (GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), main_vbox);
-	gtk_widget_show (main_vbox);
-
-	// Add preview 
-	preview = gimp_drawable_preview_new(preview_src, &params.preview);
-	gtk_container_add (GTK_CONTAINER(main_vbox), preview);
-	gtk_widget_show (preview);
-	g_signal_connect (preview, "invalidated",
-			G_CALLBACK(DoGREYCstoration), preview_src);
-
-	// Create notebook
-	notebook = gtk_notebook_new ();
-	gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook), GTK_POS_TOP);
-	gtk_container_add (GTK_CONTAINER (main_vbox), notebook);
-	gtk_widget_show (notebook);
-
-	// Create differents notebook pages
-	dialog_page1(params, notebook, preview);
-	dialog_page2(params, notebook, preview);
-
-	// Display dialog 
-	gtk_widget_show(dialog);
-	gboolean run = gimp_dialog_run(GIMP_DIALOG(dialog)) == GTK_RESPONSE_OK;
-	gtk_widget_destroy(dialog);
-	return run;
-}
-
-//----------------------------------------------------------------------------
-
-void process_flush()
-{
-	if (image.is_preview) {
-		gimp_drawable_preview_draw_region(
-				GIMP_DRAWABLE_PREVIEW(image.preview), 
-				&image.dst_rgn);
-	} else {
-		gimp_drawable_flush (image.drawable);
-		gimp_drawable_merge_shadow (image.drawable->drawable_id, TRUE);
-		gimp_drawable_update (image.drawable->drawable_id,
-				image.sel_x1, image.sel_y1, image.sel_width, image.sel_height);
-		if (image.run_mode != GIMP_RUN_NONINTERACTIVE) gimp_displays_flush ();
-	}
-}
-
-//----------------------------------------------------------------------------
-
-void set_params()
-{
-#define SET(X) greyc.X = greyc_params.X
-	SET(sigma);
-	SET(nb_iter);
-	SET(dt);
-	SET(dlength);
-	SET(power1);
-	SET(power2);
-	SET(onormalize);
-	SET(gauss_prec);
-	SET(linear);
-#undef SET
-}
-
-//----------------------------------------------------------------------------
-
-bool DoGREYCstoration(GimpPreview *preview, GimpDrawable *drawable)
-{
-	if (!gimp_drawable_is_rgb (drawable->drawable_id)) return false;
-	if (image.run_mode != GIMP_RUN_NONINTERACTIVE) 
-		gimp_progress_update (0);
-	image.init(drawable, preview);
-	set_params();
-	greyc.load_picture(image);
-	if (!greyc.process()) return false;
-	greyc.store_picture(image);
-	process_flush();	
-	return true;
-}
-
-//----------------------------------------------------------------------------
-

Deleted: greycstoration_gimp/dialog.h
===================================================================
--- greycstoration_gimp/dialog.h	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/dialog.h	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,51 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_DIALOG_H
-#define GREYCSTORATION_DIALOG_H
-//----------------------------------------------------------------------------
-#include <libgimp/gimp.h>
-#include <libgimp/gimpui.h>
-//----------------------------------------------------------------------------
-
-typedef struct GREYCstoration_params
-{
-	gint nb_iter; // Number of smoothing iterations
-	gfloat dt;       // Time step
-	gfloat dlength; // Integration step
-	gfloat dtheta; // Angular step (in degrees)
-	gfloat sigma;  // Structure tensor blurring
-	gfloat power1; // Diffusion limiter along isophote
-	gfloat power2; // Diffusion limiter along gradient
-	gfloat gauss_prec; //  Precision of the gaussian function
-	gboolean onormalize; // Output image normalization (in [0,255])
-	gboolean linear; // Use linear interpolation for integration ?
-	gboolean preview; // Use preview ?
-	GREYCstoration_params();
-} GREYCstoration_params;
-
-extern GREYCstoration_params greyc_params;
-
-//----------------------------------------------------------------------------
-
-bool dialog(GREYCstoration_params &params, GimpDrawable *drawable);
-
-bool DoGREYCstoration(GimpPreview *preview, GimpDrawable *drawable);
-//----------------------------------------------------------------------------
-#endif

Deleted: greycstoration_gimp/greycstoration.cpp
===================================================================
--- greycstoration_gimp/greycstoration.cpp	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/greycstoration.cpp	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,596 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "greycstoration.h"
-//----------------------------------------------------------------------------
-using namespace cimg_library;
-typedef unsigned char uchar;
-
-// The line below is necessary for compilation with non-standart C++ compilers.
-#if (( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__))
-#  define std
-#endif
-//----------------------------------------------------------------------------
-
-void get_geom(const char *geom, int &geom_w, int &geom_h) 
-{
-	char tmp[16];
-	std::sscanf(geom,"%d%7[^0-9]%d%7[^0-9]",&geom_w,tmp,&geom_h,tmp+1);
-	if (tmp[0]=='%') geom_w=-geom_w;
-	if (tmp[1]=='%') geom_h=-geom_h;
-}
-
-//----------------------------------------------------------------------------
-
-GREYCstoration::GREYCstoration() : eigen(CImg<>(2,1), CImg<>(2,2))
-{
-	restore = true;
-	inpaint = false;
-	resize = false;
-	visuflow = NULL;
-
-	/* restore */
-	nb_iter        = 1;
-	dt             = 20.0f;
-	sigma          = 0.8f;
-	dlength        = 0.8;
-	dtheta         = 45.0;
-	onormalize     = false;
-	power1         = 0.5;
-	power2         = 0.9;
-
-	/* inpainting *
-	nb_iter                    = 100;
-	dt                         = 50.0f;
-	sigma                      = 2.0;
-	power1                     = 0.1;
-	power2                     = 100;
-	dlength                    = 0.8;
-	dtheta                     = 45.0;
-	 */
-
-	/* resize *
-	nb_iter           = 1;
-	dt                = 30.0f;
-	sigma             = 2.0;
-	dlength           = 0.8;
-	dtheta            = 45.0;
-	power1            = 0.01;
-	power2            = 100.0;
-	 */
-
-	/* visualflow *
-	nb_iter              = 1;
-	dt                   = 30.0f;
-	dlength              = 0.5;
-	dtheta               = 20.0;
-	onormalize = false;
-	*/
-	
-	gauss_prec  = 3.0f;
-	linear = true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::cleanup()
-{
-	img0 = flow = G = dest = sum= W = CImg<>();	
-	mask = CImg<uchar> ();
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare()
-{
-	if (!restore && !inpaint && !resize && !visuflow) 
-	{
-		g_message ("You must specify one of the restore, inpaint, resize or flow mode !");
-		return false;
-	}
-
-	// Init algorithm parameters
-	//---------------------------
-	if (restore) if (!prepare_restore()) return false;
-	if (inpaint) if (!prepare_inpaint()) return false;
-	if (resize) if (!prepare_resize()) return false;
-	if (visuflow) if (!prepare_visuflow()) return false;
-
-	if (!check_args()) return false;
-
-	// Init images
-	//------------
-	dest = CImg<>(img.width,img.height,1,img.dim);
-	sum = CImg<>(img.width,img.height,1);
-	W = CImg<>(img.width,img.height,1,2);
-	
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::check_args()
-{
-	if (power2 < power1)
-	{
-		g_message ("Error : p2<p1 !");
-		return false;
-	}
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_restore()
-{
-	CImgStats stats(img,false);
-	img.normalize((float)stats.min, (float)stats.max);
-	img0=img;
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_inpaint()
-{
-	const char *file_m         = NULL; //cimg_option("-m",(const char*)NULL,"Input inpainting mask");
-	if (!file_m) 
-	{
-		g_message ("You need to specify an inpainting mask (option '-m') !");
-		return false;
-	}
-
-	const unsigned int dilate  = 0; //cimg_option("-dilate",0,"Inpainting mask dilatation");
-	const unsigned int ip_init = 3; //cimg_option("-init",3,"Inpainting init (0=black, 1=white, 2=noise, 3=unchanged, 4=interpol)");
-	if (cimg::strncasecmp("block",file_m,5)) mask = CImg<uchar>(file_m);
-	else {
-		int l=16; std::sscanf(file_m,"block%d",&l);
-		mask = CImg<uchar>(img.width/l,img.height/l);
-		cimg_mapXY(mask,x,y) mask(x,y)=(x+y)%2;
-	}
-	mask.resize(img.width,img.height,1,1);
-	if (dilate) mask.dilate(dilate);
-	switch (ip_init) {
-		case 0 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 0; } break;
-		case 1 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 255; } break;
-		case 2 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = (float)(255*cimg::rand()); } break;
-		case 3 : break;
-		case 4 : {
-					 CImg<uchar> tmask(mask),ntmask(tmask);
-					 CImg_3x3(M,uchar);
-					 CImg_3x3(I,float);
-					 while (CImgStats(ntmask,false).max>0) {
-						 cimg_map3x3(tmask,x,y,0,0,M) if (Mcc && (!Mpc || !Mnc || !Mcp || !Mcn)) {
-							 const float ccp = Mcp?0.0f:1.0f, cpc = Mpc?0.0f:1.0f,
-								   cnc = Mnc?0.0f:1.0f, ccn = Mcn?0.0f:1.0f, csum = ccp + cpc + cnc + ccn;
-							 cimg_mapV(img,k) {
-								 cimg_get3x3(img,x,y,0,k,I);
-								 img(x,y,k) = (ccp*Icp + cpc*Ipc + cnc*Inc + ccn*Icn)/csum;
-							 }
-							 ntmask(x,y) = 0;
-						 }
-						 tmask = ntmask;
-					 }
-				 } break;    
-		default: break;
-	}
-	img0=img;
-	G = CImg<>(img.width,img.height,1,3,0);
-	CImg_3x3(g,uchar);
-	CImg_3x3(I,float);
-	cimg_map3x3(mask,x,y,0,0,g) if (!gcc && !(gnc-gcc) && !(gcc-gpc) && !(gcn-gcc) && !(gcc-gcp)) cimg_mapV(img,k) {
-		cimg_get3x3(img,x,y,0,k,I);
-		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
-		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
-	}
-	G.blur(sigma);
-	{ cimg_mapXY(G,x,y) 
-		{
-			G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
-			const float
-				l1 = eigen(0)[0],
-				   l2 = eigen(0)[1],
-				   u = eigen(1)[0],
-				   v = eigen(1)[1],      
-				   ng = (float)std::sqrt(l1+l2),
-				   n1 = (float)(1.0/std::pow(1+ng,power1)),
-				   n2 = (float)(1.0/std::pow(1+ng,power2)),
-				   sr1 = (float)std::sqrt(n1),
-				   sr2 = (float)std::sqrt(n2);
-			G(x,y,0) = sr1*u*u + sr2*v*v;
-			G(x,y,1) = u*v*(sr1-sr2);
-			G(x,y,2) = sr1*v*v + sr2*u*u;
-		}    
-	}
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_resize()
-{
-	const char *geom  = NULL; //cimg_option("-g",(const char*)NULL,"Output image geometry");
-	const bool anchor = true; //cimg_option("-anchor",true,"Anchor original pixels");
-	if (!geom) throw CImgArgumentException("You need to specify an output geomety (option -g)");
-	int w,h; get_geom(geom,w,h);
-	mask = CImg<uchar>(img.width,img.height,1,1,255);
-	if (!anchor) mask.resize(w,h,1,1,1); else mask = ~mask.resize(w,h,1,1,4);
-	img0 = img.get_resize(w,h,1,-100,1);
-	img.resize(w,h,1,-100,3);
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_visuflow()
-{
-	const char *geom     = "100%x100%"; //cimg_option("-g","100%x100%","Output geometry");
-	//const char *file_i   = (const char *)NULL; //cimg_option("-i",(const char*)NULL,"Input init image");
-	const bool normalize = false; //cimg_option("-norm",false,"Normalize input flow");
-
-	int w,h; get_geom(geom,w,h);
-	if (!cimg::strcasecmp(visuflow,"circle")) { // Create a circular vector flow
-		flow = CImg<>(400,400,1,2);
-		cimg_mapXY(flow,x,y) {
-			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
-			flow(x,y,0) = -(float)std::sin(ang);
-			flow(x,y,1) = (float)std::cos(ang);
-		}
-	}
-	if (!cimg::strcasecmp(visuflow,"radial")) { // Create a radial vector flow
-		flow = CImg<>(400,400,1,2);
-		cimg_mapXY(flow,x,y) {
-			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
-			flow(x,y,0) = (float)std::cos(ang);
-			flow(x,y,1) = (float)std::sin(ang);
-		}
-	}
-	if (!flow.data) flow = CImg<>(visuflow);
-	flow.resize(w,h,1,2,3);
-	if (normalize) flow.orientation_pointwise();
-	/*    if (file_i) img = CImg<>(file_i);
-		  else img = CImg<>(flow.width,flow.height,1,1,0).noise(100,2); */
-	img0=img;
-	img0.fill(0);
-	float color[3]={255,255,255};
-	img0.draw_quiver(flow,color,15,-10);
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_smoothed_tensor()
-{
-	if (visuflow || inpaint) return;
-	CImg_3x3(I,float);
-	G.fill(0);
-	cimg_mapV(img,k) cimg_map3x3(img,x,y,0,k,I) {
-		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
-		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
-	}
-	G.blur(sigma);
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_normalized_tensor()
-{
-	if (restore || resize) cimg_mapXY(G,x,y) {
-		G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
-		const float
-			l1 = eigen(0)[0],
-			   l2 = eigen(0)[1],
-			   u = eigen(1)[0],
-			   v = eigen(1)[1],      
-			   n1 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power1)),
-			   n2 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power2));
-		G(x,y,0) = n1*u*u + n2*v*v;
-		G(x,y,1) = u*v*(n1-n2);
-		G(x,y,2) = n1*v*v + n2*u*u;
-	}    
-	if (visuflow) cimg_mapXY(G,x,y) {
-		const float 
-			u = flow(x,y,0),
-			  v = flow(x,y,1),
-			  n = (float)std::pow(u*u+v*v,0.25f),
-			  nn = n<1e-5?1:n;
-		G(x,y,0) = u*u/nn;
-		G(x,y,1) = u*v/nn;
-		G(x,y,2) = v*v/nn;
-	}
-
-	const CImgStats stats(G,false);
-	G /= cimg::max(std::fabs(stats.max), std::fabs(stats.min));
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_W(float cost, float sint)
-{
-	cimg_mapXY(W,x,y) {
-		const float 
-			a = G(x,y,0),
-			  b = G(x,y,1),
-			  c = G(x,y,2),
-			  u = a*cost + b*sint,
-			  v = b*cost + c*sint;
-		W(x,y,0) = u;
-		W(x,y,1) = v;
-	}
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_LIC_back_forward(int x, int y)
-{
-	float l, X,Y, cu, cv, lsum=0;
-	const float fsigma2 = 2*dt*(W(x,y,0)*W(x,y,0) + W(x,y,1)*W(x,y,1));
-	const float length = gauss_prec*(float)std::sqrt(fsigma2);
-
-	if (linear) {
-
-		// Integrate with linear interpolation
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = (float)x; 
-		Y  = (float)y;
-		for (l=0; l<length; l+=dlength) 
-		{
-			float u = (float)W.linear_pix2d(X,Y,0);
-			float v = (float)W.linear_pix2d(X,Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X+=dlength*u;
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y+=dlength*v; 
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-		
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = x-dlength*cu; 
-		Y  = y-dlength*cv;
-		for (l=dlength; l<length; l+=dlength) 
-		{
-			float u = (float)W.linear_pix2d(X,Y,0);
-			float v = (float)W.linear_pix2d(X,Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k)+=(float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X-=dlength*u;
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y-=dlength*v;
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u;
-			cv=v;
-		}
-
-	} else {
-
-		// Integrate with non linear interpolation
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = (float)x; 
-		Y  = (float)y; 
-		for (l=0; l<length; l+=dlength) 
-		{
-			float u = W((int)X,(int)Y,0);
-			float v = W((int)X,(int)Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X+=dlength*u; 
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y+=dlength*v; 
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-		
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = x-dlength*cu; 
-		Y  = y-dlength*cv;
-		for (l=dlength; l<length && X>=0 && Y>=0 && X<=W.dimx()-1 && Y<=W.dimy()-1; l+=dlength) 
-		{
-			float u = W((int)X,(int)Y,0);
-			float v = W((int)X,(int)Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X-=dlength*u; 
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y-=dlength*v;
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-	}
-	sum(x,y)+=lsum;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_LIC(int &counter)
-{
-	dest.fill(0);
-	sum.fill(0);
-	for (float theta=(180%(int)dtheta)/2.0f; theta<180; theta+=dtheta) 
-	{
-		const float
-			rad = (float)(theta*cimg::PI/180.0),
-				cost = (float)std::cos(rad),
-				sint = (float)std::sin(rad);
-
-		// Compute vector field w = sqrt(T)*a_alpha
-		compute_W(cost, sint);
-
-		// Compute the LIC along w in backward and forward directions
-		cimg_mapXY(dest,x,y) 
-		{
-			counter++;
-			if (image.use_progress && !((counter)%100000)) 
-			{
-				gdouble progress = counter;
-				progress /= (gdouble)dest.width*dest.height*nb_iter*(180/dtheta);
-				gimp_progress_update (progress);
-			}
-			
-			if (!mask.data || mask(x,y)) compute_LIC_back_forward(x,y);
-		}
-	}
-
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_average_LIC()
-{
-	cimg_mapXY(dest,x,y) 
-	{
-		if (sum(x,y)>0) 
-			cimg_mapV(dest,k) dest(x,y,k) /= sum(x,y); 
-		else 
-			cimg_mapV(dest,k) dest(x,y,k) = img(x,y,k);
-	}
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::process()
-{
-	if (!prepare()) return false;
-
-	//-------------------------------------
-	// Begin regularization PDE iterations
-	//-------------------------------------
-	int counter = 0;
-	for (unsigned int iter=0; iter<nb_iter; iter++) 
-	{
-		// Compute smoothed structure tensor field G
-		compute_smoothed_tensor();
-
-		// Compute normalized tensor field sqrt(T) in G
-		compute_normalized_tensor();
-
-		// Compute LIC's along different angle projections a_\alpha
-		compute_LIC(counter);
-
-		// Average all the LIC's
-		compute_average_LIC();
-
-		// Next step
-		img = dest;
-	}
-
-	// Save result and end program
-	//-----------------------------
-	if (visuflow) dest.mul(flow.get_norm_pointwise()).normalize(0,255);
-	if (onormalize) dest.normalize(0,255);
-	cleanup();
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::load_picture(Image &cfg)
-{
-	guchar* row = g_new (guchar, cfg.width), *row_ptr;
-
-	img = CImg<>(cfg.sel_width, cfg.sel_height, 1, 3);
-
-	for (gint y=0; y < cfg.sel_height; y++)
-	{
-		gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		row_ptr = row;
-		if (image.img_alpha) {
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				img(x, y,0) = row_ptr[0];
-				img(x, y,1) = row_ptr[1];
-				img(x, y,2) = row_ptr[2];
-				row_ptr += 4;
-			}	
-		} else {
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				img(x, y,0) = row_ptr[0];
-				img(x, y,1) = row_ptr[1];
-				img(x, y,2) = row_ptr[2];
-				row_ptr += 3;
-			}	
-		}
-	}
-	g_free (row);
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::store_picture(Image &cfg)
-{
-	guchar* row = g_new (guchar, cfg.width), *row_ptr;
-
-	if (image.img_alpha)
-	{
-		for (gint y=0; y < cfg.sel_height; y++)
-		{
-			gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-			row_ptr = row;
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
-				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
-				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
-				row_ptr += 4;
-			}
-			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		}
-	} else {
-		for (gint y=0; y < cfg.sel_height; y++)
-		{
-			row_ptr = row;
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
-				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
-				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
-				row_ptr += 3;
-			}
-			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		}
-	}
-
-	g_free (row);
-}
-
-//----------------------------------------------------------------------------

Deleted: greycstoration_gimp/greycstoration.h
===================================================================
--- greycstoration_gimp/greycstoration.h	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/greycstoration.h	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,90 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_CLASS_H
-#define GREYCSTORATION_CLASS_H
-//----------------------------------------------------------------------------
-#include "CImg.h"
-#include "image.h"
-//----------------------------------------------------------------------------
-
-class GREYCstoration
-{
-public:
-	// parameters
-	unsigned int nb_iter; // Number of smoothing iterations
-	float dt;       // Time step
-	float dlength; // Integration step
-	float dtheta; // Angular step (in degrees)
-	float sigma;  // Structure tensor blurring
-	float power1; // Diffusion limiter along isophote
-	float power2; // Diffusion limiter along gradient
-	float gauss_prec; //  Precision of the gaussian function
-	bool onormalize; // Output image normalization (in [0,255])
-	bool linear; // Use linear interpolation for integration
-
-private:
-	// internal use
-	bool restore;
-	bool inpaint;
-	bool resize;
-	const char* visuflow;
-	cimg_library::CImg<> dest, sum, W;
-	cimg_library::CImg<> img, img0, flow,G;
-	cimg_library::CImgl<> eigen;
-	cimg_library::CImg<unsigned char> mask;
-
-public:
-	GREYCstoration();
-	void load_picture(Image& image);
-	void store_picture(Image& image);
-	bool process();
-
-private:
-	// Compute smoothed structure tensor field G
-	void compute_smoothed_tensor();
-	
-	// Compute normalized tensor field sqrt(T) in G
-	void compute_normalized_tensor();
-	
-	// Compute LIC's along different angle projections a_\alpha
-	void compute_LIC(int &counter);
-	void compute_LIC_back_forward(int x, int y);
-	void compute_W(float cost, float sint);
-	
-	// Average all the LIC's
-	void compute_average_LIC();
-
-	// Prepare datas
-	bool prepare();
-	bool prepare_restore();
-	bool prepare_inpaint();
-	bool prepare_resize();
-	bool prepare_visuflow();
-
-	// Check arguments
-	bool check_args();
-
-	// Clean up memory (CImg datas) to save memory
-	void cleanup();
-};
-
-extern GREYCstoration greyc;
-//----------------------------------------------------------------------------
-#endif

Deleted: greycstoration_gimp/image.cpp
===================================================================
--- greycstoration_gimp/image.cpp	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/image.cpp	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,62 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "image.h"
-//----------------------------------------------------------------------------
-
-Image::Image()
-{
-	drawable = NULL;
-	run_mode = GIMP_RUN_NONINTERACTIVE;
-}
-
-//----------------------------------------------------------------------------
-
-void Image::init(GimpDrawable *pdrawable, GimpPreview *ppreview)
-{
-	drawable = pdrawable;
-	preview = ppreview;
-	if (ppreview) {
-		is_preview = true;
-		gimp_preview_get_position(preview, &sel_x1, &sel_y1);
-		gimp_preview_get_size(preview, &sel_width, &sel_height);
-		sel_x2 = sel_x1 + sel_width;	
-		sel_y2 = sel_y1 + sel_height;	
-	} else {
-		is_preview = false;
-		gimp_drawable_mask_bounds (drawable->drawable_id,
-				&sel_x1, &sel_y1, &sel_x2, &sel_y2);
-		sel_width  = sel_x2 - sel_x1;
-		sel_height = sel_y2 - sel_y1;
-	}
-	img_bpp   = gimp_drawable_bpp (drawable->drawable_id);
-	img_alpha = gimp_drawable_has_alpha (drawable->drawable_id);
-	gimp_pixel_rgn_init (&src_rgn, drawable,
-			sel_x1, sel_y1, sel_width, sel_height, FALSE, FALSE);
-	gimp_pixel_rgn_init (&dst_rgn, drawable,
-			sel_x1, sel_y1, sel_width, sel_height, !is_preview, TRUE);
-	width = sel_width * img_bpp;
-	use_progress = (run_mode != GIMP_RUN_NONINTERACTIVE) && !is_preview;
-}
-
-//----------------------------------------------------------------------------

Deleted: greycstoration_gimp/image.h
===================================================================
--- greycstoration_gimp/image.h	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/image.h	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,52 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_IMAGE_H
-#define GREYCSTORATION_IMAGE_H
-//----------------------------------------------------------------------------
-#include <libgimp/gimp.h>
-#include <libgimp/gimpui.h>
-//----------------------------------------------------------------------------
-
-class Image
-{
-public:
-	GimpDrawable *drawable;   /* Current image */
-	GimpPixelRgn src_rgn, dst_rgn;
-	gint       sel_x1;               /* Selection bounds */
-	gint       sel_y1;
-	gint       sel_x2;
-	gint       sel_y2;
-	gint       sel_width;            /* Selection width */
-	gint       sel_height;           /* Selection height */
-	gint       img_bpp;              /* Bytes-per-pixel in image */
-	bool		img_alpha;
-	guint		width;
-	bool		is_preview;
-	GimpPreview*	preview;
-	bool 		use_progress;
-	GimpRunMode run_mode;
-public:
-	Image();
-	void init(GimpDrawable *drawable, GimpPreview *preview);
-};
-
-extern Image image;
-//----------------------------------------------------------------------------
-#endif

Deleted: greycstoration_gimp/main.cpp
===================================================================
--- greycstoration_gimp/main.cpp	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/main.cpp	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,152 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-#include "plugin-intl.h"
-
-#include <libgimp/gimp.h>
-#include "dialog.h"
-#include "greycstoration.h"
-#include <unistd.h>
-
-//----------------------------------------------------------------------------
-GREYCstoration greyc;
-GREYCstoration_params greyc_params;
-Image image;
-//----------------------------------------------------------------------------
-
-static void query(void);
-static void run (const gchar* name,
-		gint nparams,
-		const GimpParam* param,
-		gint* nreturn_vals,
-		GimpParam** return_vals);
-
-//----------------------------------------------------------------------------
-
-GimpPlugInInfo PLUG_IN_INFO = 
-{
-	NULL,
-	NULL,
-	query,
-	run
-};
-
-//----------------------------------------------------------------------------
-
-MAIN()
-
-//----------------------------------------------------------------------------
-
-static void query(void)
-{
-	static GimpParamDef args[] =
-	{
-		{
-			GIMP_PDB_INT32,
-			"run_mode",
-			"Run mode"
-		},{
-			GIMP_PDB_IMAGE,
-			"image",
-			"Input image"
-		},{
-			GIMP_PDB_DRAWABLE,
-			"drawable",
-			"Input drawable"
-		}
-	};
-	gimp_install_procedure (
-			"plug_in_hello",
-			PLUGIN_NAME,
-			"Filtre Greystoration",
-			"Victor STINNER",
-			"Copyright Victor STINNER",
-			"2005",
-			"<Image>/Filters/Misc/_GREYCstoration",
-			"RGB*", //GRAY*
-			GIMP_PLUGIN,
-			G_N_ELEMENTS(args), 0,
-			args, NULL);
-}
-
-//----------------------------------------------------------------------------
-
-static void run (const gchar* name,
-		gint nparams,
-		const GimpParam* param,
-		gint* nreturn_vals,
-		GimpParam** return_vals)
-{
-	static GimpParam values[1];
-	GimpPDBStatusType status = GIMP_PDB_SUCCESS;
-
-	/* Reduce the processes importance so that it doesn't make the computer 
-	   non-interactive */
-	nice(19);
-
-	/*  Initialize i18n support  */
-	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
-#ifdef HAVE_BIND_TEXTDOMAIN_CODESET
-	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
-#endif
-	textdomain (GETTEXT_PACKAGE);
-
-	/* Mise en place d'une valeur obligatoire de retour */
-	*nreturn_vals = 1;
-	*return_vals = values;
-
-	values[0].type = GIMP_PDB_STATUS;
-	values[0].data.d_status = status;
-
-	image.run_mode = static_cast<GimpRunMode> (param[0].data.d_int32);
-	GimpDrawable *drawable = gimp_drawable_get (param[2].data.d_drawable);
-	
-	switch (image.run_mode)
-	{
-		case GIMP_RUN_INTERACTIVE:
-			gimp_get_data("plug_in_" PLUGIN_NAME, &greyc_params);
-			if (!dialog(greyc_params, drawable)) return;
-			gimp_set_data("plug_in_" PLUGIN_NAME, &greyc_params, sizeof(greyc_params));
-			break;
-			
-		case GIMP_RUN_NONINTERACTIVE:
-return;
-			break;
-
-		case GIMP_RUN_WITH_LAST_VALS:
-			gimp_get_data("plug_in_" PLUGIN_NAME, &greyc_params);
-			break;
-		default: return;
-	}
-
-	if (!DoGREYCstoration(NULL, drawable)) 
-	{
-		if (image.run_mode != GIMP_RUN_NONINTERACTIVE)
-			g_message ("Erreur !?");
-		status = GIMP_PDB_EXECUTION_ERROR;
-		values[0].data.d_status = status;
-	}
-	gimp_drawable_detach (drawable);
-}
-
-//----------------------------------------------------------------------------
-

Deleted: greycstoration_gimp/plug_in.h
===================================================================
--- greycstoration_gimp/plug_in.h	2005-11-21 21:46:49 UTC (rev 257)
+++ greycstoration_gimp/plug_in.h	2005-11-21 22:57:19 UTC (rev 258)
@@ -1,25 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_PLUGIN_H
-#define GREYCSTORATION_PLUGIN_H
-//----------------------------------------------------------------------------
-#define PLUG_IN_NAME "greycstoration"
-//----------------------------------------------------------------------------
-#endif

Copied: greycstoration_gimp/src/CImg.h (from rev 256, greycstoration_gimp/CImg.h)

Copied: greycstoration_gimp/src/Makefile (from rev 256, greycstoration_gimp/Makefile)

Copied: greycstoration_gimp/src/dialog.cpp (from rev 257, greycstoration_gimp/dialog.cpp)

Copied: greycstoration_gimp/src/dialog.h (from rev 256, greycstoration_gimp/dialog.h)

Copied: greycstoration_gimp/src/greycstoration.cpp (from rev 257, greycstoration_gimp/greycstoration.cpp)

Copied: greycstoration_gimp/src/greycstoration.h (from rev 256, greycstoration_gimp/greycstoration.h)

Copied: greycstoration_gimp/src/image.cpp (from rev 257, greycstoration_gimp/image.cpp)

Copied: greycstoration_gimp/src/image.h (from rev 256, greycstoration_gimp/image.h)

Copied: greycstoration_gimp/src/main.cpp (from rev 257, greycstoration_gimp/main.cpp)



From haypo at berlios.de  Tue Nov 22 00:33:13 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 22 Nov 2005 00:33:13 +0100
Subject: [Happyboom-svn] r261 - / haypo haypo/greycstoration_gimp
Message-ID: <200511212333.jALNXDkj001948@sheep.berlios.de>

Author: haypo
Date: 2005-11-22 00:33:10 +0100 (Tue, 22 Nov 2005)
New Revision: 261

Added:
   haypo/greycstoration_gimp/
   haypo/greycstoration_gimp/INSTALL
   haypo/greycstoration_gimp/Makefile.am
   haypo/greycstoration_gimp/autogen.sh
   haypo/greycstoration_gimp/configure.in
   haypo/greycstoration_gimp/po/
   haypo/greycstoration_gimp/src/
   haypo/poilu/
   haypo/trouphp/
   haypo/turing/
Removed:
   greycstoration_gimp/
   haypo/greycstoration_gimp/CImg.h
   haypo/greycstoration_gimp/INSTALL
   haypo/greycstoration_gimp/Makefile
   haypo/greycstoration_gimp/dialog.cpp
   haypo/greycstoration_gimp/dialog.h
   haypo/greycstoration_gimp/greycstoration.cpp
   haypo/greycstoration_gimp/greycstoration.h
   haypo/greycstoration_gimp/image.cpp
   haypo/greycstoration_gimp/image.h
   haypo/greycstoration_gimp/main.cpp
   haypo/greycstoration_gimp/plug_in.h
   poilu/
   trouphp/
   turing/
Log:
Move trouphp, greycstoration, poilu and turing in haypo subdirectory.


Copied: haypo/greycstoration_gimp (from rev 256, greycstoration_gimp)

Deleted: haypo/greycstoration_gimp/CImg.h
===================================================================
--- greycstoration_gimp/CImg.h	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/CImg.h	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,9655 +0,0 @@
-/*------------------------------------------------------------------------------------------------------
-  
-  File        : CImg.h
-  
-  Description : The C++ Template Image Processing Library
-
-  Author      : David Tschumperl?
-   
-  This software is governed by the CeCILL  license under French law and
-  abiding by the rules of distribution of free software.  You can  use, 
-  modify and/ or redistribute the software under the terms of the CeCILL
-  license as circulated by CEA, CNRS and INRIA at the following URL
-  "http://www.cecill.info". 
-  
-  As a counterpart to the access to the source code and  rights to copy,
-  modify and redistribute granted by the license, users are provided only
-  with a limited warranty  and the software's author,  the holder of the
-  economic rights,  and the successive licensors  have only  limited
-  liability. 
-  
-  In this respect, the user's attention is drawn to the risks associated
-  with loading,  using,  modifying and/or developing or reproducing the
-  software by the user in light of its specific status of free software,
-  that may mean  that it is complicated to manipulate,  and  that  also
-  therefore means  that it is reserved for developers  and  experienced
-  professionals having in-depth computer knowledge. Users are therefore
-  encouraged to load and test the software's suitability as regards their
-  requirements in conditions enabling the security of their systems and/or 
-  data to be ensured and,  more generally, to use and operate it in the 
-  same conditions as regards security. 
-  
-  The fact that you are presently reading this means that you have had
-  knowledge of the CeCILL license and that you accept its terms.
-  
-  ----------------------------------------------------------------------------------------------------*/
-
-#ifndef cimg_version
-#define cimg_version 1.08
-#include <cstdio>
-#include <cstdlib>
-#include <cstdarg>
-#include <cmath>
-#include <cstring>
-#include <ctime>
-
-// Overcome VisualC++ 6.0 and DMC compilers namespace 'std::' bug
-#if ( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__)
-#define std
-#endif
-
-/*-------------------------------------------------------------
-  
-
-  Auto-detect and set CImg Library configuration flags.
-  
-  
-  If compilation flags are not adapted to your system,
-  you may override their values, before including
-  the header file "CImg.h" (use the #define directive).
-  
-  -------------------------------------------------------------*/
-
-#ifndef cimg_OS
-#if defined(sun) || defined(__sun)        
-// Sun/Solaris configuration
-#define cimg_OS            0
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#elif defined(linux) || defined(__linux) || defined(__CYGWIN__)
-// PC Linux configuration
-#define cimg_OS            1
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#elif defined(_WIN32) || defined(__WIN32__)
-// PC Windows configuration
-#define cimg_OS            2
-#ifndef cimg_display_type
-#define cimg_display_type  2
-#endif
-#elif defined(__MACOSX__) || defined(__APPLE__)
-// Mac OS X configuration
-#define cimg_OS            3
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#elif defined(__FreeBSD__)
-// FreeBSD configuration
-#define cimg_OS            4
-#ifndef cimg_display_type
-#define cimg_display_type  1
-#endif
-#ifndef cimg_color_terminal
-#define cimg_color_terminal
-#endif
-#else
-// Unknown configuration : minimal dependencies.
-#define cimg_OS           -1
-#ifndef cimg_display_type
-#define cimg_display_type  0
-#endif
-#endif
-#endif
-
-// Debug configuration.
-//--------------------
-// Define 'cimg_debug' to : 0 to remove dynamic debug messages (exceptions are still thrown)
-//                          1 to display dynamic debug messages (default behavior).
-//                          2 to add extra memory access controls (may slow down the code)
-#ifndef cimg_debug
-#define cimg_debug         1
-#endif
-
-// Architecture-dependent includes
-//---------------------------------
-#if cimg_OS!=2
-#include <sys/time.h>
-#include <unistd.h>
-#else
-#include <windows.h>
-// Discard annoying macro definitions in windows.h
-#ifdef min
-#undef min
-#undef max
-#undef abs
-#endif
-#endif
-#if cimg_display_type==1
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <X11/keysym.h>
-#include <pthread.h>
-#endif
-
-/*-----------------------------------------------------------------------------------
-  
-
-
-   Define some macros. Macros of the CImg Library are prefixed by 'cimg_'
-   Documented macros below may be safely used in your own code.
-   
-   
-   ---------------------------------------------------------------------------------*/
-
-// Macros used to describe the program usage, and retrieve command line arguments
-// (See corresponding module 'Retrieving command line arguments' in the generated documentation).
-#define cimg_usage(usage) cimg_library::cimg::option((char*)NULL,(unsigned int)argc,(char**)argv,(char*)NULL,(char*)usage)
-#define cimg_option(name,defaut,usage) cimg_library::cimg::option((char*)name,(unsigned int)argc,(char**)argv,defaut,(char*)usage)
-
-// Macros used for dynamic debug messages. Shouldn't be used in your own source code.
-#define cimg_test(x,func)						\
-  if(!(x).width || !(x).height || !(x).depth || !(x).dim || !(x).data)	\
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is empty", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimgl_test(x,func) \
-  if(!(x).size || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImgl<%s> %s = (%d,%p) is empty", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).size,(x).data)
-#define cimg_test_scalar(x,func) \
-  if(!(x).width || !(x).height || !(x).depth || (x).dim!=1 || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not scalar", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimg_test_matrix(x,func) \
-  if(!(x).width || !(x).height || (x).depth!=1 || (x).dim!=1 || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not a matrix", \
-                                func,__FILE__,__LINE__,(x).pixel_type(),#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimg_test_square(x,func) \
-  if(!(x).width || !(x).height || (x).depth!=1 || (x).dim!=1 || (x).width!=(x).height || !(x).data) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', line %d), CImg<%s> %s = (%d,%d,%d,%d,%p) is not a square matrix", \
-                                func,__FILE__,__LINE__,(x).pixel_type,#x,(x).width,(x).height,(x).depth,(x).dim,(x).data)
-#define cimg_test_display(x,func) \
-  if (!(x).width || !(x).height) \
-    throw CImgInstanceException("(Instance error) : In function '%s()' ('%s', l.%d), CImgDisplay %s = (%d,%d) is not a valid display", \
-                                func,__FILE__,__LINE__,#x,(x).width,(x).height)
-  
-// Macros used for neighborhood definitions and manipulations (see module 'Using Image Loops' in the generated documentation).
-#define CImg_2x2(I,T)     T I##cc,I##nc=0,I##cn,I##nn=0
-#define CImg_3x3(I,T)     T I##pp,I##cp,I##np=0,I##pc,I##cc,I##nc=0,I##pn,I##cn,I##nn=0
-#define CImg_4x4(I,T)     T I##pp,I##cp,I##np=0,I##ap=0, \
-                            I##pc,I##cc,I##nc=0,I##ac=0, \
-                            I##pn,I##cn,I##nn=0,I##an=0, \
-                            I##pa,I##ca,I##na=0,I##aa=0
-#define CImg_5x5(I,T)     T I##bb,I##pb,I##cb,I##nb=0,I##ab=0, \
-                            I##bp,I##pp,I##cp,I##np=0,I##ap=0, \
-                            I##bc,I##pc,I##cc,I##nc=0,I##ac=0, \
-                            I##bn,I##pn,I##cn,I##nn=0,I##an=0, \
-                            I##ba,I##pa,I##ca,I##na=0,I##aa=0
-#define CImg_2x2x2(I,T)   T I##ccc,I##ncc=0,I##cnc,I##nnc=0, \
-                            I##ccn,I##ncn=0,I##cnn,I##nnn=0
-#define CImg_3x3x3(I,T)   T I##ppp,I##cpp,I##npp=0,I##pcp,I##ccp,I##ncp=0,I##pnp,I##cnp,I##nnp=0, \
-                            I##ppc,I##cpc,I##npc=0,I##pcc,I##ccc,I##ncc=0,I##pnc,I##cnc,I##nnc=0, \
-                            I##ppn,I##cpn,I##npn=0,I##pcn,I##ccn,I##ncn=0,I##pnn,I##cnn,I##nnn=0
-
-#define CImg_2x2_ref(I,T,tab)   T &I##cc=(tab)[0],&I##nc=(tab)[1],&I##cn=(tab)[2],&I##nn=(tab)[3];
-#define CImg_3x3_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2], \
-                                  &I##pc=(tab)[3],&I##cc=(tab)[4],&I##nc=(tab)[5], \
-                                  &I##pn=(tab)[6],&I##cn=(tab)[7],&I##nn=(tab)[8]
-#define CImg_4x4_ref(I,T,tab)   T &I##pp=(tab)[0],&I##cp=(tab)[1],&I##np=(tab)[2],&I##ap=(tab)[3], \
-                                  &I##pc=(tab)[4],&I##cc=(tab)[5],&I##nc=(tab)[6],&I##ap=(tab)[7], \
-                                  &I##pn=(tab)[8],&I##cn=(tab)[9],&I##nn=(tab)[10],&I##aa=(tab)[11], \
-                                  &I##pa=(tab)[12],&I##ca=(tab)[13],&I##na=(tab)[14],&I##aa=(tab)[15]
-#define CImg_5x5_ref(I,T,tab)   T &I##bb=(tab)[0],&I##pb=(tab)[1],&I##cb=(tab)[2],&I##nb=(tab)[3],&I##ab=(tab)[4], \
-                                  &I##bp=(tab)[5],&I##pp=(tab)[6],&I##cp=(tab)[7],&I##np=(tab)[8],&I##ap=(tab)[9], \
-                                  &I##bc=(tab)[10],&I##pc=(tab)[11],&I##cc=(tab)[12],&I##nc=(tab)[13],&I##ac=(tab)[14], \
-                                  &I##bn=(tab)[15],&I##pn=(tab)[16],&I##cn=(tab)[17],&I##nn=(tab)[18],&I##an=(tab)[19], \
-                                  &I##ba=(tab)[20],&I##pa=(tab)[21],&I##ca=(tab)[22],&I##na=(tab)[23],&I##aa=(tab)[24]
-#define CImg_2x2x2_ref(I,T,tab) T &I##ccc=(tab)[0],&I##ncc=(tab)[1],&I##cnc=(tab)[2],&I##nnc=(tab)[3], \
-                                  &I##ccn=(tab)[4],&I##ncn=(tab)[5],&I##cnn=(tab)[6],&I##nnn=(tab)[7]
-#define CImg_3x3x3_ref(I,T,tab) T &I##ppp=(tab)[0],&I##cpp=(tab)[1],&I##npp=(tab)[2], \
-                                  &I##pcp=(tab)[3],&I##ccp=(tab)[4],&I##ncp=(tab)[5], \
-                                  &I##pnp=(tab)[6],&I##cnp=(tab)[7],&I##nnp=(tab)[8], \
-                                  &I##ppc=(tab)[9],&I##cpc=(tab)[10],&I##npc=(tab)[11], \
-                                  &I##pcc=(tab)[12],&I##ccc=(tab)[13],&I##ncc=(tab)[14], \
-                                  &I##pnc=(tab)[15],&I##cnc=(tab)[16],&I##nnc=(tab)[17], \
-                                  &I##ppn=(tab)[18],&I##cpn=(tab)[19],&I##npn=(tab)[20], \
-                                  &I##pcn=(tab)[21],&I##ccn=(tab)[22],&I##ncn=(tab)[23], \
-                                  &I##pnn=(tab)[24],&I##cnn=(tab)[25],&I##nnn=(tab)[26]
-
-#define cimg_squaresum2x2(I) ( I##cc*I##cc + I##nc*I##nc + I##cn*I##cn + I##nn*I##nn )
-#define cimg_squaresum3x3(I) ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + \
-                               I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + \
-                               I##pn*I##pn + I##cn*I##cn + I##nn*I##nn )
-#define cimg_squaresum4x4(I) ( I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
-                               I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
-                               I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
-                               I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
-#define cimg_squaresum5x5(I) ( I##bb*I##bb + I##pb*I##pb + I##cb*I##cb + I##nb*I##nb + I##ab*I##ab + \
-                               I##bp*I##bp + I##pp*I##pp + I##cp*I##cp + I##np*I##np + I##ap*I##ap + \
-                               I##bc*I##bc + I##pc*I##pc + I##cc*I##cc + I##nc*I##nc + I##ac*I##ac + \
-                               I##bn*I##bn + I##pn*I##pn + I##cn*I##cn + I##nn*I##nn + I##an*I##an + \
-                               I##ba*I##ba + I##pa*I##pa + I##ca*I##ca + I##na*I##na + I##aa*I##aa )
-#define cimg_squaresum2x2x2(I) ( I##ccc*I##ccc + I##ncc*I##ncc + I##cnc*I##cnc + I##nnc*I##nnc + \
-                                 I##ccn*I##ccn + I##ncn*I##ncn + I##cnn*I##cnn + I##nnn*I##nnn )
-#define cimg_squaresum3x3x3(I) ( I##ppp*I##ppp + I##cpp*I##cpp + I##npp*I##npp + \
-                                 I##pcp*I##pcp + I##ccp*I##ccp + I##ncp*I##ncp + \
-                                 I##pnp*I##pnp + I##cnp*I##cnp + I##nnp*I##nnp + \
-                                 I##ppc*I##ppc + I##cpc*I##cpc + I##npc*I##npc + \
-                                 I##pcc*I##pcc + I##ccc*I##ccc + I##ncc*I##ncc + \
-                                 I##pnc*I##pnc + I##cnc*I##cnc + I##nnc*I##nnc + \
-                                 I##ppn*I##ppn + I##cpn*I##cpn + I##npn*I##npn + \
-                                 I##pcn*I##pcn + I##ccn*I##ccn + I##ncn*I##ncn + \
-                                 I##pnn*I##pnn + I##cnn*I##cnn + I##nnn*I##nnn )
-
-#define cimg_corr2x2(I,m) ( I##cc*(m)(0,0)+I##nc*(m)(1,0)+I##cn*(m)(0,1)+I##nn*(m)(1,1) )
-#define cimg_corr3x3(I,m) ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0) + \
-                            I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1) + \
-                            I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2) )
-#define cimg_corr4x4(I,m) ( I##pp*(m)(0,0)+I##cp*(m)(1,0)+I##np*(m)(2,0)+I##ap*(m)(3,0) + \
-                            I##pc*(m)(0,1)+I##cc*(m)(1,1)+I##nc*(m)(2,1)+I##ac*(m)(3,1) + \
-                            I##pn*(m)(0,2)+I##cn*(m)(1,2)+I##nn*(m)(2,2)+I##an*(m)(3,2) + \
-                            I##pa*(m)(0,3)+I##ca*(m)(1,3)+I##na*(m)(2,3)+I##aa*(m)(3,3) )
-#define cimg_corr5x5(I,m) ( I##bb*(m)(0,0)+I##pb*(m)(1,0)+I##cb*(m)(2,0)+I##nb*(m)(3,0)+I##ab*(m)(4,0) + \
-                            I##bp*(m)(0,1)+I##pp*(m)(1,1)+I##cp*(m)(2,1)+I##np*(m)(3,1)+I##ap*(m)(4,1) + \
-                            I##bc*(m)(0,2)+I##pc*(m)(1,2)+I##cc*(m)(2,2)+I##nc*(m)(3,2)+I##ac*(m)(4,2) + \
-                            I##bn*(m)(0,3)+I##pn*(m)(1,3)+I##cn*(m)(2,3)+I##nn*(m)(3,3)+I##an*(m)(4,3) + \
-                            I##ba*(m)(0,4)+I##pa*(m)(1,4)+I##ca*(m)(2,4)+I##na*(m)(3,4)+I##aa*(m)(4,4) )
-#define cimg_corr2x2x2(I,m) ( I##ccc*(m)(0,0,0)+I##ncc*(m)(1,0,0)+I##cnc*(m)(0,1,0)+I##nnc*(m)(1,1,0) + \
-                              I##ccn*(m)(0,0,1)+I##ncn*(m)(1,0,1)+I##cnn*(m)(0,1,1)+I##nnn*(m)(1,1,1) )
-#define cimg_corr3x3x3(I,m) ( I##ppp*(m)(0,0,0)+I##cpp*(m)(1,0,0)+I##npp*(m)(2,0,0) + \
-                              I##pcp*(m)(0,1,0)+I##ccp*(m)(1,1,0)+I##ncp*(m)(2,1,0) + \
-                              I##pnp*(m)(0,2,0)+I##cnp*(m)(1,2,0)+I##nnp*(m)(2,2,0) + \
-                              I##ppc*(m)(0,0,1)+I##cpc*(m)(1,0,1)+I##npc*(m)(2,0,1) + \
-                              I##pcc*(m)(0,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(2,1,1) + \
-                              I##pnc*(m)(0,2,1)+I##cnc*(m)(1,2,1)+I##nnc*(m)(2,2,1) + \
-                              I##ppn*(m)(0,0,2)+I##cpn*(m)(1,0,2)+I##npn*(m)(2,0,2) + \
-                              I##pcn*(m)(0,1,2)+I##ccn*(m)(1,1,2)+I##ncn*(m)(2,1,2) + \
-                              I##pnn*(m)(0,2,2)+I##cnn*(m)(1,2,2)+I##nnn*(m)(2,2,2) )
-
-#define cimg_conv2x2(I,m) ( I##cc*(m)(1,1)+I##nc*(m)(0,1)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
-#define cimg_conv3x3(I,m) ( I##pp*(m)(2,2)+I##cp*(m)(1,2)+I##np*(m)(0,2) + \
-                            I##pc*(m)(2,1)+I##cc*(m)(1,1)+I##nc*(m)(0,1) + \
-                            I##pn*(m)(2,0)+I##cn*(m)(1,0)+I##nn*(m)(0,0) )
-#define cimg_conv4x4(I,m) ( I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
-                            I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
-                            I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
-                            I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
-#define cimg_conv5x5(I,m) ( I##bb*(m)(4,4)+I##pb*(m)(3,4)+I##cb*(m)(2,4)+I##nb*(m)(1,4)+I##ab*(m)(0,4) + \
-                            I##bp*(m)(4,3)+I##pp*(m)(3,3)+I##cp*(m)(2,3)+I##np*(m)(1,3)+I##ap*(m)(0,3) + \
-                            I##bc*(m)(4,2)+I##pc*(m)(3,2)+I##cc*(m)(2,2)+I##nc*(m)(1,2)+I##ac*(m)(0,2) + \
-                            I##bn*(m)(4,1)+I##pn*(m)(3,1)+I##cn*(m)(2,1)+I##nn*(m)(1,1)+I##an*(m)(0,1) + \
-                            I##ba*(m)(4,0)+I##pa*(m)(3,0)+I##ca*(m)(2,0)+I##na*(m)(1,0)+I##aa*(m)(0,0) )
-#define cimg_conv2x2x2(I,m) ( I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
-                              I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
-#define cimg_conv3x3x3(I,m) ( I##ppp*(m)(2,2,2)+I##cpp*(m)(1,2,2)+I##npp*(m)(0,2,2) + \
-                              I##pcp*(m)(2,1,2)+I##ccp*(m)(1,1,2)+I##ncp*(m)(0,1,2) + \
-                              I##pnp*(m)(2,0,2)+I##cnp*(m)(1,0,2)+I##nnp*(m)(0,0,2) + \
-                              I##ppc*(m)(2,2,1)+I##cpc*(m)(1,2,1)+I##npc*(m)(0,2,1) + \
-                              I##pcc*(m)(2,1,1)+I##ccc*(m)(1,1,1)+I##ncc*(m)(0,1,1) + \
-                              I##pnc*(m)(2,0,1)+I##cnc*(m)(1,0,1)+I##nnc*(m)(0,0,1) + \
-                              I##ppn*(m)(2,2,0)+I##cpn*(m)(1,2,0)+I##npn*(m)(0,2,0) + \
-                              I##pcn*(m)(2,1,0)+I##ccn*(m)(1,1,0)+I##ncn*(m)(0,1,0) + \
-                              I##pnn*(m)(2,0,0)+I##cnn*(m)(1,0,0)+I##nnn*(m)(0,0,0) )
-
-#define cimg_get2x2(img,x,y,z,v,I) I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
-    I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
-#define cimg_get3x3(img,x,y,z,v,I) I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), \
-    I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), \
-    I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v)
-#define cimg_get4x4(img,x,y,z,v,I)                                      \
-  I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
-    I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
-    I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
-    I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
-#define cimg_get5x5(img,x,y,z,v,I)                                      \
-  I##bb=(img)(_b##x,_b##y,z,v), I##pb=(img)(_p##x,_b##y,z,v), I##cb=(img)(x,_b##y,z,v), I##nb=(img)(_n##x,_b##y,z,v), I##ab=(img)(_a##x,_b##y,z,v), \
-    I##bp=(img)(_b##x,_p##y,z,v), I##pp=(img)(_p##x,_p##y,z,v), I##cp=(img)(x,_p##y,z,v), I##np=(img)(_n##x,_p##y,z,v), I##ap=(img)(_a##x,_p##y,z,v), \
-    I##bc=(img)(_b##x,    y,z,v), I##pc=(img)(_p##x,    y,z,v), I##cc=(img)(x,    y,z,v), I##nc=(img)(_n##x,    y,z,v), I##ac=(img)(_a##x,    y,z,v), \
-    I##bn=(img)(_b##x,_n##y,z,v), I##pn=(img)(_p##x,_n##y,z,v), I##cn=(img)(x,_n##y,z,v), I##nn=(img)(_n##x,_n##y,z,v), I##an=(img)(_a##x,_n##y,z,v), \
-    I##ba=(img)(_b##x,_a##y,z,v), I##pa=(img)(_p##x,_a##y,z,v), I##ca=(img)(x,_a##y,z,v), I##na=(img)(_n##x,_a##y,z,v), I##aa=(img)(_a##x,_a##y,z,v)
-#define cimg_get2x2x2(img,x,y,z,v,I)                                    \
-  I##ccc=(img)(x,y,    z,v), I##ncc=(img)(_n##x,y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
-    I##ccc=(img)(x,y,_n##z,v), I##ncc=(img)(_n##x,y,_n##z,v), I##cnc=(img)(x,_n##y,_n##z,v), I##nnc=(img)(_n##x,_n##y,_n##z,v)
-#define cimg_get3x3x3(img,x,y,z,v,I)                                    \
-  I##ppp=(img)(_p##x,_p##y,_p##z,v), I##cpp=(img)(x,_p##y,_p##z,v), I##npp=(img)(_n##x,_p##y,_p##z,v), \
-    I##pcp=(img)(_p##x,    y,_p##z,v), I##ccp=(img)(x,    y,_p##z,v), I##ncp=(img)(_n##x,    y,_p##z,v), \
-    I##pnp=(img)(_p##x,_n##y,_p##z,v), I##cnp=(img)(x,_n##y,_p##z,v), I##nnp=(img)(_n##x,_n##y,_p##z,v), \
-    I##ppc=(img)(_p##x,_p##y,    z,v), I##cpc=(img)(x,_p##y,    z,v), I##npc=(img)(_n##x,_p##y,    z,v), \
-    I##pcc=(img)(_p##x,    y,    z,v), I##ccc=(img)(x,    y,    z,v), I##ncc=(img)(_n##x,    y,    z,v), \
-    I##pnc=(img)(_p##x,_n##y,    z,v), I##cnc=(img)(x,_n##y,    z,v), I##nnc=(img)(_n##x,_n##y,    z,v), \
-    I##ppn=(img)(_p##x,_p##y,_n##z,v), I##cpn=(img)(x,_p##y,_n##z,v), I##npn=(img)(_n##x,_p##y,_n##z,v), \
-    I##pcn=(img)(_p##x,    y,_n##z,v), I##ccn=(img)(x,    y,_n##z,v), I##ncn=(img)(_n##x,    y,_n##z,v), \
-    I##pnn=(img)(_p##x,_n##y,_n##z,v), I##cnn=(img)(x,_n##y,_n##z,v), I##nnn=(img)(_n##x,_n##y,_n##z,v)
-
-#define cimg_3x3to5x5(I,u) u##bb=I##pp,u##cb=I##cp,u##ab=I##np,u##bc=I##pc,u##cc=I##cc,u##ac=I##nc,u##ba=I##pn,u##ca=I##cn,u##aa=I##nn, \
-    u##pb=0.5*(u##bb+u##cb),u##nb=0.5*(u##cb+u##ab),u##pc=0.5*(u##bc+u##cc),u##nc=0.5*(u##cc+u##ac),u##pa=0.5*(u##ba+u##ca),u##na=0.5*(u##ca+u##aa), \
-    u##bp=0.5*(u##bb+u##bc),u##bn=0.5*(u##bc+u##ba),u##cp=0.5*(u##cb+u##cc),u##cn=0.5*(u##cc+u##ca),u##ap=0.5*(u##ab+u##ac),u##an=0.5*(u##ac+u##aa), \
-    u##pp=0.5*(u##bp+u##cp),u##np=0.5*(u##cp+u##ap),u##pn=0.5*(u##bn+u##cn),u##nn=0.5*(u##cn+u##an)
-
-// Macros used to define special image loops (see module 'Using Image Loops' in the generated documentation).
-#define cimg_map(img,ptr,T_ptr)   for (T_ptr *ptr=(img).data+(img).size()-1; ptr>=(img).data; ptr--)
-#define cimgl_map(list,l)         for (unsigned int l=0; l<(list).size; l++)
-#define cimg_mapoff(img,off)      for (unsigned int off=0; off<(img).size(); off++)
-#define cimg_mapX(img,x)          for (int x=0; x<(int)((img).width); x++)
-#define cimg_mapY(img,y)          for (int y=0; y<(int)((img).height);y++)
-#define cimg_mapZ(img,z)          for (int z=0; z<(int)((img).depth); z++)
-#define cimg_mapV(img,v)          for (int v=0; v<(int)((img).dim);   v++)
-#define cimg_mapXY(img,x,y)       cimg_mapY(img,y) cimg_mapX(img,x)
-#define cimg_mapXZ(img,x,z)       cimg_mapZ(img,z) cimg_mapX(img,x)
-#define cimg_mapYZ(img,y,z)       cimg_mapZ(img,z) cimg_mapY(img,y)
-#define cimg_mapXV(img,x,v)       cimg_mapV(img,v) cimg_mapX(img,x)
-#define cimg_mapYV(img,y,v)       cimg_mapV(img,v) cimg_mapY(img,y)
-#define cimg_mapZV(img,z,v)       cimg_mapV(img,v) cimg_mapZ(img,z)
-#define cimg_mapXYZ(img,x,y,z)    cimg_mapZ(img,z) cimg_mapXY(img,x,y)
-#define cimg_mapXYV(img,x,y,v)    cimg_mapV(img,v) cimg_mapXY(img,x,y)
-#define cimg_mapXZV(img,x,z,v)    cimg_mapV(img,v) cimg_mapXZ(img,x,z)
-#define cimg_mapYZV(img,y,z,v)    cimg_mapV(img,v) cimg_mapYZ(img,y,z)
-#define cimg_mapXYZV(img,x,y,z,v) cimg_mapV(img,v) cimg_mapXYZ(img,x,y,z)
-#define cimg_imapX(img,x,n)       for (int x=n; x<(int)((img).width-n); x++)
-#define cimg_imapY(img,y,n)       for (int y=n; y<(int)((img).height-n); y++)
-#define cimg_imapZ(img,z,n)       for (int z=n; z<(int)((img).depth-n); z++)
-#define cimg_imapV(img,v,n)       for (int v=n; v<(int)((img).dim-n); v++)
-#define cimg_imapXY(img,x,y,n)    cimg_imapY(img,y,n) cimg_imapX(img,x,n)
-#define cimg_imapXYZ(img,x,y,z,n) cimg_imapZ(img,z,n) cimg_imapXY(img,x,y,n)
-#define cimg_bmapX(img,x,n)       for (int x=0; x<(int)((img).width);  x==(n)-1?(x=(img).width-(n)): x++)
-#define cimg_bmapY(img,y,n)       for (int y=0; y<(int)((img).height); y==(n)-1?(x=(img).height-(n)):y++)
-#define cimg_bmapZ(img,z,n)       for (int z=0; z<(int)((img).depth);  z==(n)-1?(x=(img).depth-(n)): z++)
-#define cimg_bmapV(img,v,n)       for (int v=0; v<(int)((img).dim);    v==(n)-1?(x=(img).dim-(n)):   v++)
-#define cimg_bmapXY(img,x,y,n)    cimg_mapY(img,y) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n))?x++: \
-                                                          ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
-#define cimg_bmapXYZ(img,x,y,z,n) cimg_mapYZ(img,y,z) for (int x=0; x<(int)((img).width); (y<(n) || y>=(int)((img).height)-(n) || z<(n) || z>=(int)((img).depth)-(n))?x++: \
-                                                             ((x<(n)-1 || x>=(int)((img).width)-(n))?x++:(x=(img).width-(n))))
-#define cimg_2mapX(img,x)         for (int x=0,_n##x=1; _n##x<(int)((img).width)   || x==--_n##x; x++, _n##x++)
-#define cimg_2mapY(img,y)         for (int y=0,_n##y=1; _n##y<(int)((img).height)  || y==--_n##y; y++, _n##y++)
-#define cimg_2mapZ(img,z)         for (int z=0,_n##z=1; _n##z<(int)((img).depth)   || z==--_n##z; z++, _n##z++)
-#define cimg_2mapXY(img,x,y)      cimg_2mapY(img,y) cimg_2mapX(img,x)
-#define cimg_2mapXZ(img,x,z)      cimg_2mapZ(img,z) cimg_2mapX(img,x)
-#define cimg_2mapYZ(img,y,z)      cimg_2mapZ(img,z) cimg_2mapY(img,y)
-#define cimg_2mapXYZ(img,x,y,z)   cimg_2mapZ(img,z) cimg_2mapXY(img,x,y)
-#define cimg_3mapX(img,x)         for (int x=0,_p##x=0,_n##x=1; _n##x<(int)((img).width)  || x==--_n##x;  _p##x=x++,_n##x++)
-#define cimg_3mapY(img,y)         for (int y=0,_p##y=0,_n##y=1; _n##y<(int)((img).height) || y==--_n##y;  _p##y=y++,_n##y++)
-#define cimg_3mapZ(img,z)         for (int z=0,_p##z=0,_n##z=1; _n##z<(int)((img).depth)  || z==--_n##z;  _p##z=z++,_n##z++)
-#define cimg_3mapXY(img,x,y)      cimg_3mapY(img,y) cimg_3mapX(img,x)
-#define cimg_3mapXZ(img,x,z)      cimg_3mapZ(img,z) cimg_3mapX(img,x)
-#define cimg_3mapYZ(img,y,z)      cimg_3mapZ(img,z) cimg_3mapY(img,y)
-#define cimg_3mapXYZ(img,x,y,z)   cimg_3mapZ(img,z) cimg_3mapXY(img,x,y)
-#define cimg_4mapX(img,x)         for (int _p##x=0,x=0,_n##x=1,_a##x=2; \
-                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
-                                       _p##x=x++,_n##x++,_a##x++)
-#define cimg_4mapY(img,y)         for (int _p##y=0,y=0,_n##y=1,_a##y=2; \
-                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
-                                       _p##y=y++,_n##y++,_a##y++)
-#define cimg_4mapZ(img,z)         for (int _p##z=0,z=0,_n##z=1,_a##z=2; \
-                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
-                                       _p##z=z++,_n##z++,_a##z++)
-#define cimg_4mapXY(img,x,y)      cimg_4mapY(img,y) cimg_4mapX(img,x)
-#define cimg_4mapXZ(img,x,z)      cimg_4mapZ(img,z) cimg_4mapX(img,x)
-#define cimg_4mapYZ(img,y,z)      cimg_4mapZ(img,z) cimg_4mapY(img,y)
-#define cimg_4mapXYZ(img,x,y,z)   cimg_4mapZ(img,z) cimg_4mapXY(img,x,y)
-#define cimg_5mapX(img,x)         for (int _b##x=0,_p##x=0,x=0,_n##x=1,_a##x=2; \
-                                       _a##x<(int)((img).width)  || _n##x==--_a##x || x==(_a##x=--_n##x); \
-                                       _b##x=_p##x,_p##x=x++,_n##x++,_a##x++)
-#define cimg_5mapY(img,y)         for (int _b##y=0,_p##y=0,y=0,_n##y=1,_a##y=2; \
-                                       _a##y<(int)((img).height) || _n##y==--_a##y || y==(_a##y=--_n##y); \
-                                       _b##y=_p##y,_p##y=y++,_n##y++,_a##y++)
-#define cimg_5mapZ(img,z)         for (int _b##z=0,_p##z=0,z=0,_n##z=1,_a##z=2; \
-                                       _a##z<(int)((img).depth)  || _n##z==--_a##z || z==(_a##z=--_n##z); \
-                                       _b##z=_p##z,_p##z=z++,_n##z++,_a##z++)
-#define cimg_5mapXY(img,x,y)      cimg_5mapY(img,y) cimg_5mapX(img,x)
-#define cimg_5mapXZ(img,x,z)      cimg_5mapZ(img,z) cimg_5mapX(img,x)
-#define cimg_5mapYZ(img,y,z)      cimg_5mapZ(img,z) cimg_5mapY(img,y)
-#define cimg_5mapXYZ(img,x,y,z)   cimg_5mapZ(img,z) cimg_5mapXY(img,x,y)
-
-#define cimg_map2x2(img,x,y,z,v,I) cimg_2mapY(img,y)                    \
-       for (int _n##x=1, x=((int)(I##cc=(img)(0,  y,z,v),               \
-                                  I##cn=(img)(0,_n##y,z,v)),0);         \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##nc=(img)(_n##x,    y,z,v), \
-                                          I##nn=(img)(_n##x,_n##y,z,v), \
-                                          1)) || x==--_n##x;            \
-            I##cc=I##nc, I##cn=I##nn,                                   \
-              x++,_n##x++ )
-
-#define cimg_map3x3(img,x,y,z,v,I) cimg_3mapY(img,y)                    \
-       for (int _n##x=1, _p##x=(int)(I##cp=I##pp=(img)(0,_p##y,z,v),    \
-                                     I##cc=I##pc=(img)(0,  y,z,v),      \
-                                     I##cn=I##pn=(img)(0,_n##y,z,v)     \
-                                     ), x=_p##x=0;                      \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##np=(img)(_n##x,_p##y,z,v), \
-                                          I##nc=(img)(_n##x,    y,z,v), \
-                                          I##nn=(img)(_n##x,_n##y,z,v), \
-                                          1)) || x==--_n##x;            \
-            I##pp=I##cp, I##pc=I##cc, I##pn=I##cn,                      \
-              I##cp=I##np, I##cc=I##nc, I##cn=I##nn,                    \
-              _p##x=x++,_n##x++ )
-
-#define cimg_map4x4(img,x,y,z,v,I) cimg_4mapY(img,y)                    \
-       for (int _a##x=2, _n##x=1, x=((int)(I##cp=I##pp=(img)(0,_p##y,z,v), \
-                                           I##cc=I##pc=(img)(0,    y,z,v), \
-                                           I##cn=I##pn=(img)(0,_n##y,z,v), \
-                                           I##ca=I##pa=(img)(0,_a##y,z,v), \
-                                           I##np=(img)(_n##x,_p##y,z,v), \
-                                           I##nc=(img)(_n##x,    y,z,v), \
-                                           I##nn=(img)(_n##x,_n##y,z,v), \
-                                           I##na=(img)(_n##x,_a##y,z,v)),0), \
-              _p##x=0;                                                  \
-            (_a##x<(int)((img).width) && (                              \
-                                          I##ap=(img)(_a##x,_p##y,z,v), \
-                                          I##ac=(img)(_a##x,    y,z,v), \
-                                          I##an=(img)(_a##x,_n##y,z,v), \
-                                          I##aa=(img)(_a##x,_a##y,z,v), \
-                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
-            I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca,         \
-              I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na,       \
-              I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa,       \
-              _p##x=x++, _n##x++, _a##x++ )
-
-#define cimg_map5x5(img,x,y,z,v,I) cimg_5mapY(img,y)                    \
-       for (int _a##x=2, _n##x=1, _b##x=(int)(I##cb=I##pb=I##bb=(img)(0,_b##y,z,v), \
-                                              I##cp=I##pp=I##bp=(img)(0,_p##y,z,v), \
-                                              I##cc=I##pc=I##bc=(img)(0,    y,z,v), \
-                                              I##cn=I##pn=I##bn=(img)(0,_n##y,z,v), \
-                                              I##ca=I##pa=I##ba=(img)(0,_a##y,z,v), \
-                                              I##nb=(img)(_n##x,_b##y,z,v), \
-                                              I##np=(img)(_n##x,_p##y,z,v), \
-                                              I##nc=(img)(_n##x,   y,z,v), \
-                                              I##nn=(img)(_n##x,_n##y,z,v), \
-                                              I##na=(img)(_n##x,_a##y,z,v)), \
-              x=0, _p##x=_b##x=0;                                       \
-            (_a##x<(int)((img).width) && (                              \
-                                          I##ab=(img)(_a##x,_b##y,z,v), \
-                                          I##ap=(img)(_a##x,_p##y,z,v), \
-                                          I##ac=(img)(_a##x,    y,z,v), \
-                                          I##an=(img)(_a##x,_n##y,z,v), \
-                                          I##aa=(img)(_a##x,_a##y,z,v), \
-                                          1)) || _n##x==--_a##x || x==(_a##x=--_n##x); \
-            I##bb=I##pb, I##bp=I##pp, I##bc=I##pc, I##bn=I##pn, I##ba=I##pa, \
-              I##pb=I##cb, I##pp=I##cp, I##pc=I##cc, I##pn=I##cn, I##pa=I##ca, \
-              I##cb=I##nb, I##cp=I##np, I##cc=I##nc, I##cn=I##nn, I##ca=I##na, \
-              I##nb=I##ab, I##np=I##ap, I##nc=I##ac, I##nn=I##an, I##na=I##aa, \
-              _b##x=_p##x, _p##x=x++, _n##x++, _a##x++ )
-
-#define cimg_map2x2x2(img,x,y,z,v,I) cimg_2mapYZ(img,y,z)               \
-       for (int _n##x=1, x=((int)(I##ccc=(img)(0,    y,    z,v),        \
-                                  I##cnc=(img)(0,_n##y,    z,v),        \
-                                  I##ccn=(img)(0,    y,_n##z,v),        \
-                                  I##cnn=(img)(0,_n##y,_n##z,v)),0);    \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##ncc=(img)(_n##x,    y,    z,v), \
-                                          I##nnc=(img)(_n##x,_n##y,    z,v), \
-                                          I##ncn=(img)(_n##x,    y,_n##z,v), \
-                                          I##nnn=(img)(_n##x,_n##y,_n##z,v), \
-                                          1)) || x==--_n##x;            \
-            I##ccc=I##ncc, I##cnc=I##nnc,                               \
-              I##ccn=I##ncn, I##cnn=I##nnn,                             \
-              x++, _n##x++ )
-
-#define cimg_map3x3x3(img,x,y,z,v,I) cimg_3mapYZ(img,y,z)               \
-       for (int _n##x=1, _p##x=(int)(I##cpp=I##ppp=(img)(0,_p##y,_p##z,v), \
-                                     I##ccp=I##pcp=(img)(0,    y,_p##z,v), \
-                                     I##cnp=I##pnp=(img)(0,_n##y,_p##z,v), \
-                                     I##cpc=I##ppc=(img)(0,_p##y,    z,v), \
-                                     I##ccc=I##pcc=(img)(0,    y,    z,v), \
-                                     I##cnc=I##pnc=(img)(0,_n##y,    z,v), \
-                                     I##cpn=I##ppn=(img)(0,_p##y,_n##z,v), \
-                                     I##ccn=I##pcn=(img)(0,    y,_n##z,v), \
-                                     I##cnn=I##pnn=(img)(0,_n##y,_n##z,v)),\
-              x=_p##x=0;                                                \
-            (_n##x<(int)((img).width) && (                              \
-                                          I##npp=(img)(_n##x,_p##y,_p##z,v), \
-                                          I##ncp=(img)(_n##x,    y,_p##z,v), \
-                                          I##nnp=(img)(_n##x,_n##y,_p##z,v), \
-                                          I##npc=(img)(_n##x,_p##y,    z,v), \
-                                          I##ncc=(img)(_n##x,    y,    z,v), \
-                                          I##nnc=(img)(_n##x,_n##y,    z,v), \
-                                          I##npn=(img)(_n##x,_p##y,_n##z,v), \
-                                          I##ncn=(img)(_n##x,    y,_n##z,v), \
-                                          I##nnn=(img)(_n##x,_n##y,_n##z,v), \
-                                          1)) || x==--_n##x;            \
-            I##ppp=I##cpp, I##pcp=I##ccp, I##pnp=I##cnp,                \
-              I##cpp=I##npp, I##ccp=I##ncp, I##cnp=I##nnp,              \
-              I##ppc=I##cpc, I##pcc=I##ccc, I##pnc=I##cnc,              \
-              I##cpc=I##npc, I##ccc=I##ncc, I##cnc=I##nnc,              \
-              I##ppn=I##cpn, I##pcn=I##ccn, I##pnn=I##cnn,              \
-              I##cpn=I##npn, I##ccn=I##ncn, I##cnn=I##nnn,              \
-              _p##x=x++, _n##x++ )
-
-/*-------------------------------------------------
-  -------------------------------------------------
-  
-
-
-    Definition of the cimg_library:: namespace
-  
- 
-  -------------------------------------------------
-  -------------------------------------------------*/
-
-//! The <tt>\ref cimg_library::</tt> namespace encompasses all classes and functions of the CImg library.
-/**
-   This namespace is defined to avoid class names collisions that could happen
-   with the include of other C++ header files. Anyway, it shouldn't happen
-   very often and you may start most of your programs with
-   \code
-   #include "CImg.h"
-   using namespace cimg_library;
-   \endcode
-   to simplify the declaration of CImg class variables afterward.
-**/
-namespace cimg_library {
-  struct CImgStats;
-  struct CImgDisplay;
-  struct CImgException;
-  template<typename T=float> struct CImg;
-  template<typename T=float> struct CImgl;
-  template<typename T=float> struct CImgROI;
-   
-  /*----------------------------------------------------
-    
-  
-  
-  Definition of the CImgException structures
-  
-  
-  
-  -------------------------------------------------*/
-  
-#if cimg_debug>=1
-#if cimg_display_type!=2
-#define cimg_exception_print(str) std::fprintf(stderr,"<CImg Error> %s",str);
-#else
-#define cimg_exception_print(str) MessageBox(NULL,(LPCTSTR)str,"<CImg Error>",MB_OK);
-#endif
-#else
-#define cimg_exception_print(str)
-#endif
-#define cimg_exception_err(etype)                                 \
-  char tmp[1024];                                                 \
-  va_list ap;                                                     \
-  va_start(ap,format);                                            \
-  std::vsprintf(message,format,ap);                               \
-  va_end(ap);                                                     \
-  std::sprintf(tmp,"==> %s \n\nGeneral : %s\n\n", message,etype); \
-  cimg_exception_print(tmp)
-  
-  //! The \ref CImgException class is used to throw general exceptions when an error occurs in a library call.
-  /** 
-      The \ref CImgException class is the base class of all CImg exceptions.
-      Exceptions are thrown by the CImg Library when an error occurs during the execution of a CImg function.
-      The CImgException is seldom thrown itself, children classes (that specify the type of error)
-      are generally used instead.
-      It may be thrown anyway for non-specialized exception types.
-
-      \see CImgInstanceException, CImgArgumentException, CImgIOException and CImgDisplayException.
-
-      By default, when an error occurs, the CImg Library displays an error message on the standart error output \e stderr
-      (on Unix), or opens a pop-up window displaying the error message (on Windows).
-      Then, it throws an instance of an exception class, generally leading the program to stop (this is the
-      default behavior of the C++ exception mechanism).
-      You can always bypass this behavior by handling the exceptions by yourself (using a code block <tt>try { ... } catch() { ... }</tt>).
-      Then, if you don't want the CImg Library to display error messages, you can define the environment variable
-      <tt>cimg_debug</tt> to 0 before including the header file <tt>CImg.h</tt> (see \ref cimg_environment).
-      
-      The <tt>CImgException</tt> class owns a member variable <tt>char* message</tt> that contains the exception message
-      describing precisely the error that occured.
-
-      The example above shows how to manually handle CImg Library errors properly :
-      \code
-      #define cimg_debug 0    // Disable error message display by CImg.
-      #define "CImg.h"
-      int main() {  
-        try {
-          ...; // Here, do what you want.
-        }
-        catch (CImgException &e) {
-          std::fprintf(stderr,"CImg Library Error : %s",e.message);  // Display error message
-          ...                                                        // Do what you want to save the ship !
-        }
-      }
-      \endcode      
-  **/
-  struct CImgException {
-    char message[1024]; //!< Error message
-    CImgException() { message[0]='\0'; }
-    CImgException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgException' throw,"
-			 "corresponding to a general exception problem."); 
-    }
-  };
-
-  //! The \ref CImgInstanceException class is used to throw an exception related
-  //! to a non suitable instance encountered in a library function call.  
-  /**
-     This class will be thrown when trying to call a class function from an
-     instance which is \e empty, or \e badly \e defined.
-     Typically, this exception occurs when using empty images :
-     \code
-     CImg<float> img; // define an empty image
-     img.blur(10);    // trying to blur an empty image will generate a CImgInstanceException.
-     \endcode
-     
-     \see CImgException, CImgArgumentException, CImgIOException and CImgDisplayException.
-  **/
-  struct CImgInstanceException : CImgException { 
-    CImgInstanceException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgInstanceException' throw.\n"
-			 "The instance passed through the function above has a bad structure"
-			 "(perhaps an empty image, list or display object ?)");
-    }};
-
-  //! The \ref CImgArgumentException class is used to throw an exception related
-  //! to invalid arguments encountered in a library function call.
-  /**
-     This class will be thrown when one passes one or several invalid arguments to
-     a library function. This may happen for instance in the following case :
-     \code
-     CImg<float> img(100,100); // define a 100x100 scalar image with float pixels
-     img.get_channel(1);       // trying to retrieve the vector channel v=1, will generate a CImgArgumentException.
-     \endcode
-     As the image <tt>img</tt> is scalar, it has only one vector channel (<tt>img.dim=1</tt>), and one cannot
-     retrieve the channel 1, (only the channel 0).
-     \see CImgException, CImgInstanceException, CImgIOException and CImgDisplayException.
-  **/
-  struct CImgArgumentException : CImgException { 
-    CImgArgumentException(const char *format,...) { 
-      cimg_exception_err("This error has been generated by a 'CImgArgumentException' throw.\n"
-			 "At least one argument passed to the function above has been considered as not valid.");
-    }};
-
-  //! The \ref CImgIOException class is used to throw an exception related 
-  //! to Input/Output file problems encountered in a library function call.
-  /**
-     This class will be thrown when one Input/Output problem has been encountered
-     during the execution of a library function. This may particularly happen when using <tt>load()</tt> and <tt>save()</tt>
-     functions, with invalid files :
-     \code
-     CImg<float> img("not_here.jpg");
-     \endcode
-     This code will throw a \c CImgIOException instance if the file <tt>not_here.jpg</tt> is not in the current directory.
-     \see CImgException, CImgInstanceException, CImgArgumentException and CImgDisplayException.
-  **/
-  struct CImgIOException : CImgException { 
-    CImgIOException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgIOException' throw.\n"
-			 "When trying to load or save a file, the function above has encountered a problem.");
-    }};
-
-  //! The CImgDisplayException class is used to throw an exception related to display problems
-  //! encountered in a library function call.
-  /**
-     This class will be thrown when a library function encounters a problem
-     when trying to open or close a display window. This shouldn't happen very much if your display is 
-     detected properly. This happens for instance when trying to open a display window on a 8bits screen
-     depth, under Unix/X11.
-
-     \see CImgException, CImgInstanceException, CImgArgumentException and CImgIOException.
-  **/
-  struct CImgDisplayException : CImgException {
-    CImgDisplayException(const char *format,...) {
-      cimg_exception_err("This error has been generated by a 'CImgDisplayException' throw.\n"
-			 "When trying to operate on a CImgDisplay instance, the function above encountered a problem."); 
-    }};
-  
-
-  /*-------------------------------------------------------------------------
-
-    Add LAPACK support to the library.
-  
-    Define the macro 'cimg_lapack' before including 'CImg.h' 
-    will activate the support of LAPACK. You'll have then to link
-    your code with the Lapack library to get it working.
-  
-    -----------------------------------------------------------------------*/
-#ifdef cimg_lapack
-  extern "C" {
-    extern void dgeev_(char*,char*, int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*);
-    extern void dsyev_(char*,char*,int*,double*,int*,double*,double*,int*,int*);
-    extern void dgetrf_(int*,int*,double*,int*,int*,int*);
-    extern void dgetri_(int*,double*,int*,int*,double*,int*,int*);
-  }
-#else
-  inline void cimg_nolapack() { 
-    throw CImgException("a LAPACK call : A LAPACK function has been required, but the LAPACK library"
-			"hasn't been linked.\nPlease define the compilation flag '#define cimg_lapack'"
-			"before including 'CImg.h' and link your code with LAPACK.");
-  }
-  inline void dgeev_ (char*,char*, int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*) { cimg_nolapack(); }
-  inline void dsyev_ (char*, char*, int*, double*, int*, double*, double*, int*, int*) { cimg_nolapack(); }
-  inline void dgetrf_(int*,int*,double*,int*,int*,int*) { cimg_nolapack(); }
-  inline void dgetri_(int*,double*,int*,int*,double*,int*,int*) { cimg_nolapack(); }
-#endif
-  
-
-  /*----------------------------------------
-    
-  
-  
-    Definition of the namespace 'cimg'
-  
-  
-  
-  --------------------------------------*/
-  
-  //! The <tt>\ref cimg::</tt> namespace encompasses \e low-level functions and variables of the CImg Library.
-  /**
-     Most of the functions and variables within this namespace are used by the library for low-level purposes.
-     Nevertheless, documented variables and functions below may be used by the user in its own source code.
-     \warning Never write <tt>"using namespace cimg_library::cimg;"</tt> in your source, since a lot of functions of the
-     \ref cimg:: namespace have the same name than standart C functions defined in the global namespace <tt>::</tt>.
-     
-     \see CImg, CImgl, CImgDisplay, CImgStats and CImgException.
-  **/
-  namespace cimg {
-
-    // Define internal library variables.
-    const unsigned int lblock=1024;
-#if cimg_display_type==1
-    static pthread_mutex_t*      X11_mutex = NULL;
-    static pthread_t*            X11_event_thread = NULL;
-    static CImgDisplay*          X11_wins[1024];
-    static Display*              X11_display = NULL;
-    static volatile unsigned int X11_nb_wins = 0;
-    static volatile bool         X11_thread_finished = false;
-    static unsigned int          X11_nb_bits = 0;
-    static GC*                   X11_gc = NULL;
-    static bool                  X11_colors_endian = false;
-#endif
-#ifdef cimg_color_terminal
-    const char t_normal[9]  = {0x1b,'[','0',';','0',';','0','m','\0'};
-    const char t_red[11]    = {0x1b,'[','4',';','3','1',';','5','9','m','\0'};
-    const char t_bold[5]    = {0x1b,'[','1','m','\0'};
-    const char t_purple[11] = {0x1b,'[','0',';','3','5',';','5','9','m','\0'};
-#else
-    const char t_normal[1]  = {'\0'};
-    static const char *t_red = t_normal, *t_bold = t_normal, *t_purple = t_normal;
-#endif
-    
-#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3
-    // Keycodes for X11-based graphical systems
-    const unsigned int keyESC        = XK_Escape;
-    const unsigned int keyF1         = XK_F1;
-    const unsigned int keyF2         = XK_F2;
-    const unsigned int keyF3         = XK_F3;
-    const unsigned int keyF4         = XK_F4;
-    const unsigned int keyF5         = XK_F5;
-    const unsigned int keyF6         = XK_F6;
-    const unsigned int keyF7         = XK_F7;
-    const unsigned int keyF8         = XK_F8;
-    const unsigned int keyF9         = XK_F9;
-    const unsigned int keyF10        = XK_F10;
-    const unsigned int keyF11        = XK_F11;
-    const unsigned int keyF12        = XK_F12;
-    const unsigned int keyPAUSE      = XK_Pause;
-    const unsigned int key1          = XK_1;
-    const unsigned int key2          = XK_2;
-    const unsigned int key3          = XK_3;
-    const unsigned int key4          = XK_4;
-    const unsigned int key5          = XK_5;
-    const unsigned int key6          = XK_6;
-    const unsigned int key7          = XK_7;
-    const unsigned int key8          = XK_8;
-    const unsigned int key9          = XK_9;
-    const unsigned int key0          = XK_0;
-    const unsigned int keyBACKSPACE  = XK_BackSpace;
-    const unsigned int keyINSERT     = XK_Insert;
-    const unsigned int keyHOME       = XK_Home;
-    const unsigned int keyPAGEUP     = XK_Page_Up;
-    const unsigned int keyTAB        = XK_Tab;
-    const unsigned int keyQ          = XK_q;
-    const unsigned int keyW          = XK_w;
-    const unsigned int keyE          = XK_e;
-    const unsigned int keyR          = XK_r;
-    const unsigned int keyT          = XK_t;
-    const unsigned int keyY          = XK_y;
-    const unsigned int keyU          = XK_u;
-    const unsigned int keyI          = XK_i;
-    const unsigned int keyO          = XK_o;
-    const unsigned int keyP          = XK_p;
-    const unsigned int keyDELETE     = XK_Delete;
-    const unsigned int keyEND        = XK_End;
-    const unsigned int keyPAGEDOWN   = XK_Page_Down;
-    const unsigned int keyCAPSLOCK   = XK_Caps_Lock;
-    const unsigned int keyA          = XK_a;
-    const unsigned int keyS          = XK_s;
-    const unsigned int keyD          = XK_d;
-    const unsigned int keyF          = XK_f;
-    const unsigned int keyG          = XK_g;
-    const unsigned int keyH          = XK_h;
-    const unsigned int keyJ          = XK_j;
-    const unsigned int keyK          = XK_k;
-    const unsigned int keyL          = XK_l;
-    const unsigned int keyENTER      = XK_Return;
-    const unsigned int keySHIFTLEFT  = XK_Shift_L;
-    const unsigned int keyZ          = XK_z;
-    const unsigned int keyX          = XK_x;
-    const unsigned int keyC          = XK_c;
-    const unsigned int keyV          = XK_v;
-    const unsigned int keyB          = XK_b;
-    const unsigned int keyN          = XK_n;
-    const unsigned int keyM          = XK_m;
-    const unsigned int keySHIFTRIGHT = XK_Shift_R;
-    const unsigned int keyARROWUP    = XK_Up;
-    const unsigned int keyCTRLLEFT   = XK_Control_L;
-    const unsigned int keyAPPLEFT    = XK_Super_L;
-    const unsigned int keySPACE      = XK_space;
-    const unsigned int keyALTGR      = XK_Alt_R;
-    const unsigned int keyAPPRIGHT   = XK_Super_R;
-    const unsigned int keyMENU       = XK_Menu;
-    const unsigned int keyCTRLRIGHT  = XK_Control_R;
-    const unsigned int keyARROWLEFT  = XK_Left;
-    const unsigned int keyARROWDOWN  = XK_Down;
-    const unsigned int keyARROWRIGHT = XK_Right;  
-#else
-    // Keycodes for Windows-OS
-    //@{
-    //!\name Keycodes.
-    /** 
-	Keycodes are used to detect keyboard events occuring on display windows \c CImgDisplay.
-	The field \c key of the \c CImgDisplay structure is updated at real-time with the corresponding keycode
-	of the pressed key (or 0 if no keys have been pressed). The keycodes values are given by the variables
-	whose names are of the form <tt>cimg::key*</tt>. Above is the keycode for the 'ESC' key, but
-	almost all keycodes are thus defined.
-        Using CImg-defined keycodes ensures a better portability of your program for other architectures.
-    **/
-    const unsigned int keyESC        = 27;
-    const unsigned int keyF1         = 112;
-    const unsigned int keyF2         = 113;
-    const unsigned int keyF3         = 114;
-    const unsigned int keyF4         = 115;
-    const unsigned int keyF5         = 116;
-    const unsigned int keyF6         = 117;
-    const unsigned int keyF7         = 118;
-    const unsigned int keyF8         = 119;
-    const unsigned int keyF9         = 120;
-    const unsigned int keyF10        = 121;
-    const unsigned int keyF11        = 122;
-    const unsigned int keyF12        = 123;
-    const unsigned int keyPAUSE      = 19;
-    const unsigned int key1          = 49;
-    const unsigned int key2          = 50;
-    const unsigned int key3          = 51;
-    const unsigned int key4          = 52;
-    const unsigned int key5          = 53;
-    const unsigned int key6          = 54;
-    const unsigned int key7          = 55;
-    const unsigned int key8          = 56;
-    const unsigned int key9          = 57;
-    const unsigned int key0          = 48;
-    const unsigned int keyBACKSPACE  = 8;
-    const unsigned int keyINSERT     = 45;
-    const unsigned int keyHOME       = 36;
-    const unsigned int keyPAGEUP     = 33;
-    const unsigned int keyTAB        = 9;
-    const unsigned int keyQ          = 81;
-    const unsigned int keyW          = 87;
-    const unsigned int keyE          = 69;
-    const unsigned int keyR          = 82;
-    const unsigned int keyT          = 84;
-    const unsigned int keyY          = 89;
-    const unsigned int keyU          = 85;
-    const unsigned int keyI          = 73;
-    const unsigned int keyO          = 79;
-    const unsigned int keyP          = 80;
-    const unsigned int keyDELETE     = 8;
-    const unsigned int keyEND        = 35;
-    const unsigned int keyPAGEDOWN   = 34;
-    const unsigned int keyCAPSLOCK   = 20;
-    const unsigned int keyA          = 65;
-    const unsigned int keyS          = 83;
-    const unsigned int keyD          = 68;
-    const unsigned int keyF          = 70;
-    const unsigned int keyG          = 71;
-    const unsigned int keyH          = 72;
-    const unsigned int keyJ          = 74;
-    const unsigned int keyK          = 75;
-    const unsigned int keyL          = 76;
-    const unsigned int keyENTER      = 13;
-    const unsigned int keySHIFTLEFT  = 16;
-    const unsigned int keyZ          = 90;
-    const unsigned int keyX          = 88;
-    const unsigned int keyC          = 67;
-    const unsigned int keyV          = 86;
-    const unsigned int keyB          = 66;
-    const unsigned int keyN          = 78;
-    const unsigned int keyM          = 77;
-    const unsigned int keySHIFTRIGHT = 16;
-    const unsigned int keyARROWUP    = 38;
-    const unsigned int keyCTRLLEFT   = 17;
-    const unsigned int keyAPPLEFT    = 91;
-    const unsigned int keySPACE      = 32;
-    const unsigned int keyALTGR      = 17;
-    const unsigned int keyAPPRIGHT   = 92;
-    const unsigned int keyMENU       = 93;
-    const unsigned int keyCTRLRIGHT  = 17;
-    const unsigned int keyARROWLEFT  = 37;
-    const unsigned int keyARROWDOWN  = 40;
-    const unsigned int keyARROWRIGHT = 39;
-#endif
-    //@}
-
-#ifdef PI
-#undef PI
-#endif
-    const double PI = 3.14159265358979323846;   //!< Definition of the mathematical constant PI
-
-    // Definition of a 7x11x1x3 font, used to return a default font for drawing text.
-    const unsigned int font7x11[7*11*256/8] = 
-      {0x00000000,
-       0x00000000,0x00000000,0x00000002,0x04081020,0x00800000,0x24489000,0x00000000,0x000000a1,
-       0x4f8a7e50,0xa0000002,0x0f287030,0x50a78200,0x00008695,0x454552c2,0x00000002,0x0a143193,
-       0x19f00000,0x04081000,0x00000000,0x00001841,0x02040810,0x20203006,0x02020408,0x1020410c,
-       0x000010d8,0xc1400000,0x00000000,0x01021f08,0x10200000,0x00000000,0x00018302,0x08000000,
-       0x0007c000,0x00000000,0x00000000,0x0060c000,0x0000820c,0x1040820c,0x10400000,0xe2244891,
-       0x22380000,0x00061408,0x102043e0,0x00000070,0x10208208,0x1e000000,0x03c0810c,0x0408e000,
-       0x0000020c,0x2891f040,0x80000000,0xf1020701,0x02380000,0x0001c410,0x2c6488e0,0x0000003e,
-       0x08104102,0x08000000,0x00e22487,0x11223800,0x00000711,0x223c0823,0x80000000,0x0060c000,
-       0x060c0000,0x00000306,0x00003060,0x41000000,0x0218c180,0xc0400000,0x000007f0,0x1fc00000,
-       0x00000010,0x180c18c2,0x00000000,0x3c440820,0x80020000,0x0000f229,0xd4afa038,0x00000002,
-       0x0a1444f9,0x14100000,0x00788913,0xc4489e00,0x000001e4,0x10204040,0x78000000,0x1e224489,
-       0x12278000,0x0000f902,0x0788103e,0x00000007,0xc8103c40,0x81000000,0x001e4102,0x34244780,
-       0x00000112,0x244f9122,0x44000000,0x0f840810,0x2043e000,0x00003810,0x2040811c,0x00000002,
-       0x248a1828,0x48880000,0x00102040,0x810207c0,0x0000019b,0x36ab56a9,0x42000000,0x044c9d2a,
-       0x4c991000,0x00003c85,0x0a14284f,0x00000001,0xe2244f10,0x20400000,0x000f2142,0x850a13c0,
-       0xc0c000f1,0x12278911,0x21000000,0x01e4080e,0x0204f000,0x00003f88,0x10204081,0x00000000,
-       0x89122448,0x911c0000,0x00082891,0x22285040,0x00000041,0x9325ab64,0xc8800000,0x020a2282,
-       0x0a228200,0x00001051,0x14102040,0x80000000,0xfc082082,0x083f0000,0x00e10204,0x08102040,
-       0x81c01010,0x20202040,0x40808080,0x70204081,0x02040810,0xe0008105,0x1b228200,0x00000000,
-       0x00000000,0x00003f80,0x20200000,0x00000000,0x00000000,0x0e023c89,0x11f00000,0x2040b192,
-       0x24489e00,0x00000003,0xc8102040,0x78000000,0x811e4489,0x1223c000,0x000000e2,0x27c8101e,
-       0x00000071,0x0fc40810,0x20400000,0x00003c89,0x12244781,0x1c008102,0xe6489122,0x44000001,
-       0x001c0810,0x20408000,0x00040070,0x20408102,0x04700102,0x04491c28,0x48880000,0x0e040810,
-       0x20408100,0x00000002,0xded93264,0xc9000000,0x000b9922,0x44891000,0x00000038,0x89122447,
-       0x00000000,0x02c64891,0x22788100,0x00000f22,0x448911e0,0x40800000,0xb9920408,0x10000000,
-       0x00078818,0x0c08e000,0x0000083e,0x20408101,0xc0000000,0x01122448,0x933a0000,0x00001051,
-       0x22285040,0x00000000,0x8326ad56,0xc8800000,0x00042486,0x0c248400,0x00000020,0xa24450a0,
-       0x831c0000,0x00f81041,0x041f0000,0x00308102,0x0c081020,0x40600204,0x08102040,0x81020400,
-       0x60204081,0x82040810,0xe0000000,0x00399c00,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x04001020,
-       0x40810000,0x00107142,0x85070400,0x000000c2,0x041c1020,0xf0000000,0x213c4891,0xe4200000,
-       0x00010511,0x47c21f08,0x00000081,0x02000000,0x00408100,0x001c40c1,0x62428302,0x38480000,
-       0x00000000,0x00000000,0x0f215aa5,0x6a13c000,0x00007871,0x23e00000,0x00000000,0x00028a28,
-       0x28280000,0x00000001,0xf8102000,0x00000000,0x0007c000,0x00000000,0x07113a44,0x70000000,
-       0x1fc00000,0x00000000,0x00000000,0x41410000,0x00000000,0x00000408,0x7c2043e0,0x0000003c,
-       0x30f00000,0x00000000,0x01c10700,0x00000000,0x00820000,0x00000000,0x00000000,0x01122448,
-       0x933a4080,0x0007ce9d,0x1a142850,0xa1400000,0x0000c180,0x00000000,0x00000000,0x00000010,
-       0x60000604,0x08000000,0x00000000,0x30912180,0x00000000,0x0000000a,0x0a0a28a0,0x00000032,
-       0x28505952,0xf8400000,0x01914282,0xe8514700,0x00000e38,0xba0e34be,0x10000000,0x00100040,
-       0x8208111e,0x40404142,0x889f2282,0x00004102,0x0a1444f9,0x1410000c,0x241050a2,0x27c8a080,
-       0x0028a082,0x85113e45,0x04000480,0x04142889,0xf2282000,0x082820a1,0x444f9141,0x00000001,
-       0xc60c2c50,0xe2700000,0x001e4102,0x04040782,0x0c2021f2,0x040f1020,0x7c000020,0x8f902078,
-       0x8103e000,0x0c247c81,0x03c4081f,0x00009003,0xe4081e20,0x40f80002,0x021f0810,0x204087c0,
-       0x000410f8,0x40810204,0x3e0000c2,0x47c20408,0x1021f000,0x09003e10,0x2040810f,0x80000001,
-       0xe2245c91,0x22780000,0xa288993a,0x54993220,0x00080879,0x0a142850,0x9e000010,0x43c850a1,
-       0x4284f000,0x03091e42,0x850a1427,0x80000a28,0xf2142850,0xa13c0001,0x200790a1,0x428509e0,
-       0x00000000,0x8490c184,0x90800000,0x01f66954,0xa966f800,0x01010891,0x22448911,0xc0000104,
-       0x44891224,0x488e0000,0x61222448,0x91224470,0x00048011,0x22448912,0x23800002,0x09051141,
-       0x02040800,0x0000040f,0x112244f1,0x0000000e,0x2448a142,0x444b8000,0x202001c0,0x4791223e,
-       0x00004100,0x0e023c89,0x11f0000c,0x24007011,0xe4488f80,0x0028a003,0x808f2244,0x7c000005,
-       0x001c0479,0x1223e000,0x082820e0,0x23c8911f,0x00000000,0x1d853e91,0x21b00000,0x00003c81,
-       0x02040782,0x0c202001,0xc44f9020,0x3c000041,0x000e227c,0x8101e000,0x0c240071,0x13e4080f,
-       0x000000a0,0x03889f20,0x40780002,0x02003810,0x20408100,0x00041001,0xc0810204,0x080000c2,
-       0x400e0408,0x10204000,0x000a0070,0x20408102,0x000000e1,0x21c44891,0x22380000,0xa2801732,
-       0x44891220,0x00080800,0x71122448,0x8e000020,0x80038891,0x22447000,0x0309001c,0x44891223,
-       0x80000a28,0x00e22448,0x911c0000,0x01400711,0x224488e0,0x00000000,0x2003f000,0x04000000,
-       0x0001e4ca,0x99327800,0x01010011,0x22448933,0xa0000410,0x00891224,0x499d0000,0x61200448,
-       0x91224ce8,0x00000500,0x22448912,0x67400004,0x10020a24,0x450a0831,0xc002040b,0x19224489,
-       0xe204000a,0x00828911,0x42820c70,0x00000000,0x00000000,0x00000002,0x04081020,0x00800000,
-       0x24489000,0x00000000,0x000000a1,0x4f8a7e50,0xa0000002,0x0f287030,0x50a78200,0x00008695,
-       0x454552c2,0x00000002,0x0a143193,0x19f00000,0x04081000,0x00000000,0x00001841,0x02040810,
-       0x20203006,0x02020408,0x1020410c,0x000010d8,0xc1400000,0x00000000,0x01021f08,0x10200000,
-       0x00000000,0x00018302,0x08000000,0x0007c000,0x00000000,0x00000000,0x0060c000,0x0000820c,
-       0x1040820c,0x10400000,0xe2244891,0x22380000,0x00061408,0x102043e0,0x00000070,0x10208208,
-       0x1e000000,0x03c0810c,0x0408e000,0x0000020c,0x2891f040,0x80000000,0xf1020701,0x02380000,
-       0x0001c410,0x2c6488e0,0x0000003e,0x08104102,0x08000000,0x00e22487,0x11223800,0x00000711,
-       0x223c0823,0x80000000,0x0060c000,0x060c0000,0x00000306,0x00003060,0x41000000,0x0218c180,
-       0xc0400000,0x000007f0,0x1fc00000,0x00000010,0x180c18c2,0x00000000,0x3c440820,0x80020000,
-       0x0000f229,0xd4afa038,0x00000002,0x0a1444f9,0x14100000,0x00788913,0xc4489e00,0x000001e4,
-       0x10204040,0x78000000,0x1e224489,0x12278000,0x0000f902,0x0788103e,0x00000007,0xc8103c40,
-       0x81000000,0x001e4102,0x34244780,0x00000112,0x244f9122,0x44000000,0x0f840810,0x2043e000,
-       0x00003810,0x2040811c,0x00000002,0x248a1828,0x48880000,0x00102040,0x810207c0,0x0000019b,
-       0x36ab56a9,0x42000000,0x044c9d2a,0x4c991000,0x00003c85,0x0a14284f,0x00000001,0xe2244f10,
-       0x20400000,0x000f2142,0x850a13c0,0xc0c000f1,0x12278911,0x21000000,0x01e4080e,0x0204f000,
-       0x00003f88,0x10204081,0x00000000,0x89122448,0x911c0000,0x00082891,0x22285040,0x00000041,
-       0x9325ab64,0xc8800000,0x020a2282,0x0a228200,0x00001051,0x14102040,0x80000000,0xfc082082,
-       0x083f0000,0x00e10204,0x08102040,0x81c01010,0x20202040,0x40808080,0x70204081,0x02040810,
-       0xe0008105,0x1b228200,0x00000000,0x00000000,0x00003f80,0x20200000,0x00000000,0x00000000,
-       0x0e023c89,0x11f00000,0x2040b192,0x24489e00,0x00000003,0xc8102040,0x78000000,0x811e4489,
-       0x1223c000,0x000000e2,0x27c8101e,0x00000071,0x0fc40810,0x20400000,0x00003c89,0x12244781,
-       0x1c008102,0xe6489122,0x44000001,0x001c0810,0x20408000,0x00040070,0x20408102,0x04700102,
-       0x04491c28,0x48880000,0x0e040810,0x20408100,0x00000002,0xded93264,0xc9000000,0x000b9922,
-       0x44891000,0x00000038,0x89122447,0x00000000,0x02c64891,0x22788100,0x00000f22,0x448911e0,
-       0x40800000,0xb9920408,0x10000000,0x00078818,0x0c08e000,0x0000083e,0x20408101,0xc0000000,
-       0x01122448,0x933a0000,0x00001051,0x22285040,0x00000000,0x8326ad56,0xc8800000,0x00042486,
-       0x0c248400,0x00000020,0xa24450a0,0x831c0000,0x00f81041,0x041f0000,0x00308102,0x0c081020,
-       0x40600204,0x08102040,0x81020400,0x60204081,0x82040810,0xe0000000,0x00399c00,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x04001020,0x40810000,0x00107142,0x85070400,0x000000c2,0x041c1020,
-       0xf0000000,0x213c4891,0xe4200000,0x00010511,0x47c21f08,0x00000081,0x02000000,0x00408100,
-       0x001c40c1,0x62428302,0x38480000,0x00000000,0x00000000,0x0f215aa5,0x6a13c000,0x00007871,
-       0x23e00000,0x00000000,0x00028a28,0x28280000,0x00000001,0xf8102000,0x00000000,0x0007c000,
-       0x00000000,0x07113a44,0x70000000,0x1fc00000,0x00000000,0x00000000,0x41410000,0x00000000,
-       0x00000408,0x7c2043e0,0x0000003c,0x30f00000,0x00000000,0x01c10700,0x00000000,0x00820000,
-       0x00000000,0x00000000,0x01122448,0x933a4080,0x0007ce9d,0x1a142850,0xa1400000,0x0000c180,
-       0x00000000,0x00000000,0x00000010,0x60000604,0x08000000,0x00000000,0x30912180,0x00000000,
-       0x0000000a,0x0a0a28a0,0x00000032,0x28505952,0xf8400000,0x01914282,0xe8514700,0x00000e38,
-       0xba0e34be,0x10000000,0x00100040,0x8208111e,0x40404142,0x889f2282,0x00004102,0x0a1444f9,
-       0x1410000c,0x241050a2,0x27c8a080,0x0028a082,0x85113e45,0x04000480,0x04142889,0xf2282000,
-       0x082820a1,0x444f9141,0x00000001,0xc60c2c50,0xe2700000,0x001e4102,0x04040782,0x0c2021f2,
-       0x040f1020,0x7c000020,0x8f902078,0x8103e000,0x0c247c81,0x03c4081f,0x00009003,0xe4081e20,
-       0x40f80002,0x021f0810,0x204087c0,0x000410f8,0x40810204,0x3e0000c2,0x47c20408,0x1021f000,
-       0x09003e10,0x2040810f,0x80000001,0xe2245c91,0x22780000,0xa288993a,0x54993220,0x00080879,
-       0x0a142850,0x9e000010,0x43c850a1,0x4284f000,0x03091e42,0x850a1427,0x80000a28,0xf2142850,
-       0xa13c0001,0x200790a1,0x428509e0,0x00000000,0x8490c184,0x90800000,0x01f66954,0xa966f800,
-       0x01010891,0x22448911,0xc0000104,0x44891224,0x488e0000,0x61222448,0x91224470,0x00048011,
-       0x22448912,0x23800002,0x09051141,0x02040800,0x0000040f,0x112244f1,0x0000000e,0x2448a142,
-       0x444b8000,0x202001c0,0x4791223e,0x00004100,0x0e023c89,0x11f0000c,0x24007011,0xe4488f80,
-       0x0028a003,0x808f2244,0x7c000005,0x001c0479,0x1223e000,0x082820e0,0x23c8911f,0x00000000,
-       0x1d853e91,0x21b00000,0x00003c81,0x02040782,0x0c202001,0xc44f9020,0x3c000041,0x000e227c,
-       0x8101e000,0x0c240071,0x13e4080f,0x000000a0,0x03889f20,0x40780002,0x02003810,0x20408100,
-       0x00041001,0xc0810204,0x080000c2,0x400e0408,0x10204000,0x000a0070,0x20408102,0x000000e1,
-       0x21c44891,0x22380000,0xa2801732,0x44891220,0x00080800,0x71122448,0x8e000020,0x80038891,
-       0x22447000,0x0309001c,0x44891223,0x80000a28,0x00e22448,0x911c0000,0x01400711,0x224488e0,
-       0x00000000,0x2003f000,0x04000000,0x0001e4ca,0x99327800,0x01010011,0x22448933,0xa0000410,
-       0x00891224,0x499d0000,0x61200448,0x91224ce8,0x00000500,0x22448912,0x67400004,0x10020a24,
-       0x450a0831,0xc002040b,0x19224489,0xe204000a,0x00828911,0x42820c70,0x00000000,0x00000000,
-       0x00000002,0x04081020,0x00800000,0x24489000,0x00000000,0x000000a1,0x4f8a7e50,0xa0000002,
-       0x0f287030,0x50a78200,0x00008695,0x454552c2,0x00000002,0x0a143193,0x19f00000,0x04081000,
-       0x00000000,0x00001841,0x02040810,0x20203006,0x02020408,0x1020410c,0x000010d8,0xc1400000,
-       0x00000000,0x01021f08,0x10200000,0x00000000,0x00018302,0x08000000,0x0007c000,0x00000000,
-       0x00000000,0x0060c000,0x0000820c,0x1040820c,0x10400000,0xe2244891,0x22380000,0x00061408,
-       0x102043e0,0x00000070,0x10208208,0x1e000000,0x03c0810c,0x0408e000,0x0000020c,0x2891f040,
-       0x80000000,0xf1020701,0x02380000,0x0001c410,0x2c6488e0,0x0000003e,0x08104102,0x08000000,
-       0x00e22487,0x11223800,0x00000711,0x223c0823,0x80000000,0x0060c000,0x060c0000,0x00000306,
-       0x00003060,0x41000000,0x0218c180,0xc0400000,0x000007f0,0x1fc00000,0x00000010,0x180c18c2,
-       0x00000000,0x3c440820,0x80020000,0x0000f229,0xd4afa038,0x00000002,0x0a1444f9,0x14100000,
-       0x00788913,0xc4489e00,0x000001e4,0x10204040,0x78000000,0x1e224489,0x12278000,0x0000f902,
-       0x0788103e,0x00000007,0xc8103c40,0x81000000,0x001e4102,0x34244780,0x00000112,0x244f9122,
-       0x44000000,0x0f840810,0x2043e000,0x00003810,0x2040811c,0x00000002,0x248a1828,0x48880000,
-       0x00102040,0x810207c0,0x0000019b,0x36ab56a9,0x42000000,0x044c9d2a,0x4c991000,0x00003c85,
-       0x0a14284f,0x00000001,0xe2244f10,0x20400000,0x000f2142,0x850a13c0,0xc0c000f1,0x12278911,
-       0x21000000,0x01e4080e,0x0204f000,0x00003f88,0x10204081,0x00000000,0x89122448,0x911c0000,
-       0x00082891,0x22285040,0x00000041,0x9325ab64,0xc8800000,0x020a2282,0x0a228200,0x00001051,
-       0x14102040,0x80000000,0xfc082082,0x083f0000,0x00e10204,0x08102040,0x81c01010,0x20202040,
-       0x40808080,0x70204081,0x02040810,0xe0008105,0x1b228200,0x00000000,0x00000000,0x00003f80,
-       0x20200000,0x00000000,0x00000000,0x0e023c89,0x11f00000,0x2040b192,0x24489e00,0x00000003,
-       0xc8102040,0x78000000,0x811e4489,0x1223c000,0x000000e2,0x27c8101e,0x00000071,0x0fc40810,
-       0x20400000,0x00003c89,0x12244781,0x1c008102,0xe6489122,0x44000001,0x001c0810,0x20408000,
-       0x00040070,0x20408102,0x04700102,0x04491c28,0x48880000,0x0e040810,0x20408100,0x00000002,
-       0xded93264,0xc9000000,0x000b9922,0x44891000,0x00000038,0x89122447,0x00000000,0x02c64891,
-       0x22788100,0x00000f22,0x448911e0,0x40800000,0xb9920408,0x10000000,0x00078818,0x0c08e000,
-       0x0000083e,0x20408101,0xc0000000,0x01122448,0x933a0000,0x00001051,0x22285040,0x00000000,
-       0x8326ad56,0xc8800000,0x00042486,0x0c248400,0x00000020,0xa24450a0,0x831c0000,0x00f81041,
-       0x041f0000,0x00308102,0x0c081020,0x40600204,0x08102040,0x81020400,0x60204081,0x82040810,
-       0xe0000000,0x00399c00,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-       0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x04001020,0x40810000,0x00107142,
-       0x85070400,0x000000c2,0x041c1020,0xf0000000,0x213c4891,0xe4200000,0x00010511,0x47c21f08,
-       0x00000081,0x02000000,0x00408100,0x001c40c1,0x62428302,0x38480000,0x00000000,0x00000000,
-       0x0f215aa5,0x6a13c000,0x00007871,0x23e00000,0x00000000,0x00028a28,0x28280000,0x00000001,
-       0xf8102000,0x00000000,0x0007c000,0x00000000,0x07113a44,0x70000000,0x1fc00000,0x00000000,
-       0x00000000,0x41410000,0x00000000,0x00000408,0x7c2043e0,0x0000003c,0x30f00000,0x00000000,
-       0x01c10700,0x00000000,0x00820000,0x00000000,0x00000000,0x01122448,0x933a4080,0x0007ce9d,
-       0x1a142850,0xa1400000,0x0000c180,0x00000000,0x00000000,0x00000010,0x60000604,0x08000000,
-       0x00000000,0x30912180,0x00000000,0x0000000a,0x0a0a28a0,0x00000032,0x28505952,0xf8400000,
-       0x01914282,0xe8514700,0x00000e38,0xba0e34be,0x10000000,0x00100040,0x8208111e,0x40404142,
-       0x889f2282,0x00004102,0x0a1444f9,0x1410000c,0x241050a2,0x27c8a080,0x0028a082,0x85113e45,
-       0x04000480,0x04142889,0xf2282000,0x082820a1,0x444f9141,0x00000001,0xc60c2c50,0xe2700000,
-       0x001e4102,0x04040782,0x0c2021f2,0x040f1020,0x7c000020,0x8f902078,0x8103e000,0x0c247c81,
-       0x03c4081f,0x00009003,0xe4081e20,0x40f80002,0x021f0810,0x204087c0,0x000410f8,0x40810204,
-       0x3e0000c2,0x47c20408,0x1021f000,0x09003e10,0x2040810f,0x80000001,0xe2245c91,0x22780000,
-       0xa288993a,0x54993220,0x00080879,0x0a142850,0x9e000010,0x43c850a1,0x4284f000,0x03091e42,
-       0x850a1427,0x80000a28,0xf2142850,0xa13c0001,0x200790a1,0x428509e0,0x00000000,0x8490c184,
-       0x90800000,0x01f66954,0xa966f800,0x01010891,0x22448911,0xc0000104,0x44891224,0x488e0000,
-       0x61222448,0x91224470,0x00048011,0x22448912,0x23800002,0x09051141,0x02040800,0x0000040f,
-       0x112244f1,0x0000000e,0x2448a142,0x444b8000,0x202001c0,0x4791223e,0x00004100,0x0e023c89,
-       0x11f0000c,0x24007011,0xe4488f80,0x0028a003,0x808f2244,0x7c000005,0x001c0479,0x1223e000,
-       0x082820e0,0x23c8911f,0x00000000,0x1d853e91,0x21b00000,0x00003c81,0x02040782,0x0c202001,
-       0xc44f9020,0x3c000041,0x000e227c,0x8101e000,0x0c240071,0x13e4080f,0x000000a0,0x03889f20,
-       0x40780002,0x02003810,0x20408100,0x00041001,0xc0810204,0x080000c2,0x400e0408,0x10204000,
-       0x000a0070,0x20408102,0x000000e1,0x21c44891,0x22380000,0xa2801732,0x44891220,0x00080800,
-       0x71122448,0x8e000020,0x80038891,0x22447000,0x0309001c,0x44891223,0x80000a28,0x00e22448,
-       0x911c0000,0x01400711,0x224488e0,0x00000000,0x2003f000,0x04000000,0x0001e4ca,0x99327800,
-       0x01010011,0x22448933,0xa0000410,0x00891224,0x499d0000,0x61200448,0x91224ce8,0x00000500,
-       0x22448912,0x67400004,0x10020a24,0x450a0831,0xc002040b,0x19224489,0xe204000a,0x00828911,
-       0x42820c70};
-
-    // Return a 'stringification' of standart integral types.
-    const char* const bool_st    = "bool";
-    const char* const uchar_st   = "unsigned char";
-    const char* const char_st    = "char";
-    const char* const ushort_st  = "unsigned short";
-    const char* const short_st   = "short";
-    const char* const uint_st    = "unsigned int";
-    const char* const int_st     = "int";
-    const char* const ulong_st   = "unsigned long";
-    const char* const long_st    = "long";
-    const char* const float_st   = "float";
-    const char* const double_st  = "double";
-    const char* const unknown_st = "unknown";
-    template<typename t> inline const char* get_type(const t&) { return unknown_st; }
-    inline const char* get_type(const bool&          ) { return bool_st;   }
-    inline const char* get_type(const unsigned char& ) { return uchar_st;  }
-    inline const char* get_type(const char&          ) { return char_st;   }
-    inline const char* get_type(const unsigned short&) { return ushort_st; }
-    inline const char* get_type(const short&         ) { return short_st;  }
-    inline const char* get_type(const unsigned int&  ) { return uint_st;   }
-    inline const char* get_type(const int&           ) { return int_st;    }
-    inline const char* get_type(const unsigned long& ) { return ulong_st;  }
-    inline const char* get_type(const long&          ) { return long_st;   }
-    inline const char* get_type(const float&         ) { return float_st;  }
-    inline const char* get_type(const double&        ) { return double_st; }
-    
-    // Display a warning message
-#if cimg_debug>=1    
-    static void warn(const bool cond,const char *format,...) {
-      if (cond) {
-        va_list ap;
-        va_start(ap,format);
-        std::fprintf(stderr,"<CImg Warning> ");
-        std::vfprintf(stderr,format,ap);
-        std::fputc('\n',stderr);
-        va_end(ap);
-      }
-    }
-#else
-    inline void warn(const bool cond,const char *format,...) {}
-#endif
-
-    inline int xln(const int x) { return x>0?(int)(1+std::log10((double)x)):1; }
-    inline char uncase(const char x) { return (char)((x<'A'||x>'Z')?x:x-'A'+'a'); }
-    inline float atof(const char *str) {
-      float x=0,y=1;
-      if (!str) return 0; else { std::sscanf(str,"%g/%g",&x,&y); return x/y; }
-    }
-    inline int strlen(const char *s) { if (s) { int k; for (k=0; s[k]; k++) ; return k; } return -1; }
-    inline int strncmp(const char *s1,const char *s2,const int l) {
-      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=abs(s1[k] - s2[k]); return n; }
-      return 0;
-    }
-    inline int strncasecmp(const char *s1,const char *s2,const int l) {
-      if (s1 && s2) { int n=0; for (int k=0; k<l; k++) n+=abs(uncase(s1[k])-uncase(s2[k])); return n; }
-      return 0;
-    }
-    inline int strcmp(const char *s1,const char *s2)     { 
-      const int l1 = strlen(s1), l2 = strlen(s2);
-      return strncmp(s1,s2,1+(l1<l2?l1:l2));
-    }
-    inline int strcasecmp(const char *s1,const char *s2) { 
-      const int l1 = strlen(s1), l2 = strlen(s2);
-      return strncasecmp(s1,s2,1+(l1<l2?l1:l2));
-    }
-    inline int strfind(const char *s,const char c) {
-      if (s) { 
-        int l; for (l=strlen(s); l>=0 && s[l]!=c; l--) ;
-        return l; 
-      }
-      return -1; 
-    }
-    inline const char* basename(const char *s)  {
-      return (cimg_OS!=2)?(s?s+1+strfind(s,'/'):NULL):(s?s+1+strfind(s,'\\'):NULL); 
-    }
-
-    inline void system(const char *command) {
-#if cimg_OS==2
-      PROCESS_INFORMATION pi;
-      STARTUPINFO si;
-      GetStartupInfo(&si);
-      si.wShowWindow = SW_HIDE;
-      si.dwFlags |= SW_HIDE;
-      BOOL res = CreateProcess(NULL,(LPTSTR)command,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi);
-      if (res) {
-        WaitForSingleObject(pi.hProcess, INFINITE);
-        CloseHandle(pi.hThread);
-        CloseHandle(pi.hProcess);
-      }
-#else
-      ::system(command);
-#endif
-    }
-    
-    //! Return the path of the ImageMagick <tt>convert</tt> tool.
-    /**
-       If you have installed the <a href="http://www.imagemagick.org">ImageMagick package</a>
-       in a standart directory, this function returns the correct path of the \c convert tool
-       used to load and save compressed image formats.
-       Conversely, if the \c convert executable is not auto-detected by the function,
-       you can define the macro \c cimg_convert_path with the correct path
-       of the \c convert executable, before including <tt>"CImg.h"</tt> in your program :
-       \code
-       #define cimg_convert_path "/users/thatsme/local/bin/convert"
-       #include "CImg.h"
-       
-       int main() {
-         CImg<> img("my_image.jpg");
-	 return 0;
-       }
-       \endcode
-       \note \c convert is needed to read and write compressed image formats. Other formats do not need \c convert.
-       \see temporary_path, CImg::load_convert, CImg::save_convert.
-    **/
-    inline const char* convert_path() {
-      static char *convert_path = NULL;
-      if (!convert_path) {
-#if cimg_OS==2 || defined(cimg_convert_path)
-        bool stopflag = false;
-        std::FILE *file;
-#endif
-        convert_path = new char[1024];
-#ifdef cimg_convert_path
-        std::strcpy(convert_path,cimg_convert_path);
-        if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
-#endif
-#if cimg_OS==2
-        for (unsigned int k=0; k<=9 && !stopflag; k++) {
-          std::sprintf(convert_path,"C:\\PROGRA~1\\IMAGEM~1.%u-Q\\convert.exe",k);
-          if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
-        }
-        if (!stopflag) for (unsigned int k=0; k<=9 && !stopflag; k++) {
-          std::sprintf(convert_path,"C:\\PROGRA~1\\IMAGEM~1.%u\\convert.exe",k);
-          if ((file=std::fopen(convert_path,"r"))!=NULL) { std::fclose(file); stopflag = true; }
-        }
-        if (!stopflag) std::strcpy(convert_path,"convert.exe");
-#else
-        std::strcpy(convert_path,"convert");
-#endif
-      }
-      return convert_path;
-    }
-    
-    //! Return a path to store temporary files.
-    /**
-       If you are running on a standart Unix or Windows system, this function should return a correct path
-       where temporary files can be stored.
-       If the path is not auto-detected, you need to define the macro \c cimg_temporary_path,
-       before including <tt>"CImg.h"</tt> in your program :
-       \code
-       #define cimg_temporary_path "/users/toto/tmp"
-       #include "CImg.h"
-
-       int main() {
-         CImg<> img("my_image.jpg");
-	 return 0;
-       }
-       \endcode
-       \note A temporary path is necessary to load and save compressed image formats, using \c convert.
-       \see convert_path, CImg::load_convert, CImg::save_convert.
-    **/
-    inline const char* temporary_path() {
-      static char *temporary_path = NULL;
-      if (!temporary_path) {
-        temporary_path = new char[1024];
-#ifdef cimg_temporary_path
-        std::strcpy(temporary_path,cimg_temporary_path);
-        const char* testing_path[7] = { temporary_path, "/tmp","C:\\WINNT\\Temp", "C:\\WINDOWS\\Temp","","C:",NULL };
-#else
-        const char* testing_path[6] = { "/tmp","C:\\WINNT\\Temp", "C:\\WINDOWS\\Temp","","C:",NULL };
-#endif
-        char filetmp[1024];
-        std::FILE *file=NULL;
-        int i=-1;
-        while (!file && testing_path[++i]) {
-          std::sprintf(filetmp,"%s/CImg%.4d.ppm",testing_path[i],std::rand()%10000);
-          if ((file=std::fopen(filetmp,"w"))!=NULL) { std::fclose(file); std::remove(filetmp); }
-        }
-        if (!file) 
-	  throw CImgIOException("cimg::temporary_path() : Unable to find a temporary path accessible for writing\n"
-				"you have to set the macro 'cimg_temporary_path' to a valid path where you have writing access :\n"
-				"#define cimg_temporary_path \"path\" (before including 'CImg.h')");
-        std::strcpy(temporary_path,testing_path[i]);
-      }
-      return temporary_path;
-    }
-    
-    inline const char *filename_split(const char *const filename, char *const body=NULL) {
-      if (!filename) throw CImgArgumentException("cimg::filename_split() : Can't split the (null) filename");
-      int l=strfind(filename,'.');
-      if (l>=0) { if (body) { std::strncpy(body,filename,l); body[l]='\0'; }}
-      else { if (body) std::strcpy(body,filename); l=(int)std::strlen(filename)-1; }
-      return filename+l+1;
-    }
-    
-    inline char* file_number(const char *filename,const int number,const unsigned int n,char *const string) {
-      char format[1024],body[1024];
-      const char *ext = filename_split(filename,body);
-      if (n>0) std::sprintf(format,"%s_%%.%ud.%s",body,n,ext);
-      else std::sprintf(format,"%s_%%d.%s",body,ext);
-      std::sprintf(string,format,number);
-      return string;
-    }
-    inline std::FILE *fopen(const char *const path,const char *const mode) {
-      if(!path || !mode) throw CImgArgumentException("cimg::fopen() : Can't open file '%s' with mode '%s'",path,mode);
-      if (path[0]=='-') return (mode[0]=='r')?stdin:stdout; else {
-        std::FILE *dest=std::fopen(path,mode);
-        if(!dest) throw CImgIOException("cimg::fopen() : File '%s' cannot be opened %s",
-                                        path,mode[0]=='r'?"for reading":(mode[0]=='w'?"for writing":""),path);
-        return dest;
-      }
-    }
-    inline int fclose(std::FILE *file) {
-      warn(!file,"cimg::fclose() : Can't close (null) file");
-      if (!file || file==stdin || file==stdout) return 0;
-      const int errn=std::fclose(file);
-      warn(errn!=0,"cimg::fclose() : Error %d during file closing",errn);
-      return errn;
-    }
-    template<typename T> inline int fread(T *ptr,const unsigned int size,const unsigned int nmemb,std::FILE *stream) {
-      if (!ptr || size<=0 || nmemb<=0 || !stream)
-        throw CImgArgumentException("cimg::fread() : Can't read %u x %u bytes of file pointer '%p' in buffer '%p'",
-				    nmemb,size,stream,ptr);
-      const unsigned int errn = (unsigned int)std::fread((void*)ptr,size,nmemb,stream);
-      warn(errn!=nmemb,"cimg::fread() : File reading problems, only %u/%u elements read",errn,nmemb);
-      return errn;
-    }
-    inline int fwrite(const void *ptr,const unsigned int size,const unsigned int nmemb,std::FILE *stream) {
-      if (!ptr || size<=0 || nmemb<=0 || !stream)
-        throw CImgArgumentException("cimg::fwrite() : Can't write %u x %u bytes of file pointer '%p' from buffer '%p'",
-				    nmemb,size,stream,ptr);
-      const unsigned int errn = (unsigned int)std::fwrite(ptr,size,nmemb,stream);
-      if(errn!=nmemb)
-        throw CImgIOException("cimg::fwrite() : File writing problems, only %u/%u elements written",errn,nmemb);
-      return errn;
-    }
-    
-    // Exchange the values of variables \p a and \p b
-    template<typename T> inline void swap(T& a,T& b) { T t=a; a=b; b=t; }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2) { swap(a1,b1); swap(a2,b2); }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3) { swap(a1,b1,a2,b2); swap(a3,b3); }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4) { swap(a1,b1,a2,b2,a3,b3); swap(a4,b4); }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4,T& a5,T& b5) {
-      swap(a1,b1,a2,b2,a3,b3,a4,b4); swap(a5,b5); 
-    }
-    template<typename T> inline void swap(T& a1,T& b1,T& a2,T& b2,T& a3,T& b3,T& a4,T& b4,T& a5,T& b5,T& a6,T& b6) {
-      swap(a1,b1,a2,b2,a3,b3,a4,b4,a5,b5); swap(a6,b6);
-    }
-    
-    template<typename T> inline T& endian_swap(T& a) {  
-      if (sizeof(a)!=1) {
-	unsigned char *pb=(unsigned char*)&a, *pe=pb+sizeof(a);
-	for (int i=0; i<(int)sizeof(a)/2; i++) swap(*(pb++),*(--pe));
-      }
-      return a;
-    }
-
-    template<typename T> inline void endian_swap(T *const buffer,const unsigned int size) {
-      T *ptr = buffer;
-      for (unsigned int i=0; i<size; i++) endian_swap(*(ptr++));
-    }
-
-    inline const char* option(const char *const name,const unsigned int argc,char **argv,const char *const defaut,
-                              const char *const usage=NULL) {
-      static bool first=true, visu=false;
-      const char *res = NULL;
-      if (first) { first=false; visu = option("-h",argc,argv,(const char*)NULL)!=NULL; }
-      if (!name && visu) {
-        std::fprintf(stderr,"\n %s%s%s",t_red,basename(argv[0]),t_normal);
-        if (usage) std::fprintf(stderr," : %s",usage);
-        std::fprintf(stderr," (%s, %s)\n\n",__DATE__,__TIME__);
-      }
-      if (name) {
-        if (argc>0) {
-          unsigned int k=0,i;
-          while (k<argc && strcmp(argv[k],name)) k++;
-          i=k;
-          res=(k++==argc?defaut:(k==argc?argv[--k]:argv[k]));
-        } else res = defaut;
-        if (visu && usage) std::fprintf(stderr,"    %s%-8s%s = %-12s : %s%s%s\n",
-                                        t_bold,name,t_normal,res?res:"NULL",t_purple,usage,t_normal);
-      }
-      return res;
-    }
-    inline bool option(const char *const name,const unsigned int argc,char **argv,
-                       const bool defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const bool res = s?(strcasecmp(s,"false") && strcasecmp(s,"off") && strcasecmp(s,"0")):defaut;
-      option(name,0,NULL,res?"true":"false",usage);
-      return res;
-    }
-    inline int option(const char *const name,const unsigned int argc,char **argv,
-                      const int defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const int res = s?atoi(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%d",res);
-      option(name,0,NULL,tmp,usage);
-      return res;
-    }
-    inline char option(const char *const name,const unsigned int argc,char **argv,
-		       const char defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const char res = s?s[0]:defaut;
-      char tmp[8];
-      tmp[0] = res;
-      tmp[1] ='\0';
-      option(name,0,NULL,tmp,usage);
-      return res;
-    }
-    inline double option(const char *const name,const unsigned int argc,char **argv,
-                         const double defaut,const char *const usage=NULL) {
-      const char *s = option(name,argc,argv,(const char*)NULL);
-      const double res = s?atof(s):defaut;
-      char tmp[256];
-      std::sprintf(tmp,"%g",res);
-      option(name,0,NULL,tmp,usage);
-      return res;
-    }
-    
-    //! Return \c false for little endian CPUs, \c true for big endian CPUs.
-    inline const bool endian() { const int x=1; return ((unsigned char*)&x)[0]?false:true; }
-
-    //! Display informations about CImg compilation variables, on the standart error output \e stderr.
-    inline void info() {
-      std::fprintf(stderr,"\n %sCImg Library %g%s, compiled %s ( %s ) with the following flags :\n\n",
-                   t_red,cimg_version,t_normal,__DATE__,__TIME__);
-      std::fprintf(stderr,"  > Architecture   : %s%-12s%s %s(cimg_OS=%d)\n%s",
-                   t_bold,
-                   cimg_OS==0?"Solaris":(cimg_OS==1?"Linux":(cimg_OS==2?"Windows":(cimg_OS==3?"Mac OS X":(cimg_OS==4?"FreeBSD":"Unknown")))),
-                   t_normal,t_purple,cimg_OS,t_normal);
-      std::fprintf(stderr,"  > Display type   : %s%-12s%s %s(cimg_display_type=%d)%s\n",
-                   t_bold,cimg_display_type==0?"No":(cimg_display_type==1?"X11":(cimg_display_type==2?"WindowsGDI":"Unknown")),t_normal,t_purple,cimg_display_type,t_normal);
-#ifdef cimg_color_terminal
-      std::fprintf(stderr,"  > Color terminal : %s%-12s%s %s(cimg_color_terminal defined)%s\n",t_bold,"Yes",t_normal,t_purple,t_normal);
-#else
-      std::fprintf(stderr,"  > Color terminal : %-12s (cimg_color_terminal undefined)\n","No");
-#endif
-#ifdef cimg_lapack
-      std::fprintf(stderr,"  > Using LAPACK   : %s%-12s%s %s(cimg_lapack defined)%s\n",t_bold,"Yes",t_normal,t_purple,t_normal);
-#else
-      std::fprintf(stderr,"  > Using LAPACK   : %s%-12s%s %s(cimg_lapack undefined)%s\n",t_bold,"No",t_normal,t_purple,t_normal);
-#endif
-      std::fprintf(stderr,"  > Debug messages : %s%-12s%s %s(cimg_debug=%d)%s\n",t_bold,cimg_debug==2?"High":(cimg_debug==1?"Yes":"No"),
-                   t_normal,t_purple,cimg_debug,t_normal);
-      std::fprintf(stderr,"\n");
-    }
-    
-    //! Get the value of a system timer with a millisecond precision.
-    inline long int time() {
-#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3 || cimg_OS==4
-      struct timeval st_time;
-      gettimeofday(&st_time,NULL);
-      return (long int)(st_time.tv_usec/1000 + st_time.tv_sec*1000);
-#elif cimg_OS==2
-      static SYSTEMTIME st_time;
-      GetSystemTime(&st_time);
-      return (long int)(st_time.wMilliseconds + 1000*(st_time.wSecond + 60*(st_time.wMinute + 60*st_time.wHour)));
-#else 
-      return 0;
-#endif
-    }
-
-    //! Sleep for a certain numbers of milliseconds.
-    /**
-       This function frees the CPU ressources during the sleeping time.
-       May be used to temporize your program properly.
-       \see wait, time.
-    **/
-    inline void sleep(const int milliseconds) {
-#if cimg_OS==0 || cimg_OS==1 || cimg_OS==3 || cimg_OS==4
-      struct timespec tv;
-      tv.tv_sec = milliseconds/1000;
-      tv.tv_nsec = (milliseconds%1000)*1000000;
-      nanosleep(&tv,NULL);
-#elif cimg_OS==2
-      Sleep(milliseconds);
-#endif
-    }
-    //! Wait for a certain number of milliseconds since the last call of \ref wait().
-    /**
-       If the desired delay has expired, this function returns immediately else it sleeps till the correct time.
-       May be used to temporize your program properly.
-       \see sleep, time.
-    **/
-    inline long int wait(const int milliseconds=20,long int reference_time=-1) {
-      static long int latest_time = time();
-      if (reference_time>=0) latest_time = reference_time;
-      const long int current_time = time(), time_diff = milliseconds + latest_time - current_time;
-      if (time_diff>0) { sleep(time_diff); return (latest_time = current_time + time_diff); }
-      else return (latest_time = current_time);
-    }
-    //! Bitwise rotation on the left
-    template<typename T> inline const T rol(const T& a,const unsigned int n=1) { return (a<<n)|(a>>((sizeof(T)<<3)-n)); }
-    //! Bitwise rotation on the right
-    template<typename T> inline const T ror(const T& a,const unsigned int n=1) { return (a>>n)|(a<<((sizeof(T)<<3)-n)); }
-
-#if ( !defined(_MSC_VER) || _MSC_VER>1200 )
-    //! Return the absolute value of \p a
-    template<typename T> inline const T abs(const T& a) { return a>=0?a:-a; }
-    //! Return the minimum between \p a and \p b.
-    template<typename T> inline const T& min(const T& a,const T& b) { return a<=b?a:b; }
-    //! Return the minimum between \p a,\p b and \a c.
-    template<typename T> inline const T& min(const T& a,const T& b,const T& c) { return min(min(a,b),c); }
-    //! Return the minimum between \p a,\p b,\p c and \p d.
-    template<typename T> inline const T& min(const T& a,const T& b,const T& c,const T& d) { return min(min(min(a,b),c),d); }
-    //! Return the maximum between \p a and \p b.
-    template<typename T> inline const T& max(const T& a,const T& b) { return a>=b?a:b; }
-    //! Return the maximum between \p a,\p b and \p c.
-    template<typename T> inline const T& max(const T& a,const T& b,const T& c) { return max(max(a,b),c); }
-    //! Return the maximum between \p a,\p b,\p c and \p d.
-    template<typename T> inline const T& max(const T& a,const T& b,const T& c,const T& d) { return max(max(a,b,c),d); }
-    //! Return the sign of \p x.
-    template<typename T> inline char sign(const T& x) { return (x<0)?-1:(x==0?0:1); }
-#else
-    // Special versions due to object reference bug in VisualC++ 6.0.
-    template<typename T> inline const T abs(const T a) { return a>=0?a:-a; }
-    template<typename T> inline const T min(const T a,const T b) { return a<=b?a:b; }
-    template<typename T> inline const T min(const T a,const T b,const T c) { return min(min(a,b),c); }
-    template<typename T> inline const T min(const T a,const T b,const T c,const T& d) { return min(min(min(a,b),c),d); }
-    template<typename T> inline const T max(const T a,const T b) { return a>=b?a:b; }
-    template<typename T> inline const T max(const T a,const T b,const T c) { return max(max(a,b),c); }
-    template<typename T> inline const T max(const T a,const T b,const T c,const T& d) { return max(max(max(a,b),c),d); }
-    template<typename T> inline char sign(const T x) { return (x<0)?-1:(x==0?0:1); }
-#endif
-
-    //! Return \p x modulo \p m (generic modulo).
-    /**
-       This modulo function accepts negative and floating-points modulo numbers \p m.
-    **/
-    inline double mod(const double& x,const double& m) { return x-m*std::floor(x/m); }
-	inline float  mod(const float& x,const float& m)   { return (float)(x-m*std::floor((double)x/m)); }
-    inline int    mod(const int x,const int m)         { return x>=0?x%m:(x%m?m+x%m:0); }
-
-    //! Return minmod(\p a,\p b).
-    /**
-       The operator minmod(\p a,\p b) is defined to be :
-       - minmod(\p a,\p b) = min(\p a,\p b), if (\p a * \p b)>0.
-       - minmod(\p a,\p b) = 0,              if (\p a * \p b)<=0
-    **/
-    template<typename T> inline T minmod(const T& a,const T& b) { return a*b<=0?0:(a>0?(a<b?a:b):(a<b?b:a)); }
-    //! Return a random variable between [0,1] (uniform distribution).
-    inline double rand() { return (double)std::rand()/RAND_MAX; }
-    //! Return a random variable between [-1,1] (uniform distribution).
-    inline double crand() { return 1-2*rand(); }
-    //! Return a random variable using a gaussian distribution and a variance of 1.
-    inline double grand() { return std::sqrt(-2*std::log((double)(1e-10 + (1-2e-10)*rand())))*std::cos((double)(2*PI*rand())); }
-  }
-
-  /*-------------------------------------------------------
-    
-  
-  
-  
-    Definition of the CImgStats structure
-  
-  
-  
-    
-    ------------------------------------------------------*/
-  //! This class is used to compute basics statistics of a <tt>CImg<T></tt> image.
-  /** 
-      Constructing a CImgStats instance by passing an image CImg<T> or an image list CImgl<T> as a parameter,
-      will compute the minimum, the maximum and the average pixel values of the given object, and optionally
-      the variance of the pixel values. Use it to retrieve basic statistics of an image, or an image list,
-      like this :
-      \code 
-      const CImg<float> img("my_image.jpg");
-      const CImgStats stats(img);
-      stats.print("My statistics");
-      std::printf("Max-Min = %lf",stats.max-stats.min);
-      \endcode
-      Note that statistics are computed for all scalar values of a CImg<T> or a CImgl<T>. No vector-valued
-      statistics are performed.
-  **/
-  struct CImgStats {
-    double min;                 //!< Minimum of the pixel values after statistics computation.
-    double max;                 //!< Maximum of the pixel values after statistics computation.
-    double mean;                //!< Mean of the pixel values after statistics computation.
-    double variance;            //!< Variance of the pixel values after statistics computation.
-
-    //! Default constructor.
-    CImgStats():min(0),max(0),mean(0),variance(0) {}
-    //! Copy constructor.
-    CImgStats(const CImgStats& stats):min(stats.min),max(stats.max),mean(stats.mean),variance(stats.variance) {};
-
-    //! Constructor that compute statistics of an image \p img.
-    /** 
-        If \p compute_variance = true, the variance field of the CImgStats structure is computed, else it is set to 0.
-    **/
-    template<typename T> CImgStats(const CImg<T>& img,const bool compute_variance=true):mean(0),variance(0) {
-      cimg_test(img,"CImgStats::CImgStats");
-      T pmin=img[0], pmax=pmin;
-      cimg_map(img,ptr,T) { const T& a=*ptr; mean+=(double)a; if (a<pmin) pmin=a; if (a>pmax) pmax=a; }
-      mean/=img.size();
-      min=(double)pmin;
-      max=(double)pmax;
-      if (compute_variance) {
-        cimg_map(img,ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
-        variance = std::sqrt(variance/img.size());
-      }
-    }
-    //! Constructor that compute statistics of an image list \p list.
-    /**
-       Statistics are computed for all pixels of all images of the list.
-       If \p compute_variance = true, the variance field of the CImgStats structure is computed, else it is undefined.
-    **/
-    template<typename T> CImgStats(const CImgl<T>& list,const bool compute_variance=true):mean(0),variance(0) {
-      cimgl_test(list,"CImgStats::CImgStats");
-      T pmin=list[0][0], pmax=pmin;
-      int psize=0;
-      cimgl_map(list,l) {
-        cimg_map(list[l],ptr,T) {
-          const T& a=*ptr;
-          mean+=(double)a;
-          if (a<pmin) pmin=a;
-          if (a>pmax) pmax=a;
-        }
-        psize+=list[l].size();
-      }
-      mean/=psize;
-      min=(double)pmin;
-      max=(double)pmax;
-      if (compute_variance) {
-        cimgl_map(list,l) cimg_map(list[l],ptr,T) { const double tmpf=(*ptr)-mean; variance+=tmpf*tmpf; }
-        variance = std::sqrt(variance/psize);
-      }
-    }
-    //! Assignement operator.
-    CImgStats& operator=(const CImgStats stats) {
-      min = stats.min;
-      max = stats.max;
-      mean = stats.mean;
-      variance = stats.variance;
-      return *this;
-    }
-    //! Print the current statistics on the standart error output.
-    const CImgStats& print(const char* title=NULL) const {
-      std::fprintf(stderr,"%-8s = { %g, %g [%g], %g }\n",title?title:"CImgStats",min,mean,variance,max);
-      return *this;
-    }
-
-#ifdef cimgstats_plugin
-#include cimgstats_plugin
-#endif
-
-  };
-
-  /*-------------------------------------------------------
-  
-
-
-
-    Definition of the CImgDisplay structure
-
-
-
-
-  ------------------------------------------------------*/
-  //! This class is used to create a display window, draw images into it and handle mouse and keyboard events.
-  /**
-     Creating a \c CImgDisplay instance opens a window that can be used to display a \c CImg<T> image
-     of a \c CImgl<T> image list inside. When a display is created, associated window events
-     (such as mouse motion, keyboard and window size changes) are handled and can be easily
-     detected by testing specific \c CImgDisplay data fields.
-     See \ref cimg_displays for a complete tutorial on using the \c CImgDisplay class.
-  **/
-
-  struct CImgDisplay {
-
-    //------------------------
-    //
-    // CImgDisplay variables
-    //
-    //------------------------
-
-    //! Variable representing the width of the display.
-    /**
-       Prefer using CImgDisplay::dimx() to get the width of the display.
-       
-       \note Using CImgDisplay::dimx() instead of \p width is more safe when doing arithmetics
-       involving the value of \p width, since it returns a \e signed int. Arithmetics with
-       \e unsigned types needs a lot of attention.
-
-       \note The variable \c width should be considered as read-only.
-       Setting a new value for \p CImgDisplay::width is done through CImgDisplay::resize().
-       Modifying directly \p width would probably result in a crash.
-
-       \see CImgDisplay::height, CImgDisplay::resize()
-    **/
-    unsigned int width;
-
-    //! Variable representing the height of the display.
-    /**
-       Prefer using CImgDisplay::dimy() to get the height of the display.
- 
-       \note Using CImgDisplay::dimy() instead of \p height is more safe when doing arithmetics
-       involving the value of \p height, since it returns a \e signed int. Artihmetics with
-       \e unsigned types needs a lot of attention.
-
-       \note The variable \c height should be considered as read-only.
-       Setting a new value for \p CImgDisplay::height is done through CImgDisplay::resize().
-       Modifying directly \p height would probably result in a crash.
-       
-       \see CImgDisplay::width, CImgDisplay::resize()
-    **/
-    unsigned int height;
-
-    //! Variable representing the width of the window associated to
-    //! the current display (should be considered as read-only)
-    /**
-       \note This is not the width of the display, but the width of the underlying system window.
-       This variable is updated when an user resized the window associated to the display.
-       When it occurs, \c width and \c window_width will be probably different.       
-       \see CImgDisplay::window_height, CImgDisplay::resized, CImgDisplay::resize().
-    **/
-    volatile unsigned int window_width;
-
-    //! Variable representing the height of the window associated to
-    //! the current display (should be considered as read-only)
-    /**
-       \note This is not the height of the display, but the height of the underlying system window.
-       This variable is updated when an user resized the window associated to the display.
-       When it occurs, \c height and \c window_height will be probably different.
-       \see CImgDisplay::window_width, CImgDisplay::resized, CImgDisplay::resize().
-    **/
-    volatile unsigned int window_height;
-
-    //! Variable defining the pixel normalization behavior of the display window (can be modified on the fly).
-    /**
-       It represents the way the pixel values are normalized for display purposes.
-       Its value can be set to :
-       - \c 0 : No pixel value normalization are performed (fastest). Be sure your image data are bounded in [0,255].
-       - \c 1 : Pixel value renormalization between [0,255] is done at each display request (default).
-       - \c 2 : Pixel value renormalization between [0,255] is done at the first display request. Then the
-       normalization parameters are kept and used for the next image display requests.
-       \note \c normalization is preferably set by invoking constructors CImgDisplay::CImgDisplay().
-       \see CImgDisplay::CImgDisplay(), CImgDisplay::display().
-    **/
-    unsigned int normalization;
-
-    //! Variable representing the type of events handled by the display window (should be considered as read-only).
-    /**
-       It represents what events are handled by the display. Its value can be set to :
-       - \c 0 : No events are handled by the display.
-       - \c 1 : Display closing and resizing are handled by the display.
-       - \c 2 : Display closing, resizing, mouse motion and buttons press, as well as key press are handled by the display.
-       - \c 3 : Display closing, resizing, mouse motion and buttons press/release, as well as key press/release
-       are handled by the display.
-       \note \c events if preferably set by invoking constructors CImgDisplay::CImgDisplay().
-       \see CImgDisplay::CImgDisplay(), CImgDisplay::mousex, CImgDisplay::mousey, CImgDisplay::key,
-       CImgDisplay::button, CImgDisplay::resized, CImgDisplay::closed.
-    **/
-    unsigned int events;
-
-    //! Variable indicating if the display is fullscreen (should be considered as read-only).
-    /**
-       If the display has been specified to be fullscreen at the construction, this variable is set to \c true.
-       \note This is only useful for Windows-based OS. Fullscreen is not yet supported on X11-based systems
-       and \c fullscreen will always be equal to \e false in this case.
-    **/
-    const bool fullscreen;
-
-    //! Variable representing the current x-coordinate of the mouse pointer over the display window
-    //! (should be considered as read-only).
-    /**
-       If CImgDisplay::events>=2, \p mousex represents the current x-coordinate of the mouse pointer.
-       - If the mouse pointer is outside the display window, \p mousex is equal to \p -1.
-       - If the mouse pointer is over the display window, \p mousex falls in the range [0,CImgDisplay::width-1],
-       where \p 0 corresponds to the far left coordinate and \p CImgDisplay::width-1 to the far right coordinate.
-       \note \p mousex is updated every 25 milliseconds, through an internal thread.
-       \see CImgDisplay::mousey, CImgDisplay::button
-    **/
-    volatile int mousex;
-
-    //! Variable representing the current y-coordinate of the mouse pointer over the display window.
-    //! (should be considered as read only).
-    /**
-       If CImgDisplay::events>=2, \p mousey represents the current y-coordinate of the mouse pointer.
-       - If the mouse pointer is outside the display window, \p mousey is equal to \p -1.
-       - If the mouse pointer is over the display window, \p mousey falls in the range [0,CImgDisplay::height-1],
-       where \p 0 corresponds to the far top coordinate and \p CImgDisplay::height-1 to the far bottom coordinate.
-       \note \p mousey is updated every 25 milliseconds, through an internal thread.
-       \see CImgDisplay::mousex, CImgDisplay::button
-    **/
-    volatile int mousey;
-
-    //! Variable representing the state of the mouse buttons when the mouse pointer is over the display window.
-    //! (should be considered as read only)
-    /**
-       If CImgDisplay::events>=2, \c button represents the current state of the mouse buttons.
-       - If the mouse pointer is outside the display window, \c button is equal to \c 0.
-       - If the mouse pointer is over the display window, \c button is a combination of the following bits :
-       - bit 0 : State of the left mouse button.
-       - bit 1 : State of the right mouse button.
-       - bit 2 : State of the middle mouse button.
-       - Other bits are unused.
-       \note
-       - \c button is updated every 25 milliseconds, through an internal thread.
-       - If CImgDisplay::events==2, you should re-init \p button to \p 0 after catching the
-       mouse button events, since it will NOT be done automatically (\p Mouse \p button \p Release event is
-       not handled in this case).
-       \see CImgDisplay::mousex, CImgDisplay::mousey
-    **/
-    volatile unsigned int button;
-
-    //! Variable representing the key pressed when mouse pointer is over the display window.
-    /**
-       If CImgDisplay::events>=2, \c key represents a raw integer value corresponding 
-       to the current pressed key.
-       - If no keys are pressed, \c key is equal to \p 0.
-       - If a key is pressed, \p key is a value representing the key. This raw value is \e OS-dependent.
-       Testing the \p key value directly with a raw integer will mostly result in incompabilities
-       between different plateforms. 
-       To bypass this problem, \b OS-independent \b keycodes are defined in the \p cimg:: namespace.
-       They are named as \p cimg::key*, where * stands for the key name :
-       \p cimg::keyESC, \p cimg::keyF1, \p cimg::key0, \p cimg::keyA, \p cimg::keySPACE, \p cimg::keySHIFTLEFT, etc...
-       \code
-       CImgDisplay disp(320,200,"Display");        // Create a display window with full events handling
-       ...
-       if (disp.key==cimg::keyESC) exit(0);        // Exit when pressing the ESC key.
-       ...
-       \endcode
-
-       \note 
-       - \p key is updated every 25 milliseconds, through an internal thread.
-       - If CImgDisplay::events==2, You should re-init the \c key variable to \c 0 after catching
-       the \p Key \p Pressed event, since it will NOT be done automatically (Key Release event is handled
-       only when \c CImgDisplay::events>=3).
- 
-       \see CImgDisplay::button, CImgDisplay::mousex, CImgDisplay::mousey
-    **/
-    volatile unsigned int key;
-
-    //! Variable representing the visibility state of the display window (should be read only).
-    /**
-       \p closed can be either true or false :
-       - \p false : The window is visible.
-       - \p true  : The window is hidden.
-     
-       If CImgDisplay::events>=1, \p closed is set to \p true when the user try to close the display window.
-       The way to set a value for \p closed is to use the functions :
-       - CImgDisplay::show(), to set \p closed to \p false.
-       - CImgDisplay::close(), to set \p closed to \p true.
-
-       Closing a display window DO NOT destroy the instance object. It simply \e hides the display window
-       and set the variable \p closed to true. You are then free to decide what to do
-       when this event occurs. For instance, the following code will re-open the window indefinitely 
-       when the user tries to close it :
-       \code
-       CImgDisplay disp(320,200,"Try to close me !");
-       for (;; disp.wait()) if (disp.closed) disp.show();
-       \endcode
-
-       \note - \p closed is updated every 25 milliseconds, through an internal thread.
-
-       \see CImgDisplay::show(), CImgDisplay::close().
-    **/
-    volatile bool closed;
-
-    //! Event-variable
-    volatile bool resized;
-
-    // Not documented, internal use only.
-    double min,max;
-
-    //------------------------
-    //
-    // CImgDisplay functions
-    //
-    //------------------------
-
-    //! Return the width of the display window, as a signed integer.
-    /** \note When working with resizing window, \p dimx() does not necessarily return the width of the resized window,
-        but the width of the internal data structure that can be used to display image.
-        Resizing a display window can be done with the function CImgDisplay::resize().
-      
-        \see CImgDisplay::width, CImgDisplay::dimy(), CImgDisplay::resize()     
-    **/
-    const int dimx() const { return (int)width; }
-
-    //! Return the height of the display window, as a signed integer.
-    /** \note When working with resizing window, \p dimy() does not necessarily return the height of the resized window,
-        but the height of the internal data structure that can be used to display image.
-        Resizing a display window can be done with the function CImgDisplay::resize().
-      
-        \see CImgDisplay::height, CImgDisplay::dimx(), CImgDisplay::resize()     
-    **/
-    const int dimy() const { return (int)height; }
-
-    // operator=(). It is actually defined to avoid its use, and throw a CImgDisplay exception.
-    CImgDisplay& operator=(const CImgDisplay&) {
-      throw CImgDisplayException("CImgDisplay()::operator=() : Assignement of CImgDisplay is not allowed. Use pointers instead !");
-      return *this;
-    }
-    
-    //! Synchronized waiting function. Same as cimg::wait().
-    /** \see cimg::wait()
-     **/
-      const CImgDisplay& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this; }
-
-    //! Display an image list CImgl<T> into a display window.
-    /** First, all images of the list are appended into a single image used for visualization,
-        then this image is displayed in the current display window.
-        \param list     : The list of images to display.
-        \param axe      : The axe used to append the image for visualization. Can be 'x' (default),'y','z' or 'v'.
-        \param align : Defines the relative alignment of images when displaying images of different sizes.
-        Can be '\p c' (centered, which is the default), '\p p' (top alignment) and '\p n' (bottom aligment).
-
-        \see CImg::append()
-    **/
-    template<typename T> CImgDisplay& display(const CImgl<T>& list,const char axe='x',const char align='c') { 
-      return display(list.get_append(axe,align)); 
-    } 
-
-    //! Resize a display window with the size of an image.
-    /** \param img    : Input image. \p image.width and \p image.height give the new dimensions of the display window.
-        \param redraw : If \p true (default), the current displayed image in the display window will
-        be bloc-interpolated to fit the new dimensions. If \p false, a black image will be drawn in the resized window.
-        \param force  : If \p true, the window size is effectively set to the specified dimensions (default).
-        If \p false, only internal data buffer to display images is resized, not the window itself.
-      
-        \see CImgDisplay::resized, CImgDisplay::resizedimx(), CImgDisplay::resizedimy()
-    **/
-    template<typename T> CImgDisplay& resize(const CImg<T>& img,const bool redraw=false,const bool force=true) { 
-      return resize(img.width,img.height,redraw,force); 
-    }
-
-    CImgDisplay& resize(const CImgDisplay& disp,const bool redraw=false,const bool force=true) {
-      return resize(disp.width,disp.height,redraw,force);
-    }
-
-    CImgDisplay& resize(const bool redraw=false,const bool force=false) {
-      resize(window_width,window_height,redraw,force);
-      return *this;
-    }
-
-    // When no display available
-    //---------------------------
-#if cimg_display_type==0
-    void nodisplay_available() {
-      static bool first = true;
-      if (first) {
-        cimg::warn(true,"CImgDisplay() : Display has been required but is not available (cimg_display_type=0)");
-        first = false;
-      }    
-    }  
-    //! Create a display window with a specified size \p pwidth x \p height.
-    /** \param width      : Width of the display window.
-        \param height     : Height of the display window.
-        \param title      : Title of the display window.
-        \param normalization_type  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param attributes : Attributes of the display window (see CImgDisplay::attributes).
-      
-        A black image will be initially displayed in the display window.
-    **/
-    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
-      nodisplay_available(); 
-    }
-
-    //! Create a display window from an image.
-    /** \param img        : Image that will be used to create the display window.
-        \param title      : Title of the display window
-        \param normalize  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param attributes : Attributes of the display window (see CImgDisplay::attributes).    
-    **/
-    template<typename T> 
-    CImgDisplay(const CImg<T>& img,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
-      nodisplay_available(); 
-    }
-
-    //! Create a display window from an image list.
-    /** \param list       : The list of images to display.
-        \param title      : Title of the display window
-        \param normalize  : Normalization type of the display window (see CImgDisplay::normalize).
-        \param attributes : Attributes of the display window (see CImgDisplay::attributes).     
-    **/
-    template<typename T> 
-    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):fullscreen(false) {
-      nodisplay_available(); 
-    }
-  
-    //! Create a display window by copying another one.
-    /** \param win   : Display window to copy.
-        \param title : Title of the new display window.
-    **/
-    CImgDisplay(const CImgDisplay& win, char *title=NULL):fullscreen(false) { nodisplay_available(); }
-
-    //! Resize a display window with new dimensions \p width and \p height.
-    CImgDisplay& resize(const int width, const int height,const bool redraw=false,const bool force=true) {
-      return *this; 
-    }
-    //! Destructor. Close and destroy a display.
-    ~CImgDisplay() {}
-    //! Fill the pixel data of the window buffer according to the image \p pimg.
-    template<typename T> void render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {}
-    //! Display an image in a window.
-    template<typename T> CImgDisplay& display(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=-1) { return *this; }
-    //! Wait for a window event
-    CImgDisplay& wait()  { return *this; }
-    //! Show a closed display
-    CImgDisplay& show()  { return *this; }
-    //! Close a visible display
-    CImgDisplay& close() { return *this; }
-  
-    // X11-based display
-    //------------------
-#elif cimg_display_type==1
-    unsigned long *data;
-    XImage *image;
-    Window window;
-  
-    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      width(dimw),height(dimh),window_width(dimw),window_height(dimh),
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      new_lowlevel(title);
-      std::memset(data,0,sizeof(unsigned long)*width*height);
-      pthread_mutex_lock(cimg::X11_mutex);
-      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-      XFlush(cimg::X11_display);
-      pthread_mutex_unlock(cimg::X11_mutex);
-    }
-
-    template<typename T> 
-    CImgDisplay(const CImg<T>& img,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimg_test(img,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_3dplanes(img.width/2,img.height/2,img.depth/2));
-      window_width  = width  = nimg.width;
-      window_height = height = nimg.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(nimg);
-    }
-
-    template<typename T> 
-    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimgl_test(list,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T> img0 = list.get_append('x'), 
-        &img = (img0.depth==1)?img0:(tmp=img0.get_3dplanes(img0.width/2,img0.height/2,img0.depth/2));
-      window_width  = width  = img.width; 
-      window_height = height = img.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(img);
-    }
-
-    CImgDisplay(const CImgDisplay& win, char *title="[Copy]"):
-      width(win.width),height(win.height),window_width(width),window_height(height),
-      normalization(win.normalization),events(win.events),fullscreen(win.fullscreen),
-      mousex(-1),mousey(-1),button(0),key(0),closed(win.closed),resized(false),min(win.min),max(win.max) {
-      new_lowlevel(title);
-      std::memcpy(data,win.data,sizeof(unsigned long)*width*height);
-      pthread_mutex_lock(cimg::X11_mutex);
-      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-      XFlush(cimg::X11_display);
-      pthread_mutex_unlock(cimg::X11_mutex);
-    }
-
-    CImgDisplay& resize(const int nwidth, const int nheight,const bool redraw=false,const bool force=true) {
-      const unsigned int
-        dimx=nwidth>0?nwidth:-width*nwidth/100,
-        dimy=nheight>0?nheight:-height*nheight/100;
-      if (!dimx || !dimy) return *this;
-      pthread_mutex_lock(cimg::X11_mutex);
-      if (dimx!=width || dimy!=height) {
-        unsigned long *ndata = new unsigned long[dimx*dimy];
-        if (redraw)
-          for (unsigned int y=0; y<dimy; y++) for (unsigned int x=0; x<dimx; x++) ndata[x+y*dimx] = data[x*width/dimx + width*(y*height/dimy)];
-        else std::memset(ndata,0,sizeof(unsigned long)*dimx*dimy);
-        data = ndata;
-        XDestroyImage(image);
-        image = XCreateImage(cimg::X11_display,DefaultVisual(cimg::X11_display,DefaultScreen(cimg::X11_display)),
-                             cimg::X11_nb_bits,ZPixmap,0,(char*)data,dimx,dimy,8,0);
-      }
-      width  = dimx;
-      height = dimy;
-      if (force && (window_width!=width || window_height!=height)) {
-        XResizeWindow(cimg::X11_display,window,width,height);
-        window_width  = width;
-        window_height = height;
-      }
-      XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-      XFlush(cimg::X11_display);
-      resized = false;
-      pthread_mutex_unlock(cimg::X11_mutex);
-      return *this;
-    }
-  
-    ~CImgDisplay() {
-      unsigned int i;
-      pthread_mutex_lock(cimg::X11_mutex);
-      for (i=0; i<cimg::X11_nb_wins && cimg::X11_wins[i]!=this; i++) i++;
-      for (; i<cimg::X11_nb_wins-1; i++) cimg::X11_wins[i]=cimg::X11_wins[i+1];
-      cimg::X11_nb_wins--;
-      XDestroyWindow(cimg::X11_display,window);
-      XDestroyImage(image);
-      if (!cimg::X11_nb_wins) {
-        pthread_cancel(*cimg::X11_event_thread);
-        pthread_join(*cimg::X11_event_thread,NULL);
-        XCloseDisplay(cimg::X11_display);
-        cimg::X11_display=NULL;
-        pthread_mutex_unlock(cimg::X11_mutex);
-        pthread_mutex_destroy(cimg::X11_mutex);
-        delete cimg::X11_event_thread;
-        delete cimg::X11_mutex;
-        delete cimg::X11_gc;
-      } else pthread_mutex_unlock(cimg::X11_mutex);
-    }
-  
-    void new_lowlevel(const char *title=NULL) {
-      cimg::warn(fullscreen,"CImgDisplay::new_lowlevel() : Fullscreen mode requested, but not supported on X11 Displays");
-      if (!cimg::X11_display) {
-        cimg::X11_nb_wins = 0;
-        cimg::X11_thread_finished = false;
-        cimg::X11_mutex = new pthread_mutex_t;
-        pthread_mutex_init(cimg::X11_mutex,NULL);
-        pthread_mutex_lock(cimg::X11_mutex);
-        cimg::X11_display = XOpenDisplay((getenv("DISPLAY") ? getenv("DISPLAY") : ":0.0"));
-        if (!cimg::X11_display) throw CImgDisplayException("CImgDisplay::new_lowlevel() : Can't open X11 display");
-        cimg::X11_nb_bits = DefaultDepth(cimg::X11_display, DefaultScreen(cimg::X11_display));
-        if (cimg::X11_nb_bits!=16 && cimg::X11_nb_bits!=24)
-          throw CImgDisplayException("CImgDisplay::new_lowlevel() : %u bits mode is not supported (only 16 and 24 bits are supported)",
-                                     cimg::X11_nb_bits);
-        cimg::X11_gc = new GC;
-        *cimg::X11_gc = DefaultGC(cimg::X11_display,DefaultScreen(cimg::X11_display));
-        Visual *visual = DefaultVisual(cimg::X11_display,0);
-	XVisualInfo vtemplate;
-	vtemplate.visualid = XVisualIDFromVisual(visual);
-	int nb_visuals;
-	XVisualInfo *vinfo = XGetVisualInfo(cimg::X11_display,VisualIDMask,&vtemplate,&nb_visuals);
-	if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11_colors_endian = true;
-        cimg::X11_event_thread = new pthread_t;
-        pthread_create(cimg::X11_event_thread,NULL,thread_lowlevel,NULL);
-      } else pthread_mutex_lock(cimg::X11_mutex);
-      window = XCreateSimpleWindow(cimg::X11_display,RootWindow(cimg::X11_display,DefaultScreen(cimg::X11_display)),0,0,width,height,2,0,0x0L);
-      data   = new unsigned long[width*height];
-      image  = XCreateImage(cimg::X11_display,DefaultVisual(cimg::X11_display,DefaultScreen(cimg::X11_display)),cimg::X11_nb_bits,ZPixmap,0,(char*)data,width,height,8,0);
-      XStoreName(cimg::X11_display,window,title?title:"");
-      if (!closed) {
-        XEvent event;
-        XSelectInput(cimg::X11_display,window,StructureNotifyMask);
-        XMapWindow(cimg::X11_display,window);
-        do XWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event); while (event.type!=MapNotify);
-      }
-      if (events) { 
-        Atom atom = XInternAtom(cimg::X11_display, "WM_DELETE_WINDOW", False); 
-        XSetWMProtocols(cimg::X11_display, window, &atom, 1); 
-      }
-      cimg::X11_wins[cimg::X11_nb_wins++]=this;
-      pthread_mutex_unlock(cimg::X11_mutex);
-    }
-  
-    void proc_lowlevel(XEvent *pevent) {
-      const unsigned int buttoncode[3] = { 1,4,2 };
-      XEvent event=*pevent;
-      switch (event.type) {
-      case ClientMessage:
-        XUnmapWindow(cimg::X11_display,window);
-        mousex=mousey=-1; 
-	button=key=0;
-	closed=true; 
-        break;
-     case ConfigureNotify: {
-        while (XCheckWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event));
-        const unsigned int nw = event.xconfigure.width, nh = event.xconfigure.height;
-        if (nw && nh && (nw!=window_width || nh!=window_height)) { 
-          window_width = nw; 
-          window_height = nh; 
-	  mousex = mousey = -1;
-	  //button = key=0;
-          XResizeWindow(cimg::X11_display,window,window_width,window_height);
-          resized = true;
-        }
-      } break;
-      case Expose:
-        while (XCheckWindowEvent(cimg::X11_display,window,ExposureMask,&event));
-        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-        break;
-      case ButtonPress:
-        while (XCheckWindowEvent(cimg::X11_display,window,ButtonPressMask,&event));
-        button |= buttoncode[event.xbutton.button-1];
-        break;
-      case ButtonRelease:
-        while (XCheckWindowEvent(cimg::X11_display,window,ButtonReleaseMask,&event));
-        button &= ~buttoncode[event.xbutton.button-1];
-        break;
-      case KeyPress: {
-        while (XCheckWindowEvent(cimg::X11_display,window,KeyPressMask,&event));
-	char tmp;
-	KeySym ksym;
-	XLookupString(&event.xkey,&tmp,1,&ksym,NULL);
-	key = (unsigned int)ksym;
-      }
-        break;
-      case KeyRelease:
-        while (XCheckWindowEvent(cimg::X11_display,window,KeyReleaseMask,&event));
-        key = 0;
-        break;
-      case LeaveNotify:
-        while (XCheckWindowEvent(cimg::X11_display,window,LeaveWindowMask,&event));
-        mousex = mousey =-1; 
-        break;
-      case MotionNotify:
-        while (XCheckWindowEvent(cimg::X11_display,window,PointerMotionMask,&event));
-        mousex = event.xmotion.x; 
-        mousey = event.xmotion.y;
-        if (mousex<0 || mousey<0 || mousex>=dimx() || mousey>=dimy()) mousex=mousey=-1; 
-        break;
-      }
-    }
-  
-    static void* thread_lowlevel(void *arg) {
-      XEvent event;
-      pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,NULL);
-      for (;;) {
-        pthread_mutex_lock(cimg::X11_mutex);
-        for (unsigned int i=0; i<cimg::X11_nb_wins; i++) {
-          const unsigned int xevent_type = (cimg::X11_wins[i]->events)&3;
-          const unsigned int emask =
-            ((xevent_type>=1)?ExposureMask|StructureNotifyMask:0)|
-            ((xevent_type>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
-            ((xevent_type>=3)?ButtonReleaseMask|KeyReleaseMask:0);
-          XSelectInput(cimg::X11_display,cimg::X11_wins[i]->window,emask);
-        }
-        bool event_flag = XCheckTypedEvent(cimg::X11_display, ClientMessage, &event);
-        if (!event_flag) event_flag = XCheckMaskEvent(cimg::X11_display,
-                                                      ExposureMask|StructureNotifyMask|ButtonPressMask|
-                                                      KeyPressMask|PointerMotionMask|LeaveWindowMask|ButtonReleaseMask|
-                                                      KeyReleaseMask,&event);
-        if (event_flag) {
-          for (unsigned int i=0; i<cimg::X11_nb_wins; i++)
-            if (!cimg::X11_wins[i]->closed && event.xany.window==cimg::X11_wins[i]->window) cimg::X11_wins[i]->proc_lowlevel(&event);
-          cimg::X11_thread_finished = true;
-        }
-        pthread_mutex_unlock(cimg::X11_mutex);
-        cimg::wait(25);
-      }
-      return NULL;
-    }
-
-    template<typename T> XImage* render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {
-      cimg_test(img,"CImgDisplay::render");
-      if (img.depth!=1) return render(img.get_3dplanes(img.width/2,img.height/2,img.depth/2),0,~0);
-      if (img.width!=width || img.height!=height) return render(img.get_resize(width,height,1,-100,1),0,~0);
-      const bool by=(ymin<=ymax);
-      const unsigned int nymin = by?ymin:ymax, nymax = by?(ymax>=height?height-1:ymax):(ymin>=height?height-1:ymin), w=width;
-      const T 
-        *data1 = img.ptr(0,nymin,0,0),
-        *data2 = (img.dim>=2)?img.ptr(0,nymin,0,1):data1,
-        *data3 = (img.dim>=3)?img.ptr(0,nymin,0,2):data1;
-      if (cimg::X11_colors_endian) cimg::swap(data1,data3);
-      pthread_mutex_lock(cimg::X11_mutex);
-      XImage *ximg = image;
-      if (!normalization) {
-        switch (cimg::X11_nb_bits) {
-        case 16: 
-          for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            XPutPixel(ximg,x,y,(((unsigned char)*(data1++)>>3)<<11) | (((unsigned char)*(data2++)>>2)<<5) | ((unsigned char)*(data3++)>>3)); 
-          }
-          break;
-        case 24: 
-          for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            XPutPixel(ximg,x,y,((unsigned char)*(data1++)<<16)      | ((unsigned char)*(data2++)<<8)      | (unsigned char)*(data3++)     ); 
-          }
-          break;
-        };
-      } else {
-        if (normalization==1) { CImgStats st(img,false); min=st.min; max=st.max; }
-        const T nmin = (T)min, delta = (T)max-nmin, mm=delta?delta:(T)1;
-        switch (cimg::X11_nb_bits) {
-        case 16: for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            const unsigned char
-              val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
-              val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
-              val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
-            XPutPixel(ximg,x,y,((val1>>3)<<11) | ((val2>>2)<<5) | (val3>>3));
-          }
-          break;
-        case 24: for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-            const unsigned char
-              val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
-              val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
-              val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
-            XPutPixel(ximg,x,y,(val1<<16) | (val2<<8) | val3);
-          }
-          break;
-        } 
-      }
-      pthread_mutex_unlock(cimg::X11_mutex);
-      return image;
-    }
-
-    template<typename T> CImgDisplay& display(const CImg<T>& pimg,const unsigned int pymin=0,const unsigned int pymax=~0) {
-      const unsigned int
-        ymin = pymin<pymax?pymin:pymax,
-        ymax = pymin<pymax?(pymax>=height?height-1:pymax):(pymin>=height?height-1:pymin);
-      render(pimg,ymin,ymax);
-      if (!closed) {      
-        pthread_mutex_lock(cimg::X11_mutex);
-        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,ymin,0,ymin,width,ymax-ymin+1);
-        XFlush(cimg::X11_display);
-        pthread_mutex_unlock(cimg::X11_mutex);
-      }
-      return *this;
-    }
-  
-    CImgDisplay& wait() {
-      if (!closed && events) {
-        XEvent event;
-        do {
-          pthread_mutex_lock(cimg::X11_mutex);
-          const unsigned int 
-            emask = ExposureMask|StructureNotifyMask|
-            ((events>=2)?ButtonPressMask|KeyPressMask|PointerMotionMask|LeaveWindowMask:0)|
-            ((events>=3)?ButtonReleaseMask|KeyReleaseMask:0);
-          XSelectInput(cimg::X11_display,window,emask);
-          XPeekEvent(cimg::X11_display,&event);
-          cimg::X11_thread_finished = false;
-          pthread_mutex_unlock(cimg::X11_mutex);
-        } while (event.xany.window!=window);
-        while (!cimg::X11_thread_finished) cimg::wait(25);
-      }
-      return *this;
-    }
-
-    CImgDisplay& show() {
-      if (closed) {
-        pthread_mutex_lock(cimg::X11_mutex);
-        XEvent event;
-        XSelectInput(cimg::X11_display,window,StructureNotifyMask);
-        XMapWindow(cimg::X11_display,window);
-        do XWindowEvent(cimg::X11_display,window,StructureNotifyMask,&event);
-        while (event.type!=MapNotify);
-        XPutImage(cimg::X11_display,window,*cimg::X11_gc,image,0,0,0,0,width,height);
-        XFlush(cimg::X11_display);
-        closed = false;
-        pthread_mutex_unlock(cimg::X11_mutex);
-      }
-      return *this;
-    }
-    CImgDisplay& close() {
-      if (!closed) {
-        pthread_mutex_lock(cimg::X11_mutex);
-        XUnmapWindow(cimg::X11_display,window);
-        XFlush(cimg::X11_display);
-        closed = true;
-        pthread_mutex_unlock(cimg::X11_mutex);
-      }
-      return *this;
-    }
-  
-    // Windows-based display
-    //-----------------------
-#elif cimg_display_type==2
-    CLIENTCREATESTRUCT ccs;
-    BITMAPINFO bmi;
-    unsigned int *data;
-    DEVMODE curr_mode;
-    HWND window;
-    HDC hdc;
-    HANDLE thread;
-    HANDLE wait_disp;
-    HANDLE created;
-    HANDLE mutex;
-
-    CImgDisplay(const unsigned int dimw,const unsigned int dimh,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      width(dimw),height(dimh),window_width(dimw),window_height(dimh),
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      new_lowlevel(title);
-      std::memset(data,0,sizeof(unsigned int)*width*height);
-      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-    }
-
-    template<typename T>
-    CImgDisplay(const CImg<T>& img,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimg_test(img,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T>& nimg = (img.depth==1)?img:(tmp=img.get_3dplanes(img.width/2,img.height/2,img.depth/2));
-      window_width  = width  = nimg.width;
-      window_height = height = nimg.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(nimg);
-    }
-
-    template<typename T>
-    CImgDisplay(const CImgl<T>& list,const char *title=NULL,
-                const unsigned int normalization_type=1,const unsigned int events_type=3,
-                const bool fullscreen_flag=false,const bool closed_flag=false):
-      normalization(normalization_type&3),events(events_type&3),fullscreen(fullscreen_flag),
-      mousex(-1),mousey(-1),button(0),key(0),closed(closed_flag),resized(false),min(0),max(0) {
-      cimgl_test(list,"CImgDisplay::CImgDisplay");
-      CImg<T> tmp;
-      const CImg<T> img0 = list.get_append('x'),
-        &img = (img0.depth==1)?img0:(tmp=img0.get_3dplanes(img0.width/2,img0.height/2,img0.depth/2));
-      window_width  = width  = img.width;
-      window_height = height = img.height;
-      if (normalization==2) { CImgStats st(img,false); min=st.min; max=st.max; }
-      new_lowlevel(title);
-      display(img);
-    }
-
-    CImgDisplay(const CImgDisplay& win, char *title="[Copy]"):
-      width(win.width),height(win.height),window_width(win.width),window_height(win.height),
-      normalization(win.normalization),events(win.events),fullscreen(win.fullscreen),
-      mousex(-1),mousey(-1),button(0),key(0),closed(win.closed),resized(false),min(win.min),max(win.max) {
-      new_lowlevel(title);
-      std::memcpy(data,win.data,sizeof(unsigned int)*width*height);
-      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-    }
-
-    CImgDisplay& resize(const int nwidth, const int nheight,const bool redraw=false,const bool force=true) {
-      const unsigned int
-        dimx=nwidth>0?nwidth:(-nwidth)*width/100,
-        dimy=nheight>0?nheight:(-nheight)*height/100;
-      if (!dimx || !dimy) return *this;
-      if (dimx!=width || dimy!=height) {
-        unsigned int *ndata = new unsigned int[dimx*dimy];
-        if (redraw) 
-          for (unsigned int y=0; y<dimy; y++) for (unsigned int x=0; x<dimx; x++) ndata[x+y*dimx] = data[x*width/dimx + width*(y*height/dimy)];
-        else std::memset(ndata,0x80,sizeof(unsigned int)*dimx*dimy);
-        delete[] data;
-        data = ndata;
-        bmi.bmiHeader.biWidth=dimx;
-        bmi.bmiHeader.biHeight=-(int)dimy;
-      }
-      width  = dimx;
-      height = dimy;
-      if (force && (window_width!=width || window_height!=height)) {
-        int cwidth,cheight;
-        RECT rect;
-        rect.left=rect.top=0; rect.right=width-1; rect.bottom=height-1;
-        if (AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false)) {
-          cwidth = rect.right-rect.left+1; cheight = rect.bottom-rect.top+1;
-        } else { cwidth = width+9; cheight = height+28; }
-        SetWindowPos(window,0,0,0,cwidth,cheight,SWP_NOMOVE | SWP_NOZORDER | SWP_NOCOPYBITS);
-        window_width  = dimx;
-        window_height = dimy;
-      }
-      SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-      resized = false;
-      return *this;
-    }
-
-    ~CImgDisplay() {
-      DestroyWindow(window);
-      if (events) TerminateThread(thread,0);
-      delete[] data;
-      if (curr_mode.dmSize) ChangeDisplaySettings(&curr_mode,0);
-    }
-  
-    void new_lowlevel(const char *title=NULL) {
-      unsigned long ThreadID;
-      DEVMODE mode;
-      unsigned int imode=0,ibest=0,bestbpp=0;
-      void *arg = (void*)(new void*[2]);
-      ((void**)arg)[0]=(void*)this;
-      ((void**)arg)[1]=(void*)title;
-      if (fullscreen) {
-        for (mode.dmSize = sizeof(DEVMODE), mode.dmDriverExtra = 0; EnumDisplaySettings(NULL,imode,&mode); imode++)
-          if (mode.dmPelsWidth==width && mode.dmPelsHeight==height && mode.dmBitsPerPel>bestbpp) {
-            bestbpp = mode.dmBitsPerPel;
-            ibest=imode; 
-          }
-        cimg::warn(!bestbpp,"CImgDisplay::new_lowlevel() : Could not initialize fullscreen mode %ux%u\n",width,height);
-        if (bestbpp) {
-          curr_mode.dmSize = sizeof(DEVMODE); curr_mode.dmDriverExtra = 0;
-          EnumDisplaySettings(NULL,ENUM_CURRENT_SETTINGS,&curr_mode);
-          EnumDisplaySettings(NULL,ibest,&mode);
-          ChangeDisplaySettings(&mode,0);
-        }
-        else curr_mode.dmSize = 0;
-      }
-      else curr_mode.dmSize = 0;
-      if (events) {
-        mutex     = CreateMutex(NULL,FALSE,NULL);
-        created   = CreateEvent(NULL,FALSE,FALSE,NULL);
-        wait_disp = CreateEvent(NULL,FALSE,FALSE,NULL);
-        thread    = CreateThread(NULL,0,thread_lowlevel,arg,0,&ThreadID);
-        WaitForSingleObject(created,INFINITE);
-      } else thread_lowlevel(arg);
-    }
-  
-    static LRESULT APIENTRY proc_lowlevel(HWND window,UINT msg,WPARAM wParam,LPARAM lParam) {
-      CImgDisplay* disp = (CImgDisplay*)GetWindowLong(window,GWL_USERDATA);
-      MSG st_msg;
-
-      switch(msg) {
-      case WM_CLOSE:
-	disp->mousex=disp->mousey=-1;
-	disp->key=disp->button=0;
-        disp->closed=true;
-        ReleaseMutex(disp->mutex);
-        ShowWindow(disp->window,SW_HIDE);
-        return 0;
-      case WM_SIZE: {
-        while (PeekMessage(&st_msg,window,WM_SIZE,WM_SIZE,PM_REMOVE));
-        WaitForSingleObject(disp->mutex,INFINITE);
-        const unsigned int nw = LOWORD(lParam), nh = HIWORD(lParam);
-        if (nw && nh && (nw!=disp->width || nh!=disp->height)) { 
-          disp->window_width  = nw; 
-          disp->window_height = nh;
-	  disp->mousex = disp->mousey = -1;
-          disp->resized = true;
-        }
-        ReleaseMutex(disp->mutex);
-      }
-        break;
-      case WM_PAINT:
-        WaitForSingleObject(disp->mutex,INFINITE);
-        SetDIBitsToDevice(disp->hdc,0,0,disp->width,disp->height,0,0,0,disp->height,disp->data,&(disp->bmi),DIB_RGB_COLORS);
-        ReleaseMutex(disp->mutex);
-        break;
-      }
-      if (disp->events>=2) switch(msg) {
-      case WM_KEYDOWN:
-        while (PeekMessage(&st_msg,window,WM_KEYDOWN,WM_KEYDOWN,PM_REMOVE)); 
-        disp->key=(int)wParam;
-        break;
-      case WM_MOUSEMOVE: {
-        while (PeekMessage(&st_msg,window,WM_MOUSEMOVE,WM_MOUSEMOVE,PM_REMOVE));
-        disp->mousex = LOWORD(lParam);
-        disp->mousey = HIWORD(lParam);
-        if (disp->mousex<0 || disp->mousey<0 ||	disp->mousex>=disp->dimx() || disp->mousey>=disp->dimy())
-	  disp->mousex=disp->mousey=-1;
-      }
-        break;
-      case WM_LBUTTONDOWN: 
-        while (PeekMessage(&st_msg,window,WM_LBUTTONDOWN,WM_LBUTTONDOWN,PM_REMOVE));
-        disp->button |= 1; 
-        break;
-      case WM_RBUTTONDOWN: 
-        while (PeekMessage(&st_msg,window,WM_RBUTTONDOWN,WM_RBUTTONDOWN,PM_REMOVE));
-        disp->button |= 2; 
-        break;
-      case WM_MBUTTONDOWN: 
-        while (PeekMessage(&st_msg,window,WM_MBUTTONDOWN,WM_MBUTTONDOWN,PM_REMOVE));
-        disp->button |= 4; 
-        break;
-      }
-      if (disp->events>=3) switch(msg) {
-      case WM_KEYUP:
-        while (PeekMessage(&st_msg,window,WM_KEYUP,WM_KEYUP,PM_REMOVE));
-        disp->key=0;
-        break;
-      case WM_LBUTTONUP:
-        while (PeekMessage(&st_msg,window,WM_LBUTTONUP,WM_LBUTTONUP,PM_REMOVE));
-        disp->button &= ~1; 
-        break;
-      case WM_RBUTTONUP:
-        while (PeekMessage(&st_msg,window,WM_RBUTTONUP,WM_RBUTTONUP,PM_REMOVE)); 
-        disp->button &= ~2;
-        break;
-      case WM_MBUTTONUP:
-        while (PeekMessage(&st_msg,window,WM_MBUTTONUP,WM_MBUTTONUP,PM_REMOVE)); 
-        disp->button &= ~4;
-        break;
-      }
-      return DefWindowProc(window,msg,wParam,lParam);
-    }
-  
-    static DWORD WINAPI thread_lowlevel(void* arg) {
-      CImgDisplay *disp  = (CImgDisplay*)(((void**)arg)[0]);
-      const char *title = (const char*)(((void**)arg)[1]);
-      MSG msg;
-      delete[] (void**)arg;
-      disp->bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
-      disp->bmi.bmiHeader.biWidth=disp->width;
-      disp->bmi.bmiHeader.biHeight=-(int)disp->height;
-      disp->bmi.bmiHeader.biPlanes=1;
-      disp->bmi.bmiHeader.biBitCount=32;
-      disp->bmi.bmiHeader.biCompression=BI_RGB;
-      disp->bmi.bmiHeader.biSizeImage=0;
-      disp->bmi.bmiHeader.biXPelsPerMeter=1;
-      disp->bmi.bmiHeader.biYPelsPerMeter=1;
-      disp->bmi.bmiHeader.biClrUsed=0;
-      disp->bmi.bmiHeader.biClrImportant=0;
-      disp->data = new unsigned int[disp->width*disp->height];
-      if (!disp->curr_mode.dmSize) {
-        int cwidth,cheight;
-        RECT rect;
-        rect.left=rect.top=0; rect.right=disp->width-1; rect.bottom=disp->height-1;
-        if (AdjustWindowRect(&rect,WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,false)) {
-          cwidth = rect.right-rect.left+1; cheight = rect.bottom-rect.top+1;
-        } else { cwidth = disp->width+9; cheight = disp->height+28; }
-        disp->window = CreateWindow("MDICLIENT",title?title:"",
-                                    WS_OVERLAPPEDWINDOW | WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,
-                                    cwidth,cheight,NULL,NULL,NULL,&(disp->ccs));
-      }
-      else disp->window = CreateWindow("MDICLIENT",title?title:"",
-                                       WS_POPUP | WS_VISIBLE, CW_USEDEFAULT,CW_USEDEFAULT,
-                                       disp->width,disp->height,NULL,NULL,NULL,&(disp->ccs));
-      SetForegroundWindow(disp->window);
-      disp->hdc = GetDC(disp->window);
-      if (disp->events) {
-        SetWindowLong(disp->window,GWL_USERDATA,(LONG)disp);
-        SetWindowLong(disp->window,GWL_WNDPROC,(LONG)proc_lowlevel);
-        SetEvent(disp->created);
-        while( GetMessage( &msg, NULL, 0, 0 ) ) { DispatchMessage( &msg ); SetEvent(disp->wait_disp); }
-      }
-      return 0;
-    }
-
-    template<typename T> BITMAPINFO* render(const CImg<T>& img,const unsigned int ymin=0,const unsigned int ymax=~0) {
-      cimg_test(img,"CImgDisplay::render");
-      if (img.depth!=1) return render(img.get_3dplanes(img.width/2,img.height/2,img.depth/2),(unsigned int)0,~(unsigned int)0);
-      if (img.width!=width || img.height!=height) return render(img.get_resize(width,height,1,-100,1),(unsigned int)0,~(unsigned int)0);
-      const bool by=(ymin<=ymax);
-      const unsigned int nymin = by?ymin:ymax, nymax = by?(ymax>=height?height-1:ymax):(ymin>=height?height-1:ymin), w=width;
-      const T 
-        *data1 = img.ptr(0,nymin,0,0),
-        *data2 = (img.dim>=2)?img.ptr(0,nymin,0,1):data1,
-        *data3 = (img.dim>=3)?img.ptr(0,nymin,0,2):data1;
-      unsigned int *ximg = data + nymin*width;
-      WaitForSingleObject(mutex,INFINITE);
-      if (!normalization)
-        for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++)
-          *(ximg++) = ((unsigned char)*(data1++)<<16) | ((unsigned char)*(data2++)<<8) | (unsigned char)*(data3++);
-      else {
-        if (normalization==1) { CImgStats st(img,false); min=st.min; max=st.max; }
-        const T nmin = (T)min, delta = (T)(max-nmin), mm = delta?delta:(T)1;
-        for (unsigned int y=nymin; y<=nymax; y++) for (unsigned int x=0; x<w; x++) {
-          const unsigned char
-            val1 = (unsigned char)(255*(*(data1++)-nmin)/mm),
-            val2 = (unsigned char)(255*(*(data2++)-nmin)/mm),
-            val3 = (unsigned char)(255*(*(data3++)-nmin)/mm);
-          *(ximg++) = (val1<<16) | (val2<<8) | (val3);
-        }
-      }
-      ReleaseMutex(mutex);
-      return &bmi;
-    }
-
-    template<typename T> CImgDisplay& display(const CImg<T>& img,const unsigned int pymin=0,const unsigned int pymax=~0) {
-      cimg_test(img,"CImgDisplay::display");
-      const unsigned int 
-        ymin = pymin<pymax?pymin:pymax,
-        ymax = pymin<pymax?(pymax>=height?height-1:pymax):(pymin>=height?height-1:pymin);
-      render(img,ymin,ymax);
-      if (!closed) {
-        WaitForSingleObject(mutex,INFINITE);
-        SetDIBitsToDevice(hdc,0,ymin,width,ymax-ymin+1,0,0,0,ymax-ymin+1,data+ymin*width,&bmi,DIB_RGB_COLORS);
-        ReleaseMutex(mutex);
-      }
-      return *this;
-    }
-  
-    CImgDisplay& wait() {
-      if (!closed && events) WaitForSingleObject(wait_disp,INFINITE);
-      return *this;
-    }
-
-    CImgDisplay& show() {
-      if (closed) {
-        ShowWindow(window,SW_SHOW);
-        SetDIBitsToDevice(hdc,0,0,width,height,0,0,0,height,data,&bmi,DIB_RGB_COLORS);
-        closed = false;
-      }
-      return *this;
-    }
-
-    CImgDisplay& close() {
-      if (!closed) {
-        ShowWindow(window,SW_HIDE);
-        closed = true;
-      }
-      return *this;
-    }
-#endif
-
-#ifdef cimgdisplay_plugin
-#include cimgdisplay_plugin
-#endif
- 
-  };
-
-
-  /*-------------------------------------------------------
-
-
-
-  
-    Definition of the CImg<T> structure
-	
-	
-	
-	
-  ------------------------------------------------------*/
-
-  //! This structure represents an image (up to 4 dimensions wide), with pixels of type \c T.
-  /**
-     This is the main structure of the CImg Library. It allows to define an image,
-     access its pixel values, and perform various operations on it.
-
-     <b>* Image structure</b>
-
-     A \ref CImg<\c T> structure contains only five fields :
-     - \ref width defines the number of columns of the image.
-     - \ref height defines the number of rows of the image.
-     - \ref depth defines the number of slices of the image.
-     - \ref dim defines the number of channels of the image.
-     - \ref data defines a pointer to the pixel data (of type \c T).
-     
-     You can access these fields publicly although it is recommended to use dedicated functions
-     dimx(), dimy(), dimz(), dimv() and ptr() to do so.     
-     Image dimensions are not limited to a specific range (as long as you got enough RAM).
-     A value of \e 1 usually means that the corresponding dimension is 'flat'.
-     If one dimension is \e 0, the image is considered as an \e empty image.
-     Empty images do not contain pixel data and thus, are not processed by most of CImg member functions.
-     Most of the CImg<T> member functions are designed to work on images with general dimensions.     
-
-     <b>* Image declaration</b>
-
-     Declaration of an image uses one of the several available constructors. Below is a list of
-     the most used :
-     - Construct images from dimensions :
-         - <tt>CImg<char> img;</tt> constructs an empty image.
-         - <tt>CImg<unsigned char> img(128,128);</tt> constructs a 128x128 greyscale image with \c unsigned \c char pixel values.
-         - <tt>CImg<double> img(3,3);</tt> constructs  a 3x3 matrix with \c double coefficients.
-         - <tt>CImg<unsigned char> img(256,256,1,3);</tt> for a 256x256x1x3 (color) image (colors are stored as three channels).
-         - <tt>CImg<double> img(128,128,128);</tt> for a 128x128x128 volumetric (greyscale) image (with \c double pixel values).
-         - <tT>CImg<> img(128,128,128,3);</tt> for a 128x128x128 volumetric color image (with \c float pixels, which is
-	 the default value of the template parameter \c T).
-	 - \b Note : images pixels are <b>not automatically initialized to 0</b>. You may use the function \ref fill() to
-	 do it.
-     - Construct images from filenames :
-         - <tt>CImg<unsigned char> img("image.jpg");</tt> reads a color image from the disk.
-	 - <tt>CImg<float> img("analyze.hdr");</tt> reads a volumetric image with float pixel (ANALYZE7.5 format).
-	 - \b Note : You will need to install ImageMagick to be able to read compressed image formats (JPG,PNG,...)
-     - Construct images from C-arrays :
-         - <tt>CImg<int> img(data_buffer,256,256);</tt> convert a \c int buffer \c data_buffer to a 256x256 greyscale image.     
-
-     More constructors are available (copy constructor,...). Please look at the constructor list for more
-     informations.
-
-  
-  A CImg image is defined as a template class CImg<T> containing a pixel data field with a maximum of 4 dimensions :
-  the 3 first dimensions are usually used to describe the spatial coordinates <tt>(x,y,z)</tt> in the image, while the last one
-  is often used as a vector-valued pixel dimension (color channel for instance). Then, this class can handle the case of 3D volumes
-  of vector-valued pixels, and all images that requires less dimensions (gray-valued or color 2D images for instance). 
-  It also means that (almost) all member functions of the class CImg<T> are designed to handle the maximum case of these (3+1) dimensions.
-
-  Moreover, the pixel type is given by the template parameter T, which means that you can define images with different pixel types T.
-  Fully supported template types are the basic C++ types : <tt>unsigned char, char, short, unsigned int, int, float, double, ... </tt>
-  Using your own template types is possible however, but you will have to redefine the complete set of arithmetic and logical operators.
-  Typically, fast image display would be done using <tt>CImg<unsigned char></tt> images, while complex image processing algorithms would be coded
-  using <tt>CImg<float></tt> or <tt>CImg<double></tt> images which have floating-point pixel values. Only two others classes are defined
-  in the <tt>CImg.h</tt> file : <tt>CImgStats</tt> that is used to represent image statistics, and <tt>CImgDisplay</tt> used to open 
-  windows where images are displayed, and handle keyboard and mouse events.
-
-  CImg has been designed to be 'user-friendly', meaning that the underlying structure of the classes is always quite basic to understand.
-  For instance, the <tt>CImg<T></tt> class members (which are defined as public) are only the dimensions
-  <tt>width, height, depth, dim</tt>, and the pixel data <tt>data</tt>. Very useful when you want to access the raw pixel buffer
-  for calling with functions of other libraries, or when you want to convert your raw data buffer into a <tt>CImg</tt>,
-  in order to visualize it for instance. Moreover, most of the classical arithmetic and logical operators have been redefined
-  in the <tt>CImg<T> class</tt>, which means that accessing a pixel is as simple as <tt>image(x,y)</tt> or <tt>image(x,y,z,v)</tt> (in 4D),
-  and beautiful things are possible such as <tt>(img1+3*img2).display();</tt>
-
-
-     \see \ref cimg_structure
-  **/
-  template<typename T> struct CImg {
-    
-    //! Number of columns in the instance image (size along the X-axis).
-    /**
-       \note
-       - Prefer using CImg<T>::dimx() to get the width of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::width would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::width==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int width;       
-    
-    //! Number of rows in the instance image (size along the Y-axis).
-    /**
-       \note 
-       - Prefer using CImg<T>::dimy() to get the height of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::height would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::height==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int height;
-    
-    //! Number of slices in the instance image (size along the Z-axis).
-    /**
-       \note 
-       - Prefer using CImg<T>::dimz() to get the depth of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::depth would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::depth==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int depth;
-    
-    //! Number of vector channels in the instance image (size along the V-axis).
-    /**
-       \note 
-       - Prefer using CImg<T>::dimv() to get the depth of the instance image.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::dim would probably
-       result in a crash.
-       - This value can be modified through the CImg<T>::resize() function.
-       - If CImg<T>::dim==0, the image is empty and contains no pixel data.
-    **/
-    unsigned int dim;
-    
-    //! Pointer to pixel values (array of elements \c T).
-    /**
-       \note
-       - Prefer using CImg<T>::ptr() to get a pointer to the pixel buffer.
-       - Should be considered as \e read-only. Modifying directly \c CImg<T>::data would probably
-       result in a crash.
-       - If CImg<T>::data==NULL, the image is empty and contains no pixel data.
-       \see \ref cimg_storage
-    **/
-    T *data;
-
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Constructors - Destructor - Copy
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-  
-    //! Create an image of size (\c dx,\c dy,\c dz,\c dv) with pixels of type \c T.
-    /**
-       \param dx = number of columns of the created image (size along the X-axis).
-       \param dy = number of rows of the created image (size along the Y-axis).
-       \param dz = number of slices of the created image (size along the Z-axis).
-       \param dv = number of vector channels of the created image (size along the V-axis).
-       \note 
-       - Pixel values are \e not \e initialized by this constructor.
-       - If invoked without parameters, this constructor creates an \e empty image (default constructor).
-    **/
-    explicit CImg(const unsigned int dx=0,const unsigned int dy=1,const unsigned int dz=1,const unsigned int dv=1):
-      width(dx),height(dy),depth(dz),dim(dv) {
-      const unsigned int siz = size();
-      if (siz) data = new T[siz]; else { data=NULL; width=height=depth=dim=0; }
-    }
-
-    //! Create an image of size (\c dx,\c dy,\c dz,\c dv) with pixels of type \c T,
-    //! and set the image pixels to the value \c val.
-    /**
-       \param dx = number of columns of the created image (size along the X-axis).
-       \param dy = number of rows of the created image (size along the Y-axis).
-       \param dz = number of slices of the created image (size along the Z-axis).
-       \param dv = number of vector channels of the created image (size along the V-axis).
-    **/    
-    explicit CImg(const unsigned int dx,const unsigned int dy,const unsigned int dz,const unsigned int dv,const T& val):
-      width(dx),height(dy),depth(dz),dim(dv) {
-      const unsigned int siz = size();
-      if (siz) { data = new T[siz]; fill(val); } else { data=NULL; width=height=depth=dim=0; }
-    }
-
-    //! Copy constructor.
-    /**
-       \param img = the image to copy.
-    **/
-    template<typename t> CImg(const CImg<t>& img):width(img.width),height(img.height),depth(img.depth),dim(img.dim) {
-      const unsigned int siz = size();
-      if (siz) {
-        data = new T[siz];
-        const t *ptrs = img.data + siz;
-        cimg_map(*this,ptrd,T) (*ptrd)=(T)*(--ptrs);
-      } else data = NULL;
-    }
-    CImg(const CImg<T>& img):width(img.width),height(img.height),depth(img.depth),dim(img.dim) {
-      const unsigned siz = size();
-      if (siz) {
-	data = new T[width*height*depth*dim];
-	std::memcpy(data,img.data,siz*sizeof(T));
-      } else data = NULL;
-    }
-
-
-    //! Copy constructor.
-    /**
-       \param img = the image to copy.
-       \param pixel_copy = tells the constructor if the pixel data of the original image are copied into the created image.
-       This may be useful when one wants to create an image with same size than other image, but without same pixel data :
-       \code
-       CImg<float> source("image.jpg");
-       CImg<unsigned char> destination(source,false);
-       \endcode
-       is equivalent to
-       \code
-       CImg<float> source("image.jpg");
-       CImg<unsigned char> destination(source.dimx(),source.dimy(),source.dimz(),source.dimv());
-       \endcode
-    **/
-    template<typename t> CImg(const CImg<t>& img,const bool pixel_copy):width(0),height(0),depth(0),dim(0),data(NULL) {
-      if (pixel_copy) CImg<T>(img).swap(*this);
-      CImg<T>(img.width,img.height,img.depth,img.dim).swap(*this);
-    }
-
-    //! Create an image by loading a file.
-    /**
-       \param filename = the filename of the image file. filename extension is used to guess the image type.
-       \see CImg<T>::load().
-    **/
-    CImg(const char *filename):width(0),height(0),depth(0),dim(0),data(NULL) { load(filename).swap(*this); }
-
-    //! Create an image from a data buffer.
-    /**
-       \param data_buffer = pointer \c T* to a buffer of pixel values T.
-       \param dx = number of columns of the created image (size along the X-axis).
-       \param dy = number of rows of the created image (size along the Y-axis).
-       \param dz = number of slices of the created image (size along the Z-axis).
-       \param dv = number of vector channels of the created image (size along the V-axis).
-       \see \ref cimg_storage
-    **/
-    CImg(const T *const data_buffer,unsigned int dx,unsigned int dy=1,unsigned int dz=1,unsigned int dv=1):
-      width(dx),height(dy),depth(dz),dim(dv) {
-      const unsigned int siz = size();
-      if (data_buffer && siz) {
-        data = new T[siz];
-        std::memcpy(data,data_buffer,siz*sizeof(T));
-      } else { width=height=depth=dim=0; data = NULL; }
-    }
-
-    //! Destructor.
-    /**
-       \note The destructor frees the memory eventually used by the image pixels.
-    **/
-    ~CImg() { if (data) delete[] data; }
-
-    //! Empty image
-    CImg& empty() { return CImg<T>().swap(*this); }
-
-    //@}
-    //-----------------------------------------------------
-    //-----------------------------------------------------
-    //
-    //! \name Access to image dimensions and pixel values
-    //@{
-    //-----------------------------------------------------
-    //-----------------------------------------------------
-  
-    //! Return the type of the pixel values
-    /**
-       \return a string describing the type of the image pixels (template parameter \p T).
-    **/
-    static const char* pixel_type() { T val; return cimg::get_type(val); }
-
-    //! Return the number of pixels of an image.
-    /**
-       \return dimx()*dimy()*dimz()*dimv()
-       \see dimx(), dimy(), dimz(), dimv()
-    **/
-    const unsigned int size() const { return width*height*depth*dim; }  
-
-    //! Return the number of columns of the instance image (size along the X-axis).
-    /**
-       \return this->width
-       \see dimy(),dimz(),dimv(),size()
-    **/
-    const int dimx() const { return (int)width; }  
-
-    //! Return the number of rows of the instance image (size along the Y-axis).
-    /**
-       \return this->height
-       \see dimx(),dimz(),dimv(),size()
-    **/
-    const int dimy() const { return (int)height; }
-  
-    //! Return the number of slices of the instance image (size along the Z-axis).
-    /**
-       \return this->depth
-       \see dimx(),dimy(),dimv(),size()
-    **/
-    const int dimz() const { return (int)depth; }
-  
-    //! Return the number of vector channels of the instance image (size along the V-axis).
-    /**
-       \return this->dim
-       \see dimx(),dimy(),dimz(),size()
-    **/
-    const int dimv() const { return (int)dim; }
-  
-    //! Return the offset corresponding to the location of the pixel value located at (\p x,\p y,\p z,\p v)
-    // with respect to the pixel data pointer \ref data.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const int offset(const int x=0, const int y=0, const int z=0, const int v=0) const { return x+width*(y+height*(z+depth*v)); }
-  
-    //! Return a pointer to the pixel value located at (\p x,\p y,\p z,\p v).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    T* ptr(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0, const unsigned int v=0) const {
-#if cimg_debug>1
-      const int off = offset(x,y,z,v);
-      if (off<0 || off>=(int)size()) {
-        cimg::warn(true,"CImg<%s>::ptr() : Trying to get a pointer at (%u,%u,%u,%u) (offset=%d) which is outside the data of the image (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,off,width,height,depth,dim,size());
-        return data;
-      }
-#endif
-      return data+offset(x,y,z,v);
-    }
-
-    //! Access to pixel value for reading or writing, without boundary checking.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel       
-       \note if \c cimg_debug==2, a boundary checking is performed (also slow down the code considerably).
-    **/
-    T& operator()(const unsigned int x,const unsigned int y=0,const unsigned int z=0,const unsigned int v=0) const {
-      const int off = offset(x,y,z,v);
-#if cimg_debug>1
-      if (!data || off>=(int)size()) {
-        cimg::warn(true,
-                   "CImg<%s>::operator() : Pixel access requested at (%u,%u,%u,%u) (offset=%d) outside the image range (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),x,y,z,v,offset(x,y,z,v),width,height,depth,dim,data,size());			
-        return *data;
-      }
-#endif
-      return data[off];
-    }
-    
-    //! Access to pixel buffer value for reading or writing.
-    /**
-       \param off = offset in the pixel buffer
-       \note if \c cimg_debug==2, a out-of-buffer checking is performed (also slow down the code considerably).
-    **/    
-    T& operator[](const unsigned int off) const {
-#if cimg_debug>1
-      if (!data || off>=(int)size()) {
-        cimg::warn(true,
-                   "CImg<%s>::operator[] : Trying to get a pixel at offset=%d, outside the range of the image (%u,%u,%u,%u) (size=%u)",
-                   pixel_type(),off,width,height,depth,dim,data,size());			
-        return *data;
-      }
-#endif
-      return data[off];
-    }
-
-    //! Pixel access with Dirichlet boundary conditions for all coordinates (x,y,z,v).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix4d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || y<0 || z<0 || v<0 || x>=dimx() || y>=dimy() || z>=dimz() || v>=dimv())?out_val:(*this)(x,y,z,v);
-    }
-
-    //! Pixel access with Dirichlet boundary conditions for the three first coordinates (x,y,z).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix3d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || y<0 || z<0 || x>=dimx() || y>=dimy() || z>=dimz())?out_val:(*this)(x,y,z,v);
-    }
-    //! Pixel access with Dirichlet boundary conditions for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix2d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || y<0 || x>=dimx() || y>=dimy())?out_val:(*this)(x,y,z,v);
-    }
-
-    //! Pixel access with Dirichlet boundary conditions for the first coordinate x.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-       \param out_val = returned value if pixel coordinates is out of the image range.
-    **/
-    T dirichlet_pix1d(const int x,const int y=0,const int z=0,const int v=0,const T out_val=(T)0) const {
-      return (x<0 || x>=dimx())?out_val:(*this)(x,y,z,v);
-    }
-
-    //! Pixel access with Neumann boundary conditions for all coordinates (x,y,z,v).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix4d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
-                     y<0?0:(y>=dimy()?dimy()-1:y),
-                     z<0?0:(z>=dimz()?dimz()-1:z),
-                     v<0?0:(v>=dimv()?dimv()-1:v));
-    }
-    //! Pixel access with Neumann boundary conditions for the three first coordinates (x,y,z).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix3d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
-                     y<0?0:(y>=dimy()?dimy()-1:y),
-                     z<0?0:(z>=dimz()?dimz()-1:z),v);
-    }
-
-    //! Pixel access with Neumann boundary conditions for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix2d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),
-                     y<0?0:(y>=dimy()?dimy()-1:y),z,v);
-    }
-    //! Pixel access with Neumann boundary conditions for the first coordinate x.
-    /**
-       \param x = x-coordinate of the pixel
-       \param y = y-coordinate of the pixel
-       \param z = z-coordinate of the pixel
-       \param v = v-coordinate of the pixel
-    **/
-    const T& neumann_pix1d(const int x,const int y=0,const int z=0,const int v=0) const {
-      return (*this)(x<0?0:(x>=dimx()?dimx()-1:x),y,z,v);
-    }
-    
-    //! Pixel access with Neumann boundary conditions and linear interpolation for all coordinates (x,y,z,v).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (float value)
-       \param v = v-coordinate of the pixel (float value)
-    **/
-    double linear_pix4d(const float ffx,const float ffy=0,const float ffz=0,const float ffv=0) const {
-      double valx0,valx1,valy0,valy1,valz0,valz1;
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy),
-        fz = ffz<0?0:(ffz>depth-1?depth-1:ffz), fv = ffv<0?0:(ffv>dim-1?dim-1:ffv);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy,  z = (unsigned int)fz, v = (unsigned int)fv;
-      const float dx = fx-x, dy = fy-y, dz = fz-z, dv = fv-v;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y,  nz = dz>0?z+1:z, nv = dv>0?v+1:v;
-      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
-      valy0 = (1-dy)*valx0 + (dy)*valx1;
-      valx0 = (1-dx)*(*this)(x,y,nz,v)  + (dx)*(*this)(nx,y,nz,v);
-      valx1 = (1-dx)*(*this)(x,ny,nz,v) + (dx)*(*this)(nx,ny,nz,v);
-      valy1 = (1-dy)*valx0 + (dy)*valx1;
-      valz0 = (1-dz)*valy0 + (dz)*valy1;
-      valx0 = (1-dx)*(*this)(x,y,z,nv)  + (dx)*(*this)(nx,y,z,nv);
-      valx1 = (1-dx)*(*this)(x,ny,z,nv) + (dx)*(*this)(nx,ny,z,nv);
-      valy0 = (1-dy)*valx0 + (dy)*valx1;
-      valx0 = (1-dx)*(*this)(x,y,nz,nv)  + (dx)*(*this)(nx,y,nz,nv);
-      valx1 = (1-dx)*(*this)(x,ny,nz,nv) + (dx)*(*this)(nx,ny,nz,nv);
-      valy1 = (1-dy)*valx0 + (dy)*valx1;
-      valz1 = (1-dz)*valy0 + (dz)*valy1;
-      return (1-dv)*valz0 + (dv)*valz1;
-    }
-
-    //! Pixel access with Neumann boundary conditions and linear interpolation for the three first coordinates (x,y,z).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (float value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double linear_pix3d(const float ffx,const float ffy=0,const float ffz=0,const int v=0) const {
-      double valx0,valx1,valy0,valy1;
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy), fz = ffz<0?0:(ffz>depth-1?depth-1:ffz);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy, z = (unsigned int)fz;
-      const float dx = fx-x, dy = fy-y, dz = fz-z;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y, nz = dz>0?z+1:z;
-      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
-      valy0 = (1-dy)*valx0 + (dy)*valx1;
-      valx0 = (1-dx)*(*this)(x,y,nz,v)  + (dx)*(*this)(nx,y,nz,v);
-      valx1 = (1-dx)*(*this)(x,ny,nz,v) + (dx)*(*this)(nx,ny,nz,v);
-      valy1 = (1-dy)*valx0 + (dy)*valx1;
-      return (1-dz)*valy0 + (dz)*valy1;
-    }
-
-    //! Pixel access with Neumann boundary conditions and linear interpolation for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double linear_pix2d(const float ffx,const float ffy=0,const int z=0,int v=0) const {
-      double valx0,valx1;
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx), fy = ffy<0?0:(ffy>height-1?height-1:ffy);
-      const unsigned int x = (unsigned int)fx, y = (unsigned int)fy;
-      const float dx = fx-x, dy = fy-y;
-      const unsigned int nx = dx>0?x+1:x, ny = dy>0?y+1:y;
-      valx0 = (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-      valx1 = (1-dx)*(*this)(x,ny,z,v) + (dx)*(*this)(nx,ny,z,v);
-      return (1-dy)*valx0 + (dy)*valx1;
-    }
-
-    //! Pixel access with Neumann boundary conditions and linear interpolation for the first coordinate x.
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (integer value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double linear_pix1d(const float ffx,const int y=0,const int z=0,int v=0) const {
-      const float fx = ffx<0?0:(ffx>width-1?width-1:ffx);
-      const unsigned int x = (unsigned int)fx;
-      const float dx = fx-x;
-      const unsigned int nx = dx>0?x+1:x;
-      return (1-dx)*(*this)(x,y,z,v)  + (dx)*(*this)(nx,y,z,v);
-    }
-
-    //! Pixel access with Neumann boundary conditions and cubic interpolation for the two first coordinates (x,y).
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (float value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double cubic_pix2d(const float pfx,const float pfy=0,const int z=0,int v=0) const {
-      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx), fy = pfy<0?0:(pfy>height-1?height-1:pfy);
-      const unsigned int 
-        x = (unsigned int)fx,  px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1,
-        y = (unsigned int)fy,  py = (int)y-1>=0?y-1:0, ny = y+1<height?y+1:height-1, ay = ny+1<height?ny+1:height-1;
-      const float dx = fx-x, dy = fy-y;
-      const T& 
-        a = (*this)(px,py,z,v), b = (*this)(x,py,z,v), c = (*this)(nx,py,z,v), d = (*this)(ax,py,z,v),
-        e = (*this)(px, y,z,v), f = (*this)(x, y,z,v), g = (*this)(nx, y,z,v), h = (*this)(ax, y,z,v),
-        i = (*this)(px,ny,z,v), j = (*this)(x,ny,z,v), k = (*this)(nx,ny,z,v), l = (*this)(ax,ny,z,v),
-        m = (*this)(px,ay,z,v), n = (*this)(x,ay,z,v), o = (*this)(nx,ay,z,v), p = (*this)(ax,ay,z,v);
-      const double 
-        A = dx*dx*dx*(2*(b-c)+0.5*(c-a+d-b)) + dx*dx*(2*c-2.5*b+a-0.5*d) + dx*0.5*(c-a) + b,
-        B = dx*dx*dx*(2*(f-g)+0.5*(g-e+h-f)) + dx*dx*(2*g-2.5*f+e-0.5*h) + dx*0.5*(g-e) + f,
-        C = dx*dx*dx*(2*(j-k)+0.5*(k-i+l-j)) + dx*dx*(2*k-2.5*j+i-0.5*l) + dx*0.5*(k-i) + j,
-        D = dx*dx*dx*(2*(n-o)+0.5*(o-m+p-n)) + dx*dx*(2*o-2.5*n+m-0.5*p) + dx*0.5*(o-m) + n;
-      return dy*dy*dy*(2*(B-C)+0.5*(C-A+D-B)) + dy*dy*(2*C-2.5*B+A-0.5*D) + dy*0.5*(C-A) + B;
-    }
-
-    //! Pixel access with Neumann boundary conditions and cubic interpolation for all coordinates x.
-    /**
-       \param x = x-coordinate of the pixel (float value)
-       \param y = y-coordinate of the pixel (integer value)
-       \param z = z-coordinate of the pixel (integer value)
-       \param v = v-coordinate of the pixel (integer value)
-    **/
-    double cubic_pix1d(const float pfx,const int y=0,const int z=0,int v=0) const {
-      const float fx = pfx<0?0:(pfx>width-1?width-1:pfx);
-      const unsigned int x = (unsigned int)fx, px = (int)x-1>=0?x-1:0, nx = x+1<width?x+1:width-1, ax = nx+1<width?nx+1:width-1;
-      const float dx = fx-x;
-      const T& a = (*this)(px,y,z,v), b = (*this)(x,y,z,v), c = (*this)(nx,y,z,v), d = (*this)(ax,y,z,v);
-      return dx*dx*dx*(2*(b-c)+0.5*(c-a+d-b)) + dx*dx*(2*c-2.5*b+a-0.5*d) + dx*0.5*(c-a) + b;
-    }
-  
-    //! Compute and return statistics on the image.
-    /**
-       \param compute_variance = - \true : compute complete statistics, including the variance of the pixel values.
-                                 - \false : compute only minimum, maximum and average value of the pixel values (faster).
-       \return a CImgStats instance representing statistics of the instance image.
-    **/
-    CImgStats get_stats(const bool compute_variance=true) const { return CImgStats(*this,compute_variance); }
-  
-    //! Print image information on the standart error output
-    /**
-       \param title = name of your printed variable.
-       \param print_flag = - 0 : print only informations about image size and pixel buffer.
-                           - 1 : print also statistics on the image pixels.
-			   - 2 : print also the pixel buffer content, in a matlab-style.
-    **/
-    const CImg& print(const char *title=NULL,const unsigned int print_flag=1) const {
-      std::fprintf(stderr,"%-8s(%p) : '%s'(%u,%u,%u,%u,%p) : ",title?title:"CImg",(void*)this,
-		   pixel_type(),width,height,depth,dim,(void*)data);
-      if (size()==0 || !data) { std::fprintf(stderr,"Undefined pixel data\n"); return *this; }
-      if (print_flag>=1) { 
-        CImgStats st(*this);
-        std::fprintf(stderr,"stats = { %g, %g [%g], %g } : ",st.min,st.mean,st.variance,st.max); 
-      }
-      if (print_flag>=2 || size()<=16) {
-        std::fprintf(stderr,"%s = [ ",title?title:"data");
-        cimg_mapXYZV(*this,x,y,z,k) std::fprintf(stderr,"%g%s",(double)(*this)(x,y,z,k),((x+1)*(y+1)*(z+1)*(k+1)==(int)size()?" ]":(((x+1)%width==0)?" ; ":" ")));
-      }
-      std::fputc('\n',stderr);
-      return *this;
-    }
-    //! Print image information on the standart error output
-    /**
-      \param print_flag = - 0 : print only informations about image size and pixel buffer.
-                           - 1 : print also statistics on the image pixels.
-			   - 2 : print also the pixel buffer content, in a matlab-style.       
-    **/
-    const CImg& print(const unsigned int print_flag) const { return print(NULL,print_flag); }
-  
-    //@}
-    //--------------------------------------------------
-    //--------------------------------------------------
-    //
-    //! \name Common arithmetics and boolean operators
-    //@{
-    //--------------------------------------------------
-    //--------------------------------------------------
-  
-    //! Copy an image to the instance image.
-    /**
-       \param img = image to copy.
-       \note If pixel types are different, a type cast is performed.
-    **/
-    template<typename t> CImg<T>& operator=(const CImg<t>& img) { return CImg<T>(img).swap(*this); }
-    CImg& operator=(const CImg& img) { if (&img==this) return *this; return CImg<T>(img).swap(*this); }
-      
-    //! Assign a scalar value to all pixels of the instance image
-    /**
-       \param val = the value to assign.
-    **/
-    CImg& operator=(const T& val) { return fill(val); }
-
-    //! Copy the content of a C-array to the pixel buffer of the instance image
-    /**
-       \param buf = pointer to a C-array, with a size of (at least) this->size().
-    **/
-    CImg& operator=(const T *buf) {
-      if (buf) std::memcpy(data,buf,size()*sizeof(T));
-      else throw CImgArgumentException("CImg<T>::operator=() : Given array pointer 'ptr' is NULL");
-      return *this; 
-    }
-       
-    //! Operator+=
-    /**
-       \param val = value to add to each pixel value of the instance image.
-    **/
-    CImg& operator+=(const T& val) { cimg_map(*this,ptr,T) (*ptr)+=val; return *this; }
-
-    //! Operator-=
-    /**
-       \param val = value to sub to each pixel value of the instance image.
-    **/
-    CImg& operator-=(const T& val) { cimg_map(*this,ptr,T) (*ptr)-=val; return *this; }
-
-    //! Operator%=
-    /**
-       \param val = value of the modulo applied to each pixel value of the instance image.
-    **/
-    CImg& operator%=(const T& val) { cimg_map(*this,ptr,T) (*ptr)%=val; return *this; }
-
-    //! Operator&=
-    /**
-       \param val = value of the bitwise AND applied to each pixel value of the instance image.
-     **/
-    CImg& operator&=(const T& val) { cimg_map(*this,ptr,T) (*ptr)&=val; return *this; }
-
-    //! Operator|=
-    /**
-       \param 
-    **/
-    CImg& operator|=(const T& val) { cimg_map(*this,ptr,T) (*ptr)|=val; return *this; }
-
-    //! Operator^=
-    CImg& operator^=(const T& val) { cimg_map(*this,ptr,T) (*ptr)^=val; return *this; }
-
-    //! Operator+
-    CImg operator+(const T& val) const { return CImg<T>(*this)+=val; }
-
-    //! Operator-
-    CImg operator-(const T& val) const { return CImg<T>(*this)-=val; }
-
-    //! Operator%
-    CImg operator%(const T& val) const { return CImg<T>(*this)%=val; }  
-
-    //! Operator&
-    CImg operator&(const T& val) const { return CImg<T>(*this)&=val; }
-
-    //! Operator|
-    CImg operator|(const T& val) const { return CImg<T>(*this)|=val; }
-
-    //! Operator^
-    CImg operator^(const T& val) const { return CImg<T>(*this)^=val; }
-
-    //! Operator!
-    CImg operator!() const {
-      CImg<T> res(*this,false);
-      const T *ptrs = ptr() + size();
-      cimg_map(res,ptrd,T) *ptrd=!(*(--ptrs));
-      return res;
-    }
-
-    //! Operator~
-    CImg operator~() const {
-      CImg<T> res(*this,false);
-      const T *ptrs = ptr() + size();
-      cimg_map(res,ptrd,T) *ptrd=~(*(--ptrs));
-      return res;
-    }
-    
-    //! Operator+=
-    template<typename t> CImg& operator+=(const CImg<t>& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      t *ptrs = img.data+smin;
-      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)+(*(--ptrs))));
-      return *this;
-    }
-    //! Operator-=
-    template<typename t> CImg& operator-=(const CImg<t>& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      t *ptrs = img.data+smin;
-      for (T *ptrd = data+smin; ptrd>data; --ptrd, (*ptrd)=(T)((*ptrd)-(*(--ptrs))));
-      return *this;
-    }
-    //! Operator%=
-    CImg& operator%=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)%=*(--ptrs));
-      return *this;
-    }
-    //! Operator&=
-    CImg& operator&=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)&=*(--ptrs));
-      return *this;
-    }
-    //! Operator|=
-    CImg& operator|=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)|=*(--ptrs));
-      return *this;
-    }
-    //! Operator^=
-    CImg& operator^=(const CImg& img) {
-      const unsigned int smin = cimg::min(size(),img.size());
-      for (T *ptrs=img.data+smin, *ptrd=data+smin; ptrd>data; *(--ptrd)^=*(--ptrs));
-      return *this;
-    }
-
-    //! Operator+
-    template<typename t> CImg operator+(const CImg<t>& img)  const { return CImg<T>(*this)+=img; }
-
-    //! Operator-
-    template<typename t> CImg operator-(const CImg<t>& img)  const { return CImg<T>(*this)-=img; }
-
-    //! Operator%
-    CImg operator%(const CImg& img) const { return CImg<T>(*this)%=img; }
-
-    //! Operator&
-    CImg operator&(const CImg& img) const { return CImg<T>(*this)&=img; } 
-
-    //! Operator|
-    CImg operator|(const CImg& img) const { return CImg<T>(*this)|=img; }
-
-    //! Operator^
-    CImg operator^(const CImg& img) const { return CImg<T>(*this)^=img; }  
-
-    //! Operator*=
-    CImg& operator*=(const double val) { cimg_map(*this,ptr,T) (*ptr)=(T)((*ptr)*val); return *this; }
-
-    //! Operator/=
-    CImg& operator/=(const double val) { cimg_map(*this,ptr,T) (*ptr)=(T)((*ptr)/val); return *this; }
-
-    //! Operator*
-    CImg operator*(const double val) const { return CImg<T>(*this)*=val; }
-
-    //! Operator/
-    CImg operator/(const double val) const { return CImg<T>(*this)/=val; }
-
-    //! Operator+
-    friend CImg operator+(const T& val, const CImg& img) { return CImg<T>(img)+=val; }
-
-    //! Operator*
-    friend CImg operator*(const double val,const CImg &img) { return CImg<T>(img)*=val; }
-
-    //! Operator-
-    friend CImg operator-(const T& val, const CImg& img) { return CImg<T>(img.width,img.height,img.depth,img.dim,val)-=img; }
-
-    //! Operator==
-    template<typename t> const bool operator==(const CImg<t>& img) const {
-      const unsigned int siz = size();
-      bool vequal = true;
-      if (siz!=img.size()) return false;
-      t *ptrs=img.data+siz;
-      for (T *ptrd=data+siz; vequal && ptrd>data; vequal=vequal&&((*(--ptrd))==(*(--ptrs))));
-      return vequal;
-    }
-    //! Operator!=
-    template<typename t> const bool operator!=(const CImg<t>& img) const { return !((*this)==img); }
-
-    //@}
-    //--------------------------------------------------
-    //--------------------------------------------------
-    //
-    //! \name Usual mathematical operations
-    //@{
-    //--------------------------------------------------
-    //--------------------------------------------------
-     
-    //! Replace the image by the pointwise multiplication between \p *this and \p img.
-    /**
-       \param img = argument of the multiplication.
-       \note if \c *this and \c img have different size, the multiplication is applied
-       only on possible values.
-       \see div(),get_mul(),get_div().
-    **/
-    template<typename t> CImg& mul(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd*(*(ptrs++)));
-      return *this;
-    }
-
-    //! Return the image corresponding to the pointwise multiplication between \p *this and \p img.
-    /**
-       \param img = argument of the multiplication.
-       \note if \c *this and \c img have different size, the multiplication is applied
-       only on possible values.
-       \see get_div(),mul(),div()
-    **/
-    template<typename t> CImg get_mul(const CImg<t>& img) const { return CImg<T>(*this).mul(img); }
-  
-    //! Replace the image by the pointwise division between \p *this and \p img.
-    /**
-       \param img = argument of the division.
-       \note if \c *this and \c img have different size, the division is applied
-       only on possible values.
-       \see mul(),get_mul(),get_div().
-    **/
-    template<typename t> CImg& div(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=(T)(*ptrd/(*(ptrs++)));
-      return *this;
-    }
-
-    //! Return an image from a pointwise division between \p *this and \p img.
-    /**
-       \param img = argument of the division.
-       \note if \c *this and \c img have different size, the division is applied
-       only on possible values.
-       \see get_mul(),mul(),div()
-    **/
-    template<typename t> CImg get_div(const CImg<t>& img) const { return CImg<T>(*this).div(img); }
-  
-    //! Replace the image by the pointwise max operator between \p *this and \p img
-    /**
-       \param img = second argument of the max operator (the first one is *this).
-       \see get_max(), min(), get_min()
-    **/
-    template<typename t> CImg& max(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::max((T)(*(ptrs++)),*ptrd);
-      return *this;
-    }
-    //! Return the image corresponding to the max value for each pixel.
-    /**
-       \param img = second argument of the max operator (the first one is *this).
-       \see max(), min(), get_min()
-    **/
-    template<typename t> CImg get_max(const CImg<t>& img) const { return CImg<T>(*this).max(img); }
-  
-    //! Replace the image by the pointwise min operator between \p *this and \p img
-    /**
-       \param img = second argument of the min operator (the first one is *this).
-       \see get_min(), max(), get_max()
-    **/
-    template<typename t> CImg& min(const CImg<t>& img) {
-      t *ptrs = img.data;
-      T *ptrf = data + cimg::min(size(),img.size());
-      for (T* ptrd = data; ptrd<ptrf; ptrd++) (*ptrd)=cimg::min((T)(*(ptrs++)),*ptrd);
-      return *this;
-    }
-    //! Return the image corresponding to the min value for each pixel.
-    /**
-       \param img = second argument of the min operator (the first one is *this).
-       \see min(), max(), get_max()
-    **/
-    template<typename t> CImg get_min(const CImg<t>& img) const { return CImg<T>(*this).min(img); }
-
-    //! Replace each image pixel by its square root.
-    /**
-       \see get_sqrt()
-    **/
-    CImg& sqrt() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::sqrt((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the square root of the pixel values.
-    /**
-       \see sqrt()
-    **/
-    CImg get_sqrt() const { return CImg<T>(*this).sqrt(); }
-  
-    //! Replace each image pixel by its log.
-    /**
-       \see get_log(), log10(), get_log10()
-    **/
-    CImg& log() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::log((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the log of the pixel values.
-    /**
-       \see log(), log10(), get_log10()
-    **/
-    CImg get_log() const { return CImg<T>(*this).log(); }
-
-    //! Replace each image pixel by its log10.
-    /**
-       \see get_log10(), log(), get_log()
-    **/
-    CImg& log10() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::log10((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the log10 of the pixel values.
-    /**
-       \see log10(), log(), get_log()
-    **/
-    CImg get_log10() const { return CImg<T>(*this).log10(); }
-
-    //! Replace each image pixel by its power by \p p.
-    /**
-       \param p = power
-       \see get_pow(), sqrt(), get_sqrt()
-    **/
-    CImg& pow(const double p) {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::pow((double)(*ptr),p);
-      return *this;
-    }
-
-    //! Return the image of the square root of the pixel values.
-    /**
-       \param p = power
-       \see pow(), sqrt(), get_sqrt()
-    **/
-    CImg get_pow(const double p) const { return CImg<T>(*this).pow(p); }
-  
-    //! Replace each pixel value by its absolute value.
-    /**
-       \see get_abs()
-    **/
-    CImg& abs() {
-      cimg_map(*this,ptr,T) (*ptr)=cimg::abs(*ptr);
-      return *this;
-    }
-
-    //! Return the image of the absolute value of the pixel values.
-    /**
-       \see abs()
-    **/
-    CImg get_abs() const { return CImg<T>(*this).abs(); }
-  
-    //! Replace each image pixel by its cosinus.
-    /**
-       \see get_cos(), sin(), get_sin(), tan(), get_tan()
-    **/
-    CImg& cos() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::cos((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the cosinus of the pixel values.
-    /**
-       \see cos(), sin(), get_sin(), tan(), get_tan()
-    **/
-    CImg get_cos() const { return CImg<T>(*this).cos(); }
- 
-    //! Replace each image pixel by its sinus.
-    /**
-       \see get_sin(), cos(), get_cos(), tan(), get_tan()
-    **/
-    CImg& sin() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::sin((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the sinus of the pixel values.
-    /**
-       \see sin(), cos(), get_cos(), tan(), get_tan()
-    **/
-    CImg get_sin() const { return CImg<T>(*this).sin(); }
-  
-    //! Replace each image pixel by its tangent.
-    /**
-       \see get_tan(), cos(), get_cos(), sin(), get_sin()
-    **/
-    CImg& tan() {
-      cimg_map(*this,ptr,T) (*ptr)=(T)std::tan((double)(*ptr));
-      return *this;
-    }
-
-    //! Return the image of the tangent of the pixel values.
-    /**
-       \see tan(), cos(), get_cos(), sin(), get_sin()
-    **/
-    CImg get_tan() const { return CImg<T>(*this).tan(); }
-  
-
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Usual image transformation
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Fill all pixel values with value \a val.
-    /**
-       \param val = fill value
-       \see operator=()
-    **/
-    CImg& fill(const T& val) {
-      cimg_test(*this,"CImg<T>::fill");      
-      if (val!=0 && sizeof(T)!=1) cimg_map(*this,ptr,T) *ptr=val; 
-      else std::memset(data,(int)val,size()*sizeof(T));
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-    **/
-    CImg& fill(const T& val0,const T& val1) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-1; ) { *(ptr++)=val0; *(ptr++)=val1; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      return *this;
-    }
-    
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-2; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; }     
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      return *this;
-    }
-    
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-3; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-4; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      return *this;
-    }
-    
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a val4 and \a val5
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size(); 
-      for (ptr=data; ptr<ptr_end-5; ) { *(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val7.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,const T& val7) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-7; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val8.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,const T& val7,const T& val8) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-8; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val9.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,
-	       const T& val5,const T& val6,const T& val7,const T& val8,const T& val9) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-9; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      if (ptr!=ptr_end) *(ptr++)=val8;
-      return *this;
-    }
-
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val11.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,const T& val4,const T& val5,const T& val6,
-               const T& val7,const T& val8,const T& val9,const T& val10,const T& val11) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-11; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      if (ptr!=ptr_end) *(ptr++)=val8;
-      if (ptr!=ptr_end) *(ptr++)=val9;
-      if (ptr!=ptr_end) *(ptr++)=val10;
-      return *this;
-    }
-    //! Fill sequentially all pixel values with values \a val0 and \a val1 and \a val2 and \a val3 and \a ... and \a val15.
-    /**
-       \param val0 = fill value 1
-       \param val1 = fill value 2
-       \param val2 = fill value 3
-       \param val3 = fill value 4
-       \param val4 = fill value 5
-       \param val5 = fill value 6
-       \param val6 = fill value 7
-       \param val7 = fill value 8
-       \param val8 = fill value 9
-       \param val9 = fill value 10
-       \param val10 = fill value 11
-       \param val11 = fill value 12
-       \param val12 = fill value 13
-       \param val13 = fill value 14
-       \param val14 = fill value 15
-       \param val15 = fill value 16
-    **/
-    CImg& fill(const T& val0,const T& val1,const T& val2,const T& val3,
-	       const T& val4,const T& val5,const T& val6,const T& val7,
-               const T& val8,const T& val9,const T& val10,const T& val11,
-	       const T& val12,const T& val13,const T& val14,const T& val15) {
-      cimg_test(*this,"CImg<T>::fill");
-      T *ptr, *ptr_end = data+size();
-      for (ptr=data; ptr<ptr_end-15; ) {
-	*(ptr++)=val0; *(ptr++)=val1; *(ptr++)=val2; *(ptr++)=val3; *(ptr++)=val4; *(ptr++)=val5; 
-	*(ptr++)=val6; *(ptr++)=val7; *(ptr++)=val8; *(ptr++)=val9; *(ptr++)=val10; *(ptr++)=val11;
-	*(ptr++)=val12; *(ptr++)=val13; *(ptr++)=val14; *(ptr++)=val15;
-      }
-      if (ptr!=ptr_end) *(ptr++)=val0;
-      if (ptr!=ptr_end) *(ptr++)=val1;
-      if (ptr!=ptr_end) *(ptr++)=val2;
-      if (ptr!=ptr_end) *(ptr++)=val3;
-      if (ptr!=ptr_end) *(ptr++)=val4;
-      if (ptr!=ptr_end) *(ptr++)=val5;
-      if (ptr!=ptr_end) *(ptr++)=val6;
-      if (ptr!=ptr_end) *(ptr++)=val7;
-      if (ptr!=ptr_end) *(ptr++)=val8;
-      if (ptr!=ptr_end) *(ptr++)=val9;
-      if (ptr!=ptr_end) *(ptr++)=val10;
-      if (ptr!=ptr_end) *(ptr++)=val11;
-      if (ptr!=ptr_end) *(ptr++)=val12;
-      if (ptr!=ptr_end) *(ptr++)=val13;
-      if (ptr!=ptr_end) *(ptr++)=val14;
-      return *this;
-    }
-  
-    //! Linear normalization of the pixel values between \a a and \a b.
-    /**
-       \param a = minimum pixel value after normalization.
-       \param b = maximum pixel value after normalization.
-       \see get_normalize(), cut(), get_cut().
-    **/
-    CImg& normalize(const T& a,const T& b) {
-      cimg_test(*this,"CImg<T>::normalize");
-      const CImgStats st(*this,false);
-      if (st.min==st.max) fill(0);
-      else cimg_map(*this,ptr,T) *ptr=(T)((*ptr-st.min)/(st.max-st.min)*(b-a)+a);
-      return *this;
-    }
-
-    //! Return the image of normalized values.
-    /**
-       \param a = minimum pixel value after normalization.
-       \param b = maximum pixel value after normalization.
-       \see normalize(), cut(), get_cut().
-    **/
-    CImg get_normalize(const T& a,const T& b) const { return CImg<T>(*this).normalize(a,b); }
-  
-    //! Cut pixel values between \a a and \a b.
-    /**
-       \param a = minimum pixel value after cut.
-       \param b = maximum pixel value after cut.
-       \see get_cut(), normalize(), get_normalize().
-    **/
-    CImg& cut(const T& a, const T& b) {
-      cimg_test(*this,"CImg<T>::cut");
-      cimg_map(*this,ptr,T) *ptr = (*ptr<a)?a:((*ptr>b)?b:*ptr);
-      return *this;
-    }
-
-    //! Return the image of cutted values.
-    /**
-       \param a = minimum pixel value after cut.
-       \param b = maximum pixel value after cut.
-       \see cut(), normalize(), get_normalize().
-    **/
-    CImg get_cut(const T& a, const T& b) const { return CImg<T>(*this).cut(a,b); }
-
-    //! Quantify pixel values into \n levels.
-    /**
-       \param n = number of quantification levels
-       \see get_quantify().
-    **/
-    CImg& quantify(const unsigned int n=256) {
-      cimg_test(*this,"CImg<T>::quantify");
-      const CImgStats st(*this,false);
-      const double range = st.max-st.min;
-      cimg_map(*this,ptr,T) *ptr = (T)(st.min + range*(int)((*ptr-st.min)*(int)n/range)/n);
-      return *this;
-    }
-
-    //! Return a quantified image, with \n levels.
-    /**
-       \param n = number of quantification levels
-       \see quantify().
-    **/
-    CImg get_quantify(const unsigned int n=256) const { return CImg<T>(*this).quantify(n); }
-
-    //! Threshold the image.
-    /**
-       \param thres = threshold
-       \see get_threshold().
-    **/	
-    CImg& threshold(const T& thres) {
-      cimg_test(*this,"CImg<T>::threshold");
-      cimg_map(*this,ptr,T) *ptr = *ptr<=thres?(T)0:(T)1;
-      return *this;
-    }
-
-    //! Return a thresholded image.
-    /**
-       \param thres = threshold.
-       \see threshold().
-    **/
-    CImg get_threshold(const T& thres) const { return CImg<T>(*this).threshold(thres); }
-  
-    //! Return a rotated image.
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \note Returned image will probably have a different size than the instance image *this.
-       \see rotate()
-    **/
-    CImg get_rotate(const float angle,const unsigned int cond=2) const {
-      cimg_test(*this,"CImg<T>::get_rotate");
-      CImg dest;
-      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
-        ca=(float)std::cos(rad), sa=(float)std::sin(rad);
-    
-      if (cond!=1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
-        const int iangle = (int)nangle/90;
-        switch (iangle) {
-        case 1: {
-          dest = CImg<T>(height,width,depth,dim); 
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(y,height-1-x,z,v); 
-        } break; 
-        case 2: {
-          dest = CImg<T>(width,height,depth,dim);
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v); 
-        } break;
-        case 3: {
-          dest = CImg<T>(height,width,depth,dim); 
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-y,x,z,v); 
-        } break;
-        default: 
-          return *this;        
-        }
-      } else { // generic version
-        const float 
-          ux  = (float)(std::fabs(width*ca)),  uy  = (float)(std::fabs(width*sa)),
-          vx  = (float)(std::fabs(height*sa)), vy  = (float)(std::fabs(height*ca)),
-          w2  = 0.5f*width,           h2  = 0.5f*height,
-          dw2 = 0.5f*(ux+vx),         dh2 = 0.5f*(uy+vy);
-        dest = CImg<T>((int)(ux+vx), (int)(uy+vy),depth,dim);
-
-        switch (cond) {
-        case 0: { 
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = dirichlet_pix2d((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),(int)(h2 - (x-dw2)*sa + (y-dh2)*ca),z,v);
-        } break;
-        case 1: {
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = (*this)(cimg::mod((int)(w2 + (x-dw2)*ca + (y-dh2)*sa),width),
-                                    cimg::mod((int)(h2 - (x-dw2)*sa + (y-dh2)*ca),height),z,v);
-        } break;
-        default: {
-          cimg_mapXY(dest,x,y) {
-            const float X = w2 + (x-dw2)*ca + (y-dh2)*sa, Y = h2 - (x-dw2)*sa + (y-dh2)*ca;
-            const int ix = (int)X, iy = (int)Y;
-            if (ix<0 || ix>=dimx() || iy<0 || iy>=dimy()) cimg_mapZV(*this,z,v) dest(x,y,z,v) = 0;
-            else cimg_mapZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v);
-          }
-        } break; 
-        }
-      }
-      return dest;
-    }
-  
-    //! Rotate the image 
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \see get_rotate()
-    **/
-    CImg& rotate(const float angle,const unsigned int cond=2) { return get_rotate(angle,cond).swap(*this); }
-  
-    //! Return a rotated image around the point (\c cx,\c cy).
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cx = X-coordinate of the rotation center.
-       \param cy = Y-coordinate of the rotation center.
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \see rotate()
-    **/
-    CImg get_rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=2) const {
-      cimg_test(*this,"CImg<T>::get_rotate");
-      CImg dest(*this,false);
-      const float nangle = cimg::mod(angle,360.0f), rad = (float)((nangle*cimg::PI)/180.0),
-        ca=(float)std::cos(rad)/zoom, sa=(float)std::sin(rad)/zoom;
-    
-      if (cond!=1 && zoom==1 && cimg::mod(nangle,90.0f)==0) { // optimized version for orthogonal angles
-        const int iangle = (int)nangle/90;
-        switch (iangle) {
-        case 1: {
-          dest.fill(0);
-          const unsigned int
-            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
-            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
-            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
-            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
-          cimg_mapZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
-            dest(x,y,z,v) = (*this)(y-yoff,height-1-x+xoff,z,v);
-        } break;
-        case 2: {
-          cimg_mapXYZV(dest,x,y,z,v) dest(x,y,z,v) = (*this)(width-1-x,height-1-y,z,v); 
-        } break;
-        case 3: {
-          dest.fill(0);
-          const unsigned int
-            xmin = cimg::max(0,(dimx()-dimy())/2), xmax = cimg::min(width,xmin+height),
-            ymin = cimg::max(0,(dimy()-dimx())/2), ymax = cimg::min(height,ymin+width),
-            xoff = xmin + cimg::min(0,(dimx()-dimy())/2),
-            yoff = ymin + cimg::min(0,(dimy()-dimx())/2);
-          cimg_mapZV(dest,z,v) for (unsigned int y=ymin; y<ymax; y++) for (unsigned int x=xmin; x<xmax; x++)
-            dest(x,y,z,v) = (*this)(width-1-y+yoff,x-xoff,z,v);
-        } break;
-        default: 
-          return *this;        
-        }
-      } else 
-        switch (cond) { // generic version
-        case 0: { 
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = dirichlet_pix2d((int)(cx + (x-cx)*ca + (y-cy)*sa),(int)(cy - (x-cx)*sa + (y-cy)*ca),z,v);
-        } break;
-        case 1: {
-          cimg_mapXY(dest,x,y)
-            cimg_mapZV(*this,z,v) 
-            dest(x,y,z,v) = (*this)(cimg::mod((int)(cx + (x-cx)*ca + (y-cy)*sa),width),
-                                    cimg::mod((int)(cy - (x-cx)*sa + (y-cy)*ca),height),z,v);
-        } break;
-        default: {
-          cimg_mapXY(dest,x,y) {
-            const float X = cx + (x-cx)*ca + (y-cy)*sa, Y = cy - (x-cx)*sa + (y-cy)*ca;
-            const int ix = (int)X, iy = (int)Y;
-            if (ix<0 || ix>=dimx() || iy<0 || iy>=dimy()) cimg_mapZV(*this,z,v) dest(x,y,z,v) = 0;
-            else cimg_mapZV(*this,z,v) dest(x,y,z,v) = (T)linear_pix2d(X,Y,z,v);
-          }
-        } break; 
-        }
-      return dest;
-    }
-  
-    //! Rotate the image around the point (\c cx,\c cy).
-    /**
-       \param angle = rotation angle (in degrees).
-       \param cx = X-coordinate of the rotation center.
-       \param cy = Y-coordinate of the rotation center.
-       \param cond = rotation type. can be :
-       - 0 = zero-value at borders
-       - 1 = repeat image at borders
-       - 2 = zero-value at borders and linear interpolation
-       \note Rotation does not change the image size. If you want to get an image with a new size, use get_rotate() instead.
-       \see get_rotate()
-    **/
-    CImg& rotate(const float angle,const float cx,const float cy,const float zoom=1,const unsigned int cond=2) {
-      return get_rotate(angle,cx,cy,zoom,cond).swap(*this);
-    }
- 
-    //! Return a resized image.
-    /**
-       \param pdx = Number of columns (new size along the X-axis).
-       \param pdy = Number of rows (new size along the Y-axis).
-       \param pdz = Number of slices (new size along the Z-axis).
-       \param pdv = Number of vector-channels (new size along the V-axis).
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg get_resize(const int pdx=-100,const int pdy=-100,const int pdz=-100,const int pdv=-100,const unsigned int interp=1) const {
-      cimg_test(*this,"CImg<T>::get_resize");
-      const unsigned int 
-	dx = pdx<0?-pdx*width/100:pdx,
-	dy = pdy<0?-pdy*height/100:pdy,
-	dz = pdz<0?-pdz*depth/100:pdz, 
-	dv = pdv<0?-pdv*dim/100:pdv;
-      CImg res(dx?dx:1,dy?dy:1,dz?dz:1,dv?dv:1);
-      if (width==res.width && height==res.height && depth==res.depth && dim==res.dim) return *this;
-      switch (interp) {
-      case 0:                 // 0 filling
-        {
-          unsigned int w = cimg::min(dx,width), h = cimg::min(dy,height), d = cimg::min(dz,depth), v = cimg::min(dv,dim);
-          T *ptr = data;
-          w*=sizeof(T);
-          res.fill(0);
-          for (unsigned int k=0; k<v; k++) for (unsigned int z=0; z<d; z++) for (unsigned int y=0; y<h; y++) {
-            std::memcpy(res.ptr(0,y,z,k),ptr,w); ptr+=width; 
-          }
-        }
-        break;
-      case 1:               // bloc interpolation
-        {
-          const float sx = (float)width/res.width, sy = (float)height/res.height, sz = (float)depth/res.depth, sk = (float)dim/res.dim;
-          float cx,cy,cz,ck=0;
-          cimg_mapV(res,k) { cz = 0; 
-            cimg_mapZ(res,z) { cy = 0; 
-              cimg_mapY(res,y) { cx = 0; 
-                cimg_mapX(res,x) { res(x,y,z,k) = (*this)((unsigned int)cx,(unsigned int)cy,(unsigned int)cz,(unsigned int)ck); cx+=sx;
-                } cy+=sy;
-              } cz+=sz;
-            } ck+=sk;
-          }
-        }
-        break;
-      case 2:               // mosaic filling
-        {
-          cimg_mapXYZV(res,x,y,z,k) res(x,y,z,k) = (*this)(x%width,y%height,z%depth,k%dim);
-        }
-        break;
-      case 3:               // linear interpolation
-        {
-          const float
-            sx = res.width>1?(float)(width-1)/(res.width-1):0,
-            sy = res.height>1?(float)(height-1)/(res.height-1):0,
-            sz = res.depth>1?(float)(depth-1)/(res.depth-1):0,
-            sk = res.dim>1?(float)(dim-1)/(res.dim-1):0;
-          float cx,cy,cz,ck = 0;
-          cimg_mapV(res,k) { cz = 0; 
-            cimg_mapZ(res,z) { cy = 0;
-              cimg_mapY(res,y) { cx = 0; 
-                cimg_mapX(res,x) { res(x,y,z,k) = (T)linear_pix4d(cx,cy,cz,ck); cx+=sx;
-                } cy+=sy;
-              } cz+=sz;
-            } ck+=sk;
-          }
-        }
-        break;
-      case 4:              // grid filling
-        {
-          const float sx = (float)width/res.width, sy = (float)height/res.height, sz = (float)depth/res.depth, sk = (float)dim/res.dim;
-          res.fill(0);
-          cimg_mapXYZV(*this,x,y,z,k) res((int)(x/sx),(int)(y/sy),(int)(z/sz),(int)(k/sk)) = (*this)(x,y,z,k);
-        }
-        break;
-      case 5:             // cubic interpolation
-        {
-          const float
-            sx = res.width>1?(float)(width-1)/(res.width-1):0,
-            sy = res.height>1?(float)(height-1)/(res.height-1):0,
-            sz = res.depth>1?(float)(depth-1)/(res.depth-1):0,
-            sk = res.dim>1?(float)(dim-1)/(res.dim-1):0;
-          float cx,cy,cz,ck = 0;
-          cimg_mapV(res,k) { cz = 0;
-            cimg_mapZ(res,z) { cy = 0;
-              cimg_mapY(res,y) { cx = 0;
-                cimg_mapX(res,x) { res(x,y,z,k) = (T)cubic_pix2d(cx,cy,(int)cz,(int)ck); cx+=sx;
-                } cy+=sy;
-              } cz+=sz;
-            } ck+=sk;
-          }
-        }
-        break;      
-      }
-      return res;
-    }
-    //! Return a resized image.
-    /**
-       \param src = Image giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    template<typename t> CImg get_resize(const CImg<t>& src,const unsigned int interp=1) const {
-      return get_resize(src.width,src.height,src.depth,src.dim,interp); 
-    }  
-
-    //! Return a resized image.
-    /**
-       \param disp = Display giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg get_resize(const CImgDisplay& disp,const unsigned int interp=1) const {
-      return get_resize(disp.width,disp.height,depth,dim,interp);
-    }
-
-    //! Resize the image.
-    /**
-       \param pdx = Number of columns (new size along the X-axis).
-       \param pdy = Number of rows (new size along the Y-axis).
-       \param pdz = Number of slices (new size along the Z-axis).
-       \param pdv = Number of vector-channels (new size along the V-axis).
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).       
-    **/
-    CImg& resize(const int pdx=-100,const int pdy=-100,const int pdz=-100,const int pdv=-100,const unsigned int interp=1) {
-      const unsigned int
-        dx = pdx<0?-pdx*width/100 :(pdx==0?1:pdx),
-        dy = pdy<0?-pdy*height/100:(pdy==0?1:pdy),
-        dz = pdz<0?-pdz*depth/100 :(pdz==0?1:pdz),
-        dv = pdv<0?-pdv*dim/100   :(pdv==0?1:pdv);
-      if (width==dx && height==dy && depth==dz && dim==dv) return *this;
-      else return get_resize(dx,dy,dz,dv,interp).swap(*this);
-    }
-
-    //! Resize the image.
-    /**
-       \param src = Image giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    template<typename t> CImg& resize(const CImg<t>& src,const unsigned int interp=1) { 
-      return resize(src.width,src.height,src.depth,src.dim,interp); 
-    }
-
-    //! Resize the image
-    /**
-       \param disp = Display giving the geometry of the resize.
-       \param interp = Resizing type :
-       - 0 = no interpolation : additionnal space is filled with 0.
-       - 1 = bloc interpolation (nearest point).
-       - 2 = mosaic : image is repeated if necessary.
-       - 3 = linear interpolation.
-       - 4 = grid interpolation.
-       - 5 = bi-cubic interpolation.
-       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
-    **/
-    CImg& resize(const CImgDisplay& disp,const unsigned int interp=1) {
-      return resize(disp.width,disp.height,depth,dim,interp);
-    }
-
-    //! Return an half-resized image, using a special filter.
-    /**
-       \see resize_halfXY(), resize(), get_resize().
-    **/
-    CImg get_resize_halfXY() const {
-      cimg_test(*this,"CImg<T>::get_resize_halfXY");
-      const CImg<float> mask(3,3);
-      mask.fill(0.07842776544f, 0.1231940459f, 0.07842776544f,
-                0.1231940459f,  0.1935127547f, 0.1231940459f,
-                0.07842776544f, 0.1231940459f, 0.07842776544f);
-      CImg_3x3(I,float);
-      CImg dest(width/2,height/2,depth,dim);
-      cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) dest(x/2,y/2,z,k) = (T)cimg_conv3x3(I,mask);
-      return dest;
-    }
-
-    //! Half-resize the image, using a special filter
-    /**
-       \see get_resize_halfXY(), resize(), get_resize().
-    **/
-    CImg& resize_halfXY() {	return get_resize_halfXY().swap(*this); }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param v0 = V-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param v1 = V-coordinate of the lower-right crop rectangle corner.
-       \see crop()
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
-		  const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1) const {
-      cimg_test(*this,"CImg<T>::get_crop");
-      if (x0>=width || x1>=width || y0>=height || y1>=height || z0>=depth || z1>=depth || v0>=dim || v1>=dim || x1<x0 || y1<y0 || z1<z0 || v1<v0)
-        throw CImgArgumentException("CImg<%s>::get_crop() : Bad crop coordinates (%u,%u,%u,%u)-(%u,%u,%u,%u) in image (%u,%u,%u,%u)",
-                                    pixel_type(),x0,y0,z0,v0,x1,y1,z1,v1,width,height,depth,dim);
-      const unsigned int dx=x1-x0+1, dy=y1-y0+1, dz=z1-z0+1, dv=v1-v0+1;
-      CImg dest(dx,dy,dz,dv);
-      T *psrc = ptr(x0,y0,z0,v0), *pdest = dest.ptr(0,0,0,0);
-      if (dx!=width)
-        for (unsigned int k=0; k<dv; k++) {
-          for (unsigned int z=0; z<dz; z++) {
-            for (unsigned int y=0; y<dy; y++) {
-              std::memcpy(pdest,psrc,dx*sizeof(T));
-              pdest+=dx;
-              psrc+=width;
-            }
-            psrc+=width*(height-dy);
-          }
-          psrc+=width*height*(depth-dz);
-        }
-      else {
-        if (dy!=height)         
-          for (unsigned int k=0; k<dv; k++) {
-            for (unsigned int z=0; z<dz; z++) {
-              std::memcpy(pdest,psrc,dx*dy*sizeof(T));
-              pdest+=dx*dy;
-              psrc+=width*height;
-            }
-            psrc+=width*height*(depth-dz);
-          }
-        else {
-          if (dz!=depth)
-            for (unsigned int k=0; k<dv; k++) {
-              std::memcpy(pdest,psrc,dx*dy*dz*sizeof(T));
-              pdest+=dx*dy*dz;
-              psrc+=width*height*depth;
-            }
-          else std::memcpy(pdest,psrc,dx*dy*dz*dv*sizeof(T));
-        }
-      }
-      return dest;
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \see crop()   
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
-		  const unsigned int x1,const unsigned int y1,const unsigned int z1) const {
-      return get_crop(x0,y0,z0,0,x1,y1,z1,dim-1);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \see crop()   
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int y0,
-		  const unsigned int x1,const unsigned int y1) const {
-      return get_crop(x0,y0,0,0,x1,y1,depth-1,dim-1);
-    }
-
-    //! Return a square region of the image, as a new image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \see crop()   
-    **/
-    CImg get_crop(const unsigned int x0,const unsigned int x1) const { return get_crop(x0,0,0,0,x1,height-1,depth-1,dim-1); }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param v0 = V-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \param v1 = V-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,const unsigned int v0,
-	       const unsigned int x1,const unsigned int y1,const unsigned int z1,const unsigned int v1) {
-      return get_crop(x0,y0,z0,v0,x1,y1,z1,v1).swap(*this);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,const unsigned int z0,
-	       const unsigned int x1,const unsigned int y1,const unsigned int z1) {
-      return crop(x0,y0,z0,0,x1,y1,z1,dim-1);
-    }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int y0,
-	       const unsigned int x1,const unsigned int y1) { return crop(x0,y0,0,0,x1,y1,depth-1,dim-1); }
-
-    //! Replace the image by a square region of the image
-    /**
-       \param x0 = X-coordinate of the upper-left crop rectangle corner.
-       \param x1 = X-coordinate of the lower-right crop rectangle corner.
-       \see get_crop()
-    **/
-    CImg& crop(const unsigned int x0,const unsigned int x1) { return crop(x0,0,0,0,x1,height-1,depth-1,dim-1); }
-
-    //! Get the channel \a v of the current image, as a new image.
-    /**
-       \param v0 = vector-channel to return.
-       \see channel(), get_slice(), slice(), get_plane(), plane().
-    **/
-    CImg get_channel(const unsigned int v0=0) const { return get_crop(0,0,0,v0,width-1,height-1,depth-1,v0); }
-
-    //! Get the z-slice \a z of *this, as a new image.
-    /**
-       \param z0 = Z-slice to return.
-       \see slice(), get_channel(), channel(), get_plane(), plane().
-    **/
-    CImg get_slice(const unsigned int z0=0) const { return get_crop(0,0,z0,0,width-1,height-1,z0,dim-1); }
-
-    //! Get the z-slice \a z of the channel \a v of the current image, as a new image.
-    /**
-       \param z0 = Z-slice of the plane to return.
-       \param v0 = V-channel of the plane to return.
-       \see plane(), get_channel(), channel(), get_slice(), slice().
-    **/
-    CImg get_plane(const unsigned int z0=0,const unsigned int v0=0) const { return get_crop(0,0,z0,v0,width-1,height-1,z0,v0); }
-
-    //! Return a reference to a set of points (x0->x1,y0,z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_pointset(const unsigned int xmin,const unsigned int xmax,const unsigned int y0=0,const unsigned int z0=0,const unsigned int v0=0) const {
-      cimg_test(*this,"CImg<T>::ref_pointset");
-      if (xmax<xmin || xmax>=width || y0>=height || z0>=depth || v0>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_pointset() : Cannot return a reference (%u->%u,%u,%u,%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),xmin,xmax,y0,z0,v0,width,height,depth,dim);
-      return CImgROI<T>(1+xmax-xmin,1,1,1,ptr(xmin,y0,z0,v0));
-    }
-
-    //! Return a reference to a set of lines (y0->y1,z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_lineset(const unsigned int ymin,const unsigned int ymax,const unsigned int z0=0,const unsigned int v0=0) const {
-      cimg_test(*this,"CImg<T>::ref_lineset");
-      if (ymax<ymin || ymax>=height || z0>=depth || v0>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_lineset() : Cannot return a reference (0->%u,%u->%u,%u,%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),width-1,ymin,ymax,z0,v0,width,height,depth,dim);
-      return CImgROI<T>(width,1+ymax-ymin,1,1,ptr(0,ymin,z0,v0));
-    }
-  
-    //! Return a reference to a set of planes (z0->z1,v0) of the image. Use it carefully !
-    CImgROI<T> ref_planeset(const unsigned int zmin,const unsigned int zmax,const unsigned int v0=0) const {
-      cimg_test(*this,"CImg<T>::ref_planeset");
-      if(zmax<zmin || zmax>=depth || v0>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_planeset() : Cannot return a reference (0->%u,0->%u,%u->%u,%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),width-1,height-1,zmin,zmax,v0,width,height,depth,dim);
-      return CImgROI<T>(width,height,1+zmax-zmin,1,ptr(0,0,zmin,v0));
-    }
-
-    //! Return a reference to a set of channels (v0->v1) of the image. Use it carefully !
-    CImgROI<T> ref_channelset(const unsigned int vmin,const unsigned int vmax) const {
-      cimg_test(*this,"CImg<T>::ref_channelset");
-      if (vmax<vmin || vmax>=dim)
-        throw CImgArgumentException("CImg<%s>::ref_channelset() : Cannot return a reference (0->%u,0->%u,0->%u,%u->%u) from a (%u,%u,%u,%u) image",
-                                    pixel_type(),width-1,height-1,depth-1,vmin,vmax,width,height,depth,dim);
-      return CImgROI<T>(width,height,depth,1+vmax-vmin,ptr(0,0,0,vmin));
-    }
-  
-    //! Return a reference to a line (y0,z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_line(const unsigned int y0,const unsigned int z0=0,const unsigned int v0=0) const { return ref_pointset(0,width-1,y0,z0,v0); }
-
-    //! Return a reference to a plane (z0,v0) of the image. Use it carefully !
-    CImgROI<T> ref_plane(const unsigned int z0,const unsigned int v0=0) const { return ref_lineset(0,height-1,z0,v0); }
-
-    //! Return a reference to a channel (v0) of the image. Use it carefully !
-    CImgROI<T> ref_channel(const unsigned int v0) const { return ref_planeset(0,depth-1,v0); }
-
-    //! Replace the image by one of its channel
-    CImg& channel(const unsigned int v0=0) { return get_channel(v0).swap(*this); }
-
-    //! Replace the image by one of its z-slice
-    CImg& slice(const unsigned int z0=0) { return get_slice(z0).swap(*this); }
-
-    //! Replace the image by one of its plane
-    CImg& plane(const unsigned int z0=0, const unsigned int v0=0) { return get_plane(z0,v0).swap(*this); }
-  
-    //! Flip an image along the specified axis
-    CImg& flip(const char axe='x') {
-      cimg_test(*this,"CImg<T>::flip");
-      T *pf,*pb,*buf=NULL;
-      switch (axe) {
-      case 'x':
-        {
-          pf = ptr(); pb = ptr(width-1);
-          for (unsigned int yzv=0; yzv<height*depth*dim; yzv++) { 
-            for (unsigned int x=0; x<width/2; x++) { const T val = *pf; *(pf++)=*pb; *(pb--)=val; }
-            pf+=width-width/2;
-            pb+=width+width/2;
-          }
-        }
-        break;
-      case 'y':
-        {
-          buf = new T[width];
-          pf = ptr(); pb = ptr(0,height-1);
-          for (unsigned int zv=0; zv<depth*dim; zv++) {
-            for (unsigned int y=0; y<height/2; y++) {
-              std::memcpy(buf,pf,width*sizeof(T));
-              std::memcpy(pf,pb,width*sizeof(T));
-              std::memcpy(pb,buf,width*sizeof(T));
-              pf+=width;
-              pb-=width;
-            }
-            pf+=width*(height-height/2);
-            pb+=width*(height+height/2);
-          }
-        }
-        break;
-      case 'z':
-        {
-          buf = new T[width*height];
-          pf = ptr(); pb = ptr(0,0,depth-1);
-          cimg_mapV(*this,v) {
-            for (unsigned int z=0; z<depth/2; z++) {
-              std::memcpy(buf,pf,width*height*sizeof(T));
-              std::memcpy(pf,pb,width*height*sizeof(T));
-              std::memcpy(pb,buf,width*height*sizeof(T));
-              pf+=width*height;
-              pb-=width*height;
-            }
-            pf+=width*height*(depth-depth/2);
-            pb+=width*height*(depth+depth/2);
-          }
-        }
-        break;
-      case 'v':
-        {
-          buf = new T[width*height*depth];
-          pf = ptr(); pb = ptr(0,0,0,dim-1);
-          for (unsigned int v=0; v<dim/2; v++) {
-            std::memcpy(buf,pf,width*height*depth*sizeof(T));
-            std::memcpy(pf,pb,width*height*depth*sizeof(T));
-            std::memcpy(pb,buf,width*height*depth*sizeof(T));
-            pf+=width*height*depth;
-            pb-=width*height*depth;
-          }
-        }
-        break;
-      default: cimg::warn(true,"CImg<%s>::flip() : unknow axe '%c', should be 'x','y','z' or 'v'",pixel_type(),axe);
-      }
-      if (buf) delete[] buf;
-      return *this;
-    }
-    //! Get a flipped version of the image, along the specified axis
-    CImg get_flip(const char axe='x') { return CImg<T>(*this).flip(axe); }
-    
-    //! Return a 2D representation of a 3D image, with three slices.
-    CImg get_3dplanes(const unsigned int px0,const unsigned int py0,const unsigned int pz0) const {
-      cimg_test(*this,"CImg<T>::get_3dplanes");
-      const unsigned int
-        x0=(px0>=width)?width-1:px0,
-        y0=(py0>=height)?height-1:py0,
-        z0=(pz0>=depth)?depth-1:pz0;
-      CImg res(width+depth,height+depth,1,dim);
-      res.fill((*this)[0]);
-      { cimg_mapXYV(*this,x,y,k) res(x,y,0,k)        = (*this)(x,y,z0,k); }
-      { cimg_mapYZV(*this,y,z,k) res(width+z,y,0,k)  = (*this)(x0,y,z,k); }
-      { cimg_mapXZV(*this,x,z,k) res(x,height+z,0,k) = (*this)(x,y0,z,k); }
-      return res;
-    }
-
-    //! Return the histogram of the image
-    CImg<float> get_histogram(const unsigned int nblevels=256,const T val_min=(T)0,const T val_max=(T)0) const {
-      cimg_test(*this,"CImg<T>::get_histogram");
-      if (nblevels<1) {
-        throw CImgArgumentException("CImg<%s>::get_histogram() : Can't compute an histogram with %u levels",
-                                    pixel_type(),nblevels);
-      }
-      T vmin=val_min,vmax=val_max;
-      CImg<float> res(nblevels,1,1,1,0);
-      if (vmin==vmax && vmin==0) { CImgStats st(*this,false); vmin = (T)st.min; vmax = (T)st.max; }
-      cimg_map(*this,ptr,T) { const int pos = (int)((*ptr-vmin)*(nblevels-1)/(vmax-vmin)); if (pos>=0 && pos<(int)nblevels) res[pos]++; }
-      return res;
-    }
-
-    //! Equalize the image histogram
-    CImg& equalize_histogram(const unsigned int nblevels=256) {
-      cimg_test(*this,"CImg<T>::equalize_histogram");
-      CImgStats st(*this,false);
-      CImg<float> hist = get_histogram(nblevels,(T)st.min,(T)st.max);
-      float cumul=0;
-      cimg_mapX(hist,pos) { cumul+=hist[pos]; hist[pos]=cumul; }
-      cimg_map(*this,ptr,T) {
-        unsigned int pos = (unsigned int)((*ptr-st.min)*nblevels/(1+st.max-st.min));
-        *ptr = (T)(st.min + (st.max-st.min)*hist[pos]/size());
-      }
-      return *this;
-    }
-    //! Return the histogram-equalized version of the current image.
-    CImg get_equalize_histogram(const unsigned int nblevels=256) const { return CImg<T>(*this).equalize_histogram(nblevels); }
-
-    //! Return the image of the vector norms of the current image.
-    CImg<float> get_norm_pointwise(int ntype=2) const {
-      cimg_test(*this,"CImg<T>::get_norm_pointwise");
-      CImg<float> res(width,height,depth);
-      switch(ntype) {
-      case -1:                // Linf norm
-        {
-          cimg_mapXYZ(*this,x,y,z) {
-            float n=0; cimg_mapV(*this,v) if (std::fabs((double)((*this)(x,y,z,v)))>n) n=(float)(*this)(x,y,z,v); res(x,y,z) = n;
-          }
-        } break;
-      case 1:               // L1 norm
-        {
-          cimg_mapXYZ(*this,x,y,z) {
-            float n=0; cimg_mapV(*this,v) n+=(float)std::fabs((double)((*this)(x,y,z,v))); res(x,y,z) = n;
-          }
-        } break;
-      default:              // L2 norm
-        {
-          cimg_mapXYZ(*this,x,y,z) {
-            float n=0; cimg_mapV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v)); res(x,y,z) = (float)std::sqrt((double)n);
-          }
-        } break;
-      }
-      return res;
-    }
-
-    //! Replace each pixel value with its vector norm
-    CImg& norm_pointwise() { return CImg<T>(get_norm_pointwise()).swap(*this); }
-
-    //! Return an image of the normalized vectors
-    CImg get_orientation_pointwise() const {
-      cimg_test(*this,"CImg<T>::get_orientation_pointwise");
-      CImg dest(width,height,depth,dim);
-      cimg_mapXYZ(dest,x,y,z) {
-        float n = 0;
-        cimg_mapV(*this,v) n+=(float)((*this)(x,y,z,v)*(*this)(x,y,z,v));
-        n = (float)std::sqrt((double)n);
-        if (n>0) cimg_mapV(dest,v) dest(x,y,z,v)=(T)((*this)(x,y,z,v)/n); else cimg_mapV(dest,v) dest(x,y,z,v)=0;
-      }
-      return dest;
-    }
-
-    //! Replace each pixel value with its normalized vector component
-    CImg& orientation_pointwise() { return get_orientation_pointwise().swap(*this); }
-
-    //! Split current image into a list.
-    /**
-       - Splitting process is done along the specified dimension \c Axe.
-    **/
-    CImgl<T> get_split(const char axe='v',const unsigned int nb=0) const {
-      cimg_test(*this,"CImg<T>::get_split");
-      const char naxe = cimg::uncase(axe);
-      if (naxe!='x' && naxe!='y' && naxe!='z' && naxe!='v')
-	throw CImgArgumentException("CImg<%s>::get_split() : Unknow axe '%c', use rather 'x','y','z' or 'v'",pixel_type(),axe);
-      CImgl<T> res;
-      switch (naxe) {
-      case 'x':
-	res = CImgl<T>(nb?nb:width);
-	cimgl_map(res,l) res[l] = get_crop(l*width/res.size,0,0,0,(l+1)*width/res.size-1,height-1,depth-1,dim-1);
-	break;
-      case 'y':
-	res = CImgl<T>(nb?nb:height);
-	cimgl_map(res,l) res[l] = get_crop(0,l*height/res.size,0,0,width-1,(l+1)*height/res.size-1,depth-1,dim-1);
-	break;
-      case 'z':
-	res = CImgl<T>(nb?nb:depth);
-	cimgl_map(res,l) res[l] = get_crop(0,0,l*depth/res.size,0,width-1,height-1,(l+1)*depth/res.size-1,dim-1);
-	break;
-      case 'v':
-	res = CImgl<T>(nb?nb:dim);
-	cimgl_map(res,l) res[l] = get_crop(0,0,0,l*dim/res.size,width-1,height-1,depth-1,(l+1)*dim/res.size-1);
-	break;
-      }
-      return res;
-    }
-
-    //! Return a list of images, corresponding to the XY-gradients of an image.
-    CImgl<T> get_gradientXY(const int scheme=0) const {
-      cimg_test(*this,"CImg<T>::get_gradientXY");
-      CImgl<T> res(2,width,height,depth,dim);
-      CImg_3x3(I,T);
-      switch(scheme) {
-      case -1: { // backward finite differences
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) { res[0](x,y,z,k) = Icc-Ipc; res[1](x,y,z,k) = Icc-Icp; } 
-      } break;
-      case 1: { // forward finite differences
-        cimg_mapZV(*this,z,k) cimg_map2x2(*this,x,y,z,k,I) { res[0](x,y,0,k) = Inc-Icc; res[1](x,y,z,k) = Icn-Icc; }
-      } break;
-      case 2: { // using Sobel mask
-        const float a = 1, b = 2;
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = (T)(-a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn);
-          res[1](x,y,z,k) = (T)(-a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn);
-        }
-      } break;
-      case 3: { // using rotation invariant mask
-        const float a = (float)(0.25*(2-std::sqrt(2.0))), b = (float)(0.5f*(std::sqrt(2.0)-1));
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = (T)(-a*Ipp-b*Ipc-a*Ipn+a*Inp+b*Inc+a*Inn);
-          res[1](x,y,z,k) = (T)(-a*Ipp-b*Icp-a*Inp+a*Ipn+b*Icn+a*Inn);
-        }
-      } break;
-      case 0:   
-      default: { // central finite differences
-        cimg_mapZV(*this,z,k) cimg_map3x3(*this,x,y,z,k,I) { 
-          res[0](x,y,z,k) = (T)(0.5*(Inc-Ipc));
-          res[1](x,y,z,k) = (T)(0.5*(Icn-Icp)); 
-        } 
-      } break;
-      }
-      return res;
-    }
-
-    //! Return a list of images, corresponding to the XYZ-gradients of an image.
-    CImgl<T> get_gradientXYZ(const int scheme=0) const {
-      cimg_test(*this,"CImg<T>::get_gradientXYZ");
-      CImgl<T> res(3,width,height,depth,dim);
-      CImg_3x3x3(I,T);
-      switch(scheme) {
-      case -1: { // backward finite differences
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) { 
-          res[0](x,y,z,k) = Iccc-Ipcc;
-          res[1](x,y,z,k) = Iccc-Icpc;
-          res[2](x,y,z,k) = Iccc-Iccp; 
-        }
-      } break;
-      case 1: { // forward finite differences
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = Incc-Iccc; 
-          res[1](x,y,z,k) = Icnc-Iccc;
-          res[2](x,y,z,k) = Iccn-Iccc; 
-        } 
-      } break;
-      case 0: 
-      default: { // central finite differences
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) {
-          res[0](x,y,z,k) = (T)(0.5*(Incc-Ipcc));
-          res[1](x,y,z,k) = (T)(0.5*(Icnc-Icpc)); 
-          res[2](x,y,z,k) = (T)(0.5*(Iccn-Iccp)); 
-        } 
-      } break;
-      }
-      return res;
-    }
-
-    //@}
-    //--------------------------------------
-    //--------------------------------------
-    //
-    //! \name Color conversion functions
-    //@{
-    //--------------------------------------
-    //--------------------------------------
-  
-    //! Convert color pixels from (R,G,B) to (X,Y,Z)_709.
-    CImg& RGBtoXYZ() {
-      cimg_test(*this,"CImg<T>::RGBtoXYZ");
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::RGBtoXYZ() : Input image dimension is dim=%u, should be a (R,G,B) image (dim=3)",
-                                              pixel_type(),dim);
-      cimg_mapXYZ(*this,x,y,z) {
-        const T R = (*this)(x,y,z,0), G = (*this)(x,y,z,1), B = (*this)(x,y,z,2);
-        (*this)(x,y,z,0) = (T)(0.412453*R + 0.357580*G + 0.180423*B);
-        (*this)(x,y,z,1) = (T)(0.212671*R + 0.715160*G + 0.072169*B);
-        (*this)(x,y,z,2) = (T)(0.019334*R + 0.119193*G + 0.950227*B);
-      }
-      return *this;
-    }
-    //! Get a new image with (X,Y,Z) color-based pixels from a (R,G,B) image.
-    CImg get_RGBtoXYZ() const { return CImg<T>(*this).RGBtoXYZ(); }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (R,G,B) color space.
-    CImg& XYZtoRGB() {
-      cimg_test(*this,"CImg<T>::XYZtoRGB");
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoRGB() : Input image dimension is dim=%u, should be a (X,Y,Z) image (dim=3)",
-                                              pixel_type(),dim);
-      cimg_mapXYZ(*this,x,y,z) {
-        const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
-        (*this)(x,y,z,0) = (T)(3.240479*X  - 1.537150*Y - 0.498535*Z);
-        (*this)(x,y,z,1) = (T)(-0.969256*X + 1.875992*Y + 0.041556*Z);
-        (*this)(x,y,z,2) = (T)(0.055648*X  - 0.204043*Y + 1.057311*Z);
-      }
-      return *this;
-    }
-    //! Get a new image with (R,G,B) color-based pixels from a (X,Y,Z) image.
-    CImg get_XYZtoRGB() const { return CImg<T>(*this).XYZtoRGB(); }
-
-    //! Convert (X,Y,Z)_709 pixels of a color image into the (L*,a*,b*) color space.
-    CImg& XYZtoLab() {
-      cimg_test(*this,"CImg<T>::XYZtoLab");
-      if (dim!=3) throw CImgInstanceException("CImg<%s>::XYZtoLab() : Input image dimension is dim=%u, should be a (X,Y,Z) image (dim=3)",
-                                              pixel_type(),dim);
-      CImg<double> white = CImg<double>(1,1,1,3).fill(1,1,1).RGBtoXYZ();
-      const double Xn = white(0), Yn = white(1), Zn = white(2);
-    
-      cimg_mapXYZ(*this,x,y,z) {
-        const T X = (*this)(x,y,z,0), Y = (*this)(x,y,z,1), Z = (*this)(x,y,z,2);
-        const double L = (T)(116*std::pow(Y/Yn,1/3.0)-16);
-        (*this)(x,y,z,0) = (T)(L>=0?L:0);
-        (*this)(x,y,z,1) = (T)(500*(std::pow(X/Xn,1/3.0)-std::pow(Y/Yn,1/3.0)));
-        (*this)(x,y,z,2) = (T)(200*(std::pow(Y/Yn,1/3.0)-std::pow(Z/Zn,1/3.0)));
-      }
-      return *this;
-    }
-    //! Get a new image with (L,a,b) color-based pixels from a (X,Y,Z) image.
-    CImg get_XYZtoLab() const { return CImg<T>(*this).XYZtoLab(); }
-
-    //@}
-    //--------------------------------------
-    //--------------------------------------
-    //
-    //! \name Drawing functions
-    //@{
-    //--------------------------------------
-    //--------------------------------------
-  
-    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0,\c z0).
-    /**
-       \param x0 = X-coordinate of the vector-valued pixel to plot.
-       \param y0 = Y-coordinate of the vector-valued pixel to plot.
-       \param z0 = Z-coordinate of the vector-valued pixel to plot.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_point(const int x0,const int y0,const int z0,
-                     const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_point");
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_point() : specified color is (null)",pixel_type());
-      if (x0>=0 && y0>=0 && z0>=0 && x0<dimx() && y0<dimy() && z0<dimz()) {
-        const T *col=color;
-        const unsigned int whz = width*height*depth;
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        T *ptrd = ptr(x0,y0,z0,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = *(col++); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd=(T)(*(col++)*nopacity + *ptrd*copacity); ptrd+=whz; }
-      }
-      return *this;
-    }
-
-    //! Draw a colored point in the instance image, at coordinates (\c x0,\c y0).
-    /**
-       \param x0 = X-coordinate of the vector-valued pixel to plot.
-       \param y0 = Y-coordinate of the vector-valued pixel to plot.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_point(const int x0,const int y0,const T *const color,const float opacity=1) { 
-      return draw_point(x0,y0,0,color,opacity); 
-    }
-
-    //! Draw a 2D colored line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = A long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
-                    const T *const color,const unsigned long pattern=~0L,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_line"); 
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : specified color is (null)",pixel_type());
-      const T* col=color;
-      unsigned long hatch=1;     
-      int nx0=x0, nx1=x1, ny0=y0, ny1=y1;
-      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (nx1<0 || nx0>=dimx()) return *this;
-      if (nx0<0) { ny0-=nx0*(ny1-ny0)/(nx1-nx0); nx0=0; }
-      if (nx1>=dimx()) { ny1+=(nx1-dimx())*(ny0-ny1)/(nx1-nx0); nx1=dimx()-1;}
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (ny1<0 || ny0>=dimy()) return *this;
-      if (ny0<0) { nx0-=ny0*(nx1-nx0)/(ny1-ny0); ny0=0; }
-      if (ny1>=dimy()) { nx1+=(ny1-dimy())*(nx0-nx1)/(ny1-ny0); ny1=dimy()-1;}
-      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),ny1-ny0), whz = width*height*depth;
-      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0;
-      float x = (float)nx0, y = (float)ny0;
-      if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) {
-        if (!(~pattern) || (~pattern && pattern&hatch)) {
-          T* ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);      
-          cimg_mapV(*this,k) { *ptrd=*(col++); ptrd+=whz; }
-          col-=dim;
-        }
-        x+=px; y+=py; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
-      } else {
-        const float nopacity = cimg::abs(opacity), copacity=1-cimg::max(opacity,0.0f);
-        for (unsigned int t=0; t<=dmax; t++) {
-          if (!(~pattern) || (~pattern && pattern&hatch)) {
-            T* ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-            cimg_mapV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
-            col-=dim;
-          }
-          x+=px; y+=py; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
-        }
-      }
-      return *this;
-    }
-  
-    //! Draw a 3D colored line in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param z0 = Z-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param Z1 = Z-coordinate of the ending point of the line.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = A long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_line(const int x0,const int y0,const int z0,const int x1,const int y1,const int z1,
-                    const T *const color,const unsigned long pattern=~0L,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_line"); 
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_line() : specified color is (null)",pixel_type());
-      const T* col=color;
-      unsigned long hatch=1;
-      int nx0=x0, ny0=y0, nz0=z0, nx1=x1, ny1=y1, nz1=z1;
-      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-      if (nx1<0 || nx0>=dimx()) return *this;
-      if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; nz0-=nx0*(nz1-nz0)/D; nx0=0; }
-      if (nx1>=dimx()) { const int d=nx1-dimx(), D=nx1-nx0; ny1+=d*(ny0-ny1)/D; nz1+=d*(nz0-nz1)/D; nx1=dimx()-1;}
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-      if (ny1<0 || ny0>=dimy()) return *this;
-      if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; nz0-=ny0*(nz1-nz0)/D; ny0=0; }
-      if (ny1>=dimy()) { const int d=ny1-dimy(), D=ny1-ny0; nx1+=d*(nx0-nx1)/D; nz1+=d*(nz0-nz1)/D; ny1=dimy()-1;}
-      if (nz0>nz1) cimg::swap(nx0,nx1,ny0,ny1,nz0,nz1);
-      if (nz1<0 || nz0>=dimz()) return *this;
-      if (nz0<0) { const int D=nz1-nz0; nx0-=nz0*(nx1-nx0)/D; ny0-=nz0*(ny1-ny0)/D; nz0=0; }
-      if (nz1>=dimz()) { const int d=nz1-dimz(), D=nz1-nz0; nx1+=d*(nx0-nx1)/D; ny1+=d*(ny0-ny1)/D; nz1=dimz()-1;}
-      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),std::abs(ny1-ny0),nz1-nz0), whz = width*height*depth;
-      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0, pz = dmax?(nz1-nz0)/(float)dmax:0;
-      float x = (float)nx0, y = (float)ny0, z = (float)nz0;
-      if (opacity>=1) for (unsigned int t=0; t<=dmax; t++) { 
-        if (!(~pattern) || (~pattern && pattern&hatch)) {
-          T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
-          cimg_mapV(*this,k) { *ptrd=*(col++); ptrd+=whz; }        
-          col-=dim; 
-        }
-        x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));
-      } else {
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        for (unsigned int t=0; t<=dmax; t++) { 
-          if (!(~pattern) || (~pattern && pattern&hatch)) {
-            T* ptrd = ptr((unsigned int)x,(unsigned int)y,(unsigned int)z,0);
-            cimg_mapV(*this,k) { *ptrd = (T)(*(col++)*nopacity + copacity*(*ptrd)); ptrd+=whz; }
-            col-=dim; 
-          }
-          x+=px; y+=py; z+=pz; if (pattern) hatch=(hatch<<1)+(hatch>>(sizeof(unsigned long)*8-1));        
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D textured line in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the line.
-       \param y0 = Y-coordinate of the starting point of the line.
-       \param x1 = X-coordinate of the ending point of the line.
-       \param y1 = Y-coordinate of the ending point of the line.
-       \param texture = a colored texture image used to draw the line color.
-       \param tx0 = X-coordinate of the starting point of the texture.
-       \param ty0 = Y-coordinate of the starting point of the texture.
-       \param tx1 = X-coordinate of the ending point of the texture.
-       \param ty1 = Y-coordinate of the ending point of the texture.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param pattern = a long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_line(const int x0,const int y0,const int x1,const int y1,
-                                         const CImg<t>& texture,
-                                         const int tx0,const int ty0,const int tx1,const int ty1,
-                                         const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_line"); cimg_test(texture,"CImg<T>::draw_line");
-      if (texture.dim<dim)
-        throw CImgArgumentException("CImg<%s>::draw_line() : texture has %u channel while image has %u channels",texture.dim,dim);
-      int nx0=x0, ny0=y0, nx1=x1, ny1=y1, ntx0=tx0, nty0=ty0, ntx1=tx1, nty1=ty1;
-      if (nx0>nx1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-      if (nx1<0 || nx0>=dimx()) return *this;
-      if (nx0<0) { const int D=nx1-nx0; ny0-=nx0*(ny1-ny0)/D; ntx0-=nx0*(ntx1-ntx0)/D; nty0-=nx0*(nty1-nty0)/D; nx0=0; }
-      if (nx1>=dimx()) { const int d=nx1-dimx(),D=nx1-nx0; ny1+=d*(ny0-ny1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; nx1=dimx()-1; }
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-      if (ny1<0 || ny0>=dimy()) return *this;
-      if (ny0<0) { const int D=ny1-ny0; nx0-=ny0*(nx1-nx0)/D; ntx0-=ny0*(ntx1-ntx0)/D; nty0-=ny0*(nty1-nty0)/D; ny0=0; }
-      if (ny1>=dimy()) { const int d=ny1-dimy(),D=ny1-ny0; nx1+=d*(nx0-nx1)/D; ntx1+=d*(ntx0-ntx1)/D; nty1+=d*(nty0-nty1)/D; ny1=dimy()-1; }
-      const unsigned int dmax = (unsigned int)cimg::max(std::abs(nx1-nx0),ny1-ny0), 
-        whz = width*height*depth, twhz = texture.width*texture.height*texture.depth;
-      const float px = dmax?(nx1-nx0)/(float)dmax:0, py = dmax?(ny1-ny0)/(float)dmax:0,
-        tpx = dmax?(ntx1-ntx0)/(float)dmax:0, tpy = dmax?(nty1-nty0)/(float)dmax:0;
-      float x = (float)nx0, y = (float)ny0, tx = (float)ntx0, ty = (float)nty0;
-      if (opacity>=1) for (unsigned int tt=0; tt<=dmax; tt++) { 
-        T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-        t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
-        cimg_mapV(*this,k) { *ptrd = (T)(*ptrs); ptrd+=whz; ptrs+=twhz; }
-        x+=px; y+=py; tx+=tpx; ty+=tpy;
-      } else {
-        const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-        for (unsigned int tt=0; tt<=dmax; tt++) { 
-          T *ptrd = ptr((unsigned int)x,(unsigned int)y,0,0);
-          t *ptrs = texture.ptr((unsigned int)tx,(unsigned int)ty,0,0);
-          cimg_mapV(*this,k) { *ptrd = (T)(nopacity*(*ptrs) + copacity*(*ptrd)); ptrd+=whz; ptrs+=twhz; }
-          x+=px; y+=py; tx+=tpx; ty+=tpy;
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a 2D colored arrow in the instance image, at coordinates (\c x0,\c y0)->(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the starting point of the arrow (tail).
-       \param y0 = Y-coordinate of the starting point of the arrow (tail).
-       \param x1 = X-coordinate of the ending point of the arrow (head).
-       \param y1 = Y-coordinate of the ending point of the arrow (head).
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param angle = aperture angle of the arrow head
-       \param length = length of the arrow head. If <0, described as a percentage of the arrow length.
-       \param pattern = a long integer whose bits describes the line pattern.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_arrow(const int x0,const int y0,const int x1,const int y1,
-                     const T *const color,
-                     const float angle=30,const float length=-10,const unsigned long pattern=~0L,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_arrow");
-      const float u = (float)(x0-x1), v = (float)(y0-y1), sq = u*u+v*v,
-        deg = (float)(angle*cimg::PI/180), ang = (sq>0)?(float)std::atan2(v,u):0.0f,
-        l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
-      if (sq>0) {
-        const double cl = std::cos(ang-deg), sl = std::sin(ang-deg), cr = std::cos(ang+deg), sr = std::sin(ang+deg);        
-        const int 
-          xl = x1+(int)(l*cl), yl = y1+(int)(l*sl),
-          xr = x1+(int)(l*cr), yr = y1+(int)(l*sr),
-          xc = x1+(int)((l+1)*(cl+cr))/2, yc = y1+(int)((l+1)*(sl+sr))/2;
-        draw_line(x0,y0,xc,yc,color,pattern,opacity).draw_triangle(x1,y1,xl,yl,xr,yr,color,opacity);
-      } else draw_point(x0,y0,color,opacity);
-      return *this;
-    }
-
-    //! Draw a sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
-    /**
-       \param sprite = sprite image.
-       \param x0 = X-coordinate of the sprite position in the instance image.
-       \param y0 = Y-coordinate of the sprite position in the instance image.
-       \param z0 = Z-coordinate of the sprite position in the instance image.
-       \param v0 = V-coordinate of the sprite position in the instance image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t> CImg& draw_image(const CImg<t>& sprite,
-                                          const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image");
-      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-      const int 
-        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-      const t *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
-        (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
-      const unsigned int
-        offX = width-lX, soffX = sprite.width-lX,
-        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          for (int z=0; z<lZ; z++) {
-            for (int y=0; y<lY; y++) {
-              if (opacity>=1) for (int x=0; x<lX; x++) *(ptrd++) = (T)(*(ptrs++));
-              else for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
-              ptrd+=offX; ptrs+=soffX;
-            }
-            ptrd+=offY; ptrs+=soffY;
-          }
-          ptrd+=offZ; ptrs+=soffZ;
-        }
-      return *this;
-    }
-
-#if ( !defined(_MSC_VER) || _MSC_VER>1200 )
-    CImg& draw_image(const CImg<T>& sprite,const int x0=0,const int y0=0,const int z0=0,const int v0=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image");
-      if (this==&sprite) return draw_image(CImg<T>(sprite),x0,y0,z0,v0,opacity);
-      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-      const int 
-        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),
-        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);
-      const T *ptrs = sprite.ptr()-(bx?x0:0)-(by?y0*sprite.dimx():0)+(bz?z0*sprite.dimx()*sprite.dimy():0)+
-        (bv?v0*sprite.dimx()*sprite.dimy()*sprite.dimz():0);
-      const unsigned int
-        offX = width-lX, soffX = sprite.width-lX,
-        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ),
-        slX = lX*sizeof(T);    
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          for (int z=0; z<lZ; z++) {
-            if (opacity>=1) for (int y=0; y<lY; y++) { std::memcpy(ptrd,ptrs,slX); ptrd+=width; ptrs+=sprite.width; }
-            else for (int y=0; y<lY; y++) {
-              for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*(*(ptrs++)) + copacity*(*ptrd)); ptrd++; }
-              ptrd+=offX; ptrs+=soffX;
-            }
-            ptrd+=offY; ptrs+=soffY;
-          }
-          ptrd+=offZ; ptrs+=soffZ;
-        }
-      return *this;
-    }
-#endif
-
-    //! Draw a masked sprite image in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0).
-    /**
-       \param sprite = sprite image.
-       \param mask = mask image.
-       \param x0 = X-coordinate of the sprite position in the instance image.
-       \param y0 = Y-coordinate of the sprite position in the instance image.
-       \param z0 = Z-coordinate of the sprite position in the instance image.
-       \param v0 = V-coordinate of the sprite position in the instance image.
-       \param mask_valmax = Maximum pixel value of the mask image \c mask.
-       \param opacity = opacity of the drawing.
-       \note Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
-       \note Clipping is supported.
-       \note Dimensions along x,y and z of \c sprite and \c mask must be the same.
-    **/
-    template<typename ti,typename tm> CImg& draw_image(const CImg<ti>& sprite,const CImg<tm>& mask,
-                                                       const int x0=0,const int y0=0,const int z0=0,const int v0=0,
-                                                       const tm mask_valmax=1,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_image"); cimg_test(sprite,"CImg<T>::draw_image"); cimg_test(mask,"CImg<T>::draw_image");
-      if ((void*)this==(void*)&sprite) return draw_image(CImg<T>(sprite),mask,x0,y0,z0,v0);
-      if(mask.width!=sprite.width || mask.height!=sprite.height || mask.depth!=sprite.depth)
-        throw CImgArgumentException("CImg<%s>::draw_image() : mask dimension is (%u,%u,%u,%u), while sprite is (%u,%u,%u,%u)",
-                                    pixel_type(),mask.width,mask.height,mask.depth,mask.dim,sprite.width,sprite.height,sprite.depth,sprite.dim);
-      const bool bx=(x0<0), by=(y0<0), bz=(z0<0), bv=(v0<0);
-      const int
-        lX = sprite.dimx() - (x0+sprite.dimx()>dimx()?x0+sprite.dimx()-dimx():0) + (bx?x0:0),
-        lY = sprite.dimy() - (y0+sprite.dimy()>dimy()?y0+sprite.dimy()-dimy():0) + (by?y0:0),
-        lZ = sprite.dimz() - (z0+sprite.dimz()>dimz()?z0+sprite.dimz()-dimz():0) + (bz?z0:0),      
-        lV = sprite.dimv() - (v0+sprite.dimv()>dimv()?v0+sprite.dimv()-dimv():0) + (bv?v0:0);    
-      const int coff = -(bx?x0:0)-(by?y0*mask.dimx():0)-(bz?z0*mask.dimx()*mask.dimy():0)-
-        (bv?v0*mask.dimx()*mask.dimy()*mask.dimz():0),
-        ssize = mask.dimx()*mask.dimy()*mask.dimz();
-      const ti *ptrs = sprite.ptr() + coff;
-      const tm *ptrm = mask.ptr() + coff;
-      const unsigned int
-        offX = width-lX, soffX = sprite.width-lX,
-        offY = width*(height-lY), soffY = sprite.width*(sprite.height-lY),
-        offZ = width*height*(depth-lZ), soffZ = sprite.width*sprite.height*(sprite.depth-lZ);
-      T *ptrd = ptr(x0<0?0:x0,y0<0?0:y0,z0<0?0:z0,v0<0?0:v0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          ptrm = mask.data + (ptrm - mask.data)%ssize;
-          for (int z=0; z<lZ; z++) {
-            for (int y=0; y<lY; y++) {
-              for (int x=0; x<lX; x++) {
-                const float mopacity = *(ptrm++)*opacity,
-                  nopacity = cimg::abs(mopacity), copacity = mask_valmax-cimg::max(mopacity,0.0f);
-                *(ptrd++) = (T)((nopacity*(*(ptrs++))+copacity*(*ptrd))/mask_valmax);
-              }
-              ptrd+=offX; ptrs+=soffX; ptrm+=soffX;
-            }
-            ptrd+=offY; ptrs+=soffY; ptrm+=soffY;
-          }
-          ptrd+=offZ; ptrs+=soffZ; ptrm+=soffZ;
-        }
-      return *this;
-    }
-
-    //! Draw a 4D filled rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0,\c v0)-(\c x1,\c y1,\c z1,\c v1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
-       \param v0 = V-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
-       \param v1 = V-coordinate of the lower-right rectangle corner in the instance image.
-       \param val = scalar value used to fill the rectangle area.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int z0,const int v0,
-                         const int x1,const int y1,const int z1,const int v1,
-                         const T& val,float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_rectangle");
-      const bool bx=(x0<x1), by=(y0<y1), bz=(z0<z1), bv=(v0<v1);
-      const int nx0=bx?x0:x1, nx1=bx?x1:x0, ny0=by?y0:y1, ny1=by?y1:y0, nz0=bz?z0:z1, nz1=bz?z1:z0, nv0=bv?v0:v1, nv1=bv?v1:v0;
-      const int 
-        lX = (1+nx1-nx0) + (nx1>=dimx()?dimx()-1-nx1:0) + (nx0<0?nx0:0),
-        lY = (1+ny1-ny0) + (ny1>=dimy()?dimy()-1-ny1:0) + (ny0<0?ny0:0),
-        lZ = (1+nz1-nz0) + (nz1>=dimz()?dimz()-1-nz1:0) + (nz0<0?nz0:0),
-        lV = (1+nv1-nv0) + (nv1>=dimv()?dimv()-1-nv1:0) + (nv0<0?nv0:0);
-      const unsigned int offX = width-lX, offY = width*(height-lY), offZ = width*height*(depth-lZ);
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      T *ptrd = ptr(nx0<0?0:nx0,ny0<0?0:ny0,nz0<0?0:nz0,nv0<0?0:nv0);
-      if (lX>0 && lY>0 && lZ>0 && lV>0)
-        for (int v=0; v<lV; v++) {
-          for (int z=0; z<lZ; z++) {
-            for (int y=0; y<lY; y++) {
-              if (opacity>=1) {
-                if (sizeof(T)!=1) { for (int x=0; x<lX; x++) *(ptrd++) = val; ptrd+=offX; }
-                else { std::memset(ptrd,(int)val,lX); ptrd+=width; }
-              } else { for (int x=0; x<lX; x++) { *ptrd = (T)(nopacity*val+copacity*(*ptrd)); ptrd++; } ptrd+=offX; }
-            }
-            ptrd+=offY;
-          }
-          ptrd+=offZ;
-        }  
-      return *this;
-    }
-
-    //! Draw a 3D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0,\c z0)-(\c x1,\c y1,\c z1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param z0 = Z-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param z1 = Z-coordinate of the lower-right rectangle corner in the instance image.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int z0,
-                         const int x1,const int y1,const int z1,
-                         const T *const color,const float opacity=1) {
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_rectangle : specified color is (null)",pixel_type());
-      cimg_mapV(*this,k) draw_rectangle(x0,y0,z0,k,x1,y1,z1,k,color[k],opacity);
-      return *this;
-    }
-
-    //! Draw a 2D filled colored rectangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1).
-    /**
-       \param x0 = X-coordinate of the upper-left rectangle corner in the instance image.
-       \param y0 = Y-coordinate of the upper-left rectangle corner in the instance image.
-       \param x1 = X-coordinate of the lower-right rectangle corner in the instance image.
-       \param y1 = Y-coordinate of the lower-right rectangle corner in the instance image.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_rectangle(const int x0,const int y0,const int x1,const int y1,
-                         const T *const color,const float opacity=1) {
-      draw_rectangle(x0,y0,0,x1,y1,depth-1,color,opacity);
-      return *this;
-    }
-  
-    //! Draw a 2D filled colored triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    CImg& draw_triangle(const int x0,const int y0,
-                        const int x1,const int y1,
-                        const int x2,const int y2,
-                        const T *const color, const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_triangle"); 
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_triangle : specified color is (null).");
-      const T* col = color;
-      int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,whz=width*height*depth;
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1);
-      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2);
-      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2);
-      if (ny0>=dimy() || ny2<0) return *this;
-      const float 
-        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1);
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      float xleft = (float)nx0, xright = xleft, pleft = (p1<p2)?p1:p2, pright = (p1<p2)?p2:p1;
-      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; }
-
-      const int ya = ny1>dimy()?height:ny1;
-      for (int y=ny0<0?0:ny0; y<ya; y++) {
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<width)?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx = whz-xmax+xmin-1;
-          T *ptrd = ptr(xmin,y,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) { 
-            if (sizeof(T)!=1) { const T& cval=*(col++); for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval; ptrd+=offx; }
-            else { std::memset(ptrd,(int)*(col++),xmax-xmin+1); ptrd+=whz; }
-          } else cimg_mapV(*this,k) {
-            const T& cval=*(col++); 
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity + copacity*(*ptrd)); ptrd++; } 
-            ptrd+=offx;
-          }
-          col-=dim;
-        }
-        xleft+=pleft; xright+=pright;
-      }    
-
-      if (p1<p2) { xleft=(float)nx1;  pleft=p3;  if (ny1<0) xleft-=ny1*pleft; } 
-      else       { xright=(float)nx1; pright=p3; if (ny1<0) xright-=ny1*pright; }
-
-      const int yb = ny2>=dimy()?height-1:ny2;
-      for (int yy=ny1<0?0:ny1; yy<=yb; yy++) {
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<width)?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx=whz-xmax+xmin-1;
-          T *ptrd = ptr(xmin,yy,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) { 
-            if (sizeof(T)!=1) { const T& cval=*(col++); for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval; ptrd+=offx; }
-            else { std::memset(ptrd,(int)*(col++),xmax-xmin+1); ptrd+=whz; }
-          } else cimg_mapV(*this,k) { 
-            const T& cval=*(col++);
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity + copacity*(*ptrd)); ptrd++; }
-            ptrd+=offx; 
-          }
-          col-=dim;
-        }
-        xleft+=pleft; xright+=pright;
-      }    
-      return *this;
-    }
-  
-    //! Draw a 2D textured triangle in the instance image, at coordinates (\c x0,\c y0)-(\c x1,\c y1)-(\c x2,\c y2).
-    /**
-       \param x0 = X-coordinate of the first corner in the instance image.
-       \param y0 = Y-coordinate of the first corner in the instance image.
-       \param x1 = X-coordinate of the second corner in the instance image.
-       \param y1 = Y-coordinate of the second corner in the instance image.
-       \param x2 = X-coordinate of the third corner in the instance image.
-       \param y2 = Y-coordinate of the third corner in the instance image.
-       \param texture = texture image used to fill the triangle.
-       \param tx0 = X-coordinate of the first corner in the texture image.
-       \param ty0 = Y-coordinate of the first corner in the texture image.
-       \param tx1 = X-coordinate of the second corner in the texture image.
-       \param ty1 = Y-coordinate of the second corner in the texture image.
-       \param tx2 = X-coordinate of the third corner in the texture image.
-       \param ty2 = Y-coordinate of the third corner in the texture image.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported, but texture coordinates do not support clipping.
-    **/
-    template<typename t> CImg& draw_triangle(const int x0,const int y0,
-                                             const int x1,const int y1,
-                                             const int x2,const int y2,
-                                             const CImg<t>& texture,
-                                             const int tx0,const int ty0,
-                                             const int tx1,const int ty1,
-                                             const int tx2,const int ty2,
-                                             const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_triangle"); cimg_test(texture,"CImg<T>::draw_triangle");
-      int nx0=x0,ny0=y0,nx1=x1,ny1=y1,nx2=x2,ny2=y2,ntx0=tx0,nty0=ty0,ntx1=tx1,nty1=ty1,ntx2=tx2,nty2=ty2,whz=width*height*depth;
-      if (ny0>ny1) cimg::swap(nx0,nx1,ny0,ny1,ntx0,ntx1,nty0,nty1);
-      if (ny0>ny2) cimg::swap(nx0,nx2,ny0,ny2,ntx0,ntx2,nty0,nty2);
-      if (ny1>ny2) cimg::swap(nx1,nx2,ny1,ny2,ntx1,ntx2,nty1,nty2);
-      if (ny0>=dimy() || ny2<0) return *this;
-      const float 
-        p1 = (ny1-ny0)?(nx1-nx0)/(float)(ny1-ny0):(nx1-nx0),
-        p2 = (ny2-ny0)?(nx2-nx0)/(float)(ny2-ny0):(nx2-nx0),
-        p3 = (ny2-ny1)?(nx2-nx1)/(float)(ny2-ny1):(nx2-nx1),
-        tpx1 = (ny1-ny0)?(ntx1-ntx0)/(float)(ny1-ny0):0,
-        tpy1 = (ny1-ny0)?(nty1-nty0)/(float)(ny1-ny0):0,
-        tpx2 = (ny2-ny0)?(ntx2-ntx0)/(float)(ny2-ny0):0,
-        tpy2 = (ny2-ny0)?(nty2-nty0)/(float)(ny2-ny0):0,
-        tpx3 = (ny2-ny1)?(ntx2-ntx1)/(float)(ny2-ny1):0,
-        tpy3 = (ny2-ny1)?(nty2-nty1)/(float)(ny2-ny1):0;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      float pleft,pright,tpxleft,tpyleft,tpxright,tpyright,
-        xleft=(float)nx0,xright=xleft,txleft=(float)ntx0,tyleft=(float)nty0,txright=txleft,tyright=tyleft;
-      if (p1<p2) { pleft=p1; pright=p2; tpxleft=tpx1; tpyleft=tpy1; tpxright=tpx2; tpyright=tpy2; } 
-      else       { pleft=p2; pright=p1; tpxleft=tpx2; tpyleft=tpy2; tpxright=tpx1; tpyright=tpy1; }
-      if (ny0<0) { xleft-=ny0*pleft; xright-=ny0*pright; txleft-=ny0*tpxleft; tyleft-=ny0*tpyleft;
-        txright-=ny0*tpxright; tyright-=ny0*tpyright; }
-      const int ya = ny1<dimy()?ny1:height;
-      for (int y=(ny0<0?0:ny0); y<ya; y++) {
-        const int dx = (int)xright-(int)xleft;
-        const float
-          tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-          tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,        
-          txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-          tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx=whz-xmax+xmin-1;
-          T* ptrd = ptr(xmin,y,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) {
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)texture((unsigned int)tx,(unsigned int)ty,0,k); tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          } else cimg_mapV(*this,k) {
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          }
-        }
-        xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-      }
-
-      if (p1<p2) {
-        xleft=(float)nx1; pleft=p3; txleft=(float)ntx1; tyleft=(float)nty1; tpxleft=tpx3; tpyleft=tpy3;
-        if (ny1<0) { xleft-=ny1*pleft; txleft-=ny1*tpxleft; tyleft-=ny1*tpyleft; }
-      } else { 
-        xright=(float)nx1; pright=p3; txright=(float)ntx1; tyright=(float)nty1; tpxright=tpx3; tpyright=tpy3;
-        if (ny1<0) { xright-=ny1*pright; txright-=ny1*tpxright; tyright-=ny1*tpyright; }
-      }    
-      const int yb = ny2>=dimy()?(height-1):ny2;
-      for (int yy=(ny1<0?0:ny1); yy<=yb; yy++) {
-        const int dx = (int)xright-(int)xleft;
-        const float
-          tpx = dx?((int)txright-(int)txleft)/(float)dx:0,
-          tpy = dx?((int)tyright-(int)tyleft)/(float)dx:0,        
-          txi = (float)((xleft>=0)?(int)txleft:(int)(txleft-(int)xleft*tpx)),
-          tyi = (float)((xleft>=0)?(int)tyleft:(int)(tyleft-(int)xleft*tpy));
-        const int xmin=(xleft>=0)?(int)xleft:0, xmax=(xright<dimx())?(int)xright:(width-1);
-        if (xmin<=xmax) {
-          const int offx=whz-xmax+xmin-1;
-          T* ptrd = ptr(xmin,yy,0,0);
-          if (opacity>=1) cimg_mapV(*this,k) { 
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *(ptrd++)=(T)texture((unsigned int)tx,(unsigned int)ty,0,k); tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          } else cimg_mapV(*this,k) { 
-            float tx=txi, ty=tyi;
-            for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(nopacity*texture((unsigned int)tx,(unsigned int)ty,0,k)+copacity*(*ptrd)); ptrd++; tx+=tpx; ty+=tpy; }
-            ptrd+=offx;
-          }
-        }
-        xleft+=pleft; xright+=pright; txleft+=tpxleft; tyleft+=tpyleft; txright+=tpxright; tyright+=tpyright;
-      }
-      return *this;
-    }
-
-    //! Draw a filled ellipse on the instance image
-    /**
-       \param x0 = X-coordinate of the ellipse center.
-       \param y0 = Y-coordinate of the ellipse center.
-       \param r1 = First radius of the ellipse.
-       \param r2 = Second radius of the ellipse.
-       \param ru = X-coordinate of the orientation vector related to the first radius.
-       \param rv = Y-coordinate of the orientation vector related to the first radius.
-       \param color = a C-array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_ellipse(const int x0,const int y0,const float r1,const float r2,const float ru,const float rv,
-                       const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_ellipse");
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_ellipse : specified color is (null).",pixel_type());
-      const T* col = color;
-      const float
-        norm = (float)std::sqrt(ru*ru+rv*rv),
-        u = norm>0?ru/norm:1,
-        v = norm>0?rv/norm:0,
-        rmax = cimg::max(r1,r2),
-        l1 = (float)std::pow(rmax/(r1>0?r1:1e-6),2),
-        l2 = (float)std::pow(rmax/(r2>0?r2:1e-6),2),
-        a = l1*u*u + l2*v*v,
-        b = u*v*(l1-l2),
-        c = l1*v*v + l2*u*u,
-        nopacity = cimg::abs(opacity),
-        copacity = 1-cimg::max(opacity,0.0f);
-      const int
-        yb = (int)std::sqrt(a*rmax*rmax/(a*c-b*b)),
-        ymin = (y0-yb<0)?0:(y0-yb),
-        ymax = (1+y0+yb>=dimy())?height-1:(1+y0+yb),
-        whz = width*height*depth;
-      for (int y=ymin; y<=ymax; y++) {
-        const float
-          Y = (float)(y-y0),
-          delta = b*b*Y*Y-a*(c*Y*Y-rmax*rmax);
-        if (delta>=0) {
-          int xmin = (int)(x0-(b*Y+std::sqrt(delta))/a), xmax = (int)(x0-(b*Y-std::sqrt(delta))/a);
-          if (xmin<0) xmin=0;
-          if (xmax>=dimx()) xmax=dimx()-1;
-          if (xmin<=xmax) {
-            const int offx = whz-xmax+xmin-1;
-            T *ptrd = ptr(xmin,y,0,0);
-            if (opacity>=1) {
-              if (sizeof(T)!=1) cimg_mapV(*this,k) {
-                const T& cval=*(col++); 
-                for (int x=xmin; x<=xmax; x++) *(ptrd++)=cval;
-                ptrd+=offx;
-              } else cimg_mapV(*this,k) {
-                std::memset(ptrd,(int)*(col++),xmax-xmin+1);
-                ptrd+=whz; 
-              }
-            } else cimg_mapV(*this,k) {
-              const T& cval=*(col++);
-              for (int x=xmin; x<=xmax; x++) { *ptrd=(T)(cval*nopacity+copacity*(*ptrd)); ptrd++; }
-              ptrd+=offx;
-            }
-            col-=dim;
-          }
-        }
-      }
-      return *this;
-    }
-
-    //! Draw a filled circle on the instance image
-    /**
-       \param x0 = X-coordinate of the circle center.
-       \param y0 = Y-coordinate of the circle center.
-       \param r = radius of the circle.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_circle(const int x0,const int y0,float r,const T *const color,const float opacity=1) {
-      return draw_ellipse(x0,y0,r,r,1,0,color,opacity);
-    }
-  
-    // Create an auto-cropped font (along the X axis) from a input font \p font.
-    static CImgl<T> get_cropfont(const CImgl<T>& font,const unsigned int padding=2) {
-      CImgl<T> res;
-      cimgl_map(font,l) {
-        int xmin=font[l].width, xmax = 0;
-        cimg_mapXY(font[l],x,y) if (font[l](x,y)) { if (x<xmin) xmin=x; if (x>xmax) xmax=x; }
-        if (xmin>xmax) res.insert(font[l]);
-        else {
-          res.insert(CImg<T>(xmax-xmin+1+padding,font[l].height,1,font[l].dim,0));
-          cimg_mapYV(res[l],y,k) for (int x=xmin; x<=xmax; x++) res[l](x-xmin,y,0,k) = font[l](x,y,0,k);
-        }
-      }
-      return res;
-    }
-  
-    //! Return a copy of the default 7x11 CImg font as a list of images and masks.
-    /**
-       \param fixed_size = compute fixed or variable character size
-    **/
-    static CImgl<T> get_font7x11(const bool fixed_size = false) {
-      CImgl<T> font(32,1,1,1,3);
-      font.insert(CImgl<T>(224,7,11,1,3)).insert(CImgl<T>(32,1,1,1,1)).insert(CImgl<T>(224,7,11,1,1));
-      for (unsigned int i=0, off=0, boff=(unsigned int)(1<<31); i<256; i++) for (unsigned int j=0; j<font[i].width*font[i].height; j++) {
-        font[256+i](j) = font[i](j,0,0) = font[i](j,0,1) = font[i](j,0,2) = (cimg::font7x11[off]&boff)?(T)1:(T)0;
-        if (!(boff>>=1)) { boff=(unsigned int)(1<<31); off++; }
-      }
-      if (!fixed_size) return get_cropfont(font,2);
-      return font;
-    }
-
-    //! Draw a text into the instance image.
-    /**
-       \param text = a C-string containing the text to display.
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
-       \param font = List of font characters used for the drawing.
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-       \see get_font7x11().
-    **/
-    template<typename t> CImg& draw_text(const char *const text,
-                                         const int x0,const int y0,
-                                         const T *const fgcolor,const T *const bgcolor,
-                                         const CImgl<t>& font,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_text");
-      int x=x0, y=y0;
-      CImg letter;
-      for (int i=0; i<cimg::strlen(text); i++) {
-        const unsigned char c = text[i];
-        switch (c) {
-        case '\n': y+=font[' '].height; x=x0; break;
-        case '\t': x+=4*font[' '].width; break;
-        default: if (c<font.size) {
-            letter = font[c];
-            const CImg& mask = (c+256)<(int)font.size?font[c+256]:font[c];
-            if (fgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++) if (mask(p)) cimg_mapV(*this,k) letter(p,0,0,k)=(T)(letter(p,0,0,k)*fgcolor[k]);
-            if (bgcolor) for (unsigned int p=0; p<letter.width*letter.height; p++) if (!mask(p)) cimg_mapV(*this,k) letter(p,0,0,k)=bgcolor[k];
-            if (!bgcolor && font.size>=512) draw_image(letter,mask,x,y,0,0,(T)1,opacity); else draw_image(letter,x,y,0,0,opacity);
-            x+=letter.width;
-          }
-          break;
-        }
-      }
-      return *this;
-    }
-
-
-    //! Draw a text into the instance image.
-    /**
-       \param text = a C-string containing the text to display.
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-       \see get_font7x11().
-    **/
-    CImg& draw_text(const char *const text,
-                    const int x0,const int y0,
-                    const T *const fgcolor=NULL,const T *const bgcolor=NULL,
-                    const float opacity=1) {
-      static bool first = true;
-      static CImgl<T> default_font;
-      if (first) { default_font = get_font7x11(); first = false; }
-      return draw_text(text,x0,y0,fgcolor,bgcolor,default_font,opacity);
-    }
-  
-    //! Draw a text into the instance image.
-    /**
-       \param x0 = X-coordinate of the text in the instance image.
-       \param y0 = Y-coordinate of the text in the instance image.
-       \param fgcolor = an array of dimv() values of type \c T, defining the foreground color (NULL means 'transparent').
-       \param bgcolor = an array of dimv() values of type \c T, defining the background color (NULL means 'transparent').
-       \param opacity = opacity of the drawing.
-       \param format = a 'printf'-style format, followed by arguments.
-       \note Clipping is supported.
-       \see get_font7x11().
-    **/
-    CImg& draw_text(const int x0,const int y0,
-                    const T *const fgcolor,const T *const bgcolor,
-                    const float opacity,const char *format,...) {
-      char tmp[2048]; 
-      va_list ap;
-      va_start(ap,format);
-      std::vsprintf(tmp,format,ap);
-      va_end(ap);
-      return draw_text(tmp,x0,y0,fgcolor,bgcolor,opacity);
-    }
-    template<typename t> CImg& draw_text(const int x0,const int y0,
-                                         const T *const fgcolor,const T *const bgcolor,
-                                         const CImgl<t>& font, const float opacity, const char *format,...) {
-      char tmp[2048]; va_list ap; va_start(ap,format); std::vsprintf(tmp,format,ap); va_end(ap);
-      return draw_text(tmp,x0,y0,fgcolor,bgcolor,font);
-    }
-  
-    //! Draw a vector field in the instance image.
-    /**
-       \param flow = a 2d image of 2d vectors used as input data.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sampling = length (in pixels) between each arrow.
-       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
-       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t> 
-    CImg& draw_quiver(const CImg<t>& flow,const T *const color,const unsigned int sampling=25,const float factor=-20,
-                      const int quiver_type=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_quiver"); cimg_test(flow,"CImg<T>::draw_quiver");
-      if (!color) 
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified color is (null)",pixel_type());
-      if (sampling<=0)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : incorrect sampling value = %g",pixel_type(),sampling);
-      if (flow.dim!=2)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified flow has invalid dimensions (%u,%u,%u,%u)",
-                                    pixel_type(),flow.width,flow.height,flow.depth,flow.dim);
-      float vmax,fact;
-      if (factor<=0) {
-        CImgStats st(flow.get_norm_pointwise(2),false);
-        vmax = (float)cimg::max(std::fabs(st.min),std::fabs(st.max));
-        fact = -factor;
-      } else { fact = factor; vmax = 1; }
-
-      for (unsigned int y=sampling/2; y<height; y+=sampling)
-        for (unsigned int x=sampling/2; x<width; x+=sampling) {
-          const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
-          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
-          if (!quiver_type) {
-            const int xx = x+(int)u, yy = y+(int)v;
-            draw_arrow(x,y,xx,yy,color,45.0f,sampling/5.0f,~0L,opacity);
-          } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color,~0L,opacity);
-        }
-      return *this; 
-    }
-
-    //! Draw a vector field in the instance image, using a colormap.
-    /**
-       \param flow = a 2d image of 2d vectors used as input data.
-       \param color = a 2d image of dimv()-D vectors corresponding to the color of each arrow.
-       \param sampling = length (in pixels) between each arrow.
-       \param factor = length factor of each arrow (if <0, computed as a percentage of the maximum length).
-       \param quiver_type = type of plot. Can be 0 (arrows) or 1 (segments).
-       \param opacity = opacity of the drawing.
-       \note Clipping is supported.
-    **/
-    template<typename t1,typename t2>
-      CImg& draw_quiver(const CImg<t1>& flow,const CImg<t2>& color,const unsigned int sampling=25,const float factor=-20,
-                        const int quiver_type=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_quiver"); cimg_test(flow,"CImg<T>::draw_quiver"); cimg_test(color,"CImg<T>::draw_quiver");
-      if (sampling<=0)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : incorrect sampling value = %g",pixel_type(),sampling);
-      if (flow.dim!=2)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : specified flow has invalid dimensions (%u,%u,%u,%u)",
-                                    pixel_type(),flow.width,flow.height,flow.depth,flow.dim);
-      if (color.width!=flow.width || color.height!=flow.height)
-        throw CImgArgumentException("CImg<%s>::draw_quiver() : input color data map=(%u,%u,%u,%u)\
- and data flow=(%u,%u,%u,%u) must have same dimension.",
-                                    color.width,color.height,color.depth,color.data,
-                                    flow.width,flow.height,flow.depth,flow.data);
-      float vmax,fact;
-      if (factor<=0) {
-        CImgStats st(flow.get_norm_pointwise(2),false);
-        vmax = (float)cimg::max(std::fabs(st.min),std::fabs(st.max));
-        fact = -factor;
-      } else { fact = factor; vmax = 1; }
-
-      for (unsigned int y=sampling/2; y<height; y+=sampling)
-        for (unsigned int x=sampling/2; x<width; x+=sampling) {
-          const unsigned int X = x*flow.width/width, Y = y*flow.height/height;
-          float u = (float)flow(X,Y,0,0)*fact/vmax, v = (float)flow(X,Y,0,1)*fact/vmax;
-          if (!quiver_type) {
-            const int xx = x+(int)u, yy = y+(int)v;
-            draw_arrow(x,y,xx,yy,color.get_vector(X,Y).data,45,sampling/5,~0L,opacity);
-          } else draw_line((int)(x-0.5*u),(int)(y-0.5*v),(int)(x+0.5*u),(int)(y+0.5*v),color(X,Y),~0L,opacity);
-        }
-      return *this; 
-    }
-
-    //! Draw a 1D graph on the instance image.
-    /**
-       \param data = an image containing the graph values I = f(x).
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param gtype = define the type of the plot :
-                      - 0 = Plot using linear interpolation (segments).
-		      - 1 = Plot with bars.
-		      - 2 = Plot using cubic interpolation (3-polynomials).
-       \param ymin = lower bound of the y-range.
-       \param ymax = upper bound of the y-range.
-       \param opacity = opacity of the drawing.
-       \note
-         - if \c ymin==ymax==0, the y-range is computed automatically from the input sample.
-       \see draw_axeX(), draw_axeY(), draw_axeXY().
-    **/
-    template<typename t>
-    CImg& draw_graph(const CImg<t>& data,const T *const color,const unsigned int gtype=0,
-                     const double ymin=0,const double ymax=0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_graph");
-      if (!color) throw CImgArgumentException("CImg<%s>::draw_graph() : specified color is (null)",pixel_type());
-      T *color1 = new T[dim], *color2 = new T[dim];
-      cimg_mapV(*this,k) { color1[k]=(T)(color[k]*0.6f); color2[k]=(T)(color[k]*0.3f); }
-      CImgStats st;
-      if (ymin==ymax) { st = CImgStats(data,false); cimg::swap(st.min,st.max); } else { st.min = ymin; st.max = ymax; }
-      if (st.min==st.max) { st.min--; st.max++; }
-      const float ca = height>1?(st.max-st.min)/(height-1):0, cb = st.min;
-      const int Y0 = (int)(-cb/ca);
-      int pY=0;
-      cimg_mapoff(data,off) {     
-        const int Y = (int)((data[off]-cb)/ca);
-        switch (gtype) {
-        case 0: // plot with segments
-          if (off>0) draw_line((int)((off-1)*width/data.size()),pY,(int)(off*width/data.size()),Y,color,~0L,opacity);
-          break;
-        case 1: { // plot with bars
-          const unsigned int X = off*width/data.size(), nX = (off+1)*width/data.size()-1;
-          draw_rectangle(X,(int)Y0,nX,Y,color1,opacity);
-	  draw_line(X,Y,X,(int)Y0,color2,~0L,opacity);
-	  draw_line(X,(int)Y0,nX,(int)Y0,Y<=Y0?color2:color,~0L,opacity);
-	  draw_line(nX,Y,nX,(int)Y0,color,~0L,opacity);
-	  draw_line(X,Y,nX,Y,Y<=Y0?color:color2,~0L,opacity);
-        } break;
-        }        
-        pY=Y;
-      }
-      if (gtype==2) { // plot with cubic interpolation
-	const CImgROI<t> ndata(data.size(),1,1,1,data.ptr());
-        cimg_mapX(*this,x) {
-          const int Y = (int)((ndata.cubic_pix1d((float)x*ndata.width/width)-cb)/ca);
-          if (x>0) draw_line(x,pY,x+1,Y,color,~0L,opacity);
-          pY=Y;
-        }
-      }
-      delete[] color1; delete[] color2;
-      return *this;     
-    }
-
-    //! Draw a labelled horizontal axis on the instance image.
-    /** 
-       \param x0 = lower bound of the x-range.
-       \param x1 = upper bound of the x-range.
-       \param y = Y-coordinate of the horizontal axis in the instance image.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precision = precision of the labels.
-       \param opacity = opacity of the drawing.
-       \note if \c precision==0, precision of the labels is automatically computed.
-       \see draw_graph(), draw_axeY(), draw_axeXY().
-    **/
-    CImg& draw_axeX(const double x0,const double x1,const int y,const T *const color,
-		    const double precision=0,const float opacity=1) {
-      if (x0==x1) return *this;
-      if (x0<x1) draw_arrow(0,y,width-1,y,color,30,5,~0L,opacity);
-      else draw_arrow(width-1,y,0,y,color,30,5,~0L,opacity);
-      const int yt = (y+14)<dimy()?(y+3):(y-14);
-      double nprecision=precision;
-      if (precision<=0) { 
-	const double nb_pow = std::floor(std::log10(std::fabs(x1-x0)))-1;
-	nprecision = std::pow(10.0,nb_pow);
-	while ((std::fabs(x1-x0)/nprecision)>(dimx()/40)) nprecision*=2;
-      }
-      const double xmin=x0<x1?x0:x1, xmax=x0<x1?x1:x0,
-	tx0 = cimg::mod(xmin,nprecision)==0?xmin:((xmin+nprecision)-cimg::mod(xmin+nprecision,nprecision)),
-	tx1 = cimg::mod(xmax,nprecision)==0?xmax:((xmax+nprecision)-cimg::mod(xmax+nprecision,nprecision));
-      char txt[32];
-      for (double x=tx0; x<=tx1; x+=nprecision) {
-	std::sprintf(txt,"%g",x);       	
-	const int xi=(int)((x-x0)*(width-1)/(x1-x0)), xt = xi-(int)std::strlen(txt)*3;
-	draw_point(xi,y-1,color,opacity).draw_point(xi,y+1,color,opacity).
-	  draw_text(txt,xt<0?0:xt,yt,color,NULL,opacity);
-      }
-      return *this;
-    }
-
-    //! Draw a labelled vertical axis on the instance image.
-    /** 
-       \param x = X-coordinate of the vertical axis in the instance image.
-       \param y0 = lower bound of the y-range.
-       \param y1 = upper bound of the y-range.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precision = precision of the labels.
-       \param opacity = opacity of the drawing.
-       \note if \c precision==0, precision of the labels is automatically computed.
-       \see draw_graph(), draw_axeX(), draw_axeXY().
-    **/
-    CImg& draw_axeY(const int x,const double y0,const double y1,const T *const color,
-		    const double precision=0,const float opacity=1) {
-      if (y0==y1) return *this;
-      if (y0<y1) draw_arrow(x,0,x,height-1,color,30,5,~0L,opacity);
-      else draw_arrow(x,height-1,x,0,color,30,5,~0L,opacity);
-      double nprecision=precision;
-      if (precision<=0) {
-	const double nb_pow = std::floor(std::log10(std::fabs(y1-y0)))-1;
-	nprecision = std::pow(10.0,nb_pow);
-	while ((std::fabs(y1-y0)/nprecision)>(dimy()/40)) nprecision*=2;
-      }
-      const double ymin=y0<y1?y0:y1, ymax=y0<y1?y1:y0,
-	ty0 = cimg::mod(ymin,nprecision)==0?ymin:((ymin+nprecision)-cimg::mod(ymin+nprecision,nprecision)),
-	ty1 = cimg::mod(ymax,nprecision)==0?ymax:((ymax+nprecision)-cimg::mod(ymax+nprecision,nprecision));
-      char txt[32];
-      for (double y=ty0; y<=ty1; y+=nprecision) {
-	std::sprintf(txt,"%g",y);
-	const int yi = (int)((y-y0)*(height-1)/(y1-y0)), xt = x-(int)std::strlen(txt)*7;
-	draw_point(x-1,yi,color,opacity).draw_point(x+1,yi,color,opacity);
-	if (xt>0) draw_text(txt,xt,yi-5,color,NULL,opacity);
-	else draw_text(txt,x+3,yi-5,color,NULL,opacity);
-      }
-      return *this;
-    }
-
-    //! Draw a labelled coordinate system (X,Y) on the instance image.
-    /** 
-       \param x0 = lower bound of the x-range.
-       \param x1 = upper bound of the x-range.
-       \param y0 = lower bound of the y-range.
-       \param y1 = upper bound of the y-range.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param precisionx = precision of the labels along the X-axis.
-       \param precisiony = precision of the labels along the Y-axis.
-       \param opacity = opacity of the drawing.
-       \note if precision==0, precision of the labels along the specified axix is automatically computed.
-       \see draw_graph(), draw_axeX(), draw_axeY().
-    **/
-    CImg& draw_axeXY(const double x0,const double x1,const double y0,const double y1,const T *const color,
-		     const double precisionx=0,const double precisiony=0,const float opacity=1) {
-      if (x0*x1<=0) {
-        const int xz = (int)(-x0*(width-1)/(x1-x0));
-        if (xz>=0 && xz<dimx()) draw_axeY(xz,y0,y1,color,precisiony,opacity);
-      }
-      if (y0*y1<=0) {
-        const int yz = (int)(-y0*(height-1)/(y1-y0));
-        if (yz>=0 && yz<dimy()) draw_axeX(x0,x1,yz,color,precisionx,opacity);
-      }
-      return *this;
-    }
-  
-    // Local class used by function CImg<>::draw_fill()
-    template<typename T1,typename T2> struct _draw_fill {
-      const T1 *const color;
-      const float sigma,opacity;
-      const CImg<T1> value;
-      CImg<T2> region;
-
-      _draw_fill(const CImg<T1>& img,const int x,const int y,const int z,
-                 const T *const pcolor,const float psigma,const float popacity):
-        color(pcolor),sigma(psigma),opacity(popacity),
-        value(img.get_vector(x,y,z)), region(CImg<T2>(img.width,img.height,img.depth).fill((T2)false)) {
-        cimg_test(img,"CImg<T>::draw_fill");
-        if (!color) throw CImgArgumentException("CImg<%s>::draw_fill() : specified color is (null)",img.pixel_type());
-      }
-
-	   _draw_fill& operator=(const _draw_fill& d) {
-			color = d.color;
-			sigma = d.sigma;
-			opacity = d.opacity;
-			value = d.value;
-			region = d.region;
-		}
-
-      bool comp(const CImg<T1>& A,const CImg<T1>& B) const {
-        bool res=true;
-        const T *pA=A.data+A.size();
-        for (const T *pB=B.data+B.size(); res && pA>A.data; res=(cimg::abs(*(--pA)-(*(--pB)))<=sigma) );
-        return res;
-      }
-
-      void fill(CImg<T1>& img,const int x,const int y,const int z) {
-        if (x<0 || x>=img.dimx() || y<0 || y>=img.dimy() || z<0 || z>=img.dimz()) return;
-        if (!region(x,y,z) && comp(value,img.get_vector(x,y,z))) {
-          const T *col=color;
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          int xmin,xmax;
-          if (opacity>=1) cimg_mapV(img,k) img(x,y,z,k)=*(col++);
-          else cimg_mapV(img,k) img(x,y,z,k)=(T1)(*(col++)*opacity+copacity*img(x,y,z,k));
-          col-=img.dim;
-          region(x,y,z) = (T2)true;
-          for (xmin=x-1; xmin>=0 && comp(value,img.get_vector(xmin,y,z)); xmin--) {
-            if (opacity>=1) cimg_mapV(img,k) img(xmin,y,z,k) = *(col++);
-            else cimg_mapV(img,k) img(xmin,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmin,y,z,k)); 
-            col-=img.dim;
-            region(xmin,y,z)=(T2)true;
-          }
-          for (xmax=x+1; xmax<img.dimx() && comp(value,img.get_vector(xmax,y,z)); xmax++) {
-            if (opacity>=1) cimg_mapV(img,k) img(xmax,y,z,k) = *(col++);
-            else cimg_mapV(img,k) img(xmax,y,z,k)=(T1)(*(col++)*nopacity+copacity*img(xmax,y,z,k));
-            col-=img.dim;
-            region(xmax,y,z)=(T2)true; 
-          }
-          xmin++; xmax--;
-          for (; xmin<=xmax; xmin++) { 
-            fill(img,xmin,y-1,z); 
-            fill(img,xmin,y+1,z);
-            fill(img,xmin,y,z-1); 
-            fill(img,xmin,y,z+1);
-          }
-        }
-      }        
-    };
-
-    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param z = Z-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param region = image that will contain the mask of the filled region mask, as an output.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    template<typename t> CImg& draw_fill(const int x,const int y,const int z,
-                                         const T *const color,CImg<t>& region,const float sigma=0,
-                                         const float opacity=1) {
-      _draw_fill<T,t> F(*this,x,y,z,color,sigma,opacity);
-      F.fill(*this,x,y,z);
-      region = F.region;
-      return *this;
-    }
-
-    //! Draw a 3D filled region starting from a point (\c x,\c y,\ z) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param z = Z-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_fill(const int x,const int y,const int z,const T *const color,const float sigma=0,const float opacity=1) {
-      CImg<bool> tmp;
-      return draw_fill(x,y,z,color,tmp,sigma,opacity);
-    }
-
-    //! Draw a 2D filled region starting from a point (\c x,\c y) in the instance image.
-    /**
-       \param x = X-coordinate of the starting point of the region to fill.
-       \param y = Y-coordinate of the starting point of the region to fill.
-       \param color = an array of dimv() values of type \c T, defining the drawing color.
-       \param sigma = tolerance concerning neighborhood values.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_fill(const int x,const int y,const T *const color,const float sigma=0,const float opacity=1) {
-      CImg<bool> tmp;
-      return draw_fill(x,y,0,color,tmp,sigma,opacity);
-    }
-
-    //! Draw a plasma square in the instance image.
-    /**
-       \param x0 = X-coordinate of the upper-left corner of the plasma.
-       \param y0 = Y-coordinate of the upper-left corner of the plasma.
-       \param x1 = X-coordinate of the lower-right corner of the plasma.
-       \param y1 = Y-coordinate of the lower-right corner of the plasma.
-       \param alpha = Alpha-parameter of the plasma.
-       \param beta = Beta-parameter of the plasma.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_plasma(const int x0,const int y0,const int x1,const int y1,
-                      const double alpha=1.0,const double beta=1.0,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_plasma");
-      int nx0=x0,nx1=x1,ny0=y0,ny1=y1;
-      if (nx1<nx0) cimg::swap(nx0,nx1);
-      if (ny1<ny0) cimg::swap(ny0,ny1);
-      if (nx0<0) nx0=0;
-      if (nx1>=dimx()) nx1=width-1;
-      if (ny0<0) ny0=0;
-      if (ny1>=dimy()) ny1=height-1;
-      const int xc = (nx0+nx1)/2, yc = (ny0+ny1)/2, dx=(xc-nx0), dy=(yc-ny0);
-      const double dc = std::sqrt((double)(dx*dx+dy*dy))*alpha + beta;
-      cimg_mapV(*this,k) {
-        if (opacity>=1) {
-          (*this)(xc,ny0,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k)));
-          (*this)(xc,ny1,0,k) = (T)(0.5*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k)));
-          (*this)(nx0,yc,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k)));
-          (*this)(nx1,yc,0,k) = (T)(0.5*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k)));
-          (*this)(xc,yc,0,k)  = (T)(0.25*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
-                                          (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand());
-        } else {
-          const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-          (*this)(xc,ny0,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k))*nopacity + copacity*(*this)(xc,ny0,0,k));
-          (*this)(xc,ny1,0,k) = (T)(0.5*((*this)(nx0,ny1,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(xc,ny1,0,k));
-          (*this)(nx0,yc,0,k) = (T)(0.5*((*this)(nx0,ny0,0,k)+(*this)(nx0,ny1,0,k))*nopacity + copacity*(*this)(nx0,yc,0,k));
-          (*this)(nx1,yc,0,k) = (T)(0.5*((*this)(nx1,ny0,0,k)+(*this)(nx1,ny1,0,k))*nopacity + copacity*(*this)(nx1,yc,0,k));
-          (*this)(xc,yc,0,k)  = (T)(0.25*(((*this)(nx0,ny0,0,k)+(*this)(nx1,ny0,0,k) +
-                                           (*this)(nx1,ny1,0,k)+(*this)(nx0,ny1,0,k)) + dc*cimg::grand())*nopacity
-                                    + copacity*(*this)(xc,yc,0,k));
-        }
-      }
-      if (xc!=nx0 || yc!=ny0) { 
-        draw_plasma(nx0,ny0,xc,yc,alpha,beta,opacity);
-        draw_plasma(xc,ny0,nx1,yc,alpha,beta,opacity);
-        draw_plasma(nx0,yc,xc,ny1,alpha,beta,opacity);
-        draw_plasma(xc,yc,nx1,ny1,alpha,beta,opacity); 
-      }
-      return *this;
-    }
-
-    //! Draw a plasma in the instance image.
-    /**
-       \param alpha = Alpha-parameter of the plasma.
-       \param beta = Beta-parameter of the plasma.
-       \param opacity = opacity of the drawing.
-    **/
-    CImg& draw_plasma(const double alpha=1.0,const double beta=1.0,const float opacity=1) {
-      return draw_plasma(0,0,width-1,height-1,alpha,beta,opacity);
-    }
-  
-    //! Draw a 1D gaussian kernel in the instance image.
-    template<typename t> CImg& draw_gaussian(const float xc,const double sigma,const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_gaussian");
-      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
-      const double sigma2 = -2*sigma*sigma;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      const T *col = color;
-      const unsigned int whz = width*height*depth;
-      cimg_mapX(*this,x) {
-        const float dx = (x-xc);
-        const double val = std::exp( dx*dx/sigma2 );
-        T *ptrd = ptr(x,0,0,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; } 
-        col-=dim;
-      }
-      return *this;
-    }
-
-    //! Draw a gaussian in a 2d image.
-    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const double sigma,
-                                             const CImg<t> tensor,const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_gaussian"); cimg_test_square(tensor,"CImg<T>::draw_gaussian");
-      if (tensor.width!=2) throw CImgArgumentException("CImg<%s>::draw_gaussian() : gaussian tensor must be a 2x2 matrix, given is (%u,%u,%u,%u)",
-                                                       pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim);
-      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
-      const CImg<t> invT = tensor.get_inverse();
-      const t a=invT(0,0), b=2*invT(1,0), c=invT(1,1);
-      const double sigma2 = -2*sigma*sigma;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      const T *col = color;
-      const unsigned int whz = width*height*depth;
-      cimg_mapXY(*this,x,y) {
-        const float dx = (x-xc), dy = (y-yc);
-        const double val = std::exp( ( a*dx*dx + b*dx*dy + c*dy*dy )/sigma2 );
-        T *ptrd = ptr(x,y,0,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-        col-=dim;
-      }
-      return *this;
-    }
-
-    CImg& draw_gaussian(const float xc,const float yc,const double sigma,const T *const color,const float opacity=1) {
-      return draw_gaussian(xc,yc,sigma,CImg<float>::get_identity_matrix(2),color,opacity);
-    }
-
-    //! Draw a gaussian in a 3d image
-    template<typename t> CImg& draw_gaussian(const float xc,const float yc,const float zc,const double sigma,
-                                             const CImg<t> tensor,const T *const color,const float opacity=1) {
-      cimg_test(*this,"CImg<T>::draw_gaussian"); cimg_test_square(tensor,"CImg<T>::draw_gaussian");
-      if (tensor.width!=3) throw CImgArgumentException("CImg<%s>::draw_gaussian() : gaussian tensor must be a 3x3 matrix, given is (%u,%u,%u,%u)",
-                                                       pixel_type(),tensor.width,tensor.height,tensor.depth,tensor.dim);
-      if (sigma<=0) throw CImgArgumentException("CImg<%s>::draw_gaussian() : sigma must be strictly positive, given is %g",pixel_type(),sigma);
-      const CImg<t> invT = tensor.get_inverse();
-      const t a=invT(0,0), b=2*invT(1,0), c=2*invT(2,0), d=invT(1,1), e=2*invT(2,1), f=invT(2,2);
-      const double sigma2 = -2*sigma*sigma;
-      const float nopacity = cimg::abs(opacity), copacity = 1-cimg::max(opacity,0.0f);
-      const T *col = color;
-      const unsigned int whz = width*height*depth;    
-      cimg_mapXYZ(*this,x,y,z) {
-        const float dx = (x-xc), dy = (y-yc), dz = (z-zc);
-        const double val = std::exp( ( a*dx*dx + b*dx*dy + c*dx*dz + d*dy*dy + e*dy*dz + f*dz*dz )/sigma2 );
-        T *ptrd = ptr(x,y,z,0);
-        if (opacity>=1) cimg_mapV(*this,k) { *ptrd = (T)(val*(*col++)); ptrd+=whz; }
-        else cimg_mapV(*this,k) { *ptrd = (T)(nopacity*val*(*col++) + copacity*(*ptrd)); ptrd+=whz; }
-        col-=dim;
-      }
-      return *this;
-    }
-
-    CImg& draw_gaussian(const float xc,const float yc,const float zc,const double sigma,const T *const color,const float opacity=1) {
-      return draw_gaussian(xc,yc,zc,sigma,CImg<float>::get_identity_matrix(3),color,opacity);
-    }
-
-    //@}
-    //---------------------------------------
-    //---------------------------------------
-    //
-    //! \name Filtering functions
-    //@{
-    //---------------------------------------
-    //---------------------------------------
-  
-    //! Return the correlation of the image by a mask.
-    template<typename t> CImg get_correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) const {
-      cimg_test_scalar(mask,"CImg<T>::get_correlate");
-      CImg dest(*this,false);
-      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) {
-        // A special optimization is done for 2x2,3x3,4x4,5x5,2x2x2 and 3x3x3 mask (with cond=1)
-        switch (mask.depth) {
-        case 3: {
-          CImg_3x3x3(I,T);
-          if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr3x3x3(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum3x3x3(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr3x3x3(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        case 2: {
-          CImg_2x2x2(I,T);
-          if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr2x2x2(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum2x2x2(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr2x2x2(I,mask)/std::sqrt(norm)):0;
-          }
-        } break;
-        default:
-        case 1:
-          switch (mask.width) {
-          case 5: {
-            CImg_5x5(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr5x5(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum5x5(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr5x5(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;          
-          case 4: {
-            CImg_4x4(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr4x4(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum4x4(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr4x4(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;              
-          case 3: {
-            CImg_3x3(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr3x3(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum3x3(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr3x3(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;   
-          case 2: {
-            CImg_2x2(I,T);
-            if (!weighted_correl) cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_corr2x2(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum2x2(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_corr2x2(I,mask)/std::sqrt(norm)):0;
-            }            
-          } break;  
-          case 1: dest = mask(0)*(*this); break;
-          }
-        }
-      } else { 
-        // Generic version for other masks      
-        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-        cimg_mapV(*this,v) 
-          if (!weighted_correl) {	// Classical correlation
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                val+= (*this)(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-              dest(x,y,z,v)=(T)val;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= neumann_pix3d(x+xm,y+ym,z+zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= dirichlet_pix3d(x+xm,y+ym,z+zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-          } else {	// Weighted correlation
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0, norm = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                const T cval = (*this)(x+xm,y+ym,z+zm,v);
-                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                norm+= cval*cval;
-              }
-              dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = neumann_pix3d(x+xm,y+ym,z+zm,v);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+=cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = dirichlet_pix3d(x+xm,y+ym,z+zm,v,0);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+= cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):0;
-              }
-          }
-      }
-      return dest;
-    }
-    //! Correlate the image by a mask
-    template<typename t> CImg& correlate(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_correl=false) { 
-      return get_correlate(mask,cond,weighted_correl).swap(*this); 
-    }
-  
-    //! Return the convolution of the image by a mask
-    template<typename t> CImg get_convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) const {
-      cimg_test_scalar(mask,"CImg<T>::get_convolve");
-      CImg dest(*this,false);
-      if (cond && mask.width==mask.height && ((mask.depth==1 && mask.width<=5) || (mask.depth==mask.width && mask.width<=3))) { // optimized version
-        switch (mask.depth) {
-        case 3: {
-          CImg_3x3x3(I,T);
-          if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3x3(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map3x3x3(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum3x3x3(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv3x3x3(I,mask)/std::sqrt(norm)):(T)0;
-          }
-        } break;
-        case 2: {
-          CImg_2x2x2(I,T);
-          if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2x2(I,mask);
-          else cimg_mapZV(*this,z,v) cimg_map2x2x2(*this,x,y,z,v,I) {
-            const double norm = (double)cimg_squaresum2x2x2(I);
-            dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv2x2x2(I,mask)/std::sqrt(norm)):(T)0;
-          }
-        } break;
-        default:
-        case 1:
-          switch (mask.width) {
-          case 5: {
-            CImg_5x5(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv5x5(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map5x5(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum5x5(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv5x5(I,mask)/std::sqrt(norm)):(T)0;
-            }            
-          } break;          
-          case 4: {
-            CImg_4x4(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv4x4(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map4x4(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum4x4(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv4x4(I,mask)/std::sqrt(norm)):(T)0;
-            }
-          } break;              
-          case 3: {
-            CImg_3x3(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv3x3(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map3x3(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum3x3(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv3x3(I,mask)/std::sqrt(norm)):(T)0;
-            }            
-          } break;   
-          case 2: {
-            CImg_2x2(I,T);
-            if (!weighted_convol) cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) dest(x,y,z,v) = (T)cimg_conv2x2(I,mask);
-            else cimg_mapZV(*this,z,v) cimg_map2x2(*this,x,y,z,v,I) {
-              const double norm = (double)cimg_squaresum2x2(I);
-              dest(x,y,z,v) = (norm!=0)?(T)(cimg_conv2x2(I,mask)/std::sqrt(norm)):(T)0;
-            } 
-          } break;  
-          case 1: dest = mask(0)*(*this); break;
-          }
-        }
-      } else { // generic version
-          
-        const int cxm=mask.width/2, cym=mask.height/2, czm=mask.depth/2, fxm=cxm-1+(mask.width%2), fym=cym-1+(mask.height%2), fzm=czm-1+(mask.depth%2);
-        cimg_mapV(*this,v) 
-          if (!weighted_convol) {	// Classical convolution
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                val+= (*this)(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-              dest(x,y,z,v)=(T)val;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= neumann_pix3d(x-xm,y-ym,z-zm,v)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++)
-                  val+= dirichlet_pix3d(x-xm,y-ym,z-zm,v,0)*mask(cxm+xm,cym+ym,czm+zm,0);
-                dest(x,y,z,v)=(T)val;
-              }
-          } else {	// Weighted convolution
-            for (int z=czm; z<dimz()-czm; z++) for (int y=cym; y<dimy()-cym; y++) for (int x=cxm; x<dimx()-cxm; x++) {
-              double val = 0, norm = 0;
-              for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                const T cval = (*this)(x-xm,y-ym,z-zm,v);
-                val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                norm+= cval*cval;
-              }
-              dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
-            }
-            if (cond) cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++) for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = neumann_pix3d(x-xm,y-ym,z-zm,v);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+=cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
-              }
-            else cimg_mapYZV(*this,y,z,v)
-              for (int x=0; x<dimx(); (y<cym || y>=dimy()-cym || z<czm || z>=dimz()-czm)?x++:((x<cxm-1 || x>=dimx()-cxm)?x++:(x=dimx()-cxm))) {
-                double val = 0, norm = 0;
-                for (int zm=-czm; zm<=fzm; zm++) for (int ym=-cym; ym<=fym; ym++)  for (int xm=-cxm; xm<=fxm; xm++) {
-                  const T cval = dirichlet_pix3d(x-xm,y-ym,z-zm,v,0);
-                  val+= cval*mask(cxm+xm,cym+ym,czm+zm,0);
-                  norm+= cval*cval;
-                }
-                dest(x,y,z,v)=(norm!=0)?(T)(val/std::sqrt(norm)):(T)0;
-              }
-          }
-      }
-      return dest;
-    }
-  
-    //! Convolve the image by a mask
-    template<typename t> CImg& convolve(const CImg<t>& mask,const unsigned int cond=1,const bool weighted_convol=false) {
-      return get_convolve(mask,cond,weighted_convol).swap(*this); 
-    }
-
-    //! Add noise to the image
-    CImg& noise(const double psigma=-20,const unsigned int ntype=0) {
-      cimg_test(*this,"CImg<T>::noise");
-      double sigma = psigma;
-      static bool first_time = true;
-      if (first_time) { std::srand((unsigned int)::time(NULL)); first_time = false; }
-      CImgStats st;
-      if (sigma==0) return *this;
-      if (sigma<0 || ntype==2) st = CImgStats(*this,false);
-      if (sigma<0) sigma = -sigma*(st.max-st.min)/100.0;
-      switch (ntype) {
-      case 0: { cimg_map(*this,ptr,T) *ptr=(T)(*ptr+sigma*cimg::grand()); } break;    // Gaussian noise
-      case 1: { cimg_map(*this,ptr,T) *ptr=(T)(*ptr+sigma*cimg::crand()); } break;    // Uniform noise
-      case 2: {                                                                       // Salt & Pepper
-        if (st.max==st.min) { st.min=0; st.max=255; }
-        cimg_map(*this,ptr,T) if (cimg::rand()*100<sigma) *ptr=(T)(cimg::rand()<0.5?st.max:st.min);
-      } break;
-      }
-      return *this;
-    }
-    //! Return a noisy image
-    CImg get_noise(const double sigma=-20,const unsigned int ntype=0) const { return CImg<T>(*this).noise(sigma,ntype); }
-
-    //! Apply a deriche filter on the image
-#define cimg_deriche_map(x0,y0,z0,k0,nb,offset,T) {                           \
-    ima = ptr(x0,y0,z0,k0);                                                   \
-    I2 = *ima; ima+=offset; I1 = *ima; ima+=offset;                           \
-    Y2 = *(Y++) = sumg0*I2; Y1 = *(Y++) = g0*I1 + sumg1*I2;                   \
-    for (i=2; i<(nb); i++) { I1 = *ima; ima+=offset;                          \
-        Y0 = *(Y++) = a1*I1 + a2*I2 + b1*Y1 + b2*Y2;                          \
-        I2=I1; Y2=Y1; Y1=Y0; }                                                \
-    ima-=offset; I2 = *ima; Y2 = Y1 = parity*sumg1*I2; *ima = (T)(*(--Y)+Y2); \
-    ima-=offset; I1 = *ima; *ima = (T)(*(--Y)+Y1);                            \
-    for (i=(nb)-3; i>=0; i--) { Y0=a3*I1+a4*I2+b1*Y1+b2*Y2; ima-=offset;      \
-      I2=I1; I1=*ima; *ima=(T)(*(--Y)+Y0); Y2=Y1; Y1=Y0; }                    \
-  }
-
-    CImg& deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) {
-      cimg_test(*this,"CImg<T>::deriche");
-      if (sigma<0 || order<0 || order>2) throw CImgArgumentException("CImg<%s>::deriche() : Bad arguments (sigma=%g, order=%d)",pixel_type(),sigma,order);
-      if (sigma<0.01f) return *this;
-      const float alpha=sigma>0?1.695f/sigma:0,ea=(float)std::exp(alpha),ema=(float)std::exp(-alpha),em2a=ema*ema,b1=2*ema,b2=-em2a;
-      float ek,ekn,parity,a1,a2,a3,a4,g0,sumg1,sumg0;
-      double *Y,Y0,Y1,Y2;
-      int i,offset,nb;
-      T *ima,I1,I2;
-      switch(order) {
-      case 1:                 // first derivative
-        ek = -(1-ema)*(1-ema)*(1-ema)/(2*(ema+1)*ema); a1 = a4 = 0;  a2 = ek*ema; a3 = -ek*ema; parity =-1;\
-        if (cond) { sumg1 = (ek*ea) / ((ea-1)*(ea-1)); g0 = 0; sumg0 = g0+sumg1; } \
-        else g0 = sumg0 = sumg1 = 0;
-        break;
-      case 2:               // second derivative
-        ekn = ( -2*(-1+3*ea-3*ea*ea+ea*ea*ea)/(3*ea+1+3*ea*ea+ea*ea*ea) );
-        ek = -(em2a-1)/(2*alpha*ema); a1 = ekn;  a2 = -ekn*(1+ek*alpha)*ema; a3 = ekn*(1-ek*alpha)*ema; a4 = -ekn*em2a; parity =1;
-        if (cond) { sumg1 = ekn/2; g0 = ekn; sumg0 = g0+sumg1; }
-        else g0=sumg0=sumg1=0;
-        break;
-      default:              // smoothing
-        ek = (1-ema)*(1-ema) / (1+2*alpha*ema - em2a); a1 = ek;  a2 = ek*ema*(alpha-1); a3 = ek*ema*(alpha+1); a4 = -ek*em2a; parity = 1;
-        if (cond) { sumg1 = ek*(alpha*ea+ea-1) / ((ea-1)*(ea-1)); g0 = ek; sumg0 = g0+sumg1; }
-        else  g0=sumg0=sumg1=0;
-        break;
-      }
-      // filter init
-      Y = new double[cimg::max(width,height,depth)];
-      switch(cimg::uncase(axe)) {
-      case 'x': if (width>1)  { offset = 1;            nb = width;  cimg_mapYZV(*this,y,z,k) cimg_deriche_map(0,y,z,k,nb,offset,T); }	break;
-      case 'y': if (height>1) { offset = width;        nb = height; cimg_mapXZV(*this,x,z,k) cimg_deriche_map(x,0,z,k,nb,offset,T); }	break;
-      case 'z': if (depth>1)  { offset = width*height; nb = depth;  cimg_mapXYV(*this,x,y,k) cimg_deriche_map(x,y,0,k,nb,offset,T); }	break;
-      default : cimg::warn(true,"CImg<%s>::deriche() : Unknown axe '%c'",pixel_type(),axe); break;
-      }
-      delete[] Y;
-      return *this;
-    }
-    //! Return the result of the Deriche filter
-    CImg get_deriche(const float sigma=1,const int order=0,const char axe='x',const unsigned int cond=1) const {
-      return CImg<T>(*this).deriche(sigma,order,axe,cond);
-    }
-    //! Blur the image with a Deriche filter (quasi-gaussian filter)
-    CImg& blur(const float sigma=1,const unsigned int cond=1) {
-      cimg_test(*this,"CImg<T>::blur");
-      if (width>1)  deriche(sigma,0,'x',cond);
-      if (height>1) deriche(sigma,0,'y',cond);
-      if (depth>1)  deriche(sigma,0,'z',cond);
-      return *this;
-    }
-    //! Return a blurred version of the image, using a Deriche filter (quasi gaussian filter)
-    CImg get_blur(const float sigma=1,const unsigned int cond=1) const { return CImg<T>(*this).blur(sigma,cond); }
-
-    //! Return a eroded image (\p times erosion).
-    CImg get_erode(const unsigned int n=1) {
-      CImg_3x3x3(I,T);
-      if (n==1) {
-        CImg dest(*this);
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) 
-	  if (Iccc && (!Incc || !Ipcc || !Icnc || !Icpc || !Iccn || !Iccp)) dest(x,y,z,k) = 0;
-        return dest;
-      }
-      CImg img1(*this),img2(*this,false);
-      CImg *src = &img1, *dest = &img2, *tmp = NULL;
-      for (unsigned int iter=0; iter<n; iter++) {
-        *dest = *src;
-        cimg_mapV(*src,k) cimg_map3x3x3(*src,x,y,z,k,I) 
-	  if (Iccc && (!Incc || !Ipcc || !Icnc || !Icpc || !Iccn || !Iccp)) (*dest)(x,y,z,k) = 0;
-        tmp = src;
-        src = dest;
-        dest = tmp;
-      }
-      return *src;      
-    }
-    //! Erode the image \p n times.
-    CImg& erode(const unsigned int n=1) { return get_erode(n).swap(*this); }
-
-    //! Return an dilated image (\p times dilatation).
-    CImg get_dilate(const unsigned int n=1) {
-      CImgStats stats(*this);
-      const T tmax = stats.max!=0?(T)stats.max:(T)1;
-      CImg_3x3x3(I,T);
-      if (n==1) {
-        CImg dest(*this);
-        cimg_mapV(*this,k) cimg_map3x3x3(*this,x,y,z,k,I) 
-	  if (!Iccc && (Incc || Ipcc || Icnc || Icpc || Iccn || Iccp)) dest(x,y,z,k) = tmax;
-        return dest;
-      }
-      CImg img1(*this),img2(*this,false);
-      CImg *src = &img1, *dest = &img2, *tmp = NULL;
-      for (unsigned int iter=0; iter<n; iter++) {
-        *dest = *src;
-        cimg_mapV(*src,k) cimg_map3x3x3(*src,x,y,z,k,I) 
-	  if (!Iccc && (Incc || Ipcc || Icnc || Icpc || Iccn || Iccp)) (*dest)(x,y,z,k) = tmax;
-        tmp = src;
-        src = dest;
-        dest = tmp;
-      }
-      return *src;      
-    }
-    //! Dilate the image \p n times.
-    CImg& dilate(const unsigned int n=1) { return get_dilate(n).swap(*this); }
-
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Matrix and vector computation
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-
-    //! Return a vector with specified coefficients
-    static CImg vector(const T& a1) { return CImg<T>(1,1).fill(a1); }
-    static CImg vector(const T& a1,const T& a2) { return CImg<T>(1,2).fill(a1,a2); }
-    static CImg vector(const T& a1,const T& a2,const T& a3) { return CImg<T>(1,3).fill(a1,a2,a3); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4) { return CImg<T>(1,4).fill(a1,a2,a3,a4); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5) { return CImg<T>(1,5).fill(a1,a2,a3,a4,a5); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) { return CImg<T>(1,6).fill(a1,a2,a3,a4,a5,a6); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7) { return CImg<T>(1,7).fill(a1,a2,a3,a4,a5,a6,a7); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7,const T& a8) { return CImg<T>(1,8).fill(a1,a2,a3,a4,a5,a6,a7,a8); }
-    static CImg vector(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7,const T& a8,const T& a9) { return CImg<T>(1,9).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9); }
-
-    //! Return a square matrix with specified coefficients
-    static CImg matrix(const T& a1) { return vector(a1); }
-    static CImg matrix(const T& a1,const T& a2,
-		       const T& a3,const T& a4) { return CImg<T>(2,2).fill(a1,a2,a3,a4); }
-    static CImg matrix(const T& a1,const T& a2,const T& a3,
-		       const T& a4,const T& a5,const T& a6,
-		       const T& a7,const T& a8,const T& a9) { return CImg<T>(3,3).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9); }
-    static CImg matrix(const T& a1,const T& a2,const T& a3,const T& a4,
-		       const T& a5,const T& a6,const T& a7,const T& a8,
-		       const T& a9,const T& a10,const T& a11,const T& a12,
-		       const T& a13,const T& a14,const T& a15,const T& a16) {
-      return CImg<T>(4,4).fill(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);
-    }
-
-    //! Return a diffusion tensor with specified coefficients
-    static CImg tensor(const T& a1) { return matrix(a1); }
-    static CImg tensor(const T& a1,const T& a2,const T& a3) { return matrix(a1,a2,a2,a3); }
-    static CImg tensor(const T& a1,const T& a2,const T& a3,const T& a4,const T& a5,const T& a6) {
-      return matrix(a1,a2,a3,a2,a4,a5,a3,a5,a6);
-    }
-
-    //! Return a diagonal matrix with specified coefficients
-    static CImg diagonal(const T& a1) { return matrix(a1); }
-    static CImg diagonal(const T& a1,const T& a2) { return matrix(a1,0,0,a2); }
-    static CImg diagonal(const T& a1,const T& a2,const T& a3) { return matrix(a1,0,0,0,a2,0,0,0,a3); }
-    static CImg diagonal(const T& a1,const T& a2,const T& a3,const T& a4) { return matrix(a1,0,0,0,0,a2,0,0,0,0,a3,0,0,0,0,a4); }
-
-    //! Operator* (matrix product)
-    template<typename t> CImg operator*(const CImg<t>& img) const {
-      cimg_test_matrix(*this,"CImg<T>::operator*");
-      cimg_test_matrix(img,"CImg<T>::operator*");
-      if (width!=img.height) 
-        throw CImgArgumentException("CImg<%s>::operator*() : can't multiply a matrix *this = (%ux%u) by a matrix (%ux%u)",
-                                    pixel_type(),width,height,img.width,img.height);
-      CImg res(img.width,height);
-      double val;
-      cimg_mapXY(res,i,j) { val=0; cimg_mapX(*this,k) val+=(*this)(k,j)*img(i,k); res(i,j) = (T)val; }
-      return res;
-    }
-    //! Operator*= (matrix product)
-    template<typename t> CImg& operator*=(const CImg<t>& img) { return ((*this)*img).swap(*this); }
-  
-    //! Return a new image corresponding to the vector located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_vector(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
-      CImg dest(dim);
-      cimg_mapV(*this,k) dest[k]=(*this)(x,y,z,k);
-      return dest;
-    }
-  
-    //! Return a new image corresponding to the \a square \a matrix located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_matrix(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {
-      const int n = (int)std::sqrt((double)dim);
-      CImg dest(n,n);
-      cimg_mapV(*this,k) dest[k]=(*this)(x,y,z,k);
-      return dest;
-    }
-  
-    //! Return a new image corresponding to the \a diffusion \a tensor located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg get_tensor(const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) const {      
-      if (dim==6) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2),
-				(*this)(x,y,z,3),(*this)(x,y,z,4),(*this)(x,y,z,5));
-      if (dim==3) return tensor((*this)(x,y,z,0),(*this)(x,y,z,1),(*this)(x,y,z,2));
-      return tensor((*this)(x,y,z,0));
-    }
-
-    //! Set the image \p vec as the \a vector \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_vector(const CImg& vec,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      return draw_point(x,y,z,vec.data,1);
-    }
-    //! Set the image \p vec as the \a square \a matrix-valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_matrix(const CImg& mat,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      return set_vector(mat,x,y,z);
-    }
-    //! Set the image \p vec as the \a tensor \a valued pixel located at (\p x,\p y,\p z) of the current vector-valued image.
-    CImg& set_tensor(const CImg& ten,const unsigned int x=0,const unsigned int y=0,const unsigned int z=0) {
-      if (ten.height==2) {
-        (*this)(x,y,z,0)=ten[0];
-        (*this)(x,y,z,1)=ten[1];
-        (*this)(x,y,z,2)=ten[3];
-      }
-      else {
-        (*this)(x,y,z,0)=ten[0];
-        (*this)(x,y,z,1)=ten[1];
-        (*this)(x,y,z,2)=ten[2];
-        (*this)(x,y,z,3)=ten[4];
-        (*this)(x,y,z,4)=ten[5];
-        (*this)(x,y,z,5)=ten[8];
-      }
-      return *this;
-    }
-    //! Set the current matrix to be the identity matrix.
-    CImg& identity_matrix() {    
-      cimg_test_square(*this,"CImg<T>::identity_matrix");
-      fill(0);
-      cimg_mapX(*this,x) (*this)(x,x) = (T)1;
-      return *this;
-    }
-    //! Return a matrix \p dim * \p dim equal to \p factor * \a Identity.
-    static CImg get_identity_matrix(const unsigned int dim) {
-      return CImg<T>(dim,dim).identity_matrix();
-    }
-  
-    //! Return the transpose version of the current matrix.
-    CImg get_transpose() const {
-      cimg_test_matrix(*this,"CImg<T>::get_transpose");
-      CImg res(height,width);
-      cimg_mapXY(res,x,y) res(x,y) = (*this)(y,x);
-      return res;
-    }
-    //! Replace the current matrix by its transpose.
-    CImg& transpose() { return get_transpose().swap(*this); }
-
-    //! Get a diagonal matrix, whose diagonal coefficients are the coefficients of the input image
-    CImg get_diagonal() const {
-      cimg_test(*this,"CImg<T>::get_diagonal");
-      CImg res(size(),size(),1,1,0);
-      cimg_mapoff(*this,off) res(off,off)=(*this)(off);
-      return res;
-    }
-    //! Replace a vector by a diagonal matrix containing the original vector coefficients.
-    CImg& diagonal() { return get_diagonal().swap(*this); }
-
-    //! Inverse the current matrix.
-    CImg& inverse() {
-      cimg_test_square(*this,"CImg<T>::inverse");
-      switch (width) {
-      case 2:
-        {
-          const double 
-            a = data[0], c = data[1],
-            b = data[2], d = data[3],
-            dete = det();
-          if (dete) { 
-            data[0] = (T)(d/dete);  data[1] = (T)(-c/dete);
-            data[2] = (T)(-b/dete), data[3] = (T)(a/dete); 
-          } else {
-            cimg::warn(true,"CImg<%s>::inverse() : Matrix determinant is 0, can't invert matrix",pixel_type());
-            fill(0);
-          }
-        }
-        break;
-      case 3:
-        {
-          const double
-            a = data[0], d = data[1], g = data[2],
-            b = data[3], e = data[4], h = data[5],
-            c = data[6], f = data[7], i = data[8],
-            dete = det();
-          if (dete) {
-            data[0] = (T)((i*e-f*h)/dete), data[1] = (T)((g*f-i*d)/dete), data[2] = (T)((d*h-g*e)/dete);
-            data[3] = (T)((h*c-i*b)/dete), data[4] = (T)((i*a-c*g)/dete), data[5] = (T)((g*b-a*h)/dete);
-            data[6] = (T)((b*f-e*c)/dete), data[7] = (T)((d*c-a*f)/dete), data[8] = (T)((a*e-d*b)/dete);
-          } else {
-            cimg::warn(true,"CImg<%s>::inverse() : Matrix determinant is 0, can't invert matrix",pixel_type());
-            fill(0);
-          }
-        }
-        break;
-      default:
-        {        
-          int N = width, LWORK = 4*N, *IPIV = new int[N], INFO;
-          double *A = new double[N*N], *WORK = new double[LWORK];
-          for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) A[k*N+l] = (*this)(k,l);
-          dgetrf_(&N,&N,A,&N,IPIV,&INFO);
-          cimg::warn(INFO!=0,"CImg<%s>::inverse() : LAPACK Error code = %d, from dgetrf_()",pixel_type(),INFO);
-          if (!INFO) {
-            dgetri_(&N,A,&N,IPIV,WORK,&LWORK,&INFO);
-            cimg::warn(INFO!=0,"CImg<%s>::inverse() : LAPACK Error code = %d, from dgetri_()",pixel_type(),INFO);
-          }
-          if (!INFO) for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) (*this)(k,l) = (T)(A[k*N+l]);
-          else fill(0);
-          delete[] IPIV; delete[] A; delete[] WORK;        
-        }
-      }
-      return *this;
-    }
-    //! Return the inverse of the current matrix.
-    CImg get_inverse() const { return CImg<T>(*this).inverse(); }
-
-    //! Return the trace of the current matrix.
-    double trace() const {
-      cimg_test_square(*this,"CImg<T>::trace");
-      double res=0;
-      cimg_mapX(*this,k) res+=(*this)(k,k);
-      return res;
-    }
-    //! Return the dot product of the current vector/matrix with the vector/matrix \p img.
-    double dot(const CImg& img) const {
-      cimg_test(*this,"CImg<T>::dot"); cimg_test(img,"CImg<T>::dot");
-      const unsigned int nb = cimg::min(size(),img.size());
-      double res=0;
-      for (unsigned int off=0; off<nb; off++) res+=data[off]*img[off];
-      return res;
-    }
-	
-    //! Return the cross product between two 3d vectors
-    CImg& cross(const CImg& img) {
-      if (width!=1 || height<3 || img.width!=1 || img.height<3)
-        throw CImgInstanceException("CImg<%s>::cross() : cannot get cross product between two matrices (%u,%u) and (%u,%u)",
-                                    pixel_type(),width,height,img.width,img.height);
-      const T x = (*this)[0], y = (*this)[1], z = (*this)[2];
-      (*this)[0] = y*img[2]-z*img[1];
-      (*this)[1] = z*img[0]-x*img[2];
-      (*this)[2] = x*img[1]-y*img[0];
-      return *this;
-    }
-    //! Return the cross product between two 3d vectors
-    CImg get_cross(const CImg& img) const { return CImg<T>(*this).cross(img); }
-
-    //! Return the determinant of the current matrix.
-    double det() const {
-      cimg_test_square(*this,"CImg<T>::det");
-      switch (width) {
-      case 1: return (*this)(0,0);
-      case 2: return (*this)(0,0)*(*this)(1,1)-(*this)(0,1)*(*this)(1,0);
-      case 3: 
-        {
-          const double
-            a = data[0], d = data[1], g = data[2],
-            b = data[3], e = data[4], h = data[5],
-            c = data[6], f = data[7], i = data[8];
-          return i*a*e-a*h*f-i*b*d+b*g*f+c*d*h-c*g*e;
-        }
-      }
-      return 0;
-    }
-    //! Return the norm of the current vector/matrix. \p ntype = norm type (0=L2, 1=L1, -1=Linf).
-    double norm(const int ntype=2) const {
-      cimg_test(*this,"CImg<T>::norm");
-      double res = 0;
-      switch (ntype) {
-      case -1: { cimg_mapoff(*this,off) if (std::fabs((double)data[off])>res) res = std::fabs((double)data[off]); return res; }
-      case 1 : { cimg_mapoff(*this,off) res+=std::fabs((double)data[off]); return res; }
-      default: { return std::sqrt(dot(*this)); }
-      }
-      return 0;
-    }
-    //! Return the sum of all the pixel values in an image.
-    double sum() const {
-      cimg_test(*this,"CImg<T>::sum");		
-      double res=0;
-      cimg_map(*this,ptr,T) res+=*ptr;
-      return res;
-    }
-    //! Compute the eigenvalues and eigenvectors of a general matrix.
-    template<typename t> const CImg<T>& eigen(CImg<t>& val, CImg<t> &vec) const {
-      cimg_test_square(*this,"CImg<T>::eigen");
-      if (val.size()<width) 
-        throw CImgArgumentException("CImg<%s>::eigen() : Argument 'val' is not large enough to be filled with eigenvalues (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width);
-      if (vec.data && vec.size()<width*width) 
-        throw CImgArgumentException("CImg<%s>::eigen() : Argument 'vec' is not large enough to be filled with eigenvectors (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width*width);
-      switch(width) {
-      case 1:
-        val[0]=(t)(*this)[0]; 
-        if (vec.data) vec[0]=(t)1;
-        break;
-      case 2:
-        {
-          const double
-            a = (*this)[0], b = (*this)[1],
-            c = (*this)[2], d = (*this)[3],
-            e = a+d;
-          double f = e*e-4*(a*d-b*c);
-          cimg::warn(f<0,"CImg<%s>::eigen() : Complex eigenvalues",pixel_type());
-          f = std::sqrt(f);
-          const double l1 = 0.5*(e-f), l2 = 0.5*(e+f);
-          val[0]=(t)l1; val[1]=(t)l2;
-          if (vec.data) {
-            double u,v,n;
-            if (std::fabs(b)>std::fabs(a-l1)) { u = 1; v = (l1-a)/b; }
-            else { if (a-l1!=0) { u = -b/(a-l1); v = 1; } else { u = 1; v = 0; } }
-            n = std::sqrt(u*u+v*v); u/=n; v/=n; vec[0] = (t)u; vec[1] = (t)v;
-            if (std::fabs(b)>std::fabs(a-l2)) { u = 1; v = (l2-a)/b; }
-            else { if (a-l2!=0) { u = -b/(a-l2); v = 1; } else { u = 0; v = 1; } }
-            n = std::sqrt(u*u+v*v); u/=n; v/=n; vec[2] = (t)u; vec[3] = (t)v;
-          }
-        }
-        break;
-      default: 
-        throw CImgInstanceException("CImg<%s>::eigen() : Eigenvalues computation of general matrices is limited to 2x2 matrices (given is %ux%u)",
-                                    pixel_type(),width,height);
-      }
-      return *this;
-    }
-
-    //! Compute the eigenvalues of a general matrix.
-    template<typename t> const CImg<T>& eigen(CImg<t>& val) const { CImg foo; return eigen(val,foo); }
-    CImgl<T> get_eigen(const bool compute_vectors=true) const {
-      cimg_test_square(*this,"CImg<T>::get_eigen");
-      CImgl<T> res(1,1,width);
-      if (compute_vectors) res.insert(CImg<T>(width,width));
-      eigen(res[0],res[1]);
-      return res;
-    }
-
-    //! Compute the eigenvalues and eigenvectors of a symmetric matrix.
-    template<typename t> const CImg<T>& symeigen(CImg<t>& val, CImg<t>& vec) const {
-      cimg_test_square(*this,"CImg<T>::symeigen");
-      if (val.size()<width) 
-        throw CImgArgumentException("CImg<%s>::symeigen() : Argument 'val' is not large enough to be filled with eigenvalues (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width);
-      if (vec.data && vec.size()<width*width) 
-        throw CImgArgumentException("CImg<%s>::symeigen() : Argument 'vec' is not large enough to be filled with eigenvectors (size=%u, needed is %u)",
-                                    pixel_type(),val.size(),width*width);
-      char JOBZ=vec.data?'V':'N', UPLO='U';
-      int N,INFO=0,LWORK;
-      double *WORK,*A,*VAL;
-      if (width<3) return eigen(val,vec);
-      N = width;
-      LWORK = 5*N;
-      A    = new double[N*N];
-      WORK = new double[LWORK];
-      VAL  = new double[width];
-      for (unsigned int k=0; k<(unsigned int)N; k++) for (unsigned int l=0; l<(unsigned int)N; l++) A[k*N+l] = (*this)(k,l);
-      dsyev_(&JOBZ,&UPLO,&N,A,&N,VAL,WORK,&LWORK,&INFO);
-      cimg::warn(INFO!=0,"CImg<%s>::symeigen() : LAPACK Error code = %d, from ssyev_()",pixel_type(),INFO);
-      cimg_mapX(*this,x) val(x) = (t)VAL[x];
-      if (vec.data) cimg_mapXY(*this,x,y) vec(x,y) = (t)A[x+y*N];
-      delete[] A; 
-      delete[] WORK;
-      delete[] VAL;
-      return *this;
-    }
-    //! Compute the eigenvalues of a symmetric matrix.
-    template<typename t> const CImg<T>& symeigen(CImg<t>& val) const { CImg foo; return symeigen(val,foo); }
-    CImgl<T> get_symeigen(const bool compute_vectors=true) const {
-      cimg_test_square(*this,"CImg<T>::symeigen");
-      CImgl<T> res(1,1,width);
-      if (compute_vectors) res.insert(CImg<T>(width,width));
-      symeigen(res[0],res[1]);
-      return res;
-    }
-
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Display functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-  
-    //! Display an image into a CImgDisplay window.
-    const CImg& display(CImgDisplay& disp,const unsigned int ymin=0,const unsigned int ymax=~0) const { disp.display(*this,ymin,ymax); return *this; }
-
-    //! Same as \ref cimg::wait()
-    const CImg& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this;  }
-  
-    //! Display an image in a window with a title \p title, and wait a 'closed' or 'keyboard' event.\n
-    //! Parameters \p min_size and \p max_size set the minimum and maximum dimensions of the display window.
-    //! If negative, they corresponds to a percentage of the original image size.
-    const CImg& display(const char* title,const int min_size=128,const int max_size=1024) const {
-      cimg_test(*this,"CImg<T>::display");
-      CImgDisplay *disp;
-      unsigned int w = width+(depth>1?depth:0), h = height+(depth>1?depth:0), XYZ[3];
-      print(title);
-      const unsigned int dmin = cimg::min(w,h), minsiz = min_size>=0?min_size:(-min_size)*dmin/100;
-      if (dmin<minsiz) { w=w*minsiz/dmin; w+=(w==0); h=h*minsiz/dmin; h+=(h==0); }
-      const unsigned int dmax = cimg::max(w,h), maxsiz = max_size>=0?max_size:(-max_size)*dmax/100;
-      if (dmax>maxsiz) { w=w*maxsiz/dmax; w+=(w==0); h=h*maxsiz/dmax; h+=(h==0); }
-      disp = new CImgDisplay(CImg<unsigned char>(w,h,1,1,0),title,0,3);
-      XYZ[0] = width/2; XYZ[1] = height/2; XYZ[2] = depth/2;
-      while (!disp->closed && !disp->key) feature_selection(NULL,1,*disp,XYZ);
-      delete disp;
-      return *this;
-    }
-
-    //! Display an image in a window, with a default title. See also \see display() for details on parameters.
-    const CImg& display(const int min_size=128,const int max_size=1024) const { return display("",min_size,max_size); }
-  
-    //! High-level interface to select features from images
-    const CImg& feature_selection(int *const selection, const int feature_type,CImgDisplay &disp,
-                                  unsigned int *const XYZ=NULL,const unsigned char *const color=NULL) const {
-      cimg_test(*this,"CImg<T>::feature_selection");
-      if (disp.events<3) 
-        throw CImgArgumentException("CImg<%s>::feature_selection() : Input display must be able to catch keyboard and mouse events (events>=3). Given display has 'events = %s'.",pixel_type(),disp.events);
-      unsigned char fgcolor[3]={255,255,105},bgcolor[3]={0,0,0};
-      if (color) std::memcpy(fgcolor,color,sizeof(unsigned char)*cimg::min(3,dimv()));
-      int carea=0,area=0,phase=0,
-        X0=(XYZ?XYZ[0]:width/2)%width, Y0=(XYZ?XYZ[1]:height/2)%height, Z0=(XYZ?XYZ[2]:depth/2)%depth, 
-        X=-1,Y=-1,Z=-1,oX=-1,oY=-1,oZ=-1,X1=-1,Y1=-1,Z1=-1;
-      unsigned long hatch=feature_type?0xF0F0F0F0:~0L;
-      bool feature_selected = false, ytext = false;
-      CImg<unsigned char> visu, visu0;
-      char text[1024];
-    
-      while (!disp.key && !disp.closed && !feature_selected) {
-
-        // Init visu0 if necessary
-        if (disp.resized || !visu0.data) { 
-          if (disp.resized) disp.resize();
-          if (depth==1) visu0=get_normalize(0,(T)255); else visu0=get_3dplanes(X0,Y0,Z0).get_normalize(0,(T)255);
-          visu0.resize(disp.width,disp.height,1,cimg::min(3,dimv()));
-        }
-        visu = visu0;      
-      
-        // Handle motion and selection
-        const int mx = disp.mousex, my = disp.mousey, b = disp.button;
-        if (mx>=0 && my>=0) {
-          const int mX = mx*(width+(depth>1?depth:0))/disp.width, mY = my*(height+(depth>1?depth:0))/disp.height;
-          if (mX<dimx() && mY<dimy())   { area=1; X=mX; Y=mY; Z=phase?Z1:Z0; }
-          if (mX<dimx() && mY>=dimy())  { area=2; X=mX; Y=phase?Y1:Y0; Z=mY-height; }
-          if (mX>=dimx() && mY<dimy())  { area=3; X=phase?X1:X0; Y=mY; Z=mX-width;  }
-          if (mX>=dimx() && mY>=dimy()) { X=X0; Y=Y0; Z=Z0; }
-          if ((!(phase%2) && (b&1)) || (phase%2 && !(b&1))) { 
-            if (!carea) carea=area;
-            if (!(phase++)) { X0=X; Y0=Y; Z0=Z; }
-          }
-          if (b&2) { if (!phase) { X0=X; Y0=Y; Z0=Z; } else { X1=Y1=Z1=-1; phase=carea=0; }}
-          if ((b&2 || phase) && depth>1) 
-            visu0 = get_3dplanes(X,Y,Z).normalize(0,(T)255).resize(disp.width,disp.height,1,cimg::min(3,dimv()));
-          if (phase) {
-            if (!feature_type) feature_selected = phase?true:false;
-            else {
-              if (depth>1) feature_selected = (phase==3)?true:false;
-              else feature_selected = (phase==2)?true:false;
-            }   
-            if (!feature_selected) {
-              if (phase<2) { X1=X; Y1=Y; Z1=Z; }
-              else switch(carea) {
-              case 1: Z1=Z; break;
-              case 2: Y1=Y; break;
-              case 3: X1=X; break;
-              }
-            }
-          }
-          if (!phase || !feature_type) {
-            if (depth>1) std::sprintf(text,"Coords (%d,%d,%d)={ ",X,Y,Z); else std::sprintf(text,"Coords (%d,%d)={ ",X,Y);
-            cimg_mapV(*this,k) std::sprintf(text+cimg::strlen(text),"%g ",(double)(*this)(X,Y,Z,k));
-            std::sprintf(text+cimg::strlen(text),"}");
-            if (!feature_type) { X1=X0; Y1=Y0; Z1=Z0; }
-          } else
-            switch (feature_type) {
-            case 1:
-              {
-                const double dX=(double)(X0-X1), dY=(double)(Y0-Y1), dZ=(double)(Z0-Z1), norm = std::sqrt(dX*dX+dY*dY+dZ*dZ);
-                if (depth>1) std::sprintf(text,"Vect (%d,%d,%d)-(%d,%d,%d), norm=%g",X0,Y0,Z0,X1,Y1,Z1,norm);
-                else std::sprintf(text,"Vect (%d,%d)-(%d,%d), norm=%g",X0,Y0,X1,Y1,norm);
-              }
-              break;
-            case 2:
-              if (depth>1) std::sprintf(text,"Box (%d,%d,%d)-(%d,%d,%d), Size=(%d,%d,%d)",
-                                        X0<X1?X0:X1,Y0<Y1?Y0:Y1,Z0<Z1?Z0:Z1,
-                                        X0<X1?X1:X0,Y0<Y1?Y1:Y0,Z0<Z1?Z1:Z0,
-                                        1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1),1+cimg::abs(Z0-Z1));
-              else  std::sprintf(text,"Box (%d,%d)-(%d,%d), Size=(%d,%d)",
-                                 X0<X1?X0:X1,Y0<Y1?Y0:Y1,X0<X1?X1:X0,Y0<Y1?Y1:Y0,1+cimg::abs(X0-X1),1+cimg::abs(Y0-Y1));
-              break;
-            }
-          if (my<12) ytext=true;
-          if (my>=visu.dimy()-11) ytext=false;
-          visu.draw_text(text,0,ytext?visu.dimy()-11:0,fgcolor,bgcolor,0.7f);
-        } else { X=Y=Z=-1; if (phase) disp.button=phase%2; }
-      
-        // Draw image + selection on display window
-        if (X>=0 && Y>=0 && Z>=0) {
-          hatch=cimg::ror(hatch);
-          if (feature_type==1 && phase) {
-            const int d=(depth>1)?depth:0,
-              x0=(int)((X0+0.5f)*disp.width/(width+d)), y0=(int)((Y0+0.5f)*disp.height/(height+d)),
-              x1=(int)((X1+0.5f)*disp.width/(width+d)), y1=(int)((Y1+0.5f)*disp.height/(height+d));
-            visu.draw_arrow(x0,y0,x1,y1,fgcolor,30.0f,5.0f,hatch);
-            if (d) {
-              const int zx0=(int)((width+Z0+0.5f)*disp.width/(width+d)), zx1=(int)((width+Z1+0.5f)*disp.width/(width+d)),
-                zy0=(int)((height+Z0+0.5f)*disp.height/(height+d)), zy1=(int)((height+Z1+0.5f)*disp.height/(height+d));
-              visu.draw_arrow(zx0,y0,zx1,y1,fgcolor,30.0f,5.0f,hatch).draw_arrow(x0,zy0,x1,zy1,fgcolor,30.0f,5.0f,hatch);
-            }
-          } else {
-            const bool cond=(phase&&feature_type);
-            const int d=(depth>1)?depth:0,
-              nX0=cond?X0:X, nY0=cond?Y0:Y, nZ0=cond?Z0:Z,
-              nX1=cond?X1:X, nY1=cond?Y1:Y, nZ1=cond?Z1:Z,
-              x0=(nX0<nX1?nX0:nX1)*disp.width/(width+d),
-              y0=(nY0<nY1?nY0:nY1)*disp.height/(height+d),
-              x1=((nX0<nX1?nX1:nX0)+1)*disp.width/(width+d)-1,
-              y1=((nY0<nY1?nY1:nY0)+1)*disp.height/(height+d)-1;
-            const unsigned long nhatch=phase?hatch:~0L;
-            visu.draw_rectangle(x0,y0,x1,y1,fgcolor,0.2f).draw_line(x0,y0,x1,y0,fgcolor,nhatch).
-              draw_line(x1,y0,x1,y1,fgcolor,nhatch).draw_line(x1,y1,x0,y1,fgcolor,nhatch).draw_line(x0,y1,x0,y0,fgcolor,nhatch);
-            if (d) {
-              const int
-                zx0=(int)((width+(nZ0<nZ1?nZ0:nZ1))*disp.width/(width+d)),
-                zy0=(int)((height+(nZ0<nZ1?nZ0:nZ1))*disp.height/(height+d)),
-                zx1=(int)((width+(nZ0<nZ1?nZ1:nZ0)+1)*disp.width/(width+d))-1,
-                zy1=(int)((height+(nZ0<nZ1?nZ1:nZ0)+1)*disp.height/(height+d))-1;
-              visu.draw_rectangle(zx0,y0,zx1,y1,fgcolor,0.2f).draw_line(zx0,y0,zx1,y0,fgcolor,nhatch).
-                draw_line(zx1,y0,zx1,y1,fgcolor,nhatch).draw_line(zx1,y1,zx0,y1,fgcolor,nhatch).draw_line(zx0,y1,zx0,y0,fgcolor,nhatch);
-              visu.draw_rectangle(x0,zy0,x1,zy1,fgcolor,0.2f).draw_line(x0,zy0,x1,zy0,fgcolor,nhatch).
-                draw_line(x1,zy0,x1,zy1,fgcolor,nhatch).draw_line(x1,zy1,x0,zy1,fgcolor,nhatch).draw_line(x0,zy1,x0,zy0,fgcolor,nhatch);
-            }
-          }
-        }
-        visu.display(disp).wait(32);
-        if (!feature_selected && (!phase && oX==X && oY==Y && oZ==Z) || (X<0 || Y<0 || Z<0)) disp.wait();
-        oX=X; oY=Y; oZ=Z;
-      }
-
-      // Return result
-      if (XYZ) { XYZ[0] = X; XYZ[1] = Y; XYZ[2] = Z; }
-      if (feature_selected) {
-        if (feature_type==2) {
-          if (X0>X1) cimg::swap(X0,X1);
-          if (Y0>Y1) cimg::swap(Y0,Y1);
-          if (Z0>Z1) cimg::swap(Z0,Z1);
-        }
-        if (selection) {
-          if (X1<0 || Y1<0 || Z1<0) X0=Y0=Z0=X1=Y1=Z1=-1;
-          switch(feature_type) {
-          case 1:
-          case 2:  selection[3] = X1; selection[4] = Y1; selection[5] = Z1;
-          default: selection[0] = X0; selection[1] = Y0; selection[2] = Z0;
-          }
-        }
-      } else if (selection) selection[0]=selection[1]=selection[2]=selection[3]=selection[4]=selection[5]=-1;
-      disp.button=0;
-      return *this;
-    }
-
-    //! High-level interface to select features in images
-    const CImg& feature_selection(int *const selection, const int feature_type,
-                                  unsigned int *const XYZ=NULL,const unsigned char *const color=NULL) const {
-      unsigned int w = width + (depth>1?depth:0), h = height + (depth>1?depth:0);
-      const unsigned int dmin = cimg::min(w,h), minsiz = 256;
-      if (dmin<minsiz) { w=w*minsiz/dmin; h=h*minsiz/dmin; }
-      const unsigned int dmax = cimg::max(w,h), maxsiz = 1024;
-      if (dmax>maxsiz) { w=w*maxsiz/dmax; h=h*maxsiz/dmax; }
-      CImgDisplay disp(w,h,"",0,3);
-      return feature_selection(selection,feature_type,disp,XYZ,color);
-    }
-  
- 
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Input-Output functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-
-    //! Load an image from a file.
-    /**
-       \note The extension of \c filename defines the file format.
-    **/
-    static CImg load(const char *filename) {
-      const char *ext = cimg::filename_split(filename);
-      if (!filename) throw CImgArgumentException("CImg<%s>::load() : Can't load (null) filename",pixel_type());
-      if (!cimg::strcasecmp(ext,"asc")) return load_ascii(filename);
-      if (!cimg::strcasecmp(ext,"dlm")) return load_dlm(filename);
-      if (!cimg::strcasecmp(ext,"inr")) return load_inr(filename);
-      if (!cimg::strcasecmp(ext,"hdr")) return load_analyze(filename);
-      if (!cimg::strcasecmp(ext,"pan")) return load_pandore(filename);
-      if (!cimg::strcasecmp(ext,"bmp")) return load_bmp(filename);
-      if (!cimg::strcasecmp(ext,"ppm") || 
-	  !cimg::strcasecmp(ext,"pgm") ||
-	  !cimg::strcasecmp(ext,"pnm")) return load_pnm(filename);
-      if (!cimg::strcasecmp(ext,"raw") || ext[0]=='\0') return load_raw(filename);      
-      return load_convert(filename);
-    }
-
-    //! Load an image from an ASCII file
-    static CImg load_ascii(const char *filename) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-      char line[256] = {0};
-      std::fscanf(file,"%255[^\n]",line);
-      unsigned int off;
-	  int err=1, dx=0, dy=1, dz=1, dv=1;
-      std::sscanf(line,"%d %d %d %d",&dx,&dy,&dz,&dv);
-      if (!dx || !dy || !dz || !dv)
-	throw CImgIOException("CImg<%s>::load_ascii() : File '%s' does not appear to be a valid ASC file.\n"
-			      "Specified image dimensions are (%d,%d,%d,%d)",pixel_type(),filename,dx,dy,dz,dv);
-      CImg dest(dx,dy,dz,dv);
-      double val;
-      T *ptr = dest.data;
-      for (off=0; off<dest.size() && err==1; off++) {
-	err = fscanf(file,"%lf%*[^0-9.eE+-]",&val); 
-	*(ptr++)=(T)val; 
-      }
-      cimg::warn(off<dest.size(),"CImg<%s>::load_ascii() : File '%s', only %u values read, instead of %u",
-		 pixel_type(),filename,off,dest.size());
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a DLM file
-    static CImg load_dlm(const char *filename) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-      unsigned int cdx=0,dx=0,dy=0;
-      double val;
-      char c, delimiter[256]={0};
-      int err;
-      while ((err = std::fscanf(file,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
-	if (err>0) cdx++;
-	if (std::sscanf(delimiter,"%*[^\n]%c",&c)>0 && c=='\n') { dx = cimg::max(cdx,dx); dy++; cdx=0; }
-      }
-      if (!dx || !dy) throw CImgIOException("CImg<%s>::load_dlm() : File '%s' does not appear to be a "
-					    "valid DLM file.\n",pixel_type(),filename);
-      std::rewind(file);
-      CImg<T> dest(dx,dy,1,1,0);
-      unsigned int x = 0, y = 0;
-      while ((err = std::fscanf(file,"%lf%255[^0-9.eE+-]",&val,delimiter))!=EOF) {
-	if (err>0) dest(x++,y) = (T)val;
-	if (std::sscanf(delimiter,"%*[^\n]%c",&c)>0 && c=='\n') { x=0; y++; }
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a PNM file
-    static CImg load_pnm(const char *filename) {
-      std::FILE *file=cimg::fopen(filename,"rb");
-      char item[1024]={0};
-      unsigned int ppm_type,width,height,colormax=255;
-      int err;
-      
-      while ((err=std::fscanf(file,"%1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
-      if(std::sscanf(item," P%u",&ppm_type)!=1) 
-        throw CImgIOException("CImg<%s>::load_pnm() : file '%s',PPM header 'P?' not found",pixel_type(),filename);
-      while ((err=std::fscanf(file," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
-      if (std::sscanf(item," %u %u",&width,&height)!=2)
-        throw CImgIOException("CImg<%s>::load_pnm() : file '%s',WIDTH and HEIGHT not defined",pixel_type(),filename);
-      while ((err=std::fscanf(file," %1023[^\n]",item))!=EOF && (item[0]=='#' || !err)) std::fgetc(file);
-      std::fgetc(file);
-      cimg::warn(std::sscanf(item,"%u",&colormax)!=1,"CImg<%s>::load_pnm() : file '%s',COLORMAX not defined",pixel_type(),filename);
-      cimg::warn(colormax!=255,"CImg<%s>::load_pnm() : file '%s', COLORMAX=%u mode is not supported",pixel_type(),filename,colormax);
-
-      CImg dest;
-      int rval,gval,bval;
-
-      switch (ppm_type) {
-      case 2: { // Grey Ascii
-	dest = CImg<T>(width,height,1,1);
-	T* rdata = dest.ptr();
-	cimg_mapoff(dest,off) { std::fscanf(file,"%d",&rval); *(rdata++)=(T)rval; }
-      } break;
-      case 3: { // Color Ascii
-	dest = CImg<T>(width,height,1,3);
-	T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-	cimg_mapXY(dest,x,y) { 
-	  std::fscanf(file,"%d %d %d",&rval,&gval,&bval);
-	  *(rdata++)=(T)rval; 
-	  *(gdata++)=(T)gval; 
-	  *(bdata++)=(T)bval; }
-      } break;
-      case 5: { // Grey Binary
-	unsigned char *raw = new unsigned char[width*height], *raw2 = raw;
-	cimg::fread(raw,sizeof(unsigned char),width*height,file);
-	dest = CImg<T>(width,height,1,1);
-	T *rdata = dest.ptr();
-	cimg_mapoff(dest,off) *(rdata++)=(T)*(raw2++);
-	delete[] raw;
-      } break;
-      case 6: { // Color Binary
-	unsigned char *raw = new unsigned char[width*height*3], *raw2 = raw;
-	cimg::fread(raw,sizeof(unsigned char),width*height*3,file);
-	dest = CImg<T>(width,height,1,3);
-	T *rdata = dest.ptr(0,0,0,0), *gdata = dest.ptr(0,0,0,1), *bdata = dest.ptr(0,0,0,2);
-	cimg_mapXY(dest,x,y) {
-	  *(rdata++)=(T)*(raw2++);
-	  *(gdata++)=(T)*(raw2++);
-	  *(bdata++)=(T)*(raw2++); 
-	}
-	delete[] raw;
-      } break;
-      default:
-	cimg::fclose(file);
-	throw CImgIOException("CImg<%s>::load_pnm() : file '%s', PPM type 'P%d' not supported",pixel_type(),filename,ppm_type);
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a BMP file.
-    static CImg load_bmp(const char *filename) {
-      unsigned char header[64];
-      std::FILE *file = cimg::fopen(filename,"rb");
-      cimg::fread(header,sizeof(unsigned char),54,file);
-      if (header[0]!='B' || header[1]!='M')
-	throw CImgIOException("CImg<%s>::load_bmp() : filename '%s' does not appear to be a valid BMP file",
-			      pixel_type(),filename);
-      
-      // Read header and pixel buffer
-      int
-	file_size   = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24),
-	offset      = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24),
-	dx          = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24),
-	dy          = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24),
-	compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24),
-	nb_colors   = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24),
-	bpp         = header[0x1C] + (header[0x1D]<<8),
-	*palette    = NULL;
-      const int 
-	dx_bytes   = (bpp==1)?(dx/8+(dx%8?1:0)):((bpp==4)?(dx/2+(dx%2?1:0)):(dx*bpp/8)),
-	align      = (4-dx_bytes%4)%4,
-	buf_size   = cimg::min(cimg::abs(dy)*(dx_bytes+align),file_size-offset);
-
-      if (bpp<16) { if (!nb_colors) nb_colors=1<<bpp; } else nb_colors=0;
-      if (nb_colors) { palette = new int[nb_colors]; cimg::fread(palette,sizeof(int),nb_colors,file); }
-      const int	xoffset = offset-54-4*nb_colors;      
-      if (xoffset>0) std::fseek(file,xoffset,SEEK_CUR);
-      const unsigned char *buffer  = new unsigned char[buf_size], *ptrs = buffer;
-      cimg::fread(buffer,sizeof(unsigned char),buf_size,file);
-      cimg::fclose(file);
-
-      // Decompress buffer (if necessary)
-      if (compression) return load_convert(filename);
-      
-      // Read pixel data
-      CImg res(dx,cimg::abs(dy),1,3);
-      switch (bpp) {
-      case 1: { // Monochrome
-	for (int y=res.height-1; y>=0; y--) { 
-	  unsigned char mask = 0x80, val = 0;
-	  cimg_mapX(res,x) {
-	    if (mask==0x80) val = *(ptrs++);
-	    const unsigned char *col = (unsigned char*)(palette+(val&mask?1:0));
-	    res(x,y,2) = (T)*(col++);
-	    res(x,y,1) = (T)*(col++);
-	    res(x,y,0) = (T)*(col++);
-	    mask = cimg::ror(mask);
-	  } ptrs+=align; }
-      } break;
-      case 4: { // 16 colors
-	for (int y=res.height-1; y>=0; y--) { 
-	  unsigned char mask = 0xF0, val = 0;
-	  cimg_mapX(res,x) {
-	    if (mask==0xF0) val = *(ptrs++);
-	    const unsigned char color = (mask<16)?(val&mask):((val&mask)>>4);
-	    unsigned char *col = (unsigned char*)(palette+color);
-	    res(x,y,2) = (T)*(col++);
-	    res(x,y,1) = (T)*(col++);
-	    res(x,y,0) = (T)*(col++);
-	    mask = cimg::ror(mask,4);
-	  } ptrs+=align; }
-      } break;
-      case 8: { //  256 colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  const unsigned char *col = (unsigned char*)(palette+*(ptrs++));
-	  res(x,y,2) = (T)*(col++);
-	  res(x,y,1) = (T)*(col++);
-	  res(x,y,0) = (T)*(col++);
-	} ptrs+=align; }
-      } break;
-      case 16: { // 16 bits colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  const unsigned char c1 = *(ptrs++), c2 = *(ptrs++);
-	  const unsigned short col = c1+(c2<<8);
-	  res(x,y,2) = (T)(col&0x1F);
-	  res(x,y,1) = (T)((col>>5)&0x1F);
-	  res(x,y,0) = (T)((col>>10)&0x1F);
-	} ptrs+=align; }
-      } break;	
-      case 24: { // 24 bits colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  res(x,y,2) = (T)*(ptrs++);
-	  res(x,y,1) = (T)*(ptrs++);
-	  res(x,y,0) = (T)*(ptrs++);
-	} ptrs+=align; }
-      } break;
-      case 32: { // 32 bits colors
-	for (int y=res.height-1; y>=0; y--) { cimg_mapX(res,x) {
-	  res(x,y,2) = (T)*(ptrs++);
-	  res(x,y,1) = (T)*(ptrs++);
-	  res(x,y,0) = (T)*(ptrs++);
-	  ptrs++;
-	} ptrs+=align; }
-      } break;
-      }
-
-      if (palette) delete[] palette;
-      if (dy<0) res.flip('y');
-      return res;
-    }
-
-
-    //! Load an image from an INRIMAGE-4 file.
-#define cimg_load_inr_case(Tf,sign,pixsize,Ts)                            \
-  if (!loaded && fopt[6]==pixsize && fopt[4]==Tf && fopt[5]==sign) {      \
-      Ts *xval, *val = new Ts[fopt[0]*fopt[3]];                           \
-      cimg_mapYZ(dest,y,z) {                                              \
-          cimg::fread(val,pixsize/8,fopt[0]*fopt[3],file);                \
-          if (fopt[7]!=endian) cimg::endian_swap(val,fopt[0]*fopt[3]);    \
-          xval = val; cimg_mapX(dest,x) cimg_mapV(dest,k)                 \
-                          dest(x,y,z,k) = (T)*(xval++);                   \
-        }                                                                 \
-      delete[] val;                                                       \
-      loaded = true;                                                      \
-    }
-    
-    static void _load_inr(std::FILE *file,int out[8],float *voxsize=NULL) {
-      char item[1024],tmp1[64],tmp2[64];
-      out[0]=out[1]=out[2]=out[3]=out[5]=1; out[4]=out[6]=out[7]=-1;
-      std::fscanf(file,"%63s",item);
-      if(cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0) 
-	throw CImgIOException("CImg<%s>::load_inr() : File does not appear to be a valid INR file.\n"
-			      "(INRIMAGE-4 identifier not found)",pixel_type());
-      while (std::fscanf(file," %63[^\n]%*c",item)!=EOF && cimg::strncmp(item,"##}",3)) {
-        std::sscanf(item," XDIM%*[^0-9]%d",out);
-        std::sscanf(item," YDIM%*[^0-9]%d",out+1);
-        std::sscanf(item," ZDIM%*[^0-9]%d",out+2);
-        std::sscanf(item," VDIM%*[^0-9]%d",out+3);
-        std::sscanf(item," PIXSIZE%*[^0-9]%d",out+6);
-        if (voxsize) {
-          std::sscanf(item," VX%*[^0-9.eE+-]%f",voxsize);
-          std::sscanf(item," VY%*[^0-9.eE+-]%f",voxsize+1);
-          std::sscanf(item," VZ%*[^0-9.eE+-]%f",voxsize+2);
-        }
-        if (std::sscanf(item," CPU%*[ =]%s",tmp1)) out[7]=cimg::strncasecmp(tmp1,"sun",3)?0:1;
-        switch(std::sscanf(item," TYPE%*[ =]%s %s",tmp1,tmp2)) {
-        case 0: break;
-        case 2: out[5] = cimg::strncasecmp(tmp1,"unsigned",8)?1:0; std::strcpy(tmp1,tmp2);
-        case 1:
-          if (!cimg::strncasecmp(tmp1,"int",3)   || !cimg::strncasecmp(tmp1,"fixed",5))  out[4]=0;
-          if (!cimg::strncasecmp(tmp1,"float",5) || !cimg::strncasecmp(tmp1,"double",6)) out[4]=1;
-          if (!cimg::strncasecmp(tmp1,"packed",6))                                       out[4]=2;
-          if (out[4]>=0) break;
-        default: throw CImgIOException("cimg::inr_header_read() : Invalid TYPE '%s'",tmp2);
-        }
-      }
-      if(out[0]<0 || out[1]<0 || out[2]<0 || out[3]<0)
-        throw CImgIOException("CImg<%s>::load_inr() : Bad dimensions in .inr file = ( %d , %d , %d , %d )",
-                              pixel_type(),out[0],out[1],out[2],out[3]);
-      if(out[4]<0 || out[5]<0) throw CImgIOException("CImg<%s>::load_inr() : TYPE is not fully defined",pixel_type());
-      if(out[6]<0) throw CImgIOException("CImg<%s>::load_inr() : PIXSIZE is not fully defined",pixel_type());
-      if(out[7]<0) throw CImgIOException("CImg<%s>::load_inr() : Big/Little Endian coding type is not defined",pixel_type());
-    }
-    
-    static CImg load_inr(const char *filename, float *voxsize = NULL) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-	  int fopt[8], endian=cimg::endian()?1:0;
-      bool loaded = false;
-      if (voxsize) voxsize[0]=voxsize[1]=voxsize[2]=1;
-      _load_inr(file,fopt,voxsize);
-      CImg<T> dest = CImg<T>(fopt[0],fopt[1],fopt[2],fopt[3]);
-      cimg_load_inr_case(0,0,8, unsigned char);
-      cimg_load_inr_case(0,1,8, char);
-      cimg_load_inr_case(0,0,16,unsigned short);
-      cimg_load_inr_case(0,1,16,short);
-      cimg_load_inr_case(0,0,32,unsigned int);
-      cimg_load_inr_case(0,1,32,int);
-      cimg_load_inr_case(1,0,32,float);
-      cimg_load_inr_case(1,1,32,float);
-      cimg_load_inr_case(1,0,64,double);
-      cimg_load_inr_case(1,1,64,double);
-      if (!loaded) throw CImgIOException("CImg<%s>::load_inr() : File '%s', can't read images of the type specified in the file",
-					 pixel_type(),filename);
-      cimg::fclose(file);
-      return dest;
-    }
-   
-    //! Load an image from a PANDORE file
-
-#define cimg_load_pandore_case(nid,nbdim,nwidth,nheight,ndepth,ndim,stype)  \
-  case nid: {                                                         \
-    cimg::fread(dims,sizeof(unsigned int),nbdim,file);                \
-    if (endian) cimg::endian_swap(dims,nbdim);                        \
-    dest = CImg<T>(nwidth,nheight,ndepth,ndim);                       \
-    stype *buffer = new stype[dest.size()];                           \
-    cimg::fread(buffer,sizeof(stype),dest.size(),file);               \
-    if (endian) cimg::endian_swap(buffer,dest.size());                \
-    T *ptrd = dest.ptr();                                             \
-    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));               \
-    buffer-=dest.size();                                              \
-    delete[] buffer;                                                  \
-   }                                                                  \
-   break;
-    
-    static CImg load_pandore(const char *filename) {
-      std::FILE *file = cimg::fopen(filename,"rb");
-      typedef unsigned char uchar;
-      typedef unsigned short ushort;
-      typedef unsigned int uint;  
-      typedef unsigned long ulong; 
-      CImg dest;
-      char tmp[16];
-      cimg::fread(tmp,sizeof(char),12,file);
-      if (cimg::strncasecmp("PANDORE",tmp,7)) 
-	throw CImgIOException("CImg<%s>::load_pandore() : File '%s' does not appear to be a valid PANDORE file.\n"
-			      "(PANDORE identifier not found)",pixel_type(),filename);
-      unsigned int id,dims[8];
-      long ptbuf[4];
-      cimg::fread(&id,sizeof(int),1,file);
-      const bool endian = (id>255);
-      if (endian) cimg::endian_swap(id);
-      cimg::fread(tmp,sizeof(char),20,file);
-      switch (id) {
-	cimg_load_pandore_case(2,2,dims[1],1,1,1,uchar);
-	cimg_load_pandore_case(3,2,dims[1],1,1,1,long);
-	cimg_load_pandore_case(4,2,dims[1],1,1,1,float);
-	cimg_load_pandore_case(5,3,dims[2],dims[1],1,1,uchar);
-	cimg_load_pandore_case(6,3,dims[2],dims[1],1,1,long);
-	cimg_load_pandore_case(7,3,dims[2],dims[1],1,1,float);
-	cimg_load_pandore_case(8,4,dims[3],dims[2],dims[1],1,uchar);
-	cimg_load_pandore_case(9,4,dims[3],dims[2],dims[1],1,long);
-	cimg_load_pandore_case(10,4,dims[3],dims[2],dims[1],1,float);
-      case 11: { // Region 1D
-	cimg::fread(dims,sizeof(unsigned int),3,file);
-	if (endian) cimg::endian_swap(dims,3);
-	dest = CImg<T>(dims[1],1,1,1);
-	if (dims[2]<256) {
-	  unsigned char *buffer = new unsigned char[dest.size()];
-	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
-	  T *ptrd = dest.ptr();
-	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	  buffer-=dest.size();
-	  delete[] buffer;
-	} else {
-	  if (dims[2]<65536) {
-	    unsigned short *buffer = new unsigned short[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  } else {
-	    unsigned long *buffer = new unsigned long[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  }
-	}	
-      }
-	break;
-      case 12: { // Region 2D
-	cimg::fread(dims,sizeof(unsigned int),4,file);
-	if (endian) cimg::endian_swap(dims,4);
-	dest = CImg<T>(dims[2],dims[1],1,1);
-	if (dims[3]<256) {
-	  unsigned char *buffer = new unsigned char[dest.size()];
-	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
-	  T *ptrd = dest.ptr();
-	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	  buffer-=dest.size();
-	  delete[] buffer;
-	} else {
-	  if (dims[3]<65536) {
-	    unsigned short *buffer = new unsigned short[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  } else {
-	    unsigned long *buffer = new unsigned long[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  }
-	}	
-      }
-	break;
-      case 13: { // Region 3D
-	cimg::fread(dims,sizeof(unsigned int),5,file);
-	if (endian) cimg::endian_swap(dims,5);
-	dest = CImg<T>(dims[3],dims[2],dims[1],1);
-	if (dims[4]<256) {
-	  unsigned char *buffer = new unsigned char[dest.size()];
-	  cimg::fread(buffer,sizeof(unsigned char),dest.size(),file);
-	  T *ptrd = dest.ptr();
-	  cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	  buffer-=dest.size();
-	  delete[] buffer;
-	} else {
-	  if (dims[4]<65536) {
-	    unsigned short *buffer = new unsigned short[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned short),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  } else {
-	    unsigned long *buffer = new unsigned long[dest.size()];
-	    cimg::fread(buffer,sizeof(unsigned long),dest.size(),file);
-	    if (endian) cimg::endian_swap(buffer,dest.size());
-	    T *ptrd = dest.ptr();
-	    cimg_mapoff(dest,off) *(ptrd++) = (T)(*(buffer++));
-	    buffer-=dest.size();
-	    delete[] buffer;
-	  }
-	}	
-      }
-	break;
-	cimg_load_pandore_case(16,4,dims[2],dims[1],1,3,uchar);
-	cimg_load_pandore_case(17,4,dims[2],dims[1],1,3,long);
-	cimg_load_pandore_case(18,4,dims[2],dims[1],1,3,float);
-	cimg_load_pandore_case(19,5,dims[3],dims[2],dims[1],3,uchar);
-	cimg_load_pandore_case(20,5,dims[3],dims[2],dims[1],3,long);
-	cimg_load_pandore_case(21,5,dims[3],dims[2],dims[1],3,float);
-	cimg_load_pandore_case(22,2,dims[1],1,1,dims[0],uchar);
-	cimg_load_pandore_case(23,2,dims[1],1,1,dims[0],long);
-	cimg_load_pandore_case(24,2,dims[1],1,1,dims[0],ulong);
-	cimg_load_pandore_case(25,2,dims[1],1,1,dims[0],float);
-	cimg_load_pandore_case(26,3,dims[2],dims[1],1,dims[0],uchar);
-	cimg_load_pandore_case(27,3,dims[2],dims[1],1,dims[0],long);
-	cimg_load_pandore_case(28,3,dims[2],dims[1],1,dims[0],ulong);
-	cimg_load_pandore_case(29,3,dims[2],dims[1],1,dims[0],float);
-	cimg_load_pandore_case(30,4,dims[3],dims[2],dims[1],dims[0],uchar);
-	cimg_load_pandore_case(31,4,dims[3],dims[2],dims[1],dims[0],long);
-	cimg_load_pandore_case(32,4,dims[3],dims[2],dims[1],dims[0],ulong);
-	cimg_load_pandore_case(33,4,dims[3],dims[2],dims[1],dims[0],float);	
-      case 34: // Points 1D	
-	cimg::fread(ptbuf,sizeof(long),1,file);
-	if (endian) cimg::endian_swap(ptbuf,1);
-	dest = CImg<T>(1); dest[0]=(T)ptbuf[0];
-	break;
-      case 35: // Points 2D
-	cimg::fread(ptbuf,sizeof(long),2,file);
-	if (endian) cimg::endian_swap(ptbuf,2);
-	dest = CImg<T>(2); dest[0]=(T)ptbuf[1]; dest[1]=(T)ptbuf[0];
-	break;
-      case 36: // Points 3D
-	cimg::fread(ptbuf,sizeof(long),3,file);
-	if (endian) cimg::endian_swap(ptbuf,3);
-	dest = CImg<T>(3); dest[0]=(T)ptbuf[2]; dest[1]=(T)ptbuf[1]; dest[2]=(T)ptbuf[0];
-	break;
-      default:
-	throw CImgIOException("CImg<%s>::load_pandore() : File '%s', can't read images with ID_type=%d",pixel_type(),filename,id);
-      }
-      return dest;
-    }
-
-
-    //! Load an image from an ANALYZE7.5 file
-    static CImg load_analyze(const char *filename, float *voxsize = NULL) {
-      
-      // Open header and data files
-      std::FILE *file_header=NULL, *file=NULL;
-      char body[1024];
-      const char *ext = cimg::filename_split(filename,body);
-      if (!cimg::strcasecmp(ext,"hdr") || !cimg::strcasecmp(ext,"img")) {
-	std::sprintf(body+cimg::strlen(body),".hdr");
-	file_header = cimg::fopen(body,"rb");
-	std::sprintf(body+cimg::strlen(body)-3,"img");
-	file = cimg::fopen(body,"rb");
-      } else throw CImgIOException("CImg<%s>::load_analyze() : Cannot load filename '%s' as an analyze format",pixel_type(),filename);
-
-      // Read header
-      bool endian = false;
-      unsigned int header_size;
-      cimg::fread(&header_size,sizeof(int),1,file_header);
-      if (header_size>=4096) { endian = true; cimg::endian_swap(header_size); }
-      unsigned char *header = new unsigned char[header_size];
-      cimg::fread(header+sizeof(int),sizeof(char),header_size-sizeof(int),file_header);
-      cimg::fclose(file_header);
-      if (endian) {
-	cimg::endian_swap((short*)(header+40),5);
-        cimg::endian_swap((short*)(header+70),1);
-        cimg::endian_swap((short*)(header+72),1);
-        cimg::endian_swap((float*)(header+76),4);
-        cimg::endian_swap((float*)(header+112),1);
-      }
-      unsigned short *dim = (unsigned short*)(header+40), dimx=1, dimy=1, dimz=1, dimv=1;
-      cimg::warn(!dim[0],"CImg<%s>::load_analyze() : Specified image has zero dimensions.",pixel_type());
-      cimg::warn(dim[0]>4,"CImg<%s>::load_analyze() : Number of image dimension is %d, reading only the 4 first dimensions",
-		 pixel_type(),dim[0]);
-      if (dim[0]>=1) dimx = dim[1];
-      if (dim[0]>=2) dimy = dim[2];
-      if (dim[0]>=3) dimz = dim[3];
-      if (dim[0]>=4) dimv = dim[4];
-      
-      float scalefactor = *(float*)(header+112); if (scalefactor==0) scalefactor=1;
-      const unsigned short datatype = *(short*)(header+70);
-      if (voxsize) { const float *vsize = (float*)(header+76); voxsize[0] = vsize[1]; voxsize[1] = vsize[2]; voxsize[2] = vsize[3]; }
-      delete[] header;
-
-      // Read pixel data
-      CImg dest(dimx,dimy,dimz,dimv);
-      switch (datatype) {
-      case 2: {
-	unsigned char *buffer = new unsigned char[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(unsigned char),dimx*dimy*dimz*dimv,file);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 4: {
-	short *buffer = new short[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(short),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 8: {
-	int *buffer = new int[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(int),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 16: {
-	float *buffer = new float[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(float),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      case 64: {
-	double *buffer = new double[dimx*dimy*dimz*dimv];
-	cimg::fread(buffer,sizeof(double),dimx*dimy*dimz*dimv,file);
-	if (endian) cimg::endian_swap(buffer,dimx*dimy*dimz*dimv);
-	cimg_mapoff(dest,off) dest.data[off] = (T)(buffer[off]*scalefactor);
-	delete[] buffer;
-      } break;
-      default: throw CImgIOException("CImg<%s>::load_analyze() : Cannot read images width 'datatype = %d'",pixel_type(),datatype);
-      }
-      cimg::fclose(file);
-      return dest;
-    }
-
-    //! Load an image from a RAW file
-    static CImg load_raw(const char *filename,const char axe='v',const char align='p') { 
-      return CImgl<T>(filename).get_append(axe,align); 
-    }
-
-    //! Function that loads the image for other file formats that are not natively handled by CImg, using the tool 'convert' from the ImageMagick package.\n
-    //! This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install the ImageMagick package in order to get
-    //! this function working properly (see http://www.imagemagick.org ).
-    static CImg load_convert(const char *filename) {
-      srand((unsigned int)::time(NULL));
-      char command[512], filetmp[512];
-      std::sprintf(filetmp,"%s/CImg%.4d.ppm",cimg::temporary_path(),::rand()%10000);
-      std::sprintf(command,"\"%s\" \"%s\" %s",cimg::convert_path(),filename,filetmp);
-      cimg::system(command);
-      std::FILE *file = std::fopen(filetmp,"rb");
-      if (!file) {
-        std::fclose(cimg::fopen(filename,"r"));
-        throw CImgIOException("CImg<%s>::load_convert() : Failed to open image '%s' with 'convert'.\n"
-			      "Check that you have installed the ImageMagick package in a standart directory.",
-			      pixel_type(),filename);
-      } else cimg::fclose(file);
-      const CImg dest(filetmp);
-      std::remove(filetmp);
-      return dest;
-    }
-
-
-    //! Save the image as a file. 
-    /**
-       The used file format is defined by the file extension in the filename \p filename.\n
-       Parameter \p number can be used to add a 6-digit number to the filename before saving.\n
-       If \p normalize is true, a normalized version of the image (between [0,255]) is saved.
-    **/
-    const CImg& save(const char *filename,const int number=-1) const {
-      cimg_test(*this,"CImg<T>::save");
-      const char *ext = cimg::filename_split(filename);
-      char nfilename[1024];
-      if (number>=0) filename = cimg::file_number(filename,number,6,nfilename);
-      if (!cimg::strcasecmp(ext,"asc")) return save_ascii(filename);
-      if (!cimg::strcasecmp(ext,"dlm")) return save_dlm(filename);
-      if (!cimg::strcasecmp(ext,"inr")) return save_inr(filename);
-      if (!cimg::strcasecmp(ext,"hdr")) return save_analyze(filename);
-      if (!cimg::strcasecmp(ext,"pan")) return save_pandore(filename);
-      if (!cimg::strcasecmp(ext,"bmp")) return save_bmp(filename);
-      if (!cimg::strcasecmp(ext,"raw") || ext[0]=='\0') return save_raw(filename);
-      if (!cimg::strcasecmp(ext,"pgm") || 
-	  !cimg::strcasecmp(ext,"ppm") || 
-	  !cimg::strcasecmp(ext,"pnm")) return save_pnm(filename);
-      return save_convert(filename);
-    }
-  
-    //! Save the image as an ASCII file.
-    const CImg& save_ascii(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_ascii");
-      std::FILE *file = cimg::fopen(filename,"w");
-      std::fprintf(file,"%u %u %u %u\n",width,height,depth,dim);
-      const T* ptrs = data;
-      cimg_mapYZV(*this,y,z,v) {
-	cimg_mapX(*this,x) std::fprintf(file,"%g ",(double)*(ptrs++));
-	std::fputc('\n',file);
-      }
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a DLM file.
-    const CImg& save_dlm(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_dlm");
-      std::FILE *file = cimg::fopen(filename,"w");
-      const T* ptrs = data;
-      cimg_mapYZV(*this,y,z,v) {
-	cimg_mapX(*this,x) std::fprintf(file,"%g%s",(double)*(ptrs++),(x==(int)width-1)?"":",");
-	std::fputc('\n',file);
-      }
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a PNM file.
-    const CImg& save_pnm(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_pnm");
-      const char *ext = cimg::filename_split(filename);
-      if (dim>1 && !cimg::strcasecmp(ext,"pgm")) { get_norm_pointwise().normalize(0,255).save_pnm(filename); return *this; }
-      std::FILE *file = cimg::fopen(filename,"wb");
-      const T 
-	*ptrR = ptr(0,0,0,0),
-	*ptrG = (dim>=2)?ptr(0,0,0,1):ptrR,
-	*ptrB = (dim>=3)?ptr(0,0,0,2):ptrR;
-      const unsigned int buf_size = width*height*(dim==1?1:3);
-      unsigned char *ptrd = new unsigned char[buf_size], *xptrd = ptrd;
-      switch(dim) {
-      case 1: { // Binary PGM
-	std::fprintf(file,"P5\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n255\n",width,height,depth,dim,width,height);
-	cimg_mapXY(*this,x,y) *(xptrd++) = (unsigned char)*(ptrR++);
-      } break;
-      default: { // Binary PPM
-	std::fprintf(file,"P6\n# CREATOR: CImg : Original size=%ux%ux%ux%u\n%u %u\n255\n",width,height,depth,dim,width,height);
-	cimg_mapXY(*this,x,y) {
-	  *(xptrd++) = (unsigned char)*(ptrR++);
-	  *(xptrd++) = (unsigned char)*(ptrG++);
-	  *(xptrd++) = (unsigned char)*(ptrB++);
-	}
-      } break;
-      }
-      cimg::fwrite(ptrd,sizeof(unsigned char),buf_size,file);
-      cimg::fclose(file);
-      delete[] ptrd;
-      return *this;
-    }
-
-    //! Save the image as an ANALYZE7.5 file.
-    const CImg& save_analyze(const char *filename,const float *const voxsize=NULL) const {
-      cimg_test(*this,"CImg<T>::save_analyze");
-      std::FILE *file;
-      char header[348],hname[1024],iname[1024];
-      const char *ext = cimg::filename_split(filename);
-      short datatype=-1;
-      std::memset(header,0,348);
-      if (!ext[0]) { std::sprintf(hname,"%s.hdr",filename); std::sprintf(iname,"%s.img",filename); }
-      if (!cimg::strncasecmp(ext,"hdr",3)) { 
-	std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(iname+cimg::strlen(iname)-3,"img"); 
-      }
-      if (!cimg::strncasecmp(ext,"img",3)) {
-	std::strcpy(hname,filename); std::strcpy(iname,filename); std::sprintf(hname+cimg::strlen(iname)-3,"hdr"); 
-      }
-      ((int*)(header))[0] = 348;
-      std::sprintf(header+4,"CImg");
-      std::sprintf(header+14," ");
-      ((short*)(header+36))[0] = 4096;
-      ((char*)(header+38))[0] = 114;
-      ((short*)(header+40))[0] = 4;
-      ((short*)(header+40))[1] = width;
-      ((short*)(header+40))[2] = height;
-      ((short*)(header+40))[3] = depth;
-      ((short*)(header+40))[4] = dim;
-      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  datatype = 2;
-      if (!cimg::strcasecmp(pixel_type(),"short"))          datatype = 4;
-      if (!cimg::strcasecmp(pixel_type(),"int"))            datatype = 8;
-      if (!cimg::strcasecmp(pixel_type(),"float"))          datatype = 16;
-      if (!cimg::strcasecmp(pixel_type(),"double"))         datatype = 64;
-      ((short*)(header+70))[0] = datatype;
-      ((short*)(header+72))[0] = sizeof(T);
-      ((float*)(header+112))[0] = 1;
-      ((float*)(header+76))[0] = 0;
-      if (voxsize) {
-        ((float*)(header+76))[1] = voxsize[0];
-        ((float*)(header+76))[2] = voxsize[1];
-        ((float*)(header+76))[3] = voxsize[2];
-      } else ((float*)(header+76))[1] = ((float*)(header+76))[2] = ((float*)(header+76))[3] = 1;
-      file = cimg::fopen(hname,"wb");
-      cimg::fwrite(header,sizeof(char),348,file);
-      cimg::fclose(file);
-      file = cimg::fopen(iname,"wb");
-      cimg::fwrite(data,sizeof(T),size(),file);
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a RAW file
-    const CImg& save_raw(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_raw");      
-      CImgl<T> shared(1);
-      shared[0].width = width;
-      shared[0].height = height;
-      shared[0].depth = depth;
-      shared[0].dim = dim;
-      shared[0].data = data;
-      shared.save_raw(filename);
-      shared[0].width = shared[0].height = shared[0].depth = shared[0].dim = 0;
-      shared[0].data = NULL;
-      return *this;
-    }
- 
-    //! Save the image using ImageMagick's convert.    
-    /** Function that saves the image for other file formats that are not natively handled by CImg,
-	using the tool 'convert' from the ImageMagick package.\n
-	This is the case for all compressed image formats (GIF,PNG,JPG,TIF,...). You need to install 
-	the ImageMagick package in order to get
-	this function working properly (see http://www.imagemagick.org ).
-    **/
-    const CImg& save_convert(const char *filename) const {
-      cimg_test(*this,"CImg<T>::save_convert");
-      srand((unsigned int)::time(NULL));
-      char command[512],filetmp[512];
-      std::sprintf(filetmp,"%s/CImg%.4d.ppm",cimg::temporary_path(),::rand()%10000);
-      save_pnm(filetmp);
-      std::sprintf(command,"\"%s\" -quality 100%% \"%s\" %s",cimg::convert_path(),filetmp,filename);
-      cimg::system(command);
-      std::FILE *file = std::fopen(filename,"rb");
-      if (!file) throw CImgIOException("CImg<%s>::save_convert() : Failed to save image '%s' with 'convert'.\n"
-				       "Check that you have installed the ImageMagick package in a standart directory.",
-				       pixel_type(),filename);
-      if (file) cimg::fclose(file);
-      std::remove(filetmp);
-      return *this;
-    }
-  
-    //! Save the image as an INRIMAGE-4 file.
-    const CImg& save_inr(const char *filename,const float *const voxsize = NULL) const {
-      cimg_test(*this,"CImg<T>::save_inr");
-      int inrpixsize=-1;
-      const char *inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0";
-      if (!cimg::strcasecmp(pixel_type(),"unsigned char"))  { inrtype = "unsigned fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
-      if (!cimg::strcasecmp(pixel_type(),"char"))           { inrtype = "fixed\nPIXSIZE=8 bits\nSCALE=2**0"; inrpixsize = 1; }
-      if (!cimg::strcasecmp(pixel_type(),"unsigned short")) { inrtype = "unsigned fixed\nPIXSIZE=16 bits\nSCALE=2**0";inrpixsize = 2; }
-      if (!cimg::strcasecmp(pixel_type(),"short"))          { inrtype = "fixed\nPIXSIZE=16 bits\nSCALE=2**0"; inrpixsize = 2; }
-      if (!cimg::strcasecmp(pixel_type(),"unsigned int"))   { inrtype = "unsigned fixed\nPIXSIZE=32 bits\nSCALE=2**0";inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"int"))            { inrtype = "fixed\nPIXSIZE=32 bits\nSCALE=2**0"; inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"float"))          { inrtype = "float\nPIXSIZE=32 bits"; inrpixsize = 4; }
-      if (!cimg::strcasecmp(pixel_type(),"double"))         { inrtype = "float\nPIXSIZE=64 bits"; inrpixsize = 8; }
-      if (inrpixsize<=0) throw CImgIOException("CImg<%s>::save_inr() : Don't know how to save images of '%s'",pixel_type(),pixel_type());
-      std::FILE *file = cimg::fopen(filename,"wb");
-      char header[257];      
-      int err = std::sprintf(header,"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",width,height,depth,dim);
-      if (voxsize) err += std::sprintf(header+err,"VX=%g\nVY=%g\nVZ=%g\n",voxsize[0],voxsize[1],voxsize[2]);
-      err += std::sprintf(header+err,"TYPE=%s\nCPU=%s\n",inrtype,cimg::endian()?"sun":"decm");
-      std::memset(header+err,'\n',252-err);
-      std::memcpy(header+252,"##}\n",4);
-      cimg::fwrite(header,sizeof(char),256,file);
-      cimg_mapXYZ(*this,x,y,z) cimg_mapV(*this,k) cimg::fwrite(&((*this)(x,y,z,k)),inrpixsize,1,file);
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a PANDORE-5 file
-
-#define cimg_save_pandore_case(sy,sz,sv,stype,id)                           \
-   if (!saved && (sy?(sy==height):true) && (sz?(sz==depth):true) && (sv?(sv==dim):true) && !strcmp(stype,pixel_type())) { \
-      unsigned int *iheader = (unsigned int*)(header+12);                   \
-      nbdims = _save_pandore_header_length((*iheader=id),dims);             \
-      cimg::fwrite(header,sizeof(unsigned char),36,file);                   \
-      cimg::fwrite(dims,sizeof(unsigned int),nbdims,file);                  \
-      if (id==2 || id==5 || id==8 || id==16 || id==19 || id==22 || id==26 || id==30) { \
-	unsigned char *buffer = new unsigned char[size()];                  \
-	T *ptrs = ptr();                                                    \
-	cimg_mapoff(*this,off) *(buffer++)=(unsigned char)(*(ptrs++));      \
-	buffer-=size();                                                     \
-	cimg::fwrite(buffer,sizeof(unsigned char),size(),file);             \
-	delete[] buffer;                                                    \
-      }                                                                     \
-      if (id==3 || id==6 || id==9 || id==17 || id==20 || id==23 || id==27 || id==31) { \
-	unsigned long *buffer = new unsigned long[size()];                  \
-	T *ptrs = ptr();                                                    \
-	cimg_mapoff(*this,off) *(buffer++)=(long)(*(ptrs++));               \
-	buffer-=size();                                                     \
-	cimg::fwrite(buffer,sizeof(long),size(),file);                      \
-	delete[] buffer;                                                    \
-      }                                                                     \
-      if (id==4 || id==7 || id==10 || id==18 || id==21 || id==25 || id==29 || id==33) { \
-	float *buffer = new float[size()];                                  \
-	T *ptrs = ptr();                                                    \
-	cimg_mapoff(*this,off) *(buffer++)=(float)(*(ptrs++));              \
-	buffer-=size();                                                     \
-	cimg::fwrite(buffer,sizeof(float),size(),file);                     \
-	delete[] buffer;                                                    \
-      }                                                                     \
-      saved = true;                                                         \
-    }
-
-    unsigned int _save_pandore_header_length(unsigned int id,unsigned int *dims) const {
-      unsigned int nbdims=0;
-      if (id==2 || id==3 || id==4)    { dims[0]=1; dims[1]=width; nbdims=2; }
-      if (id==5 || id==6 || id==7)    { dims[0]=1; dims[1]=height; dims[2]=width; nbdims=3; }
-      if (id==8 || id==9 || id==10)   { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
-      if (id==16 || id==17 || id==18) { dims[0]=3; dims[1]=height; dims[2]=width; dims[3]=1; nbdims=4; }
-      if (id==19 || id==20 || id==21) { dims[0]=3; dims[1]=depth; dims[2]=height; dims[3]=width; dims[4]=0; nbdims=5; }
-      if (id==22 || id==23 || id==25) { dims[0]=dim; dims[1]=width; nbdims=2; }
-      if (id==26 || id==27 || id==29) { dims[0]=dim; dims[1]=height; dims[2]=width; nbdims=3; }
-      if (id==30 || id==31 || id==33) { dims[0]=dim; dims[1]=depth; dims[2]=height; dims[3]=width; nbdims=4; }
-      return nbdims;
-    }    
-
-    const CImg& save_pandore(const char* filename) const {
-      cimg_test(*this,"CImg<T>::save_pandore");
-      std::FILE *file = cimg::fopen(filename,"wb");
-      unsigned char header[36] = { 'P','A','N','D','O','R','E','0','4',0,0,0,
-				   0,0,0,0,'C','I','m','g',0,0,0,0,0,
-				   '2','0','0','0','/','0','1','/','0','1',
-				   0 };
-      unsigned int nbdims,dims[5];
-      bool saved=false;
-      cimg_save_pandore_case(1,1,1,"unsigned char",2);
-      cimg_save_pandore_case(1,1,1,"char",3);
-      cimg_save_pandore_case(1,1,1,"short",3);
-      cimg_save_pandore_case(1,1,1,"unsigned short",3);
-      cimg_save_pandore_case(1,1,1,"unsigned int",3);
-      cimg_save_pandore_case(1,1,1,"int",3);
-      cimg_save_pandore_case(1,1,1,"unsigned long",4);
-      cimg_save_pandore_case(1,1,1,"long",3);
-      cimg_save_pandore_case(1,1,1,"float",4);
-      cimg_save_pandore_case(1,1,1,"double",4);
- 
-      cimg_save_pandore_case(0,1,1,"unsigned char",5);
-      cimg_save_pandore_case(0,1,1,"char",6);
-      cimg_save_pandore_case(0,1,1,"short",6);
-      cimg_save_pandore_case(0,1,1,"unsigned short",6);
-      cimg_save_pandore_case(0,1,1,"unsigned int",6);
-      cimg_save_pandore_case(0,1,1,"int",6);
-      cimg_save_pandore_case(0,1,1,"unsigned long",7);
-      cimg_save_pandore_case(0,1,1,"long",6);
-      cimg_save_pandore_case(0,1,1,"float",7);
-      cimg_save_pandore_case(0,1,1,"double",7);
-
-      cimg_save_pandore_case(0,0,1,"unsigned char",8);
-      cimg_save_pandore_case(0,0,1,"char",9);
-      cimg_save_pandore_case(0,0,1,"short",9);
-      cimg_save_pandore_case(0,0,1,"unsigned short",9);
-      cimg_save_pandore_case(0,0,1,"unsigned int",9);
-      cimg_save_pandore_case(0,0,1,"int",9);
-      cimg_save_pandore_case(0,0,1,"unsigned long",10);
-      cimg_save_pandore_case(0,0,1,"long",9);
-      cimg_save_pandore_case(0,0,1,"float",10);
-      cimg_save_pandore_case(0,0,1,"double",10);
-      
-      cimg_save_pandore_case(0,1,3,"unsigned char",16);
-      cimg_save_pandore_case(0,1,3,"char",17);
-      cimg_save_pandore_case(0,1,3,"short",17);
-      cimg_save_pandore_case(0,1,3,"unsigned short",17);
-      cimg_save_pandore_case(0,1,3,"unsigned int",17);
-      cimg_save_pandore_case(0,1,3,"int",17);
-      cimg_save_pandore_case(0,1,3,"unsigned long",18);
-      cimg_save_pandore_case(0,1,3,"long",17);
-      cimg_save_pandore_case(0,1,3,"float",18);
-      cimg_save_pandore_case(0,1,3,"double",18);
-
-      cimg_save_pandore_case(0,0,3,"unsigned char",19);
-      cimg_save_pandore_case(0,0,3,"char",20);
-      cimg_save_pandore_case(0,0,3,"short",20);
-      cimg_save_pandore_case(0,0,3,"unsigned short",20);
-      cimg_save_pandore_case(0,0,3,"unsigned int",20);
-      cimg_save_pandore_case(0,0,3,"int",20);
-      cimg_save_pandore_case(0,0,3,"unsigned long",21);
-      cimg_save_pandore_case(0,0,3,"long",20);
-      cimg_save_pandore_case(0,0,3,"float",21);
-      cimg_save_pandore_case(0,0,3,"double",21);
-     
-      cimg_save_pandore_case(1,1,0,"unsigned char",22);
-      cimg_save_pandore_case(1,1,0,"char",23);
-      cimg_save_pandore_case(1,1,0,"short",23);
-      cimg_save_pandore_case(1,1,0,"unsigned short",23);
-      cimg_save_pandore_case(1,1,0,"unsigned int",23);
-      cimg_save_pandore_case(1,1,0,"int",23);
-      cimg_save_pandore_case(1,1,0,"unsigned long",25);
-      cimg_save_pandore_case(1,1,0,"long",23);
-      cimg_save_pandore_case(1,1,0,"float",25);
-      cimg_save_pandore_case(1,1,0,"double",25);
- 
-      cimg_save_pandore_case(0,1,0,"unsigned char",26);
-      cimg_save_pandore_case(0,1,0,"char",27);
-      cimg_save_pandore_case(0,1,0,"short",27);
-      cimg_save_pandore_case(0,1,0,"unsigned short",27);
-      cimg_save_pandore_case(0,1,0,"unsigned int",27);
-      cimg_save_pandore_case(0,1,0,"int",27);
-      cimg_save_pandore_case(0,1,0,"unsigned long",29);
-      cimg_save_pandore_case(0,1,0,"long",27);
-      cimg_save_pandore_case(0,1,0,"float",29);
-      cimg_save_pandore_case(0,1,0,"double",29);
-
-      cimg_save_pandore_case(0,0,0,"unsigned char",30);
-      cimg_save_pandore_case(0,0,0,"char",31);
-      cimg_save_pandore_case(0,0,0,"short",31);
-      cimg_save_pandore_case(0,0,0,"unsigned short",31);
-      cimg_save_pandore_case(0,0,0,"unsigned int",31);
-      cimg_save_pandore_case(0,0,0,"int",31);
-      cimg_save_pandore_case(0,0,0,"unsigned long",33);
-      cimg_save_pandore_case(0,0,0,"long",31);
-      cimg_save_pandore_case(0,0,0,"float",33);
-      cimg_save_pandore_case(0,0,0,"double",33);
-
-      cimg::fclose(file);
-      return *this;
-    }
-
-    //! Save the image as a BMP file
-    const CImg& save_bmp(const char* filename) const {
-      cimg_test(*this,"CImg<T>::save_bmp");
-      std::FILE *file = cimg::fopen(filename,"wb");
-
-      unsigned char header[54]={0}, align_buf[4]={0};
-      const unsigned int 
-	align     = (4-(3*width)%4)%4,
-	buf_size  = (3*width+align)*dimy(),
-	file_size = 54+buf_size;
-      header[0] = 'B'; header[1] = 'M';
-      header[0x02]=file_size&0xFF; header[0x03]=(file_size>>8)&0xFF;
-      header[0x04]=(file_size>>16)&0xFF; header[0x05]=(file_size>>24)&0xFF;
-      header[0x0A]=0x36;
-      header[0x0E]=0x28;
-      header[0x12]=width&0xFF; header[0x13]=(width>>8)&0xFF;
-      header[0x14]=(width>>16)&0xFF; header[0x15]=(width>>24)&0xFF;
-      header[0x16]=height&0xFF; header[0x17]=(height>>8)&0xFF;
-      header[0x18]=(height>>16)&0xFF; header[0x19]=(height>>24)&0xFF;
-      header[0x1A]=1;  header[0x1B]=0;
-      header[0x1C]=24; header[0x1D]=0;
-      header[0x22]=buf_size&0xFF; header[0x23]=(buf_size>>8)&0xFF;
-      header[0x24]=(buf_size>>16)&0xFF; header[0x25]=(buf_size>>24)&0xFF;
-      header[0x27]=0x1; header[0x2B]=0x1;
-      cimg::fwrite(header,sizeof(unsigned char),54,file);
-
-      const T
-	*pR = ptr(0,height-1,0,0),
-	*pG = (dim>=2)?ptr(0,height-1,0,1):pR, 
-	*pB = (dim>=3)?ptr(0,height-1,0,2):pR;
-
-      cimg_mapY(*this,y) {
-	cimg_mapX(*this,x) {
-	  std::fputc((unsigned char)(*(pB++)),file);
-	  std::fputc((unsigned char)(*(pG++)),file);
-	  std::fputc((unsigned char)(*(pR++)),file);
-	}
-	std::fwrite(align_buf,sizeof(unsigned char),align,file);
-	pR-=2*width; pG-=2*width; pB-=2*width;	
-      }      
-      cimg::fclose(file);
-      return *this;
-    }
-
-    
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Other functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    CImg& swap(CImg& img) {
-      cimg::swap(width,img.width);
-      cimg::swap(height,img.height);
-      cimg::swap(depth,img.depth);
-      cimg::swap(dim,img.dim);
-      cimg::swap(data,img.data);
-      return img;
-    }
-
-#ifdef cimg_plugin
-#include cimg_plugin
-#endif
-    
-    //@}
-  };
-
-
-  /*-------------------------------------------------------
-    
-
-
-
-  Definition of the CImgl<> structure
-
-
-
-
-  ------------------------------------------------------*/
-
-  //! This class represents list of images CImg<T>.
-  template<typename T> struct CImgl {       
-    //! This variable represents the number of images in the image list.
-    /**
-       \note if \c size==0, the image list is empty.
-    **/
-    unsigned int size;
-    
-    //! This variable represents a pointer to the first \c CImg<T> image of the list.
-    /**
-       \note the images are stored continuously in memory.
-       \note If the list is empty, \c data=NULL.
-    **/
-    CImg<T> *data;                      //!< Pointer to the first image of the image list.
-    
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Constructors - Destructor - Copy
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Return a string describing the type of the image pixels in the list (template parameter \p T).
-    static const char* pixel_type() { T val; return cimg::get_type(val); }
-    
-    //! Create a list of \p n new images, each having size (\p width,\p height,\p depth,\p dim).
-    CImgl(const unsigned int n=0,const unsigned int width=0,const unsigned int height=1,
-	  const unsigned int depth=1, const unsigned int dim=1):size(n) {
-      if (n) {
-	data = new CImg<T>[(n/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l]=CImg<T>(width,height,depth,dim);
-      } else data = NULL;
-    }
-    
-    // ! Create a list of \p n copy of the input image.
-    template<typename t> CImgl(const unsigned int n, const CImg<t>& img):size(n) {
-      if (n) {
-	data = new CImg<T>[(n/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l]=img;
-      } else data = NULL;
-    }
-    
-    //! Copy constructor.
-    template<typename t> CImgl(const CImgl<t>& list):size(list.size) {
-      if (size) {
-	data = new CImg<T>[(size/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l] = list[l];
-      } else data = NULL;
-    }
-    CImgl(const CImgl<T>& list):size(list.size) {
-      if (size>0) {
-	data = new CImg<T>[(size/cimg::lblock+1)*cimg::lblock];
-	cimgl_map(*this,l) data[l] = list[l];
-      } else data = NULL;
-    }
-
-    //! Create a list by loading a file.
-    CImgl(const char* filename):size(0),data(NULL) { load(filename).swap(*this); }
-    
-    //! Create a list from a single image \p img.
-    CImgl(const CImg<T>& img):size(0),data(NULL) { CImgl<T>(1,img).swap(*this); }
-
-    //! Create a list from two images \p img1 and \p img2 (images are copied).
-    CImgl(const CImg<T>& img1,const CImg<T>& img2):size(2) {
-      data = new CImg<T>[cimg::lblock];
-      data[0] = img1;
-      data[1] = img2;
-    }
-
-    //! Create a list from three images \p img1,\p img2 and \p img3 (images are copied).
-    CImgl(const CImg<T>& img1,const CImg<T>& img2,const CImg<T>& img3):size(3) {
-      data = new CImg<T>[cimg::lblock];
-      data[0] = img1;
-      data[1] = img2;
-      data[2] = img3;
-    }
-
-    //! Create a list from four images \p img1,\p img2,\p img3 and \p img4 (images are copied).
-    CImgl(const CImg<T>& img1,const CImg<T>& img2,const CImg<T>& img3,const CImg<T>& img4):size(4) {
-      data = new CImg<T>[cimg::lblock];
-      data[0] = img1;
-      data[1] = img2;
-      data[2] = img3;
-      data[3] = img4;
-    }
-    
-    //! Copy a list into another one.
-    template<typename t> CImgl& operator=(const CImgl<t>& list) { return CImgl<T>(list).swap(*this); }
-    CImgl& operator=(const CImgl<T>& list) { if (&list==this) return *this; return CImgl<T>(list).swap(*this); }
-    
-    //! Destructor
-    ~CImgl() { if (data) delete[] data; }
-    
-    //! Empty list
-    CImgl& empty() { return CImgl<T>().swap(*this); }
-    
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name Arithmetics operators
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Add each image of the current list with the corresponding image in the list \p list.
-    template<typename t> CImgl& operator+=(const CImgl<t>& list) {
-      const unsigned int sizemax = min(size,list.size);
-      for (unsigned int l=0; l<sizemax; l++) (*this)[l]+=list[l];
-      return *this;
-    }
-    
-    //! Subtract each image of the current list with the corresponding image in the list \p list.
-    template<typename t> CImgl& operator-=(const CImgl<t>& list) {
-      const unsigned int sizemax = min(size,list.size);
-      for (unsigned int l=0; l<sizemax; l++) (*this)[l]-=list[l];
-      return *this;
-    }
-    
-    //! Add each image of the current list with a value \p val.
-    CImgl& operator+=(const T& val) { cimgl_map(*this,l) (*this)[l]+=val; return *this; }
-    
-    //! Substract each image of the current list with a value \p val.
-    CImgl& operator-=(const T& val) { cimgl_map(*this,l) (*this)[l]-=val; return *this; }
-    
-    //! Multiply each image of the current list by a value \p val.
-    CImgl& operator*=(const double val) { cimgl_map(*this,l) (*this)[l]*=val; return *this; }
-    
-    //! Divide each image of the current list by a value \p val.
-    CImgl& operator/=(const double val) { cimgl_map(*this,l) (*this)[l]/=val; return *this; }
-    
-    //! Return a new image list corresponding to the addition of each image of the current list with a value \p val.
-    CImgl operator+(const T& val) const { return CImgl<T>(*this)+=val;  }
-    
-    //! Return a new image list corresponding to the multiplication of each image of the current list by a value \p val.
-    CImgl operator*(const double val) const { return CImgl<T>(*this)*=val;  }
-    
-    //! Return a new image list corresponding to the substraction of each image of the current list with a value \p val.
-    CImgl operator-(const T& val) const { return CImgl<T>(*this)-=val;  }
-    
-    //! Return a new image list corresponding to the division of each image of the current list by a value \p val.
-    CImgl operator/(const double val) const { return CImgl<T>(*this)/=val;  }
-    
-    //! Return a new image list corresponding to the addition of each image of the current list with the corresponding image in the list \p list.
-    CImgl operator+(const CImgl& list) const { return CImgl<T>(*this)+=list; }
-
-    //! Return a new image list corresponding to the substraction of each image of the current list with the corresponding image in the list \p list.
-    CImgl operator-(const CImgl& list) const { return CImgl<T>(*this)-=list; }
-    
-    //! Return a new image list corresponding to the addition of each image of the current list with a value \p val;
-    friend CImgl operator+(const T& val, const CImgl& list) { return CImgl<T>(list)+=val; }
-    
-    //! Return a new image list corresponding to the scalar multiplication of each image of the current list by a value \p val.
-    friend CImgl operator*(const double val, const CImgl& list) { return CImgl<T>(list)*=val; }
-  
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name List operations
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Return a reference to the i-th element of the image list.
-    CImg<T>& operator[](const unsigned int pos) const {
-#if cimg_debug>1
-      if (pos>=size) {
-	cimg::warn(true,"CImgl<%s>::operator[] : bad list position %u, in a list of %u images",pixel_type(),pos,size);
-	return *data;
-      }
-#endif
-      return data[pos];
-    }
-    
-    //! Equivalent to CImgl<T>::operator[]
-    CImg<T>& operator()(const unsigned int pos) const { return (*this)[pos]; }
-    
-    //! Insert a copy of the image \p img into the current image list, at position \p pos.
-    CImgl& insert(const CImg<T>& img,const unsigned int pos) {
-      if (pos>size) throw CImgArgumentException("CImgl<%s>::insert() : Can't insert at position %u into a list with %u elements",pixel_type(),pos,size);
-      CImg<T> *new_data = (!((++size)%cimg::lblock) || !data)?new CImg<T>[(size/cimg::lblock+1)*cimg::lblock]:NULL;
-      if (!data) { data=new_data; *data=img; }
-      else {
-	if (new_data) {
-	  std::memcpy(new_data,data,sizeof(CImg<T>)*pos);
-	  if (pos!=size-1) std::memcpy(new_data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-	  std::memset(data,0,sizeof(CImg<T>)*(size-1));
-	  delete[] data;
-	  data = new_data;
-	}
-	else if (pos!=size-1) memmove(data+pos+1,data+pos,sizeof(CImg<T>)*(size-1-pos));
-	data[pos].data = NULL;
-	data[pos] = img;
-      }
-      return *this;
-    }
-    
-    //! Append a copy of the image \p img at the current image list.
-    CImgl& insert(const CImg<T>& img) { return insert(img,size); }
-    
-    //! Insert a copy of the image list \p list into the current image list, starting from position \p pos.
-    CImgl& insert(const CImgl<T>& list,const unsigned int pos) { cimgl_map(list,l) insert(list[l],pos+l); return *this; }
-    
-    //! Append a copy of the image list \p list at the current image list.
-    CImgl& insert(const CImgl<T>& list) { return insert(list,size); }
-    
-    //! Remove the image at position \p pos from the image list.
-    CImgl& remove(const unsigned int pos) {
-      if (pos>=size) { 
-	cimg::warn(true,"CImgl<%s>::remove() : Can't remove an image from a list (%p,%u), at position %u",pixel_type(),data,size,pos);
-	return *this;
-      }
-      CImg<T> tmp; tmp.swap(data[pos]); // the image to remove will be freed
-      size--;
-      if (pos!=size) { 
-	memmove(data+pos,data+pos+1,sizeof(CImg<T>)*(size-pos));
-	CImg<T> &tmp = data[size];
-	tmp.width = tmp.height = tmp.depth = tmp.dim = 0;
-	tmp.data = NULL;
-      }
-      return *this;
-    }
-
-    //! Remove the last image from the image list.
-    CImgl& remove() { return remove(size); }  
-
-    //! Reverse list order
-    CImgl& reverse() {
-      for (unsigned int l=0; l<size/2; l++) (*this)[l].swap((*this)[size-1-l]);
-      return *this;
-    }
-    
-    CImgl& get_reverse() { return CImgl<T>(*this).reverse(); }
-    
-    //@}
-    //------------------------------------------
-    //------------------------------------------
-    //
-    //! \name IO and display functions
-    //@{
-    //------------------------------------------
-    //------------------------------------------
-    
-    //! Print informations about the list on the standart error stream.
-    const CImgl& print(const char* title=NULL,const int print_flag=1) const { 
-      char tmp[1024];
-      std::fprintf(stderr,"%-8s(%p) : (%u,%p)\n",title?title:"CImgl",(void*)this,size,(void*)data);
-      if (print_flag>0)	cimgl_map(*this,l) {
-	std::sprintf(tmp,"%s[%d]",title?title:"CImgl",l);
-	data[l].print(tmp,print_flag);
-      }
-      return *this;
-    }
-    //! Load an image list from a file (.raw format).
-
-#define cimg_load_raw_case(Ts,Tss)					 	 \
-  if (!loaded && !cimg::strcasecmp(Ts,tmp2)) for (unsigned int l=0; l<n; l++) {  \
-      Tss *buf;                                                         \
-      const bool endian = cimg::endian();                               \
-      j=0; while((i=fgetc(file))!='\n') tmp[j++]=(char)i; tmp[j]='\0';  \
-      std::sscanf(tmp,"%u %u %u %u",&w,&h,&z,&k);                       \
-      buf = new Tss[w*h*z*k]; cimg::fread(buf,sizeof(Tss),w*h*z*k,file);\
-      if (endian) cimg::endian_swap(buf,w*h*z*k);	   	        \
-      CImg<T> idest(w,h,z,k); cimg_mapoff(idest,off)                    \
-                        idest[off] = (T)(buf[off]); idest.swap(res[l]); \
-      delete[] buf;                                                     \
-      loaded = true;                                                    \
-    }
-
-    static CImgl load_raw(const char *filename) {
-      typedef unsigned char uchar;
-      typedef unsigned short ushort;
-      typedef unsigned int uint;  
-      typedef unsigned long ulong; 
-      std::FILE *file = cimg::fopen(filename,"rb");
-      char tmp[256],tmp2[256];
-      int i;
-      bool loaded = false;
-      unsigned int n,j,w,h,z,k,err;
-      j=0; while((i=fgetc(file))!='\n' && i!=EOF) tmp[j++]=i; tmp[j]='\0';
-      err=std::sscanf(tmp,"%u#%255[A-Za-z ]",&n,tmp2);
-      if (err!=2) throw CImgIOException("CImgl<%s>::load_raw() : file '%s', Unknow .raw header",pixel_type(),filename);
-      CImgl<T> res(n);
-      cimg_load_raw_case("unsigned char",uchar);
-      cimg_load_raw_case("uchar",uchar);
-      cimg_load_raw_case("char",char);
-      cimg_load_raw_case("unsigned short",ushort);
-      cimg_load_raw_case("ushort",ushort);
-      cimg_load_raw_case("short",short);
-      cimg_load_raw_case("unsigned int",uint);
-      cimg_load_raw_case("uint",uint);
-      cimg_load_raw_case("int",int);
-      cimg_load_raw_case("unsigned long",ulong);
-      cimg_load_raw_case("ulong",ulong);
-      cimg_load_raw_case("long",long);
-      cimg_load_raw_case("float",float);
-      cimg_load_raw_case("double",double);
-      if (!loaded) throw CImgIOException("CImgl<%s>::load_raw() : file '%s', can't read images of %s",pixel_type(),filename,tmp2);
-      cimg::fclose(file);
-      return res;
-    }
-
-    //! Load an image list from a file. The file should be a '.raw' format, else only one image will be loaded into the list.
-    static CImgl load(const char *filename) {
-      CImgl res;
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strcasecmp(ext,"raw") || !ext[0]) return load_raw(filename); else return CImg<T>(filename);
-    }
-
-
-    //! Save an image list into a file.
-    /**
-       Depending on the extension of the given filename, a file format is chosen for the output file.       
-    **/    
-    const CImgl& save(const char *filename) const {
-      cimgl_test(*this,"CImgl<T>::save");
-      const char *ext = cimg::filename_split(filename);
-      if (!cimg::strcasecmp(ext,"raw") || !ext[0]) return save_raw(filename);
-      else {
-	if (size==1) data[0].save(filename,-1);
-	else cimgl_map(*this,l) data[l].save(filename,l);
-      }
-      return *this;
-    }
-
-    //! Save an image list into a RAW file.
-    /**
-       A RAW file is a simple uncompressed binary file that may be used to save list of CImg<T> images.
-       \param filename : name of the output file.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& save_raw(const char *filename) const {
-      cimgl_test(*this,"CImgl<T>::save_raw");
-      std::FILE *file = cimg::fopen(filename,"wb");
-      std::fprintf(file,"%u#%s\n",size,pixel_type());
-      cimgl_map(*this,l) {
-	const CImg<T>& img = data[l];
-	std::fprintf(file,"%u %u %u %u\n",img.width,img.height,img.depth,img.dim);
-	if (cimg::endian()) {
-	  CImg<T> tmp(img);
-	  cimg::endian_swap(tmp.data,tmp.size());
-	  cimg::fwrite(tmp.data,sizeof(T),img.width*img.height*img.depth*img.dim,file);
-	} else cimg::fwrite(img.data,sizeof(T),img.width*img.height*img.depth*img.dim,file);
-      }
-      cimg::fclose(file);
-      return *this;
-    }    
-
-    //! Return a single image which is the concatenation of all images of the current CImgl instance.
-    /**
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \return A CImg<T> image corresponding to the concatenation is returned.
-    **/
-    CImg<T> get_append(const char axe='x',const char align='c') const {
-      cimgl_test(*this,"CImgl<T>::get_append");
-      unsigned int dx=0,dy=0,dz=0,dv=0,pos=0;
-      CImg<T> res;
-      switch(cimg::uncase(axe)) {
-      case 'x': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx += img.width;
-	  dy = cimg::max(dy,img.height);
-	  dz = cimg::max(dz,img.depth);
-	  dv = cimg::max(dv,img.dim);
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p' : { cimgl_map(*this,ll) { res.draw_image((*this)[ll],pos,0,0,0); pos+=(*this)[ll].width; }} break;
-	case 'n' : { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],pos,dy-(*this)[ll].height,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].width;
-	    }} break;
-	default  : { cimgl_map(*this,ll) {
-	      res.draw_image((*this)[ll],pos,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
-	      pos+=(*this)[ll].width; 
-	    }} break;
-	}
-      }	break;
-      case 'y': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx = cimg::max(dx,img.width);
-	  dy += img.height;
-	  dz = cimg::max(dz,img.depth);
-	  dv = cimg::max(dv,img.dim);
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,pos,0,0); pos+=(*this)[ll].height; }} break;
-	case 'n': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],dx-(*this)[ll].width,pos,dz-(*this)[ll].depth,dv-(*this)[ll].dim); pos+=(*this)[ll].height;
-	    }} break;
-	default : { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,pos,(dz-(*this)[ll].depth)/2,(dv-(*this)[ll].dim)/2);
-	      pos+=(*this)[ll].height; 
-	    }} break;
-	}
-      }	break;
-      case 'z': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx = cimg::max(dx,img.width);
-	  dy = cimg::max(dy,img.height);
-	  dz += img.depth;
-	  dv = cimg::max(dv,img.dim);
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,0,pos,0); pos+=(*this)[ll].depth; }} break;
-	case 'n': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,pos,dv-(*this)[ll].dim); pos+=(*this)[ll].depth;
-	    }} break;
-	case 'c': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,pos,(dv-(*this)[ll].dim)/2);
-	      pos+=(*this)[ll].depth; 
-	    }} break;
-	}
-      }	break;
-      case 'v': {
-	cimgl_map(*this,l) {
-	  const CImg<T>& img = (*this)[l];
-	  dx = cimg::max(dx,img.width);
-	  dy = cimg::max(dy,img.height);
-	  dz = cimg::max(dz,img.depth);
-	  dv += img.dim;
-	}
-	res = CImg<T>(dx,dy,dz,dv,0);
-	switch (cimg::uncase(align)) {
-	case 'p': { cimgl_map(*this,ll) { res.draw_image((*this)[ll],0,0,0,pos); pos+=(*this)[ll].dim; }} break;
-	case 'n': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],dx-(*this)[ll].width,dy-(*this)[ll].height,dz-(*this)[ll].depth,pos); pos+=(*this)[ll].dim;
-	    }} break;
-	case 'c': { cimgl_map(*this,ll) { 
-	      res.draw_image((*this)[ll],(dx-(*this)[ll].width)/2,(dy-(*this)[ll].height)/2,(dz-(*this)[ll].depth)/2,pos);
-	      pos+=(*this)[ll].dim; 
-	    }} break;
-	}
-      } break;
-      }
-      return res;
-    }
-    
-    //! Display the current CImgl instance in an existing CImgDisplay window (by reference).
-    /**
-       This function displays the list images of the current CImgl instance into an existing CImgDisplay window.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns immediately.
-       \param disp : reference to an existing CImgDisplay instance, where the current image list will be displayed.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(CImgDisplay& disp,const char axe='x',const char align='c') const { 
-      get_append(axe,align).display(disp); return *this; 
-    }
-
-    //! Display the current CImgl instance in an existing CImgDisplay window (by pointer).
-    /**
-       This function displays the list images of the current CImgl instance into an existing CImgDisplay window.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns immediately.
-       \param disp : pointer to an existing CImgDisplay instance, where the current image list will be displayed.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(CImgDisplay* disp,const char axe='x',const char align='c') const { 
-      if (!disp) throw CImgArgumentException("CImgl<%s>::display() : given display pointer is (null)",pixel_type());
-      else display(*disp,axe,align);
-      return *this;
-    }
-
-    //! Display the current CImgl instance in a new display window.
-    /**
-       This function opens a new window with a specific title and displays the list images of the current CImgl instance into it.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns when a key is pressed or the display window is closed by the user.
-       \param title : specify the title of the opening display window.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(const char* title,const char axe='x',const char align='c',
-			 const int min_size=128,const int max_size=1024) const {
-      get_append(axe,align).display(title,min_size,max_size);
-      return *this;
-    }
-
-    //! Display the current CImgl instance in a new display window.
-    /**
-       This function opens a new window and displays the list images of the current CImgl instance into it.
-       Images of the list are concatenated in a single temporarly image for visualization purposes.
-       The function returns when a key is pressed or the display window is closed by the user.
-       \param axe : specify the axe for image concatenation. Can be 'x','y','z' or 'v'.
-       \param align : specify the alignment for image concatenation. Can be 'p' (top), 'c' (center) or 'n' (bottom).
-       \param min_size : specify the minimum size of the opening display window. Images having dimensions below this
-       size will be upscaled.
-       \param max_size : specify the maximum size of the opening display window. Images having dimensions above this
-       size will be downscaled.
-       \return A reference to the current CImgl instance is returned.
-    **/
-    const CImgl& display(const char axe='x',const char align='c',
-			 const int min_size=128,const int max_size=1024) const {
-      return display("",axe,align,min_size,max_size); 
-    }
-
-    //! Same as \ref cimg::wait()
-    /**
-       \see cimg::wait().
-    **/
-    const CImgl& wait(const unsigned int milliseconds) const { cimg::wait(milliseconds); return *this;  }
-    
-    // Swap fields of two CImgl instances.
-    CImgl& swap(CImgl& list) {
-      cimg::swap(size,list.size);
-      cimg::swap(data,list.data);
-      return list;
-    }
-
-#ifdef cimgl_plugin
-#include cimgl_plugin
-#endif
-   
-    //@}
-  };
-
-
-  //! This class represents a region of interest of a CImg<T> image.
-  /**
-     When using the functions CImg<T>::ref_*(), an instance of a CImgROI<T> is returned, corresponding
-     to a sub-image of the original image. Acting on the CImgROI<T> instance allows to modify only a
-     part of the original image.
-     CImgROI<T> instances should be handled with care.  
-  **/
-  template<typename T> struct CImgROI : public CImg<T> {
-    CImgROI(const unsigned int dx,const unsigned int dy,const unsigned int dz,const unsigned int dv,T *const pdata) {
-      CImg<T>::width = dx; CImg<T>::height = dy; CImg<T>::depth = dz; CImg<T>::dim = dv; CImg<T>::data = pdata;
-    }
-    CImgROI(const CImgROI& roi) {
-      CImg<T>::width = roi.width; CImg<T>::height = roi.height; CImg<T>::depth = roi.depth; CImg<T>::dim = roi.dim; 
-      CImg<T>::data = roi.data;
-    }
-    ~CImgROI() { CImg<T>::width=CImg<T>::height=CImg<T>::depth=CImg<T>::dim=0; CImg<T>::data=NULL;}
-  };
-  
-}
-
-// Overcome VisualC++ 6.0 and DMC compilers namespace bug
-#if ( defined(_MSC_VER) || defined(__DMC__) ) && defined(std)
-#undef std
-#endif
-
-/*--------------------------------------------------------------------------------------
-
-
-
-  Additional documentation for the generation of the reference page (using doxygen)
-
-
-
-  -------------------------------------------------------------------------------------*/
-/**
-   \mainpage
-   
-   This is the reference documentation of <a href="http://cimg.sourceforge.net">the CImg Library</a>.
-   This documentation has been automatically generated from the header file CImg.h, using the tool
-   <a href="http://www.doxygen.org">doxygen</a>.
-   It contains a detailed description of all classes and functions of <a href="http://cimg.sourceforge.net">the CImg Library</a>.
-   If you don't know what the CImg Library is, you should go to <a href="http://cimg.sourceforge.net">the project web page</a>
-   first.
-   
-   You can easily navigate through the documentation pages, using the menu above.
-
-   To get started, you may first check the list of <a href="modules.html">available modules</a>.
-
-*/
-
-//---------------------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_structure Introduction to the CImg Library */
-/*@{
-  \page foo2
-
-  The CImg Library consists in a \b single \b header \b file \ref CImg.h providing a set of C++ classes that
-  can be used in your own sources, to load/save, process and display images. Very portable 
-  (Unix/X11,Windows, MacOS X, FreeBSD,..), efficient, simple to use, it's a pleasant toolkit
-  for coding image processing stuffs in C++.
-
-  \section s1 Library structure
-
-  The file \ref CImg.h contains all the classes and functions that compose the library itself.
-  It is organized as follows :
-  
-  - All library classes and functions are defined in the namespace cimg_library. This namespace
-  encapsulates all library functionalities and avoid any class name collision that could happen with
-  other includes. Generally, one uses this namespace as a default namespace :
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-  \endcode
-
-  - The namespace cimg_library::cimg defines a set of \e low-level functions and variables used by the library.
-  Documented functions in this namespace can be safely used in your own program. But, \b never use the
-  cimg_library::cimg namespace as a default namespace, since it contains functions whose names are already
-  used in the standart C library.
-
-  - The class \ref cimg_library::CImg represents images up to 4-dimensions wide, containing pixels of type \c T.
-  This is actually the main class of the library.
-
-  - The class cimg_library::CImgl represents lists of cimg_library::CImg images. It can be used for instance
-  to store different frames of an image sequence.
-
-  - The class cimg_library::CImgDisplay is able to display images or image lists into graphical windows.
-  As you may guess, the code of this class is highly system-dependant (see \c cimg_display_type in \ref cimg_environment ).
-
-  - The class cimg_library::CImgStats represents simple image statistics. Use it to compute the
-  minimum, maximum, mean and variance of pixel values of images.
-
-  - The class cimg_library::CImgException (and its subclasses) are used by the library to throw exceptions
-  when errors occur. Those exceptions can be catched with a bloc <tt>try { ..} catch (CImgException) { .. }</tt>.
-  Subclasses define more precisely the type of the encountered error.
-
-  Knowing these five classes is enough to get benefit of most of the CImg Library functionalities.
-
-  As you can see, all the library functions and classes are defined in a single header file CImg.h.
-  This may sound strange, but it is actually one major advantage of the CImg library :
-
-  - The compilation is done on the fly : Only functions \e really \e used in your program are compiled and appear in the final
-  program. This leads to very compact executables, without any unused functions code.
-  - Class members and functions are inlined, leading to better performance during execution.
-  - No complex dependancies have to be handled : Just include the CImg.h file, and you get a working toolkit that processes images.
-
-  \section s2 CImg version of "Hello world".
-
-  Below is a very simple code that creates a "Hello World" image. This shows you basically how a CImg program looks like.
-
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-
-  int main() {
-    CImg<unsigned char> img(640,400,1,3);        // Define a 640x400 color image
-    img.fill(0);                                 // Set pixel values to 0 (color : black)
-    unsigned char purple[3]={255,0,255};         // Define a purple color
-    img.draw_text("Hello World",100,100,purple); // Draw a purple "Hello world" at coordinates (100,100).
-    img.display("Hello World");                  // Display the image
-    return 0;
-  }
-  \endcode
-
-  Which can be also written in a more compact way as :
-
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-
-  int main() {
-    const unsigned char purple[3]={255,0,255};
-    CImg<unsigned char>(640,400,1,3,0).draw_text("Hello World",100,100,purple).display("Hello World");
-    return 0;
-  }
-  \endcode
-
-  Generally, you can write very small code that performs complex image tasks. The CImg Library is very simple
-  to use but provide a lot of interesting algorithms for image manipulation.
-  
-  \section s3 How to compile ?
-
-  The CImg library is a very light and user-friendly library : only standart system libraries are used.
-  this avoid to handle complex dependancies and problems with library compatibility.
-  The only thing you need is a (quite modern) C++ compiler. Before each release, the CImg library
-  is successfully compiled with the following compilers :
-  
-  - <b>Microsoft Visual C++ 6.0 and Visual Studio.NET</b> : Use project files and solution files provided in the 
-  CImg Library package to see how it works.
-  - <b>Intel ICL compiler</b> : Use the following command to compile a CImg-based program with ICL :
-  \code
-  icl /Ox hello_world.cpp user32.lib gdi32.lib
-  \endcode
-  - <b>Digital Mars Compiler</b> : Use the following command to compile a CImg-based program with DMC :
-  \code
-  dmc -Ae hello_world.cpp gdi32.lib
-  \endcode
-  - <b>g++ (MingW windows version)</b> : Use the following command to compile a CImg-based program with g++, on Windows :
-  \code
-  g++ -o hello_word.exe hello_word.cpp -O2 -lgdi32
-  \endcode
-  - <b>g++ (Linux version)</b> : Use the following command to compile a CImg-based program with g++, on Linux :
-  \code
-  g++ -o hello_word.exe hello_world.cpp -O2 -Wl,-rpath /usr/X11R6/lib -lm -lpthread -lX11
-  \endcode
-  - <b>g++ (Solaris version)</b> : Use the following command to compile a CImg-based program with g++, on Solaris :
-  \code
-  g++ -o hello_word.exe hello_world.cpp -O2 -lm -lpthread -R/usr/X11R6/lib -lrt -lnsl -lsocket
-  \endcode
-  - <b>g++ (Mac OS X version)</b> : Use the following command to compile a CImg-based program with g++, on Mac OS X :
-  \code
-  g++ -o hello_word.exe hello_world.cpp -O2 -lm -lpthread -L/usr/X11R6/lib -lm -lpthread -lX11
-  \endcode
-  - <b>Dev-Cpp</b> : Use the project file provided in the CImg library package to see how it works.
-
-  If you are using another compilers and encounter problems, please
-  <a href="http://www.greyc.ensicaen.fr/~dtschump">write me</a> since maintaining compatibility is one
-  of my priority.
-
-  \section s4 What's next ?
-
-  If you are ready to get more, and to start writing more serious programs
-  with CImg, you are invited to go to the \ref cimg_tutorial section.
-
-**/
-/*@}*/
-
-//--------------------------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_environment Setting Environment Variables */
-/*@{
-  \page foo1
-  
-  The CImg library is a multiplatform library, working on a wide variety of systems.
-  This implies the existence of some \e environment \e variables that must be correctly defined
-  depending on your current system.
-  Most of the time, the CImg Library defines these variables automatically
-  (for popular systems). Anyway, if your system is not recognized, you will have to set the environment
-  variables by hand. Here is a quick explanations of environment variables.\n
-  
-  Setting the environment variables is done with the <tt>#define</tt> keyword.
-  This setting must be done <i>before including the file CImg.h</i> in your source code.
-  For instance,
-  defining the environment variable \c cimg_display_type would be done like this :
-  \code
-  #define cimg_display_type 0
-  #include "CImg.h"
-  ...
-  \endcode
-
-  Here are the different environment variables used by the CImg Library :
-  
-  - \b \c cimg_OS : This variable defines the type of your Operating System. It can be set to \b 0 (\e Solaris),
-  \b 1 (\e Linux),
-  \b 2 (\e Windows), \b 3 (\e Mac \ OS X), \b 4 (\e FreeBSD) or \b -1 (\e Other \e configuration).
-  It should be actually auto-detected by the CImg library. If this is not the case (<tt>cimg_OS=-1</tt>), you
-  will probably have to tune the environment variables described below.
-
-  - \b \c cimg_display_type : This variable defines the type of graphical library used to
-  display images in windows. It can be set to 0 (no display library available), \b 1 (X11-based display) or
-  \b 2 (Windows-GDI display).
-  If you are running on a system without X11 or Windows-GDI ability, please set this variable to \c 0.
-  This will disable the display support, since the CImg Library doesn't contain the necessary code to display
-  images on systems other than X11 or Windows GDI.
-
-  - \b \c cimg_color_terminal : This variable tells the library if the system terminal has VT100 color capabilities.
-  It can be \e defined or \e not \e defined. Define this variable to get colored output on your terminal, 
-  when using the CImg Library.
-  
-  - \b \c cimg_debug : This variable defines the level of run-time debug messages that will be displayed by
-  the CImg Library. It can be set to 0 (no debug messages), 1 (normal debug messages, which is
-  the default value), or 2 (high debug messages). Note that setting this value to 2 may slow down your
-  program since more debug tests are made by the library (particularly to check if pixel access is made outside
-  image boundaries). See also \ref CImgException to better understand how debug messages are working.
-  
-  - \b \c cimg_lapack : This variable tells the library to use the LAPACK library.
-  It can be \e defined or \e not \e defined (default). Define this variable if you want to use CImg-specific functions
-  based on the LAPACK library. You will have to link your code with the LAPACK library to be able to run
-  your program.
-
-  - \b \c cimg_convert_path : This variables tells the library where the ImageMagick's \e convert tool is located.
-  Setting this variable should not be necessary if ImageMagick is installed on a standart directory, or
-  if \e convert is in your system PATH variable. This macro should be defined only if the ImageMagick's 
-  \e convert tool is not found automatically, when trying to read compressed image format (GIF,PNG,...). 
-  See also cimg_library::CImg::load_convert() and cimg_library::CImg::save_convert() for more informations.
-
-  - \b \c cimg_temporary_path : This variable tells the library where it can find a directory to store
-  temporary files. Setting this variable should not be necessary if you are running on a standart system.
-  This macro should be defined only when troubles are encountered when trying to read
-  compressed image format (GIF,PNG,...).
-  See also cimg_library::CImg::load_convert() and cimg_library::CImg::save_convert() for more informations.
-
-  - \b \c cimg_plugin : This variable tells the library to use a plugin file to add features to the CImg<T> class.
-  Define it with the path of your plugin file, if you want to add member functions to the CImg<T> class,
-  without having to modify directly the \c "CImg.h" file. An include of the plugin file is performed in the CImg<T>
-  class. If \c cimg_plugin if not specified (default), no include is done.
-  
-  - \b \c cimgl_plugin : Same as \c cimg_plugin, but to add features to the CImgl<T> class.
-  
-  - \b \c cimgdisplay_plugin : Same as \c cimg_plugin, but to add features to the CImgDisplay<T> class.
-
-  - \b \c cimgstats_plugin : Same as \c cimg_plugin, but to add features to the CImgStats<T> class.
-
-  All these compilation variables can be checked, using the function cimg_library::cimg::info(), which
-  displays a list of the different configuration variables and their values on the standart error output.
-**/
-/*@}*/
-
-//--------------------------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_tutorial Tutorial : Getting Started. */
-/*@{
-  \page foo3
-  
-  Let's start to write our first program to get the idea. This will demonstrate how to load and create images, as well as handle image 
-  display and mouse events.
-  Assume we want to load a color image <tt>lena.jpg</tt>, smooth it, display it in a windows, and enter an event loop so that clicking a
-  point in the image with the mouse will draw the intensity profiles of (R,G,B) of the corresponding image line (in another window).
-  Yes, that sounds quite complex for a first code, but don't worry, it will be very simple using the CImg library ! Well, just look
-  at the code below, it does the task :
-
-  \code
-  #include "CImg.h"
-  using namespace cimg_library;
-
-  int main() {
-    CImg<unsigned char> image("lena.jpg"), visu(500,400,1,3,0);
-    const unsigned char red[3]={255,0,0}, green[3]={0,255,0}, blue[3]={0,0,255};
-    image.blur(2.5);
-    CImgDisplay main_disp(image,"Click a point"), draw_disp(visu,"Intensity profile");
-    while (!main_disp.closed && !draw_disp.closed) {
-      main_disp.wait();
-      if (main_disp.button && main_disp.mousey>=0) {
-        const int y = main_disp.mousey;
-	visu.fill(0).draw_graph(image.get_crop(0,y,0,0,image.dimx()-1,y,0,0),red,0,256,0);
-	visu.draw_graph(image.get_crop(0,y,0,1,image.dimx()-1,y,0,1),green,0,256,0);
-	visu.draw_graph(image.get_crop(0,y,0,2,image.dimx()-1,y,0,2),blue,0,256,0).display(draw_disp);
-	}
-      }
-    return 0;
-  }
-  \endcode
-  
-  Here is a screenshot of the resulting program :
-
-  <img SRC="../img/tutorial.jpg">
-
-  And here is the detailled explanation of the source, line by line :
-
-  \code #include "CImg.h" \endcode
-  Include the main and only header file of the CImg library.
-  \code using namespace cimg_library; \endcode
-  Use the library namespace to ease the declarations afterward.
-  \code int main() { \endcode
-  Definition of the main function.
-  \code CImg<unsigned char> image("lena.jpg"), visu(500,400,1,3,0); \endcode
-  Creation of two instances of images of \c unsigned \c char pixels.
-  The first image \c image is initialized by reading an image file from the disk. 
-  Here, <tt>lena.jpg</tt> must be in the same directory than the current program.
-  Note that you must also have installed the \e ImageMagick package in order to be able to read JPG images.
-  The second image \c visu is initialized as a black color image with dimension <tt>dx=500</tt>, <tt>dy=400</tt>, 
-  <tt>dz=1</tt> (here, it is a 2D image, not a 3D one), and <tt>dv=3</tt> (each pixel has 3 'vector' channels R,G,B).
-  The last argument in the constructor defines the default value of the pixel values
-  (here \c 0, which means that \c visu will be initially black).
-  \code const unsigned char red[3]={255,0,0}, green[3]={0,255,0}, blue[3]={0,0,255}; \endcode
-  Definition of three different colors as array of unsigned char. This will be used to draw plots with different colors.
-  \code image.blur(2.5); \endcode
-  Blur the image, with a gaussian blur and a variance of 2.5. Note that most of the CImg functions have two versions :
-  one that acts in-place (which is the case of blur), and one that returns the result as a new image (the name of the function 
-  begins then with <tt>get_</tt>&nbsp;). In this case, one could have also written <tt>image = image.get_blur(2.5);</tt>
-  (more expensive, since it needs an additional copy operation).
-  \code CImgDisplay main_disp(image,"Click a point"), draw_disp(visu,"Intensity profile"); \endcode
-  Creation of two display windows, one for the input image image, and one for the image visu which will be display intensity profiles.
-  By default, CImg displays handles events (mouse,keyboard,..). On Windows, there is a way to create fullscreen displays.
-  \code while (!main_disp.closed && !draw_disp.closed) { \endcode
-  Enter the event loop, the code will exit when one of the two display windows is closed.
-  \code main_disp.wait(); \endcode
-  Wait for an event (mouse, keyboard,..) in the display window \c main_disp.
-  \code if (main_disp.button && main_disp.mousey>=0) { \endcode
-  Test if the mouse button has been clicked on the image area.
-  One may distinguish between the 3 different mouse buttons,
-  but in this case it is not necessary
-  \code const int y = main_disp.mousey; \endcode
-  Get the image line y-coordinate that has been clicked.
-  \code visu.fill(0).draw_graph(image.get_crop(0,y,0,0,image.dimx()-1,y,0,0),red,0,256,0); \endcode
-  This line illustrates the pipeline property of most of the CImg class functions. The first function <tt>fill(0)</tt> simply sets
-  all pixel values with 0 (i.e. clear the image \c visu). The interesting thing is that it returns a reference to
-  \c visu and then, can be pipelined with the function \c draw_graph() which draws a plot in the image \c visu.
-  The plot data are given by another image (the first argument of \c draw_graph()). In this case, the given image is 
-  the red-component of the line y of the original image, retrieved by the function \c get_crop() which returns a
-  sub-image of the image \c image. Remember that images coordinates are 4D (x,y,z,v) and for color images,
-  the R,G,B channels are respectively given by <tt>v=0, v=1</tt> and <tt>v=2</tt>.
-  \code visu.draw_graph(image.get_crop(0,y,0,1,image.dimx()-1,y,0,1),green,0,256,0); \endcode
-  Plot the intensity profile for the green channel of the clicked line.
-  \code visu.draw_graph(image.get_crop(0,y,0,2,image.dimx()-1,y,0,2),blue,0,256,0).display(draw_disp); \endcode
-  Same thing for the blue channel. Note how the function (which return a reference to \c visu) is pipelined with the function
-  \c display() that just paints the image visu in the corresponding display window.
-  \code ...till the end \endcode
-  I don't think you need more explanations !
-
-  As you have noticed, the CImg library allows to write very small and intuitive code. Note also that this source will perfectly 
-  work on Unix and Windows systems. Take also a look to the examples provided in the CImg package (
-  directory \c examples/ ). It will show you how CImg-based code can be surprisingly small. 
-  Moreover, there is surely one example close to what you want to do.
-  A good start will be to look at the file <tt>CImg_test.cpp</tt> which contains small and various examples of what you can do
-  with the CImg Library. All CImg classes are used in this source, and the code can be easily modified to see what happens. 
-
-**/
-/*@}*/
-
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_drawing Using Drawing Functions. */
-/*@{
-  \page foo5
-
-  \section s5 Using Drawing Functions.
-
-  This section tells more about drawing features in CImg images.
-  Drawing functions list can be found in <a href="structCImg.html">the CImg functions list</a>
-  (section \b Drawing Functions),
-  and are all defined on a common basis. Here are the important points to understand before using
-  drawing functions :
-  
-  - Drawing is performed on the instance image. Drawing functions parameters
-  are defined as \e const variables and return a reference to the current instance <tt>(*this)</tt>,
-  so that drawing functions can be pipelined (see examples below).
-  Drawing is usually done in 2D color images but can be performed in 3D images with any vector-valued dimension,
-  and with any possible pixel type.
-
-  - A color parameter is always needed to draw features in an image. The color must be defined as a C-style array
-  whose dimension is at least
-
-*/
-/*@}*/
-
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_loops Using Image Loops. */
-/*@{
-  \page foo_lo
-  The CImg Library provides different macros that define useful iterative loops over an image.
-  Basically, it can be used to replace one or several <tt>for(..)</tt> instructions, but it also proposes
-  interesting extensions to classical loops.
-  Below is a list of all existing loop macros, classified in four different categories :
-  - \ref lo1
-  - \ref lo4
-  - \ref lo5
-  - \ref lo6
-
-  \section lo1 Loops over the pixel buffer
-
-  Loops over the pixel buffer are really basic loops that iterate a pointer on the pixel data buffer
-  of a \c cimg_library::CImg image. Two macros are defined for this purpose :
-  
-  - \b cimg_map(img,ptr,T) :
-  This macro loops over the pixel data buffer of the image \c img, using a pointer <tt>T* ptr</tt>,
-  starting from the end of the buffer (last pixel) till the beginning of the buffer (first pixel).
-      - \c img must be a (non empty) \c cimg_library::CImg image of pixels \c T.
-      - \c ptr is a pointer of type \c T*.
-  This kind of loop should not appear a lot in your own source code, since this is a low-level loop
-  and many functions of the CImg class may be used instead. Here is an example of use :
-  \code
-  CImg<float> img(320,200);
-  cimg_map(img,ptr,float) { *ptr=0; }      // Equivalent to 'img.fill(0);'
-  \endcode
-
-  - \b cimg_mapoff(img,off) :
-  This macro loops over the pixel data buffer of the image \c img, using an offset \c ,
-  starting from the beginning of the buffer (first pixel, \c off=0)
-  till the end of the buffer (last pixel value, <tt>off = img.size()-1</tt>).
-      - \c img must be a (non empty) cimg_library::CImg<T> image of pixels \c T.
-      - \c off is an inner-loop variable, only defined inside the scope of the loop.
-
-  Here is an example of use :
-  \code
-  CImg<float> img(320,200);
-  cimg_mapoff(img,off) { img[off]=0; }  // Equivalent to 'img.fill(0);'
-  \endcode
-
-  \section lo4 Loops over image dimensions
-
-  The following loops are probably the most used loops in image processing programs.
-  They allow to loop over the image along one or several dimensions, along a raster scan course.
-  Here is the list of such loop macros for a single dimension :
-  - \b cimg_mapX(img,x) : equivalent to : <tt>for (int x=0; x<img.dimx(); x++)</tt>.
-  - \b cimg_mapY(img,y) : equivalent to : <tt>for (int y=0; y<img.dimy(); y++)</tt>.
-  - \b cimg_mapZ(img,z) : equivalent to : <tt>for (int z=0; z<img.dimz(); z++)</tt>.
-  - \b cimg_mapV(img,v) : equivalent to : <tt>for (int v=0; v<img.dimv(); v++)</tt>.
-
-  Combinations of these macros are also defined as other loop macros, allowing to loop directly over 2D, 3D or 4D images :
-  - \b cimg_mapXY(img,x,y) : equivalent to : \c cimg_mapY(img,y) \c cimg_mapX(img,x).
-  - \b cimg_mapXZ(img,x,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapX(img,x).
-  - \b cimg_mapYZ(img,y,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapY(img,y).
-  - \b cimg_mapXV(img,x,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapX(img,x).
-  - \b cimg_mapYV(img,y,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapY(img,y).
-  - \b cimg_mapZV(img,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapZ(img,z).
-  - \b cimg_mapXYZ(img,x,y,z) : equivalent to : \c cimg_mapZ(img,z) \c cimg_mapXY(img,x,y).
-  - \b cimg_mapXYV(img,x,y,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXY(img,x,y).
-  - \b cimg_mapXZV(img,x,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXZ(img,x,z).
-  - \b cimg_mapYZV(img,y,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapYZ(img,y,z).
-  - \b cimg_mapXYZV(img,x,y,z,v) : equivalent to : \c cimg_mapV(img,v) \c cimg_mapXYZ(img,x,y,z).
-
-  - For all these loops, \c x,\c y,\c z and \c v are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  - \c img must be a (non empty) cimg_library::CImg image.
-
-  Here is an example of use that creates an image with a smooth color gradient :
-  \code
-  CImg<unsigned char> img(256,256,1,3);       // Define a 256x256 color image
-  cimg_mapXYV(img,x,y,v) { img(x,y,v) = (x+y)*(v+1)/6; }
-  img.display("Color gradient");
-  \endcode
-
-  \section lo5 Loops over interior regions and borders.
-
-  Similar macros are also defined to loop only on the border of an image, or inside the image (excluding the border).
-  The border may be several pixel wide :
-
-  - \b cimg_imapX(img,x,n) : Loop along the x-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapY(img,y,n) : Loop along the y-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapZ(img,z,n) : Loop along the z-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapV(img,v,n) : Loop along the v-axis, except for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapXY(img,x,y,n) : Loop along the (x,y)-axes, excepted for pixels inside a border of \p n pixels wide.
-  - \b cimg_imapXYZ(img,x,y,z,n) : Loop along the (x,y,z)-axes, excepted for pixels inside a border of \p n pixels wide.
-
-  And also :
-
-  - \b cimg_bmapX(img,x,n) : Loop along the x-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapY(img,y,n) : Loop along the y-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapZ(img,z,n) : Loop along the z-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapV(img,v,n) : Loop along the z-axis, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapXY(img,x,y,n) : Loop along the (x,y)-axes, only for pixels inside a border of \p n pixels wide.
-  - \b cimg_bmapXYZ(img,x,y,z,n) : Loop along the (x,y,z)-axes, only for pixels inside a border of \p n pixels wide.
-
-  - For all these loops, \c x,\c y,\c z and \c v are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  - \c img must be a (non empty) cimg_library::CImg image.
-  - The constant \c n stands for the size of the border.
-
-  Here is an example of use, to create a 2d grayscale image with two different intensity gradients :
-  \code
-  CImg<> img(256,256);
-  cimg_imapXY(img,x,y,50) img(x,y) = x+y;
-  cimg_bmapXY(img,x,y,50) img(x,y) = x-y;
-  img.display();
-  \endcode
-
-  \section lo6 Loops using neighborhoods.
-  
-  Inside an image loop, it is often useful to get values of neighborhood pixels of the
-  current pixel at the loop location.
-  The CImg Library provides a very smart and fast mechanism for this purpose, with the definition
-  of several loop macros that remember the neighborhood values of the pixels.
-  The use of these macros can highly optimize your code, and also simplify your program.
-
-  \subsection lo7 Neighborhood-based loops for 2D images
-
-  For 2D images, the neighborhood-based loop macros are : 
-
-  - \b cimg_map2x2(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 2x2 neighborhood.
-  - \b cimg_map3x3(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 3x3 neighborhood.
-  - \b cimg_map4x4(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 4x4 neighborhood.
-  - \b cimg_map5x5(img,x,y,z,v,I) : Loop along the (x,y)-axes using a centered 5x5 neighborhood.
-
-  For all these loops, \c x and \c y are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  \c img is a non empty CImg<T> image. \c z and \c v are constants that define on which image slice and
-  vector channel the loop must apply (usually both 0 for grayscale 2D images).
-  Finally, \c I is the 2x2, 3x3, 4x4 or 5x5 neighborhood that will be updated with the correct pixel values
-  during the loop (see \ref lo9).
-
-  \subsection lo8 Neighborhood-based loops for 3D images
-
-  For 3D images, the neighborhood-based loop macros are : 
-
-  - \b cimg_map2x2x2(img,x,y,z,v,I) : Loop along the (x,y,z)-axes using a centered 2x2x2 neighborhood.
-  - \b cimg_map3x3x3(img,x,y,z,v,I) : Loop along the (x,y,z)-axes using a centered 3x3x3 neighborhood.
-
-  For all these loops, \c x, \c y and \c z are inner-defined variables only visible inside the scope of the loop.
-  They don't have to be defined before the call of the macro.
-  \c img is a non empty CImg<T> image. \c v is a constant that defines on which image channel
-  the loop must apply (usually 0 for grayscale 3D images).
-  Finally, \c I is the 2x2x2 or 3x3x3 neighborhood that will be updated with the correct pixel values
-  during the loop (see \ref lo9).
-
-  \subsection lo9 Defining neighborhoods
-
-  The CImg library defines a neighborhood as a set of named \e variables or \e references, declared
-  using specific CImg macros :
-
-  - \b CImg_2x2(I,type) : Define a 2x2 neighborhood named \c I, of type \c type.
-  - \b CImg_3x3(I,type) : Define a 3x3 neighborhood named \c I, of type \c type.
-  - \b CImg_4x4(I,type) : Define a 4x4 neighborhood named \c I, of type \c type.
-  - \b CImg_5x5(I,type) : Define a 5x5 neighborhood named \c I, of type \c type.
-  - \b CImg_2x2x2(I,type) : Define a 2x2x2 neighborhood named \c I, of type \c type.
-  - \b CImg_3x3x3(I,type) : Define a 3x3x3 neighborhood named \c I, of type \c type.
-
-  Actually, \c I is a \e generic \e name for the neighborhood. In fact, these macros declare
-  a \e set of new variables.
-  For instance, defining a 3x3 neighborhood \c CImg_3x3(I,float) declares 9 different float variables
-  \c Ipp,\c Icp,\c Inp,\c Ipc,\c Icc,\c Inc,\c Ipn,\c Icn,\c Inn which correspond to each pixel value of
-  a 3x3 neighborhood.
-  Variable indices are \c p,\c c or \c n, and stand respectively for \e 'previous', \e 'current' and \e 'next'.
-  First indice denotes the \c x-axis, second indice denotes the \c y-axis.
-  Then, the names of the variables are directly related to the position of the corresponding pixels
-  in the neighborhood. For 3D neighborhoods, a third indice denotes the \c z-axis.
-  Then, inside a neighborhood loop, you will have the following equivalence :
-  - <tt>Ipp = img(x-1,y-1)</tt>
-  - <tt>Icn = img(x,y+1)</tt>
-  - <tt>Inp = img(x+1,y-1)</tt>
-  - <tt>Inpc = img(x+1,y-1,z)</tt>
-  - <tt>Ippn = img(x-1,y-1,z+1)</tt>
-  - and so on...
-
-  For bigger neighborhoods, such as 4x4 or 5x5 neighborhoods, two additionnal indices are introduced :
-  \c a (stands for \e 'after') and \c b (stands for \e 'before'), so that :
-  - <tt>Ibb = img(x-2,y-2)</tt>
-  - <tt>Ina = img(x+1,y+2)</tt>
-  - and so on...
-
-  The value of a neighborhood pixel outside the image range (image border problem) is automatically set to the same
-  values than the nearest valid pixel in the image (this is also called the \e Neumann \e border \e condition).
-
-  \subsection lo10 Neighborhood as a reference
-  It is also possible to define neighborhood variables as references to classical C-arrays or CImg<T> images, instead of
-  allocating new variables. This is done by adding \c _ref to the macro names used for the neighborhood definition :
-
-  - \b CImg_2x2_ref(I,type,tab) : Define a 2x2 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_3x3_ref(I,type,tab) : Define a 3x3 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_4x4_ref(I,type,tab) : Define a 4x4 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_5x5_ref(I,type,tab) : Define a 5x5 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_2x2x2_ref(I,type,tab) : Define a 2x2x2 neighborhood named \c I, of type \c type, as a reference to \c tab.
-  - \b CImg_3x3x3_ref(I,type,tab) : Define a 3x3x3 neighborhood named \c I, of type \c type, as a reference to \c tab.
-
-  \c tab can be a one-dimensionnal C-style array, or a non empty \c CImg<T> image. Both objects must have
-  same sizes as the considered neighborhoods.
-
-  \subsection lo11 Example codes
-  More than a long discussion, the above example will demonstrate how to compute the gradient norm of a 3D volume
-  using the \c cimg_map3x3x3() loop macro :
-
-  \code
-  CImg<float> volume("IRM.hdr");        // Load an IRM volume from an Analyze7.5 file
-  CImg_3x3x3(I,float);                  // Define a 3x3x3 neighborhood
-  CImg<float> gradnorm(volume,false);   // Create an image with same size as 'volume'
-  cimg_map3x3x3(volume,x,y,z,0,I) {     // Loop over the volume, using the neighborhood I
-    const float ix = 0.5f*(Incc-Ipcc);  // Compute the derivative along the x-axis.
-    const float iy = 0.5f*(Icnc-Icpc);  // Compute the derivative along the y-axis.
-    const float iz = 0.5f*(Iccn-Iccp);  // Compute the derivative along the z-axis.
-    gradnorm(x,y,z) = std::sqrt(ix*ix+iy*iy+iz*iz);  // Set the gradient norm in the destination image
-  }
-  gradnorm.display("Gradient norm");
-  \endcode
-  
-  And the following example shows how to deal with neighborhood references to blur a color image by averaging
-  pixel values on a 5x5 neighborhood.
-
-  \code
-  CImg<unsigned char> src("image_color.jpg"), dest(src,false), neighbor(5,5);  // Image definitions.
-  typedef unsigned char uchar;             // Avoid space in the second parameter of the macro CImg_5x5 below.
-  CImg_5x5_ref(N,uchar,neighbor);          // Define a 5x5 neighborhood as a reference to the 5x5 image neighbor.
-  cimg_mapV(src,k)                         // Standart loop on color channels
-     cimg_map5x5(src,x,y,0,k,N)            // 5x5 neighborhood loop.
-       dest(x,y,k) = neighbor.sum()/(5*5); // Averaging pixels to filter the color image.
-  CImgl<unsigned char> visu(src,dest);
-  visu.display("Original + Filtered");     // Display both original and filtered image.
-  \endcode
-  
-  Note that in this example, we didn't use directly the variables Nbb,Nbp,..,Ncc,... since
-  there are only references to the neighborhood image \c neighbor. We rather used a member function of \c neighbor.
-
-  As you can see, explaining the use of the CImg neighborhood macros is actually more difficult than using them !
-*/
-/*@}*/
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_displays Using Display Windows. */
-/*@{
-  \page foo_di
-
-  When opening a display window, you can choose the way the pixel values will be normalized
-  before being displayed on the screen. Screen displays only support color values between [0,255],
-  and some
-  
-  When displaying an image into the display window using CImgDisplay::display(), values of
-  the image pixels can be eventually linearly normalized between [0,255] for visualization purposes.
-  This may be useful for instance when displaying \p CImg<double> images with pixel values
-  between [0,1].
-  The normalization behavior depends on the value of \p normalize which can be either \p 0,\p 1 or \p 2 :
-  - \p 0 : No pixel normalization is performed when displaying an image. This is the fastest
-  process, but you must be sure your displayed image have pixel values inside the range [0,255].
-  - \p 1 : Pixel value normalization is done for each new image display. Image pixels are
-  not modified themselves, only displayed pixels are normalized.
-  - \p 2 : Pixel value normalization is done for the first image display, then the
-  normalization parameters are kept and used for all the next image displays.
-  
-*/
-/*@}*/
-
-//----------------------------------------------------------------------------------------------------
-/** \addtogroup cimg_options Retrieving Command Line Arguments. */
-/*@{
-  \page foo_so
-
-   The CImg library offers facilities to retrieve command line arguments in a console-based
-   program, as it is a commonly needed operation.
-   Two macros \c cimg_usage() and \c cimg_option() are defined for this purpose.
-   Using these macros allows to easily retrieve options values from the command line.
-   Moreover, invoking the corresponding executable with the option \c -h or \c --help will
-   automatically display the program usage, followed by the list of requested options.
-
-   \section so1 The cimg_usage() macro
-
-   The macro \c cimg_usage(usage) may be used to describe the program goal and usage.
-   It is generally inserted one time after the <tt>int main(int argc,char **argv)</tt> definition.
-  
-   \param usage : A string describing the program goal and usage.
-   \pre The function where \c cimg_usage() is used must have correctly defined \c argc and \c argv variables.
-
-   \section so2 The cimg_option() macro
-
-   The macro \c cimg_option(name,default,usage) may be used to retrieve an option value from the command line.
-
-   \param name    : The name of the option to be retrieved from the command line.
-   \param default : The default value returned by the macro if no options \p name has been specified when running the program.
-   \param usage   : A brief explanation of the option. If \c usage==NULL, the option won't appear on the option list
-                    when invoking the executable with options \c -h or \c --help (hidden option).
-                  
-   \return \c cimg_option() returns an object that has the \e same \e type than the default value \c default.
-   The return value is equal to the one specified on the command line. If no such option have been specified,
-   the return value is equal to the default value \c default.
-   Warning, this can be confusing in some situations (look at the end of the next section).
-   \pre The function where \c cimg_option() is used must have correctly defined \c argc and \c argv variables.
-
-   \section so3 Example of use
-
-   The code below uses the macros \c cimg_usage() and \c cimg_option().
-   It loads an image, smoothes it an quantifies it with a specified number of values.
-   \code
-   #include "CImg.h"
-   using namespace cimg_library;
-   int main(int argc,char **argv) {
-     cimg_usage("Retrieve command line arguments");
-     const char* filename = cimg_option("-i","image.gif","Input image file");
-     const char* output   = cimg_option("-o",(const char*)NULL,"Output image file");
-     const double sigma   = cimg_option("-s",1.0,"Variance of the gaussian smoothing");
-     const  int nblevels  = cimg_option("-n",16,"Number of quantification levels");
-     const bool hidden    = cimg_option("-hidden",false,NULL);      // This is a hidden option
-
-     CImg<unsigned char> img(filename);
-     img.blur(sigma).quantify(nblevels);
-     if (output) img.save(output); else img.display("Output image");
-     if (hidden) std::fprintf(stderr,"You found me !\n");
-     return 0;
-   }
-   \endcode
-
-   Invoking the corresponding executable with <tt>test -h -hidden -n 20 -i foo.jpg</tt> will display :
-   \verbatim
-$ ./test -h -hidden -n 20 -i foo.jpg
-
- test : Retrieve command line arguments (Oct 16 2004, 12:34:26)
-
-    -i       = foo.jpg      : Input image file
-    -o       = NULL         : Output image file
-    -s       = 1            : Variance of the gaussian smoothing
-    -n       = 20           : Number of quantification levels
-
-   You found me !
-\endverbatim
-
-   \warning As the type of object returned by the macro \c cimg_option(option,default,usage) 
-   is defined by the type of \c default, undesired casts may appear when writting code such as :
-   \code
-   const double sigma = cimg_option("-val",0,"A floating point value");
-   \endcode
-   In this case, \c sigma will always be equal to an integer (since the default value \c 0 is an integer).
-   When passing a float value on the command line, a \e float \e to \e integer cast is then done,
-   truncating the given parameter to an integer value (this is surely not a desired behavior).
-   You must specify <tt>0.0</tt> as the default value in this case.
-
-   \section so4 How to learn more about command line options ?
-   You should take a look at the examples <tt>examples/inrcast.cpp</tt> provided in the CImg Library package.
-   This is a command line based image converter which intensively uses the \c cimg_option() and \c cimg_usage()
-   macros to retrieve command line parameters.
-*/
-/*@}*/
-//----------------------------------------------------------------------------------------------------
-#endif

Deleted: haypo/greycstoration_gimp/INSTALL
===================================================================
--- greycstoration_gimp/INSTALL	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/INSTALL	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,19 +0,0 @@
-The install the Gimp plugin GREYCstoration, you have to compile it first.
-For this, you will need:
-
-- Gimp 2.2.x (or greater) and headers of the Gimp library
-  http://www.gimp.org/
-- Compiler GNU g++
-  http://gcc.gnu.org/
-- GTK 2.x (version 2.6 or greater?) and development headers of GTK+
-  http://www.gtk.org/
-
-Instruction to compile
-======================
-
-make && make install
-
-That's all :-)
-
-The plugin is only tested on Linux, but Michael Schumacher
-prepared Win32 binaries.

Copied: haypo/greycstoration_gimp/INSTALL (from rev 260, greycstoration_gimp/INSTALL)

Deleted: haypo/greycstoration_gimp/Makefile
===================================================================
--- greycstoration_gimp/Makefile	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/Makefile	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,36 +0,0 @@
-# Common arguments
-CXXFLAGS=-Wall -O3 -ffast-math
-SRC=image.cpp greycstoration.cpp dialog.cpp main.cpp
-
-# C++ compiler
-CXX=g++
-
-# pkg-config modules needed
-MODULES=gimp-2.0 gimpui-2.0 gtk+-2.0
-CXXFLAGS+=$(shell pkg-config $(MODULES) --cflags)
-LIBS=$(shell pkg-config $(MODULES) --libs)
-
-# Don't use CImg interface (keyboard/mouse interaction)
-CXXFLAGS+=-Dcimg_OS=-1 -Dcimg_display_type=0 
-
-# And others variables ...
-PROG=greycstoration
-OBJECTS=$(patsubst %.cpp,%.o,$(SRC))
-GIMPTOOL=gimptool-2.0
-
-$(PROG): $(OBJECTS)
-	@echo "Linking ..."
-	@$(CXX) -o $(PROG) $(OBJECTS) $(CXXFLAGS) $(LIBS)
-	
-%.o: %.cpp
-	@echo "Compile $@"
-	@$(CXX) -c -o $@ $< $(CXXFLAGS)
-	
-install: $(PROG)
-	$(GIMPTOOL) --install-bin $(PROG)
-	
-uninstall:
-	$(GIMPTOOL) --uninstall-bin $(PROG)
-
-clean:
-	rm -f $(PROG) $(OBJECTS)

Copied: haypo/greycstoration_gimp/Makefile.am (from rev 260, greycstoration_gimp/Makefile.am)

Copied: haypo/greycstoration_gimp/autogen.sh (from rev 260, greycstoration_gimp/autogen.sh)

Copied: haypo/greycstoration_gimp/configure.in (from rev 260, greycstoration_gimp/configure.in)

Deleted: haypo/greycstoration_gimp/dialog.cpp
===================================================================
--- greycstoration_gimp/dialog.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/dialog.cpp	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,275 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include <stdio.h>
-
-#include "dialog.h"
-//----------------------------------------------------------------------------
-
-// Future gettext use
-#define _(X) X
-
-#include "image.h"
-#include "greycstoration.h"
-#include "plug_in.h"
-#include <libgimp/gimp.h>
-#include <libgimp/gimpui.h>
-#include <gtk/gtk.h>
-//----------------------------------------------------------------------------
-#define SCALE_WIDTH 125
-#define SCALE_DIGITS 3
-#define BOX_SPACING 6
-//----------------------------------------------------------------------------
-
-#define TABLE_SCALE(ROW, LABEL,TYPE,VALUE,MIN,MAX,DELTA1,DELTA2,DIGITS) \
-    { GtkObject *scale = gimp_scale_entry_new ( \
-			GTK_TABLE (table), 0, ROW, \
-			LABEL, SCALE_WIDTH, 0, \
-			VALUE, MIN, MAX, DELTA1, DELTA2, DIGITS, \
-			TRUE, 0, 0, \
-			NULL, NULL); \
-	g_signal_connect (scale, "value_changed", \
-			G_CALLBACK(gimp_##TYPE##_adjustment_update), &VALUE); \
-	g_signal_connect_swapped (scale, "value_changed", \
-			G_CALLBACK(gimp_preview_invalidate), preview); }
-
-//----------------------------------------------------------------------------
-
-GREYCstoration_params::GREYCstoration_params()
-{
-	nb_iter        = 1;
-	dt             = 20.0f;
-	sigma          = 1.4f;
-	dlength        = 0.8;
-	dtheta         = 45.0;
-	onormalize     = false;
-	power1         = 0.1;
-	power2         = 0.9;
-	gauss_prec     = 3.0f;
-	linear         = true;
-	onormalize     = false;
-	preview        = true;
-}
-
-//----------------------------------------------------------------------------
-
-GtkWidget* ajoute_param(
-		GtkObject *spinbutton_adj, 
-		GtkWidget *dst_box, 
-		const char *label_string,
-		int digits=0)
-{
-	GtkWidget *main_hbox;
-	GtkWidget *param_label;
-	GtkWidget *spinbutton;
-
-	/* Bo?te horizontale */
-	main_hbox = gtk_hbox_new (FALSE, BOX_SPACING);
-	gtk_widget_show (main_hbox);
-	gtk_container_add (GTK_CONTAINER(dst_box), main_hbox);
-
-	/* Param?tre : Texte */
-	param_label = gtk_label_new_with_mnemonic(label_string);
-	gtk_widget_show (param_label);
-	gtk_box_pack_start(GTK_BOX(main_hbox), param_label, FALSE, FALSE, 6);
-	gtk_label_set_justify (GTK_LABEL(param_label), GTK_JUSTIFY_RIGHT);
-
-	/* Param?tre : SpinButton */	
-	if (0 <= digits)
-	{
-		spinbutton = gtk_spin_button_new (GTK_ADJUSTMENT(spinbutton_adj), 1, digits);
-		gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(spinbutton), TRUE);
-	} else {
-		spinbutton = gtk_check_button_new();
-	}
-	gtk_widget_show (spinbutton);
-	gtk_box_pack_start (GTK_BOX(main_hbox), spinbutton, FALSE, FALSE, 6);
-	if (digits < 0) return spinbutton; else return NULL;
-}
-
-//----------------------------------------------------------------------------
-
-void dialog_page1 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
-{
-	GtkWidget *page_label;   
-	GtkWidget *table;
-
-	// Create the table
-	table = gtk_table_new (5, 3, FALSE);
-	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
-	gtk_table_set_row_spacings (GTK_TABLE (table), 6);
-	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
-	gtk_widget_show (table);
-
-	// Insert table in a new notebook page
-	page_label = gtk_label_new (_("Restore"));
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), table, page_label);
-	gtk_widget_show (table);
-	
-	// Power1
-	TABLE_SCALE(0, _("_Detail factor (p1):"), float, params.power1, 0, 2, 0.1, 0.3, SCALE_DIGITS);
-	TABLE_SCALE(1, _("_Gradient factor (p2):"), float, params.power2, 0, 100, 0.1, 1, SCALE_DIGITS);
-	TABLE_SCALE(2, _("_Time step (dt):"), float, params.dt, 1, 300, 10, 25, SCALE_DIGITS);
-	TABLE_SCALE(3, _("_Blur (sigma):"), float, params.sigma, 0, 10, 0.2, 1, SCALE_DIGITS);
-	TABLE_SCALE(4, _("_Blur iterations (iter) :"), int, params.nb_iter, 1, 5, 1, 2, 0);
-}
-
-void dialog_page2 (GREYCstoration_params &params, GtkWidget *notebook, GtkWidget *preview)
-{
-	GtkWidget *page_label;   
-	GtkWidget *vbox;
-	GtkWidget *table;
-
-	// New vbox
-	page_label = gtk_label_new (_("Quality"));
-	vbox = gtk_vbox_new (FALSE, BOX_SPACING);
-	gtk_notebook_append_page (GTK_NOTEBOOK (notebook), vbox, page_label);
-	gtk_widget_show (vbox);
-
-	// linear checkbox
-	GtkWidget* check = ajoute_param(NULL, vbox, _("Use linear interpolation:"), -1);
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), params.linear);
-	g_signal_connect (check, "toggled",
-			G_CALLBACK(gimp_toggle_button_update), &params.linear);
-
-	// normalize checkbox
-	check = ajoute_param(NULL, vbox, _("Normalize picture to [0-255]:"), -1);
-	gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (check), params.onormalize);
-	g_signal_connect (check, "toggled",
-			G_CALLBACK(gimp_toggle_button_update), &params.onormalize);	
-
-	// Create the table
-	table = gtk_table_new (3, 3, FALSE);
-	gtk_table_set_col_spacings (GTK_TABLE (table), 6);
-	gtk_table_set_row_spacings (GTK_TABLE (table), 6);
-	gtk_container_set_border_width (GTK_CONTAINER (table), 12);
-	gtk_widget_show (table);
-
-	// Insert table in the container
-	gtk_container_add (GTK_CONTAINER(vbox), table);
-	gtk_widget_show (table);
-
-	// Insert parameters into the table
-	TABLE_SCALE(0, _("_Angular step (da):"), float, params.dtheta, 5, 90, 5, 15, SCALE_DIGITS);
-	TABLE_SCALE(1, _("_Integral step (dt):"), float, params.dlength, 0.1, 10, 0.1, 0.5, SCALE_DIGITS);
-	TABLE_SCALE(2, _("_Gaussian precision (gauss):"), float, params.gauss_prec, 0.1, 10, 0.1, 0.5, SCALE_DIGITS);	
-}
-
-
-//----------------------------------------------------------------------------
-
-bool dialog(GREYCstoration_params &params, GimpDrawable *preview_src)
-{
-	GtkWidget *dialog;
-	GtkWidget *notebook;
-	GtkWidget *preview;
-	GtkWidget *main_vbox;
-
-	// New dialog
-	gimp_ui_init (PLUG_IN_NAME, false);
-	dialog = gimp_dialog_new(
-			_("GREYCstoration"), 
-			PLUG_IN_NAME,
-			NULL, (GtkDialogFlags)0,
-			gimp_standard_help_func, "plug-in-" PLUG_IN_NAME,
-			GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-			GTK_STOCK_OK,     GTK_RESPONSE_OK,
-			NULL);
-
-	// Main vbox	
-	main_vbox = gtk_vbox_new (false, BOX_SPACING);
-	gtk_container_add (GTK_CONTAINER(GTK_DIALOG(dialog)->vbox), main_vbox);
-	gtk_widget_show (main_vbox);
-
-	// Add preview 
-	preview = gimp_drawable_preview_new(preview_src, &params.preview);
-	gtk_container_add (GTK_CONTAINER(main_vbox), preview);
-	gtk_widget_show (preview);
-	g_signal_connect (preview, "invalidated",
-			G_CALLBACK(DoGREYCstoration), preview_src);
-
-	// Create notebook
-	notebook = gtk_notebook_new ();
-	gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook), GTK_POS_TOP);
-	gtk_container_add (GTK_CONTAINER (main_vbox), notebook);
-	gtk_widget_show (notebook);
-
-	// Create differents notebook pages
-	dialog_page1(params, notebook, preview);
-	dialog_page2(params, notebook, preview);
-
-	// Display dialog 
-	gtk_widget_show(dialog);
-	gboolean run = gimp_dialog_run(GIMP_DIALOG(dialog)) == GTK_RESPONSE_OK;
-	gtk_widget_destroy(dialog);
-	return run;
-}
-
-//----------------------------------------------------------------------------
-
-void process_flush()
-{
-	if (image.is_preview) {
-		gimp_drawable_preview_draw_region(
-				GIMP_DRAWABLE_PREVIEW(image.preview), 
-				&image.dst_rgn);
-	} else {
-		gimp_drawable_flush (image.drawable);
-		gimp_drawable_merge_shadow (image.drawable->drawable_id, TRUE);
-		gimp_drawable_update (image.drawable->drawable_id,
-				image.sel_x1, image.sel_y1, image.sel_width, image.sel_height);
-		if (image.run_mode != GIMP_RUN_NONINTERACTIVE) gimp_displays_flush ();
-	}
-}
-
-//----------------------------------------------------------------------------
-
-void set_params()
-{
-#define SET(X) greyc.X = greyc_params.X
-	SET(sigma);
-	SET(nb_iter);
-	SET(dt);
-	SET(dlength);
-	SET(power1);
-	SET(power2);
-	SET(onormalize);
-	SET(gauss_prec);
-	SET(linear);
-#undef SET
-}
-
-//----------------------------------------------------------------------------
-
-bool DoGREYCstoration(GimpPreview *preview, GimpDrawable *drawable)
-{
-	if (!gimp_drawable_is_rgb (drawable->drawable_id)) return false;
-	if (image.run_mode != GIMP_RUN_NONINTERACTIVE) 
-		gimp_progress_update (0);
-	image.init(drawable, preview);
-	set_params();
-	greyc.load_picture(image);
-	if (!greyc.process()) return false;
-	greyc.store_picture(image);
-	process_flush();	
-	return true;
-}
-
-//----------------------------------------------------------------------------
-

Deleted: haypo/greycstoration_gimp/dialog.h
===================================================================
--- greycstoration_gimp/dialog.h	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/dialog.h	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,51 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_DIALOG_H
-#define GREYCSTORATION_DIALOG_H
-//----------------------------------------------------------------------------
-#include <libgimp/gimp.h>
-#include <libgimp/gimpui.h>
-//----------------------------------------------------------------------------
-
-typedef struct GREYCstoration_params
-{
-	gint nb_iter; // Number of smoothing iterations
-	gfloat dt;       // Time step
-	gfloat dlength; // Integration step
-	gfloat dtheta; // Angular step (in degrees)
-	gfloat sigma;  // Structure tensor blurring
-	gfloat power1; // Diffusion limiter along isophote
-	gfloat power2; // Diffusion limiter along gradient
-	gfloat gauss_prec; //  Precision of the gaussian function
-	gboolean onormalize; // Output image normalization (in [0,255])
-	gboolean linear; // Use linear interpolation for integration ?
-	gboolean preview; // Use preview ?
-	GREYCstoration_params();
-} GREYCstoration_params;
-
-extern GREYCstoration_params greyc_params;
-
-//----------------------------------------------------------------------------
-
-bool dialog(GREYCstoration_params &params, GimpDrawable *drawable);
-
-bool DoGREYCstoration(GimpPreview *preview, GimpDrawable *drawable);
-//----------------------------------------------------------------------------
-#endif

Deleted: haypo/greycstoration_gimp/greycstoration.cpp
===================================================================
--- greycstoration_gimp/greycstoration.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/greycstoration.cpp	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,592 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "greycstoration.h"
-//----------------------------------------------------------------------------
-using namespace cimg_library;
-typedef unsigned char uchar;
-
-// The line below is necessary for compilation with non-standart C++ compilers.
-#if (( defined(_MSC_VER) && _MSC_VER<=1200 ) || defined(__DMC__))
-#  define std
-#endif
-//----------------------------------------------------------------------------
-
-void get_geom(const char *geom, int &geom_w, int &geom_h) 
-{
-	char tmp[16];
-	std::sscanf(geom,"%d%7[^0-9]%d%7[^0-9]",&geom_w,tmp,&geom_h,tmp+1);
-	if (tmp[0]=='%') geom_w=-geom_w;
-	if (tmp[1]=='%') geom_h=-geom_h;
-}
-
-//----------------------------------------------------------------------------
-
-GREYCstoration::GREYCstoration() : eigen(CImg<>(2,1), CImg<>(2,2))
-{
-	restore = true;
-	inpaint = false;
-	resize = false;
-	visuflow = NULL;
-
-	/* restore */
-	nb_iter        = 1;
-	dt             = 20.0f;
-	sigma          = 0.8f;
-	dlength        = 0.8;
-	dtheta         = 45.0;
-	onormalize     = false;
-	power1         = 0.5;
-	power2         = 0.9;
-
-	/* inpainting *
-	nb_iter                    = 100;
-	dt                         = 50.0f;
-	sigma                      = 2.0;
-	power1                     = 0.1;
-	power2                     = 100;
-	dlength                    = 0.8;
-	dtheta                     = 45.0;
-	 */
-
-	/* resize *
-	nb_iter           = 1;
-	dt                = 30.0f;
-	sigma             = 2.0;
-	dlength           = 0.8;
-	dtheta            = 45.0;
-	power1            = 0.01;
-	power2            = 100.0;
-	 */
-
-	/* visualflow *
-	nb_iter              = 1;
-	dt                   = 30.0f;
-	dlength              = 0.5;
-	dtheta               = 20.0;
-	onormalize = false;
-	*/
-	
-	gauss_prec  = 3.0f;
-	linear = true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::cleanup()
-{
-	img0 = flow = G = dest = sum= W = CImg<>();	
-	mask = CImg<uchar> ();
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare()
-{
-	if (!restore && !inpaint && !resize && !visuflow) 
-	{
-		g_message ("You must specify one of the restore, inpaint, resize or flow mode !");
-		return false;
-	}
-
-	// Init algorithm parameters
-	//---------------------------
-	if (restore) if (!prepare_restore()) return false;
-	if (inpaint) if (!prepare_inpaint()) return false;
-	if (resize) if (!prepare_resize()) return false;
-	if (visuflow) if (!prepare_visuflow()) return false;
-
-	if (!check_args()) return false;
-
-	// Init images
-	//------------
-	dest = CImg<>(img.width,img.height,1,img.dim);
-	sum = CImg<>(img.width,img.height,1);
-	W = CImg<>(img.width,img.height,1,2);
-	
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::check_args()
-{
-	if (power2 < power1)
-	{
-		g_message ("Error : p2<p1 !");
-		return false;
-	}
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_restore()
-{
-	CImgStats stats(img,false);
-	img.normalize((float)stats.min, (float)stats.max);
-	img0=img;
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_inpaint()
-{
-	const char *file_m         = NULL; //cimg_option("-m",(const char*)NULL,"Input inpainting mask");
-	if (!file_m) 
-	{
-		g_message ("You need to specify an inpainting mask (option '-m') !");
-		return false;
-	}
-
-	const unsigned int dilate  = 0; //cimg_option("-dilate",0,"Inpainting mask dilatation");
-	const unsigned int ip_init = 3; //cimg_option("-init",3,"Inpainting init (0=black, 1=white, 2=noise, 3=unchanged, 4=interpol)");
-	if (cimg::strncasecmp("block",file_m,5)) mask = CImg<uchar>(file_m);
-	else {
-		int l=16; std::sscanf(file_m,"block%d",&l);
-		mask = CImg<uchar>(img.width/l,img.height/l);
-		cimg_mapXY(mask,x,y) mask(x,y)=(x+y)%2;
-	}
-	mask.resize(img.width,img.height,1,1);
-	if (dilate) mask.dilate(dilate);
-	switch (ip_init) {
-		case 0 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 0; } break;
-		case 1 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = 255; } break;
-		case 2 : { cimg_mapXYV(img,x,y,k) if (mask(x,y)) img(x,y,k) = (float)(255*cimg::rand()); } break;
-		case 3 : break;
-		case 4 : {
-					 CImg<uchar> tmask(mask),ntmask(tmask);
-					 CImg_3x3(M,uchar);
-					 CImg_3x3(I,float);
-					 while (CImgStats(ntmask,false).max>0) {
-						 cimg_map3x3(tmask,x,y,0,0,M) if (Mcc && (!Mpc || !Mnc || !Mcp || !Mcn)) {
-							 const float ccp = Mcp?0.0f:1.0f, cpc = Mpc?0.0f:1.0f,
-								   cnc = Mnc?0.0f:1.0f, ccn = Mcn?0.0f:1.0f, csum = ccp + cpc + cnc + ccn;
-							 cimg_mapV(img,k) {
-								 cimg_get3x3(img,x,y,0,k,I);
-								 img(x,y,k) = (ccp*Icp + cpc*Ipc + cnc*Inc + ccn*Icn)/csum;
-							 }
-							 ntmask(x,y) = 0;
-						 }
-						 tmask = ntmask;
-					 }
-				 } break;    
-		default: break;
-	}
-	img0=img;
-	G = CImg<>(img.width,img.height,1,3,0);
-	CImg_3x3(g,uchar);
-	CImg_3x3(I,float);
-	cimg_map3x3(mask,x,y,0,0,g) if (!gcc && !(gnc-gcc) && !(gcc-gpc) && !(gcn-gcc) && !(gcc-gcp)) cimg_mapV(img,k) {
-		cimg_get3x3(img,x,y,0,k,I);
-		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
-		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
-	}
-	G.blur(sigma);
-	{ cimg_mapXY(G,x,y) 
-		{
-			G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
-			const float
-				l1 = eigen(0)[0],
-				   l2 = eigen(0)[1],
-				   u = eigen(1)[0],
-				   v = eigen(1)[1],      
-				   ng = (float)std::sqrt(l1+l2),
-				   n1 = (float)(1.0/std::pow(1+ng,power1)),
-				   n2 = (float)(1.0/std::pow(1+ng,power2)),
-				   sr1 = (float)std::sqrt(n1),
-				   sr2 = (float)std::sqrt(n2);
-			G(x,y,0) = sr1*u*u + sr2*v*v;
-			G(x,y,1) = u*v*(sr1-sr2);
-			G(x,y,2) = sr1*v*v + sr2*u*u;
-		}    
-	}
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_resize()
-{
-	const char *geom  = NULL; //cimg_option("-g",(const char*)NULL,"Output image geometry");
-	const bool anchor = true; //cimg_option("-anchor",true,"Anchor original pixels");
-	if (!geom) throw CImgArgumentException("You need to specify an output geomety (option -g)");
-	int w,h; get_geom(geom,w,h);
-	mask = CImg<uchar>(img.width,img.height,1,1,255);
-	if (!anchor) mask.resize(w,h,1,1,1); else mask = ~mask.resize(w,h,1,1,4);
-	img0 = img.get_resize(w,h,1,-100,1);
-	img.resize(w,h,1,-100,3);
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::prepare_visuflow()
-{
-	const char *geom     = "100%x100%"; //cimg_option("-g","100%x100%","Output geometry");
-	//const char *file_i   = (const char *)NULL; //cimg_option("-i",(const char*)NULL,"Input init image");
-	const bool normalize = false; //cimg_option("-norm",false,"Normalize input flow");
-
-	int w,h; get_geom(geom,w,h);
-	if (!cimg::strcasecmp(visuflow,"circle")) { // Create a circular vector flow
-		flow = CImg<>(400,400,1,2);
-		cimg_mapXY(flow,x,y) {
-			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
-			flow(x,y,0) = -(float)std::sin(ang);
-			flow(x,y,1) = (float)std::cos(ang);
-		}
-	}
-	if (!cimg::strcasecmp(visuflow,"radial")) { // Create a radial vector flow
-		flow = CImg<>(400,400,1,2);
-		cimg_mapXY(flow,x,y) {
-			const float ang = (float)(std::atan2(y-0.5*flow.dimy(),x-0.5*flow.dimx()));
-			flow(x,y,0) = (float)std::cos(ang);
-			flow(x,y,1) = (float)std::sin(ang);
-		}
-	}
-	if (!flow.data) flow = CImg<>(visuflow);
-	flow.resize(w,h,1,2,3);
-	if (normalize) flow.orientation_pointwise();
-	/*    if (file_i) img = CImg<>(file_i);
-		  else img = CImg<>(flow.width,flow.height,1,1,0).noise(100,2); */
-	img0=img;
-	img0.fill(0);
-	float color[3]={255,255,255};
-	img0.draw_quiver(flow,color,15,-10);
-	G = CImg<>(img.width,img.height,1,3);
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_smoothed_tensor()
-{
-	if (visuflow || inpaint) return;
-	CImg_3x3(I,float);
-	G.fill(0);
-	cimg_mapV(img,k) cimg_map3x3(img,x,y,0,k,I) {
-		const float ix = 0.5f*(Inc-Ipc), iy = 0.5f*(Icn-Icp);
-		G(x,y,0)+= ix*ix; G(x,y,1)+= ix*iy; G(x,y,2)+= iy*iy;    
-	}
-	G.blur(sigma);
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_normalized_tensor()
-{
-	if (restore || resize) cimg_mapXY(G,x,y) {
-		G.get_tensor(x,y).symeigen(eigen(0),eigen(1));
-		const float
-			l1 = eigen(0)[0],
-			   l2 = eigen(0)[1],
-			   u = eigen(1)[0],
-			   v = eigen(1)[1],      
-			   n1 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power1)),
-			   n2 = (float)(1.0/std::pow(1.0f+l1+l2,0.5f*power2));
-		G(x,y,0) = n1*u*u + n2*v*v;
-		G(x,y,1) = u*v*(n1-n2);
-		G(x,y,2) = n1*v*v + n2*u*u;
-	}    
-	if (visuflow) cimg_mapXY(G,x,y) {
-		const float 
-			u = flow(x,y,0),
-			  v = flow(x,y,1),
-			  n = (float)std::pow(u*u+v*v,0.25f),
-			  nn = n<1e-5?1:n;
-		G(x,y,0) = u*u/nn;
-		G(x,y,1) = u*v/nn;
-		G(x,y,2) = v*v/nn;
-	}
-
-	const CImgStats stats(G,false);
-	G /= cimg::max(std::fabs(stats.max), std::fabs(stats.min));
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_W(float cost, float sint)
-{
-	cimg_mapXY(W,x,y) {
-		const float 
-			a = G(x,y,0),
-			  b = G(x,y,1),
-			  c = G(x,y,2),
-			  u = a*cost + b*sint,
-			  v = b*cost + c*sint;
-		W(x,y,0) = u;
-		W(x,y,1) = v;
-	}
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_LIC_back_forward(int x, int y)
-{
-	float l, X,Y, cu, cv, lsum=0;
-	const float fsigma2 = 2*dt*(W(x,y,0)*W(x,y,0) + W(x,y,1)*W(x,y,1));
-	const float length = gauss_prec*(float)std::sqrt(fsigma2);
-
-	if (linear) {
-
-		// Integrate with linear interpolation
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = (float)x; 
-		Y  = (float)y;
-		for (l=0; l<length; l+=dlength) 
-		{
-			float u = (float)W.linear_pix2d(X,Y,0);
-			float v = (float)W.linear_pix2d(X,Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X+=dlength*u;
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y+=dlength*v; 
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-		
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = x-dlength*cu; 
-		Y  = y-dlength*cv;
-		for (l=dlength; l<length; l+=dlength) 
-		{
-			float u = (float)W.linear_pix2d(X,Y,0);
-			float v = (float)W.linear_pix2d(X,Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k)+=(float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X-=dlength*u;
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y-=dlength*v;
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u;
-			cv=v;
-		}
-
-	} else {
-
-		// Integrate with non linear interpolation
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = (float)x; 
-		Y  = (float)y; 
-		for (l=0; l<length; l+=dlength) 
-		{
-			float u = W((int)X,(int)Y,0);
-			float v = W((int)X,(int)Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X+=dlength*u; 
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y+=dlength*v; 
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-		
-		cu = W(x,y,0); 
-		cv = W(x,y,1); 
-		X  = x-dlength*cu; 
-		Y  = y-dlength*cv;
-		for (l=dlength; l<length && X>=0 && Y>=0 && X<=W.dimx()-1 && Y<=W.dimy()-1; l+=dlength) 
-		{
-			float u = W((int)X,(int)Y,0);
-			float v = W((int)X,(int)Y,1);
-			const float coef = (float)std::exp(-l*l/fsigma2);
-			if ((cu*u+cv*v)<0) { u=-u; v=-v; }
-			cimg_mapV(dest,k) dest(x,y,k) += (float)(coef*img.linear_pix2d(X,Y,k));
-			lsum+=coef;
-			X-=dlength*u; 
-			if ((X<0) || ((W.dimx()-1) < X)) break;
-			Y-=dlength*v;
-			if ((Y<0) || ((W.dimy()-1) < Y)) break;
-			cu=u; 
-			cv=v; 
-		}
-	}
-	sum(x,y)+=lsum;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_LIC(int &counter)
-{
-	dest.fill(0);
-	sum.fill(0);
-	for (float theta=(180%(int)dtheta)/2.0f; theta<180; theta+=dtheta) 
-	{
-		const float
-			rad = (float)(theta*cimg::PI/180.0),
-				cost = (float)std::cos(rad),
-				sint = (float)std::sin(rad);
-
-		// Compute vector field w = sqrt(T)*a_alpha
-		compute_W(cost, sint);
-
-		// Compute the LIC along w in backward and forward directions
-		cimg_mapXY(dest,x,y) 
-		{
-			counter++;
-			if (image.use_progress && !((counter)%100000)) 
-			{
-				gdouble progress = counter;
-				progress /= (gdouble)dest.width*dest.height*nb_iter*(180/dtheta);
-				gimp_progress_update (progress);
-			}
-			
-			if (!mask.data || mask(x,y)) compute_LIC_back_forward(x,y);
-		}
-	}
-
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::compute_average_LIC()
-{
-	cimg_mapXY(dest,x,y) 
-	{
-		if (sum(x,y)>0) 
-			cimg_mapV(dest,k) dest(x,y,k) /= sum(x,y); 
-		else 
-			cimg_mapV(dest,k) dest(x,y,k) = img(x,y,k);
-	}
-}
-
-//----------------------------------------------------------------------------
-
-bool GREYCstoration::process()
-{
-	if (!prepare()) return false;
-
-	//-------------------------------------
-	// Begin regularization PDE iterations
-	//-------------------------------------
-	int counter = 0;
-	for (unsigned int iter=0; iter<nb_iter; iter++) 
-	{
-		// Compute smoothed structure tensor field G
-		compute_smoothed_tensor();
-
-		// Compute normalized tensor field sqrt(T) in G
-		compute_normalized_tensor();
-
-		// Compute LIC's along different angle projections a_\alpha
-		compute_LIC(counter);
-
-		// Average all the LIC's
-		compute_average_LIC();
-
-		// Next step
-		img = dest;
-	}
-
-	// Save result and end program
-	//-----------------------------
-	if (visuflow) dest.mul(flow.get_norm_pointwise()).normalize(0,255);
-	if (onormalize) dest.normalize(0,255);
-	cleanup();
-	return true;
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::load_picture(Image &cfg)
-{
-	guchar* row = g_new (guchar, cfg.width), *row_ptr;
-
-	img = CImg<>(cfg.sel_width, cfg.sel_height, 1, 3);
-
-	for (gint y=0; y < cfg.sel_height; y++)
-	{
-		gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		row_ptr = row;
-		if (image.img_alpha) {
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				img(x, y,0) = row_ptr[0];
-				img(x, y,1) = row_ptr[1];
-				img(x, y,2) = row_ptr[2];
-				row_ptr += 4;
-			}	
-		} else {
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				img(x, y,0) = row_ptr[0];
-				img(x, y,1) = row_ptr[1];
-				img(x, y,2) = row_ptr[2];
-				row_ptr += 3;
-			}	
-		}
-	}
-	g_free (row);
-}
-
-//----------------------------------------------------------------------------
-
-void GREYCstoration::store_picture(Image &cfg)
-{
-	guchar* row = g_new (guchar, cfg.width), *row_ptr;
-
-	if (image.img_alpha)
-	{
-		for (gint y=0; y < cfg.sel_height; y++)
-		{
-			gimp_pixel_rgn_get_row (&cfg.src_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-			row_ptr = row;
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
-				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
-				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
-				row_ptr += 4;
-			}
-			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		}
-	} else {
-		for (gint y=0; y < cfg.sel_height; y++)
-		{
-			row_ptr = row;
-			for (gint x=0; x<cfg.sel_width; x++) 
-			{
-				row_ptr[0] = static_cast<uchar>( img(x, y, 0) );
-				row_ptr[1] = static_cast<uchar>( img(x, y, 1) );
-				row_ptr[2] = static_cast<uchar>( img(x, y, 2) );
-				row_ptr += 3;
-			}
-			gimp_pixel_rgn_set_row (&cfg.dst_rgn, row, cfg.sel_x1, cfg.sel_y1+y, cfg.sel_width);
-		}
-	}
-
-	g_free (row);
-}
-
-//----------------------------------------------------------------------------

Deleted: haypo/greycstoration_gimp/greycstoration.h
===================================================================
--- greycstoration_gimp/greycstoration.h	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/greycstoration.h	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,90 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_CLASS_H
-#define GREYCSTORATION_CLASS_H
-//----------------------------------------------------------------------------
-#include "CImg.h"
-#include "image.h"
-//----------------------------------------------------------------------------
-
-class GREYCstoration
-{
-public:
-	// parameters
-	unsigned int nb_iter; // Number of smoothing iterations
-	float dt;       // Time step
-	float dlength; // Integration step
-	float dtheta; // Angular step (in degrees)
-	float sigma;  // Structure tensor blurring
-	float power1; // Diffusion limiter along isophote
-	float power2; // Diffusion limiter along gradient
-	float gauss_prec; //  Precision of the gaussian function
-	bool onormalize; // Output image normalization (in [0,255])
-	bool linear; // Use linear interpolation for integration
-
-private:
-	// internal use
-	bool restore;
-	bool inpaint;
-	bool resize;
-	const char* visuflow;
-	cimg_library::CImg<> dest, sum, W;
-	cimg_library::CImg<> img, img0, flow,G;
-	cimg_library::CImgl<> eigen;
-	cimg_library::CImg<unsigned char> mask;
-
-public:
-	GREYCstoration();
-	void load_picture(Image& image);
-	void store_picture(Image& image);
-	bool process();
-
-private:
-	// Compute smoothed structure tensor field G
-	void compute_smoothed_tensor();
-	
-	// Compute normalized tensor field sqrt(T) in G
-	void compute_normalized_tensor();
-	
-	// Compute LIC's along different angle projections a_\alpha
-	void compute_LIC(int &counter);
-	void compute_LIC_back_forward(int x, int y);
-	void compute_W(float cost, float sint);
-	
-	// Average all the LIC's
-	void compute_average_LIC();
-
-	// Prepare datas
-	bool prepare();
-	bool prepare_restore();
-	bool prepare_inpaint();
-	bool prepare_resize();
-	bool prepare_visuflow();
-
-	// Check arguments
-	bool check_args();
-
-	// Clean up memory (CImg datas) to save memory
-	void cleanup();
-};
-
-extern GREYCstoration greyc;
-//----------------------------------------------------------------------------
-#endif

Deleted: haypo/greycstoration_gimp/image.cpp
===================================================================
--- greycstoration_gimp/image.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/image.cpp	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,58 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "image.h"
-//----------------------------------------------------------------------------
-
-Image::Image()
-{
-	drawable = NULL;
-	run_mode = GIMP_RUN_NONINTERACTIVE;
-}
-
-//----------------------------------------------------------------------------
-
-void Image::init(GimpDrawable *pdrawable, GimpPreview *ppreview)
-{
-	drawable = pdrawable;
-	preview = ppreview;
-	if (ppreview) {
-		is_preview = true;
-		gimp_preview_get_position(preview, &sel_x1, &sel_y1);
-		gimp_preview_get_size(preview, &sel_width, &sel_height);
-		sel_x2 = sel_x1 + sel_width;	
-		sel_y2 = sel_y1 + sel_height;	
-	} else {
-		is_preview = false;
-		gimp_drawable_mask_bounds (drawable->drawable_id,
-				&sel_x1, &sel_y1, &sel_x2, &sel_y2);
-		sel_width  = sel_x2 - sel_x1;
-		sel_height = sel_y2 - sel_y1;
-	}
-	img_bpp   = gimp_drawable_bpp (drawable->drawable_id);
-	img_alpha = gimp_drawable_has_alpha (drawable->drawable_id);
-	gimp_pixel_rgn_init (&src_rgn, drawable,
-			sel_x1, sel_y1, sel_width, sel_height, FALSE, FALSE);
-	gimp_pixel_rgn_init (&dst_rgn, drawable,
-			sel_x1, sel_y1, sel_width, sel_height, !is_preview, TRUE);
-	width = sel_width * img_bpp;
-	use_progress = (run_mode != GIMP_RUN_NONINTERACTIVE) && !is_preview;
-}
-
-//----------------------------------------------------------------------------

Deleted: haypo/greycstoration_gimp/image.h
===================================================================
--- greycstoration_gimp/image.h	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/image.h	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,52 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_IMAGE_H
-#define GREYCSTORATION_IMAGE_H
-//----------------------------------------------------------------------------
-#include <libgimp/gimp.h>
-#include <libgimp/gimpui.h>
-//----------------------------------------------------------------------------
-
-class Image
-{
-public:
-	GimpDrawable *drawable;   /* Current image */
-	GimpPixelRgn src_rgn, dst_rgn;
-	gint       sel_x1;               /* Selection bounds */
-	gint       sel_y1;
-	gint       sel_x2;
-	gint       sel_y2;
-	gint       sel_width;            /* Selection width */
-	gint       sel_height;           /* Selection height */
-	gint       img_bpp;              /* Bytes-per-pixel in image */
-	bool		img_alpha;
-	guint		width;
-	bool		is_preview;
-	GimpPreview*	preview;
-	bool 		use_progress;
-	GimpRunMode run_mode;
-public:
-	Image();
-	void init(GimpDrawable *drawable, GimpPreview *preview);
-};
-
-extern Image image;
-//----------------------------------------------------------------------------
-#endif

Deleted: haypo/greycstoration_gimp/main.cpp
===================================================================
--- greycstoration_gimp/main.cpp	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/main.cpp	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,141 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include <libgimp/gimp.h>
-#include "plug_in.h"
-#include "dialog.h"
-#include "greycstoration.h"
-#include <unistd.h>
-
-//----------------------------------------------------------------------------
-GREYCstoration greyc;
-GREYCstoration_params greyc_params;
-Image image;
-//----------------------------------------------------------------------------
-
-static void query(void);
-static void run (const gchar* name,
-		gint nparams,
-		const GimpParam* param,
-		gint* nreturn_vals,
-		GimpParam** return_vals);
-
-//----------------------------------------------------------------------------
-
-GimpPlugInInfo PLUG_IN_INFO = 
-{
-	NULL,
-	NULL,
-	query,
-	run
-};
-
-//----------------------------------------------------------------------------
-
-MAIN()
-
-//----------------------------------------------------------------------------
-
-static void query(void)
-{
-	static GimpParamDef args[] =
-	{
-		{
-			GIMP_PDB_INT32,
-			"run_mode",
-			"Run mode"
-		},{
-			GIMP_PDB_IMAGE,
-			"image",
-			"Input image"
-		},{
-			GIMP_PDB_DRAWABLE,
-			"drawable",
-			"Input drawable"
-		}
-	};
-	gimp_install_procedure (
-			"plug_in_hello",
-			PLUG_IN_NAME,
-			"Filtre Greystoration",
-			"Victor STINNER",
-			"Copyright Victor STINNER",
-			"2005",
-			"<Image>/Filters/Misc/_GREYCstoration",
-			"RGB*", //GRAY*
-			GIMP_PLUGIN,
-			G_N_ELEMENTS(args), 0,
-			args, NULL);
-}
-
-//----------------------------------------------------------------------------
-
-static void run (const gchar* name,
-		gint nparams,
-		const GimpParam* param,
-		gint* nreturn_vals,
-		GimpParam** return_vals)
-{
-	static GimpParam values[1];
-	GimpPDBStatusType status = GIMP_PDB_SUCCESS;
-
-	/* Reduce the processes importance so that it doesn't make the computer 
-	   non-interactive */
-	nice(19);
-
-	/* Mise en place d'une valeur obligatoire de retour */
-	*nreturn_vals = 1;
-	*return_vals = values;
-
-	values[0].type = GIMP_PDB_STATUS;
-	values[0].data.d_status = status;
-
-	image.run_mode = static_cast<GimpRunMode> (param[0].data.d_int32);
-	GimpDrawable *drawable = gimp_drawable_get (param[2].data.d_drawable);
-	
-	switch (image.run_mode)
-	{
-		case GIMP_RUN_INTERACTIVE:
-			gimp_get_data("plug_in_" PLUG_IN_NAME, &greyc_params);
-			if (!dialog(greyc_params, drawable)) return;
-			gimp_set_data("plug_in_" PLUG_IN_NAME, &greyc_params, sizeof(greyc_params));
-			break;
-			
-		case GIMP_RUN_NONINTERACTIVE:
-return;
-			break;
-
-		case GIMP_RUN_WITH_LAST_VALS:
-			gimp_get_data("plug_in_" PLUG_IN_NAME, &greyc_params);
-			break;
-		default: return;
-	}
-
-	if (!DoGREYCstoration(NULL, drawable)) 
-	{
-		if (image.run_mode != GIMP_RUN_NONINTERACTIVE)
-			g_message ("Erreur !?");
-		status = GIMP_PDB_EXECUTION_ERROR;
-		values[0].data.d_status = status;
-	}
-	gimp_drawable_detach (drawable);
-}
-
-//----------------------------------------------------------------------------
-

Deleted: haypo/greycstoration_gimp/plug_in.h
===================================================================
--- greycstoration_gimp/plug_in.h	2005-11-17 21:20:01 UTC (rev 256)
+++ haypo/greycstoration_gimp/plug_in.h	2005-11-21 23:33:10 UTC (rev 261)
@@ -1,25 +0,0 @@
-/* GREYCstoration Gimp plugin
- * Copyright (C) 2005 Victor Stinner and David Tschumperl?
- *
- * This plug-in is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef GREYCSTORATION_PLUGIN_H
-#define GREYCSTORATION_PLUGIN_H
-//----------------------------------------------------------------------------
-#define PLUG_IN_NAME "greycstoration"
-//----------------------------------------------------------------------------
-#endif

Copied: haypo/greycstoration_gimp/po (from rev 260, greycstoration_gimp/po)

Copied: haypo/greycstoration_gimp/src (from rev 260, greycstoration_gimp/src)

Copied: haypo/poilu (from rev 256, poilu)

Copied: haypo/trouphp (from rev 256, trouphp)

Copied: haypo/turing (from rev 256, turing)



From haypo at berlios.de  Mon Nov 28 00:23:58 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 28 Nov 2005 00:23:58 +0100
Subject: [Happyboom-svn] r278 - in haypo/hachoir: . plugins
Message-ID: <200511272323.jARNNwxQ031643@sheep.berlios.de>

Author: haypo
Date: 2005-11-28 00:23:58 +0100 (Mon, 28 Nov 2005)
New Revision: 278

Added:
   haypo/hachoir/plugins/elf.py
Modified:
   haypo/hachoir/export.template
Log:
Add very alpha ELF filter.


Modified: haypo/hachoir/export.template
===================================================================
--- haypo/hachoir/export.template	2005-11-27 21:13:34 UTC (rev 277)
+++ haypo/hachoir/export.template	2005-11-27 23:23:58 UTC (rev 278)
@@ -6,8 +6,11 @@
 """
 
 from filter import Filter
+from plugins import registerPlugin
 
 class MyFilter(Filter):
-    def __init__(self, stream):
-        Filter.__init__(self, "{id}", "{description}", stream, None)
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "{id}", "{description}", stream, parent)
 {chunks}
+
+#registerPlugin(MyFilter, "<MIME type>")

Added: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-11-27 21:13:34 UTC (rev 277)
+++ haypo/hachoir/plugins/elf.py	2005-11-27 23:23:58 UTC (rev 278)
@@ -0,0 +1,66 @@
+"""
+ELF filter.
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+class ELF_Header(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "default", "default", stream, parent)
+        self.read("id", "4s", "Identifier")
+        good_id = chr(127) + "ELF"
+        assert self["id"] == good_id 
+        self.read("class", "B", "Class")
+        self.read("encoding", "B", "Encoding")
+        self.read("file_version", "B", "File version")
+        self.read("pad", "8s", "Pad")
+        self.read("nident", "B", "Size of ident[]")
+        self.read("type", "<H", "File fype", post=self.getType)
+        self.read("machine", "<H", "Machine type", post=self.getMachine)
+        self.read("version", "<L", "Version of ELF")
+        self.read("entry", "<L", "Number of entries")
+        self.read("phoff", "<L", "PH offset")
+        self.read("shoff", "<L", "SH offset")
+        self.read("flags", "<L", "Flags")
+        self.read("ehsize", "<H", "EH size")
+        self.read("phentsize", "<H", "PH entry size")
+        self.read("phnum", "<H", "PH entry count")
+        self.read("shentsize", "<H", "SH entry size")
+        self.read("shnum", "<H", "SH entre count")
+        self.read("shstrndx", "<H", "SH strtab index")
+
+    def getType(self, chunk):
+        type = chunk.value
+        types = {
+            0: "No file type",
+            1: "Relocable file",
+            2: "Executable file",
+            3: "Shared object file",
+            4: "Core file",
+            0xFF00: "Processor-specific (0xFF00)",
+            0xFFFF: "Processor-specific (0xFFFF)"
+        }
+        return types.get(type, "Unknow type (%u)" % type)
+
+    def getMachine(self, chunk):
+        type = chunk.value
+        types = {
+            0: "No machine",
+            1: "AT&T WE 32100",
+            2: "SPARC",
+            3: "Intel 80386",
+            4: "Motorolla 68000",
+            5: "Motorolla 88000",
+            7: "Intel 80860",
+            8: "MIPS RS3000"
+        }
+        return types.get(type, "Unknow machine (%u)" % type)
+
+class ELF_Filter(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "default", "default", stream, parent)
+        self.readChild("header", ELF_Header)
+
+registerPlugin(ELF_Filter, "application/x-executable")



From haypo at berlios.de  Mon Nov 28 01:58:30 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 28 Nov 2005 01:58:30 +0100
Subject: [Happyboom-svn] r279 - in haypo/hachoir: . plugins
Message-ID: <200511280058.jAS0wUJg007003@sheep.berlios.de>

Author: haypo
Date: 2005-11-28 01:58:10 +0100 (Mon, 28 Nov 2005)
New Revision: 279

Added:
   haypo/hachoir/plugins/3ds.py
Modified:
   haypo/hachoir/format.py
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/plugins/tar.py
Log:
- Supports float and double in FormatChunk ("f" and "d").
- Create 3DS (3D Studio Max) parser
- Fix TAR plugin


Modified: haypo/hachoir/format.py
===================================================================
--- haypo/hachoir/format.py	2005-11-27 23:23:58 UTC (rev 278)
+++ haypo/hachoir/format.py	2005-11-28 00:58:10 UTC (rev 279)
@@ -1,11 +1,11 @@
 import re
 
 def checkFormat(format):
-    m = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLsc]$").match(format)
+    m = re.compile("^[!<>]?(?:[0-9]+|\{[a-z at _]+\})?[BHLscfd]$").match(format)
     return m != None
 
 def splitFormat(format):
-    m = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLsc])$").match(format)
+    m = re.compile("^([!<>]?)((?:[0-9]+|\{[a-z at _]+\})?)([BHLscfd])$").match(format)
     if m == None: return None
     endian = m.group(1)
     if endian=="": endian="!"

Added: haypo/hachoir/plugins/3ds.py
===================================================================
--- haypo/hachoir/plugins/3ds.py	2005-11-27 23:23:58 UTC (rev 278)
+++ haypo/hachoir/plugins/3ds.py	2005-11-28 00:58:10 UTC (rev 279)
@@ -0,0 +1,142 @@
+"""
+3D Studio Max file (.3ds) parser.
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+def readTextureFilename(filter, stream):
+    filter.readString("filename", "C", "Texture filename")
+
+def readVersion(filter, stream):
+    filter.read("version", "<L", "Version")
+
+def readMaterial(filter, stream):
+    filter.readString("name", "C", "Material name")
+    while not stream.eof():
+        filter.readChild("chunk[]", Filter_3DS_Chunk)
+
+def readObject(filter, stream):
+    filter.readString("name", "C", "Object name")
+    while not stream.eof():
+        filter.readChild("chunk[]", Filter_3DS_Chunk)
+
+class Filter_3DS_MapUV(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "3ds_map", "3DS UV map", stream, parent)
+        self.read("u", "f", "Map U")
+        self.read("v", "f", "Map V")
+
+class Filter_3DS_Vertex(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "3ds_vertex", "3DS vertex", stream, parent)
+        self.read("x", "f", "X")
+        self.read("y", "f", "Y")
+        self.read("z", "f", "Z")
+
+class Filter_3DS_Polygon(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "3ds_polygon", "3DS polygon", stream, parent)
+        self.read("a", "<H", "Vertex A")
+        self.read("b", "<H", "Vertex B")
+        self.read("c", "<H", "Vertex C")
+        self.read("flags", "<H", "Flags")
+    
+def readMapList(filter, stream):
+    filter.read("count", "<H", "Map count")
+    while not stream.eof():
+        filter.readChild("map[]", Filter_3DS_MapUV)
+
+def readColor(filter, stream):
+    filter.read("red", "B", "Red componant")
+    filter.read("green", "B", "Green componant")
+    filter.read("blue", "B", "Blue componant")
+
+def readVertexList(filter, stream):
+    filter.read("count", "<H", "Vertex count")
+    while not stream.eof():
+        filter.readChild("vertex[]", Filter_3DS_Vertex)
+    
+def readPolygonList(filter, stream):
+    filter.read("count", "<H", "Vertex count")
+    while not stream.eof():
+        filter.readChild("polygon[]", Filter_3DS_Polygon)
+
+class Filter_3DS_Chunk(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
+        chunk = self.read("type", "<H", "Chunk type", post=self.toHex)
+        chunk.description = "Chunk type (%s)" % self.getType()
+        self.read("size", "<L", "Chunk size")
+        types = {
+            0xA000: readMaterial,
+            0x4000: readObject,
+            0xA300: readTextureFilename,
+            0x0011: readColor,
+#            0x4110: readVertexList,
+#            0x4120: readPolygonList,
+#            0x4140: readMapList,
+            0x0002: readVersion
+        }
+        size = self["size"] - 6
+        type = self["type"] 
+        end = stream.tell() + size
+        if type in (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200, 0xA010, 0xA030, 0xA020):
+            while stream.tell() < end:
+                self.readChild("chunk[]", Filter_3DS_Chunk)
+            assert stream.tell() == end 
+        else:
+            if type in types: 
+                substream = stream.createSub(size=size)
+                types[type] (self, substream)
+            else:
+                self.read("data", "%us" % size, "Raw data")
+
+    def checkEnd(self, stream, array, last):
+        return stream.eof()
+
+    def updateParent(self, chunk):
+        type = self.getType()
+        chunk.description = "Chunk of type \"%s\"" % type
+        self.setDescription("Chunk type (%s)" % type)
+        self.setId("chunk_%04x" % self["type"])
+
+    def toHex(self, chunk):
+        return "%04X" % chunk.value
+        
+    def getType(self):
+        type = self["type"]
+        know = {
+            0x0011: "Color",
+            0x4D4D: "Main chunk",
+            0x0002: "File version",
+            0x3D3D: "Materials and objects",
+            0x4000: "Object",
+            0x4100: "Mesh (triangular)",
+            0x4110: "Vertices list",
+            0x4120: "Polygon (faces) list",
+            0x4140: "Map UV list",
+            0x4130: "Object material",
+            0xAFFF: "New material",
+            0xA000: "New material (name)",
+            0xA010: "Material ambiant",
+            0xA020: "Material diffuse",
+            0xA030: "Texture specular",
+            0xA200: "Texture",
+            0xA300: "Texture filename"
+        }
+        if type in know:
+            return know[type]
+        else:
+            return "%04X" % type 
+
+class Filter_3DS_File(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "3ds_file", "3DS file", stream, parent)
+        while not stream.eof():
+            self.readChild("chunk[]", Filter_3DS_Chunk)
+
+# TODO: What the is that!? => image/tiff
+# What's the right MIME type?
+registerPlugin(Filter_3DS_File, "image/tiff")

Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-11-27 23:23:58 UTC (rev 278)
+++ haypo/hachoir/plugins/elf.py	2005-11-28 00:58:10 UTC (rev 279)
@@ -10,8 +10,7 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "default", "default", stream, parent)
         self.read("id", "4s", "Identifier")
-        good_id = chr(127) + "ELF"
-        assert self["id"] == good_id 
+        assert self["id"] == (chr(127) + "ELF")
         self.read("class", "B", "Class")
         self.read("encoding", "B", "Encoding")
         self.read("file_version", "B", "File version")

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-27 23:23:58 UTC (rev 278)
+++ haypo/hachoir/plugins/tar.py	2005-11-28 00:58:10 UTC (rev 279)
@@ -80,12 +80,12 @@
     def __init__(self, stream, parent):
         Filter.__init__(self, "tar_file_entry","Tar file entry", stream, parent)
         self.read("name", "!100s", "Name", truncate=False, post=self.stripNul)
-        self.name = self.name.strip("\0")
+        self.name = self["name"].strip("\0")
         self.read("mode", "!8s", "Mode", post=self.convertOctal)
         self.read("uid", "!8s", "User ID", post=self.convertOctal)
         self.read("gid", "!8s", "Group ID", post=self.convertOctal)
         self.read("size", "!12s", "Size", post=self.convertOctal)
-        self.size = self.octal2int(self.size)
+        self.size = self.octal2int(self["size"])
         self.read("mtime", "!12s", "Modification time", self.getTime)
         self.read("check_sum", "!8s", "Check sum")
         self.read("type", "!c", "Type")
@@ -96,7 +96,7 @@
         self.read("devmajor", "!8s", "Dev major")
         self.read("devminor", "!8s", "Dev minor")
         self.read("header_padding", "!167s", "Padding (zero)")
-        if self.type in ("\0", "0"):
+        if self["type"] in ("\0", "0"):
             substream = stream.createSub(stream.tell(), self.size)
             plugin = guessPlugin(substream, self.name)
 
@@ -139,8 +139,7 @@
             "6": "FIFO special file",
             "7": "Contiguous file"
         }
-        if self.type not in name: return "Unknow type (%02X)" % ord(self.type)
-        return name[self.type]
+        name.get(self["type"], "Unknow type (%02X)" % ord(self["type"]))
 
     def updateParent(self, chunk):
         if not self.isEmpty():
@@ -148,7 +147,8 @@
                 % (self.name, self.getType(), humanFilesize(self.size))
         else:
             text = "Tar File (terminator, empty header)"
-        chunk.description = self.description = text
+        chunk.description = text
+        self.setDescription(text)
 
 class TarFile(Filter):
     def __init__(self, stream, parent=None):



From haypo at berlios.de  Mon Nov 28 03:52:42 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 28 Nov 2005 03:52:42 +0100
Subject: [Happyboom-svn] r280 - in haypo/hachoir: . plugins
Message-ID: <200511280252.jAS2qgMr014287@sheep.berlios.de>

Author: haypo
Date: 2005-11-28 03:52:23 +0100 (Mon, 28 Nov 2005)
New Revision: 280

Added:
   haypo/hachoir/plugins/exif.py
Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/mime.py
   haypo/hachoir/plugins/3ds.py
   haypo/hachoir/plugins/jpeg.py
Log:
- 3DS filter: add keyframe identifiers
- Create EXIF filter (eg. for JPEG pictures)
- In JPEG chunk, use sub-stream, and supports Exif
- Fix FormatChunk.getValue() -> don't change stream position
- Fix Filter.readStreamChild() stream seek (use parent stream old
  position and no more chunk address)


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-28 00:58:10 UTC (rev 279)
+++ haypo/hachoir/chunk.py	2005-11-28 02:52:23 UTC (rev 280)
@@ -203,12 +203,15 @@
 
     def _getRawData(self, max_size=None):
         stream = self._chunk.getStream()
+        oldpos = stream.tell()
         stream.seek(self._addr)
         if (max_size == None or self._size<max_size) or not self._chunk.isString():
             data = stream.getN(self._size)
+            stream.seek(oldpos)
             return data, False
         else:
             data = stream.getN(max_size)
+            stream.seek(oldpos)
             return data+"(...)", True
 
     def update(self):

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-28 00:58:10 UTC (rev 279)
+++ haypo/hachoir/filter.py	2005-11-28 02:52:23 UTC (rev 280)
@@ -335,7 +335,7 @@
         filter.setId(id)
         chunk = self.addFilter(id, filter, oldpos)
         chunk.postProcess()
-        self._stream.seek(chunk.addr + chunk.size)
+        self._stream.seek(oldpos + chunk.size)
         return chunk
         
     def readChild(self, id, filter_class, *args): 

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-28 00:58:10 UTC (rev 279)
+++ haypo/hachoir/mime.py	2005-11-28 02:52:23 UTC (rev 280)
@@ -44,7 +44,6 @@
       => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
     """
     
-    print mimes
     list = []
     for mime in map(string.strip, mimes.split(",")):
         parts = mime.split(";")

Modified: haypo/hachoir/plugins/3ds.py
===================================================================
--- haypo/hachoir/plugins/3ds.py	2005-11-28 00:58:10 UTC (rev 279)
+++ haypo/hachoir/plugins/3ds.py	2005-11-28 02:52:23 UTC (rev 280)
@@ -64,6 +64,12 @@
         filter.readChild("polygon[]", Filter_3DS_Polygon)
 
 class Filter_3DS_Chunk(Filter):
+    # List of chunks which contains other chunks
+    sub_chunks = \
+        (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200,
+         0xB002, 0xB006, 0xB007,
+         0xA010, 0xA030, 0xA020, 0xB000)
+    
     def __init__(self, stream, parent):
         Filter.__init__(self, "3ds_chunk", "3DS chunk", stream, parent)
         chunk = self.read("type", "<H", "Chunk type", post=self.toHex)
@@ -74,6 +80,7 @@
             0x4000: readObject,
             0xA300: readTextureFilename,
             0x0011: readColor,
+# TODO: Uncomment these functions, it's too slow yet            
 #            0x4110: readVertexList,
 #            0x4120: readPolygonList,
 #            0x4140: readMapList,
@@ -82,7 +89,7 @@
         size = self["size"] - 6
         type = self["type"] 
         end = stream.tell() + size
-        if type in (0x4D4D, 0x4100, 0x3D3D, 0xAFFF, 0xA200, 0xA010, 0xA030, 0xA020):
+        if type in Filter_3DS_Chunk.sub_chunks:
             while stream.tell() < end:
                 self.readChild("chunk[]", Filter_3DS_Chunk)
             assert stream.tell() == end 
@@ -124,7 +131,18 @@
             0xA020: "Material diffuse",
             0xA030: "Texture specular",
             0xA200: "Texture",
-            0xA300: "Texture filename"
+            0xA300: "Texture filename",
+
+            # Key frames
+            0xB000: "Keyframes",
+            0xB002: "Object node tag",
+            0xB006: "Light target node tag",
+            0xB007: "Spot light node tag",
+            0xB00A: "Keyframes header",
+            0xB009: "Keyframe current time",
+            0xB030: "Node identifier",
+            0xB010: "Node header",
+            0x7001: "Viewport layout"
         }
         if type in know:
             return know[type]

Added: haypo/hachoir/plugins/exif.py
===================================================================
--- haypo/hachoir/plugins/exif.py	2005-11-28 00:58:10 UTC (rev 279)
+++ haypo/hachoir/plugins/exif.py	2005-11-28 02:52:23 UTC (rev 280)
@@ -0,0 +1,59 @@
+"""
+Exif filter.
+
+Informations about Exif at:
+- http://www.exif.org/
+- http://libexif.sourceforge.net/
+
+Author: Victor Stinner
+"""
+
+from filter import Filter
+
+class ExifEntry(Filter):
+    def __init__(self, stream, parent, endian):
+        Filter.__init__(self, "exif_entry", "Exif entry", stream, parent)
+        self.endian = endian
+        self.read("tag", endian+"H", "Tag", post=self.processTag)
+        self.read("whatsthis", "10s", "What's this?")
+
+    def updateParent(self, parent):
+        parent.description = "Exif entry (%s)" % self.getTag() 
+
+    def getTag(self):
+        know = {
+            0x010e: "Image description",
+            0x010f: "Camera constructor",
+            0x0110: "Camera model",
+            0x0131: "Software"
+        }
+        return know.get(self["tag"], "Unknown tag (0x%03X)" % self["tag"])
+
+    def processTag(self, chunk):
+        chunk.description = self.getTag()
+        return "(0x%04X)" % chunk.value 
+
+class ExifFilter(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "exif", "Exif", stream, parent)
+
+        # Headers
+        self.read("header", "6s", "Header (Exif\\0\\0)")
+        assert self["header"] == "Exif\0\0"
+        self.read("byte_order", "2s", "Byte order")
+        assert self["byte_order"] in ("II", "MM")
+        if self["byte_order"] == "II":
+           endian = "<"
+        else:
+           endian = ">"
+        self.read("header2", endian+"H", "Header2 (42)")
+
+        # Part 0
+        self.read("nb_entry", endian+"H", "Number of entries")
+        self.read("offset", endian+"L", "Reserved")
+        nb_entry = self["nb_entry"]
+        for i in range(0,nb_entry):
+            self.readChild("entry[]", ExifEntry, endian)
+
+        # TODO: To be continued...
+        self.read("end", "{@end@}s", "End")

Modified: haypo/hachoir/plugins/jpeg.py
===================================================================
--- haypo/hachoir/plugins/jpeg.py	2005-11-28 00:58:10 UTC (rev 279)
+++ haypo/hachoir/plugins/jpeg.py	2005-11-28 02:52:23 UTC (rev 280)
@@ -7,11 +7,11 @@
 
 from filter import Filter
 from plugin import registerPlugin
+from exif import ExifFilter
 
 class JpegChunkApp0(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "jpeg_chunk", "JPEG chunk App0", stream, parent)
-        self.read("size", "!H", "Size")
         self.read("jfif", "5s", "JFIF string")
         self.read("ver_maj", "B", "Major version")
         self.read("ver_min", "B", "Minor version")
@@ -27,18 +27,27 @@
         thumb = self["thumb_w"] * self["thumb_h"]
         if thumb != 0:
             self.read("thumb_data", "%us" % size, "Thumbnail data", truncate=True)
-        assert self["size"] == self.getSize()
 
 class JpegChunk(Filter):
     def __init__(self, stream, parent):
         Filter.__init__(self, "jpeg_chunk", "JPEG chunk", stream, parent)
-        chunk = self.read("header", "!2B", "Header", post=self.getChunkType)
-        assert self["header"][0] == 0xFF
-        if self["header"][1] == 0xE0:
-            self.readChild("app0", JpegChunkApp0)
+        chunk = self.read("header", "B", "Header")
+        assert self["header"] == 0xFF
+        chunk = self.read("type", "B", "Type", post=self.getChunkType)
+        known = {
+            0xE0: JpegChunkApp0,
+            0xE1: ExifFilter
+        }
+        chunk_type = self["type"]
+        self.read("size", "!H", "Size")
+        size = self["size"] - 2
+        if chunk_type in known:
+            end = stream.tell() + size
+            sub = stream.createSub(size=size)
+            self.readStreamChild("app0", sub, known[chunk_type])
+            assert stream.tell() == end
         else:
-            self.read("size", "!H", "Size")
-            self.read("data", "!%us" % (self["size"] - 2), "Data")
+            self.read("data", "!%us" % size, "Data")
 
     def getChunkType(self, chunk):
         types = {
@@ -50,10 +59,11 @@
             0xDB: "Define Quantization Table (DQT)",
             0xDC: "Define number of Lines (DNL)",
             0xDD: "Define Restart Interval (DRI)",
+            0xE1: "EXIF",
             0xE0: "APP0",
             0xFE: "Comment"
         }
-        type = chunk.value[1]
+        type = chunk.value
         if type in types:
             type = types[type]
         else:
@@ -63,7 +73,7 @@
 
 class JpegFile(Filter):
     def checkEndOfChunks(self, stream, array, chunk):
-        if chunk != None and chunk["header"][1] == 0xDA: return True
+        if chunk != None and chunk["type"] == 0xDA: return True
         return stream.eof()
 
     def __init__(self, stream, parent=None):



From haypo at berlios.de  Mon Nov 28 06:22:01 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 28 Nov 2005 06:22:01 +0100
Subject: [Happyboom-svn] r281 - in haypo/hachoir: . plugins
Message-ID: <200511280522.jAS5M18W015342@sheep.berlios.de>

Author: haypo
Date: 2005-11-28 06:21:57 +0100 (Mon, 28 Nov 2005)
New Revision: 281

Added:
   haypo/hachoir/plugins/xcf.py
Modified:
   haypo/hachoir/mime.py
Log:
Add XCF (Gimp image) filter.


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-28 02:52:23 UTC (rev 280)
+++ haypo/hachoir/mime.py	2005-11-28 05:21:57 UTC (rev 281)
@@ -1,4 +1,14 @@
 #!/usr/bin/python
+
+"""
+MIME type detection using libmagic library.
+
+See also:
+- ftp://ftp.astron.com/pub/file/ (libmagic)
+- http://www.demonseed.net/~jp/code/magic.py (100% Python)
+- http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
+"""
+
 import os, stat, string
 
 instance = None
@@ -32,6 +42,8 @@
         return "application/x-gzip"
     if buffer[:4] == "%PDF":
         return "application/pdf"
+    if buffer[:14] == "gimp xcf file\0":
+        return "image/x-xcf"
     return None        
 
 def splitMimes(mimes):

Added: haypo/hachoir/plugins/xcf.py
===================================================================
--- haypo/hachoir/plugins/xcf.py	2005-11-28 02:52:23 UTC (rev 280)
+++ haypo/hachoir/plugins/xcf.py	2005-11-28 05:21:57 UTC (rev 281)
@@ -0,0 +1,208 @@
+"""
+Exif filter.
+
+Informations about Exif at:
+- http://www.exif.org/
+- http://libexif.sourceforge.net/
+
+Author: Victor Stinner
+"""
+
+from filter import Filter
+from plugin import registerPlugin
+
+def readCompression(filter, stream):
+    name = {
+        0: "None",
+        1: "RLE",
+        2: "Zlib",
+        3: "Fractal"
+    }
+    chunk = filter.read("compression", "B", "")
+    type = name.get(chunk.value, "Unknow (%s)" % chunk.value)
+    chunk.description = "Compress type (%s)" % type
+
+def readResolution(filter, stream):
+    filter.read("xres", "f", "X resolution")
+    filter.read("yres", "f", "Y resolution")
+
+def readTattoo(filter, stream):
+    filter.read("tattoo", "!L", "Tattoo")
+
+def readUnit(filter, stream):
+    filter.read("unit", "!L", "Unit")
+
+def readString(filter, stream, name, description):
+    chunk = filter.read(name+"_size", "!L", description+" length")
+    filter.read(name, "%us" % chunk.value, description)
+
+class XcfParasite(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf_para", "XCF parasite", stream, parent)
+        readString(self, stream, "name", "Name")
+        self.read("flags", "!L", "Flags")
+        self.read("size", "!L", "Size")
+        if 0 < self["size"]:
+            self.read("data", "%us" % self["size"], "Data")
+
+class XcfLevel(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf_level", "XCF level", stream, parent)
+        self.read("width", "!L", "Width")
+        self.read("height", "!L", "Height")
+        self.read("offset", "!L", "Offset")
+        offset = self["offset"]
+        if offset == 0:
+            return
+        data_offsets = []
+        while stream.tell() < offset:
+            chunk = self.read("data_offset[]", "!L", "Data offset")
+            if chunk.value == 0:
+                break
+            data_offsets.append(chunk.value)
+        assert stream.tell() == offset
+        previous = offset
+        for data_offset in data_offsets:
+            size = data_offset - previous
+            self.read("data[]", "%us" % size, "Data")
+            previous = data_offset
+
+class XcfHierarchie(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf_hier", "XCF hierarchie", stream, parent)
+        self.read("width", "!L", "Width")
+        self.read("height", "!L", "Height")
+        self.read("bpp", "!L", "Bits/pixel")
+            
+        offsets = []
+        while True:
+            chunk = self.read("offset[]", "!L", "Level offset")
+            if chunk.value == 0:
+                break
+            offsets.append(chunk.value)
+        for offset in offsets:
+            seek(self, stream, offset)
+            self.readChild("level[]", XcfLevel)
+#        self.readChild("channel[]", XcfChannel)
+
+class XcfChannel(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf_channel", "XCF channel", stream, parent)
+        self.read("width", "!L", "Channel width")
+        self.read("height", "!L", "Channel height")
+        readString(self, stream, "name", "Channel name")
+        readProperties(self, stream)
+        return
+        self.read("hierarchie_ofs", "!L", "Hierarchie offset")
+        self.readChild("hierarchie", XcfHierarchie)
+
+class XcfLayer(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf_layer", "XCF layer", stream, parent)
+        self.read("width", "!L", "Layer width")
+        self.read("height", "!L", "Layer height")
+        self.read("type", "!L", "Layer type")
+        readString(self, stream, "name", "Layer name")
+        readProperties(self, stream)
+        # TODO: Hack for Gimp 1.2 files
+        self.read("hierarchie_ofs", "!L", "Hierarchie offset")
+        self.read("mask_ofs", "!L", "Layer mask offset")
+        seek(self, stream, self["hierarchie_ofs"])
+        self.readChild("hierarchie", XcfHierarchie)
+        # TODO: Read layer mask if needed: self["mask_ofs"] != 0
+
+def readParasites(filter, stream):
+    while not stream.eof():
+        filter.readChild("parasite[]", XcfParasite)
+
+class XcfProperty(Filter):
+    known_types = {
+        0: "End",
+        1: "Colormap",
+        2: "Active layer",
+        3: "Active channel",
+        4: "Selection",
+        5: "Floating selection",
+        6: "Opacity",
+        7: "Mode",
+        8: "Visible",
+        9: "Linked",
+        10: "Lock alpha",
+        11: "Apply mask",
+        12: "Edit mask",
+        13: "Show mask",
+        14: "Show masked",
+        15: "Offsets",
+        16: "Color",
+        17: "Compression",
+        18: "Guides",
+        19: "Resolution",
+        20: "Tattoo",
+        21: "Parasites",
+        22: "Unit",
+        23: "Paths",
+        24: "User unit",
+        25: "Vectors",
+        26: "Text layer flags"
+    }
+    handler = {
+        17: readCompression,
+        19: readResolution,
+        20: readTattoo,
+        21: readParasites,
+        22: readUnit
+    }
+
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf_prop", "XCF property", stream, parent)
+        chunk = self.read("type", "!L", "")
+        chunk.description = "Property type (%s)" % self.getType()
+        self.read("size", "!L", "Property size")
+        type = self["type"]
+        if type in XcfProperty.handler:
+            end = stream.tell() + self["size"]
+            substream = stream.createSub(size=self["size"])
+            XcfProperty.handler[type] (self, substream)
+            assert stream.tell() == end
+        elif 0 < self["size"]:
+            self.read("data", "%us" % self["size"], "Data")
+
+    def updateParent(self, parent):
+        parent.description = "XCF property (%s)" % self.getType()
+
+    def getType(self):
+        return XcfProperty.known_types.get(self["type"], "Unknow type (%u)" % self["type"])
+
+def readProperties(filter, stream):        
+    while True:
+        chunk = filter.readChild("property[]", XcfProperty)
+        type = chunk.getFilter()["type"]
+        if type == 0:
+            break
+
+def seek(filter, stream, offset):
+    current = stream.tell()
+    if current != offset:
+        filter.read("padding[]", "%us" % (offset-current), "Padding")
+
+class XcfFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "xcf", "XCF file", stream, parent)
+        self.readString("header", "C", "Header")
+        assert self["header"] == "gimp xcf file"
+        self.read("width", "!L", "Image width")
+        self.read("height", "!L", "Image height")
+        self.read("type", "!L", "Image type")
+        readProperties(self, stream)
+
+        offsets = []
+        while True:
+            chunk = self.read("layer_offset[]", "!L", "Layer offset")
+            if chunk.value == 0:
+                break
+            offsets.append(chunk.value)
+        for offset in offsets:
+            seek(self, stream, offset)
+            self.readChild("layer[]", XcfLayer)
+
+registerPlugin(XcfFile, "image/x-xcf")



From haypo at berlios.de  Mon Nov 28 22:49:59 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 28 Nov 2005 22:49:59 +0100
Subject: [Happyboom-svn] r282 - in haypo/hachoir: . failback plugins ui
Message-ID: <200511282149.jASLnxBV014784@sheep.berlios.de>

Author: haypo
Date: 2005-11-28 22:49:58 +0100 (Mon, 28 Nov 2005)
New Revision: 282

Added:
   haypo/hachoir/failback/
   haypo/hachoir/failback/__init__.py
   haypo/hachoir/failback/magic.py
   haypo/hachoir/ui/ui_glade.py
Modified:
   haypo/hachoir/error.py
   haypo/hachoir/hachoir.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/mime.py
   haypo/hachoir/plugin.py
   haypo/hachoir/plugins/deb.py
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/plugins/pdf.py
   haypo/hachoir/plugins/png.py
   haypo/hachoir/plugins/tar.py
   haypo/hachoir/ui/ui.py
Log:
- Better behavious when pygtk and python glade are missing
- Small fix in DEB plugin (syntax: self.header => self["header"])
- Fix ELF filters default name
- Fix PDF filter: match Deflate string on first object line, only get
  empty line if there is an empty line
- Add fallback MIME if libmagic is missing


Modified: haypo/hachoir/error.py
===================================================================
--- haypo/hachoir/error.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/error.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -1,13 +1,10 @@
 import os
-import pygtk
-pygtk.require ('2.0') # 2.2 for Clipboard
-import gtk
 from log import log
-import ui.ui as ui
+from ui.ui import ui as ui
 
 def warning(message):
-    log.warning(message)
-    if ui.ui != None:
+    log.warning(message)   
+    if ui != None:
         dlg = gtk.MessageDialog( \
             type=gtk.MESSAGE_WARNING,
             buttons=gtk.BUTTONS_OK,
@@ -17,7 +14,7 @@
 
 def error(message):
     log.error(message)
-    if ui.ui != None:
+    if ui != None:
         dlg = gtk.MessageDialog( \
             type=gtk.MESSAGE_ERROR,
             buttons=gtk.BUTTONS_OK,

Added: haypo/hachoir/failback/__init__.py
===================================================================

Added: haypo/hachoir/failback/magic.py
===================================================================
--- haypo/hachoir/failback/magic.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/failback/magic.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -0,0 +1,1118 @@
+#!/usr/bin/env python 
+'''
+magic.py
+ determines a file type by its magic number
+
+ (C)opyright 2000 Jason Petrone <jp_py at demonseed.net>
+ All Rights Reserved
+
+ Command Line Usage: running as `python magic.py file` will print
+                     a description of what 'file' is.
+
+ Module Usage:
+     magic.whatis(data): when passed a string 'data' containing 
+                         binary or text data, a description of
+                         what the data is will be returned.
+
+     magic.file(filename): returns a description of what the file
+                           'filename' contains.
+'''
+
+import re, struct, string
+
+__version__ = '0.1'
+
+magic = [
+  [0L, 'leshort', '=', 1538L, 'application/x-alan-adventure-game'],
+  [0L, 'string', '=', 'TADS', 'application/x-tads-game'],
+  [0L, 'short', '=', 420L, 'application/x-executable-file'],
+  [0L, 'short', '=', 421L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 603L, 'application/x-executable-file'],
+  [0L, 'string', '=', 'Core\001', 'application/x-executable-file'],
+  [0L, 'string', '=', 'AMANDA: TAPESTART DATE', 'application/x-amanda-header'],
+  [0L, 'belong', '=', 1011L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 999L, 'application/x-library-file'],
+  [0L, 'belong', '=', 435L, 'video/mpeg'],
+  [0L, 'belong', '=', 442L, 'video/mpeg'],
+  [0L, 'beshort&0xfff0', '=', 65520L, 'audio/mpeg'],
+  [4L, 'leshort', '=', 44817L, 'video/fli'],
+  [4L, 'leshort', '=', 44818L, 'video/flc'],
+  [0L, 'string', '=', 'MOVI', 'video/x-sgi-movie'],
+  [4L, 'string', '=', 'moov', 'video/quicktime'],
+  [4L, 'string', '=', 'mdat', 'video/quicktime'],
+  [0L, 'long', '=', 100554L, 'application/x-apl-workspace'],
+  [0L, 'string', '=', 'FiLeStArTfIlEsTaRt', 'text/x-apple-binscii'],
+  [0L, 'string', '=', '\012GL', 'application/data'],
+  [0L, 'string', '=', 'v\377', 'application/data'],
+  [0L, 'string', '=', 'NuFile', 'application/data'],
+  [0L, 'string', '=', 'N\365F\351l\345', 'application/data'],
+  [0L, 'belong', '=', 333312L, 'application/data'],
+  [0L, 'belong', '=', 333319L, 'application/data'],
+  [257L, 'string', '=', 'ustar\000', 'application/x-tar'],
+  [257L, 'string', '=', 'ustar  \000', 'application/x-gtar'],
+  [0L, 'short', '=', 70707L, 'application/x-cpio'],
+  [0L, 'short', '=', 143561L, 'application/x-bcpio'],
+  [0L, 'string', '=', '070707', 'application/x-cpio'],
+  [0L, 'string', '=', '070701', 'application/x-cpio'],
+  [0L, 'string', '=', '070702', 'application/x-cpio'],
+  [0L, 'string', '=', '!<arch>\012debian', 'application/x-dpkg'],
+  [0L, 'long', '=', 177555L, 'application/x-ar'],
+  [0L, 'short', '=', 177555L, 'application/data'],
+  [0L, 'long', '=', 177545L, 'application/data'],
+  [0L, 'short', '=', 177545L, 'application/data'],
+  [0L, 'long', '=', 100554L, 'application/x-apl-workspace'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'string', '=', '!<arch>\012__________E', 'application/x-ar'],
+  [0L, 'string', '=', '-h-', 'application/data'],
+  [0L, 'string', '=', '!<arch>', 'application/x-ar'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'string', '=', '<ar>', 'application/x-ar'],
+  [0L, 'belong', '=', 1711210496L, 'application/x-ar'],
+  [0L, 'belong', '=', 1013019198L, 'application/x-ar'],
+  [0L, 'long', '=', 557605234L, 'application/x-ar'],
+  [0L, 'lelong', '=', 177555L, 'application/data'],
+  [0L, 'leshort', '=', 177555L, 'application/data'],
+  [0L, 'lelong', '=', 177545L, 'application/data'],
+  [0L, 'leshort', '=', 177545L, 'application/data'],
+  [0L, 'lelong', '=', 236525L, 'application/data'],
+  [0L, 'lelong', '=', 236526L, 'application/data'],
+  [0L, 'lelong&0x8080ffff', '=', 2074L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 2330L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 538L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 794L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 1050L, 'application/x-arc'],
+  [0L, 'lelong&0x8080ffff', '=', 1562L, 'application/x-arc'],
+  [0L, 'string', '=', '\032archive', 'application/data'],
+  [0L, 'leshort', '=', 60000L, 'application/x-arj'],
+  [0L, 'string', '=', 'HPAK', 'application/data'],
+  [0L, 'string', '=', '\351,\001JAM application/data', ''],
+  [2L, 'string', '=', '-lh0-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh1-', 'application/x-lha'],
+  [2L, 'string', '=', '-lz4-', 'application/x-lha'],
+  [2L, 'string', '=', '-lz5-', 'application/x-lha'],
+  [2L, 'string', '=', '-lzs-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh -', 'application/x-lha'],
+  [2L, 'string', '=', '-lhd-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh2-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh3-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh4-', 'application/x-lha'],
+  [2L, 'string', '=', '-lh5-', 'application/x-lha'],
+  [0L, 'string', '=', 'Rar!', 'application/x-rar'],
+  [0L, 'string', '=', 'SQSH', 'application/data'],
+  [0L, 'string', '=', 'UC2\032', 'application/data'],
+  [0L, 'string', '=', 'PK\003\004', 'application/zip'],
+  [20L, 'lelong', '=', 4257523676L, 'application/x-zoo'],
+  [10L, 'string', '=', '# This is a shell archive', 'application/x-shar'],
+  [0L, 'string', '=', '*STA', 'application/data'],
+  [0L, 'string', '=', '2278', 'application/data'],
+  [0L, 'beshort', '=', 560L, 'application/x-executable-file'],
+  [0L, 'beshort', '=', 561L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\000\004\036\212\200', 'application/core'],
+  [0L, 'string', '=', '.snd', 'audio/basic'],
+  [0L, 'lelong', '=', 6583086L, 'audio/basic'],
+  [0L, 'string', '=', 'MThd', 'audio/midi'],
+  [0L, 'string', '=', 'CTMF', 'audio/x-cmf'],
+  [0L, 'string', '=', 'SBI', 'audio/x-sbi'],
+  [0L, 'string', '=', 'Creative Voice File', 'audio/x-voc'],
+  [0L, 'belong', '=', 1314148939L, 'audio/x-multitrack'],
+  [0L, 'string', '=', 'RIFF', 'audio/x-wav'],
+  [0L, 'string', '=', 'EMOD', 'audio/x-emod'],
+  [0L, 'belong', '=', 779248125L, 'audio/x-pn-realaudio'],
+  [0L, 'string', '=', 'MTM', 'audio/x-multitrack'],
+  [0L, 'string', '=', 'if', 'audio/x-669-mod'],
+  [0L, 'string', '=', 'FAR', 'audio/mod'],
+  [0L, 'string', '=', 'MAS_U', 'audio/x-multimate-mod'],
+  [44L, 'string', '=', 'SCRM', 'audio/x-st3-mod'],
+  [0L, 'string', '=', 'GF1PATCH110\000ID#000002\000', 'audio/x-gus-patch'],
+  [0L, 'string', '=', 'GF1PATCH100\000ID#000002\000', 'audio/x-gus-patch'],
+  [0L, 'string', '=', 'JN', 'audio/x-669-mod'],
+  [0L, 'string', '=', 'UN05', 'audio/x-mikmod-uni'],
+  [0L, 'string', '=', 'Extended Module:', 'audio/x-ft2-mod'],
+  [21L, 'string', '=', '!SCREAM!', 'audio/x-st2-mod'],
+  [1080L, 'string', '=', 'M.K.', 'audio/x-protracker-mod'],
+  [1080L, 'string', '=', 'M!K!', 'audio/x-protracker-mod'],
+  [1080L, 'string', '=', 'FLT4', 'audio/x-startracker-mod'],
+  [1080L, 'string', '=', '4CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', '6CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', '8CHN', 'audio/x-fasttracker-mod'],
+  [1080L, 'string', '=', 'CD81', 'audio/x-oktalyzer-mod'],
+  [1080L, 'string', '=', 'OKTA', 'audio/x-oktalyzer-mod'],
+  [1080L, 'string', '=', '16CN', 'audio/x-taketracker-mod'],
+  [1080L, 'string', '=', '32CN', 'audio/x-taketracker-mod'],
+  [0L, 'string', '=', 'TOC', 'audio/x-toc'],
+  [0L, 'short', '=', 3401L, 'application/x-executable-file'],
+  [0L, 'long', '=', 406L, 'application/x-executable-file'],
+  [0L, 'short', '=', 406L, 'application/x-executable-file'],
+  [0L, 'short', '=', 3001L, 'application/x-executable-file'],
+  [0L, 'lelong', '=', 314L, 'application/x-executable-file'],
+  [0L, 'string', '=', '//', 'text/cpp'],
+  [0L, 'string', '=', '\\\\1cw\\', 'application/data'],
+  [0L, 'string', '=', '\\\\1cw', 'application/data'],
+  [0L, 'belong&0xffffff00', '=', 2231440384L, 'application/data'],
+  [0L, 'belong&0xffffff00', '=', 2231487232L, 'application/data'],
+  [0L, 'short', '=', 575L, 'application/x-executable-file'],
+  [0L, 'short', '=', 577L, 'application/x-executable-file'],
+  [4L, 'string', '=', 'pipe', 'application/data'],
+  [4L, 'string', '=', 'prof', 'application/data'],
+  [0L, 'string', '=', ': shell', 'application/data'],
+  [0L, 'string', '=', '#!/bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/sh', 'application/x-sh'],
+  [0L, 'string', '=', '#!/bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/csh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#! /bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#! /bin/ksh', 'application/x-ksh'],
+  [0L, 'string', '=', '#!/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#! /usr/local/bin/tcsh', 'application/x-csh'],
+  [0L, 'string', '=', '#!/usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/zsh', 'application/x-zsh'],
+  [0L, 'string', '=', '#!/usr/local/bin/ash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/ash', 'application/x-zsh'],
+  [0L, 'string', '=', '#! /usr/local/bin/ash', 'application/x-zsh'],
+  [0L, 'string', '=', '#!/usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#! /usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#! /usr/local/bin/ae', 'text/script'],
+  [0L, 'string', '=', '#!/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/nawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/local/bin/gawk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#!/usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', '#! /usr/bin/awk', 'application/x-awk'],
+  [0L, 'string', '=', 'BEGIN', 'application/x-awk'],
+  [0L, 'string', '=', '#!/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /usr/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#! /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', 'eval "exec /usr/local/bin/perl', 'application/x-perl'],
+  [0L, 'string', '=', '#!/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /usr/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', 'eval "exec /usr/local/bin/python', 'application/x-python'],
+  [0L, 'string', '=', '#!/usr/bin/env python', 'application/x-python'],
+  [0L, 'string', '=', '#! /usr/bin/env python', 'application/x-python'],
+  [0L, 'string', '=', '#!/bin/rc', 'text/script'],
+  [0L, 'string', '=', '#! /bin/rc', 'text/script'],
+  [0L, 'string', '=', '#! /bin/rc', 'text/script'],
+  [0L, 'string', '=', '#!/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#!/usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /usr/local/bin/bash', 'application/x-sh'],
+  [0L, 'string', '=', '#! /', 'text/script'],
+  [0L, 'string', '=', '#! /', 'text/script'],
+  [0L, 'string', '=', '#!/', 'text/script'],
+  [0L, 'string', '=', '#! text/script', ''],
+  [0L, 'string', '=', '\037\235', 'application/compress'],
+  [0L, 'string', '=', '\037\213', 'application/x-gzip'],
+  [0L, 'string', '=', '\037\036', 'application/data'],
+  [0L, 'short', '=', 17437L, 'application/data'],
+  [0L, 'short', '=', 8191L, 'application/data'],
+  [0L, 'string', '=', '\377\037', 'application/data'],
+  [0L, 'short', '=', 145405L, 'application/data'],
+  [0L, 'string', '=', 'BZh', 'application/x-bzip2'],
+  [0L, 'leshort', '=', 65398L, 'application/data'],
+  [0L, 'leshort', '=', 65142L, 'application/data'],
+  [0L, 'leshort', '=', 64886L, 'application/x-lzh'],
+  [0L, 'string', '=', '\037\237', 'application/data'],
+  [0L, 'string', '=', '\037\236', 'application/data'],
+  [0L, 'string', '=', '\037\240', 'application/data'],
+  [0L, 'string', '=', 'BZ', 'application/x-bzip'],
+  [0L, 'string', '=', '\211LZO\000\015\012\032\012', 'application/data'],
+  [0L, 'belong', '=', 507L, 'application/x-object-file'],
+  [0L, 'belong', '=', 513L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 515L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 517L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 70231L, 'application/core'],
+  [24L, 'belong', '=', 60011L, 'application/data'],
+  [24L, 'belong', '=', 60012L, 'application/data'],
+  [24L, 'belong', '=', 60013L, 'application/data'],
+  [24L, 'belong', '=', 60014L, 'application/data'],
+  [0L, 'belong', '=', 601L, 'application/x-object-file'],
+  [0L, 'belong', '=', 607L, 'application/data'],
+  [0L, 'belong', '=', 324508366L, 'application/x-gdbm'],
+  [0L, 'lelong', '=', 324508366L, 'application/x-gdbm'],
+  [0L, 'string', '=', 'GDBM', 'application/x-gdbm'],
+  [0L, 'belong', '=', 398689L, 'application/x-db'],
+  [0L, 'belong', '=', 340322L, 'application/x-db'],
+  [0L, 'string', '=', '<list>\012<protocol bbn-m', 'application/data'],
+  [0L, 'string', '=', 'diff text/x-patch', ''],
+  [0L, 'string', '=', '*** text/x-patch', ''],
+  [0L, 'string', '=', 'Only in text/x-patch', ''],
+  [0L, 'string', '=', 'Common subdirectories: text/x-patch', ''],
+  [0L, 'string', '=', '!<arch>\012________64E', 'application/data'],
+  [0L, 'leshort', '=', 387L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 392L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 399L, 'application/x-object-file'],
+  [0L, 'string', '=', '\377\377\177', 'application/data'],
+  [0L, 'string', '=', '\377\377|', 'application/data'],
+  [0L, 'string', '=', '\377\377~', 'application/data'],
+  [0L, 'string', '=', '\033c\033', 'application/data'],
+  [0L, 'long', '=', 4553207L, 'image/x11'],
+  [0L, 'string', '=', '!<PDF>!\012', 'application/x-prof'],
+  [0L, 'short', '=', 1281L, 'application/x-locale'],
+  [24L, 'belong', '=', 60012L, 'application/x-dump'],
+  [24L, 'belong', '=', 60011L, 'application/x-dump'],
+  [24L, 'lelong', '=', 60012L, 'application/x-dump'],
+  [24L, 'lelong', '=', 60011L, 'application/x-dump'],
+  [0L, 'string', '=', '\177ELF', 'application/x-executable-file'],
+  [0L, 'short', '=', 340L, 'application/data'],
+  [0L, 'short', '=', 341L, 'application/x-executable-file'],
+  [1080L, 'leshort', '=', 61267L, 'application/x-linux-ext2fs'],
+  [0L, 'string', '=', '\366\366\366\366', 'application/x-pc-floppy'],
+  [774L, 'beshort', '=', 55998L, 'application/data'],
+  [510L, 'leshort', '=', 43605L, 'application/data'],
+  [1040L, 'leshort', '=', 4991L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 5007L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 9320L, 'application/x-filesystem'],
+  [1040L, 'leshort', '=', 9336L, 'application/x-filesystem'],
+  [0L, 'string', '=', '-rom1fs-\000', 'application/x-filesystem'],
+  [395L, 'string', '=', 'OS/2', 'application/x-bootable'],
+  [0L, 'string', '=', 'FONT', 'font/x-vfont'],
+  [0L, 'short', '=', 436L, 'font/x-vfont'],
+  [0L, 'short', '=', 17001L, 'font/x-vfont'],
+  [0L, 'string', '=', '%!PS-AdobeFont-1.0', 'font/type1'],
+  [6L, 'string', '=', '%!PS-AdobeFont-1.0', 'font/type1'],
+  [0L, 'belong', '=', 4L, 'font/x-snf'],
+  [0L, 'lelong', '=', 4L, 'font/x-snf'],
+  [0L, 'string', '=', 'STARTFONT font/x-bdf', ''],
+  [0L, 'string', '=', '\001fcp', 'font/x-pcf'],
+  [0L, 'string', '=', 'D1.0\015', 'font/x-speedo'],
+  [0L, 'string', '=', 'flf', 'font/x-figlet'],
+  [0L, 'string', '=', 'flc', 'application/x-font'],
+  [0L, 'belong', '=', 335698201L, 'font/x-libgrx'],
+  [0L, 'belong', '=', 4282797902L, 'font/x-dos'],
+  [7L, 'belong', '=', 4540225L, 'font/x-dos'],
+  [7L, 'belong', '=', 5654852L, 'font/x-dos'],
+  [4098L, 'string', '=', 'DOSFONT', 'font/x-dos'],
+  [0L, 'string', '=', '<MakerFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MIFFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MakerDictionary', 'application/x-framemaker'],
+  [0L, 'string', '=', '<MakerScreenFont', 'font/x-framemaker'],
+  [0L, 'string', '=', '<MML', 'application/x-framemaker'],
+  [0L, 'string', '=', '<BookFile', 'application/x-framemaker'],
+  [0L, 'string', '=', '<Maker', 'application/x-framemaker'],
+  [0L, 'lelong&0377777777', '=', 41400407L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400410L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400413L, 'application/x-executable-file'],
+  [0L, 'lelong&0377777777', '=', 41400314L, 'application/x-executable-file'],
+  [7L, 'string', '=', '\357\020\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000', 'application/core'],
+  [0L, 'lelong', '=', 11421044151L, 'application/data'],
+  [0L, 'string', '=', 'GIMP Gradient', 'application/x-gimp-gradient'],
+  [0L, 'string', '=', 'gimp xcf', 'application/x-gimp-image'],
+  [20L, 'string', '=', 'GPAT', 'application/x-gimp-pattern'],
+  [20L, 'string', '=', 'GIMP', 'application/x-gimp-brush'],
+  [0L, 'string', '=', '\336\022\004\225', 'application/x-locale'],
+  [0L, 'string', '=', '\225\004\022\336', 'application/x-locale'],
+  [0L, 'beshort', '=', 627L, 'application/x-executable-file'],
+  [0L, 'beshort', '=', 624L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\000\001\000\000\000', 'font/ttf'],
+  [0L, 'long', '=', 1203604016L, 'application/data'],
+  [0L, 'long', '=', 1702407010L, 'application/data'],
+  [0L, 'long', '=', 1003405017L, 'application/data'],
+  [0L, 'long', '=', 1602007412L, 'application/data'],
+  [0L, 'belong', '=', 34603270L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34603271L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603272L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603275L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34603278L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34603277L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34865414L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34865415L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865416L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865419L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34865422L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34865421L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34275590L, 'application/x-object-file'],
+  [0L, 'belong', '=', 34275591L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275592L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275595L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34275598L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34275597L, 'application/x-library-file'],
+  [0L, 'belong', '=', 557605234L, 'application/x-ar'],
+  [0L, 'long', '=', 34078982L, 'application/x-executable-file'],
+  [0L, 'long', '=', 34078983L, 'application/x-executable-file'],
+  [0L, 'long', '=', 34078984L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341128L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341127L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341131L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341126L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34210056L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34210055L, 'application/x-executable-file'],
+  [0L, 'belong', '=', 34341134L, 'application/x-library-file'],
+  [0L, 'belong', '=', 34341133L, 'application/x-library-file'],
+  [0L, 'long', '=', 65381L, 'application/x-library-file'],
+  [0L, 'long', '=', 34275173L, 'application/x-library-file'],
+  [0L, 'long', '=', 34406245L, 'application/x-library-file'],
+  [0L, 'long', '=', 34144101L, 'application/x-library-file'],
+  [0L, 'long', '=', 22552998L, 'application/core'],
+  [0L, 'long', '=', 1302851304L, 'font/x-hp-windows'],
+  [0L, 'string', '=', 'Bitmapfile', 'image/unknown'],
+  [0L, 'string', '=', 'IMGfile', 'CIS image/unknown'],
+  [0L, 'long', '=', 34341132L, 'application/x-lisp'],
+  [0L, 'string', '=', 'msgcat01', 'application/x-locale'],
+  [0L, 'string', '=', 'HPHP48-', 'HP48 binary'],
+  [0L, 'string', '=', '%%HP:', 'HP48 text'],
+  [0L, 'beshort', '=', 200L, 'hp200 (68010) BSD'],
+  [0L, 'beshort', '=', 300L, 'hp300 (68020+68881) BSD'],
+  [0L, 'beshort', '=', 537L, '370 XA sysV executable'],
+  [0L, 'beshort', '=', 532L, '370 XA sysV pure executable'],
+  [0L, 'beshort', '=', 54001L, '370 sysV pure executable'],
+  [0L, 'beshort', '=', 55001L, '370 XA sysV pure executable'],
+  [0L, 'beshort', '=', 56401L, '370 sysV executable'],
+  [0L, 'beshort', '=', 57401L, '370 XA sysV executable'],
+  [0L, 'beshort', '=', 531L, 'SVR2 executable (Amdahl-UTS)'],
+  [0L, 'beshort', '=', 534L, 'SVR2 pure executable (Amdahl-UTS)'],
+  [0L, 'beshort', '=', 530L, 'SVR2 pure executable (USS/370)'],
+  [0L, 'beshort', '=', 535L, 'SVR2 executable (USS/370)'],
+  [0L, 'beshort', '=', 479L, 'executable (RISC System/6000 V3.1) or obj module'],
+  [0L, 'beshort', '=', 260L, 'shared library'],
+  [0L, 'beshort', '=', 261L, 'ctab data'],
+  [0L, 'beshort', '=', 65028L, 'structured file'],
+  [0L, 'string', '=', '0xabcdef', 'AIX message catalog'],
+  [0L, 'belong', '=', 505L, 'AIX compiled message catalog'],
+  [0L, 'string', '=', '<aiaff>', 'archive'],
+  [0L, 'string', '=', 'FORM', 'IFF data'],
+  [0L, 'string', '=', 'P1', 'image/x-portable-bitmap'],
+  [0L, 'string', '=', 'P2', 'image/x-portable-graymap'],
+  [0L, 'string', '=', 'P3', 'image/x-portable-pixmap'],
+  [0L, 'string', '=', 'P4', 'image/x-portable-bitmap'],
+  [0L, 'string', '=', 'P5', 'image/x-portable-graymap'],
+  [0L, 'string', '=', 'P6', 'image/x-portable-pixmap'],
+  [0L, 'string', '=', 'IIN1', 'image/tiff'],
+  [0L, 'string', '=', 'MM\000*', 'image/tiff'],
+  [0L, 'string', '=', 'II*\000', 'image/tiff'],
+  [0L, 'string', '=', '\211PNG', 'image/x-png'],
+  [1L, 'string', '=', 'PNG', 'image/x-png'],
+  [0L, 'string', '=', 'GIF8', 'image/gif'],
+  [0L, 'string', '=', '\361\000@\273', 'image/x-cmu-raster'],
+  [0L, 'string', '=', 'id=ImageMagick', 'MIFF image data'],
+  [0L, 'long', '=', 1123028772L, 'Artisan image data'],
+  [0L, 'string', '=', '#FIG', 'FIG image text'],
+  [0L, 'string', '=', 'ARF_BEGARF', 'PHIGS clear text archive'],
+  [0L, 'string', '=', '@(#)SunPHIGS', 'SunPHIGS'],
+  [0L, 'string', '=', 'GKSM', 'GKS Metafile'],
+  [0L, 'string', '=', 'BEGMF', 'clear text Computer Graphics Metafile'],
+  [0L, 'beshort&0xffe0', '=', 32L, 'binary Computer Graphics Metafile'],
+  [0L, 'beshort', '=', 12320L, 'character Computer Graphics Metafile'],
+  [0L, 'string', '=', 'yz', 'MGR bitmap, modern format, 8-bit aligned'],
+  [0L, 'string', '=', 'zz', 'MGR bitmap, old format, 1-bit deep, 16-bit aligned'],
+  [0L, 'string', '=', 'xz', 'MGR bitmap, old format, 1-bit deep, 32-bit aligned'],
+  [0L, 'string', '=', 'yx', 'MGR bitmap, modern format, squeezed'],
+  [0L, 'string', '=', '%bitmap\000', 'FBM image data'],
+  [1L, 'string', '=', 'PC Research, Inc', 'group 3 fax data'],
+  [0L, 'beshort', '=', 65496L, 'image/jpeg'],
+  [0L, 'string', '=', 'hsi1', 'image/x-jpeg-proprietary'],
+  [0L, 'string', '=', 'BM', 'image/x-bmp'],
+  [0L, 'string', '=', 'IC', 'image/x-ico'],
+  [0L, 'string', '=', 'PI', 'PC pointer image data'],
+  [0L, 'string', '=', 'CI', 'PC color icon data'],
+  [0L, 'string', '=', 'CP', 'PC color pointer image data'],
+  [0L, 'string', '=', '/* XPM */', 'X pixmap image text'],
+  [0L, 'leshort', '=', 52306L, 'RLE image data,'],
+  [0L, 'string', '=', 'Imagefile version-', 'iff image data'],
+  [0L, 'belong', '=', 1504078485L, 'x/x-image-sun-raster'],
+  [0L, 'beshort', '=', 474L, 'x/x-image-sgi'],
+  [0L, 'string', '=', 'IT01', 'FIT image data'],
+  [0L, 'string', '=', 'IT02', 'FIT image data'],
+  [2048L, 'string', '=', 'PCD_IPI', 'x/x-photo-cd-pack-file'],
+  [0L, 'string', '=', 'PCD_OPA', 'x/x-photo-cd-overfiew-file'],
+  [0L, 'string', '=', 'SIMPLE  =', 'FITS image data'],
+  [0L, 'string', '=', 'This is a BitMap file', 'Lisp Machine bit-array-file'],
+  [0L, 'string', '=', '!!', 'Bennet Yee\'s "face" format'],
+  [0L, 'beshort', '=', 4112L, 'PEX Binary Archive'],
+  [3000L, 'string', '=', 'Visio (TM) Drawing', '%s'],
+  [0L, 'leshort', '=', 502L, 'basic-16 executable'],
+  [0L, 'leshort', '=', 503L, 'basic-16 executable (TV)'],
+  [0L, 'leshort', '=', 510L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 511L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 512L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 522L, 'application/x-executable-file'],
+  [0L, 'leshort', '=', 514L, 'application/x-executable-file'],
+  [0L, 'string', '=', '\210OPS', 'Interleaf saved data'],
+  [0L, 'string', '=', '<!OPS', 'Interleaf document text'],
+  [4L, 'string', '=', 'pgscriptver', 'IslandWrite document'],
+  [13L, 'string', '=', 'DrawFile', 'IslandDraw document'],
+  [0L, 'leshort&0xFFFC', '=', 38400L, 'little endian ispell'],
+  [0L, 'beshort&0xFFFC', '=', 38400L, 'big endian ispell'],
+  [0L, 'belong', '=', 3405691582L, 'compiled Java class data,'],
+  [0L, 'beshort', '=', 44269L, 'Java serialization data'],
+  [0L, 'string', '=', 'KarmaRHD', 'Version Karma Data Structure Version'],
+  [0L, 'string', '=', 'lect', 'DEC SRC Virtual Paper Lectern file'],
+  [53L, 'string', '=', 'yyprevious', 'C program text (from lex)'],
+  [21L, 'string', '=', 'generated by flex', 'C program text (from flex)'],
+  [0L, 'string', '=', '%{', 'lex description text'],
+  [0L, 'short', '=', 32768L, 'lif file'],
+  [0L, 'lelong', '=', 6553863L, 'Linux/i386 impure executable (OMAGIC)'],
+  [0L, 'lelong', '=', 6553864L, 'Linux/i386 pure executable (NMAGIC)'],
+  [0L, 'lelong', '=', 6553867L, 'Linux/i386 demand-paged executable (ZMAGIC)'],
+  [0L, 'lelong', '=', 6553804L, 'Linux/i386 demand-paged executable (QMAGIC)'],
+  [0L, 'string', '=', '\007\001\000', 'Linux/i386 object file'],
+  [0L, 'string', '=', '\001\003\020\004', 'Linux-8086 impure executable'],
+  [0L, 'string', '=', '\001\003 \004', 'Linux-8086 executable'],
+  [0L, 'string', '=', '\243\206\001\000', 'Linux-8086 object file'],
+  [0L, 'string', '=', '\001\003\020\020', 'Minix-386 impure executable'],
+  [0L, 'string', '=', '\001\003 \020', 'Minix-386 executable'],
+  [0L, 'string', '=', '*nazgul*', 'Linux compiled message catalog'],
+  [216L, 'lelong', '=', 421L, 'Linux/i386 core file'],
+  [2L, 'string', '=', 'LILO', 'Linux/i386 LILO boot/chain loader'],
+  [0L, 'string', '=', '0.9', ''],
+  [0L, 'leshort', '=', 1078L, 'font/linux-psf'],
+  [4086L, 'string', '=', 'SWAP-SPACE', 'Linux/i386 swap file'],
+  [0L, 'leshort', '=', 387L, 'ECOFF alpha'],
+  [514L, 'string', '=', 'HdrS', 'Linux kernel'],
+  [0L, 'belong', '=', 3099592590L, 'Linux kernel'],
+  [0L, 'string', '=', 'Begin3', 'Linux Software Map entry text'],
+  [0L, 'string', '=', ';;', 'Lisp/Scheme program text'],
+  [0L, 'string', '=', '\012(', 'byte-compiled Emacs-Lisp program data'],
+  [0L, 'string', '=', ';ELC\023\000\000\000', 'byte-compiled Emacs-Lisp program data'],
+  [0L, 'string', '=', "(SYSTEM::VERSION '", 'CLISP byte-compiled Lisp program text'],
+  [0L, 'long', '=', 1886817234L, 'CLISP memory image data'],
+  [0L, 'long', '=', 3532355184L, 'CLISP memory image data, other endian'],
+  [0L, 'long', '=', 3725722773L, 'GNU-format message catalog data'],
+  [0L, 'long', '=', 2500072158L, 'GNU-format message catalog data'],
+  [0L, 'belong', '=', 3405691582L, 'mach-o fat file'],
+  [0L, 'belong', '=', 4277009102L, 'mach-o'],
+  [11L, 'string', '=', 'must be converted with BinHex', 'BinHex binary text'],
+  [0L, 'string', '=', 'SIT!', 'StuffIt Archive (data)'],
+  [65L, 'string', '=', 'SIT!', 'StuffIt Archive (rsrc + data)'],
+  [0L, 'string', '=', 'SITD', 'StuffIt Deluxe (data)'],
+  [65L, 'string', '=', 'SITD', 'StuffIt Deluxe (rsrc + data)'],
+  [0L, 'string', '=', 'Seg', 'StuffIt Deluxe Segment (data)'],
+  [65L, 'string', '=', 'Seg', 'StuffIt Deluxe Segment (rsrc + data)'],
+  [0L, 'string', '=', 'APPL', 'Macintosh Application (data)'],
+  [65L, 'string', '=', 'APPL', 'Macintosh Application (rsrc + data)'],
+  [0L, 'string', '=', 'zsys', 'Macintosh System File (data)'],
+  [65L, 'string', '=', 'zsys', 'Macintosh System File(rsrc + data)'],
+  [0L, 'string', '=', 'FNDR', 'Macintosh Finder (data)'],
+  [65L, 'string', '=', 'FNDR', 'Macintosh Finder(rsrc + data)'],
+  [0L, 'string', '=', 'libr', 'Macintosh Library (data)'],
+  [65L, 'string', '=', 'libr', 'Macintosh Library(rsrc + data)'],
+  [0L, 'string', '=', 'shlb', 'Macintosh Shared Library (data)'],
+  [65L, 'string', '=', 'shlb', 'Macintosh Shared Library(rsrc + data)'],
+  [0L, 'string', '=', 'cdev', 'Macintosh Control Panel (data)'],
+  [65L, 'string', '=', 'cdev', 'Macintosh Control Panel(rsrc + data)'],
+  [0L, 'string', '=', 'INIT', 'Macintosh Extension (data)'],
+  [65L, 'string', '=', 'INIT', 'Macintosh Extension(rsrc + data)'],
+  [0L, 'string', '=', 'FFIL', 'font/ttf'],
+  [65L, 'string', '=', 'FFIL', 'font/ttf'],
+  [0L, 'string', '=', 'LWFN', 'font/type1'],
+  [65L, 'string', '=', 'LWFN', 'font/type1'],
+  [0L, 'string', '=', 'PACT', 'Macintosh Compact Pro Archive (data)'],
+  [65L, 'string', '=', 'PACT', 'Macintosh Compact Pro Archive(rsrc + data)'],
+  [0L, 'string', '=', 'ttro', 'Macintosh TeachText File (data)'],
+  [65L, 'string', '=', 'ttro', 'Macintosh TeachText File(rsrc + data)'],
+  [0L, 'string', '=', 'TEXT', 'Macintosh TeachText File (data)'],
+  [65L, 'string', '=', 'TEXT', 'Macintosh TeachText File(rsrc + data)'],
+  [0L, 'string', '=', 'PDF', 'Macintosh PDF File (data)'],
+  [65L, 'string', '=', 'PDF', 'Macintosh PDF File(rsrc + data)'],
+  [0L, 'string', '=', '# Magic', 'magic text file for file(1) cmd'],
+  [0L, 'string', '=', 'Relay-Version:', 'old news text'],
+  [0L, 'string', '=', '#! rnews', 'batched news text'],
+  [0L, 'string', '=', 'N#! rnews', 'mailed, batched news text'],
+  [0L, 'string', '=', 'Forward to', 'mail forwarding text'],
+  [0L, 'string', '=', 'Pipe to', 'mail piping text'],
+  [0L, 'string', '=', 'Return-Path:', 'message/rfc822'],
+  [0L, 'string', '=', 'Path:', 'message/news'],
+  [0L, 'string', '=', 'Xref:', 'message/news'],
+  [0L, 'string', '=', 'From:', 'message/rfc822'],
+  [0L, 'string', '=', 'Article', 'message/news'],
+  [0L, 'string', '=', 'BABYL', 'message/x-gnu-rmail'],
+  [0L, 'string', '=', 'Received:', 'message/rfc822'],
+  [0L, 'string', '=', 'MIME-Version:', 'MIME entity text'],
+  [0L, 'string', '=', 'Content-Type: ', ''],
+  [0L, 'string', '=', 'Content-Type:', ''],
+  [0L, 'long', '=', 31415L, 'Mirage Assembler m.out executable'],
+  [0L, 'string', '=', '\311\304', 'ID tags data'],
+  [0L, 'string', '=', '\001\001\001\001', 'MMDF mailbox'],
+  [4L, 'string', '=', 'Research,', 'Digifax-G3-File'],
+  [0L, 'short', '=', 256L, 'raw G3 data, byte-padded'],
+  [0L, 'short', '=', 5120L, 'raw G3 data'],
+  [0L, 'string', '=', 'RMD1', 'raw modem data'],
+  [0L, 'string', '=', 'PVF1\012', 'portable voice format'],
+  [0L, 'string', '=', 'PVF2\012', 'portable voice format'],
+  [0L, 'beshort', '=', 520L, 'mc68k COFF'],
+  [0L, 'beshort', '=', 521L, 'mc68k executable (shared)'],
+  [0L, 'beshort', '=', 522L, 'mc68k executable (shared demand paged)'],
+  [0L, 'beshort', '=', 554L, '68K BCS executable'],
+  [0L, 'beshort', '=', 555L, '88K BCS executable'],
+  [0L, 'string', '=', 'S0', 'Motorola S-Record; binary data in text format'],
+  [0L, 'string', '=', '@echo off', 'MS-DOS batch file text'],
+  [128L, 'string', '=', 'PE\000\000', 'MS Windows PE'],
+  [0L, 'leshort', '=', 332L, 'MS Windows COFF Intel 80386 object file'],
+  [0L, 'leshort', '=', 358L, 'MS Windows COFF MIPS R4000 object file'],
+  [0L, 'leshort', '=', 388L, 'MS Windows COFF Alpha object file'],
+  [0L, 'leshort', '=', 616L, 'MS Windows COFF Motorola 68000 object file'],
+  [0L, 'leshort', '=', 496L, 'MS Windows COFF PowerPC object file'],
+  [0L, 'leshort', '=', 656L, 'MS Windows COFF PA-RISC object file'],
+  [0L, 'string', '=', 'MZ', 'application/x-ms-dos-executable'],
+  [0L, 'string', '=', 'LZ', 'MS-DOS executable (built-in)'],
+  [0L, 'string', '=', 'regf', 'Windows NT Registry file'],
+  [2080L, 'string', '=', 'Microsoft Word 6.0 Document', 'text/vnd.ms-word'],
+  [2080L, 'string', '=', 'Documento Microsoft Word 6', 'text/vnd.ms-word'],
+  [2112L, 'string', '=', 'MSWordDoc', 'text/vnd.ms-word'],
+  [0L, 'belong', '=', 834535424L, 'text/vnd.ms-word'],
+  [0L, 'string', '=', 'PO^Q`', 'text/vnd.ms-word'],
+  [2080L, 'string', '=', 'Microsoft Excel 5.0 Worksheet', 'application/vnd.ms-excel'],
+  [2114L, 'string', '=', 'Biff5', 'application/vnd.ms-excel'],
+  [0L, 'belong', '=', 6656L, 'Lotus 1-2-3'],
+  [0L, 'belong', '=', 512L, 'Lotus 1-2-3'],
+  [1L, 'string', '=', 'WPC', 'text/vnd.wordperfect'],
+  [0L, 'beshort', '=', 610L, 'Tower/XP rel 2 object'],
+  [0L, 'beshort', '=', 615L, 'Tower/XP rel 2 object'],
+  [0L, 'beshort', '=', 620L, 'Tower/XP rel 3 object'],
+  [0L, 'beshort', '=', 625L, 'Tower/XP rel 3 object'],
+  [0L, 'beshort', '=', 630L, 'Tower32/600/400 68020 object'],
+  [0L, 'beshort', '=', 640L, 'Tower32/800 68020'],
+  [0L, 'beshort', '=', 645L, 'Tower32/800 68010'],
+  [0L, 'lelong', '=', 407L, 'NetBSD little-endian object file'],
+  [0L, 'belong', '=', 407L, 'NetBSD big-endian object file'],
+  [0L, 'belong&0377777777', '=', 41400413L, 'NetBSD/i386 demand paged'],
+  [0L, 'belong&0377777777', '=', 41400410L, 'NetBSD/i386 pure'],
+  [0L, 'belong&0377777777', '=', 41400407L, 'NetBSD/i386'],
+  [0L, 'belong&0377777777', '=', 41400507L, 'NetBSD/i386 core'],
+  [0L, 'belong&0377777777', '=', 41600413L, 'NetBSD/m68k demand paged'],
+  [0L, 'belong&0377777777', '=', 41600410L, 'NetBSD/m68k pure'],
+  [0L, 'belong&0377777777', '=', 41600407L, 'NetBSD/m68k'],
+  [0L, 'belong&0377777777', '=', 41600507L, 'NetBSD/m68k core'],
+  [0L, 'belong&0377777777', '=', 42000413L, 'NetBSD/m68k4k demand paged'],
+  [0L, 'belong&0377777777', '=', 42000410L, 'NetBSD/m68k4k pure'],
+  [0L, 'belong&0377777777', '=', 42000407L, 'NetBSD/m68k4k'],
+  [0L, 'belong&0377777777', '=', 42000507L, 'NetBSD/m68k4k core'],
+  [0L, 'belong&0377777777', '=', 42200413L, 'NetBSD/ns32532 demand paged'],
+  [0L, 'belong&0377777777', '=', 42200410L, 'NetBSD/ns32532 pure'],
+  [0L, 'belong&0377777777', '=', 42200407L, 'NetBSD/ns32532'],
+  [0L, 'belong&0377777777', '=', 42200507L, 'NetBSD/ns32532 core'],
+  [0L, 'belong&0377777777', '=', 42400413L, 'NetBSD/sparc demand paged'],
+  [0L, 'belong&0377777777', '=', 42400410L, 'NetBSD/sparc pure'],
+  [0L, 'belong&0377777777', '=', 42400407L, 'NetBSD/sparc'],
+  [0L, 'belong&0377777777', '=', 42400507L, 'NetBSD/sparc core'],
+  [0L, 'belong&0377777777', '=', 42600413L, 'NetBSD/pmax demand paged'],
+  [0L, 'belong&0377777777', '=', 42600410L, 'NetBSD/pmax pure'],
+  [0L, 'belong&0377777777', '=', 42600407L, 'NetBSD/pmax'],
+  [0L, 'belong&0377777777', '=', 42600507L, 'NetBSD/pmax core'],
+  [0L, 'belong&0377777777', '=', 43000413L, 'NetBSD/vax demand paged'],
+  [0L, 'belong&0377777777', '=', 43000410L, 'NetBSD/vax pure'],
+  [0L, 'belong&0377777777', '=', 43000407L, 'NetBSD/vax'],
+  [0L, 'belong&0377777777', '=', 43000507L, 'NetBSD/vax core'],
+  [0L, 'lelong', '=', 459141L, 'ECOFF NetBSD/alpha binary'],
+  [0L, 'belong&0377777777', '=', 43200507L, 'NetBSD/alpha core'],
+  [0L, 'belong&0377777777', '=', 43400413L, 'NetBSD/mips demand paged'],
+  [0L, 'belong&0377777777', '=', 43400410L, 'NetBSD/mips pure'],
+  [0L, 'belong&0377777777', '=', 43400407L, 'NetBSD/mips'],
+  [0L, 'belong&0377777777', '=', 43400507L, 'NetBSD/mips core'],
+  [0L, 'belong&0377777777', '=', 43600413L, 'NetBSD/arm32 demand paged'],
+  [0L, 'belong&0377777777', '=', 43600410L, 'NetBSD/arm32 pure'],
+  [0L, 'belong&0377777777', '=', 43600407L, 'NetBSD/arm32'],
+  [0L, 'belong&0377777777', '=', 43600507L, 'NetBSD/arm32 core'],
+  [0L, 'string', '=', 'StartFontMetrics', 'font/x-sunos-news'],
+  [0L, 'string', '=', 'StartFont', 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773060L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773063L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773072L, 'font/x-sunos-news'],
+  [0L, 'belong', '=', 326773073L, 'font/x-sunos-news'],
+  [8L, 'belong', '=', 326773573L, 'font/x-sunos-news'],
+  [8L, 'belong', '=', 326773576L, 'font/x-sunos-news'],
+  [0L, 'string', '=', 'Octave-1-L', 'Octave binary data (little endian)'],
+  [0L, 'string', '=', 'Octave-1-B', 'Octave binary data (big endian)'],
+  [0L, 'string', '=', '\177OLF', 'OLF'],
+  [0L, 'beshort', '=', 34765L, 'OS9/6809 module:'],
+  [0L, 'beshort', '=', 19196L, 'OS9/68K module:'],
+  [0L, 'long', '=', 61374L, 'OSF/Rose object'],
+  [0L, 'short', '=', 565L, 'i386 COFF object'],
+  [0L, 'short', '=', 10775L, '"compact bitmap" format (Poskanzer)'],
+  [0L, 'string', '=', '%PDF-', 'PDF document'],
+  [0L, 'lelong', '=', 101555L, 'PDP-11 single precision APL workspace'],
+  [0L, 'lelong', '=', 101554L, 'PDP-11 double precision APL workspace'],
+  [0L, 'leshort', '=', 407L, 'PDP-11 executable'],
+  [0L, 'leshort', '=', 401L, 'PDP-11 UNIX/RT ldp'],
+  [0L, 'leshort', '=', 405L, 'PDP-11 old overlay'],
+  [0L, 'leshort', '=', 410L, 'PDP-11 pure executable'],
+  [0L, 'leshort', '=', 411L, 'PDP-11 separate I&D executable'],
+  [0L, 'leshort', '=', 437L, 'PDP-11 kernel overlay'],
+  [0L, 'beshort', '=', 39168L, 'PGP key public ring'],
+  [0L, 'beshort', '=', 38145L, 'PGP key security ring'],
+  [0L, 'beshort', '=', 38144L, 'PGP key security ring'],
+  [0L, 'beshort', '=', 42496L, 'PGP encrypted data'],
+  [0L, 'string', '=', '-----BEGIN PGP', 'PGP armored data'],
+  [0L, 'string', '=', '# PaCkAgE DaTaStReAm', 'pkg Datastream (SVR4)'],
+  [0L, 'short', '=', 601L, 'mumps avl global'],
+  [0L, 'short', '=', 602L, 'mumps blt global'],
+  [0L, 'string', '=', '%!', 'application/postscript'],
+  [0L, 'string', '=', '\004%!', 'application/postscript'],
+  [0L, 'belong', '=', 3318797254L, 'DOS EPS Binary File'],
+  [0L, 'string', '=', '*PPD-Adobe:', 'PPD file'],
+  [0L, 'string', '=', '\033%-12345X at PJL', 'HP Printer Job Language data'],
+  [0L, 'string', '=', '\033%-12345X at PJL', 'HP Printer Job Language data'],
+  [0L, 'string', '=', '\033E\033', 'image/x-pcl-hp'],
+  [0L, 'string', '=', '@document(', 'Imagen printer'],
+  [0L, 'string', '=', 'Rast', 'RST-format raster font data'],
+  [0L, 'belong&0xff00ffff', '=', 1442840576L, 'ps database'],
+  [0L, 'long', '=', 1351614727L, 'Pyramid 90x family executable'],
+  [0L, 'long', '=', 1351614728L, 'Pyramid 90x family pure executable'],
+  [0L, 'long', '=', 1351614731L, 'Pyramid 90x family demand paged pure executable'],
+  [0L, 'beshort', '=', 60843L, ''],
+  [0L, 'string', '=', '{\\\\rtf', 'Rich Text Format data,'],
+  [38L, 'string', '=', 'Spreadsheet', 'sc spreadsheet file'],
+  [8L, 'string', '=', '\001s SCCS', 'archive data'],
+  [0L, 'byte', '=', 46L, 'Sendmail frozen configuration'],
+  [0L, 'short', '=', 10012L, 'Sendmail frozen configuration'],
+  [0L, 'lelong', '=', 234L, 'BALANCE NS32000 .o'],
+  [0L, 'lelong', '=', 4330L, 'BALANCE NS32000 executable (0 @ 0)'],
+  [0L, 'lelong', '=', 8426L, 'BALANCE NS32000 executable (invalid @ 0)'],
+  [0L, 'lelong', '=', 12522L, 'BALANCE NS32000 standalone executable'],
+  [0L, 'leshort', '=', 4843L, 'SYMMETRY i386 .o'],
+  [0L, 'leshort', '=', 8939L, 'SYMMETRY i386 executable (0 @ 0)'],
+  [0L, 'leshort', '=', 13035L, 'SYMMETRY i386 executable (invalid @ 0)'],
+  [0L, 'leshort', '=', 17131L, 'SYMMETRY i386 standalone executable'],
+  [0L, 'string', '=', 'kbd!map', 'kbd map file'],
+  [0L, 'belong', '=', 407L, 'old SGI 68020 executable'],
+  [0L, 'belong', '=', 410L, 'old SGI 68020 pure executable'],
+  [0L, 'beshort', '=', 34661L, 'disk quotas file'],
+  [0L, 'beshort', '=', 1286L, 'IRIS Showcase file'],
+  [0L, 'beshort', '=', 550L, 'IRIS Showcase template'],
+  [0L, 'belong', '=', 1396917837L, 'IRIS Showcase file'],
+  [0L, 'belong', '=', 1413695053L, 'IRIS Showcase template'],
+  [0L, 'belong', '=', 3735927486L, 'IRIX Parallel Arena'],
+  [0L, 'beshort', '=', 352L, 'MIPSEB COFF executable'],
+  [0L, 'beshort', '=', 354L, 'MIPSEL COFF executable'],
+  [0L, 'beshort', '=', 24577L, 'MIPSEB-LE COFF executable'],
+  [0L, 'beshort', '=', 25089L, 'MIPSEL-LE COFF executable'],
+  [0L, 'beshort', '=', 355L, 'MIPSEB MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 358L, 'MIPSEL MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 25345L, 'MIPSEB-LE MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 26113L, 'MIPSEL-LE MIPS-II COFF executable'],
+  [0L, 'beshort', '=', 320L, 'MIPSEB MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 322L, 'MIPSEL MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 16385L, 'MIPSEB-LE MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 16897L, 'MIPSEL-LE MIPS-III COFF executable'],
+  [0L, 'beshort', '=', 384L, 'MIPSEB Ucode'],
+  [0L, 'beshort', '=', 386L, 'MIPSEL Ucode'],
+  [0L, 'belong', '=', 3735924144L, 'IRIX core dump'],
+  [0L, 'belong', '=', 3735924032L, 'IRIX 64-bit core dump'],
+  [0L, 'belong', '=', 3133063355L, 'IRIX N32 core dump'],
+  [0L, 'string', '=', 'CrshDump', 'IRIX vmcore dump of'],
+  [0L, 'string', '=', 'SGIAUDIT', 'SGI Audit file'],
+  [0L, 'string', '=', 'WNGZWZSC', 'Wingz compiled script'],
+  [0L, 'string', '=', 'WNGZWZSS', 'Wingz spreadsheet'],
+  [0L, 'string', '=', 'WNGZWZHP', 'Wingz help file'],
+  [0L, 'string', '=', '\\#Inventor', 'V IRIS Inventor 1.0 file'],
+  [0L, 'string', '=', '\\#Inventor', 'V2 Open Inventor 2.0 file'],
+  [0L, 'string', '=', 'glfHeadMagic();', 'GLF_TEXT'],
+  [4L, 'belong', '=', 1090584576L, 'GLF_BINARY_LSB_FIRST'],
+  [4L, 'belong', '=', 321L, 'GLF_BINARY_MSB_FIRST'],
+  [0L, 'string', '=', '<!DOCTYPE HTML', 'text/html'],
+  [0L, 'string', '=', '<!doctype html', 'text/html'],
+  [0L, 'string', '=', '<HEAD', 'text/html'],
+  [0L, 'string', '=', '<head', 'text/html'],
+  [0L, 'string', '=', '<TITLE', 'text/html'],
+  [0L, 'string', '=', '<title', 'text/html'],
+  [0L, 'string', '=', '<html', 'text/html'],
+  [0L, 'string', '=', '<HTML', 'text/html'],
+  [0L, 'string', '=', '<!DOCTYPE', 'exported SGML document text'],
+  [0L, 'string', '=', '<!doctype', 'exported SGML document text'],
+  [0L, 'string', '=', '<!SUBDOC', 'exported SGML subdocument text'],
+  [0L, 'string', '=', '<!subdoc', 'exported SGML subdocument text'],
+  [0L, 'string', '=', '<!--', 'exported SGML document text'],
+  [0L, 'string', '=', 'RTSS', 'NetMon capture file'],
+  [0L, 'string', '=', 'TRSNIFF data    \032', 'Sniffer capture file'],
+  [0L, 'string', '=', 'XCP\000', 'NetXRay capture file'],
+  [0L, 'ubelong', '=', 2712847316L, 'tcpdump capture file (big-endian)'],
+  [0L, 'ulelong', '=', 2712847316L, 'tcpdump capture file (little-endian)'],
+  [0L, 'string', '=', '<!SQ DTD>', 'Compiled SGML rules file'],
+  [0L, 'string', '=', '<!SQ A/E>', 'A/E SGML Document binary'],
+  [0L, 'string', '=', '<!SQ STS>', 'A/E SGML binary styles file'],
+  [0L, 'short', '=', 49374L, 'Compiled PSI (v1) data'],
+  [0L, 'short', '=', 49370L, 'Compiled PSI (v2) data'],
+  [0L, 'short', '=', 125252L, 'SoftQuad DESC or font file binary'],
+  [0L, 'string', '=', 'SQ BITMAP1', 'SoftQuad Raster Format text'],
+  [0L, 'string', '=', 'X SoftQuad', 'troff Context intermediate'],
+  [0L, 'belong&077777777', '=', 600413L, 'sparc demand paged'],
+  [0L, 'belong&077777777', '=', 600410L, 'sparc pure'],
+  [0L, 'belong&077777777', '=', 600407L, 'sparc'],
+  [0L, 'belong&077777777', '=', 400413L, 'mc68020 demand paged'],
+  [0L, 'belong&077777777', '=', 400410L, 'mc68020 pure'],
+  [0L, 'belong&077777777', '=', 400407L, 'mc68020'],
+  [0L, 'belong&077777777', '=', 200413L, 'mc68010 demand paged'],
+  [0L, 'belong&077777777', '=', 200410L, 'mc68010 pure'],
+  [0L, 'belong&077777777', '=', 200407L, 'mc68010'],
+  [0L, 'belong', '=', 407L, 'old sun-2 executable'],
+  [0L, 'belong', '=', 410L, 'old sun-2 pure executable'],
+  [0L, 'belong', '=', 413L, 'old sun-2 demand paged executable'],
+  [0L, 'belong', '=', 525398L, 'SunOS core file'],
+  [0L, 'long', '=', 4197695630L, 'SunPC 4.0 Hard Disk'],
+  [0L, 'string', '=', '#SUNPC_CONFIG', 'SunPC 4.0 Properties Values'],
+  [0L, 'string', '=', 'snoop', 'Snoop capture file'],
+  [36L, 'string', '=', 'acsp', 'Kodak Color Management System, ICC Profile'],
+  [0L, 'string', '=', '#!teapot\012xdr', 'teapot work sheet (XDR format)'],
+  [0L, 'string', '=', '\032\001', 'Compiled terminfo entry'],
+  [0L, 'short', '=', 433L, 'Curses screen image'],
+  [0L, 'short', '=', 434L, 'Curses screen image'],
+  [0L, 'string', '=', '\367\002', 'TeX DVI file'],
+  [0L, 'string', '=', '\367\203', 'font/x-tex'],
+  [0L, 'string', '=', '\367Y', 'font/x-tex'],
+  [0L, 'string', '=', '\367\312', 'font/x-tex'],
+  [0L, 'string', '=', 'This is TeX,', 'TeX transcript text'],
+  [0L, 'string', '=', 'This is METAFONT,', 'METAFONT transcript text'],
+  [2L, 'string', '=', '\000\021', 'font/x-tex-tfm'],
+  [2L, 'string', '=', '\000\022', 'font/x-tex-tfm'],
+  [0L, 'string', '=', '\\\\input\\', 'texinfo Texinfo source text'],
+  [0L, 'string', '=', 'This is Info file', 'GNU Info text'],
+  [0L, 'string', '=', '\\\\input', 'TeX document text'],
+  [0L, 'string', '=', '\\\\section', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\setlength', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\documentstyle', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\chapter', 'LaTeX document text'],
+  [0L, 'string', '=', '\\\\documentclass', 'LaTeX 2e document text'],
+  [0L, 'string', '=', '\\\\relax', 'LaTeX auxiliary file'],
+  [0L, 'string', '=', '\\\\contentsline', 'LaTeX table of contents'],
+  [0L, 'string', '=', '\\\\indexentry', 'LaTeX raw index file'],
+  [0L, 'string', '=', '\\\\begin{theindex}', 'LaTeX sorted index'],
+  [0L, 'string', '=', '\\\\glossaryentry', 'LaTeX raw glossary'],
+  [0L, 'string', '=', '\\\\begin{theglossary}', 'LaTeX sorted glossary'],
+  [0L, 'string', '=', 'This is makeindex', 'Makeindex log file'],
+  [0L, 'string', '=', '**TI82**', 'TI-82 Graphing Calculator'],
+  [0L, 'string', '=', '**TI83**', 'TI-83 Graphing Calculator'],
+  [0L, 'string', '=', '**TI85**', 'TI-85 Graphing Calculator'],
+  [0L, 'string', '=', '**TI92**', 'TI-92 Graphing Calculator'],
+  [0L, 'string', '=', '**TI80**', 'TI-80 Graphing Calculator File.'],
+  [0L, 'string', '=', '**TI81**', 'TI-81 Graphing Calculator File.'],
+  [0L, 'string', '=', 'TZif', 'timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\005\000', 'old timezone data'],
+  [0L, 'string', '=', '\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\006\000', 'old timezone data'],
+  [0L, 'string', '=', '.\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\'\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\'.\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', '\\\\"', 'troff or preprocessor input text'],
+  [0L, 'string', '=', 'x T', 'ditroff text'],
+  [0L, 'string', '=', '@\357', 'very old (C/A/T) troff output data'],
+  [0L, 'string', '=', 'Interpress/Xerox', 'Xerox InterPress data'],
+  [0L, 'short', '=', 263L, 'unknown machine executable'],
+  [0L, 'short', '=', 264L, 'unknown pure executable'],
+  [0L, 'short', '=', 265L, 'PDP-11 separate I&D'],
+  [0L, 'short', '=', 267L, 'unknown pure executable'],
+  [0L, 'long', '=', 268L, 'unknown demand paged pure executable'],
+  [0L, 'long', '=', 269L, 'unknown demand paged pure executable'],
+  [0L, 'long', '=', 270L, 'unknown readable demand paged pure executable'],
+  [0L, 'string', '=', 'begin uuencoded', 'or xxencoded text'],
+  [0L, 'string', '=', 'xbtoa Begin', "btoa'd text"],
+  [0L, 'string', '=', '$\012ship', "ship'd binary text"],
+  [0L, 'string', '=', 'Decode the following with bdeco', 'bencoded News text'],
+  [11L, 'string', '=', 'must be converted with BinHex', 'BinHex binary text'],
+  [0L, 'short', '=', 610L, 'Perkin-Elmer executable'],
+  [0L, 'beshort', '=', 572L, 'amd 29k coff noprebar executable'],
+  [0L, 'beshort', '=', 1572L, 'amd 29k coff prebar executable'],
+  [0L, 'beshort', '=', 160007L, 'amd 29k coff archive'],
+  [6L, 'beshort', '=', 407L, 'unicos (cray) executable'],
+  [596L, 'string', '=', 'X\337\377\377', 'Ultrix core file'],
+  [0L, 'string', '=', 'Joy!peffpwpc', 'header for PowerPC PEF executable'],
+  [0L, 'lelong', '=', 101557L, 'VAX single precision APL workspace'],
+  [0L, 'lelong', '=', 101556L, 'VAX double precision APL workspace'],
+  [0L, 'lelong', '=', 407L, 'VAX executable'],
+  [0L, 'lelong', '=', 410L, 'VAX pure executable'],
+  [0L, 'lelong', '=', 413L, 'VAX demand paged pure executable'],
+  [0L, 'leshort', '=', 570L, 'VAX COFF executable'],
+  [0L, 'leshort', '=', 575L, 'VAX COFF pure executable'],
+  [0L, 'string', '=', 'LBLSIZE=', 'VICAR image data'],
+  [43L, 'string', '=', 'SFDU_LABEL', 'VICAR label file'],
+  [0L, 'short', '=', 21845L, 'VISX image file'],
+  [0L, 'string', '=', '\260\0000\000', 'VMS VAX executable'],
+  [0L, 'belong', '=', 50331648L, 'VMS Alpha executable'],
+  [1L, 'string', '=', 'WPC', '(Corel/WP)'],
+  [0L, 'string', '=', 'core', 'core file (Xenix)'],
+  [0L, 'byte', '=', 128L, '8086 relocatable (Microsoft)'],
+  [0L, 'leshort', '=', 65381L, 'x.out'],
+  [0L, 'leshort', '=', 518L, 'Microsoft a.out'],
+  [0L, 'leshort', '=', 320L, 'old Microsoft 8086 x.out'],
+  [0L, 'lelong', '=', 518L, 'b.out'],
+  [0L, 'leshort', '=', 1408L, 'XENIX 8086 relocatable or 80286 small model'],
+  [0L, 'long', '=', 59399L, 'object file (z8000 a.out)'],
+  [0L, 'long', '=', 59400L, 'pure object file (z8000 a.out)'],
+  [0L, 'long', '=', 59401L, 'separate object file (z8000 a.out)'],
+  [0L, 'long', '=', 59397L, 'overlay object file (z8000 a.out)'],
+  [0L, 'string', '=', 'ZyXEL\002', 'ZyXEL voice data'],
+]
+
+magicNumbers = []
+
+def strToNum(n):
+  val = 0
+  col = long(1)
+  if n[:1] == 'x': n = '0' + n
+  if n[:2] == '0x':
+    # hex
+    n = string.lower(n[2:])
+    while len(n) > 0:
+      l = n[len(n) - 1]
+      val = val + string.hexdigits.index(l) * col
+      col = col * 16
+      n = n[:len(n)-1]
+  elif n[0] == '\\':
+    # octal
+    n = n[1:]
+    while len(n) > 0:
+      l = n[len(n) - 1]
+      if ord(l) < 48 or ord(l) > 57: break
+      val = val + int(l) * col
+      col = col * 8
+      n = n[:len(n)-1]
+  else:
+    val = string.atol(n)
+  return val
+       
+def unescape(s):
+  # replace string escape sequences
+  while 1:
+    m = re.search(r'\\', s)
+    if not m: break
+    x = m.start()+1
+    if m.end() == len(s): 
+      # escaped space at end
+      s = s[:len(s)-1] + ' '
+    elif s[x:x+2] == '0x':
+      # hex ascii value
+      c = chr(strToNum(s[x:x+4]))
+      s = s[:x-1] + c + s[x+4:]
+    elif s[m.start()+1] == 'x':
+      # hex ascii value
+      c = chr(strToNum(s[x:x+3]))
+      s = s[:x-1] + c + s[x+3:]
+    elif ord(s[x]) > 47 and ord(s[x]) < 58:
+      # octal ascii value
+      end = x
+      while (ord(s[end]) > 47 and ord(s[end]) < 58):
+        end = end + 1
+        if end > len(s) - 1: break
+      c = chr(strToNum(s[x-1:end]))
+      s = s[:x-1] + c + s[end:]
+    elif s[x] == 'n':
+      # newline
+      s = s[:x-1] + '\n' + s[x+1:]
+    else:
+      break
+  return s
+
+class magicTest:
+  def __init__(self, offset, t, op, value, msg, mask = None):
+    if t.count('&') > 0:
+      mask = strToNum(t[t.index('&')+1:])  
+      t = t[:t.index('&')]
+    if type(offset) == type('a'):
+      self.offset = strToNum(offset)
+    else:
+      self.offset = offset
+    self.type = t
+    self.msg = msg
+    self.subTests = []
+    self.op = op
+    self.mask = mask
+    self.value = value
+      
+
+  def test(self, data):
+    if self.mask:
+      data = data & self.mask
+    if self.op == '=': 
+      if self.value == data: return self.msg
+    elif self.op ==  '<':
+      pass
+    elif self.op ==  '>':
+      pass
+    elif self.op ==  '&':
+      pass
+    elif self.op ==  '^':
+      pass
+    return None
+
+  def compare(self, data):
+    #print str([self.type, self.value, self.msg])
+    try: 
+      if self.type == 'string':
+        c = ''; s = ''
+        for i in range(0, len(self.value)+1):
+          if i + self.offset > len(data) - 1: break
+          s = s + c
+          [c] = struct.unpack('c', data[self.offset + i])
+        data = s
+      elif self.type == 'short':
+        [data] = struct.unpack('h', data[self.offset : self.offset + 2])
+      elif self.type == 'leshort':
+        [data] = struct.unpack('<h', data[self.offset : self.offset + 2])
+      elif self.type == 'beshort':
+        [data] = struct.unpack('>H', data[self.offset : self.offset + 2])
+      elif self.type == 'long':
+        [data] = struct.unpack('l', data[self.offset : self.offset + 4])
+      elif self.type == 'lelong':
+        [data] = struct.unpack('<l', data[self.offset : self.offset + 4])
+      elif self.type == 'belong':
+        [data] = struct.unpack('>l', data[self.offset : self.offset + 4])
+      else:
+        #print 'UNKNOWN TYPE: ' + self.type
+        pass
+    except:
+      return None
+  
+#    print str([self.msg, self.value, data])
+    return self.test(data)
+    
+
+def load(file):
+  global magicNumbers
+  lines = open(file).readlines()
+  last = { 0: None }
+  for line in lines:
+    if re.match(r'\s*#', line):
+      # comment
+      continue
+    else:
+      # split up by space delimiters, and remove trailing space
+      line = string.rstrip(line)
+      line = re.split(r'\s*', line)
+      if len(line) < 3:
+        # bad line
+        continue
+      offset = line[0]
+      type = line[1]
+      value = line[2]
+      level = 0
+      while offset[0] == '>':
+        # count the level of the type
+        level = level + 1
+        offset = offset[1:]
+      l = magicNumbers
+      if level > 0:
+        l = last[level - 1].subTests
+      if offset[0] == '(':
+        # don't handle indirect offsets just yet
+        print 'SKIPPING ' + string.join(list(line[3:]))
+        pass
+      elif offset[0] == '&':
+        # don't handle relative offsets just yet
+        print 'SKIPPING ' + string.join(list(line[3:]))
+        pass
+      else:
+        operands = ['=', '<', '>', '&']
+        if operands.count(value[0]) > 0:
+          # a comparison operator is specified
+          op = value[0] 
+          value = value[1:]
+        else:
+          print str([value, operands])
+          if len(value) >1 and value[0] == '\\' and operands.count(value[1]) >0:
+            # literal value that collides with operands is escaped
+            value = value[1:]
+          op = '='
+
+        mask = None
+        if type == 'string':
+          while 1:
+            value = unescape(value)
+            if value[len(value)-1] == ' ' and len(line) > 3:
+              # last value was an escaped space, join
+              value = value + line[3]
+              del line[3]
+            else:
+              break
+        else:
+          if value.count('&') != 0:
+            mask = value[(value.index('&') + 1):]
+            print 'MASK: ' + mask
+            value = value[:(value.index('&')+1)]
+          try: value = strToNum(value)
+          except: continue
+          msg = string.join(list(line[3:]))
+        new = magicTest(offset, type, op, value, msg, mask)
+        last[level] = new
+        l.append(new)
+
+def whatis(data):
+  for test in magicNumbers:
+     m = test.compare(data)
+     if m: return m
+  # no matching, magic number. is it binary or text?
+  for c in data:
+    if ord(c) > 128:
+      return 'data'
+  # its ASCII, now do text tests
+  if string.find('The', data, 0, 8192) > -1:
+    return 'English text'
+  if string.find('def', data, 0, 8192) > -1:
+    return 'Python Source'
+  return 'ASCII text'
+      
+    
+def file(file):
+  try:
+    return whatis(open(file, 'r').read(8192))
+  except Exception, e:
+    if str(e) == '[Errno 21] Is a directory':
+      return 'directory'
+    else:
+      raise e
+  
+
+#### BUILD DATA ####
+#load('mime-magic')
+#f = open('out', 'w')
+#for m in magicNumbers:
+#  f.write(str([m.offset, m.type, m.op, m.value, m.msg]) + ',\n')
+#f.close
+
+import sys
+for m in magic:
+  magicNumbers.append(magicTest(m[0], m[1], m[2], m[3], m[4]))
+
+if __name__ == '__main__':
+  import sys
+  for arg in sys.argv[1:]:
+    msg = file(arg)
+    if msg:
+      print arg + ': ' + msg
+    else:
+      print arg + ': unknown'

Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/hachoir.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -8,10 +8,11 @@
 """
 
 import sys, os, re, traceback
-from hachoir_class import Hachoir
 from program import PROGRAM, VERSION
 from log import log
 from error import error
+from hachoir_class import Hachoir
+import ui.ui as ui
 
 def usage(defval):
     print "%s version %s" % (PROGRAM, VERSION)
@@ -82,13 +83,17 @@
         for key in opt:
             setattr(hachoir, key, opt[key])
         try:
-            import ui.ui as ui
+            ui.loadInterface(hachoir)
         except ImportError, err:
-            error("""Error: a Python module is missing:\n%s\n
+            error("""Error: a Python module is missing:
+%s
+
 You can find PyGTK at: http://www.pygtk.org/
-and PyGlade at: http://glade.gnome.org/""" % (err))
+and PyGlade at: http://glade.gnome.org/
+
+Debian: apt-get install python2.4-gtk
+Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
             sys.exit(1)
-        ui.loadInterface(hachoir)
         hachoir.run(filename)
 
     except SystemExit:
@@ -97,4 +102,6 @@
         where = "".join(traceback.format_exception( \
             sys.exc_type, sys.exc_value, sys.exc_traceback))
         error("Exception:\n%s\n%s" % (err, where))
+	sys.exit(1)
+
 if __name__=="__main__": main()    

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/hachoir_class.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -3,8 +3,9 @@
 from chunk import FilterChunk
 from default import DefaultFilter
 from user_filter import UserFilterDescriptor, loadUserFilter
-from error import error
+from error import error, warning
 from tools import getBacktrace
+from mime import getStreamMime
 
 class Hachoir:
     instance = None
@@ -96,7 +97,11 @@
 
     def loadStream(self, stream, filename=None):
         # Look for a plugin
-        split_class = getPluginByStream(stream, filename)
+        split_class = getPluginByStream(stream, filename, None)
+        if split_class == None:
+            mimes = [ item[0] for item in getStreamMime(stream, filename)]
+            warning("Warning: No plugin found for MIME %s." % ", ".join(mimes))
+            split_class = DefaultFilter
             
         # Split 
         try:

Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/mime.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -9,18 +9,33 @@
 - http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
 """
 
-import os, stat, string
+import os, stat, string, re
+from error import warning
 
 instance = None
 
-def getInstance():
-    global instance
-    if instance == None:
-        import magic
-        instance = magic.open(magic.MAGIC_MIME)
-        instance.load()
-    return instance
+class GuessMime:
+    def __init__(self):
+        self.use_failback = False
+        self.func = None
+        try:
+            import magic
+            self.func = magic.open(magic.MAGIC_MIME)
+            self.func.load()
+        except ImportError:
+            warning("Warning: The library libmagic for Python is unavailable. Using internal fallback engine.")
+            self.use_failback = True
+        if self.use_failback:
+            from  failback.magic import whatis
+            self.func = whatis
 
+    def guess(self, buffer):
+        if not self.use_failback:
+            return self.func.buffer(buffer)
+        else:
+            mime = self.func(buffer)
+            return mime
+
 def getFileMime(realname, filename=None):
     if filename == None:
         filename = realname
@@ -37,8 +52,18 @@
         return 'application/x-gzip'
     return None        
 
-def _getBufferMime(buffer):    
-    if ord(buffer[0])==31 and ord(buffer[1])==139:
+def getStreamMime(stream, filename):
+    oldpos = stream.tell()
+    stream.seek(0)
+    size = stream.getSize()
+    if 4096<size:
+        size = 4096
+    data = stream.getN(size)
+    stream.seek(oldpos)
+    return getBufferMime(data, filename)
+
+def getAnotherBufferMime(buffer):    
+    if 2<=len(buffer) and ord(buffer[0])==31 and ord(buffer[1])==139:
         return "application/x-gzip"
     if buffer[:4] == "%PDF":
         return "application/pdf"
@@ -54,10 +79,18 @@
     - "text/plain, text/xml" => [["text/plain"],["text/xml"]]
     - "text/plain; charset=ISO-8859-1; format=flowed"
       => [['text/plain', {'charset': 'ISO-8859-1', 'format': 'flowed'}]]
+    - "application/x-archive application/x-debian-package"
     """
+
+
+    #mimes = map(string.strip, mimes.split(","))
     
+    regex = re.compile("[^/]+/[^; ]+(?:;[^;]+)*")
+    mimes = regex.findall(mimes)    
+    
     list = []
-    for mime in map(string.strip, mimes.split(",")):
+    for mime in mimes:
+        mime = mime.strip(" ,")
         parts = mime.split(";")
         mime = parts[0]
         parts = map(string.strip, parts[1:])
@@ -70,12 +103,14 @@
     return list
 
 def getBufferMime(buffer, filename):
-    magic = getInstance()
-    mimes = magic.buffer(buffer)
+    global instance
+    if instance == None:
+        instance = GuessMime()
+    mimes = instance.guess(buffer)
     mimes = splitMimes(mimes)
-    if mimes[0][0] == 'application/octet-stream' and filename != None:
+    if (len(mimes) == 0 or mimes[0][0] == 'application/octet-stream') and filename != None:
         ext = os.path.splitext(filename)[1]
-        new_mime = _getBufferMime(buffer)
+        new_mime = getAnotherBufferMime(buffer)
         if new_mime == None:
             new_mime = getMimeByExt(ext)
         if new_mime != None:

Modified: haypo/hachoir/plugin.py
===================================================================
--- haypo/hachoir/plugin.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/plugin.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -1,16 +1,9 @@
 import re
-from mime import getFileMime, getBufferMime
+from mime import getFileMime, getStreamMime
 from default import DefaultFilter
 
 def guessPlugin(stream, filename, default=DefaultFilter):
-    oldpos = stream.tell()
-    size = stream.getSize()
-    if 4096<size:
-        size = 4096
-    buffer = stream.getN(size)
-    plugin = getPluginByBuffer(buffer, filename, default)
-    stream.seek(oldpos)
-    return plugin
+    return getPluginByStream(stream, filename, default)
 
 def getPluginByMime(mimes, default=DefaultFilter):
     global hachoir_plugins
@@ -25,19 +18,8 @@
         warning("More than one plugin have same MIME...")
     return plugins[0]
     
-def getPluginByBuffer(buffer, filename, default=DefaultFilter):
-    mime = getBufferMime(buffer, filename)
-    return getPluginByMime(mime, default)
-
 def getPluginByStream(stream, filename, default=DefaultFilter):
-    oldpos = stream.tell()
-    stream.seek(0)
-    size = stream.getSize()
-    if 4096<size:
-        size = 4096
-    data = stream.getN(size)
-    stream.seek(oldpos)
-    mime = getBufferMime(data, filename)
+    mime = getStreamMime(stream, filename)
     return getPluginByMime(mime, default)
 
 def getPluginByFile(filename, realname=None, default=DefaultFilter):

Modified: haypo/hachoir/plugins/deb.py
===================================================================
--- haypo/hachoir/plugins/deb.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/plugins/deb.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -10,7 +10,7 @@
         Filter.__init__(self, "file_entry", "File entry", stream, parent)
         self.readString("header", "UnixLine", "Header")
 #        info = re.split(" +", self.header)
-        info = self.header.split()
+        info = self["header"].split()
         filename = info[0]
         size = int(info[5])
         dataio = stream.createSub(stream.tell(), size)

Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/plugins/elf.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -8,7 +8,7 @@
 
 class ELF_Header(Filter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "default", "default", stream, parent)
+        Filter.__init__(self, "elf_header", "ELF header", stream, parent)
         self.read("id", "4s", "Identifier")
         assert self["id"] == (chr(127) + "ELF")
         self.read("class", "B", "Class")
@@ -59,7 +59,7 @@
 
 class ELF_Filter(Filter):
     def __init__(self, stream, parent):
-        Filter.__init__(self, "default", "default", stream, parent)
+        Filter.__init__(self, "elf", "ELF file", stream, parent)
         self.readChild("header", ELF_Header)
 
 registerPlugin(ELF_Filter, "application/x-executable")

Modified: haypo/hachoir/plugins/pdf.py
===================================================================
--- haypo/hachoir/plugins/pdf.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/plugins/pdf.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -47,15 +47,16 @@
         self.setDescription("Object (%s)" % info)
 
     def readContent(self):
-        chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+        text = "" 
         deflate = False
-        while chunk.value not in ("endobj", "stream"):
-            self.processLine(chunk.value)
+        while text not in ("endobj", "stream"):
+            self.processLine(text)
+            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
+            text = chunk.value
+            if re.match(r".*/Filter /FlateDecode.*", chunk.value) != None:
+                deflate = True
             if self.getStream().eof():
                 return "eof"
-            chunk = self.readString("line[]", "AutoLine", "", post=stripLine)
-            if re.match(r"^.*/Filter /FlateDecode", chunk.value) != None:
-                deflate = True
         if chunk.value == "endobj":
             chunk.id = "endobj"
             chunk.description = "Object end"
@@ -90,8 +91,8 @@
             self.readString("data_end[]", "AutoLine", "Data end")
             self.readString("endobj", "AutoLine", "Object end", post=stripLine)
         ver = self.getParent().version
-        if ver[0] > 1 or (ver[0] == 1 and ver[1] > 0):
-            # PDF > 1.0 
+        eol = self.getStream().read(1, seek=False)
+        if eol in ("\n", "\r"):
             self.readString("emptyline", "AutoLine", "")
 
     def readXref(self):

Modified: haypo/hachoir/plugins/png.py
===================================================================
--- haypo/hachoir/plugins/png.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/plugins/png.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -119,4 +119,4 @@
     def __str__(self):
         return "PngChunk <size=%u, type=%s>" % (self["size"], self["type"])
 
-registerPlugin(PngFile, "image/png")
+registerPlugin(PngFile, ["image/png", "image/x-png"])

Modified: haypo/hachoir/plugins/tar.py
===================================================================
--- haypo/hachoir/plugins/tar.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/plugins/tar.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -165,4 +165,4 @@
             if file.isEmpty(): return True
         return stream.eof()
         
-registerPlugin(TarFile, "application/x-tar")
+registerPlugin(TarFile, ["application/x-gtar", "application/x-tar"])

Modified: haypo/hachoir/ui/ui.py
===================================================================
--- haypo/hachoir/ui/ui.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/ui/ui.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -1,12 +1,13 @@
-import os
-import pygtk
-pygtk.require ('2.0') # 2.2 for Clipboard
-import gtk
-import gtk.glade
-
 def loadInterface(hachoir):
     global ui 
     global window
+    import os
+    import pygtk
+    try:
+        pygtk.require ('2.0') # 2.2 for Clipboard
+    except:
+	raise Exception("Sorry, you need pyGTK version 2.0")	
+    from ui_glade import GladeInterface    
     glade = os.path.join(os.path.dirname(__file__), 'hachoir.glade')
     ui = GladeInterface(glade, hachoir)
     window = ui.window
@@ -14,44 +15,5 @@
     hachoir.ui.on_row_click = hachoir.onRowClick
     hachoir.ui.on_go_parent = hachoir.onGoParent
 
-class GladeInterface:
-    def __init__(self, filename, hachoir):
-        self.hachoir = hachoir
-        self.glade_xml = filename
-        self.on_row_click = None # event(chunk_id)
-        self.on_go_parent = None # event(chunk_id)
-        self.build_ui()
-        self._clipboard = None
-        
-    def getClipboard(self):
-        if self._clipboard == None:
-            self._clipboard = gtk.Clipboard()
-        return self._clipboard
-
-    def run(self):
-        self.window.updateToolbar()
-        try:
-            gtk.main()
-        except KeyboardInterrupt:
-            print "Interrupted (CTRL+C)."
-
-    def loadAbout(self):
-        xml = gtk.glade.XML(self.glade_xml, "about_dialog")
-        self.about_dialog = xml.get_widget('about_dialog')
-        self.about_dialog.hide()
-        
-    def build_ui(self):
-        from ui_window import MainWindow
-        from ui_popup import TablePopup
-        from ui_property import PropertyDialog
-        self.window = MainWindow(self)
-        self.loadAbout()
-        self.table_popup = TablePopup(self, self.glade_xml)
-        self.property_dialog = PropertyDialog(self)
-        
-    def quit(self):
-        print "Quit."
-        gtk.main_quit()
-
 ui = None
-window = None
+window = None
\ No newline at end of file

Added: haypo/hachoir/ui/ui_glade.py
===================================================================
--- haypo/hachoir/ui/ui_glade.py	2005-11-28 05:21:57 UTC (rev 281)
+++ haypo/hachoir/ui/ui_glade.py	2005-11-28 21:49:58 UTC (rev 282)
@@ -0,0 +1,43 @@
+import pygtk
+pygtk.require ('2.0') # 2.2 for Clipboard
+import gtk
+import gtk.glade
+
+class GladeInterface:
+    def __init__(self, filename, hachoir):
+        self.hachoir = hachoir
+        self.glade_xml = filename
+        self.on_row_click = None # event(chunk_id)
+        self.on_go_parent = None # event(chunk_id)
+        self.build_ui()
+        self._clipboard = None
+        
+    def getClipboard(self):
+        if self._clipboard == None:
+            self._clipboard = gtk.Clipboard()
+        return self._clipboard
+
+    def run(self):
+        self.window.updateToolbar()
+        try:
+            gtk.main()
+        except KeyboardInterrupt:
+            print "Interrupted (CTRL+C)."
+
+    def loadAbout(self):
+        xml = gtk.glade.XML(self.glade_xml, "about_dialog")
+        self.about_dialog = xml.get_widget('about_dialog')
+        self.about_dialog.hide()
+        
+    def build_ui(self):
+        from ui_window import MainWindow
+        from ui_popup import TablePopup
+        from ui_property import PropertyDialog
+        self.window = MainWindow(self)
+        self.loadAbout()
+        self.table_popup = TablePopup(self, self.glade_xml)
+        self.property_dialog = PropertyDialog(self)
+        
+    def quit(self):
+        print "Quit."
+        gtk.main_quit()
\ No newline at end of file



From haypo at berlios.de  Mon Nov 28 22:50:55 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Mon, 28 Nov 2005 22:50:55 +0100
Subject: [Happyboom-svn] r283 - haypo/hachoir
Message-ID: <200511282150.jASLotqY014959@sheep.berlios.de>

Author: haypo
Date: 2005-11-28 22:50:55 +0100 (Mon, 28 Nov 2005)
New Revision: 283

Added:
   haypo/hachoir/fallback/
Removed:
   haypo/hachoir/failback/
Log:
Fix fallback directory name :-)


Copied: haypo/hachoir/fallback (from rev 282, haypo/hachoir/failback)



From haypo at berlios.de  Tue Nov 29 02:36:07 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 29 Nov 2005 02:36:07 +0100
Subject: [Happyboom-svn] r284 - haypo/hachoir
Message-ID: <200511290136.jAT1a7xL009503@sheep.berlios.de>

Author: haypo
Date: 2005-11-29 02:35:50 +0100 (Tue, 29 Nov 2005)
New Revision: 284

Modified:
   haypo/hachoir/mime.py
Log:
Add Hachoir directory to sys.path directories, so it's possible to load magic.so
in same directory. Fix failback => fallback in mime.py


Modified: haypo/hachoir/mime.py
===================================================================
--- haypo/hachoir/mime.py	2005-11-28 21:50:55 UTC (rev 283)
+++ haypo/hachoir/mime.py	2005-11-29 01:35:50 UTC (rev 284)
@@ -9,28 +9,30 @@
 - http://svn.gna.org/viewcvs/castor/trunk/lib/mime.php?view=markup (PHP)
 """
 
-import os, stat, string, re
+import os, sys, stat, string, re
 from error import warning
 
 instance = None
 
 class GuessMime:
     def __init__(self):
-        self.use_failback = False
+        self.use_fallback = False
         self.func = None
         try:
+            path = os.path.dirname(__file__)
+            sys.path.append(path)
             import magic
             self.func = magic.open(magic.MAGIC_MIME)
             self.func.load()
         except ImportError:
             warning("Warning: The library libmagic for Python is unavailable. Using internal fallback engine.")
-            self.use_failback = True
-        if self.use_failback:
-            from  failback.magic import whatis
+            self.use_fallback = True
+        if self.use_fallback:
+            from  fallback.magic import whatis
             self.func = whatis
 
     def guess(self, buffer):
-        if not self.use_failback:
+        if not self.use_fallback:
             return self.func.buffer(buffer)
         else:
             mime = self.func(buffer)



From haypo at berlios.de  Tue Nov 29 03:07:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 29 Nov 2005 03:07:22 +0100
Subject: [Happyboom-svn] r285 - haypo/hachoir
Message-ID: <200511290207.jAT27MPN020990@sheep.berlios.de>

Author: haypo
Date: 2005-11-29 03:06:59 +0100 (Tue, 29 Nov 2005)
New Revision: 285

Modified:
   haypo/hachoir/hachoir.py
   haypo/hachoir/program.py
Log:
Add website url, and Gentoo command to install dependencies.


Modified: haypo/hachoir/hachoir.py
===================================================================
--- haypo/hachoir/hachoir.py	2005-11-29 01:35:50 UTC (rev 284)
+++ haypo/hachoir/hachoir.py	2005-11-29 02:06:59 UTC (rev 285)
@@ -8,7 +8,7 @@
 """
 
 import sys, os, re, traceback
-from program import PROGRAM, VERSION
+from program import PROGRAM, VERSION, WEBSITE
 from log import log
 from error import error
 from hachoir_class import Hachoir
@@ -16,7 +16,7 @@
 
 def usage(defval):
     print "%s version %s" % (PROGRAM, VERSION)
-    print ""
+    print "%s\n" % WEBSITE
     print "Usage: %s [options] file" % (sys.argv[0])
     print ""
     print "Options:"
@@ -60,6 +60,9 @@
 
 def main():
     try:        
+        print "%s version %s" % (PROGRAM, VERSION)
+        print "%s\n" % WEBSITE
+    
         import imp
         plugins_dir = os.path.join(os.path.dirname(__file__), "plugins")
         plugins_files = os.listdir(plugins_dir)
@@ -91,7 +94,8 @@
 You can find PyGTK at: http://www.pygtk.org/
 and PyGlade at: http://glade.gnome.org/
 
-Debian: apt-get install python2.4-gtk
+Gentoo: emerge pytgtk
+Debian: apt-get install python2.4-gtk python2.4-magic
 Ubuntu: apt-get install python-gtk2 python-glade2""" % (err))
             sys.exit(1)
         hachoir.run(filename)

Modified: haypo/hachoir/program.py
===================================================================
--- haypo/hachoir/program.py	2005-11-29 01:35:50 UTC (rev 284)
+++ haypo/hachoir/program.py	2005-11-29 02:06:59 UTC (rev 285)
@@ -1,2 +1,3 @@
 PROGRAM="Hachoir"
 VERSION="2005-10-27"
+WEBSITE="http://www.haypocalc.com/wiki/Hachoir"



From haypo at berlios.de  Tue Nov 29 03:29:40 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Tue, 29 Nov 2005 03:29:40 +0100
Subject: [Happyboom-svn] r286 - in haypo/hachoir: . ui
Message-ID: <200511290229.jAT2TeLL028151@sheep.berlios.de>

Author: haypo
Date: 2005-11-29 03:29:32 +0100 (Tue, 29 Nov 2005)
New Revision: 286

Modified:
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
Add close button.


Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-29 02:06:59 UTC (rev 285)
+++ haypo/hachoir/hachoir_class.py	2005-11-29 02:29:32 UTC (rev 286)
@@ -26,8 +26,11 @@
     def setFilter(self, filter):
         self._main_filter = filter
         self._filter = filter
-        self._addPadding()
-        self._filter.display()
+        if filter != None:
+            self._addPadding()
+            self._filter.display()
+        else:
+            self.ui.window.clear_table()
         self.ui.window.updateToolbar()
 
     def onGoParent(self):

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-11-29 02:06:59 UTC (rev 285)
+++ haypo/hachoir/ui/hachoir.glade	2005-11-29 02:29:32 UTC (rev 286)
@@ -17,6 +17,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_NORMAL</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <signal name="destroy" handler="on_window_destroy" last_modification_time="Sat, 29 Oct 2005 02:58:52 GMT"/>
 
   <child>
@@ -28,18 +29,20 @@
       <child>
 	<widget class="GtkMenuBar" id="menubar">
 	  <property name="visible">True</property>
+	  <property name="pack_direction">GTK_PACK_DIRECTION_LTR</property>
+	  <property name="child_pack_direction">GTK_PACK_DIRECTION_LTR</property>
 
 	  <child>
-	    <widget class="GtkMenuItem" id="file">
+	    <widget class="GtkMenuItem" id="menu_file">
 	      <property name="visible">True</property>
 	      <property name="label" translatable="yes">_File</property>
 	      <property name="use_underline">True</property>
 
 	      <child>
-		<widget class="GtkMenu" id="file_menu">
+		<widget class="GtkMenu" id="menu_file_menu">
 
 		  <child>
-		    <widget class="GtkImageMenuItem" id="open">
+		    <widget class="GtkImageMenuItem" id="menu_open">
 		      <property name="visible">True</property>
 		      <property name="label">gtk-open</property>
 		      <property name="use_stock">True</property>
@@ -48,8 +51,17 @@
 		  </child>
 
 		  <child>
-		    <widget class="GtkImageMenuItem" id="quit">
+		    <widget class="GtkImageMenuItem" id="menu_close">
 		      <property name="visible">True</property>
+		      <property name="label">gtk-close</property>
+		      <property name="use_stock">True</property>
+		      <signal name="activate" handler="on_toolbutton_close" last_modification_time="Tue, 29 Nov 2005 02:27:30 GMT"/>
+		    </widget>
+		  </child>
+
+		  <child>
+		    <widget class="GtkImageMenuItem" id="menu_quit">
+		      <property name="visible">True</property>
 		      <property name="label">gtk-quit</property>
 		      <property name="use_stock">True</property>
 		      <signal name="activate" handler="on_quit_activate" last_modification_time="Sun, 30 Oct 2005 02:19:54 GMT"/>
@@ -61,16 +73,16 @@
 	  </child>
 
 	  <child>
-	    <widget class="GtkImageMenuItem" id="help">
+	    <widget class="GtkImageMenuItem" id="menu_help">
 	      <property name="visible">True</property>
 	      <property name="label">gtk-help</property>
 	      <property name="use_stock">True</property>
 
 	      <child>
-		<widget class="GtkMenu" id="help_menu">
+		<widget class="GtkMenu" id="menu_help_menu">
 
 		  <child>
-		    <widget class="GtkImageMenuItem" id="about">
+		    <widget class="GtkImageMenuItem" id="menu_about">
 		      <property name="visible">True</property>
 		      <property name="label">gtk-about</property>
 		      <property name="use_stock">True</property>
@@ -214,6 +226,21 @@
 		  <property name="homogeneous">True</property>
 		</packing>
 	      </child>
+
+	      <child>
+		<widget class="GtkToolButton" id="toolbutton_close">
+		  <property name="visible">True</property>
+		  <property name="stock_id">gtk-close</property>
+		  <property name="visible_horizontal">True</property>
+		  <property name="visible_vertical">True</property>
+		  <property name="is_important">False</property>
+		  <signal name="clicked" handler="on_toolbutton_close" last_modification_time="Tue, 29 Nov 2005 02:21:01 GMT"/>
+		</widget>
+		<packing>
+		  <property name="expand">False</property>
+		  <property name="homogeneous">True</property>
+		</packing>
+	      </child>
 	    </widget>
 	  </child>
 	</widget>
@@ -426,6 +453,7 @@
   <property name="copyright" translatable="yes">Copyright 2005 Victor Stinner</property>
   <property name="comments" translatable="yes">Split binary stream into filters and chunks ...</property>
   <property name="license" translatable="yes">Under GNU GPL licence</property>
+  <property name="wrap_license">False</property>
   <property name="website">http://www.haypocalc.com/wiki/Hachoir</property>
   <property name="website_label" translatable="yes">Website</property>
   <property name="authors">Victor Stinner &lt;victor.stinner AT haypocalc.com&gt;</property>
@@ -446,6 +474,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -796,6 +825,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -1058,6 +1088,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">
@@ -1236,6 +1267,7 @@
   <property name="type_hint">GDK_WINDOW_TYPE_HINT_DIALOG</property>
   <property name="gravity">GDK_GRAVITY_NORTH_WEST</property>
   <property name="focus_on_map">True</property>
+  <property name="urgency_hint">False</property>
   <property name="has_separator">True</property>
 
   <child internal-child="vbox">

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-11-29 02:06:59 UTC (rev 285)
+++ haypo/hachoir/ui/ui_window.py	2005-11-29 02:29:32 UTC (rev 286)
@@ -15,6 +15,9 @@
         self.toolbutton_open = xml.get_widget('toolbutton_open')
         self.toolbutton_save = xml.get_widget('toolbutton_save')
         self.toolbutton_property = xml.get_widget('toolbutton_property')
+        self.toolbutton_close = xml.get_widget('toolbutton_close')
+        self.toolbutton_export = xml.get_widget('toolbutton_export')
+        self.menu_close = xml.get_widget('menu_close')
         self.statusbar_state = self.statusbar.get_context_id("State")
         self.table = xml.get_widget('table')
         self.table_store = None
@@ -31,6 +34,9 @@
         if not file_present:
             self.toolbutton_parent.set_sensitive(False)
         self.toolbutton_property.set_sensitive(file_present)
+        self.toolbutton_export.set_sensitive(file_present)
+        self.toolbutton_close.set_sensitive(file_present)
+        self.menu_close.set_sensitive(file_present)
 
     def getTableChunk(self, col):
         chunk_id = self.table_store[col][3]
@@ -107,6 +113,9 @@
     def on_toolbutton_new(self, widget):
         self.on_open_activate(widget)
 
+    def on_toolbutton_close(self, widget):
+        self.ui.hachoir.setFilter(None)
+
     def on_toolbutton_property(self, widget):
         filter = self.ui.hachoir.getFilter()
         dlg = self.ui.property_dialog



From haypo at berlios.de  Wed Nov 30 03:36:12 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 30 Nov 2005 03:36:12 +0100
Subject: [Happyboom-svn] r287 - in haypo/hachoir: . ui
Message-ID: <200511300236.jAU2aCVM011390@sheep.berlios.de>

Author: haypo
Date: 2005-11-30 03:36:04 +0100 (Wed, 30 Nov 2005)
New Revision: 287

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/config.py
   haypo/hachoir/filter.py
   haypo/hachoir/hachoir_class.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
New UI: add informations on the bottom, and can now display hexadecimal.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-29 02:29:32 UTC (rev 286)
+++ haypo/hachoir/chunk.py	2005-11-30 02:36:04 UTC (rev 287)
@@ -1,5 +1,5 @@
 import struct, re, types
-from config import config
+import config
 from format import checkFormat, splitFormat
 from error import warning, error
 from tools import convertDataToPrintableString
@@ -40,14 +40,21 @@
         else:
             return "%s" % value
 
+    def getRaw(self, max_size=None):
+        oldpos = self._stream.tell()
+        self._stream.seek(self.addr)
+        data = self._stream.getN(max_size)
+        self._stream.seek(oldpos)
+        return data
+
     def getValue(self, max_size=None):
-        return None
+        return self.getRaw(max_size)
 
     def getDisplayData(self):
         if self.display != None:
             return self.display
         else:
-            return self.getValue()
+            return self.getRaw(40)
 
     def setParent(self, parent):
         self._parent = parent
@@ -64,6 +71,7 @@
     size = property(_getSize)        
     id = property(__getId, __setId)
     value = property(getValue)
+    raw = property(getRaw)
     
 class FilterChunk(Chunk):
     def __init__(self, id, filter, parent, parent_addr):
@@ -177,15 +185,15 @@
         Chunk.update(self)
         self._findSize()
 
-    def getValue(self, max_size=None):
+    def getRaw(self, max_size=None):
         return self._read(None)
-    value = property(getValue)
+    raw = property(getRaw)
 
     def getDisplayData(self):
         if self.display != None:
             return self.display
         else:
-            text = self._read(config["max_string_length"])
+            text = self._read(config.max_string_length)
             return convertDataToPrintableString(text)
         
 class FormatChunkCache:
@@ -201,7 +209,7 @@
         endian, size, type = splitFormat(format)
         return (size != "1" and size != "")
 
-    def _getRawData(self, max_size=None):
+    def _getRawData(self, max_size=None, add_comment=True):
         stream = self._chunk.getStream()
         oldpos = stream.tell()
         stream.seek(self._addr)
@@ -212,7 +220,10 @@
         else:
             data = stream.getN(max_size)
             stream.seek(oldpos)
-            return data+"(...)", True
+            if add_comment:
+                return data+"(...)", True
+            else:
+                return data, True
 
     def update(self):
         real_format = self._chunk.getRealFormat(self._chunk.getFormat())
@@ -227,6 +238,10 @@
         self.update()
         return self._size
 
+    def getRaw(self, max_size=None):
+        self.update()
+        return self._getRawData(max_size, False)[0]
+
     def getValue(self, max_size=None):
         self.update()
         if max_size not in self._value:
@@ -307,6 +322,10 @@
                 self._parent.rescan(self, diff_size, new_id=old_id, new_description=old_description, truncate=True)
         self._parent.updateFormatChunk(self)
    
+    def getRaw(self, max_size=None):
+        return self._cache.getRaw(max_size)
+    raw = property(getRaw)
+   
     def getValue(self, max_size=None):
         return self._cache.getValue(max_size)
     value = property(getValue)

Modified: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-11-29 02:29:32 UTC (rev 286)
+++ haypo/hachoir/config.py	2005-11-30 02:36:04 UTC (rev 287)
@@ -1,3 +1,2 @@
-config = { \
-    "max_string_length": 30
-}    
+max_string_length = 30
+max_hexa_length = 1024

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-29 02:29:32 UTC (rev 286)
+++ haypo/hachoir/filter.py	2005-11-30 02:36:04 UTC (rev 287)
@@ -3,7 +3,7 @@
 """
 
 import struct, re, sys, string, types
-from config import config
+import config
 import ui.ui as ui
 from chunk import Chunk, FormatChunk, FilterChunk, StringChunk
 from format import splitFormat    
@@ -256,10 +256,10 @@
         text = ""
         current = self
         while current != None:
-            if text != "": text = " > " + text
+            if text != "": text = "/" + text
             text = current.getId() + text
             current = current.getParent()
-        return text
+        return "/"+text
 
     def updateStatusBar(self):
         text = self.getPath()
@@ -296,7 +296,7 @@
 
     def updateFormatChunk(self, chunk):
         if chunk.id == None: return
-        data = chunk.getValue(config["max_string_length"])
+        data = chunk.getValue(config.max_string_length)
         setattr(self, chunk.id, data)       
 
     def _appendChunk(self, chunk, can_truncate=False, position=None):

Modified: haypo/hachoir/hachoir_class.py
===================================================================
--- haypo/hachoir/hachoir_class.py	2005-11-29 02:29:32 UTC (rev 286)
+++ haypo/hachoir/hachoir_class.py	2005-11-30 02:36:04 UTC (rev 287)
@@ -29,6 +29,7 @@
         if filter != None:
             self._addPadding()
             self._filter.display()
+            self.ui.window.info.updateFilter(filter)
         else:
             self.ui.window.clear_table()
         self.ui.window.updateToolbar()
@@ -36,6 +37,7 @@
     def onGoParent(self):
         if self._filter.getParent() == None: return
         self._filter = self._filter.getParent()
+        self.ui.window.info.updateFilter(self._filter)
         self._filter.display()
         
     def onRowClick(self, chunk_id):
@@ -44,6 +46,7 @@
         if issubclass(chunk.__class__, FilterChunk):
             self._filter = chunk.getFilter()
             self._filter.display()
+            self.ui.window.info.updateFilter(self._filter)
 
     def loadUser(self, filename):
         try:

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-11-29 02:29:32 UTC (rev 286)
+++ haypo/hachoir/ui/hachoir.glade	2005-11-30 02:36:04 UTC (rev 287)
@@ -252,27 +252,825 @@
       </child>
 
       <child>
-	<widget class="GtkScrolledWindow" id="scrolledwindow1">
+	<widget class="GtkHBox" id="hbox1">
 	  <property name="visible">True</property>
+	  <property name="homogeneous">False</property>
+	  <property name="spacing">0</property>
+
+	  <child>
+	    <widget class="GtkLabel" id="label38">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Filter path:</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">6</property>
+	      <property name="expand">False</property>
+	      <property name="fill">False</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkEntry" id="filter_path">
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="editable">True</property>
+	      <property name="visibility">True</property>
+	      <property name="max_length">0</property>
+	      <property name="text" translatable="yes"></property>
+	      <property name="has_frame">True</property>
+	      <property name="invisible_char">*</property>
+	      <property name="activates_default">False</property>
+	    </widget>
+	    <packing>
+	      <property name="padding">0</property>
+	      <property name="expand">True</property>
+	      <property name="fill">True</property>
+	    </packing>
+	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">False</property>
+	  <property name="fill">False</property>
+	</packing>
+      </child>
+
+      <child>
+	<widget class="GtkVPaned" id="vpaned1">
+	  <property name="visible">True</property>
 	  <property name="can_focus">True</property>
-	  <property name="hscrollbar_policy">GTK_POLICY_ALWAYS</property>
-	  <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
-	  <property name="shadow_type">GTK_SHADOW_IN</property>
-	  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+	  <property name="position">159</property>
 
 	  <child>
-	    <widget class="GtkTreeView" id="table">
+	    <widget class="GtkScrolledWindow" id="scrolledwindow1">
 	      <property name="visible">True</property>
 	      <property name="can_focus">True</property>
-	      <property name="headers_visible">True</property>
-	      <property name="rules_hint">False</property>
-	      <property name="reorderable">False</property>
-	      <property name="enable_search">True</property>
-	      <property name="fixed_height_mode">False</property>
-	      <property name="hover_selection">False</property>
-	      <property name="hover_expand">False</property>
+	      <property name="hscrollbar_policy">GTK_POLICY_NEVER</property>
+	      <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
+	      <property name="shadow_type">GTK_SHADOW_IN</property>
+	      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+	      <child>
+		<widget class="GtkTreeView" id="table">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="headers_visible">True</property>
+		  <property name="rules_hint">False</property>
+		  <property name="reorderable">False</property>
+		  <property name="enable_search">True</property>
+		  <property name="fixed_height_mode">False</property>
+		  <property name="hover_selection">False</property>
+		  <property name="hover_expand">False</property>
+		</widget>
+	      </child>
 	    </widget>
+	    <packing>
+	      <property name="shrink">True</property>
+	      <property name="resize">True</property>
+	    </packing>
 	  </child>
+
+	  <child>
+	    <widget class="GtkNotebook" id="notebook1">
+	      <property name="visible">True</property>
+	      <property name="can_focus">True</property>
+	      <property name="show_tabs">True</property>
+	      <property name="show_border">True</property>
+	      <property name="tab_pos">GTK_POS_TOP</property>
+	      <property name="scrollable">False</property>
+	      <property name="enable_popup">False</property>
+
+	      <child>
+		<widget class="GtkTable" id="table5">
+		  <property name="border_width">6</property>
+		  <property name="visible">True</property>
+		  <property name="n_rows">5</property>
+		  <property name="n_columns">2</property>
+		  <property name="homogeneous">False</property>
+		  <property name="row_spacing">6</property>
+		  <property name="column_spacing">6</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label31">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Name:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="filter_name">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label32">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Decription:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="filter_description">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="stream_size">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">3</property>
+		      <property name="bottom_attach">4</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label29">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Size:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">3</property>
+		      <property name="bottom_attach">4</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label28">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Stream:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">4</property>
+		      <property name="bottom_attach">5</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="stream_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">4</property>
+		      <property name="bottom_attach">5</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="filter_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label39">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Type:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="tab_expand">False</property>
+		  <property name="tab_fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label21">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Filter</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="type">tab</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkTable" id="table7">
+		  <property name="border_width">6</property>
+		  <property name="visible">True</property>
+		  <property name="n_rows">5</property>
+		  <property name="n_columns">2</property>
+		  <property name="homogeneous">False</property>
+		  <property name="row_spacing">6</property>
+		  <property name="column_spacing">6</property>
+
+		  <child>
+		    <widget class="GtkLabel" id="label33">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Name:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label34">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Size:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label35">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Type:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_name">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_size">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label36">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Description:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">4</property>
+		      <property name="bottom_attach">5</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_description">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">4</property>
+		      <property name="bottom_attach">5</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkLabel" id="label41">
+		      <property name="visible">True</property>
+		      <property name="label" translatable="yes">Address:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">0</property>
+		      <property name="right_attach">1</property>
+		      <property name="top_attach">3</property>
+		      <property name="bottom_attach">4</property>
+		      <property name="x_options">fill</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="chunk_address">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">3</property>
+		      <property name="bottom_attach">4</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="tab_expand">False</property>
+		  <property name="tab_fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label23">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Chunk</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="type">tab</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkVBox" id="vbox5">
+		  <property name="visible">True</property>
+		  <property name="homogeneous">False</property>
+		  <property name="spacing">0</property>
+
+		  <child>
+		    <widget class="GtkHBox" id="hbox2">
+		      <property name="visible">True</property>
+		      <property name="homogeneous">False</property>
+		      <property name="spacing">0</property>
+
+		      <child>
+			<widget class="GtkLabel" id="label42">
+			  <property name="visible">True</property>
+			  <property name="label" translatable="yes">Path:</property>
+			  <property name="use_underline">False</property>
+			  <property name="use_markup">False</property>
+			  <property name="justify">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap">False</property>
+			  <property name="selectable">False</property>
+			  <property name="xalign">0</property>
+			  <property name="yalign">0.5</property>
+			  <property name="xpad">0</property>
+			  <property name="ypad">0</property>
+			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+			  <property name="width_chars">-1</property>
+			  <property name="single_line_mode">False</property>
+			  <property name="angle">0</property>
+			</widget>
+			<packing>
+			  <property name="padding">6</property>
+			  <property name="expand">False</property>
+			  <property name="fill">False</property>
+			</packing>
+		      </child>
+
+		      <child>
+			<widget class="GtkEntry" id="hexa_path">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">False</property>
+			  <property name="visibility">True</property>
+			  <property name="max_length">0</property>
+			  <property name="text" translatable="yes"></property>
+			  <property name="has_frame">True</property>
+			  <property name="invisible_char">*</property>
+			  <property name="activates_default">False</property>
+			</widget>
+			<packing>
+			  <property name="padding">6</property>
+			  <property name="expand">True</property>
+			  <property name="fill">True</property>
+			</packing>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkScrolledWindow" id="scrolledwindow2">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		      <property name="shadow_type">GTK_SHADOW_IN</property>
+		      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
+		      <child>
+			<widget class="GtkTextView" id="hexa_content">
+			  <property name="visible">True</property>
+			  <property name="can_focus">True</property>
+			  <property name="editable">True</property>
+			  <property name="overwrite">False</property>
+			  <property name="accepts_tab">True</property>
+			  <property name="justification">GTK_JUSTIFY_LEFT</property>
+			  <property name="wrap_mode">GTK_WRAP_NONE</property>
+			  <property name="cursor_visible">True</property>
+			  <property name="pixels_above_lines">0</property>
+			  <property name="pixels_below_lines">0</property>
+			  <property name="pixels_inside_wrap">0</property>
+			  <property name="left_margin">0</property>
+			  <property name="right_margin">0</property>
+			  <property name="indent">0</property>
+			  <property name="text" translatable="yes"></property>
+			</widget>
+		      </child>
+		    </widget>
+		    <packing>
+		      <property name="padding">12</property>
+		      <property name="expand">True</property>
+		      <property name="fill">True</property>
+		    </packing>
+		  </child>
+
+		  <child>
+		    <widget class="GtkButton" id="button3">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="label">gtk-refresh</property>
+		      <property name="use_stock">True</property>
+		      <property name="relief">GTK_RELIEF_NORMAL</property>
+		      <property name="focus_on_click">True</property>
+		      <signal name="clicked" handler="on_hexadecimal_clicked" last_modification_time="Wed, 30 Nov 2005 02:05:28 GMT"/>
+		    </widget>
+		    <packing>
+		      <property name="padding">0</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
+		    </packing>
+		  </child>
+		</widget>
+		<packing>
+		  <property name="tab_expand">False</property>
+		  <property name="tab_fill">True</property>
+		</packing>
+	      </child>
+
+	      <child>
+		<widget class="GtkLabel" id="label40">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Hexa</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0.5</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="type">tab</property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="shrink">False</property>
+	      <property name="resize">True</property>
+	    </packing>
+	  </child>
 	</widget>
 	<packing>
 	  <property name="padding">0</property>

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-11-29 02:29:32 UTC (rev 286)
+++ haypo/hachoir/ui/ui_window.py	2005-11-30 02:36:04 UTC (rev 287)
@@ -2,7 +2,41 @@
 import pygtk
 import gtk
 import gtk.glade
+import config
 
+class InfoNotebook:
+    def __init__(self, xml):
+        self.filter_name = xml.get_widget("filter_name")
+        self.filter_description = xml.get_widget("filter_description")
+        self.filter_type = xml.get_widget("filter_type")
+        self.filter_path = xml.get_widget("filter_path")
+        
+        self.stream_type = xml.get_widget("stream_type")        
+        self.stream_size = xml.get_widget("stream_size")
+        
+        self.chunk_name = xml.get_widget("chunk_name")
+        self.chunk_description = xml.get_widget("chunk_description")
+        self.chunk_size = xml.get_widget("chunk_size")
+        self.chunk_address = xml.get_widget("chunk_address")
+        self.chunk_type = xml.get_widget("chunk_type")
+        
+    def updateChunk(self, chunk):
+        self.chunk_name.set_text(chunk.id)
+        self.chunk_description.set_text(chunk.description)
+        self.chunk_address.set_text(str(chunk.addr))
+        self.chunk_size.set_text(str(chunk.size))
+        self.chunk_type.set_text(chunk.__class__.__name__)
+    
+    def updateFilter(self, filter):        
+        self.filter_name.set_text(filter.getId())
+        self.filter_description.set_text(filter.getDescription())
+        self.filter_type.set_text(filter.__class__.__name__)
+        self.filter_path.set_text(filter.getPath())
+
+        stream = filter.getStream()
+        self.stream_type.set_text(stream.__class__.__name__)
+        self.stream_size.set_text("%u" % filter.getSize())
+
 class MainWindow:
     def __init__(self, ui):
         self.ui = ui
@@ -17,14 +51,17 @@
         self.toolbutton_property = xml.get_widget('toolbutton_property')
         self.toolbutton_close = xml.get_widget('toolbutton_close')
         self.toolbutton_export = xml.get_widget('toolbutton_export')
+        self.hexa_path = xml.get_widget('hexa_path')
+        self.hexa_content = xml.get_widget('hexa_content')
         self.menu_close = xml.get_widget('menu_close')
         self.statusbar_state = self.statusbar.get_context_id("State")
+        self.info = InfoNotebook(xml)
         self.table = xml.get_widget('table')
         self.table_store = None
         xml.signal_autoconnect(self)
         self.window.connect("key-press-event", self.onKeyUp)
         self.table.connect("button_press_event", self.on_treeview_button_press_event)
-        self.window.set_size_request(760,500)
+#        self.window.set_size_request(760,500)
         self.build_table()
         
     def updateToolbar(self):
@@ -80,14 +117,29 @@
         if key.keyval == gtk.keysyms.Escape:
             self.on_go_parent()
         
-    def onTableClicked(self, widget, iter, data=None):
+    def onTableRowActivate(self, widget, iter, data=None):
         row = self.table_store[iter]
         self.ui.on_row_click(row[3])
+        
+    def getActiveChunk(self):
+        select = self.table.get_selection()
+        iter = select.get_selected()[1]
+        if iter != None:
+            row = self.table_store[iter]
+            return self.ui.hachoir.getFilter().getChunk(row[3])
+        else:
+            return None 
 
+    def onTableClick(self, widget, data=None):
+        chunk = self.getActiveChunk()
+        if chunk != None:
+            self.info.updateChunk(chunk)
+
     def build_table(self):
         self.table_store = gtk.TreeStore(int, str, int, str, str, str)
         self.table.set_model(self.table_store)
-        self.table.connect("row-activated", self.onTableClicked)
+        self.table.connect("button_release_event", self.onTableClick)
+        self.table.connect("row-activated", self.onTableRowActivate)
         self.treeview_add_column(self.table, "Address", 0)
         self.treeview_add_column(self.table, "Format", 1)
         self.treeview_add_column(self.table, "Size", 2)
@@ -164,6 +216,30 @@
             self.ui.hachoir.saveUser(filename)
         chooser.destroy()
 
+    def on_hexadecimal_clicked(self, widget):
+        chunk = self.getActiveChunk()
+        if chunk == None:
+            return
+        path = chunk.getParent().getPath()+"/"+chunk.id
+        self.hexa_path.set_text(path)
+        raw = chunk.getRaw(config.max_hexa_length)
+        # TODO: Use better str=>hexa function ...
+        content = ""
+        wrap = 16
+        while len(raw) != 0:
+            if len(content) != 0:
+                content = content + "\n"
+            content = content + " ".join([ "%02X" % ord(i) for i in raw[:wrap] ])
+            raw = raw[wrap:]
+        if config.max_hexa_length < chunk.size:
+            if len(content) != 0:
+                content = content + "\n"
+            content = content + " (...)"
+        # TODO: Write new TextBuffer!?
+        buffer = gtk.TextBuffer()
+        buffer.set_text(content)
+        self.hexa_content.set_buffer(buffer)
+
     def on_about_activate(self, widget):
         self.ui.about_dialog.show()
 



From haypo at berlios.de  Wed Nov 30 04:00:22 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 30 Nov 2005 04:00:22 +0100
Subject: [Happyboom-svn] r288 - in haypo/hachoir: . ui
Message-ID: <200511300300.jAU30MJn017949@sheep.berlios.de>

Author: haypo
Date: 2005-11-30 04:00:08 +0100 (Wed, 30 Nov 2005)
New Revision: 288

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/config.py
   haypo/hachoir/filter.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
Fix getRaw() in StringChunk. UI: remove status bar and use 2 fields columns
in informations.


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-30 02:36:04 UTC (rev 287)
+++ haypo/hachoir/chunk.py	2005-11-30 03:00:08 UTC (rev 288)
@@ -43,7 +43,10 @@
     def getRaw(self, max_size=None):
         oldpos = self._stream.tell()
         self._stream.seek(self.addr)
-        data = self._stream.getN(max_size)
+        size = self.size
+        if max_size<size:
+            size = max_size
+        data = self._stream.getN(size)
         self._stream.seek(oldpos)
         return data
 
@@ -185,9 +188,9 @@
         Chunk.update(self)
         self._findSize()
 
-    def getRaw(self, max_size=None):
+    def getValue(self, max_size=None):
         return self._read(None)
-    raw = property(getRaw)
+    value = property(getValue)
 
     def getDisplayData(self):
         if self.display != None:

Modified: haypo/hachoir/config.py
===================================================================
--- haypo/hachoir/config.py	2005-11-30 02:36:04 UTC (rev 287)
+++ haypo/hachoir/config.py	2005-11-30 03:00:08 UTC (rev 288)
@@ -1,2 +1,2 @@
 max_string_length = 30
-max_hexa_length = 1024
+max_hexa_length = 4096 

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-30 02:36:04 UTC (rev 287)
+++ haypo/hachoir/filter.py	2005-11-30 03:00:08 UTC (rev 288)
@@ -261,13 +261,8 @@
             current = current.getParent()
         return "/"+text
 
-    def updateStatusBar(self):
-        text = self.getPath()
-        ui.window.updateStatusBar("%s: %s (size=%s)" % (text, self.getDescription(), self.getSize()))
-
     def display(self):  
         ui.window.enableParentButton(self.getParent() != None)
-        self.updateStatusBar()
             
         # Update table
         ui.window.clear_table()

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-11-30 02:36:04 UTC (rev 287)
+++ haypo/hachoir/ui/hachoir.glade	2005-11-30 03:00:08 UTC (rev 288)
@@ -286,7 +286,7 @@
 	    <widget class="GtkEntry" id="filter_path">
 	      <property name="visible">True</property>
 	      <property name="can_focus">True</property>
-	      <property name="editable">True</property>
+	      <property name="editable">False</property>
 	      <property name="visibility">True</property>
 	      <property name="max_length">0</property>
 	      <property name="text" translatable="yes"></property>
@@ -312,7 +312,6 @@
 	<widget class="GtkVPaned" id="vpaned1">
 	  <property name="visible">True</property>
 	  <property name="can_focus">True</property>
-	  <property name="position">159</property>
 
 	  <child>
 	    <widget class="GtkScrolledWindow" id="scrolledwindow1">
@@ -357,8 +356,8 @@
 		<widget class="GtkTable" id="table5">
 		  <property name="border_width">6</property>
 		  <property name="visible">True</property>
-		  <property name="n_rows">5</property>
-		  <property name="n_columns">2</property>
+		  <property name="n_rows">3</property>
+		  <property name="n_columns">4</property>
 		  <property name="homogeneous">False</property>
 		  <property name="row_spacing">6</property>
 		  <property name="column_spacing">6</property>
@@ -462,7 +461,7 @@
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="stream_size">
+		    <widget class="GtkEntry" id="filter_type">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="editable">False</property>
@@ -476,16 +475,16 @@
 		    <packing>
 		      <property name="left_attach">1</property>
 		      <property name="right_attach">2</property>
-		      <property name="top_attach">3</property>
-		      <property name="bottom_attach">4</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkLabel" id="label29">
+		    <widget class="GtkLabel" id="label39">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Size:</property>
+		      <property name="label" translatable="yes">Type:</property>
 		      <property name="use_underline">False</property>
 		      <property name="use_markup">False</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -503,8 +502,8 @@
 		    <packing>
 		      <property name="left_attach">0</property>
 		      <property name="right_attach">1</property>
-		      <property name="top_attach">3</property>
-		      <property name="bottom_attach">4</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
 		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
@@ -529,17 +528,17 @@
 		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">4</property>
-		      <property name="bottom_attach">5</property>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
 		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="stream_type">
+		    <widget class="GtkEntry" id="stream_size">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="editable">False</property>
@@ -551,39 +550,18 @@
 		      <property name="activates_default">False</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">4</property>
-		      <property name="bottom_attach">5</property>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="filter_type">
+		    <widget class="GtkLabel" id="label29">
 		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="label39">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Type:</property>
+		      <property name="label" translatable="yes">Size:</property>
 		      <property name="use_underline">False</property>
 		      <property name="use_markup">False</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -599,14 +577,35 @@
 		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
 		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
+
+		  <child>
+		    <widget class="GtkEntry" id="stream_type">
+		      <property name="visible">True</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
+		    </widget>
+		    <packing>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
+		      <property name="y_options"></property>
+		    </packing>
+		  </child>
 		</widget>
 		<packing>
 		  <property name="tab_expand">False</property>
@@ -641,8 +640,8 @@
 		<widget class="GtkTable" id="table7">
 		  <property name="border_width">6</property>
 		  <property name="visible">True</property>
-		  <property name="n_rows">5</property>
-		  <property name="n_columns">2</property>
+		  <property name="n_rows">3</property>
+		  <property name="n_columns">4</property>
 		  <property name="homogeneous">False</property>
 		  <property name="row_spacing">6</property>
 		  <property name="column_spacing">6</property>
@@ -676,37 +675,30 @@
 		  </child>
 
 		  <child>
-		    <widget class="GtkLabel" id="label34">
+		    <widget class="GtkEntry" id="chunk_name">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Size:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
+		      <property name="can_focus">True</property>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
+		      <property name="left_attach">1</property>
+		      <property name="right_attach">2</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkLabel" id="label35">
+		    <widget class="GtkLabel" id="label41">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Type:</property>
+		      <property name="label" translatable="yes">Address:</property>
 		      <property name="use_underline">False</property>
 		      <property name="use_markup">False</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -722,17 +714,17 @@
 		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
+		      <property name="top_attach">0</property>
+		      <property name="bottom_attach">1</property>
 		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="chunk_name">
+		    <widget class="GtkEntry" id="chunk_address">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="editable">False</property>
@@ -744,8 +736,8 @@
 		      <property name="activates_default">False</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
 		      <property name="top_attach">0</property>
 		      <property name="bottom_attach">1</property>
 		      <property name="y_options"></property>
@@ -753,28 +745,35 @@
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="chunk_size">
+		    <widget class="GtkLabel" id="label34">
 		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
+		      <property name="label" translatable="yes">Size:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
+		      <property name="left_attach">2</property>
+		      <property name="right_attach">3</property>
 		      <property name="top_attach">1</property>
 		      <property name="bottom_attach">2</property>
+		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="chunk_type">
+		    <widget class="GtkEntry" id="chunk_size">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="editable">False</property>
@@ -786,18 +785,18 @@
 		      <property name="activates_default">False</property>
 		    </widget>
 		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
+		      <property name="left_attach">3</property>
+		      <property name="right_attach">4</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkLabel" id="label36">
+		    <widget class="GtkLabel" id="label35">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Description:</property>
+		      <property name="label" translatable="yes">Type:</property>
 		      <property name="use_underline">False</property>
 		      <property name="use_markup">False</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -815,15 +814,15 @@
 		    <packing>
 		      <property name="left_attach">0</property>
 		      <property name="right_attach">1</property>
-		      <property name="top_attach">4</property>
-		      <property name="bottom_attach">5</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
 		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="chunk_description">
+		    <widget class="GtkEntry" id="chunk_type">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="editable">False</property>
@@ -837,16 +836,16 @@
 		    <packing>
 		      <property name="left_attach">1</property>
 		      <property name="right_attach">2</property>
-		      <property name="top_attach">4</property>
-		      <property name="bottom_attach">5</property>
+		      <property name="top_attach">1</property>
+		      <property name="bottom_attach">2</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkLabel" id="label41">
+		    <widget class="GtkLabel" id="label36">
 		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Address:</property>
+		      <property name="label" translatable="yes">Description:</property>
 		      <property name="use_underline">False</property>
 		      <property name="use_markup">False</property>
 		      <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -864,15 +863,15 @@
 		    <packing>
 		      <property name="left_attach">0</property>
 		      <property name="right_attach">1</property>
-		      <property name="top_attach">3</property>
-		      <property name="bottom_attach">4</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
 		      <property name="x_options">fill</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkEntry" id="chunk_address">
+		    <widget class="GtkEntry" id="chunk_description">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
 		      <property name="editable">False</property>
@@ -886,8 +885,8 @@
 		    <packing>
 		      <property name="left_attach">1</property>
 		      <property name="right_attach">2</property>
-		      <property name="top_attach">3</property>
-		      <property name="bottom_attach">4</property>
+		      <property name="top_attach">2</property>
+		      <property name="bottom_attach">3</property>
 		      <property name="y_options"></property>
 		    </packing>
 		  </child>
@@ -979,8 +978,8 @@
 		    </widget>
 		    <packing>
 		      <property name="padding">0</property>
-		      <property name="expand">True</property>
-		      <property name="fill">True</property>
+		      <property name="expand">False</property>
+		      <property name="fill">False</property>
 		    </packing>
 		  </child>
 
@@ -997,9 +996,9 @@
 			<widget class="GtkTextView" id="hexa_content">
 			  <property name="visible">True</property>
 			  <property name="can_focus">True</property>
-			  <property name="editable">True</property>
+			  <property name="editable">False</property>
 			  <property name="overwrite">False</property>
-			  <property name="accepts_tab">True</property>
+			  <property name="accepts_tab">False</property>
 			  <property name="justification">GTK_JUSTIFY_LEFT</property>
 			  <property name="wrap_mode">GTK_WRAP_NONE</property>
 			  <property name="cursor_visible">True</property>
@@ -1078,18 +1077,6 @@
 	  <property name="fill">True</property>
 	</packing>
       </child>
-
-      <child>
-	<widget class="GtkStatusbar" id="statusbar">
-	  <property name="visible">True</property>
-	  <property name="has_resize_grip">True</property>
-	</widget>
-	<packing>
-	  <property name="padding">0</property>
-	  <property name="expand">False</property>
-	  <property name="fill">False</property>
-	</packing>
-      </child>
     </widget>
   </child>
 </widget>

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-11-30 02:36:04 UTC (rev 287)
+++ haypo/hachoir/ui/ui_window.py	2005-11-30 03:00:08 UTC (rev 288)
@@ -42,7 +42,6 @@
         self.ui = ui
         xml = gtk.glade.XML(self.ui.glade_xml, "main_window")
         self.window = xml.get_widget('main_window')
-        self.statusbar = xml.get_widget('statusbar')
         self.toolbar = xml.get_widget('toolbar')
         self.toolbutton_parent = xml.get_widget('toolbutton_parent')
         self.toolbutton_new = xml.get_widget('toolbutton_new')
@@ -54,7 +53,6 @@
         self.hexa_path = xml.get_widget('hexa_path')
         self.hexa_content = xml.get_widget('hexa_content')
         self.menu_close = xml.get_widget('menu_close')
-        self.statusbar_state = self.statusbar.get_context_id("State")
         self.info = InfoNotebook(xml)
         self.table = xml.get_widget('table')
         self.table_store = None
@@ -93,9 +91,6 @@
                 self.ui.table_popup.show(pthinfo, event)
             return 1
 
-    def updateStatusBar(self, text):
-        self.statusbar.push(self.statusbar_state, text)
-        
     def enableParentButton(self, enable):
         self.toolbutton_parent.set_sensitive(enable)
 
@@ -149,6 +144,8 @@
         self.table.set_reorderable(True)
         self.treeselection = self.table.get_selection()
         self.table.columns_autosize()
+        self.window.maximize()
+        self.window.grab_focus()
 
     def treeview_add_column(self, treeview, name, num):
         col = gtk.TreeViewColumn(name)
@@ -174,7 +171,6 @@
         if dlg.run(filter) == gtk.RESPONSE_CANCEL: return
         filter.setId( dlg.getId() )
         filter.setDescription( dlg.getDescription() )
-        filter.updateStatusBar()
         
     def on_open_activate(self, widget):
         chooser = gtk.FileChooserDialog( \



From haypo at berlios.de  Wed Nov 30 06:55:35 2005
From: haypo at berlios.de (haypo at BerliOS)
Date: Wed, 30 Nov 2005 06:55:35 +0100
Subject: [Happyboom-svn] r289 - in haypo/hachoir: . plugins stream ui
Message-ID: <200511300555.jAU5tZeN004723@sheep.berlios.de>

Author: haypo
Date: 2005-11-30 06:55:11 +0100 (Wed, 30 Nov 2005)
New Revision: 289

Modified:
   haypo/hachoir/chunk.py
   haypo/hachoir/filter.py
   haypo/hachoir/plugins/elf.py
   haypo/hachoir/stream/file.py
   haypo/hachoir/stream/stream.py
   haypo/hachoir/ui/hachoir.glade
   haypo/hachoir/ui/ui_window.py
Log:
Write second part of ELF filte: it can now read program headers, sections,
and sections header. Fix FileStream.clone() => now also copy low-level file
IO. Add Stream.getType() for nice print. Filter.getUniqChunkId() supports
"a[]" (was managed somewhere else before).


Modified: haypo/hachoir/chunk.py
===================================================================
--- haypo/hachoir/chunk.py	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/chunk.py	2005-11-30 05:55:11 UTC (rev 289)
@@ -78,12 +78,13 @@
     
 class FilterChunk(Chunk):
     def __init__(self, id, filter, parent, parent_addr):
+        self._description = filter.getDescription()
+        self.parent_addr = parent_addr
+        self._filter = filter
+        self._filter.filter_chunk = self
         Chunk.__init__(self, id, \
             filter.getDescription(), filter.getStream(), filter.getAddr(), \
             filter.getSize(), parent)
-        self.parent_addr = parent_addr
-        self._filter = filter
-        self._filter.filter_chunk = self
     
     def getFormat(self):
         return self._filter.getId()
@@ -117,6 +118,13 @@
     def getFilter(self):
         return self._filter
 
+    def _getDescription(self):
+        return self._description
+    def _setDescription(self, description):
+        self._description = description
+        self._filter.setDescription(description)
+    description = property(_getDescription, _setDescription)
+
 class StringChunk(Chunk):
     cache_hit = 0
 

Modified: haypo/hachoir/filter.py
===================================================================
--- haypo/hachoir/filter.py	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/filter.py	2005-11-30 05:55:11 UTC (rev 289)
@@ -68,21 +68,26 @@
     def getChunks(self):
         return self._chunks
 
-    def getUniqChunkId(self, id):
-        if id not in self._chunks_dict: return id
-        m = re.compile("^(.*?)([0-9]+)$").match(id)
-        if m != None:
-            root = m.group(1)
-            uniq = int(m.group(2))+1
-        else:
-            root = id
-            uniq = 2
-        new_id = "%s%u" % (root, uniq)
+    def _getUniqChunkId(self, pattern, root, index):
+        new_id = pattern % (root, index)
         while new_id in self._chunks_dict:
-            uniq = uniq+1
-            new_id = "%s%u" % (root, uniq)
+            index = index + 1
+            new_id = pattern % (root, index)
         return new_id 
 
+    def getUniqChunkId(self, id):
+        if id[-2:] == "[]":
+            return self._getUniqChunkId("%s[%u]", id[:-2], 1)
+
+        if id in self._chunks_dict:
+            m = re.compile("^(.*?)([0-9]+)$").match(id)
+            if m != None:
+                return self._getUniqChunkId("%s%u", m.group(1), int(m.group(2))+1)
+            else:
+                return self._getUniqChunkId("%s%u", id, 2)
+        else:
+            return id
+
     def updateChunkId(self, chunk, new_id):
         if chunk.id == new_id: return
         if new_id in self._chunks_dict or hasattr(self, new_id):
@@ -325,6 +330,7 @@
         return chunk
         
     def readStreamChild(self, id, stream, filter_class, *args): 
+        id = self.getUniqChunkId(id)
         oldpos = self._stream.tell()
         filter = filter_class(stream, self, *args)
         filter.setId(id)
@@ -436,6 +442,7 @@
             chunk_id = "%s[%u]" % (self.getId(), nb)
             addr = self._stream.tell()
             filter = self._entry_class(self._stream, self)
+            filter.setId(chunk_id)
             nb = nb + 1
             chunk = FilterChunk(chunk_id, filter, self, addr)
             self._array.append( chunk )
@@ -493,10 +500,10 @@
         return new
 
 class DeflateFilter(Filter):
-    def __init__(self, stream, parent, bz_stream, size, filter):
+    def __init__(self, stream, parent, bz_stream, size, filter, *args):
         Filter.__init__(self, "deflate", "Deflate", bz_stream, parent)
         self._addr = stream.tell()
-        self.readChild("data", filter)
+        self.readChild("data", filter, *args)
         self._compressed_size = size
 
     def getSize(self):

Modified: haypo/hachoir/plugins/elf.py
===================================================================
--- haypo/hachoir/plugins/elf.py	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/plugins/elf.py	2005-11-30 05:55:11 UTC (rev 289)
@@ -3,10 +3,24 @@
 Author: Victor Stinner
 """
 
-from filter import Filter
+from filter import Filter, DeflateFilter
 from plugin import registerPlugin
 
-class ELF_Header(Filter):
+def processAddr(chunk):
+    return "%08X" % chunk.value
+
+class ElfHeader(Filter):
+    machine = {
+        0: "No machine",
+        1: "AT&T WE 32100",
+        2: "SPARC",
+        3: "Intel 80386",
+        4: "Motorolla 68000",
+        5: "Motorolla 88000",
+        7: "Intel 80860",
+        8: "MIPS RS3000"
+    }
+
     def __init__(self, stream, parent):
         Filter.__init__(self, "elf_header", "ELF header", stream, parent)
         self.read("id", "4s", "Identifier")
@@ -16,19 +30,19 @@
         self.read("file_version", "B", "File version")
         self.read("pad", "8s", "Pad")
         self.read("nident", "B", "Size of ident[]")
-        self.read("type", "<H", "File fype", post=self.getType)
+        self.read("type", "<H", "File type", post=self.getType)
         self.read("machine", "<H", "Machine type", post=self.getMachine)
-        self.read("version", "<L", "Version of ELF")
+        self.read("version", "<L", "ELF format version")
         self.read("entry", "<L", "Number of entries")
-        self.read("phoff", "<L", "PH offset")
-        self.read("shoff", "<L", "SH offset")
+        self.read("phoff", "<L", "Program header offset")
+        self.read("shoff", "<L", "Section header offset")
         self.read("flags", "<L", "Flags")
-        self.read("ehsize", "<H", "EH size")
-        self.read("phentsize", "<H", "PH entry size")
-        self.read("phnum", "<H", "PH entry count")
-        self.read("shentsize", "<H", "SH entry size")
-        self.read("shnum", "<H", "SH entre count")
-        self.read("shstrndx", "<H", "SH strtab index")
+        self.read("ehsize", "<H", "Elf header size (this header)")
+        self.read("phentsize", "<H", "Program header entry size")
+        self.read("phnum", "<H", "Program header entry count")
+        self.read("shentsize", "<H", "Section header entry size")
+        self.read("shnum", "<H", "Section header entre count")
+        self.read("shstrndx", "<H", "Section header strtab index")
 
     def getType(self, chunk):
         type = chunk.value
@@ -45,21 +59,123 @@
 
     def getMachine(self, chunk):
         type = chunk.value
-        types = {
-            0: "No machine",
-            1: "AT&T WE 32100",
-            2: "SPARC",
-            3: "Intel 80386",
-            4: "Motorolla 68000",
-            5: "Motorolla 88000",
-            7: "Intel 80860",
-            8: "MIPS RS3000"
-        }
-        return types.get(type, "Unknow machine (%u)" % type)
+        return ElfHeader.machine.get(type, "Unknow machine (%u)" % type)
 
-class ELF_Filter(Filter):
+class SectionHeader32(Filter):
+    types = {
+        8: "BSS"
+    }
+    
     def __init__(self, stream, parent):
-        Filter.__init__(self, "elf", "ELF file", stream, parent)
-        self.readChild("header", ELF_Header)
+        Filter.__init__(self, "section_header", "Section header", stream, parent)
+        self.read("name", "<L", "")
+        self.read("type", "<L", "")
+        self.read("flags", "<L", "")
+        self.read("VMA", "<L", "Virtual memory address")#, post=processAddr)
+        self.read("LMA", "<L", "Logical memory address (in file)")#, post=processAddr)
+        self.read("size", "<L", "", post=processAddr)
+        self.read("link", "<L", "")
+        self.read("info", "<L", "")
+        self.read("addralign", "<L", "")
+        self.read("entsize", "<L", "")
 
-registerPlugin(ELF_Filter, "application/x-executable")
+    def getType(self):
+        type = self["type"]
+        return SectionHeader32.types.get(type, "unknow type=%u" % type)
+
+    def getName(self):
+        #?TODO: Look in symbol name
+        return self["name"]
+
+    def updateParent(self, chunk):
+        desc = "Section header (name: %s, type: %s)" % (self.getName(), self.getType())
+        chunk.description = desc
+        self.setDescription(desc)
+
+class ProgramHeader32(Filter):
+    type = {
+        3: "Dynamic library"
+    }
+    
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "prg_header", "Program header", stream, parent)
+        self.read("type", "<H", "")
+        self.read("flags", "<H", "")
+        self.read("offset", "<L", "")
+        self.read("vaddr", "<L", "", post=processAddr)
+        self.read("paddr", "<L", "", post=processAddr)
+        self.read("file_size", "<L", "")
+        self.read("mem_size", "<L", "")
+        self.read("align", "<L", "")
+        self.read("padding", "<L", "(padding?)")
+
+    def getType(self):
+        type = self["type"]
+        return ProgramHeader32.type.get(type, "unknow, %u" % type)
+
+    def updateParent(self, chunk):
+        desc = "Program Header (%s)" % self.getType() 
+        self.setDescription(desc)
+        chunk.description = desc 
+
+def seek(filter, stream, offset):
+    current = stream.tell()
+    if current != offset:
+        filter.read("padding[]", "%us" % (offset-current), "Padding")
+
+def sortSection(a, b):
+    return int(a["offset"] - b["offset"])
+
+class Section(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "elf_section", "Elf section", stream, parent)
+        self.read("raw", "{@end@}s", "Raw data")
+        
+class Sections(Filter):
+    def __init__(self, stream, parent, sections):
+        Filter.__init__(self, "elf_sections", "ELF sections", stream, parent)
+        for section in sections:
+            ofs = section["offset"]
+            size = section["file_size"]
+            sub = stream.createSub(ofs, size)
+            #self.readChild("section[]", DeflateFilter, sub, size, Section) 
+            chunk = self.readStreamChild("section[]", sub, Section) 
+            chunk.description = "ELF section (in file: %s..%s)" % (ofs, ofs+size)
+
+class ElfFile(Filter):
+    def __init__(self, stream, parent):
+        Filter.__init__(self, "elf_file", "ELF file", stream, parent)
+        self.readChild("elf_header", ElfHeader)
+        elf = self["elf_header"]
+        sections = []
+        for i in range(0, elf["phnum"]):
+            section = self.readChild("prg_header[]", ProgramHeader32)
+            sections.append(section.getFilter())
+
+        i = 1
+        for section in sections:
+            print "Section %u: type %u, data in %u..%u " % (i, section["type"], section["offset"], section["offset"]+section["file_size"])
+            i = i + 1
+            
+        if False:
+            sections.sort( sortSection )
+            for section in sections:
+                if section["type"] != 6 and section["offset"] != 0:
+                    print "  DO Section: %u..%u" % (section["offset"], section["offset"]+section["file_size"])
+                    seek(self, stream, section["offset"])
+                    print stream.tell(), section["offset"]
+#                    assert stream.tell() == section["offset"]
+                    self.read("section[]", "%us" % section["file_size"], "")
+            seek(self, stream, elf["shoff"])
+            assert stream.tell() == elf["shoff"]            
+        else:
+            size = elf["shoff"] - stream.tell()
+            newstream = stream.clone()
+            chunk = self.readChild("data", DeflateFilter, newstream, size, Sections, sections) 
+            chunk.description = "Sections (use an evil hack to manage share same data on differents parts)"
+            assert stream.tell() == elf["shoff"]
+        for i in range(0, elf["shnum"]):
+            chunk = self.readChild("section_header[]", SectionHeader32)
+            assert chunk.size == 40
+
+registerPlugin(ElfFile, "application/x-executable")

Modified: haypo/hachoir/stream/file.py
===================================================================
--- haypo/hachoir/stream/file.py	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/stream/file.py	2005-11-30 05:55:11 UTC (rev 289)
@@ -1,5 +1,6 @@
 from error import StreamError
 from stream import Stream
+import os
 
 class FileStream(Stream):
     def __init__(self, file, filename=None):
@@ -12,6 +13,10 @@
         self.__file.seek(0,2) # Seek to end
         self.__size = self.__file.tell()
         self.__file.seek(0,0) # Seel to beginning
+
+    def getType(self):
+        return "%s (%s)" % \
+            (self.__class__.__name__, self.filename)
         
     def read(self, size, seek=True):
         data = self.__file.read(size)
@@ -20,7 +25,11 @@
         return data            
 
     def clone(self):
-        return FileStream(self.__file, self.filename)
+        #?TODO: Don't copy low-level file IO,
+        # but only copy seed :-)
+        # => use internal?seed + cache
+        file_copy = open(self.filename)
+        return FileStream(file_copy, self.filename)
 
     def seek(self, pos, where=0):
         """ Read file seek document to understand where. """

Modified: haypo/hachoir/stream/stream.py
===================================================================
--- haypo/hachoir/stream/stream.py	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/stream/stream.py	2005-11-30 05:55:11 UTC (rev 289)
@@ -34,6 +34,9 @@
     
     #--- End of virtual functions -------------------------------------------    
 
+    def getType(self):
+        return self.__class__.__name__
+
     def eof(self):
         return self.getLastPos() <= self.tell() 
 
@@ -134,6 +137,11 @@
         self._end = self._start + self._size
         self._stream.seek(self._start)
 
+    def getType(self):
+        return "%s of %s: %s..%s" % \
+            (self.__class__.__name__, self._stream.getType(),
+             self._start, self._end)
+ 
     def search(self, str, size_max=None):
         if self._end == 0: return -1
         if size_max == None or self._end-self.tell() < size_max:
@@ -179,7 +187,7 @@
         if pos != -1:
             pos = pos - self._start
         return pos
-        
+               
     def read(self, size, seek=True):
         """ Works like Posix read (can returns less than size bytes. """
         return self._stream.read(size, seek)

Modified: haypo/hachoir/ui/hachoir.glade
===================================================================
--- haypo/hachoir/ui/hachoir.glade	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/ui/hachoir.glade	2005-11-30 05:55:11 UTC (rev 289)
@@ -309,320 +309,261 @@
       </child>
 
       <child>
-	<widget class="GtkVPaned" id="vpaned1">
+	<widget class="GtkScrolledWindow" id="scrolledwindow1">
 	  <property name="visible">True</property>
 	  <property name="can_focus">True</property>
+	  <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+	  <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+	  <property name="shadow_type">GTK_SHADOW_IN</property>
+	  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
 
 	  <child>
-	    <widget class="GtkScrolledWindow" id="scrolledwindow1">
+	    <widget class="GtkTreeView" id="table">
 	      <property name="visible">True</property>
 	      <property name="can_focus">True</property>
-	      <property name="hscrollbar_policy">GTK_POLICY_NEVER</property>
-	      <property name="vscrollbar_policy">GTK_POLICY_ALWAYS</property>
-	      <property name="shadow_type">GTK_SHADOW_IN</property>
-	      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
-
-	      <child>
-		<widget class="GtkTreeView" id="table">
-		  <property name="visible">True</property>
-		  <property name="can_focus">True</property>
-		  <property name="headers_visible">True</property>
-		  <property name="rules_hint">False</property>
-		  <property name="reorderable">False</property>
-		  <property name="enable_search">True</property>
-		  <property name="fixed_height_mode">False</property>
-		  <property name="hover_selection">False</property>
-		  <property name="hover_expand">False</property>
-		</widget>
-	      </child>
+	      <property name="headers_visible">True</property>
+	      <property name="rules_hint">False</property>
+	      <property name="reorderable">False</property>
+	      <property name="enable_search">True</property>
+	      <property name="fixed_height_mode">False</property>
+	      <property name="hover_selection">False</property>
+	      <property name="hover_expand">False</property>
 	    </widget>
-	    <packing>
-	      <property name="shrink">True</property>
-	      <property name="resize">True</property>
-	    </packing>
 	  </child>
+	</widget>
+	<packing>
+	  <property name="padding">0</property>
+	  <property name="expand">True</property>
+	  <property name="fill">True</property>
+	</packing>
+      </child>
 
+      <child>
+	<widget class="GtkNotebook" id="notebook1">
+	  <property name="visible">True</property>
+	  <property name="can_focus">True</property>
+	  <property name="show_tabs">True</property>
+	  <property name="show_border">True</property>
+	  <property name="tab_pos">GTK_POS_TOP</property>
+	  <property name="scrollable">False</property>
+	  <property name="enable_popup">False</property>
+
 	  <child>
-	    <widget class="GtkNotebook" id="notebook1">
+	    <widget class="GtkTable" id="table5">
+	      <property name="border_width">6</property>
 	      <property name="visible">True</property>
-	      <property name="can_focus">True</property>
-	      <property name="show_tabs">True</property>
-	      <property name="show_border">True</property>
-	      <property name="tab_pos">GTK_POS_TOP</property>
-	      <property name="scrollable">False</property>
-	      <property name="enable_popup">False</property>
+	      <property name="n_rows">3</property>
+	      <property name="n_columns">4</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">6</property>
+	      <property name="column_spacing">6</property>
 
 	      <child>
-		<widget class="GtkTable" id="table5">
-		  <property name="border_width">6</property>
+		<widget class="GtkLabel" id="label31">
 		  <property name="visible">True</property>
-		  <property name="n_rows">3</property>
-		  <property name="n_columns">4</property>
-		  <property name="homogeneous">False</property>
-		  <property name="row_spacing">6</property>
-		  <property name="column_spacing">6</property>
+		  <property name="label" translatable="yes">Name:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label31">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Name:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="filter_name">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="filter_name">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label32">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Decription:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label32">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Decription:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="filter_description">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="filter_description">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="filter_type">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="filter_type">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label39">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Type:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label39">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Type:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label28">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Stream:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label28">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Stream:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">2</property>
-		      <property name="right_attach">3</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="stream_size">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">3</property>
-		      <property name="right_attach">4</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkLabel" id="label29">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Size:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">2</property>
-		      <property name="right_attach">3</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
-
-		  <child>
-		    <widget class="GtkEntry" id="stream_type">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">3</property>
-		      <property name="right_attach">4</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="stream_size">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
 		</widget>
 		<packing>
-		  <property name="tab_expand">False</property>
-		  <property name="tab_fill">True</property>
+		  <property name="left_attach">3</property>
+		  <property name="right_attach">4</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="label21">
+		<widget class="GtkLabel" id="label29">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Filter</property>
+		  <property name="label" translatable="yes">Size:</property>
 		  <property name="use_underline">False</property>
 		  <property name="use_markup">False</property>
 		  <property name="justify">GTK_JUSTIFY_LEFT</property>
 		  <property name="wrap">False</property>
 		  <property name="selectable">False</property>
-		  <property name="xalign">0.5</property>
+		  <property name="xalign">0</property>
 		  <property name="yalign">0.5</property>
 		  <property name="xpad">0</property>
 		  <property name="ypad">0</property>
@@ -632,281 +573,281 @@
 		  <property name="angle">0</property>
 		</widget>
 		<packing>
-		  <property name="type">tab</property>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkTable" id="table7">
-		  <property name="border_width">6</property>
+		<widget class="GtkEntry" id="stream_type">
 		  <property name="visible">True</property>
-		  <property name="n_rows">3</property>
-		  <property name="n_columns">4</property>
-		  <property name="homogeneous">False</property>
-		  <property name="row_spacing">6</property>
-		  <property name="column_spacing">6</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">3</property>
+		  <property name="right_attach">4</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label33">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Name:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	  <child>
+	    <widget class="GtkLabel" id="label21">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Filter</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="chunk_name">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	  <child>
+	    <widget class="GtkTable" id="table7">
+	      <property name="border_width">6</property>
+	      <property name="visible">True</property>
+	      <property name="n_rows">3</property>
+	      <property name="n_columns">4</property>
+	      <property name="homogeneous">False</property>
+	      <property name="row_spacing">6</property>
+	      <property name="column_spacing">6</property>
 
-		  <child>
-		    <widget class="GtkLabel" id="label41">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Address:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">2</property>
-		      <property name="right_attach">3</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label33">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Name:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="chunk_address">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">3</property>
-		      <property name="right_attach">4</property>
-		      <property name="top_attach">0</property>
-		      <property name="bottom_attach">1</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="chunk_name">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label34">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Size:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">2</property>
-		      <property name="right_attach">3</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label41">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Address:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="chunk_size">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">3</property>
-		      <property name="right_attach">4</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="chunk_address">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">3</property>
+		  <property name="right_attach">4</property>
+		  <property name="top_attach">0</property>
+		  <property name="bottom_attach">1</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label35">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Type:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label34">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Size:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">2</property>
+		  <property name="right_attach">3</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="chunk_type">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">1</property>
-		      <property name="bottom_attach">2</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="chunk_size">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">3</property>
+		  <property name="right_attach">4</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkLabel" id="label36">
-		      <property name="visible">True</property>
-		      <property name="label" translatable="yes">Description:</property>
-		      <property name="use_underline">False</property>
-		      <property name="use_markup">False</property>
-		      <property name="justify">GTK_JUSTIFY_LEFT</property>
-		      <property name="wrap">False</property>
-		      <property name="selectable">False</property>
-		      <property name="xalign">0</property>
-		      <property name="yalign">0.5</property>
-		      <property name="xpad">0</property>
-		      <property name="ypad">0</property>
-		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		      <property name="width_chars">-1</property>
-		      <property name="single_line_mode">False</property>
-		      <property name="angle">0</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">0</property>
-		      <property name="right_attach">1</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="x_options">fill</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkLabel" id="label35">
+		  <property name="visible">True</property>
+		  <property name="label" translatable="yes">Type:</property>
+		  <property name="use_underline">False</property>
+		  <property name="use_markup">False</property>
+		  <property name="justify">GTK_JUSTIFY_LEFT</property>
+		  <property name="wrap">False</property>
+		  <property name="selectable">False</property>
+		  <property name="xalign">0</property>
+		  <property name="yalign">0.5</property>
+		  <property name="xpad">0</property>
+		  <property name="ypad">0</property>
+		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		  <property name="width_chars">-1</property>
+		  <property name="single_line_mode">False</property>
+		  <property name="angle">0</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
 
-		  <child>
-		    <widget class="GtkEntry" id="chunk_description">
-		      <property name="visible">True</property>
-		      <property name="can_focus">True</property>
-		      <property name="editable">False</property>
-		      <property name="visibility">True</property>
-		      <property name="max_length">0</property>
-		      <property name="text" translatable="yes"></property>
-		      <property name="has_frame">True</property>
-		      <property name="invisible_char">*</property>
-		      <property name="activates_default">False</property>
-		    </widget>
-		    <packing>
-		      <property name="left_attach">1</property>
-		      <property name="right_attach">2</property>
-		      <property name="top_attach">2</property>
-		      <property name="bottom_attach">3</property>
-		      <property name="y_options"></property>
-		    </packing>
-		  </child>
+	      <child>
+		<widget class="GtkEntry" id="chunk_type">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
 		</widget>
 		<packing>
-		  <property name="tab_expand">False</property>
-		  <property name="tab_fill">True</property>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">1</property>
+		  <property name="bottom_attach">2</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="label23">
+		<widget class="GtkLabel" id="label36">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Chunk</property>
+		  <property name="label" translatable="yes">Description:</property>
 		  <property name="use_underline">False</property>
 		  <property name="use_markup">False</property>
 		  <property name="justify">GTK_JUSTIFY_LEFT</property>
 		  <property name="wrap">False</property>
 		  <property name="selectable">False</property>
-		  <property name="xalign">0.5</property>
+		  <property name="xalign">0</property>
 		  <property name="yalign">0.5</property>
 		  <property name="xpad">0</property>
 		  <property name="ypad">0</property>
@@ -916,164 +857,213 @@
 		  <property name="angle">0</property>
 		</widget>
 		<packing>
-		  <property name="type">tab</property>
+		  <property name="left_attach">0</property>
+		  <property name="right_attach">1</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="x_options">fill</property>
+		  <property name="y_options"></property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkVBox" id="vbox5">
+		<widget class="GtkEntry" id="chunk_description">
 		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="editable">False</property>
+		  <property name="visibility">True</property>
+		  <property name="max_length">0</property>
+		  <property name="text" translatable="yes"></property>
+		  <property name="has_frame">True</property>
+		  <property name="invisible_char">*</property>
+		  <property name="activates_default">False</property>
+		</widget>
+		<packing>
+		  <property name="left_attach">1</property>
+		  <property name="right_attach">2</property>
+		  <property name="top_attach">2</property>
+		  <property name="bottom_attach">3</property>
+		  <property name="y_options"></property>
+		</packing>
+	      </child>
+	    </widget>
+	    <packing>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label23">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Chunk</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
+
+	  <child>
+	    <widget class="GtkVBox" id="vbox5">
+	      <property name="visible">True</property>
+	      <property name="homogeneous">False</property>
+	      <property name="spacing">0</property>
+
+	      <child>
+		<widget class="GtkHBox" id="hbox2">
+		  <property name="visible">True</property>
 		  <property name="homogeneous">False</property>
 		  <property name="spacing">0</property>
 
 		  <child>
-		    <widget class="GtkHBox" id="hbox2">
+		    <widget class="GtkLabel" id="label42">
 		      <property name="visible">True</property>
-		      <property name="homogeneous">False</property>
-		      <property name="spacing">0</property>
-
-		      <child>
-			<widget class="GtkLabel" id="label42">
-			  <property name="visible">True</property>
-			  <property name="label" translatable="yes">Path:</property>
-			  <property name="use_underline">False</property>
-			  <property name="use_markup">False</property>
-			  <property name="justify">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap">False</property>
-			  <property name="selectable">False</property>
-			  <property name="xalign">0</property>
-			  <property name="yalign">0.5</property>
-			  <property name="xpad">0</property>
-			  <property name="ypad">0</property>
-			  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-			  <property name="width_chars">-1</property>
-			  <property name="single_line_mode">False</property>
-			  <property name="angle">0</property>
-			</widget>
-			<packing>
-			  <property name="padding">6</property>
-			  <property name="expand">False</property>
-			  <property name="fill">False</property>
-			</packing>
-		      </child>
-
-		      <child>
-			<widget class="GtkEntry" id="hexa_path">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="editable">False</property>
-			  <property name="visibility">True</property>
-			  <property name="max_length">0</property>
-			  <property name="text" translatable="yes"></property>
-			  <property name="has_frame">True</property>
-			  <property name="invisible_char">*</property>
-			  <property name="activates_default">False</property>
-			</widget>
-			<packing>
-			  <property name="padding">6</property>
-			  <property name="expand">True</property>
-			  <property name="fill">True</property>
-			</packing>
-		      </child>
+		      <property name="label" translatable="yes">Path:</property>
+		      <property name="use_underline">False</property>
+		      <property name="use_markup">False</property>
+		      <property name="justify">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap">False</property>
+		      <property name="selectable">False</property>
+		      <property name="xalign">0</property>
+		      <property name="yalign">0.5</property>
+		      <property name="xpad">0</property>
+		      <property name="ypad">0</property>
+		      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+		      <property name="width_chars">-1</property>
+		      <property name="single_line_mode">False</property>
+		      <property name="angle">0</property>
 		    </widget>
 		    <packing>
-		      <property name="padding">0</property>
+		      <property name="padding">6</property>
 		      <property name="expand">False</property>
 		      <property name="fill">False</property>
 		    </packing>
 		  </child>
 
 		  <child>
-		    <widget class="GtkScrolledWindow" id="scrolledwindow2">
+		    <widget class="GtkEntry" id="hexa_path">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
-		      <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
-		      <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
-		      <property name="shadow_type">GTK_SHADOW_IN</property>
-		      <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
-
-		      <child>
-			<widget class="GtkTextView" id="hexa_content">
-			  <property name="visible">True</property>
-			  <property name="can_focus">True</property>
-			  <property name="editable">False</property>
-			  <property name="overwrite">False</property>
-			  <property name="accepts_tab">False</property>
-			  <property name="justification">GTK_JUSTIFY_LEFT</property>
-			  <property name="wrap_mode">GTK_WRAP_NONE</property>
-			  <property name="cursor_visible">True</property>
-			  <property name="pixels_above_lines">0</property>
-			  <property name="pixels_below_lines">0</property>
-			  <property name="pixels_inside_wrap">0</property>
-			  <property name="left_margin">0</property>
-			  <property name="right_margin">0</property>
-			  <property name="indent">0</property>
-			  <property name="text" translatable="yes"></property>
-			</widget>
-		      </child>
+		      <property name="editable">False</property>
+		      <property name="visibility">True</property>
+		      <property name="max_length">0</property>
+		      <property name="text" translatable="yes"></property>
+		      <property name="has_frame">True</property>
+		      <property name="invisible_char">*</property>
+		      <property name="activates_default">False</property>
 		    </widget>
 		    <packing>
-		      <property name="padding">12</property>
+		      <property name="padding">6</property>
 		      <property name="expand">True</property>
 		      <property name="fill">True</property>
 		    </packing>
 		  </child>
+		</widget>
+		<packing>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
+		</packing>
+	      </child>
 
+	      <child>
+		<widget class="GtkScrolledWindow" id="scrolledwindow2">
+		  <property name="visible">True</property>
+		  <property name="can_focus">True</property>
+		  <property name="hscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		  <property name="vscrollbar_policy">GTK_POLICY_AUTOMATIC</property>
+		  <property name="shadow_type">GTK_SHADOW_IN</property>
+		  <property name="window_placement">GTK_CORNER_TOP_LEFT</property>
+
 		  <child>
-		    <widget class="GtkButton" id="button3">
+		    <widget class="GtkTextView" id="hexa_content">
 		      <property name="visible">True</property>
 		      <property name="can_focus">True</property>
-		      <property name="label">gtk-refresh</property>
-		      <property name="use_stock">True</property>
-		      <property name="relief">GTK_RELIEF_NORMAL</property>
-		      <property name="focus_on_click">True</property>
-		      <signal name="clicked" handler="on_hexadecimal_clicked" last_modification_time="Wed, 30 Nov 2005 02:05:28 GMT"/>
+		      <property name="editable">False</property>
+		      <property name="overwrite">False</property>
+		      <property name="accepts_tab">False</property>
+		      <property name="justification">GTK_JUSTIFY_LEFT</property>
+		      <property name="wrap_mode">GTK_WRAP_NONE</property>
+		      <property name="cursor_visible">True</property>
+		      <property name="pixels_above_lines">0</property>
+		      <property name="pixels_below_lines">0</property>
+		      <property name="pixels_inside_wrap">0</property>
+		      <property name="left_margin">0</property>
+		      <property name="right_margin">0</property>
+		      <property name="indent">0</property>
+		      <property name="text" translatable="yes"></property>
 		    </widget>
-		    <packing>
-		      <property name="padding">0</property>
-		      <property name="expand">False</property>
-		      <property name="fill">False</property>
-		    </packing>
 		  </child>
 		</widget>
 		<packing>
-		  <property name="tab_expand">False</property>
-		  <property name="tab_fill">True</property>
+		  <property name="padding">12</property>
+		  <property name="expand">True</property>
+		  <property name="fill">True</property>
 		</packing>
 	      </child>
 
 	      <child>
-		<widget class="GtkLabel" id="label40">
+		<widget class="GtkButton" id="button3">
 		  <property name="visible">True</property>
-		  <property name="label" translatable="yes">Hexa</property>
-		  <property name="use_underline">False</property>
-		  <property name="use_markup">False</property>
-		  <property name="justify">GTK_JUSTIFY_LEFT</property>
-		  <property name="wrap">False</property>
-		  <property name="selectable">False</property>
-		  <property name="xalign">0.5</property>
-		  <property name="yalign">0.5</property>
-		  <property name="xpad">0</property>
-		  <property name="ypad">0</property>
-		  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
-		  <property name="width_chars">-1</property>
-		  <property name="single_line_mode">False</property>
-		  <property name="angle">0</property>
+		  <property name="can_focus">True</property>
+		  <property name="label">gtk-refresh</property>
+		  <property name="use_stock">True</property>
+		  <property name="relief">GTK_RELIEF_NORMAL</property>
+		  <property name="focus_on_click">True</property>
+		  <signal name="clicked" handler="on_hexadecimal_clicked" last_modification_time="Wed, 30 Nov 2005 02:05:28 GMT"/>
 		</widget>
 		<packing>
-		  <property name="type">tab</property>
+		  <property name="padding">0</property>
+		  <property name="expand">False</property>
+		  <property name="fill">False</property>
 		</packing>
 	      </child>
 	    </widget>
 	    <packing>
-	      <property name="shrink">False</property>
-	      <property name="resize">True</property>
+	      <property name="tab_expand">False</property>
+	      <property name="tab_fill">True</property>
 	    </packing>
 	  </child>
+
+	  <child>
+	    <widget class="GtkLabel" id="label40">
+	      <property name="visible">True</property>
+	      <property name="label" translatable="yes">Hexa</property>
+	      <property name="use_underline">False</property>
+	      <property name="use_markup">False</property>
+	      <property name="justify">GTK_JUSTIFY_LEFT</property>
+	      <property name="wrap">False</property>
+	      <property name="selectable">False</property>
+	      <property name="xalign">0.5</property>
+	      <property name="yalign">0.5</property>
+	      <property name="xpad">0</property>
+	      <property name="ypad">0</property>
+	      <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+	      <property name="width_chars">-1</property>
+	      <property name="single_line_mode">False</property>
+	      <property name="angle">0</property>
+	    </widget>
+	    <packing>
+	      <property name="type">tab</property>
+	    </packing>
+	  </child>
 	</widget>
 	<packing>
 	  <property name="padding">0</property>
-	  <property name="expand">True</property>
+	  <property name="expand">False</property>
 	  <property name="fill">True</property>
 	</packing>
       </child>

Modified: haypo/hachoir/ui/ui_window.py
===================================================================
--- haypo/hachoir/ui/ui_window.py	2005-11-30 03:00:08 UTC (rev 288)
+++ haypo/hachoir/ui/ui_window.py	2005-11-30 05:55:11 UTC (rev 289)
@@ -34,7 +34,7 @@
         self.filter_path.set_text(filter.getPath())
 
         stream = filter.getStream()
-        self.stream_type.set_text(stream.__class__.__name__)
+        self.stream_type.set_text(stream.getType())
         self.stream_size.set_text("%u" % filter.getSize())
 
 class MainWindow:



