<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Happyboom-svn] r131 - poilu/trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/happyboom-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r131%20-%20poilu/trunk&In-Reply-To=%3C200509090149.j891nAaV026186%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000036.html">
   <LINK REL="Next"  HREF="000038.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Happyboom-svn] r131 - poilu/trunk</H1>
    <B>Victor STINNER at BerliOS</B> 
    <A HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r131%20-%20poilu/trunk&In-Reply-To=%3C200509090149.j891nAaV026186%40sheep.berlios.de%3E"
       TITLE="[Happyboom-svn] r131 - poilu/trunk">haypo at berlios.de
       </A><BR>
    <I>Fri Sep  9 03:49:10 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000036.html">[Happyboom-svn] r130 - poilu/trunk
</A></li>
        <LI>Next message: <A HREF="000038.html">[Happyboom-svn] r132 - poilu/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37">[ date ]</a>
              <a href="thread.html#37">[ thread ]</a>
              <a href="subject.html#37">[ subject ]</a>
              <a href="author.html#37">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: haypo
Date: 2005-09-09 03:49:04 +0200 (Fri, 09 Sep 2005)
New Revision: 131

Added:
   poilu/trunk/irclib.py
Modified:
   poilu/trunk/dico.txt
   poilu/trunk/dico_poilu.py
   poilu/trunk/pypoil.py
   poilu/trunk/terminaison.txt
Log:
Fixe les terminaisons. Ajoute la version tuning (avec leave) de irclib.


Modified: poilu/trunk/dico.txt
===================================================================
--- poilu/trunk/dico.txt	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/dico.txt	2005-09-09 01:49:04 UTC (rev 131)
@@ -19,15 +19,20 @@
 moustiques
 comique
 loup
+nez
+n&#195;&#169;n&#195;&#169;
 meules
 poing
 coin
 babouin
 marsouin
+pierre
 chien
 croutes
+pieds
+gosier
+docteur
 pubis
-docteur
 poignet
 mollet
 superettes
@@ -61,13 +66,8 @@
 blaireaux
 chalumeau
 dinosaures
-pieds
-nez
-n&#195;&#169;n&#195;&#169;
-gosier
 cul
 dahu
-pointu
 poilu
 tout nu
 cr&#195;&#169;pu

Modified: poilu/trunk/dico_poilu.py
===================================================================
--- poilu/trunk/dico_poilu.py	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/dico_poilu.py	2005-09-09 01:49:04 UTC (rev 131)
@@ -57,6 +57,7 @@
 
     def charge_dico(self):
         f = file(&quot;dico.txt&quot;,&quot;r&quot;)
+        self.dico = {}
         for ligne in f:
             ligne = unicode(ligne.strip(), &quot;utf8&quot;)
             if ligne != '': self.ajoute_terme(ligne)

Added: poilu/trunk/irclib.py
===================================================================
--- poilu/trunk/irclib.py	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/irclib.py	2005-09-09 01:49:04 UTC (rev 131)
@@ -0,0 +1,1556 @@
+# Copyright (C) 1999--2002  Joel Rosdahl
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+#
+# Joel Rosdahl &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">joel at rosdahl.net</A>&gt;
+#
+# $Id: irclib.py,v 1.30 2005/02/24 01:25:50 keltus Exp $
+
+&quot;&quot;&quot;irclib -- Internet Relay Chat (IRC) protocol client library.
+
+This library is intended to encapsulate the IRC protocol at a quite
+low level.  It provides an event-driven IRC client framework.  It has
+a fairly thorough support for the basic IRC protocol and CTCP, but DCC
+connection support is not yet implemented.
+
+In order to understand how to make an IRC client, I'm afraid you more
+or less must understand the IRC specifications.  They are available
+here: [IRC specifications].
+
+The main features of the IRC client framework are:
+
+  * Abstraction of the IRC protocol.
+  * Handles multiple simultaneous IRC server connections.
+  * Handles server PONGing transparently.
+  * Messages to the IRC server are done by calling methods on an IRC
+    connection object.
+  * Messages from an IRC server triggers events, which can be caught
+    by event handlers.
+  * Reading from and writing to IRC server sockets are normally done
+    by an internal select() loop, but the select()ing may be done by
+    an external main loop.
+  * Functions can be registered to execute at specified times by the
+    event-loop.
+  * Decodes CTCP tagging correctly (hopefully); I haven't seen any
+    other IRC client implementation that handles the CTCP
+    specification subtilties.
+  * A kind of simple, single-server, object-oriented IRC client class
+    that dispatches events to instance methods is included.
+
+Current limitations:
+
+  * The IRC protocol shines through the abstraction a bit too much.
+  * Data is not written asynchronously to the server, i.e. the write()
+    may block if the TCP buffers are stuffed.
+  * There are no support for DCC connections.
+  * The author haven't even read RFC 2810, 2811, 2812 and 2813.
+  * Like most projects, documentation is lacking...
+
+Since I seldom use IRC anymore, I will probably not work much on the
+library.  If you want to help or continue developing the library,
+please contact me (Joel Rosdahl &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">joel at rosdahl.net</A>&gt;).
+
+.. [IRC specifications] <A HREF="http://www.irchelp.org/irchelp/rfc/">http://www.irchelp.org/irchelp/rfc/</A>
+&quot;&quot;&quot;
+
+import bisect
+import re
+import select
+import socket
+import string
+import sys
+import time
+import types
+
+VERSION = 0, 4, 4
+DEBUG = 0
+
+# TODO
+# ----
+# (maybe) thread safety
+# (maybe) color parser convenience functions
+# documentation (including all event types)
+# (maybe) add awareness of different types of ircds
+# send data asynchronously to the server (and DCC connections)
+# (maybe) automatically close unused, passive DCC connections after a while
+
+# NOTES
+# -----
+# connection.quit() only sends QUIT to the server.
+# ERROR from the server triggers the error event and the disconnect event.
+# dropping of the connection triggers the disconnect event.
+
+class IRCError(Exception):
+    &quot;&quot;&quot;Represents an IRC exception.&quot;&quot;&quot;
+    pass
+
+
+class IRC:
+    &quot;&quot;&quot;Class that handles one or several IRC server connections.
+
+    When an IRC object has been instantiated, it can be used to create
+    Connection objects that represent the IRC connections.  The
+    responsibility of the IRC object is to provide an event-driven
+    framework for the connections and to keep the connections alive.
+    It runs a select loop to poll each connection's TCP socket and
+    hands over the sockets with incoming data for processing by the
+    corresponding connection.
+
+    The methods of most interest for an IRC client writer are server,
+    add_global_handler, remove_global_handler, execute_at,
+    execute_delayed, process_once and process_forever.
+
+    Here is an example:
+
+        irc = irclib.IRC()
+        server = irc.server()
+        server.connect(\&quot;irc.some.where\&quot;, 6667, \&quot;my_nickname\&quot;)
+        server.privmsg(\&quot;a_nickname\&quot;, \&quot;Hi there!\&quot;)
+        server.process_forever()
+
+    This will connect to the IRC server irc.some.where on port 6667
+    using the nickname my_nickname and send the message \&quot;Hi there!\&quot;
+    to the nickname a_nickname.
+    &quot;&quot;&quot;
+
+    def __init__(self, fn_to_add_socket=None,
+                 fn_to_remove_socket=None,
+                 fn_to_add_timeout=None):
+        &quot;&quot;&quot;Constructor for IRC objects.
+
+        Optional arguments are fn_to_add_socket, fn_to_remove_socket
+        and fn_to_add_timeout.  The first two specify functions that
+        will be called with a socket object as argument when the IRC
+        object wants to be notified (or stop being notified) of data
+        coming on a new socket.  When new data arrives, the method
+        process_data should be called.  Similarly, fn_to_add_timeout
+        is called with a number of seconds (a floating point number)
+        as first argument when the IRC object wants to receive a
+        notification (by calling the process_timeout method).  So, if
+        e.g. the argument is 42.17, the object wants the
+        process_timeout method to be called after 42 seconds and 170
+        milliseconds.
+
+        The three arguments mainly exist to be able to use an external
+        main loop (for example Tkinter's or PyGTK's main app loop)
+        instead of calling the process_forever method.
+
+        An alternative is to just call ServerConnection.process_once()
+        once in a while.
+        &quot;&quot;&quot;
+
+        if fn_to_add_socket and fn_to_remove_socket:
+            self.fn_to_add_socket = fn_to_add_socket
+            self.fn_to_remove_socket = fn_to_remove_socket
+        else:
+            self.fn_to_add_socket = None
+            self.fn_to_remove_socket = None
+
+        self.fn_to_add_timeout = fn_to_add_timeout
+        self.connections = []
+        self.handlers = {}
+        self.delayed_commands = [] # list of tuples in the format (time, function, arguments)
+
+        self.add_global_handler(&quot;ping&quot;, _ping_ponger, -42)
+
+    def server(self):
+        &quot;&quot;&quot;Creates and returns a ServerConnection object.&quot;&quot;&quot;
+
+        c = ServerConnection(self)
+        self.connections.append(c)
+        return c
+
+    def process_data(self, sockets):
+        &quot;&quot;&quot;Called when there is more data to read on connection sockets.
+
+        Arguments:
+
+            sockets -- A list of socket objects.
+
+        See documentation for IRC.__init__.
+        &quot;&quot;&quot;
+        for s in sockets:
+            for c in self.connections:
+                if s == c._get_socket():
+                    c.process_data()
+
+    def process_timeout(self):
+        &quot;&quot;&quot;Called when a timeout notification is due.
+
+        See documentation for IRC.__init__.
+        &quot;&quot;&quot;
+        t = time.time()
+        while self.delayed_commands:
+            if t &gt;= self.delayed_commands[0][0]:
+                self.delayed_commands[0][1](*self.delayed_commands[0][2])
+                del self.delayed_commands[0]
+            else:
+                break
+
+    def process_once(self, timeout=0):
+        &quot;&quot;&quot;Process data from connections once.
+
+        Arguments:
+
+            timeout -- How long the select() call should wait if no
+                       data is available.
+
+        This method should be called periodically to check and process
+        incoming data, if there are any.  If that seems boring, look
+        at the process_forever method.
+        &quot;&quot;&quot;
+        sockets = map(lambda x: x._get_socket(), self.connections)
+        sockets = filter(lambda x: x != None, sockets)
+        if sockets:
+            (i, o, e) = select.select(sockets, [], [], timeout)
+            self.process_data(i)
+        else:
+            time.sleep(timeout)
+        self.process_timeout()
+
+    def process_forever(self, timeout=0.2):
+        &quot;&quot;&quot;Run an infinite loop, processing data from connections.
+
+        This method repeatedly calls process_once.
+
+        Arguments:
+
+            timeout -- Parameter to pass to process_once.
+        &quot;&quot;&quot;
+        while 1:
+            self.process_once(timeout)
+
+    def disconnect_all(self, message=&quot;&quot;):
+        &quot;&quot;&quot;Disconnects all connections.&quot;&quot;&quot;
+        for c in self.connections:
+            c.quit(message)
+            c.disconnect(message)
+
+    def add_global_handler(self, event, handler, priority=0):
+        &quot;&quot;&quot;Adds a global handler function for a specific event type.
+
+        Arguments:
+
+            event -- Event type (a string).  Check the values of the
+            numeric_events dictionary in irclib.py for possible event
+            types.
+
+            handler -- Callback function.
+
+            priority -- A number (the lower number, the higher priority).
+
+        The handler function is called whenever the specified event is
+        triggered in any of the connections.  See documentation for
+        the Event class.
+
+        The handler functions are called in priority order (lowest
+        number is highest priority).  If a handler function returns
+        \&quot;NO MORE\&quot;, no more handlers will be called.
+        &quot;&quot;&quot;
+
+        if not self.handlers.has_key(event):
+            self.handlers[event] = []
+        bisect.insort(self.handlers[event], ((priority, handler)))
+
+    def remove_global_handler(self, event, handler):
+        &quot;&quot;&quot;Removes a global handler function.
+
+        Arguments:
+
+            event -- Event type (a string).
+
+            handler -- Callback function.
+
+        Returns 1 on success, otherwise 0.
+        &quot;&quot;&quot;
+        if not self.handlers.has_key(event):
+            return 0
+        for h in self.handlers[event]:
+            if handler == h[1]:
+                self.handlers[event].remove(h)
+        return 1
+
+    def execute_at(self, at, function, arguments=()):
+        &quot;&quot;&quot;Execute a function at a specified time.
+
+        Arguments:
+
+            at -- Execute at this time (standard \&quot;time_t\&quot; time).
+
+            function -- Function to call.
+
+            arguments -- Arguments to give the function.
+        &quot;&quot;&quot;
+        self.execute_delayed(at-time.time(), function, arguments)
+
+    def execute_delayed(self, delay, function, arguments=()):
+        &quot;&quot;&quot;Execute a function after a specified time.
+
+        Arguments:
+
+            delay -- How many seconds to wait.
+
+            function -- Function to call.
+
+            arguments -- Arguments to give the function.
+        &quot;&quot;&quot;
+        bisect.insort(self.delayed_commands, (delay+time.time(), function, arguments))
+        if self.fn_to_add_timeout:
+            self.fn_to_add_timeout(delay)
+
+    def dcc(self, dcctype=&quot;chat&quot;):
+        &quot;&quot;&quot;Creates and returns a DCCConnection object.
+
+        Arguments:
+
+            dcctype -- &quot;chat&quot; for DCC CHAT connections or &quot;raw&quot; for
+                       DCC SEND (or other DCC types). If &quot;chat&quot;,
+                       incoming data will be split in newline-separated
+                       chunks. If &quot;raw&quot;, incoming data is not touched.
+        &quot;&quot;&quot;
+        c = DCCConnection(self, dcctype)
+        self.connections.append(c)
+        return c
+
+    def _handle_event(self, connection, event):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+        h = self.handlers
+        for handler in h.get(&quot;all_events&quot;, []) + h.get(event.eventtype(), []):
+            if handler[1](connection, event) == &quot;NO MORE&quot;:
+                return
+
+    def _remove_connection(self, connection):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+        self.connections.remove(connection)
+        if self.fn_to_remove_socket:
+            self.fn_to_remove_socket(connection._get_socket())
+
+_rfc_1459_command_regexp = re.compile(&quot;^(:(?P&lt;prefix&gt;[^ ]+) +)?(?P&lt;command&gt;[^ ]+)( *(?P&lt;argument&gt; .+))?&quot;)
+
+
+class Connection:
+    &quot;&quot;&quot;Base class for IRC connections.
+
+    Must be overridden.
+    &quot;&quot;&quot;
+    def __init__(self, irclibobj):
+        self.irclibobj = irclibobj
+
+    def _get_socket():
+        raise IRCError, &quot;Not overridden&quot;
+
+    ##############################
+    ### Convenience wrappers.
+
+    def execute_at(self, at, function, arguments=()):
+        self.irclibobj.execute_at(at, function, arguments)
+
+    def execute_delayed(self, delay, function, arguments=()):
+        self.irclibobj.execute_delayed(delay, function, arguments)
+
+
+class ServerConnectionError(IRCError):
+    pass
+
+class ServerNotConnectedError(ServerConnectionError):
+    pass
+
+
+# Huh!?  Crrrrazy EFNet doesn't follow the RFC: their ircd seems to
+# use \n as message separator!  :P
+_linesep_regexp = re.compile(&quot;\r?\n&quot;)
+
+class ServerConnection(Connection):
+    &quot;&quot;&quot;This class represents an IRC server connection.
+
+    ServerConnection objects are instantiated by calling the server
+    method on an IRC object.
+    &quot;&quot;&quot;
+
+    def __init__(self, irclibobj):
+        Connection.__init__(self, irclibobj)
+        self.connected = 0  # Not connected yet.
+
+    def connect(self, server, port, nickname, password=None, username=None,
+                ircname=None, localaddress=&quot;&quot;, localport=0):
+        &quot;&quot;&quot;Connect/reconnect to a server.
+
+        Arguments:
+
+            server -- Server name.
+
+            port -- Port number.
+
+            nickname -- The nickname.
+
+            password -- Password (if any).
+
+            username -- The username.
+
+            ircname -- The IRC name (&quot;realname&quot;).
+
+            localaddress -- Bind the connection to a specific local IP address.
+
+            localport -- Bind the connection to a specific local port.
+
+        This function can be called to reconnect a closed connection.
+
+        Returns the ServerConnection object.
+        &quot;&quot;&quot;
+        if self.connected:
+            self.quit(&quot;Changing servers&quot;)
+
+        self.socket = None
+        self.previous_buffer = &quot;&quot;
+        self.handlers = {}
+        self.real_server_name = &quot;&quot;
+        self.real_nickname = nickname
+        self.server = server
+        self.port = port
+        self.nickname = nickname
+        self.username = username or nickname
+        self.ircname = ircname or nickname
+        self.password = password
+        self.localaddress = localaddress
+        self.localport = localport
+        self.localhost = socket.gethostname()
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        try:
+            self.socket.bind((self.localaddress, self.localport))
+            self.socket.connect((self.server, self.port))
+        except socket.error, x:
+            self.socket.close()
+            self.socket = None
+            raise ServerConnectionError, &quot;Couldn't connect to socket: %s&quot; % x
+        self.connected = 1
+        if self.irclibobj.fn_to_add_socket:
+            self.irclibobj.fn_to_add_socket(self.socket)
+
+        # Log on...
+        if self.password:
+            self.pass_(self.password)
+        self.nick(self.nickname)
+        self.user(self.username, self.ircname)
+        return self
+
+    def close(self):
+        &quot;&quot;&quot;Close the connection.
+
+        This method closes the connection permanently; after it has
+        been called, the object is unusable.
+        &quot;&quot;&quot;
+
+        self.disconnect(&quot;Closing object&quot;)
+
+    def _get_socket(self):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+        return self.socket
+
+    def get_server_name(self):
+        &quot;&quot;&quot;Get the (real) server name.
+
+        This method returns the (real) server name, or, more
+        specifically, what the server calls itself.
+        &quot;&quot;&quot;
+
+        if self.real_server_name:
+            return self.real_server_name
+        else:
+            return &quot;&quot;
+
+    def get_nickname(self):
+        &quot;&quot;&quot;Get the (real) nick name.
+
+        This method returns the (real) nickname.  The library keeps
+        track of nick changes, so it might not be the nick name that
+        was passed to the connect() method.  &quot;&quot;&quot;
+
+        return self.real_nickname
+
+    def process_data(self):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+
+        try:
+            new_data = self.socket.recv(2**14)
+        except socket.error, x:
+            # The server hung up.
+            self.disconnect(&quot;Connection reset by peer&quot;)
+            return
+        if not new_data:
+            # Read nothing: connection must be down.
+            self.disconnect(&quot;Connection reset by peer&quot;)
+            return
+
+        lines = _linesep_regexp.split(self.previous_buffer + new_data)
+
+        # Save the last, unfinished line.
+        self.previous_buffer = lines[-1]
+        lines = lines[:-1]
+
+        for line in lines:
+            if DEBUG:
+                print &quot;FROM SERVER:&quot;, line
+
+            if not line:
+                continue
+
+            prefix = None
+            command = None
+            arguments = None
+            self._handle_event(Event(&quot;all_raw_messages&quot;,
+                                     self.get_server_name(),
+                                     None,
+                                     [line]))
+
+            m = _rfc_1459_command_regexp.match(line)
+            if m.group(&quot;prefix&quot;):
+                prefix = m.group(&quot;prefix&quot;)
+                if not self.real_server_name:
+                    self.real_server_name = prefix
+
+            if m.group(&quot;command&quot;):
+                command = string.lower(m.group(&quot;command&quot;))
+
+            if m.group(&quot;argument&quot;):
+                a = string.split(m.group(&quot;argument&quot;), &quot; :&quot;, 1)
+                arguments = string.split(a[0])
+                if len(a) == 2:
+                    arguments.append(a[1])
+
+            if command == &quot;nick&quot;:
+                if nm_to_n(prefix) == self.real_nickname:
+                    self.real_nickname = arguments[0]
+            elif command == &quot;001&quot;:
+                # Record the nickname in case the client changed nick
+                # in a nicknameinuse callback.
+                self.real_nickname = arguments[0]
+
+            if command in [&quot;privmsg&quot;, &quot;notice&quot;]:
+                target, message = arguments[0], arguments[1]
+                messages = _ctcp_dequote(message)
+
+                if command == &quot;privmsg&quot;:
+                    if is_channel(target):
+                        command = &quot;pubmsg&quot;
+                else:
+                    if is_channel(target):
+                        command = &quot;pubnotice&quot;
+                    else:
+                        command = &quot;privnotice&quot;
+
+                for m in messages:
+                    if type(m) is types.TupleType:
+                        if command in [&quot;privmsg&quot;, &quot;pubmsg&quot;]:
+                            command = &quot;ctcp&quot;
+                        else:
+                            command = &quot;ctcpreply&quot;
+
+                        m = list(m)
+                        if DEBUG:
+                            print &quot;command: %s, source: %s, target: %s, arguments: %s&quot; % (
+                                command, prefix, target, m)
+                        self._handle_event(Event(command, prefix, target, m))
+                        if command == &quot;ctcp&quot; and m[0] == &quot;ACTION&quot;:
+                            # Emit an action event too. We're generous today.
+                            self._handle_event(Event(&quot;action&quot;, prefix, target, m[1:]))
+                    else:
+                        if DEBUG:
+                            print &quot;command: %s, source: %s, target: %s, arguments: %s&quot; % (
+                                command, prefix, target, [m])
+                        self._handle_event(Event(command, prefix, target, [m]))
+            else:
+                target = None
+
+                if command == &quot;quit&quot;:
+                    arguments = [arguments[0]]
+                elif command == &quot;ping&quot;:
+                    target = arguments[0]
+                else:
+                    target = arguments[0]
+                    arguments = arguments[1:]
+
+                if command == &quot;mode&quot;:
+                    if not is_channel(target):
+                        command = &quot;umode&quot;
+
+                # Translate numerics into more readable strings.
+                if numeric_events.has_key(command):
+                    command = numeric_events[command]
+
+                if DEBUG:
+                    print &quot;command: %s, source: %s, target: %s, arguments: %s&quot; % (
+                        command, prefix, target, arguments)
+                self._handle_event(Event(command, prefix, target, arguments))
+
+    def _handle_event(self, event):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+        self.irclibobj._handle_event(self, event)
+        if self.handlers.has_key(event.eventtype()):
+            for fn in self.handlers[event.eventtype()]:
+                fn(self, event)
+
+    def is_connected(self):
+        &quot;&quot;&quot;Return connection status.
+
+        Returns true if connected, otherwise false.
+        &quot;&quot;&quot;
+        return self.connected
+
+    def add_global_handler(self, *args):
+        &quot;&quot;&quot;Add global handler.
+
+        See documentation for IRC.add_global_handler.
+        &quot;&quot;&quot;
+        self.irclibobj.add_global_handler(*args)
+
+    def remove_global_handler(self, *args):
+        &quot;&quot;&quot;Remove global handler.
+
+        See documentation for IRC.remove_global_handler.
+        &quot;&quot;&quot;
+        self.irclibobj.remove_global_handler(*args)
+
+    def action(self, target, action):
+        &quot;&quot;&quot;Send a CTCP ACTION command.&quot;&quot;&quot;
+        self.ctcp(&quot;ACTION&quot;, target, action)
+
+    def admin(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send an ADMIN command.&quot;&quot;&quot;
+        self.send_raw(string.strip(string.join([&quot;ADMIN&quot;, server])))
+
+    def ctcp(self, ctcptype, target, parameter=&quot;&quot;):
+        &quot;&quot;&quot;Send a CTCP command.&quot;&quot;&quot;
+        ctcptype = string.upper(ctcptype)
+        self.privmsg(target, &quot;\001%s%s\001&quot; % (ctcptype, parameter and (&quot; &quot; + parameter) or &quot;&quot;))
+
+    def ctcp_reply(self, target, parameter):
+        &quot;&quot;&quot;Send a CTCP REPLY command.&quot;&quot;&quot;
+        self.notice(target, &quot;\001%s\001&quot; % parameter)
+
+    def disconnect(self, message=&quot;&quot;):
+        &quot;&quot;&quot;Hang up the connection.
+
+        Arguments:
+
+            message -- Quit message.
+        &quot;&quot;&quot;
+        if not self.connected:
+            return
+
+        self.irclibobj._remove_connection(self)
+        self.connected = 0
+        try:
+            self.socket.close()
+        except socket.error, x:
+            pass
+        self.socket = None
+        self._handle_event(Event(&quot;disconnect&quot;, self.server, &quot;&quot;, [message]))
+
+    def globops(self, text):
+        &quot;&quot;&quot;Send a GLOBOPS command.&quot;&quot;&quot;
+        self.send_raw(&quot;GLOBOPS :&quot; + text)
+
+    def info(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send an INFO command.&quot;&quot;&quot;
+        self.send_raw(string.strip(string.join([&quot;INFO&quot;, server])))
+
+    def invite(self, nick, channel):
+        &quot;&quot;&quot;Send an INVITE command.&quot;&quot;&quot;
+        self.send_raw(string.strip(string.join([&quot;INVITE&quot;, nick, channel])))
+
+    def ison(self, nicks):
+        &quot;&quot;&quot;Send an ISON command.
+
+        Arguments:
+
+            nicks -- List of nicks.
+        &quot;&quot;&quot;
+        self.send_raw(&quot;ISON &quot; + string.join(nicks, &quot; &quot;))
+
+    def leave(self, channel, key=&quot;&quot;):
+        &quot;&quot;&quot;Send a LEAVE command.&quot;&quot;&quot;
+        self.send_raw(&quot;PART %s%s&quot; % (channel, (key and (&quot; &quot; + key))))
+
+    def join(self, channel, key=&quot;&quot;):
+        &quot;&quot;&quot;Send a JOIN command.&quot;&quot;&quot;
+        self.send_raw(&quot;JOIN %s%s&quot; % (channel, (key and (&quot; &quot; + key))))
+
+    def kick(self, channel, nick, comment=&quot;&quot;):
+        &quot;&quot;&quot;Send a KICK command.&quot;&quot;&quot;
+        self.send_raw(&quot;KICK %s %s%s&quot; % (channel, nick, (comment and (&quot; :&quot; + comment))))
+
+    def links(self, remote_server=&quot;&quot;, server_mask=&quot;&quot;):
+        &quot;&quot;&quot;Send a LINKS command.&quot;&quot;&quot;
+        command = &quot;LINKS&quot;
+        if remote_server:
+            command = command + &quot; &quot; + remote_server
+        if server_mask:
+            command = command + &quot; &quot; + server_mask
+        self.send_raw(command)
+
+    def list(self, channels=None, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a LIST command.&quot;&quot;&quot;
+        command = &quot;LIST&quot;
+        if channels:
+            command = command + &quot; &quot; + string.join(channels, &quot;,&quot;)
+        if server:
+            command = command + &quot; &quot; + server
+        self.send_raw(command)
+
+    def lusers(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a LUSERS command.&quot;&quot;&quot;
+        self.send_raw(&quot;LUSERS&quot; + (server and (&quot; &quot; + server)))
+
+    def mode(self, target, command):
+        &quot;&quot;&quot;Send a MODE command.&quot;&quot;&quot;
+        self.send_raw(&quot;MODE %s %s&quot; % (target, command))
+
+    def motd(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send an MOTD command.&quot;&quot;&quot;
+        self.send_raw(&quot;MOTD&quot; + (server and (&quot; &quot; + server)))
+
+    def names(self, channels=None):
+        &quot;&quot;&quot;Send a NAMES command.&quot;&quot;&quot;
+        self.send_raw(&quot;NAMES&quot; + (channels and (&quot; &quot; + string.join(channels, &quot;,&quot;)) or &quot;&quot;))
+
+    def nick(self, newnick):
+        &quot;&quot;&quot;Send a NICK command.&quot;&quot;&quot;
+        self.send_raw(&quot;NICK &quot; + newnick)
+
+    def notice(self, target, text):
+        &quot;&quot;&quot;Send a NOTICE command.&quot;&quot;&quot;
+        # Should limit len(text) here!
+        self.send_raw(&quot;NOTICE %s :%s&quot; % (target, text))
+
+    def oper(self, nick, password):
+        &quot;&quot;&quot;Send an OPER command.&quot;&quot;&quot;
+        self.send_raw(&quot;OPER %s %s&quot; % (nick, password))
+
+    def part(self, channels):
+        &quot;&quot;&quot;Send a PART command.&quot;&quot;&quot;
+        if type(channels) == types.StringType:
+            self.send_raw(&quot;PART &quot; + channels)
+        else:
+            self.send_raw(&quot;PART &quot; + string.join(channels, &quot;,&quot;))
+
+    def pass_(self, password):
+        &quot;&quot;&quot;Send a PASS command.&quot;&quot;&quot;
+        self.send_raw(&quot;PASS &quot; + password)
+
+    def ping(self, target, target2=&quot;&quot;):
+        &quot;&quot;&quot;Send a PING command.&quot;&quot;&quot;
+        self.send_raw(&quot;PING %s%s&quot; % (target, target2 and (&quot; &quot; + target2)))
+
+    def pong(self, target, target2=&quot;&quot;):
+        &quot;&quot;&quot;Send a PONG command.&quot;&quot;&quot;
+        self.send_raw(&quot;PONG %s%s&quot; % (target, target2 and (&quot; &quot; + target2)))
+
+    def privmsg(self, target, text):
+        &quot;&quot;&quot;Send a PRIVMSG command.&quot;&quot;&quot;
+        # Should limit len(text) here!
+        self.send_raw(&quot;PRIVMSG %s :%s&quot; % (target, text))
+
+    def privmsg_many(self, targets, text):
+        &quot;&quot;&quot;Send a PRIVMSG command to multiple targets.&quot;&quot;&quot;
+        # Should limit len(text) here!
+        self.send_raw(&quot;PRIVMSG %s :%s&quot; % (string.join(targets, &quot;,&quot;), text))
+
+    def quit(self, message=&quot;&quot;):
+        &quot;&quot;&quot;Send a QUIT command.&quot;&quot;&quot;
+        # Note that many IRC servers don't use your QUIT message
+        # unless you've been connected for at least 5 minutes!
+        self.send_raw(&quot;QUIT&quot; + (message and (&quot; :&quot; + message)))
+
+    def sconnect(self, target, port=&quot;&quot;, server=&quot;&quot;):
+        &quot;&quot;&quot;Send an SCONNECT command.&quot;&quot;&quot;
+        self.send_raw(&quot;CONNECT %s%s%s&quot; % (target,
+                                          port and (&quot; &quot; + port),
+                                          server and (&quot; &quot; + server)))
+
+    def send_raw(self, string):
+        &quot;&quot;&quot;Send raw string to the server.
+
+        The string will be padded with appropriate CR LF.
+        &quot;&quot;&quot;
+        if self.socket is None:
+            raise ServerNotConnectedError, &quot;Not connected.&quot;
+        try:
+            self.socket.send(string + &quot;\r\n&quot;)
+            if DEBUG:
+                print &quot;TO SERVER:&quot;, string
+        except socket.error, x:
+            # Ouch!
+            self.disconnect(&quot;Connection reset by peer.&quot;)
+
+    def squit(self, server, comment=&quot;&quot;):
+        &quot;&quot;&quot;Send an SQUIT command.&quot;&quot;&quot;
+        self.send_raw(&quot;SQUIT %s%s&quot; % (server, comment and (&quot; :&quot; + comment)))
+
+    def stats(self, statstype, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a STATS command.&quot;&quot;&quot;
+        self.send_raw(&quot;STATS %s%s&quot; % (statstype, server and (&quot; &quot; + server)))
+
+    def time(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a TIME command.&quot;&quot;&quot;
+        self.send_raw(&quot;TIME&quot; + (server and (&quot; &quot; + server)))
+
+    def topic(self, channel, new_topic=None):
+        &quot;&quot;&quot;Send a TOPIC command.&quot;&quot;&quot;
+        if new_topic == None:
+            self.send_raw(&quot;TOPIC &quot; + channel)
+        else:
+            self.send_raw(&quot;TOPIC %s :%s&quot; % (channel, new_topic))
+
+    def trace(self, target=&quot;&quot;):
+        &quot;&quot;&quot;Send a TRACE command.&quot;&quot;&quot;
+        self.send_raw(&quot;TRACE&quot; + (target and (&quot; &quot; + target)))
+
+    def user(self, username, realname):
+        &quot;&quot;&quot;Send a USER command.&quot;&quot;&quot;
+        self.send_raw(&quot;USER %s 0 * :%s&quot; % (username, realname))
+
+    def userhost(self, nicks):
+        &quot;&quot;&quot;Send a USERHOST command.&quot;&quot;&quot;
+        self.send_raw(&quot;USERHOST &quot; + string.join(nicks, &quot;,&quot;))
+
+    def users(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a USERS command.&quot;&quot;&quot;
+        self.send_raw(&quot;USERS&quot; + (server and (&quot; &quot; + server)))
+
+    def version(self, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a VERSION command.&quot;&quot;&quot;
+        self.send_raw(&quot;VERSION&quot; + (server and (&quot; &quot; + server)))
+
+    def wallops(self, text):
+        &quot;&quot;&quot;Send a WALLOPS command.&quot;&quot;&quot;
+        self.send_raw(&quot;WALLOPS :&quot; + text)
+
+    def who(self, target=&quot;&quot;, op=&quot;&quot;):
+        &quot;&quot;&quot;Send a WHO command.&quot;&quot;&quot;
+        self.send_raw(&quot;WHO%s%s&quot; % (target and (&quot; &quot; + target), op and (&quot; o&quot;)))
+
+    def whois(self, targets):
+        &quot;&quot;&quot;Send a WHOIS command.&quot;&quot;&quot;
+        self.send_raw(&quot;WHOIS &quot; + string.join(targets, &quot;,&quot;))
+
+    def whowas(self, nick, max=&quot;&quot;, server=&quot;&quot;):
+        &quot;&quot;&quot;Send a WHOWAS command.&quot;&quot;&quot;
+        self.send_raw(&quot;WHOWAS %s%s%s&quot; % (nick,
+                                         max and (&quot; &quot; + max),
+                                         server and (&quot; &quot; + server)))
+
+
+class DCCConnectionError(IRCError):
+    pass
+
+
+class DCCConnection(Connection):
+    &quot;&quot;&quot;This class represents a DCC connection.
+
+    DCCConnection objects are instantiated by calling the dcc
+    method on an IRC object.
+    &quot;&quot;&quot;
+    def __init__(self, irclibobj, dcctype):
+        Connection.__init__(self, irclibobj)
+        self.connected = 0
+        self.passive = 0
+        self.dcctype = dcctype
+        self.peeraddress = None
+        self.peerport = None
+
+    def connect(self, address, port):
+        &quot;&quot;&quot;Connect/reconnect to a DCC peer.
+
+        Arguments:
+            address -- Host/IP address of the peer.
+
+            port -- The port number to connect to.
+
+        Returns the DCCConnection object.
+        &quot;&quot;&quot;
+        self.peeraddress = socket.gethostbyname(address)
+        self.peerport = port
+        self.socket = None
+        self.previous_buffer = &quot;&quot;
+        self.handlers = {}
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.passive = 0
+        try:
+            self.socket.connect((self.peeraddress, self.peerport))
+        except socket.error, x:
+            raise DCCConnectionError, &quot;Couldn't connect to socket: %s&quot; % x
+        self.connected = 1
+        if self.irclibobj.fn_to_add_socket:
+            self.irclibobj.fn_to_add_socket(self.socket)
+        return self
+
+    def listen(self):
+        &quot;&quot;&quot;Wait for a connection/reconnection from a DCC peer.
+
+        Returns the DCCConnection object.
+
+        The local IP address and port are available as
+        self.localaddress and self.localport.  After connection from a
+        peer, the peer address and port are available as
+        self.peeraddress and self.peerport.
+        &quot;&quot;&quot;
+        self.previous_buffer = &quot;&quot;
+        self.handlers = {}
+        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.passive = 1
+        try:
+            self.socket.bind((socket.gethostbyname(socket.gethostname()), 0))
+            self.localaddress, self.localport = self.socket.getsockname()
+            self.socket.listen(10)
+        except socket.error, x:
+            raise DCCConnectionError, &quot;Couldn't bind socket: %s&quot; % x
+        return self
+
+    def disconnect(self, message=&quot;&quot;):
+        &quot;&quot;&quot;Hang up the connection and close the object.
+
+        Arguments:
+
+            message -- Quit message.
+        &quot;&quot;&quot;
+        if not self.connected:
+            return
+
+        self.connected = 0
+        try:
+            self.socket.close()
+        except socket.error, x:
+            pass
+        self.socket = None
+        self.irclibobj._handle_event(
+            self,
+            Event(&quot;dcc_disconnect&quot;, self.peeraddress, &quot;&quot;, [message]))
+        self.irclibobj._remove_connection(self)
+
+    def process_data(self):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+
+        if self.passive and not self.connected:
+            conn, (self.peeraddress, self.peerport) = self.socket.accept()
+            self.socket.close()
+            self.socket = conn
+            self.connected = 1
+            if DEBUG:
+                print &quot;DCC connection from %s:%d&quot; % (
+                    self.peeraddress, self.peerport)
+            self.irclibobj._handle_event(
+                self,
+                Event(&quot;dcc_connect&quot;, self.peeraddress, None, None))
+            return
+
+        try:
+            new_data = self.socket.recv(2**14)
+        except socket.error, x:
+            # The server hung up.
+            self.disconnect(&quot;Connection reset by peer&quot;)
+            return
+        if not new_data:
+            # Read nothing: connection must be down.
+            self.disconnect(&quot;Connection reset by peer&quot;)
+            return
+
+        if self.dcctype == &quot;chat&quot;:
+            # The specification says lines are terminated with LF, but
+            # it seems safer to handle CR LF terminations too.
+            chunks = _linesep_regexp.split(self.previous_buffer + new_data)
+
+            # Save the last, unfinished line.
+            self.previous_buffer = chunks[-1]
+            if len(self.previous_buffer) &gt; 2**14:
+                # Bad peer! Naughty peer!
+                self.disconnect()
+                return
+            chunks = chunks[:-1]
+        else:
+            chunks = [new_data]
+
+        command = &quot;dccmsg&quot;
+        prefix = self.peeraddress
+        target = None
+        for chunk in chunks:
+            if DEBUG:
+                print &quot;FROM PEER:&quot;, chunk
+            arguments = [chunk]
+            if DEBUG:
+                print &quot;command: %s, source: %s, target: %s, arguments: %s&quot; % (
+                    command, prefix, target, arguments)
+            self.irclibobj._handle_event(
+                self,
+                Event(command, prefix, target, arguments))
+
+    def _get_socket(self):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+        return self.socket
+
+    def privmsg(self, string):
+        &quot;&quot;&quot;Send data to DCC peer.
+
+        The string will be padded with appropriate LF if it's a DCC
+        CHAT session.
+        &quot;&quot;&quot;
+        try:
+            self.socket.send(string)
+            if self.dcctype == &quot;chat&quot;:
+                self.socket.send(&quot;\n&quot;)
+            if DEBUG:
+                print &quot;TO PEER: %s\n&quot; % string
+        except socket.error, x:
+            # Ouch!
+            self.disconnect(&quot;Connection reset by peer.&quot;)
+
+class SimpleIRCClient:
+    &quot;&quot;&quot;A simple single-server IRC client class.
+
+    This is an example of an object-oriented wrapper of the IRC
+    framework.  A real IRC client can be made by subclassing this
+    class and adding appropriate methods.
+
+    The method on_join will be called when a &quot;join&quot; event is created
+    (which is done when the server sends a JOIN messsage/command),
+    on_privmsg will be called for &quot;privmsg&quot; events, and so on.  The
+    handler methods get two arguments: the connection object (same as
+    self.connection) and the event object.
+
+    Instance attributes that can be used by sub classes:
+
+        ircobj -- The IRC instance.
+
+        connection -- The ServerConnection instance.
+
+        dcc_connections -- A list of DCCConnection instances.
+    &quot;&quot;&quot;
+    def __init__(self):
+        self.ircobj = IRC()
+        self.connection = self.ircobj.server()
+        self.dcc_connections = []
+        self.ircobj.add_global_handler(&quot;all_events&quot;, self._dispatcher, -10)
+        self.ircobj.add_global_handler(&quot;dcc_disconnect&quot;, self._dcc_disconnect, -10)
+
+    def _dispatcher(self, c, e):
+        &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+        m = &quot;on_&quot; + e.eventtype()
+        if hasattr(self, m):
+            getattr(self, m)(c, e)
+
+    def _dcc_disconnect(self, c, e):
+        self.dcc_connections.remove(c)
+
+    def connect(self, server, port, nickname, password=None, username=None,
+                ircname=None, localaddress=&quot;&quot;, localport=0):
+        &quot;&quot;&quot;Connect/reconnect to a server.
+
+        Arguments:
+
+            server -- Server name.
+
+            port -- Port number.
+
+            nickname -- The nickname.
+
+            password -- Password (if any).
+
+            username -- The username.
+
+            ircname -- The IRC name.
+
+            localaddress -- Bind the connection to a specific local IP address.
+
+            localport -- Bind the connection to a specific local port.
+
+        This function can be called to reconnect a closed connection.
+        &quot;&quot;&quot;
+        self.connection.connect(server, port, nickname,
+                                password, username, ircname,
+                                localaddress, localport)
+
+    def dcc_connect(self, address, port, dcctype=&quot;chat&quot;):
+        &quot;&quot;&quot;Connect to a DCC peer.
+
+        Arguments:
+
+            address -- IP address of the peer.
+
+            port -- Port to connect to.
+
+        Returns a DCCConnection instance.
+        &quot;&quot;&quot;
+        dcc = self.ircobj.dcc(dcctype)
+        self.dcc_connections.append(dcc)
+        dcc.connect(address, port)
+        return dcc
+
+    def dcc_listen(self, dcctype=&quot;chat&quot;):
+        &quot;&quot;&quot;Listen for connections from a DCC peer.
+
+        Returns a DCCConnection instance.
+        &quot;&quot;&quot;
+        dcc = self.ircobj.dcc(dcctype)
+        self.dcc_connections.append(dcc)
+        dcc.listen()
+        return dcc
+
+    def start(self):
+        &quot;&quot;&quot;Start the IRC client.&quot;&quot;&quot;
+        self.ircobj.process_forever()
+
+
+class Event:
+    &quot;&quot;&quot;Class representing an IRC event.&quot;&quot;&quot;
+    def __init__(self, eventtype, source, target, arguments=None):
+        &quot;&quot;&quot;Constructor of Event objects.
+
+        Arguments:
+
+            eventtype -- A string describing the event.
+
+            source -- The originator of the event (a nick mask or a server). XXX Correct?
+
+            target -- The target of the event (a nick or a channel). XXX Correct?
+
+            arguments -- Any event specific arguments.
+        &quot;&quot;&quot;
+        self._eventtype = eventtype
+        self._source = source
+        self._target = target
+        if arguments:
+            self._arguments = arguments
+        else:
+            self._arguments = []
+
+    def eventtype(self):
+        &quot;&quot;&quot;Get the event type.&quot;&quot;&quot;
+        return self._eventtype
+
+    def source(self):
+        &quot;&quot;&quot;Get the event source.&quot;&quot;&quot;
+        return self._source
+
+    def target(self):
+        &quot;&quot;&quot;Get the event target.&quot;&quot;&quot;
+        return self._target
+
+    def arguments(self):
+        &quot;&quot;&quot;Get the event arguments.&quot;&quot;&quot;
+        return self._arguments
+
+_LOW_LEVEL_QUOTE = &quot;\020&quot;
+_CTCP_LEVEL_QUOTE = &quot;\134&quot;
+_CTCP_DELIMITER = &quot;\001&quot;
+
+_low_level_mapping = {
+    &quot;0&quot;: &quot;\000&quot;,
+    &quot;n&quot;: &quot;\n&quot;,
+    &quot;r&quot;: &quot;\r&quot;,
+    _LOW_LEVEL_QUOTE: _LOW_LEVEL_QUOTE
+}
+
+_low_level_regexp = re.compile(_LOW_LEVEL_QUOTE + &quot;(.)&quot;)
+
+def mask_matches(nick, mask):
+    &quot;&quot;&quot;Check if a nick matches a mask.
+
+    Returns true if the nick matches, otherwise false.
+    &quot;&quot;&quot;
+    nick = irc_lower(nick)
+    mask = irc_lower(mask)
+    mask = string.replace(mask, &quot;\\&quot;, &quot;\\\\&quot;)
+    for ch in &quot;.$|[](){}+&quot;:
+        mask = string.replace(mask, ch, &quot;\\&quot; + ch)
+    mask = string.replace(mask, &quot;?&quot;, &quot;.&quot;)
+    mask = string.replace(mask, &quot;*&quot;, &quot;.*&quot;)
+    r = re.compile(mask, re.IGNORECASE)
+    return r.match(nick)
+
+_alpha = &quot;abcdefghijklmnopqrstuvwxyz&quot;
+_special = &quot;-[]\\`^{}&quot;
+nick_characters = _alpha + string.upper(_alpha) + string.digits + _special
+_ircstring_translation = string.maketrans(string.upper(_alpha) + &quot;[]\\^&quot;,
+                                          _alpha + &quot;{}|~&quot;)
+
+def irc_lower(s):
+    &quot;&quot;&quot;Returns a lowercased string.
+
+    The definition of lowercased comes from the IRC specification (RFC
+    1459).
+    &quot;&quot;&quot;
+    return string.translate(s, _ircstring_translation)
+
+def _ctcp_dequote(message):
+    &quot;&quot;&quot;[Internal] Dequote a message according to CTCP specifications.
+
+    The function returns a list where each element can be either a
+    string (normal message) or a tuple of one or two strings (tagged
+    messages).  If a tuple has only one element (ie is a singleton),
+    that element is the tag; otherwise the tuple has two elements: the
+    tag and the data.
+
+    Arguments:
+
+        message -- The message to be decoded.
+    &quot;&quot;&quot;
+
+    def _low_level_replace(match_obj):
+        ch = match_obj.group(1)
+
+        # If low_level_mapping doesn't have the character as key, we
+        # should just return the character.
+        return _low_level_mapping.get(ch, ch)
+
+    if _LOW_LEVEL_QUOTE in message:
+        # Yup, there was a quote.  Release the dequoter, man!
+        message = _low_level_regexp.sub(_low_level_replace, message)
+
+    if _CTCP_DELIMITER not in message:
+        return [message]
+    else:
+        # Split it into parts.  (Does any IRC client actually *use*
+        # CTCP stacking like this?)
+        chunks = string.split(message, _CTCP_DELIMITER)
+
+        messages = []
+        i = 0
+        while i &lt; len(chunks)-1:
+            # Add message if it's non-empty.
+            if len(chunks[i]) &gt; 0:
+                messages.append(chunks[i])
+
+            if i &lt; len(chunks)-2:
+                # Aye!  CTCP tagged data ahead!
+                messages.append(tuple(string.split(chunks[i+1], &quot; &quot;, 1)))
+
+            i = i + 2
+
+        if len(chunks) % 2 == 0:
+            # Hey, a lonely _CTCP_DELIMITER at the end!  This means
+            # that the last chunk, including the delimiter, is a
+            # normal message!  (This is according to the CTCP
+            # specification.)
+            messages.append(_CTCP_DELIMITER + chunks[-1])
+
+        return messages
+
+def is_channel(string):
+    &quot;&quot;&quot;Check if a string is a channel name.
+
+    Returns true if the argument is a channel name, otherwise false.
+    &quot;&quot;&quot;
+    return string and string[0] in &quot;#&amp;+!&quot;
+
+def ip_numstr_to_quad(num):
+    &quot;&quot;&quot;Convert an IP number as an integer given in ASCII
+    representation (e.g. '3232235521') to an IP address string
+    (e.g. '192.168.0.1').&quot;&quot;&quot;
+    n = long(num)
+    p = map(str, map(int, [n &gt;&gt; 24 &amp; 0xFF, n &gt;&gt; 16 &amp; 0xFF,
+                           n &gt;&gt; 8 &amp; 0xFF, n &amp; 0xFF]))
+    return string.join(p, &quot;.&quot;)
+
+def ip_quad_to_numstr(quad):
+    &quot;&quot;&quot;Convert an IP address string (e.g. '192.168.0.1') to an IP
+    number as an integer given in ASCII representation
+    (e.g. '3232235521').&quot;&quot;&quot;
+    p = map(long, string.split(quad, &quot;.&quot;))
+    s = str((p[0] &lt;&lt; 24) | (p[1] &lt;&lt; 16) | (p[2] &lt;&lt; 8) | p[3])
+    if s[-1] == &quot;L&quot;:
+        s = s[:-1]
+    return s
+
+def nm_to_n(s):
+    &quot;&quot;&quot;Get the nick part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    &quot;&quot;&quot;
+    return string.split(s, &quot;!&quot;)[0]
+
+def nm_to_uh(s):
+    &quot;&quot;&quot;Get the userhost part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    &quot;&quot;&quot;
+    return string.split(s, &quot;!&quot;)[1]
+
+def nm_to_h(s):
+    &quot;&quot;&quot;Get the host part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    &quot;&quot;&quot;
+    return string.split(s, &quot;@&quot;)[1]
+
+def nm_to_u(s):
+    &quot;&quot;&quot;Get the user part of a nickmask.
+
+    (The source of an Event is a nickmask.)
+    &quot;&quot;&quot;
+    s = string.split(s, &quot;!&quot;)[1]
+    return string.split(s, &quot;@&quot;)[0]
+
+def parse_nick_modes(mode_string):
+    &quot;&quot;&quot;Parse a nick mode string.
+
+    The function returns a list of lists with three members: sign,
+    mode and argument.  The sign is \&quot;+\&quot; or \&quot;-\&quot;.  The argument is
+    always None.
+
+    Example:
+
+    &gt;&gt;&gt; irclib.parse_nick_modes(\&quot;+ab-c\&quot;)
+    [['+', 'a', None], ['+', 'b', None], ['-', 'c', None]]
+    &quot;&quot;&quot;
+
+    return _parse_modes(mode_string, &quot;&quot;)
+
+def parse_channel_modes(mode_string):
+    &quot;&quot;&quot;Parse a channel mode string.
+
+    The function returns a list of lists with three members: sign,
+    mode and argument.  The sign is \&quot;+\&quot; or \&quot;-\&quot;.  The argument is
+    None if mode isn't one of \&quot;b\&quot;, \&quot;k\&quot;, \&quot;l\&quot;, \&quot;v\&quot; or \&quot;o\&quot;.
+
+    Example:
+
+    &gt;&gt;&gt; irclib.parse_channel_modes(\&quot;+ab-c foo\&quot;)
+    [['+', 'a', None], ['+', 'b', 'foo'], ['-', 'c', None]]
+    &quot;&quot;&quot;
+
+    return _parse_modes(mode_string, &quot;bklvo&quot;)
+
+def _parse_modes(mode_string, unary_modes=&quot;&quot;):
+    &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+    modes = []
+    arg_count = 0
+
+    # State variable.
+    sign = &quot;&quot;
+
+    a = string.split(mode_string)
+    if len(a) == 0:
+        return []
+    else:
+        mode_part, args = a[0], a[1:]
+
+    if mode_part[0] not in &quot;+-&quot;:
+        return []
+    for ch in mode_part:
+        if ch in &quot;+-&quot;:
+            sign = ch
+        elif ch == &quot; &quot;:
+            collecting_arguments = 1
+        elif ch in unary_modes:
+            if len(args) &gt;= arg_count + 1:
+                modes.append([sign, ch, args[arg_count]])
+                arg_count = arg_count + 1
+            else:
+                modes.append([sign, ch, None])
+        else:
+            modes.append([sign, ch, None])
+    return modes
+
+def _ping_ponger(connection, event):
+    &quot;&quot;&quot;[Internal]&quot;&quot;&quot;
+    connection.pong(event.target())
+
+# Numeric table mostly stolen from the Perl IRC module (Net::IRC).
+numeric_events = {
+    &quot;001&quot;: &quot;welcome&quot;,
+    &quot;002&quot;: &quot;yourhost&quot;,
+    &quot;003&quot;: &quot;created&quot;,
+    &quot;004&quot;: &quot;myinfo&quot;,
+    &quot;005&quot;: &quot;featurelist&quot;,  # XXX
+    &quot;200&quot;: &quot;tracelink&quot;,
+    &quot;201&quot;: &quot;traceconnecting&quot;,
+    &quot;202&quot;: &quot;tracehandshake&quot;,
+    &quot;203&quot;: &quot;traceunknown&quot;,
+    &quot;204&quot;: &quot;traceoperator&quot;,
+    &quot;205&quot;: &quot;traceuser&quot;,
+    &quot;206&quot;: &quot;traceserver&quot;,
+    &quot;207&quot;: &quot;traceservice&quot;,
+    &quot;208&quot;: &quot;tracenewtype&quot;,
+    &quot;209&quot;: &quot;traceclass&quot;,
+    &quot;210&quot;: &quot;tracereconnect&quot;,
+    &quot;211&quot;: &quot;statslinkinfo&quot;,
+    &quot;212&quot;: &quot;statscommands&quot;,
+    &quot;213&quot;: &quot;statscline&quot;,
+    &quot;214&quot;: &quot;statsnline&quot;,
+    &quot;215&quot;: &quot;statsiline&quot;,
+    &quot;216&quot;: &quot;statskline&quot;,
+    &quot;217&quot;: &quot;statsqline&quot;,
+    &quot;218&quot;: &quot;statsyline&quot;,
+    &quot;219&quot;: &quot;endofstats&quot;,
+    &quot;221&quot;: &quot;umodeis&quot;,
+    &quot;231&quot;: &quot;serviceinfo&quot;,
+    &quot;232&quot;: &quot;endofservices&quot;,
+    &quot;233&quot;: &quot;service&quot;,
+    &quot;234&quot;: &quot;servlist&quot;,
+    &quot;235&quot;: &quot;servlistend&quot;,
+    &quot;241&quot;: &quot;statslline&quot;,
+    &quot;242&quot;: &quot;statsuptime&quot;,
+    &quot;243&quot;: &quot;statsoline&quot;,
+    &quot;244&quot;: &quot;statshline&quot;,
+    &quot;250&quot;: &quot;luserconns&quot;,
+    &quot;251&quot;: &quot;luserclient&quot;,
+    &quot;252&quot;: &quot;luserop&quot;,
+    &quot;253&quot;: &quot;luserunknown&quot;,
+    &quot;254&quot;: &quot;luserchannels&quot;,
+    &quot;255&quot;: &quot;luserme&quot;,
+    &quot;256&quot;: &quot;adminme&quot;,
+    &quot;257&quot;: &quot;adminloc1&quot;,
+    &quot;258&quot;: &quot;adminloc2&quot;,
+    &quot;259&quot;: &quot;adminemail&quot;,
+    &quot;261&quot;: &quot;tracelog&quot;,
+    &quot;262&quot;: &quot;endoftrace&quot;,
+    &quot;263&quot;: &quot;tryagain&quot;,
+    &quot;265&quot;: &quot;n_local&quot;,
+    &quot;266&quot;: &quot;n_global&quot;,
+    &quot;300&quot;: &quot;none&quot;,
+    &quot;301&quot;: &quot;away&quot;,
+    &quot;302&quot;: &quot;userhost&quot;,
+    &quot;303&quot;: &quot;ison&quot;,
+    &quot;305&quot;: &quot;unaway&quot;,
+    &quot;306&quot;: &quot;nowaway&quot;,
+    &quot;311&quot;: &quot;whoisuser&quot;,
+    &quot;312&quot;: &quot;whoisserver&quot;,
+    &quot;313&quot;: &quot;whoisoperator&quot;,
+    &quot;314&quot;: &quot;whowasuser&quot;,
+    &quot;315&quot;: &quot;endofwho&quot;,
+    &quot;316&quot;: &quot;whoischanop&quot;,
+    &quot;317&quot;: &quot;whoisidle&quot;,
+    &quot;318&quot;: &quot;endofwhois&quot;,
+    &quot;319&quot;: &quot;whoischannels&quot;,
+    &quot;321&quot;: &quot;liststart&quot;,
+    &quot;322&quot;: &quot;list&quot;,
+    &quot;323&quot;: &quot;listend&quot;,
+    &quot;324&quot;: &quot;channelmodeis&quot;,
+    &quot;329&quot;: &quot;channelcreate&quot;,
+    &quot;331&quot;: &quot;notopic&quot;,
+    &quot;332&quot;: &quot;topic&quot;,
+    &quot;333&quot;: &quot;topicinfo&quot;,
+    &quot;341&quot;: &quot;inviting&quot;,
+    &quot;342&quot;: &quot;summoning&quot;,
+    &quot;346&quot;: &quot;invitelist&quot;,
+    &quot;347&quot;: &quot;endofinvitelist&quot;,
+    &quot;348&quot;: &quot;exceptlist&quot;,
+    &quot;349&quot;: &quot;endofexceptlist&quot;,
+    &quot;351&quot;: &quot;version&quot;,
+    &quot;352&quot;: &quot;whoreply&quot;,
+    &quot;353&quot;: &quot;namreply&quot;,
+    &quot;361&quot;: &quot;killdone&quot;,
+    &quot;362&quot;: &quot;closing&quot;,
+    &quot;363&quot;: &quot;closeend&quot;,
+    &quot;364&quot;: &quot;links&quot;,
+    &quot;365&quot;: &quot;endoflinks&quot;,
+    &quot;366&quot;: &quot;endofnames&quot;,
+    &quot;367&quot;: &quot;banlist&quot;,
+    &quot;368&quot;: &quot;endofbanlist&quot;,
+    &quot;369&quot;: &quot;endofwhowas&quot;,
+    &quot;371&quot;: &quot;info&quot;,
+    &quot;372&quot;: &quot;motd&quot;,
+    &quot;373&quot;: &quot;infostart&quot;,
+    &quot;374&quot;: &quot;endofinfo&quot;,
+    &quot;375&quot;: &quot;motdstart&quot;,
+    &quot;376&quot;: &quot;endofmotd&quot;,
+    &quot;377&quot;: &quot;motd2&quot;,        # 1997-10-16 -- tkil
+    &quot;381&quot;: &quot;youreoper&quot;,
+    &quot;382&quot;: &quot;rehashing&quot;,
+    &quot;384&quot;: &quot;myportis&quot;,
+    &quot;391&quot;: &quot;time&quot;,
+    &quot;392&quot;: &quot;usersstart&quot;,
+    &quot;393&quot;: &quot;users&quot;,
+    &quot;394&quot;: &quot;endofusers&quot;,
+    &quot;395&quot;: &quot;nousers&quot;,
+    &quot;401&quot;: &quot;nosuchnick&quot;,
+    &quot;402&quot;: &quot;nosuchserver&quot;,
+    &quot;403&quot;: &quot;nosuchchannel&quot;,
+    &quot;404&quot;: &quot;cannotsendtochan&quot;,
+    &quot;405&quot;: &quot;toomanychannels&quot;,
+    &quot;406&quot;: &quot;wasnosuchnick&quot;,
+    &quot;407&quot;: &quot;toomanytargets&quot;,
+    &quot;409&quot;: &quot;noorigin&quot;,
+    &quot;411&quot;: &quot;norecipient&quot;,
+    &quot;412&quot;: &quot;notexttosend&quot;,
+    &quot;413&quot;: &quot;notoplevel&quot;,
+    &quot;414&quot;: &quot;wildtoplevel&quot;,
+    &quot;421&quot;: &quot;unknowncommand&quot;,
+    &quot;422&quot;: &quot;nomotd&quot;,
+    &quot;423&quot;: &quot;noadmininfo&quot;,
+    &quot;424&quot;: &quot;fileerror&quot;,
+    &quot;431&quot;: &quot;nonicknamegiven&quot;,
+    &quot;432&quot;: &quot;erroneusnickname&quot;, # Thiss iz how its speld in thee RFC.
+    &quot;433&quot;: &quot;nicknameinuse&quot;,
+    &quot;436&quot;: &quot;nickcollision&quot;,
+    &quot;437&quot;: &quot;unavailresource&quot;,  # &quot;Nick temporally unavailable&quot;
+    &quot;441&quot;: &quot;usernotinchannel&quot;,
+    &quot;442&quot;: &quot;notonchannel&quot;,
+    &quot;443&quot;: &quot;useronchannel&quot;,
+    &quot;444&quot;: &quot;nologin&quot;,
+    &quot;445&quot;: &quot;summondisabled&quot;,
+    &quot;446&quot;: &quot;usersdisabled&quot;,
+    &quot;451&quot;: &quot;notregistered&quot;,
+    &quot;461&quot;: &quot;needmoreparams&quot;,
+    &quot;462&quot;: &quot;alreadyregistered&quot;,
+    &quot;463&quot;: &quot;nopermforhost&quot;,
+    &quot;464&quot;: &quot;passwdmismatch&quot;,
+    &quot;465&quot;: &quot;yourebannedcreep&quot;, # I love this one...
+    &quot;466&quot;: &quot;youwillbebanned&quot;,
+    &quot;467&quot;: &quot;keyset&quot;,
+    &quot;471&quot;: &quot;channelisfull&quot;,
+    &quot;472&quot;: &quot;unknownmode&quot;,
+    &quot;473&quot;: &quot;inviteonlychan&quot;,
+    &quot;474&quot;: &quot;bannedfromchan&quot;,
+    &quot;475&quot;: &quot;badchannelkey&quot;,
+    &quot;476&quot;: &quot;badchanmask&quot;,
+    &quot;477&quot;: &quot;nochanmodes&quot;,  # &quot;Channel doesn't support modes&quot;
+    &quot;478&quot;: &quot;banlistfull&quot;,
+    &quot;481&quot;: &quot;noprivileges&quot;,
+    &quot;482&quot;: &quot;chanoprivsneeded&quot;,
+    &quot;483&quot;: &quot;cantkillserver&quot;,
+    &quot;484&quot;: &quot;restricted&quot;,   # Connection is restricted
+    &quot;485&quot;: &quot;uniqopprivsneeded&quot;,
+    &quot;491&quot;: &quot;nooperhost&quot;,
+    &quot;492&quot;: &quot;noservicehost&quot;,
+    &quot;501&quot;: &quot;umodeunknownflag&quot;,
+    &quot;502&quot;: &quot;usersdontmatch&quot;,
+}
+
+generated_events = [
+    # Generated events
+    &quot;dcc_connect&quot;,
+    &quot;dcc_disconnect&quot;,
+    &quot;dccmsg&quot;,
+    &quot;disconnect&quot;,
+    &quot;ctcp&quot;,
+    &quot;ctcpreply&quot;,
+]
+
+protocol_events = [
+    # IRC protocol events
+    &quot;error&quot;,
+    &quot;join&quot;,
+    &quot;kick&quot;,
+    &quot;mode&quot;,
+    &quot;part&quot;,
+    &quot;ping&quot;,
+    &quot;privmsg&quot;,
+    &quot;privnotice&quot;,
+    &quot;pubmsg&quot;,
+    &quot;pubnotice&quot;,
+    &quot;quit&quot;,
+]
+
+all_events = generated_events + protocol_events + numeric_events.values()

Modified: poilu/trunk/pypoil.py
===================================================================
--- poilu/trunk/pypoil.py	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/pypoil.py	2005-09-09 01:49:04 UTC (rev 131)
@@ -7,23 +7,7 @@
 # Commandes priv&#233;es
 # -----------------
 #
-#   rime &lt;mot&gt;           : ajoute un mot au dictionnaire des rimes
-#   derime &lt;mot&gt;         : supprime un mot du dictinnaire des rimes
-#   dit #chan (...)      : fait parler le bot
-#   liste rimes &lt;mot&gt;    : liste toutes les rimes connues pour le nom donn&#233;
-#   recharge_muet        : recharge muet.txt
-#   recharge_terminaison : recharge terminaison.txt
-#   recharge_insult      : charge insulte.txt
-#   recharge_motcle      : charge motcle_regex.txt
-#   join #&lt;chan&gt;         : joindre le canal #&lt;chan&gt;
-#   backup               : sauve toutes les donn&#233;es sur le disque dur
-#   utf-8                : passe en UTF-8
-#   iso                  : passe en iso-xxx
-#   muet                 : liste des caract&#232;res muets
-#   taux_reponse         : affiche le taux de r&#233;ponse
-#   taux_reponse xx      : fixe le taux de r&#233;ponse (en pourcent), 0% : ne
-#                          r&#233;pond jamais, 100% r&#233;pond chaque fois qu'il trouve
-#                          une rime
+#  Tapez &quot;aide&quot; pour obtenir l'aide ;-) (ou voir la fonction aide ci-dessous)
 #
 # Commandes publiques 
 # -------------------
@@ -76,13 +60,13 @@
         self.echou(u&quot;- dit #chan (...)      : fait parler le bot&quot;)
         self.echou(u&quot;- recharge_muet        : recharge muet.txt&quot;)
         self.echou(u&quot;- recharge_terminaison : recharge terminaison.txt&quot;)
-        self.echou(u&quot;- recharge_insult      : charge insulte.txt&quot;)
-        self.echou(u&quot;- recharge_motcle      : charge motcle_regex.txt&quot;)
+        self.echou(u&quot;- recharge_dico        : recharge dico.txt&quot;)
+        self.echou(u&quot;- recharge_insult      : recharge insulte.txt&quot;)
+        self.echou(u&quot;- recharge_motcle      : recharge motcle_regex.txt&quot;)
         self.echou(u&quot;- join #chan / leave #chan : joint/quitte le canal #&lt;chan&gt;&quot;)
         self.echou(u&quot;- backup               : sauve toutes les donn&#233;es sur le disque dur&quot;)
         self.echou(u&quot;- utf-8 / iso          : passe en UTF-8 / iso-8859-1&quot;)
         self.echou(u&quot;- muet                 : liste des caract&#232;res muets&quot;)
-        self.echou(u&quot;- taux_reponse         : affiche le taux de r&#233;ponse&quot;)
         self.echou(u&quot;- taux_reponse xxx     : fixe le taux de r&#233;ponse (en pourcent)&quot;)
 
 
@@ -220,15 +204,11 @@
                 if taux&lt;0: taux=0
                 if 100&lt;taux: taux=100
                 self.taux_reponse = taux
-                self.echou(u&quot;Taux r&#233;ponse = %s&quot; % self.taux_reponse)
+                self.echou(u&quot;Taux r&#233;ponse = %s%%&quot; % self.taux_reponse)
                 return True
             except:
                 self.echou(u&quot;%s n'est pas un taux valide&quot; %(regs.group(1)))
             
-        if cmd==&quot;taux_reponse&quot;:
-            self.echo (&quot;Taux r&#233;ponse = %s&quot; %(self.taux_reponse) )
-            return True
-
         if cmd==&quot;muet&quot;:
             self.echou(self.dico.muet)
             return True
@@ -238,9 +218,16 @@
             self.dico.charge_muet()
             return True
             
+        if (cmd == &quot;recharge_dico&quot;):
+            self.echo(&quot;(recharge dico.txt)&quot;)
+            self.dico.charge_dico()
+            return True
+            
         if (cmd == &quot;recharge_terminaison&quot;):
-            self.echo(&quot;(recharge terminaison.txt)&quot;)
+            self.echo(&quot;(sauve dico, recharge terminaison.txt puis dico.txt)&quot;)
+            self.dico.sauve()
             self.dico.charge_regex()
+            self.dico.charge_dico()
             return True
             
         if (cmd == &quot;recharge_motcle&quot;):
@@ -308,6 +295,7 @@
     try:
         bot.start()
     except KeyboardInterrupt:
+        bot.dico.sauve()
         print &quot;Interrompu (CTRL+C).&quot;
 
 if __name__ == &quot;__main__&quot;:

Modified: poilu/trunk/terminaison.txt
===================================================================
--- poilu/trunk/terminaison.txt	2005-09-09 01:20:01 UTC (rev 130)
+++ poilu/trunk/terminaison.txt	2005-09-09 01:49:04 UTC (rev 131)
@@ -1,4 +1,6 @@
-r:(er(re)?|ier)$
+ied:(ied[s]?|sier)$
+ier:ier(re)?s?$
+r:(er(re)?|&#195;&#168;re)$
 or:(aur(es?)?|or[tes]?)$
 aite:(aite?|et(te)?s?|&#195;&#168;tes?)$
 ouin:(oin[g]?|ouin)$
@@ -6,7 +8,7 @@
 ien:ien[ts]?$
 a:(a[st]?|&#195;&#160;)$
 &#195;&#168;:(&#195;&#168;[ts]?|ai([ets]|ent)?|a&#195;&#175;)$
-&#195;&#169;:(ied[s]?|&#195;&#169;e?s?|ez)$
+er:(&#195;&#169;e?s?|ez|cd)$
 an:(en(s|ts?)?|an([dg]|ts?)?)$
 is:is$
 ou:(oo|ou[setx]?)$


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000036.html">[Happyboom-svn] r130 - poilu/trunk
</A></li>
	<LI>Next message: <A HREF="000038.html">[Happyboom-svn] r132 - poilu/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#37">[ date ]</a>
              <a href="thread.html#37">[ thread ]</a>
              <a href="subject.html#37">[ subject ]</a>
              <a href="author.html#37">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/happyboom-svn">More information about the Happyboom-svn
mailing list</a><br>
</body></html>
