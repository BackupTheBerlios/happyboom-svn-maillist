<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Happyboom-svn] r209 - in happyboom/trunk/happyboom: . client common net net/io net/io_tcp net/io_udp server specification
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/happyboom-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r209%20-%20in%20happyboom/trunk/happyboom%3A%20.%20client%20common%20net%20net/io%20net/io_tcp%20net/io_udp%20server%20specification&In-Reply-To=%3C200509192014.j8JKEjOe013109%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000115.html">
   <LINK REL="Next"  HREF="000116.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Happyboom-svn] r209 - in happyboom/trunk/happyboom: . client common net net/io net/io_tcp net/io_udp server specification</H1>
    <B>Victor STINNER at BerliOS</B> 
    <A HREF="mailto:happyboom-svn%40lists.berlios.de?Subject=Re%3A%20%5BHappyboom-svn%5D%20r209%20-%20in%20happyboom/trunk/happyboom%3A%20.%20client%20common%20net%20net/io%20net/io_tcp%20net/io_udp%20server%20specification&In-Reply-To=%3C200509192014.j8JKEjOe013109%40sheep.berlios.de%3E"
       TITLE="[Happyboom-svn] r209 - in happyboom/trunk/happyboom: . client common net net/io net/io_tcp net/io_udp server specification">haypo at berlios.de
       </A><BR>
    <I>Mon Sep 19 22:14:45 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000115.html">[Happyboom-svn] r208 - happyboom/trunk
</A></li>
        <LI>Next message: <A HREF="000116.html">[Happyboom-svn] r210 - in happyboom/trunk: . common
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#122">[ date ]</a>
              <a href="thread.html#122">[ thread ]</a>
              <a href="subject.html#122">[ subject ]</a>
              <a href="author.html#122">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: haypo
Date: 2005-09-19 22:14:42 +0200 (Mon, 19 Sep 2005)
New Revision: 209

Added:
   happyboom/trunk/happyboom/.project
   happyboom/trunk/happyboom/AUTHORS
   happyboom/trunk/happyboom/COPYING
   happyboom/trunk/happyboom/ChangeLog
   happyboom/trunk/happyboom/README
   happyboom/trunk/happyboom/TODO
   happyboom/trunk/happyboom/__init__.py
   happyboom/trunk/happyboom/client/
   happyboom/trunk/happyboom/client/__init__.py
   happyboom/trunk/happyboom/client/base_client.py
   happyboom/trunk/happyboom/common/
   happyboom/trunk/happyboom/common/__init__.py
   happyboom/trunk/happyboom/common/event.py
   happyboom/trunk/happyboom/common/file.py
   happyboom/trunk/happyboom/common/generic_event.py
   happyboom/trunk/happyboom/common/happyboom_protocol.py
   happyboom/trunk/happyboom/common/log.py
   happyboom/trunk/happyboom/common/packer.py
   happyboom/trunk/happyboom/common/presentation.py
   happyboom/trunk/happyboom/common/protocol.py
   happyboom/trunk/happyboom/common/thread.py
   happyboom/trunk/happyboom/makedoc.sh
   happyboom/trunk/happyboom/net/
   happyboom/trunk/happyboom/net/__init__.py
   happyboom/trunk/happyboom/net/io/
   happyboom/trunk/happyboom/net/io/__init__.py
   happyboom/trunk/happyboom/net/io/base_io.py
   happyboom/trunk/happyboom/net/io/io_client.py
   happyboom/trunk/happyboom/net/io/packet.py
   happyboom/trunk/happyboom/net/io_tcp/
   happyboom/trunk/happyboom/net/io_tcp/__init__.py
   happyboom/trunk/happyboom/net/io_tcp/server_waiter.py
   happyboom/trunk/happyboom/net/io_tcp/tcp.py
   happyboom/trunk/happyboom/net/io_tcp/tcp_client.py
   happyboom/trunk/happyboom/net/io_udp/
   happyboom/trunk/happyboom/net/io_udp/__init__.py
   happyboom/trunk/happyboom/net/io_udp/udp.py
   happyboom/trunk/happyboom/net/io_udp/udp_client.py
   happyboom/trunk/happyboom/net/io_udp/udp_ping.py
   happyboom/trunk/happyboom/net/net_buffer.py
   happyboom/trunk/happyboom/release.sh
   happyboom/trunk/happyboom/run.sh
   happyboom/trunk/happyboom/server/
   happyboom/trunk/happyboom/server/__init__.py
   happyboom/trunk/happyboom/server/agent.py
   happyboom/trunk/happyboom/server/base_server.py
   happyboom/trunk/happyboom/server/client.py
   happyboom/trunk/happyboom/server/client_manager.py
   happyboom/trunk/happyboom/server/gateway.py
   happyboom/trunk/happyboom/server/server_agent.py
   happyboom/trunk/happyboom/server/stat.py
   happyboom/trunk/happyboom/specification/
   happyboom/trunk/happyboom/specification/client.dia
   happyboom/trunk/happyboom/specification/server.dia
   happyboom/trunk/happyboom/specification/socket_at_server_side.dia
Log:
I try Subclipse ...

Added: happyboom/trunk/happyboom/.project
===================================================================
--- happyboom/trunk/happyboom/.project	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/.project	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,17 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;projectDescription&gt;
+	&lt;name&gt;happyboom&lt;/name&gt;
+	&lt;comment&gt;&lt;/comment&gt;
+	&lt;projects&gt;
+	&lt;/projects&gt;
+	&lt;buildSpec&gt;
+		&lt;buildCommand&gt;
+			&lt;name&gt;org.python.pydev.PyDevBuilder&lt;/name&gt;
+			&lt;arguments&gt;
+			&lt;/arguments&gt;
+		&lt;/buildCommand&gt;
+	&lt;/buildSpec&gt;
+	&lt;natures&gt;
+		&lt;nature&gt;org.python.pydev.pythonNature&lt;/nature&gt;
+	&lt;/natures&gt;
+&lt;/projectDescription&gt;

Added: happyboom/trunk/happyboom/AUTHORS
===================================================================
--- happyboom/trunk/happyboom/AUTHORS	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/AUTHORS	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,2 @@
+Victor STINNER &lt;victor.stinner AT haypocalc.com&gt;
+Damien BOUCARD &lt;damien.boucard AT tchoy.net&gt;
\ No newline at end of file

Added: happyboom/trunk/happyboom/COPYING
===================================================================
--- happyboom/trunk/happyboom/COPYING	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/COPYING	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The &quot;Program&quot;, below,
+refers to any such program or work, and a &quot;work based on the Program&quot;
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and &quot;any
+later version&quot;, you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the &quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the program's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: happyboom/trunk/happyboom/ChangeLog
===================================================================
--- happyboom/trunk/happyboom/ChangeLog	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/ChangeLog	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,48 @@
+2005-08-05
+	o Rewrite of the BoomBoom server (based on multi-agent-system)
+	o The server requires the PySMA library (see README)
+
+2005-08-03
+	o Rewrite of the BoomBoom client (based on event-system)
+	o The BoomBoom client source code is documented with Epydoc
+
+2005-08-02
+	o The 'net' package is documented with Epydoc
+
+2005-04-28
+	o Fix network client : use buffer to keep unfinished lines, and support
+	  wrong host name error
+	o Fix pygame : use pygame.quit() 
+	o BoomBoom have character, weapon and projectile
+
+2005-04-25
+	o Server client support socket error 11
+	o Split input, view and server into base and specific code (eg. hb_input -&gt;
+	  base_input and console_input)
+	o Write new game : BoomBoom which will first looks like old QBasic game
+	  &quot;gorilla&quot;
+
+2005-04-15
+	o Clients and server well support evil disconnection (eg. broken pipe)
+	o Add network stats (in/out bytes) in view module
+	o Add server stats (uptime, number of connections) and server network 
+	  stats (in/out bytes), which can be read by ServerStatAgent in view module
+	o Support command line options like max-fps, set host, set ports, 
+	  debug mode, etc.
+	o Server, view and input have verbose and debug mode (which active or not
+	  print functions)
+	o View register himself each role for each agent in server
+	o Server ask protocol version and name to view and input
+	o Server can send text messages (eg. &quot;Welcome to XXX client!&quot;)
+	o Add a chat agent :-D
+	
+2005-04-13 : First release
+	o Network server support multiple clients (four by default)
+	o Server don't need to wait clients anymore
+	o Send messages to a role instead of &quot;dest&quot;
+	o Agent have to say that it wants to get messages of a given role
+	o In the server, agents communicates together. For the example, a
+	  &quot;follow agent&quot; is written. It hear &quot;number&quot; role, and update
+	  slowly (+/- 1) its value.
+	o Agent &quot;AgentN&quot; can be reused : messages integrate agent ID
+	o TODO : Server should support client disconnexion

Added: happyboom/trunk/happyboom/README
===================================================================
--- happyboom/trunk/happyboom/README	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/README	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,16 @@
+HappyBoom
+=========
+
+HappyBoom is a game engine based on client-server architecture. The server is
+based ony multi-agents system.
+
+Website: <A HREF="http://www.happyboom.org/">http://www.happyboom.org/</A>
+
+Documentation
+=============
+
+You can generate the API documentation of HappyBoom which this command:
+    ./makedoc.sh
+
+Documentation will be generated in HTML in the subdirectory &quot;doc&quot;. You
+need Epydoc (version 2.1 or earlier, just tested 2.1).

Added: happyboom/trunk/happyboom/TODO
===================================================================
--- happyboom/trunk/happyboom/TODO	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/TODO	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,2 @@
+See our webpage to get the last todo list:
+   <A HREF="http://www.happyboom.org/HappyBoom#Todo">http://www.happyboom.org/HappyBoom#Todo</A>

Added: happyboom/trunk/happyboom/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/client/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/client/base_client.py
===================================================================
--- happyboom/trunk/happyboom/client/base_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/client/base_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,180 @@
+from happyboom.common.happyboom_protocol import HappyboomProtocol
+from happyboom.common.protocol import ProtocolException
+from happyboom.common.log import log
+from happyboom.common.event import EventLauncher, EventListener
+from happyboom.net.io.packet import Packet
+from happyboom.net.io_tcp.tcp import IO_TCP
+import struct, string, thread, imp, os.path, sys
+
+class Client(object, EventListener, EventLauncher):
+    &quot;&quot;&quot;
+    Base HappyBoom client.
+    @ivar __stopped: Stopped display client flag.
+    @type __stopped: C{bool}
+    @ivar __stoplock: Mutex for synchronizing __stopped.
+    @type __stoplock: C{thread.lock}
+    @ivar _io: Network input/output object using UDP protocole.
+    @type _io: C{net.io_udp.IO_UDP}
+    @ivar verbose: Verbose mode flag.
+    @type verbose: C{bool}
+    @ivar debug: Debug mode flag.
+    @type debug: C{bool}
+    &quot;&quot;&quot;
+    
+    def __init__(self, args):
+        EventListener.__init__(self)
+        EventLauncher.__init__(self)
+        self.host = args.get(&quot;host&quot;, &quot;127.0.0.1&quot;)
+        self.port = args.get(&quot;port&quot;, 12430)
+        self.verbose = args.get(&quot;verbose&quot;, False)
+        self.debug = args.get(&quot;debug&quot;, False)
+        protocol = args.get(&quot;protocol&quot;, None)
+        self._io = IO_TCP()
+        self._io.verbose = False # self.verbose
+        self._io.debug = False # self.debug
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        
+        self.signature = None
+        self.presentation = HappyboomProtocol(protocol, args)
+        self.gateway = Gateway(protocol, args)
+        self.registerEvent(&quot;happyboom&quot;)
+        
+    def evt_happyboom_stop(self):
+        self.stop()
+
+    def evt_happyboom_network(self, feature, event, *args):
+        self.launchEvent(&quot;happyboom&quot;, &quot;event&quot;, (self._io,), feature, event, args)
+
+    def start(self):
+        &quot;&quot;&quot; Starts the client : connection to the server, etc. &quot;&quot;&quot;
+        # Try to connect to server
+        if self.verbose: log.info(&quot;[HAPPYBOOM] Trying to connect to server %s:%u&quot; % (self.host, self.port))
+        self._io.on_connect = self.onConnect
+        self._io.on_connection_fails = self.onConnectionFails
+        self._io.on_disconnect = self.onDisconnect
+        self._io.on_new_packet = self.presentation.processPacket
+        self._io.on_lost_connection = self.onLostConnection
+        self._io.connect(self.host, self.port)
+        if not self._io.is_ready: return
+        thread.start_new_thread(self._io.run_thread, ())
+        
+    def stop(self):
+        &quot;&quot;&quot; Stops the display client : disconnection from the server, etc. &quot;&quot;&quot;
+        # Does not stop several times
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return False
+        self.__stopped = True
+        self.__stoplock.release()
+        
+        self._io.stop()
+        if self.verbose:
+            log.info(&quot;[HAPPYBOOM] Stopped&quot;)
+        return True
+        
+    def __isStopped(self):
+        self.__stoplock.acquire()
+        stop = self.__stopped
+        self.__stoplock.release()
+        return stop
+    stopped = property(__isStopped)
+    
+    def onConnect(self):
+        &quot;&quot;&quot; Handler called on network connection. &quot;&quot;&quot;
+        if self.verbose:
+            log.info(&quot;[HAPPYBOOM] Connected to server, send presentation connection().&quot;)
+        self.launchEvent(&quot;happyboom&quot;, &quot;connection&quot;, self._io)
+        
+    def onConnectionFails(self):
+        &quot;&quot;&quot; Handler called when network connection fails. &quot;&quot;&quot;
+        log.error(&quot;[HAPPYBOOM] Fail to connect to the server.&quot;)
+
+    def onDisconnect(self):
+        &quot;&quot;&quot; Handler called on network disconnection. &quot;&quot;&quot;
+        if self.stopped: return
+        log.info(&quot;[HAPPYBOOM] Connection to server closed&quot;)
+        self.launchEvent(&quot;happyboom&quot;, &quot;stop&quot;)
+
+    def onLostConnection(self):
+        &quot;&quot;&quot; Handler called on losting network connection. &quot;&quot;&quot;
+        log.warning(&quot;[HAPPYBOOM] Lost connection with server.&quot;)
+        self.launchEvent(&quot;happyboom&quot;, &quot;stop&quot;)
+        
+class Gateway(EventLauncher, EventListener):
+    def __init__(self, protocol, args):
+        EventLauncher.__init__(self)
+        EventListener.__init__(self, &quot;evt_&quot;)
+        self.protocol = protocol
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;connection&quot;, self.processConnection)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;disconnection&quot;, self.processDisconnection)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;create_item&quot;, self.processCreateItem)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;destroy_item&quot;, self.processDestroyItem)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;recv_event&quot;, self.processEvent)
+        self.registerEvent(&quot;happyboom&quot;)
+        self.verbose = args.get(&quot;verbose&quot;, False)
+        self.debug = args.get(&quot;debug&quot;, False)
+        self.features = {}
+        for feat in args.get(&quot;features&quot;, ()):
+            self.features[feat] = None
+        self.items = {}
+        itemPath = args[&quot;item_path&quot;]
+        dirs = itemPath.split(os.path.sep)
+        if dirs[-1] == &quot;&quot;:
+            dirs = dirs[:-1]
+        packagePath = None
+        try:
+            for d in dirs:
+                #print &quot;imp.find_module(%s, %s)&quot; %(repr(modName), repr(modDir))
+                f, fname, desc = imp.find_module(d, packagePath)
+                self.module = imp.load_module(d, f, fname, desc)
+                packagePath = self.module.__path__
+        except:
+            raise Exception(&quot;[HAPPYBOOM] Invalid item path : %s&quot; %itemPath)
+        import types
+        for attr in self.module.__dict__:
+            if type(self.module.__dict__[attr]) == types.ClassType:
+                itemClass = self.module.__dict__[attr]
+                if hasattr(itemClass, &quot;feature&quot;):
+                    feat = getattr(itemClass, &quot;feature&quot;)
+                    if feat != None:
+                        if feat in self.features:
+                            raise Exception(&quot;[HAPPYBOOM] Duplicated feature %s in %s and %s classes&quot; %(feat, itemClass.__name__, self.features[feat].__name__))
+                        self.features[feat] = itemClass
+        
+    def processConnection(self, ioclient, version, signature):
+        self.launchEvent(&quot;happyboom&quot;, &quot;signature&quot;, ioclient, signature)
+        features = &quot;&quot;
+        for name in self.features:
+            try:
+                feature = self.protocol.getFeature(name)
+                features = features + &quot;%c&quot; % feature.id
+            except ProtocolException:
+                pass
+        self.launchEvent(&quot;happyboom&quot;, &quot;features&quot;, ioclient, features)
+        
+    def processDisconnection(self, ioclient, reason):
+        self.launchEvent(&quot;happyboom&quot;, &quot;stop&quot;, reason)
+    
+    def processCreateItem(self, ioclient, feature, id):
+        assert feature in self.features, &quot;Unexpected feature : %s&quot; %feature
+        itemClass = self.features[feature]
+        if itemClass != None:
+            item = itemClass(id)
+            self.items[id] = item
+            self.launchEvent(feature, &quot;new&quot;, id)
+    
+    def processDestroyItem(self, ioclient, id):
+        assert id in self.items, &quot;Unknown item identifier %s&quot; %id
+        self.launchEvent(feature, &quot;delete&quot;, id)
+        del self.items[id]
+        
+    def processEvent(self, ioclient, feature, event, args):
+        if self.debug:
+            log.info(&quot;New event: %s.%s%s&quot; % (feature, event, args))
+        assert feature in self.features, &quot;Unexpected feature&quot;
+        self.launchEvent(feature, event, *args)
+
+#    def evt_happyboom_gamepath(self, path):
+#        self.gamepath = path
\ No newline at end of file

Added: happyboom/trunk/happyboom/common/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/common/event.py
===================================================================
--- happyboom/trunk/happyboom/common/event.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/event.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,72 @@
+&quot;&quot;&quot;
+Module to use event-system very easily.
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at author</A>: Damien Boucard
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at license</A>: Gnu/GPL v2 or later, see LICENSE file.
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at contact</A>: See U{<A HREF="http://developer.berlios.de/projects/happyboom/">http://developer.berlios.de/projects/happyboom/</A>}
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at version</A>: 1.0
+&quot;&quot;&quot;
+import generic_event as evt
+
+class EventListener(evt.EventListener):
+    &quot;&quot;&quot; Happyboom generic class for listening to events.
+    &quot;&quot;&quot;
+    def __init__(self, prefix=&quot;evt_&quot;, suffix=&quot;&quot;, default=&quot;eventPerformed&quot;, silent=True):
+        &quot;&quot;&quot; EventListener constructor.
+        &quot;&quot;&quot;
+        evt.EventListener.__init__(self, prefix, suffix, &quot;happyboomEventPerformed&quot;, silent)
+        self.event_hb_default = default
+        
+    def getEventName(self, feature, event):
+        return &quot;%s_%s&quot; %(feature, event)
+        
+    def happyboomEventPerformed(self, event):
+        if issubclass(event.__class__, Event):
+            # Try to call event-specific handle method
+            fctname = self.event_pattern %(self.getEventName(event.type, event.event))
+            if hasattr(self, fctname):
+                function = getattr(self, fctname)
+                if callable(function):
+                    function(*event.content)
+                    return
+
+        # Try to call default handle method
+        if hasattr(self, self.event_hb_default):
+            function = getattr(self, self.event_hb_default)
+            if callable(function):
+                function(event)
+                return
+        # No handle method found, raise error ?
+        if not self.event_silent:
+            raise evt.UnhandledEventError(&quot;%s has no method to handle %s&quot; %(self, event))
+
+class EventLauncher(evt.EventLauncher):
+    &quot;&quot;&quot; Happyboom generic class for launching events.
+    &quot;&quot;&quot;
+    def __init__(self):
+        &quot;&quot;&quot; EventLauncher constructor. &quot;&quot;&quot;
+        evt.EventLauncher.__init__(self)
+        
+    def launchEvent(self, feature, event, *args):
+        &quot;&quot;&quot; Launches a new event to the listeners.
+        &quot;&quot;&quot;
+        e = Event(feature, event, self, args)
+        self.event_manager.dispatchEvent(e)
+
+class Event(evt.Event):
+    &quot;&quot;&quot; Represents an happyboom event entity.
+    &quot;&quot;&quot;
+    def __init__(self, feature, event, source, content):
+        &quot;&quot;&quot; Event constructor.
+        &quot;&quot;&quot;
+        evt.Event.__init__(self, feature, source, content)
+        self.event = event
+    
+    def __str__(self):
+        &quot;&quot;&quot; Converts object itself to string.
+        @return: Object converted string.
+        @rtype: C{str}
+        &quot;&quot;&quot;
+        return &quot;&lt;event.Event feature=%s event=%s source=%s content=%s&gt;&quot; %(self.type, self.event, self.source, self.content)
+    
+    def getFeature(self): return feature
+    feature = property(getFeature)

Added: happyboom/trunk/happyboom/common/file.py
===================================================================
--- happyboom/trunk/happyboom/common/file.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/file.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,25 @@
+import os
+
+def getCreateHomeDir(subdir):
+    &quot;&quot;&quot;
+    Get the home directory, and then create a subdirectory.
+    Example: create ~/.subdir/ in Linux.
+    
+    Returns None if fails to find home directory and/or create subdirectory.
+    &quot;&quot;&quot;
+
+    # Get user directory 
+    if os.name==&quot;nt&quot;:
+        home = os.environ['USERHOME']
+    else:
+        subdir = &quot;.&quot;+subdir
+        home = os.environ['HOME']
+
+    # Create happywarry directory if needed
+    logdir = os.path.join(home, subdir)
+    try:
+        os.mkdir(logdir)
+    except OSError, err:
+        if err[0] != 17:
+            logdir = None
+    return logdir

Added: happyboom/trunk/happyboom/common/generic_event.py
===================================================================
--- happyboom/trunk/happyboom/common/generic_event.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/generic_event.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,178 @@
+&quot;&quot;&quot;
+Module to use event-system very easily.
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at author</A>: Damien Boucard
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at license</A>: Gnu/GPL v2 or later, see LICENSE file.
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at contact</A>: See U{<A HREF="http://developer.berlios.de/projects/happyboom/">http://developer.berlios.de/projects/happyboom/</A>}
<A HREF="https://lists.berlios.de/mailman/listinfo/happyboom-svn">+ at version</A>: 1.0
+&quot;&quot;&quot;
+from happyboom.common.log import log
+class EventManager:
+    &quot;&quot;&quot; Manages the event-system.
+    This class is instanciated on importing the module,
+    so it is not needed to use it directly but via EventLaunch and EventListener.
+    @cvar instance: The instance created on importing the module.
+    @type instance: C{L{EventManager}}
+    @ivar listeners: Dictionnary with keys of type C{str} representing a event type and with values of type C{list} representing a collection of C{EventListener}.
+    @type listeners: C{dict&lt;str, list&lt;L{EventListener}&gt;&gt;}
+    &quot;&quot;&quot;
+    def __init__(self):
+        &quot;&quot;&quot; EventManager constructor. &quot;&quot;&quot;
+        EventManager.instance = self
+        self.listeners = {}
+        
+    def addListener(self, obj, event_type):
+        &quot;&quot;&quot; Add a listener to a specific event.
+        @param obj: Listener to add.
+        @type obj: C{L{EventListener}}
+        @param event_type: Type of the event to listen.
+        @type event_type: C{str}
+        &quot;&quot;&quot;
+        if event_type in self.listeners:
+            if obj not in self.listeners[event_type]:
+                self.listeners[event_type].append(obj)
+        else:
+            self.listeners[event_type] = [obj]
+    
+    def removeListener(self, obj, event_type):
+        &quot;&quot;&quot; Remove a listener from a specific event.
+        @param obj: Listener to remove.
+        @type obj: C{L{EventListener}}
+        @param event_type: Type of the event that was listening.
+        @type event_type: C{str}
+        &quot;&quot;&quot;
+        if event_type in self.listeners and obj in self.listeners[event_type]:
+            self.listeners[event_type].remove(obj)
+    
+    def dispatchEvent(self, event):
+        &quot;&quot;&quot; Dispatch a launched event to all affected listeners.
+        @param event: Event launched.
+        @type event: C{L{Event}}
+        &quot;&quot;&quot;
+        if event.type in self.listeners:
+            for obj in self.listeners[event.type]:
+                # Try to call event-specific handle method
+                fctname = obj.event_pattern %(event.type)
+                if hasattr(obj, fctname):
+                    function = getattr(obj, fctname)
+                    if callable(function):
+                        function(event)
+                        continue
+                # Try to call default handle method
+                if hasattr(obj, obj.event_default):
+                    function = getattr(obj, obj.event_default)
+                    if callable(function):
+                        function(event)
+                        continue
+                # No handle method found, raise error ?
+                if not obj.event_silent:
+                    raise UnhandledEventError(&quot;%s has no method to handle %s&quot; %(obj, event))
+        else:
+            log.error(&quot;Pas de event.type %s&quot; % event.type)
+
+EventManager()
+    
+class EventListener:
+    &quot;&quot;&quot; Generic class for listening to events.
+    
+    It is just needed to herite from this class and register to events to listen easily events.
+    It is also needed to write handler methods with event-specific and/or C{L{default}} function.
+    
+    Event-specific functions have name as the concatenation of the C{prefix} parameter + the listened event type + the C{suffix} parameter.
+    
+    If it does not exist, the default function is called as defined by the C{L{default}} parameter/attribute.
+    
+    If the event cannot be handled, a C{L{UnhandledEventError}} is raised, except if C{L{silent}} flag is C{True}.
+    @ivar event_manager: The event manager instance.
+    @type event_manager: C{L{EventManager}}
+    @ivar event_pattern: Event-specific handler pattern.
+    @type event_pattern: C{str}
+    @ivar event_default: Default handler function name.
+    @type event_default: C{str}
+    @ivar silent: Silent flag. If C{False}, C{L{UnhandledEventError}} is raised if an event cannot be handled. If C{True}, do nothing, listener does not handle the event.
+    @type silent: C{str}
+    &quot;&quot;&quot;
+    def __init__(self, prefix=&quot;evt&quot;, suffix=&quot;&quot;, default=&quot;eventPerformed&quot;, silent=False):
+        &quot;&quot;&quot; EventListener constructor.
+        @param prefix: Prefix for all event-specific handler function name.
+        @type prefix: C{str}
+        @param suffix: Suffix for all event-specific handler function name.
+        @type suffix: C{str}
+        @param event_default: Default handler function name.
+        @type event_default: C{str}
+        @param event_silent: Silent flag.
+        @type event_silent: C{bool}
+        &quot;&quot;&quot;
+        self.event_manager = EventManager.instance
+        self.event_pattern = prefix + &quot;%s&quot; + suffix
+        self.event_default = default
+        self.event_silent = silent
+        
+    def registerEvent(self, event_type):
+        &quot;&quot;&quot; Registers itself to a new event.
+        @param event_type: Type of the event to listen.
+        @type event_type: C{str}
+        &quot;&quot;&quot;
+        self.event_manager.addListener(self, event_type)
+        
+    def unregisterEvent(self, event_type):
+        &quot;&quot;&quot; Unregisters itself from a event.
+        @param event_type: Type of the event which was listening.
+        @type event_type: C{str}
+        &quot;&quot;&quot;
+        self.event_manager.removeListener(self, event_type)
+
+
+class EventLauncher:
+    &quot;&quot;&quot; Generic class for launching events.
+    It is just needed to herite from this class to launch easily events.
+    @ivar event_manager: The event manager instance.
+    @type event_manager: C{L{EventManager}}
+    &quot;&quot;&quot;
+    def __init__(self):
+        &quot;&quot;&quot; EventLauncher constructor. &quot;&quot;&quot;
+        self.event_manager = EventManager.instance
+        
+        
+    def launchEvent(self, event_type, content=None):
+        &quot;&quot;&quot; Launches a new event to the listeners.
+        @param event_type: Type of the event to launch.
+        @type event_type: C{str}
+        @param content: Content to attach with the event (Optional).
+        @type content: any
+        &quot;&quot;&quot;
+        self.event_manager.dispatchEvent(Event(event_type, self, content))
+    
+    
+class Event:
+    &quot;&quot;&quot; Represents an event entity.
+    @ivar type: Type of the event.
+    @type type: C{str}
+    @ivar source: Instance which launched the event.
+    @type source: C{L{EventLauncher}}
+    @ivar content: Content attached to the event (C{None} if none).
+    @type content: any
+    &quot;&quot;&quot;
+    def __init__(self, type, source, content):
+        &quot;&quot;&quot; Event constructor.
+        @param type: Type of the event.
+        @type type: C{str}
+        @param source: Instance which launched the event.
+        @type source: C{L{EventLauncher}}
+        @param content: Content attached to the event (C{None} if none).
+        @type content: any
+        &quot;&quot;&quot;
+        self.type = type
+        self.source = source
+        self.content = content
+    
+    def __str__(self):
+        &quot;&quot;&quot; Converts object itself to string.
+        @return: Object converted string.
+        @rtype: C{str}
+        &quot;&quot;&quot;
+        return &quot;&lt;generic_event.Event type=%s source=%s content=%s&gt;&quot; %(self.type, self.source, self.content)
+    
+    
+class UnhandledEventError(AttributeError):
+    &quot;&quot;&quot; Error raised when an event cannot be handled, except if C{L{silent&lt;EventListener.silent&gt;}} flag is C{True}. &quot;&quot;&quot;
+    pass

Added: happyboom/trunk/happyboom/common/happyboom_protocol.py
===================================================================
--- happyboom/trunk/happyboom/common/happyboom_protocol.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/happyboom_protocol.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,126 @@
+from presentation import Presentation
+import happyboom.common.packer as packer
+from happyboom.common.log import log
+import struct
+
+class HappyboomProtocol(Presentation):
+    def __init__(self, protocol, args):
+        Presentation.__init__(self, protocol, args)
+        self._unpackFunc = { \
+            self.CONNECTION: self.unpackConnection,
+            self.DISCONNECTION: self.unpackDisconnection,
+            self.FEATURES: self.unpackFeatures,
+            self.CREATE: self.unpackCreateItem,
+            self.DESTROY: self.unpackDestroyItem,
+            self.EVENT: self.unpackEvent}
+
+    def packConnection(self, version, signature):
+        data = struct.pack(&quot;!B&quot;, self.CONNECTION)
+        data = data + packer.packBin(version)
+        return data + packer.packBin(signature)
+
+    def packDisconnection(self, reason):
+        return struct.pack(&quot;!B&quot;, self.DISCONNECTION) + packer.packUtf8(reason)
+
+    def packFeatures(self, features):
+        data = struct.pack(&quot;!B&quot;, self.FEATURES)
+        return data + packer.packBin(features)
+
+    def packCreate(self, feature, id):
+        return struct.pack(&quot;!BBI&quot;, self.CREATE, feature, id)
+
+    def packEvent(self, id):
+        return struct.pack(&quot;!BI&quot;, self.DESTROY, id)
+
+    def packEvent(self, feature, event, args):
+        f = self.protocol.getFeature(feature)
+        e = f.getEvent(event)
+        out = struct.pack(&quot;!BB&quot;, f.id, e.id)
+        types = e.getParamTypes()
+        if len(args) != len(types):
+            raise ProtocolException( \
+                &quot;Unexpected number of parameters (%u) for the event %s.%s.&quot; \
+                % (len(args), f.name, e))
+        for i in range(len(args)):
+            if not packer.checkType(types[i], args[i]):
+                raise ProtocolException( \
+                    &quot;Parameter %u of event %s.%s should have type %s (instead of %s).&quot; \
+                    % (i, f.name, e, types[i], type(args[i])))
+            type = types[i]
+            data = args[i]
+            
+            if type==&quot;int&quot;:
+                data = packer.packInt(data)
+            elif type==&quot;bin&quot;:
+                data = packer.packBin(data)
+            elif type==&quot;utf8&quot;:
+                data = packer.packUtf8(data)
+            else:
+                raise packer.PackerException(&quot;Wrong argument type: %s&quot; % type)
+            out = out + data
+        return struct.pack(&quot;!B&quot;, self.EVENT) + out
+
+    def unpackPacketType(self, data):
+        # Get packet type
+        fmt = &quot;!B&quot;
+        i = struct.calcsize(fmt)
+        type, = struct.unpack(fmt, data[:i]) 
+        return type, data[i:]
+
+    def unpackConnection(self, ioclient, data):
+        version, data = packer.unpackBin(data)
+        signature, data = packer.unpackBin(data) 
+        if self._on_connection != None:
+            self._on_connection(ioclient, version, signature)
+        return data
+
+    def unpackDisconnection(self, ioclient, data):
+        reason, data = packer.unpackUtf8(data)
+        if self._on_disconnection != None:
+            self._on_disconnection(ioclient, reason)
+#            self.client_manager.closeClient(ioclient)
+        return data
+        
+    def unpackFeatures(self, ioclient, data):
+        features, data = packer.unpackBin(data)
+        if self._on_features != None:
+            self._on_features(ioclient, features)
+        return data
+
+    def unpackCreateItem(self, ioclient, data):
+        fmt = &quot;!BI&quot;
+        i = struct.calcsize(fmt)
+        typeid, itemid = struct.unpack(fmt, data)
+        type = self.protocol[typeid]
+        data = data[i:]
+        if self._on_create_item != None:
+            self._on_create_item(ioclient, type.name, itemid)
+        return data
+
+    def unpackDestroyItem(self, ioclient, data):
+        itemid,data = packer.unpackInt(data)
+        if self._on_destroy_item != None:
+            self._on_destroy_item(ioclient, itemid)
+        return data
+    
+    def unpackEvent(self, ioclient, data):
+        fmt = &quot;!BB&quot;
+        i = struct.calcsize(fmt)
+        feature_id, event_id = struct.unpack(fmt, data[:i])
+        feat = self.protocol[feature_id]
+        evt = feat[event_id]
+        data = data[i:]
+        args = []
+        for type in evt.getParamTypes():
+            if type==&quot;int&quot;:
+                arg, data = packer.unpackInt(data)
+            elif type==&quot;bin&quot;:
+                arg, data = packer.unpackBin(data)
+            elif type==&quot;utf8&quot;:
+                arg, data = packer.unpackUtf8(data)
+            else:
+                raise packer.PackerException(&quot;Wrong argument type: %s&quot; % type)
+            args.append(arg)
+        if self._on_recv_event != None:
+            self._on_recv_event(ioclient, feat.name, evt.name, tuple(args))
+        return &quot;&quot;

Added: happyboom/trunk/happyboom/common/log.py
===================================================================
--- happyboom/trunk/happyboom/common/log.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/log.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,93 @@
+#!/usr/bin/python
+# -*- coding: UTF-8 -*-
+
+import time
+
+class Log:
+    LOG_INFO   = 0
+    LOG_WARN   = 1
+    LOG_ERROR  = 2
+
+    def __init__(self):
+        self.__buffer = {}
+        self.__file = None
+        self.use_print = True
+        self.on_new_message = None # (level, prefix, text)
+
+    def setFilename(self, filename):
+        &quot;&quot;&quot;
+        Use a file to store all messages. The
+        UTF-8 encoding will be used. Write an informative
+        message if the file can't be created.
+
+        @param filename: C{L{string}}
+        &quot;&quot;&quot;
+
+        try:
+            import codecs
+            self.__file = codecs.open(filename, &quot;w&quot;, &quot;utf-8&quot;)
+        except IOError, errno:
+            if errno[0] == 2:
+                self.__file = None
+                self.info(&quot;Log.setFilename(%s) fails : no such file.&quot; % filename)
+                return
+            raise
+
+    def getLevelPrefix(self, level):
+        &quot;&quot;&quot;
+        String prefix which depends on message level.
+        Eg. information returns &quot;[info]&quot;.
+        @return: C{str}
+        &quot;&quot;&quot;
+        if level==Log.LOG_WARN: return &quot;[warn]&quot;
+        if level==Log.LOG_ERROR: return &quot;[err!]&quot;
+        return &quot;[info]&quot;
+
+    def new_message(self, level, str):
+        &quot;&quot;&quot;
+        Write a new message : append it in the buffer,
+        display it to the screen (if needed), and write
+        it in the log file (if needed).
+
+        @param level: Message level.
+        @type level: C{int}
+        @param str: Message content.
+        @type str: C{str}
+        &quot;&quot;&quot;
+
+        if not self.__buffer.has_key(level):
+            self.__buffer[level] = [str]
+        else:
+            self.__buffer[level].append(str)
+        prefix = self.getLevelPrefix(level)            
+        if self.use_print:
+            print &quot;%s %s&quot; % (prefix, str)
+        if self.__file:
+            self.__file.write(u&quot;%s - %s %s\n&quot; \
+                % (time.strftime(&quot;%Y-%M-%d %H:%M:%S&quot;),
+                   prefix, str))
+        if self.on_new_message:
+            self.on_new_message (level, prefix, str)
+
+    def info(self, str):
+        &quot;&quot;&quot;
+        New informative message.
+        @type str: C{str}
+        &quot;&quot;&quot;
+        self.new_message(Log.LOG_INFO, str)
+
+    def warning(self, str):
+        &quot;&quot;&quot;
+        New warning message.
+        @type str: C{str}
+        &quot;&quot;&quot;
+        self.new_message(Log.LOG_WARN, str)
+
+    def error(self, str):
+        &quot;&quot;&quot;
+        New error message.
+        @type str: C{str}
+        &quot;&quot;&quot;
+        self.new_message(Log.LOG_WARN, str)
+
+log = Log()        

Added: happyboom/trunk/happyboom/common/packer.py
===================================================================
--- happyboom/trunk/happyboom/common/packer.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/packer.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,53 @@
+import types # maybe only used for assertions
+import struct
+
+class PackerException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+def checkType(datatype, data):
+    if datatype==&quot;int&quot;:
+        return (type(data) == type(1)) and (data &lt;= 2147483647) and (-2147483648 &lt;= data)
+    elif datatype==&quot;bin&quot;:
+        return type(data)==types.StringType and len(data) &lt; 65535 
+    elif datatype==&quot;utf8&quot;:
+        return type(data)==types.UnicodeType and len(data) &lt; 65535
+    else:
+        raise PackerException(&quot;Wrong argument type: %s&quot; % datatype)
+
+# Integer type
+def packInt(data):
+    assert checkType(&quot;int&quot;, data), &quot;packInt argument have to be an integer&quot;
+    return struct.pack(&quot;!i&quot;, data)
+    
+def unpackInt(data):
+    fmt = &quot;!i&quot;
+    i = struct.calcsize(fmt)
+    value, = struct.unpack(fmt, data[:i])
+    return value, data[i:]
+    
+# unicode string type (encoded in UTF-8)
+def packUtf8(data):
+    assert checkType(&quot;utf8&quot;, data), &quot;packUtf8 argument have to be an unicode string&quot;
+    return packBin(data.encode(&quot;utf-8&quot;))
+
+def unpackUtf8(data):
+    str, data = unpackBin(data)
+    str = unicode(str, &quot;UTF-8&quot;)
+    return str, data
+
+# Binary string type
+def packBin(data):
+    assert checkType(&quot;bin&quot;, data), &quot;packBin argument have to be a string&quot;
+    # TODO : verify length
+    return struct.pack(&quot;!H%us&quot; % len(data), len(data), data)
+
+def unpackBin(data):        
+    fmt = &quot;!H&quot;
+    i = struct.calcsize(fmt)
+    version_len, = struct.unpack(fmt, data[:i])
+    data = data[i:]
+    fmt = &quot;!%us&quot; %(version_len)
+    i = struct.calcsize(fmt)
+    bin, = struct.unpack(fmt, data[:i])
+    return bin, data[i:]

Added: happyboom/trunk/happyboom/common/presentation.py
===================================================================
--- happyboom/trunk/happyboom/common/presentation.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/presentation.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,131 @@
+from happyboom.common.event import EventListener
+from happyboom.common.log import log
+from happyboom.net.io.packet import Packet
+from happyboom.server.client import Client
+import struct
+
+class PresentationException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+class Presentation(EventListener):
+    
+    CONNECTION    = 0x1
+    DISCONNECTION = 0x2
+    FEATURES      = 0x3
+    CREATE        = 0x4
+    DESTROY       = 0x5
+    EVENT         = 0x6
+    
+    def __init__(self, protocol, args):
+        EventListener.__init__(self)
+        self.protocol = protocol
+        self.items = {}
+        self._unpackFunc = {}
+        self.registerEvent(&quot;happyboom&quot;)
+        self.verbose = args.get(&quot;verbose&quot;, False)
+
+        # Event (IO_Client client, str version, str signature)
+        self._on_connection = None
+        # Event (IO_Client client, str features)
+        self._on_features = None
+        # Event (IO_Client client)
+        self._on_disconnection = None
+        # Event (IO_Client client, str feature, str event, str arguments)
+        self._on_recv_event = None
+        # Event (IO_Client client, str type, int id)
+        self._on_create_item = None
+        # Event (IO_Client client, int id)
+        self._on_destroy_item = None
+
+    def processPacket(self, packet):
+        &quot;&quot;&quot; Processes incomming network packets (converts and launches local event).
+        @param packet: incomming network packet.
+        @type packet: C{net.io.packet.Packet}
+        &quot;&quot;&quot;
+        ptype, data = self.unpackPacketType(packet.data)
+        
+        # Choose process function
+        if ptype in self._unpackFunc:
+            data = self._unpackFunc[ptype] (packet.recv_from, data)
+        else:
+            log.warning(&quot;ProtocoleWarning: received unexpected packet type %s.&quot; % ptype)
+        if len(data) != 0:
+            log.warning(&quot;ProtocolWarning: Received a message with an unexpected length.&quot;)
+            log.warning(u&quot;Rest: [%s].&quot; % data)
+
+    def evt_happyboom_register(self, event, handler):
+        event = &quot;_on_&quot;+event
+        if hasattr(self, event):
+            setattr(self, event, handler)
+    
+    def evt_happyboom_closeConnection(self, ioclient, reason):
+        &quot;&quot;&quot;
+        Close client connection.
+        @type ioclient L{IOClient}
+        @type reason Unicode
+        &quot;&quot;&quot;
+        self.evt_happyboom_disconnection(ioclient, reason)
+
+    def evt_happyboom_connection(self, ioclient, version=None, signature=&quot;&quot;):
+        &quot;&quot;&quot;
+        Send a connection message to ioclient.
+        @type version ASCII string
+        @type signature string
+        &quot;&quot;&quot;
+        if version == None:
+            version = self.protocol.version
+        if self.verbose:
+            log.info(&quot;[PRESENTATION] Send connection(\&quot;%s\&quot;, \&quot;%s\&quot;)&quot; % (version, signature))
+        data = self.packConnection(version, signature)
+        ioclient.send( Packet(data) )
+
+    def evt_happyboom_disconnection(self, ioclient, reason):
+        &quot;&quot;&quot;
+        Send a disconnection message to ioclient.
+        @type ioclient L{IOClient}
+        @type reason Unicode
+        &quot;&quot;&quot;
+        
+        if self.verbose:
+            log.info(u&quot;[PRESENTATION] Send disconnection(\&quot;%s\&quot;)&quot; % reason)
+        data = self.packDisconnection(reason)
+        ioclient.send( Packet(data) )
+        ioclient.disconnect()
+    
+
+    def evt_happyboom_features(self, ioclient, features):
+        if self.verbose:
+            log.info(u&quot;[PRESENTATION] Send features(%s)&quot; % features)
+        data = self.packFeatures(features)
+        ioclient.send( Packet(data) )
+        
+    def evt_happyboom_create(self, ioclient, feature, id):
+        if self.verbose:
+            log.info(u&quot;[PRESENTATION] Send create(%s, %s)&quot; % (feature, id))
+        data = self.packCreate(feature, id)
+        ioclient.send( Packet(data) )
+       
+    
+    def evt_happyboom_event(self, clients, feature, event, args):
+        data = self.packEvent(feature, event, args)
+        packet = Packet(data)
+        for client in clients: client.send(packet)
+        
+    def unpackPacketType(self, data):
+        &quot;&quot;&quot; returns type, data &quot;&quot;&quot;
+        return 0, data
+        
+    def unpackConnection(self, ioclient, version, signature): return data
+    def unpackDisconnection(self, ioclient, data): return data
+    def unpackFeatures(self, ioclient, data): return data
+    def unpackCreateItem(self, data): return data
+    def unpackDestroyItem(self, data): return data
+    def unpackEvent(self, ioclient, data): return data
+
+    def packConnection(self, version, signature): return &quot;&quot;
+    def packDisconnect(self, reason): return &quot;&quot;
+    def packFeatures(self, features): return &quot;&quot;
+    def packCreateItem(self, feature, id): return &quot;&quot;
+    def packDestroyItem(self, id): return &quot;&quot;
+    def packEvent(self, feature, event, args): return &quot;&quot;
\ No newline at end of file

Added: happyboom/trunk/happyboom/common/protocol.py
===================================================================
--- happyboom/trunk/happyboom/common/protocol.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/protocol.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,188 @@
+&quot;&quot;&quot;
+Tools to load HappyBoom protocol in Python from an XML description file.
+&quot;&quot;&quot;
+
+import xml.dom.minidom
+
+class ProtocolException(Exception):
+    def __init__(self, msg):
+        Exception.__init__(self, msg)
+
+class ProtocolEventParam:
+    def __init__(self, event, name, type):
+        self.name = name.encode(&quot;ascii&quot;)
+        self.type = type
+        self.event = event
+
+    def __str__(self):
+        return &quot;%s: %s&quot; % (self.name, self.type)
+       
+class ProtocolEvent:
+    def __init__(self, feature, name, id):
+        self.name = name.encode(&quot;ascii&quot;)
+        self.id = id
+        self.feature = feature
+        self.__params_dict = {}
+        self.__params_array = [] 
+        
+    def addParam(self, name, id):
+        param = ProtocolEventParam(self, name, id)
+        self.__params_dict[name] = param
+        self.__params_array.append(param)
+        return param
+
+    def getParamTypes(self):
+        types = []
+        for param in self.__params_array:
+            types.append(param.type)
+        return types
+        
+    def __str__(self):
+        out = &quot;%s(&quot; % (self.name)
+        comma = False
+        for param in self.__params_array:
+            if comma:
+                out = out + &quot;,&quot;
+            else:
+                comma = True
+            out = out + str(param)
+        out = out + &quot;)&quot;
+        return out
+
+class ProtocolFeature:
+    def __init__(self, protocol, name, id):
+        self.protocol = protocol
+        self.name = name.encode(&quot;ascii&quot;)
+        self.id = id
+        self.__evtnames = {}
+        self.__evtids = {}
+
+    def addEvent(self, name, id):
+        # Check if no other event have the same identifier
+        event = self.__evtids.get(id, None)
+        if event != None:
+            raise ProtocolException( \
+                &quot;Events %s.%s and %s.%s have the same identifier (%s).&quot; \
+                % (self.name, event.name, self.name, name, id))
+        # Check if no other event have the same name
+        event = self.__evtnames.get(name, None)
+        if event != None:
+            raise ProtocolException( \
+                &quot;Events %s[%s] and %s[%s] have the same name (%s).&quot; \
+                % (self.name, event.id, self.name, id, name))
+
+        # Add the new event 
+        event = ProtocolEvent(self, name, id)
+        self.__evtnames[name] = event
+        self.__evtids[id] = event
+        return event
+
+    def getEvent(self, name):
+        event = self.__evtnames.get(name, None)
+        if event == None:
+            raise ProtocolException( \
+                &quot;The protocol %s has no event %s.%s(...).&quot; 
+                % (self.protocol.name, self.name, name))
+        return self.__evtnames[name]
+
+    def __getitem__(self, id):
+        event = self.__evtids.get(id, None)
+        if event == None:
+            raise ProtocolException( \
+                &quot;The protocol %s has no event %s[%s](...).&quot; 
+                % (self.protocol.name, self.name, id))
+        return self.__evtids[id]
+
+    def __str__(self):
+        first = True
+        out = &quot;&quot;
+        for event in self.__evtnames.values():
+            if first:
+                first = False
+            else:
+                out = out + &quot;\n&quot;
+            out = out + &quot;%s.%s&quot; % (self.name, event)
+        return out
+
+class Protocol:
+    &quot;&quot;&quot;
+    HappyBoom protocol utility.
+    version is ASCII 
+    &quot;&quot;&quot;
+    def __init__(self, name, version):
+        self.name = name.encode(&quot;ascii&quot;)
+        self.version = version.encode(&quot;ascii&quot;)
+        self.__featnames = {}
+        self.__featids = {}
+
+    def addFeature(self, name, id):
+        # Check if no other feature have the same identifier
+        feature = self.__featnames.get(name, None)
+        if feature != None:
+            raise ProtocolException( \
+                &quot;Features %s and %s have the same identifier (%s).&quot; \
+                % (feature.name, name, id))
+                
+        # Check if no other feature have the same name
+        feature = self.__featids.get(id, None)
+        if feature != None:
+            raise ProtocolException( \
+                &quot;Features %s and %s have the same name (%s).&quot; \
+                % (feature.id, id, name))
+
+        # Add the new feature
+        feature = ProtocolFeature(self, name, id)
+        self.__featnames[name] = feature
+        self.__featids[id] = feature
+        return feature
+
+    def getFeature(self, name):
+        feature = self.__featnames.get(name, None)
+        if feature == None:
+            raise ProtocolException( \
+                &quot;The protocol %s has no feature \&quot;%s\&quot;.&quot; \
+                % (self.name, name))
+        return feature
+
+    def __getitem__(self, id):
+        feature = self.__featids.get(id, None)
+        if  feature == None:
+            raise ProtocolException( \
+                &quot;The protocol %s has no feature with \&quot;%s\&quot; identifier.&quot; \
+                % (self.name, id))
+        return feature
+        
+    def __str__(self):
+        out = &quot;&quot;
+        first = True
+        for feature in self.__featnames.values():
+            if first:
+                first = False
+            else:
+                out = out + &quot;\n&quot;
+            out = out + &quot;[ %s ]\n&quot; % feature.name
+            out = out + str(feature)
+        return out
+ 
+def loadProtocol(filename):
+    doc = xml.dom.minidom.parse(filename)
+    protocol = doc.documentElement
+    p = Protocol( \
+        protocol.getAttribute(&quot;name&quot;),
+        protocol.getAttribute(&quot;version&quot;))
+    features = protocol.getElementsByTagName(&quot;feature&quot;)
+    for feature in features:
+        f = p.addFeature( \
+            feature.getAttribute(&quot;name&quot;),
+            int(feature.getAttribute(&quot;id&quot;)))
+        events = feature.getElementsByTagName(&quot;event&quot;)
+        for event in events:
+            e = f.addEvent( \
+                event.getAttribute(&quot;name&quot;),
+                int(event.getAttribute(&quot;id&quot;)))
+            params = event.getElementsByTagName(&quot;param&quot;)
+            for param in params:
+                e.addParam( \
+                    param.getAttribute(&quot;name&quot;),
+                    param.getAttribute(&quot;type&quot;))
+    return p

Added: happyboom/trunk/happyboom/common/thread.py
===================================================================
--- happyboom/trunk/happyboom/common/thread.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/common/thread.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,6 @@
+import traceback, sys
+
+def getBacktrace():
+    bt = traceback.format_exception( \
+        sys.exc_type, sys.exc_value, sys.exc_traceback)
+    return &quot;&quot;.join(bt)

Added: happyboom/trunk/happyboom/makedoc.sh
===================================================================
--- happyboom/trunk/happyboom/makedoc.sh	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/makedoc.sh	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,7 @@
+#!/bin/sh
+test -e doc || mkdir doc
+epydoc \
+    -o doc/api
+    -n &quot;HappyBoom game engine 0.2&quot; \
+    --private-css blue \
+    common net server


Property changes on: happyboom/trunk/happyboom/makedoc.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happyboom/net/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/net/io/__init__.py
===================================================================
--- happyboom/trunk/happyboom/net/io/__init__.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/__init__.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,3 @@
+from packet import Packet
+from io_client import IO_Client
+from base_io import BaseIO

Added: happyboom/trunk/happyboom/net/io/base_io.py
===================================================================
--- happyboom/trunk/happyboom/net/io/base_io.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/base_io.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,128 @@
+#!/usr/bin/python
+# -*- coding: ISO-8859-1 -*-
+
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.io_client import IO_Client
+import time
+import threading
+import socket
+import traceback
+import struct
+
+class BaseIO(object):
+    &quot;&quot;&quot;
+    Base IO virtual class.
+
+    @ivar verbose: Is verbose ?
+    @type verbose: C{bool}
+    @ivar debug: Display debug messages ?
+    @type debug: C{bool}
+    @ivar on_connect: Event called when the IO try to connect.
+    @type on_connect: C{function()}
+    @ivar on_connection_fails: Event called when the IO fails to connect to server.
+    @type on_connection_fails: C{function()}
+    @ivar on_disconnect: Event called when the server try to disconnect.
+    @type on_disconnect: C{function()}
+    @ivar on_client_connect: Event called when a new client try to connect to the server.
+    @type on_client_connect: C{function(L{IO_Client})}
+    @ivar on_client_disconnect: Event called when a client is disconnected.
+    @type on_client_disconnect: C{function(L{IO_Client})}
+    @ivar on_new_packet: Event called when a new packet is received.
+    @type on_new_packet: C{function(L{Packet})}
+    @ivar _name: The IO name.
+    @type _name: C{str}
+    @ivar _running: Is the thread running ?
+    @type _running: C{bool}
+    &quot;&quot;&quot;
+    
+    def __init__(self, is_server=False):
+        &quot;&quot;&quot;
+        Constructor.
+        @type is_server: C{bool}
+        &quot;&quot;&quot;
+        self.debug = False
+        self.verbose = False 
+        self._is_ready = False
+        self._running = False 
+
+        # Events
+        self.on_connect = None            # No argument
+        self.on_connection_fails = None   # No argument
+        self.on_lost_connection = None    # No argument
+        self.on_disconnect = None         # No argument
+        self.on_client_connect = None     # (client)
+        self.on_client_disconnect = None  # (client)
+        self.on_new_packet = None         # (packet) : client address
+        self.on_send = None               # (data)
+        self.on_receive = None            # (data)
+
+        self._name = None
+
+    def connect(self, host, port):
+        &quot;&quot;&quot; Connect to host:port.
+        @parameter host: Network hostname.
+        @type host: C{str}
+        @parameter port: Network port number.
+        @type port: C{int}
+        &quot;&quot;&quot;
+        if self._name==None:
+            self._name = &quot;%s:%u&quot; % (host, port)
+        self._running = True
+
+    def disconnect(self):
+        &quot;&quot;&quot; Close connection. &quot;&quot;&quot;
+        pass
+
+    def send(self, packet, to=None):
+        &quot;&quot;&quot; Send a packet to the server or to all clients. &quot;&quot;&quot;
+        pass
+    
+    def receive(self, max_size = 1024):
+        &quot;&quot;&quot; Read a packet from the socket. Returns None if there is not new data.
+        @parameter max_size: Maximum packet size (in bytes).
+        @type max_size: C{int}
+        @rtype: C{L{Packet}}
+        &quot;&quot;&quot;
+        pass
+
+    def live(self):                
+        &quot;&quot;&quot; Keep the connection alive. &quot;&quot;&quot;
+        pass
+
+    def disconnectClient(self, client):
+        &quot;&quot;&quot; Disconnect an IO client.
+        @type client: L{IO_Client}
+        &quot;&quot;&quot;
+        pass
+    
+    def run_thread(self):
+        &quot;&quot;&quot; Run the IO thread (will call L{live()} itself). &quot;&quot;&quot;
+        pass
+    
+    def stop(self):
+        &quot;&quot;&quot; Stop the IO (close connections). &quot;&quot;&quot;
+        if not self._running: return
+        self._running = False
+        self.disconnect()
+
+    def __str__(self):
+        return self.name
+    
+    def isRunning(self): return self._running
+
+    #--- Private functions ------------------------------------------------------
+
+    def _getName(self):
+        if self._name == None: return &quot;no name&quot;
+        return self._name
+    
+    def _setName(self, name):
+        self._name = name
+
+    def __getReady(self):
+        return self._is_ready
+
+    #--- Properties -------------------------------------------------------------
+
+    name = property(_getName, _setName, doc=&quot;The IO name.&quot;)
+    is_ready = property(__getReady, doc=&quot;Tells if the IO is ready to use.&quot;);

Added: happyboom/trunk/happyboom/net/io/io_client.py
===================================================================
--- happyboom/trunk/happyboom/net/io/io_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/io_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,55 @@
+import socket
+
+class IO_Client(object):
+    &quot;&quot;&quot; IO Client.
+    @ivar __addr: Client address (host, port).
+    @type __addr: C{(str,int)}
+    @ivar connected: Is client connected ?
+    @type connected: C{bool}
+    @ivar io: Main IO used by client.
+    @type io: C{L{BaseIO}}
+    @ivar name: Client name.
+    @type name: C{str}
+    &quot;&quot;&quot;
+    
+    def __init__(self, io, addr, name=None):
+        &quot;&quot;&quot; Constructor.
+        @parameter io: Main IO used by client.
+        @type io: C{L{BaseIO}}
+        @parameter addr: Client address (host, port).
+        @type addr: C{(str,int)}
+        @parameter name: Client name.
+        @type name: C{str}
+        &quot;&quot;&quot;
+        self.__addr = addr
+        self.name = name
+        self.connected = True 
+        self.io = io
+        if self.name == None:
+            self.name = &quot;%s:%u&quot; % (self.host, self.port)
+
+    def send(self, packet):
+        &quot;&quot;&quot; Send a packet to the client.
+        @type packet: C{L{Packet}}
+        &quot;&quot;&quot;
+        pass
+
+    def disconnect(self):    
+        &quot;&quot;&quot; Disconnect the client. &quot;&quot;&quot;
+        self.connected = False
+        self.io.disconnectClient(self)
+
+    def __str__(self):
+        return self.name
+
+    def __getAddr(self):
+        return self.__addr
+    def __getHost(self):
+        if self.__addr[0]=='': return 'localhost'
+        return self.__addr[0]
+    def __getPort(self):
+        return self.__addr[1]
+
+    addr = property(__getAddr, doc=&quot;Client address (host, port)&quot;)
+    host = property(__getHost, doc=&quot;Client network hostname.&quot;)
+    port = property(__getPort, doc=&quot;Client network port.&quot;)

Added: happyboom/trunk/happyboom/net/io/packet.py
===================================================================
--- happyboom/trunk/happyboom/net/io/packet.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io/packet.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,173 @@
+&quot;&quot;&quot;
+A network packet. It can have differents types :
+1. Data
+2. Ping
+3. Pong
+4. Ack
+
+Ping, pong and ack(nowledge) are only used on transport layer.
+&quot;&quot;&quot;
+
+from happyboom.common.log import log
+import time
+import struct
+
+class Packet(object):
+    &quot;&quot;&quot; Network packet.
+    @ivar id: Packet identifier.
+    @type id: C{int}
+    @ivar __data: Data string.
+    @type __data: C{str}
+    @ivar type: Packet type (see types).
+    @type type: C{int}
+    @ivar recv_from: Packet shipper.
+    @type recv_from: C{L{IO_Client}}
+    @ivar timeout: Timeout before packet is resend.
+    @type timeout: C{float}
+    @ivar total_timeout: Timeout before packet is said to be &quot;lost&quot;.
+    @type total_timeout: C{float}
+    @ivar max_resend: Maximum number of packet resend.
+    @type max_resend: C{int}
+    @ivar use_tcp : Does IO used TCP connection ?
+    @type use_tcp: C{bool}
+    &quot;&quot;&quot;
+
+    timeout = 0.250
+    total_timeout = 5.000 
+    max_resend = int(total_timeout / timeout)
+    use_tcp = False
+
+    # Packet types
+    PACKET_DATA = 1
+    PACKET_PING = 2
+    PACKET_PONG = 3
+    PACKET_ACK = 4
+
+    def __str__(self):
+        txt = &quot;Packet &lt;type=%u, &quot; % (self.type)
+        if self.__data:
+            txt = txt+&quot;data=\&quot;%s\&quot;&quot; % (self.__data)
+        else:
+            txt = txt+&quot;no data&quot;            
+        if self.skippable: txt = txt+&quot;, skippable&quot;
+        return txt+&quot;&gt;&quot;
+
+    def __init__(self, str=None, skippable=False):
+        &quot;&quot;&quot; Constructor.
+        @parameter str: String data.
+        @type str: C{str}
+        @parameter skippable: Is the packet skippable if link quality is bad ? See skippable attribute.
+        @type skippable: C{bool}
+        &quot;&quot;&quot;
+        self.sent = 0
+        self.__data = None
+        self.timeout = None
+        self.skippable = skippable
+        self.id = None
+        self.type = Packet.PACKET_DATA
+        self.recv_from = None
+        self.__valid = True
+        if str != None: self.writeStr(str)
+
+    def isValid(self):
+        &quot;&quot;&quot; After unpack, say if the packet is valid or not.
+        @rtype: C{bool}
+        &quot;&quot;&quot;
+        if not Packet.use_tcp and self.id==None: return False
+        return self.__valid 
+        
+    def toStr(self):
+        &quot;&quot;&quot; For debug only, convert to string &quot;&quot;&quot;
+        if self.type == Packet.PACKET_ACK:
+            return &quot;ACK %u [id=%u, skippable=%u]&quot; % (self.id, self.id, self.skippable)
+        if self.type == Packet.PACKET_PING:
+            ping = struct.unpack(&quot;!I&quot;, self.__data)
+            return &quot;PING %u [id=%u, skippable=%u]&quot; % (ping[0], self.id, self.skippable)
+        if self.type == Packet.PACKET_PONG:
+            ping = struct.unpack(&quot;!I&quot;, self.__data)
+            return &quot;PONG %u [id=%u, skippable=%u]&quot; % (ping[0], self.id, self.skippable)
+        else:
+            return &quot;\&quot;%s\&quot; [id=%u, skippable=%u]&quot; \
+                % (self.__data, self.id, self.skippable)
+
+    def unpack(self, binary_data):
+        &quot;&quot;&quot; Fill attributes from a binary data packet
+        @parameter binary_data: Binary datas which comes from network.
+        @type C{binary}
+        &quot;&quot;&quot;
+        if binary_data==None: return
+        self.__valid = False
+
+        if Packet.use_tcp:
+            # Read data len
+            format = &quot;!I&quot;
+            size = struct.calcsize(format)
+            if len(binary_data) &lt;  size:
+                log.warning(&quot;Wrong network packet size from %s!&quot; % self.recv_from)
+                return None
+            data = struct.unpack(format, binary_data[:size])
+            data_len = data[0]
+            binary_data = binary_data[size:]
+        else:
+            # Read skippable, id, data len
+            format = &quot;!BBII&quot;
+            size = struct.calcsize(format)
+            if len(binary_data) &lt;  size:
+                log.warning(&quot;Wrong network packet size from %s!&quot; % self.recv_from)
+                return None
+            data = struct.unpack(format, binary_data[:size])
+            self.type = data[0]
+            self.skippable = (data[1]==1)
+            self.id = data[2]
+            data_len = data[3]
+            binary_data = binary_data[size:]
+
+        # Read data
+        if 0 &lt; data_len:
+            format = &quot;!%us&quot; % (data_len)
+            size = struct.calcsize(format)
+            if len(binary_data) &lt; size:
+                log.warning(&quot;Wrong network packet size from %s!&quot; % self.recv_from)
+                return None
+            data = struct.unpack(format, binary_data[:size]) 
+            self.__data = data[0] 
+        else:
+            self.__data = None
+        self.__valid = True
+        return binary_data[size:]
+
+    def pack(self):
+        &quot;&quot;&quot; Pack datas to a binary string (using struct module)
+        @rtype: C{str}
+        &quot;&quot;&quot;
+        if self.__data != None:
+            data_len = len(self.__data)
+        else:
+            data_len = 0
+        if Packet.use_tcp:
+            data = struct.pack(&quot;!I&quot;, data_len)
+        else:
+            data = struct.pack(&quot;!BBII&quot;, 
+                self.type, int(self.skippable), self.id, data_len)
+        if data_len != 0:
+            data = data + struct.pack(&quot;!%us&quot; % data_len, self.__data)
+        return data
+        
+    def writeStr(self, str):
+        &quot;&quot;&quot; Write a sting into packet (still used ???) &quot;&quot;&quot;
+        if self.__data == None:
+            self.__data = str
+        else:
+            self.__data = self.__data + str
+        
+    def prepareSend(self):
+        &quot;&quot;&quot; Prepare the packet before it will be send : set timeout and send counter. &quot;&quot;&quot;
+        self.timeout = time.time()+Packet.timeout
+        self.sent = self.sent + 1
+
+    #-- Properties --------------------------------------------------------------
+
+    def getData(self): return self.__data
+    data = property(getData, doc=&quot;Packet data.&quot;)    
+
+

Added: happyboom/trunk/happyboom/net/io_tcp/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/net/io_tcp/server_waiter.py
===================================================================
--- happyboom/trunk/happyboom/net/io_tcp/server_waiter.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_tcp/server_waiter.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,125 @@
+import socket
+import thread
+import traceback
+from tcp_client import TCP_Client
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+
+class NetworkServerWaiter(object):
+    def __init__(self, server):
+        self.__server = server
+        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.__port = None
+        self.__host = ''
+        self.__max_clients = None
+        self.__nb_clients = 0
+        self.__nb_clients_sema = thread.allocate_lock()
+        self.__listening = False
+        self.__listening_sema = thread.allocate_lock()
+        self.__running = False
+
+    def isRunning(self):
+        return self.__running
+
+    def run_thread(self, port, max_connection):
+        try:
+            self.__running = True
+            self.start(port, max_connection)
+        except Exception, msg:
+            log.error(&quot;EXCEPTION IN TCP SERVER WAITER!\n%s\n%s&quot; \
+                % (msg, getBacktrace()))
+        self.__running = False 
+        
+    def clientConnect(self, client):
+        if self.__server.debug:
+            log.info(&quot;Client %s enter server %s.&quot; \
+                % (client.name, self.__server.name))
+        self.__nb_clients_sema.acquire()
+        self.__nb_clients = self.__nb_clients + 1
+        self.__nb_clients_sema.release()
+        self.__server.clientConnect (client)
+
+    def clientDisconnect(self, client):
+        if self.__server.debug: log.info(&quot;New client : %s&quot; % (client.getName()))
+        self.__nb_clients_sema.acquire()
+        self.__nb_clients = self.__nb_clients - 1
+        self.__nb_clients_sema.release()
+
+    def waitClient(self):
+        try:
+            (conn, addr) = self.__socket.accept()
+        except socket.error, err:
+            if err[0] == 11: # Resource temporarily unavailable
+                return None
+            raise
+        if self.__max_clients &lt;= self.getNbClients():
+            if self.__server.debug:
+                log.info( \
+                    &quot;Client %s refused on server %s (too many connection, %u/%u).&quot; \
+                    % (addr, self.__server.name, self.getNbClients(), self.__max_clients))
+            conn.close()
+            return None
+        return TCP_Client(self.__server, addr, socket=conn)
+
+    def start(self, port, max_connection):
+        self.__max_clients = max_connection
+        self.__port = port
+        if self.__server.debug: 
+            log.info(&quot;Start %s on port %u.&quot; \
+                % (self.__server.name, port))
+        self.__socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        try:
+            self.__socket.bind((self.__host, self.__port))
+            self.__socket.listen(max_connection)
+        except socket.error, err:
+            if self.__server.debug:
+                log.error(&quot;Binding error for %s.&quot; % (self.__server.name))
+            if self.__server.on_binding_error != None:
+                self.__server.on_binding_error (self.__server)
+            return
+        if self.__server.debug: 
+            log.info(&quot;Server %s is listening (max=%u clients).&quot; \
+                % (self.__server.name, max_connection))
+        self.__listening_sema.acquire()
+        self.__listening = True 
+        self.__listening_sema.release()
+
+        while 1:
+            try:
+                client = self.waitClient()
+                if client != None: self.clientConnect (client)
+                client = None
+
+            except socket.error, error:
+                # Connection reset by peer.
+                if error[0] == 104:
+                    if client != None: client.disconnect()
+                else:
+                    raise
+
+    def getNbClients(self):
+        self.__nb_clients_sema.acquire()
+        val = self.__nb_clients
+        self.__nb_clients_sema.release()
+        return val
+    nb_clients = property(getNbClients)
+    
+    def getMaxClients(self):
+        return self.__max_clients
+    max_clients = property(getMaxClients)
+        
+    def getListening(self):
+        self.__listening_sema.acquire()
+        listening = self.__listening
+        self.__listening_sema.release()
+        return listening
+    listening = property(getListening)
+
+    def getPort(self):
+        return self.__port
+    port = property(getPort)
+    
+    def getHost(self):
+        if self.__host == '': return 'localhost'
+        return self.__host
+    host = property(getHost)

Added: happyboom/trunk/happyboom/net/io_tcp/tcp.py
===================================================================
--- happyboom/trunk/happyboom/net/io_tcp/tcp.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_tcp/tcp.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,211 @@
+#!/usr/bin/python
+# -*- coding: ISO-8859-1 -*-
+
+from happyboom.net.io_tcp.tcp_client import TCP_Client
+from happyboom.net.io.packet import Packet
+from happyboom.net.io.base_io import BaseIO
+from server_waiter import NetworkServerWaiter
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+import time
+import thread
+import socket
+import traceback
+import struct
+
+class IO_TCP(BaseIO):
+    &quot;&quot;&quot;
+    IO for TCP transport.
+    @ivar packet_timeout: Timeout of packets (in seconds)
+    @type packet_timeout: C{float}
+    @ivar thread_sleep: Sleep time used in the thread (in seconds).
+    @type thread_sleep: C{float}
+    @ivar __is_server: ??? 
+    @type __is_server: C{bool}
+    @ivar __waiter: Class which wait for clients.
+    @type __waiter: NetworkServerWaiter
+    @ivar __addr: The IO network address (host, port).
+    @type __addr: C{(string, string,)}
+    @ivar __clients: List of clients connected to this IO.
+    @type __clients: C{list&lt;L{IO_client&lt;io.IO_Client&gt;}&gt;?}
+    @ivar __clients_sema: Semaphore used to access L{__clients}.
+    @type __clients_sema: C{thread.lock}
+    &quot;&quot;&quot;
+    
+    def __init__(self, is_server=False):
+        BaseIO.__init__(self)
+        self.packet_timeout = 1.000
+        self.thread_sleep = 0.010
+
+        self.__is_server = is_server
+
+        self.__waiter = NetworkServerWaiter(self)
+        self.__addr = None
+        self.__clients = {}
+        self.__server = None
+        self.__clients_sema = thread.allocate_lock()
+        Packet.use_tcp = True
+
+    def connect(self, host, port):
+        &quot;&quot;&quot; Connect to host:port &quot;&quot;&quot;
+        max_connection = 50
+    
+        self.__addr = (host, port,)
+        if self.__is_server:
+            if self.verbose:
+                log.info(&quot;Run server at %s:%u (tcp)&quot; % (self.host, self.port))
+            thread.start_new_thread( self.__waiter.run_thread, (port,max_connection,))
+        else:
+            if self.verbose:
+                log.info(&quot;Connect to server %s:%u&quot; % (self.host, self.port))
+            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            try:
+                s.connect(self.__addr)
+            except socket.error, err:
+                if err[0]==111:
+                    if self.verbose:
+                        log.warning(&quot;Fail to connect to server %s:%u&quot; % (self.host, self.port))
+                    if self.on_connection_fails:
+                        self.on_connection_fails()
+                    return
+                raise
+
+            client = TCP_Client(self, self.__addr, socket=s)
+            self.__server = client
+            self.__clients_sema.acquire()
+            self.__clients[client.addr] = client
+            self.__clients_sema.release()
+
+        BaseIO.connect(self, host, port)
+        if self.on_connect != None: self.on_connect()
+        self._is_ready = True
+
+    def disconnect(self):
+        &quot;&quot;&quot; Close connection &quot;&quot;&quot;
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        for client_addr, client in clients.items():
+            client.disconnect()
+        if self.on_disconnect != None: self.on_disconnect()
+        self.stop()
+
+    def disconnectClient(self, client):
+        &quot;&quot;&quot; Disconnect a client. &quot;&quot;&quot;
+        self.__clients_sema.acquire()
+        if  self.__clients.has_key(client.addr): del self.__clients[client.addr]
+        self.__clients_sema.release()
+        if self.verbose:
+            log.info(&quot;Disconnect client %s.&quot; % client)
+        if self.on_client_disconnect != None: self.on_client_disconnect (client)
+        if self.__server == client: self.disconnect()
+    
+    def send(self, packet, to=None):
+        &quot;&quot;&quot; Send a packet to the server or to all clients
+        @type packet: Packet
+        &quot;&quot;&quot;
+        if not self._running: return
+        
+        # Read binary version of the packet
+        data = packet.pack()
+
+        if self.__is_server:
+            if to==None:
+                self.__clients_sema.acquire()
+                clients = self.__clients.copy()
+                self.__clients_sema.release()    
+                for client in clients:
+                    client.sendBinary(data)
+            else:
+                to.sendBinary(data)
+        else:
+            self.__server.sendBinary(data)
+
+    def live(self):                
+        &quot;&quot;&quot; Keep the connection alive :
+        - Get clients new packets
+        - Process packets (eg. ping/pong)
+        &quot;&quot;&quot;
+        clients = self.clients
+        for client_addr, client in clients.items():
+            data = client.receiveNonBlocking()
+            if data != None:
+                self.__processData(client, data)
+
+    def __processData(self, client, data):
+        while data != &quot;&quot;:
+            packet = Packet()
+            packet.recv_from = client
+            data = packet.unpack(data)
+            if not packet.isValid():
+                if self.debug:
+                    log.warning(&quot;Received buggy network packet from %s!&quot; % client)
+                return
+            if self.debug:
+                log.info(&quot;Received %s:%u =&gt; \&quot;%s\&quot;&quot; % (client.host, client.port, packet.data))
+            if self.on_new_packet: self.on_new_packet(packet)
+    
+    def run_thread(self):
+        &quot;&quot;&quot; Function which should be called in a thread. &quot;&quot;&quot;
+        try:
+            while self._running:
+                self.live()                
+                time.sleep(self.thread_sleep)
+        except Exception, msg:
+            log.error( \
+                &quot;EXCEPTION DANS LE THREAD IO :\n%s\n%s&quot;
+                % (msg, getBacktrace()))
+        self.stop()
+
+    #--- Private functions ------------------------------------------------------
+
+    def __getPort(self):
+        if self.__addr==None: return &quot;(no port)&quot;
+        return self.__addr[1]
+
+    def __getHost(self):
+        if self.__addr==None: return &quot;(no hostname)&quot;
+        if self.__addr[0]=='': return &quot;localhost&quot;
+        return self.__addr[0]
+
+    def __getAddr(self): return self.__addr
+
+    def _getName(self):
+        if self._name != None: return self._name
+        if self.__addr != None: return self.host
+        return &quot;(no name)&quot;
+        
+    def __getClients(self):
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        return clients
+
+    def __getMaxClients(self):
+        return 0
+    
+    def clientConnect(self, client):
+        client.on_receive = self.on_receive
+        client.on_send = self.on_send
+        self.__clients_sema.acquire()
+        self.__clients[client.addr] = client
+        self.__clients_sema.release()
+        if self.on_client_connect != None: self.on_client_connect (client)
+        
+    def clientDisconnect(self, client):
+        if self.verbose:
+            log.info(&quot;Client %s leave server %s.&quot; % (client, self))
+        self.__clients_sema.acquire()
+        self.__clients.remove(client)
+        self.__clients_sema.release()
+        self.__waiter.client_disconnect(client)
+        if self.on_client_disconnect != None: self.on_client_disconnect (client)
+        
+    #--- Properties -------------------------------------------------------------
+
+    name = property(_getName, BaseIO._setName)
+    addr = property(__getAddr)
+    port = property(__getPort)
+    host = property(__getHost)
+    clients = property(__getClients)
+    max_clients = property(__getMaxClients)

Added: happyboom/trunk/happyboom/net/io_tcp/tcp_client.py
===================================================================
--- happyboom/trunk/happyboom/net/io_tcp/tcp_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_tcp/tcp_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,87 @@
+from happyboom.net.io.io_client import IO_Client
+from happyboom.common.log import log
+import socket
+
+class TCP_Client(IO_Client):
+    &quot;&quot;&quot; An TCP client.
+    @ivar __socket: The TCP socket
+    @type __socket: C{socket}
+    @ivar on_send: Event called when a packet is sent to the client.
+    @type on_send: C{function}
+    @ivar on_receive: Event called when a new packet is received.
+    @type on_receive: C{function}
+    &quot;&quot;&quot;
+    def __init__(self, io_tcp, addr, name=None, socket=None):
+        IO_Client.__init__(self, io_tcp, addr, name)
+        self.__socket = socket 
+        self.on_send = None
+        self.on_receive = None
+
+    def send(self, packet):
+        &quot;&quot;&quot; Send a packet to the client.
+        @type packet: Packet
+        &quot;&quot;&quot;
+        self.sendBinary( packet.pack() )
+    
+    def sendBinary(self, data):
+        &quot;&quot;&quot; Send binary datas to the client.
+        @type data: str
+        &quot;&quot;&quot;
+        if not self.connected: return
+        try:
+            self.__socket.send(data)
+        except SocketError, err:
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+
+    def receiveNonBlocking(self, max_size=1024):
+        &quot;&quot;&quot; Non blocking read on the socket. &quot;&quot;&quot;
+        if not self.connected: return
+        try:
+            self.__socket.setblocking(0)
+            data = self.__socket.recv(max_size)
+        except socket.error, err:
+            if err[0] == 11: return None
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+        return self.__processRecvData(data)
+
+    def receiveBlocking(self, max_size=1024):
+        &quot;&quot;&quot; Blocking read on the socket. &quot;&quot;&quot;
+        if not self.connected: return
+        try:
+            self.__socket.setblocking(1)
+            data = self.__socket.recv(max_size)
+        except socket.error, err:
+            # Broken pipe (32) or Connection reset by peer (104)
+            if err[0] in (32, 104,):
+                self.disconnect()
+                return None
+            raise
+        return self.__processRecvData(data)
+
+    def disconnect(self):
+        &quot;&quot;&quot; Disconned the client : close the socket. &quot;&quot;&quot;
+        self.__socket.close()
+        IO_Client.disconnect(self)
+
+    def __processRecvData(self, data):
+        # If no data, connection is lost
+        if len(data)==0:
+            if self.io.verbose:
+                log.warning(&quot;Client %s lost connection with server!&quot; % self)
+            self.disconnect()
+            return None
+
+        # Call user event if needed
+        if self.on_receive != None: self.on_receive(data)
+        return data

Added: happyboom/trunk/happyboom/net/io_udp/__init__.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/__init__.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/__init__.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1 @@
+from udp import IO_UDP

Added: happyboom/trunk/happyboom/net/io_udp/udp.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/udp.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/udp.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,363 @@
+# -*- coding: ISO-8859-1 -*-
+
+import time
+import thread
+import socket
+import traceback
+import struct
+from net.io.base_io import BaseIO
+from udp_client import UDP_Client
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+
+class IO_UDP(BaseIO):
+    &quot;&quot;&quot; IO for UDP transport.
+    @ivar packet_timeout: Try to send a packet until this timeout.
+    @type packet_timeout: C{float}
+    @ivar thread_sleep: Sleep time used in the thread.
+    @type thread_sleep: C{float}
+    @ivar __is_server: ??? 
+    @type __is_server: C{bool}
+    @ivar __server: The server (only used by clients, None else).
+    @type __server: ?
+    @ivar __running: Is the thread running ?
+    @type __running: C{bool}
+    @ivar __socket: The network socket.
+    @type __socket: C{socket}
+    @ivar __socket_open: Is the network socket L{__socket} opened ?
+    @type __socket_open: C{bool}
+    @ivar __addr: The IO network address (host, port).
+    @type __addr: C{(string, string,)}
+    @ivar __packet_id: ???
+    @type __packet_id: C{int}
+    @ivar __clients: List of clients connected to this IO.
+    @type __clients: C{list&lt;L{IO_client&lt;io.IO_Client&gt;}&gt;?}
+    @ivar __clients_sema: Lock used to access L{__clients}.
+    @type __clients_sema: C{thread.lock}
+    &quot;&quot;&quot;
+    
+    def __init__(self, is_server=False):
+        &quot;&quot;&quot; Constructor. &quot;&quot;&quot;
+        BaseIO.__init__(self)
+        self.packet_timeout = 1.000
+        self.thread_sleep = 0.010
+
+        self.__is_server = is_server
+        self.__server = None # only used in client mode
+        self.__running = True
+
+        self.__socket = None
+        self.__socket_open = False        
+        self.__addr = None
+        self.__packet_id = 0
+        self.__clients = {}
+        self.__clients_sema = thread.allocate_lock()
+
+    def connect(self, host, port):
+        &quot;&quot;&quot; Connect to host:port 
+        @type host: C{str}
+        @type port: C{int}
+        &quot;&quot;&quot;
+        if host != &quot;&quot;:
+            host = socket.gethostbyname(host)
+        else:
+            host = &quot;127.0.0.1&quot;
+        self.__addr = (host, port,)
+        self.__socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+        if self.__is_server:
+            if self.verbose:
+                log.info(&quot;Run server on port %u (udp).&quot; % self.port)
+            self.__socket.bind((&quot;&quot;,port,))
+        else:
+            if self.verbose:
+                log.info(&quot;Connect to server %s:%u.&quot; % (self.host, self.port))
+            self.__server = UDP_Client(self, self.__addr)
+            self.__server.name = &quot;server&quot;
+            self.__server.send_ping = True
+            self.__clients_sema.acquire()
+            self.__clients[self.__addr] = self.__server
+            self.__clients_sema.release()
+
+        self.__socket_open = True
+        self.__socket.setblocking(0)
+
+        if not self.__is_server:
+            self.send( io.Packet(&quot;I'm here&quot;) )
+        
+        BaseIO.connect(self, host, port)
+
+        # Call user event if needed
+        if self.on_connect != None: self.on_connect()
+
+    def disconnect(self):
+        &quot;&quot;&quot; Close connection. &quot;&quot;&quot;
+        if not self.__socket_open: return
+        self.__socket.close()
+        self.__socket_open = False
+        if self.on_disconnect != None: self.on_disconnect()
+        self.stop()
+
+    def disconnectClient(self, client):
+        &quot;&quot;&quot; Disconnect a client.
+        @type client: C{L{IO_Client&lt;io.IO_Client&gt;}}
+        &quot;&quot;&quot;
+        self.__clients_sema.acquire()
+        if self.__clients.has_key(client.addr): del self.__clients[client.addr]
+        self.__clients_sema.release()
+        if self.verbose:
+            log.info(&quot;Disconnect client %s.&quot; % client)
+        if self.on_client_disconnect != None: self.on_client_disconnect(client)
+    
+    def send(self, packet, to=None):
+        &quot;&quot;&quot; Send a packet to the server or to all clients.
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        @type to: C{L{IO_Client&lt;io.IO_Client&gt;}}
+        &quot;&quot;&quot;
+        if not self.__socket_open: return
+        first_send = (packet.sent == 0)
+        
+        # No client, exit !
+        if self.__is_server:
+            self.__clients_sema.acquire()
+            nb_clients = len(self.__clients)
+            self.__clients_sema.release()
+            if nb_clients==0: return None
+
+        # Prepare the packet
+        packet.prepareSend()
+        if first_send:
+            # First send : give an ID to the packet
+            self.__packet_id = self.__packet_id + 1
+            packet.id = self.__packet_id
+            if self.debug: packet.creation = time.time()
+        need_ack = first_send and not packet.skippable
+        
+        # Read binary version of the packet
+        data = packet.pack()
+
+        # Send data to client(s)
+        if self.__is_server:
+            if to==None:
+                for addr,client in self.clients.items(): # use internal copy for clients
+                    self.__sendDataTo(packet, data, client, need_ack)
+            else:
+                self.__sendDataTo(packet, data, to, need_ack)
+        else:
+            self.__sendDataTo(packet, data, self.__server, need_ack)
+        
+    def sendBinary(self, data, client):
+        &quot;&quot;&quot; Send binary data that doesn't need an acknoledge. 
+        @type data: C{str}
+        @type client: C{L{IO_Client&lt;io.IO_Client&gt;}}
+        &quot;&quot;&quot;        
+        if self.debug:
+            log.info(&quot;Send data %s to %s (without ack)&quot; % (data, client))
+        self.__socket.sendto(data, client.addr)    
+        
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+    
+    def __sendDataTo(self, packet, data, client, need_ack):
+        &quot;&quot;&quot; Send binary data with an acknoledge to a client.
+        @type data: C{str}
+        @type client: C{L{IO_Client&lt;io.IO_Client&gt;}}
+        @type need_ack: C{bool}
+        &quot;&quot;&quot;
+        if self.debug:
+            log.info(&quot;Send packet %s to %s&quot; % (packet.toStr(), client))
+        self.__socket.sendto(data, client.addr)
+
+        # If the packet need an ack, add it to the list
+        if need_ack: client.needAck(packet)
+        
+        # Call user event if needed
+        if self.on_send != None: self.on_send(data)
+    
+    def receive(self, max_size = 1024):
+        &quot;&quot;&quot; Read a packet from the socket.
+        Returns None if there is not new data.
+        @type max_size: C{int}
+        @rtype: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        if not self.__socket_open: return None
+
+        # Try to read data from the socket
+        try:                        
+            data,addr = self.__socket.recvfrom(max_size)
+        except socket.error, err:
+            if err[0] == 11: return None
+            raise
+    
+        # New client ?
+        return self.__processRecvData(data, addr)
+
+    def live(self):                
+        &quot;&quot;&quot; Keep the connection alive. &quot;&quot;&quot;
+        # Resend packets which don't have received their ack
+        for addr, client in self.clients.items(): # use internal copy for clients
+            client.live()                            
+                    
+        # Read data from network (if needed)
+        packet = self.receive()                
+        if packet != None: self.__processNewPacket(packet)
+                    
+
+    def clientLostConnection(self, client):
+        if self.__is_server:
+            self.__lostClient(client)
+        else:
+            self.lostConnection()
+
+    def __lostClient(self, client):
+        if not client.addr in self.__clients: return
+        client = self.__clients[client.addr]
+        if self.verbose:
+            log.warning(&quot;Lost connection with client %s !&quot; % client)
+        self.disconnectClient(client)
+    
+    def lostConnection(self):
+        if self.verbose:
+            log.warning(&quot;Lost connection to %s:%u!&quot; % (self.host, self.port))
+        if self.__socket_open:
+            self.__socket.close()
+            self.__socket_open = False
+        if self.on_lost_connection: self.on_lost_connection()
+        self.stop()
+    
+    def run_thread(self):
+        &quot;&quot;&quot; Function which should be called in a thread : call L{live()} with a sleep. &quot;&quot;&quot;
+        try:
+            while self.__running:
+                self.live()                
+                time.sleep(self.thread_sleep)
+        except Exception, msg:
+            log.error( \
+                &quot;EXCEPTION IN UDP SERVER:\n%s\n%s&quot; \
+                % (msg, getBacktrace()))
+            self.stop()
+
+    def stop(self):
+        if not self.__running: return
+        self.__running = False 
+        self.disconnect()
+
+    def isRunning(self): return self.__running
+
+    #--- Private functions ------------------------------------------------------
+
+    def __processRecvData(self, data, addr):
+        if self.__is_server:
+            self.__clients_sema.acquire()
+            if addr not in self.__clients:
+                client = UDP_Client(self, addr)
+                self.__clients[addr] = client
+                self.__clients_sema.release()
+                if self.verbose: log.info(&quot;New client: %s:%u.&quot; % (addr[0], addr[1]))
+                client.send_ping = True
+                if self.on_client_connect != None: self.on_client_connect(client)
+            else:
+                client = self.__clients[addr] 
+                self.__clients_sema.release()
+        else:
+            # Drop packets which doesn't come from server
+            if self.__server.addr != addr:
+                if self.debug:
+                    log.warning(&quot;Drop packet from %s:%u (it isn't the server address).&quot; % (addr[0], addr[1]))
+                return None
+            client = self.__server
+    
+        # Call user event if needed
+        if self.on_receive != None: self.on_receive(data)
+                    
+        # Decode data to normal packet (unpack) 
+        packet = io.Packet()
+        packet.unpack(data)
+        if not packet.isValid():
+            if self.debug:
+                log.warning(&quot;Drop invalid network packet from %s&quot; % (data, client))
+            return None
+        
+        # Return packet
+        packet.recv_from = client 
+        return self.__processPacket(packet)
+
+    def __processPacket(self, packet):
+        client = packet.recv_from
+
+        if self.debug:
+            log.info(&quot;Received packet %s from %s:%u&quot; % (packet.toStr(), client.host, client.port))
+        
+        # Send an ack if needed
+        if not packet.skippable: self.__sendAck(packet)
+        
+        # Is is a special packet (ack / ping / poing) ?
+        if packet.type == io.Packet.PACKET_ACK:
+            client.processAck(packet)
+            return None
+        if packet.type == io.Packet.PACKET_PING:
+            client.processPing(packet)
+            return None
+        if packet.type == io.Packet.PACKET_PONG:
+            client.processPong(packet)
+            return None
+            
+        # This packet is already received ? Drop it!
+        if client.alreadyReceived(packet.id):
+            if self.debug:
+                log.warning(&quot;Drop packet %u (already received)&quot; % packet.id)
+            return None    
+            
+        client.receivePacket(packet)
+        
+        # Returns the new packet
+        return packet
+
+    def __sendAck(self, packet):
+        &quot;&quot;&quot; Send an ack for a packet.
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        # Write ack to socket
+        ack = io.Packet(skippable=True)
+        ack.type = io.Packet.PACKET_ACK
+        ack.writeStr( struct.pack(&quot;!I&quot;, packet.id) )
+        #if self.debug: log.info(&quot;Send ACK %u.&quot; % ack.id)
+        packet.recv_from.send(ack)
+
+    def __processNewPacket(self, packet):
+        &quot;&quot;&quot; Do something with a new packet
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        if self.verbose:
+            log.info(&quot;New udp message : %s&quot; % packet.toStr())
+        if self.on_new_packet != None: self.on_new_packet(packet)        
+
+    def __getPort(self):
+        return self.__addr[1]
+
+    def __getHost(self):
+        if self.__addr[0]=='': return &quot;localhost&quot;
+        return self.__addr[0]
+
+    def __getAddr(self): return self.__addr
+
+    def _getName(self):
+        if self._name != None: return self._name
+        return self.host
+        
+    def __getClients(self):
+        self.__clients_sema.acquire()
+        clients = self.__clients.copy()
+        self.__clients_sema.release()
+        return clients
+
+    def __getMaxClients(self):
+        return 0
+        
+    #--- Properties -------------------------------------------------------------
+
+    name = property(_getName, BaseIO._setName, doc=&quot;The IO name&quot;)
+    addr = property(__getAddr, doc=&quot;The IO addresse (host, port).&quot;)
+    port = property(__getPort, doc=&quot;The network port number.&quot;)
+    host = property(__getHost, doc=&quot;The network hostname.&quot;)
+    clients = property(__getClients, doc=&quot;List of clients.&quot;)
+    max_clients = property(__getMaxClients, doc=&quot;Maximum number of clients connected to the server.&quot;)

Added: happyboom/trunk/happyboom/net/io_udp/udp_client.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/udp_client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/udp_client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,146 @@
+from net import io
+import thread
+import time
+import struct
+from happyboom.common.log import log
+from udp_ping import UDP_Pinger 
+
+class UDP_Client(io.IO_Client):
+    &quot;&quot;&quot; An UDP Client.
+    @ivar __waitAck: List of packets (id) which are waiting for an acknoledge.
+    @type __waitAck: C{dict&lt;int&gt;, L{Packet&lt;io.Packet&gt;}}
+    @ivar __waitAck_sema: Lock used to access L{__waitAck}.
+    @type __waitAck_sema: C{thread.lock}
+    @ivar __received: List of received packets (id). List used to remove duplicated packets.
+    @type __received: C{dict&lt;int, L{Packet&lt;io.Packet&gt;}&gt;}
+    @ivar __received_sema: Lock used to access L{__received}.
+    @type __received_sema: C{thread.lock}
+    @ivar __pinger: Send regulary ping to server.
+    @type __pinger: C{L{UDP_Pinger}}
+    &quot;&quot;&quot;
+    def __init__(self, io_udp, addr, name=None):
+        &quot;&quot;&quot; Constructor.
+        @parameter io_udp: Main IO.
+        @type io_udp: C{L{IO_UDP}}
+        @parameter addr: The client network address (host, port).
+        @type addr: C{(str, int)}
+        @parameter name: The client name.
+        @type name: C{str}
+        &quot;&quot;&quot;
+        io.IO_Client.__init__(self, io_udp, addr, name)
+        self.send_ping = False
+        self.__waitAck = {}
+        self.__received = {}
+        self.__waitAck_sema = thread.allocate_lock()
+        self.__received_sema = thread.allocate_lock()
+        self.__pinger = UDP_Pinger(self)
+
+    def alreadyReceived(self, id):
+        &quot;&quot;&quot; Tell if a packet (id) is already received.
+        @rtype: C{bool}
+        &quot;&quot;&quot;
+        self.__received_sema.acquire()
+        received = id in self.__received
+        self.__received_sema.release()
+        return received
+
+    def receivePacket(self, packet):
+        &quot;&quot;&quot; Process a new received packet.
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        if packet.skippable: return
+        
+        # Store packet to drop packet which are receive twice
+        timeout = time.time()+io.Packet.total_timeout
+        self.__received_sema.acquire()
+        self.__received[packet.id] = timeout 
+        self.__received_sema.release()    
+
+    def processPing(self, id):
+        &quot;&quot;&quot; Process a new received ping.
+        @type id: C{int}
+        &quot;&quot;&quot;
+        self.__pinger.processPing(id)
+        
+    def processPong(self, id):
+        &quot;&quot;&quot; Process a new received pong.
+        @type id: C{int}
+        &quot;&quot;&quot;
+        self.__pinger.processPong(id)
+        
+    def processAck(self, packet):
+        &quot;&quot;&quot; Process new received acknoledge.
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        # Read packet ID
+        format  = &quot;!I&quot;
+        if len(packet.data) != struct.calcsize(format): return None
+        data = struct.unpack(format, packet.data)
+        id = data[0]
+
+        # Packet still exists ?
+        self.__waitAck_sema.acquire()
+        if not self.__waitAck.has_key(id):
+            self.__waitAck_sema.release()
+            return
+
+        # Debug message
+        if self.io.debug:
+            t = time.time() - self.__waitAck[id].creation
+            log.info(&quot;Ack %u received (time=%.1f ms)&quot; % (id, t*1000))
+
+        # The packet don't need ack anymore
+        del self.__waitAck[id]
+        self.__waitAck_sema.release()
+
+    def disconnect(self):
+        &quot;&quot;&quot; Disconnect client. &quot;&quot;&quot;
+        self.io.disconnectClient(self)
+
+    def needAck(self, packet):
+        &quot;&quot;&quot; Tell that a packet needs an acknoledge. &quot;&quot;&quot;
+        self.__waitAck_sema.acquire()
+        self.__waitAck[packet.id] = packet
+        self.__waitAck_sema.release()
+
+    def live(self):
+        &quot;&quot;&quot; Keep the connection alive :
+        Resend packet if needed,
+        clean old received packets,
+        send ping if needed.
+        &quot;&quot;&quot;
+        
+        # Resend packet which don't have received their ack yet
+        self.__waitAck_sema.acquire()
+        waitAckCopy = self.__waitAck.copy()
+        self.__waitAck_sema.release()
+        for id,packet in waitAckCopy.items():
+            if packet.timeout &lt; time.time():
+                if packet.sent &lt; io.Packet.max_resend:
+                    self.send(packet)
+                else:
+                    self.io.clientLostConnection(self)
+
+        # Clean old received packets 
+        self.__received_sema.acquire()
+        receivedCopy = self.__received.copy()
+        self.__received_sema.release()
+        for id,timeout in receivedCopy.items():
+            if timeout &lt; time.time():
+                if self.io.debug:
+                    log.info(&quot;Remove old packet %u from %s:%u (clear cache).&quot; \
+                        % (id, self.host, self.port))
+                self.__received_sema.acquire()
+                del self.__received[id]
+                self.__received_sema.release()
+
+        # Send ping if needed
+        if self.send_ping: self.__pinger.live()
+
+    def send(self, packet):
+        &quot;&quot;&quot; Send packet to the client. &quot;&quot;&quot;
+        self.io.send(packet, to=self)
+        
+    def sendBinary(self, data):
+        &quot;&quot;&quot; Send binary datas the client. &quot;&quot;&quot;
+        self.io.sendBinary(data, self)

Added: happyboom/trunk/happyboom/net/io_udp/udp_ping.py
===================================================================
--- happyboom/trunk/happyboom/net/io_udp/udp_ping.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/io_udp/udp_ping.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,124 @@
+import time
+import struct
+from net import io
+from happyboom.common.log import log
+
+class UDP_Ping:
+    &quot;&quot;&quot; One UDP ping.
+    @ivar timeout: Ping timeout (in seconds).
+    @type timeout: C{float}
+    @ivar creation: Creation time.
+    @type creation: C{float}
+    @ivar id: Ping id.
+    @type id: C{int}
+    &quot;&quot;&quot;
+    timeout = 5.000
+    
+    def __init__(self, id):
+        &quot;&quot;&quot; Constuctor.
+        @type id: C{int}
+        &quot;&quot;&quot;
+        self.creation = time.time()
+        self.timeout = self.creation+UDP_Ping.timeout
+        self.id = id
+
+    def getPacket(self):
+        &quot;&quot;&quot; Create a network packet containing the ping. &quot;&quot;&quot;
+        ping = io.Packet()
+        ping.type = io.Packet.PACKET_PING
+        ping.writeStr( struct.pack(&quot;!I&quot;, self.id) )
+        return ping    
+
+class UDP_Pinger:
+    &quot;&quot;&quot; An UDP pinger (send ping and process pong).
+    @ivar ping_sleep: Sleep (in seconds) after sending one ping.
+    @type ping_sleep: C{float}
+    @ivar client: The UDP Client.
+    @type client: C{L{UDP_Client&lt;udp.UDP_Client&gt;}}
+    @ivar __sent_ping: List of sent pings (id,packet).
+    @type __sent_ping: C{dict&lt;int, L{UDP_Ping}&gt;}
+    @ivar __ping_id: Next ping id.
+    @type __ping_id: C{int}
+    @ivar __next_ping: Timer until next ping.
+    @type __next_ping: C{float}
+    &quot;&quot;&quot;
+
+    ping_sleep = 1.000
+    
+    def __init__(self, client):
+        &quot;&quot;&quot; Constructor.
+        @type client: C{L{UDP_Client&lt;udp.UDP_Client&gt;}}
+        &quot;&quot;&quot;
+        self.__next_ping = time.time()+UDP_Pinger.ping_sleep
+        self.__ping_id = 0
+        self.client = client
+        self.__sent_ping = {}
+
+    def processPong(self, id):
+        &quot;&quot;&quot; Process pong. &quot;&quot;&quot;
+        pass
+
+    def sendPing(self):
+        &quot;&quot;&quot; Send a new ping : create the packet and send it to the client. &quot;&quot;&quot;
+        self.__ping_id = self.__ping_id + 1
+        ping = UDP_Ping(self.__ping_id)
+        self.client.send( ping.getPacket() )
+        self.__sent_ping[ping.id] = ping
+                
+    def pingTimeout(self, id):
+        &quot;&quot;&quot; Function called when a ping timeout is raised.
+        @parameter id: The ping id.
+        @type id: C{int}
+        &quot;&quot;&quot;
+        log.error(&quot;UDP ping timeout.&quot;)
+#        log.error(&quot;Disconnect client %s:%u (ping timeout).&quot; \
+#            % (self.client.host, self.client.port))
+#        self.client.disconnect()
+
+    def live(self):
+        &quot;&quot;&quot; Remove old ping and send ping if needed. &quot;&quot;&quot;
+        
+        # Remove old ping
+        for id,ping in self.__sent_ping.items():
+            if ping.timeout &lt; time.time():
+                del self.__sent_ping[id]
+                self.pingTimeout(id)
+        
+        # Send ping if needed
+        if self.__next_ping &lt; time.time():
+            self.__next_ping = time.time()+UDP_Pinger.ping_sleep
+            self.sendPing()
+
+    def __getPingId(self, data):
+        &quot;&quot;&quot; Utility used to get an ping id from binary data.
+        @type data: C{str}
+        &quot;&quot;&quot;
+        format  = &quot;!I&quot;
+        if len(data) != struct.calcsize(format): return None
+        data = struct.unpack(format, data)
+        return data[0]
+
+    def processPing(self, packet):
+        &quot;&quot;&quot; Process ping : send pong.
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        pong = io.Packet(skippable=True)
+        pong.type = io.Packet.PACKET_PONG
+        pong.writeStr( packet.data )
+        self.client.send(pong)
+        
+    def processPong(self, packet):
+        &quot;&quot;&quot; Process pong.
+        @type packet: C{L{Packet&lt;io.Packet&gt;}}
+        &quot;&quot;&quot;
+        id = self.__getPingId(packet.data)
+        if id == None:
+            if self.debug:
+                log.warning(&quot;Received invalid udp ping packet!&quot;)
+            return
+
+        # Received too late ?
+        if not self.__sent_ping.has_key(id): return
+
+        # Remove ping from the list
+        del self.__sent_ping[id]

Added: happyboom/trunk/happyboom/net/net_buffer.py
===================================================================
--- happyboom/trunk/happyboom/net/net_buffer.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/net/net_buffer.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,59 @@
+import thread
+import time
+
+class NetBuffer:
+    &quot;&quot;&quot; Buffer used to store network packets. Support multithreading.
+    @ivar blocking_read_sleep : Sleep duration when waiting data from network.
+    @type blocking_read_sleep: C{float}
+    @ivar __buffer: Buffer which store network packets.
+    @type __buffer: C{list&lt;L{Packet&lt;io.Packet&gt;}&gt;}
+    &quot;&quot;&quot;
+    
+    def __init__(self):
+        &quot;&quot;&quot; Constructor. &quot;&quot;&quot;
+        self.blocking_read_sleep = 0.010
+        self.__buffer = {} 
+        self.__sema = thread.allocate_lock()
+
+    def clear(self, key):
+        &quot;&quot;&quot; Clear buffer. &quot;&quot;&quot;
+        self.__sema.acquire()
+        self.__buffer[key] = [] 
+        self.__sema.release()
+    
+    def append(self, key, data):
+        &quot;&quot;&quot; Append new data to the buffer. &quot;&quot;&quot;
+        self.__sema.acquire()
+        if self.__buffer.has_key(key):
+            self.__buffer[key].append(data)
+        else:
+            self.__buffer[key] = [data]
+        self.__sema.release()
+
+    def readNonBlocking(self, key):
+        &quot;&quot;&quot; Read one data. Returns None if their is no data.
+        @rtype: C{str}
+        &quot;&quot;&quot;
+        self.__sema.acquire()
+        buffer = self.__buffer.get(key, [])
+        self.__buffer[key] = []
+        self.__sema.release()
+        return buffer
+
+    def readBlocking(self, key, timeout):
+        &quot;&quot;&quot; Read one data.
+        Returns None if their is no data after the timeout.
+        @type timeout: C{float}
+        @rtype: C{str}
+        &quot;&quot;&quot;
+        data = None
+        timeout = time.time()+timeout
+        while data == None:
+            if timeout &lt; time.time(): break
+            self.__sema.acquire()
+            if self.__buffer.has_key(key) and len(self.__buffer[key]) != 0:
+                data = self.__buffer[key][0]
+                del self.__buffer[key][0] 
+            self.__sema.release()
+            if data == None: time.sleep(self.blocking_read_sleep)
+        return data

Added: happyboom/trunk/happyboom/release.sh
===================================================================
--- happyboom/trunk/happyboom/release.sh	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/release.sh	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,22 @@
+#!/bin/sh
+PKG=&quot;happyboom&quot;
+VERSION=&quot;0.1.4&quot;
+FILES=&quot;AUTHORS ChangeLog README COPYING&quot;
+OUT=&quot;$PKG-$VERSION.tar.bz2&quot;
+TMP_DIR=&quot;$PKG-$VERSION&quot;
+
+rm -rf $TMP_DIR
+mkdir $TMP_DIR
+
+for i in $(find . -name &quot;*.py&quot; -o -name &quot;*.sh&quot;; echo $FILES); do
+	FILE=$(echo $i | sed -e 's!\./!!')
+	SUBDIR=$(dirname &quot;$TMP_DIR/$FILE&quot;)
+	test -d &quot;$SUBDIR&quot; || mkdir -p $SUBDIR
+	ln $PWD/$FILE $TMP_DIR/$FILE
+done
+
+echo &quot;Creating archive $OUT ..&quot;
+tar --create  --bzip --dereference --file $OUT $TMP_DIR	
+rm -rf $TMP_DIR
+
+echo &quot;Done.&quot;


Property changes on: happyboom/trunk/happyboom/release.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happyboom/run.sh
===================================================================
--- happyboom/trunk/happyboom/run.sh	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/run.sh	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,5 @@
+#!/bin/sh
+xterm -e &quot;cd $PWD; python console_server.py&quot; &amp;
+sleep 1
+xterm -e &quot;cd $PWD; python console_view.py&quot; &amp;
+xterm -e &quot;cd $PWD; python console_input.py&quot; &amp;


Property changes on: happyboom/trunk/happyboom/run.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: happyboom/trunk/happyboom/server/__init__.py
===================================================================

Added: happyboom/trunk/happyboom/server/agent.py
===================================================================
--- happyboom/trunk/happyboom/server/agent.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/agent.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,39 @@
+from pysma import ActionAgent, ActionMessage as Message
+from happyboom.common.log import log
+from happyboom.common.event import EventLauncher, EventListener
+
+class Agent(ActionAgent, EventLauncher, EventListener):
+    &quot;&quot;&quot;
+    SMA agent in HappyBoom.
+    &quot;&quot;&quot;
+    def __init__(self, type, gateway, **args):
+        EventLauncher.__init__(self)
+        EventListener.__init__(self)
+        ActionAgent.__init__(self, prefix=&quot;msg_&quot;)
+        self._gateway = gateway
+        self.type = type
+        self.__debug = args.get(&quot;debug&quot;, False)
+        self.sendBroadcast = self.sendBroadcastMessage
+
+    def netCreateItem(self, client):
+        if self.type in client.features:
+            self.launchEvent(&quot;happyboom&quot;, &quot;netCreateItem&quot;, client, self)
+        elif self.__debug:
+            log.info(&quot;Client %s doesn't want item %s&quot; % (client, self.type))
+
+    def born(self):
+        self.requestRole(self.type)
+
+    def requestActions(self, type):
+        self.requestRole(&quot;%s_listener&quot; %type)
+        
+    def send(self, action, *arg, **kw):
+        message = Message(&quot;%s_%s&quot; %(self.type, action), arg, kw)
+        self.sendBroadcastMessage(message, &quot;%s_listener&quot; %self.type)
+
+    def sendNetMsg(self, func, event, *args):
+        self.launchEvent(&quot;happyboom&quot;, &quot;network&quot;, func, event, *args)
+
+    def messageReceived(self, msg):
+        if self.__debug:
+            log.warning(&quot;Unhandled message : %s -- %s&quot; %(type(self), msg))

Added: happyboom/trunk/happyboom/server/base_server.py
===================================================================
--- happyboom/trunk/happyboom/server/base_server.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/base_server.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,52 @@
+# TODO: Check if it's always possible to send skippable packets
+
+from happyboom.common.log import log
+from happyboom.server.gateway import Gateway
+from happyboom.server.client_manager import ClientManager
+import random, thread, time
+
+class Server(object):
+    def __init__(self, gateway, client_manager, arg): #verbose=False, debug=False):
+        self.started = False
+        self.__debug = arg.get('debug', False)
+        self.__verbose = arg.get('verbose', False)
+        self.__stopped = False
+        self.__stoplock = thread.allocate_lock()
+        self.__gateway = gateway 
+        self.__client_manager = client_manager
+        self.__gateway.server = self
+        self.__gateway.client_manager.server = self
+        random.seed()
+        self.__items = []
+        
+    def born(self):
+        self.gateway.born()
+        
+    def start(self):
+        if self.__verbose: log.info(&quot;[*] Starting server...&quot;)
+        self.__gateway.start()
+        self.__client_manager.start()
+        log.info(&quot;[*] Server started&quot;)
+        
+        self.__stoplock.acquire()
+        running = not self.__stopped
+        self.__stoplock.release()
+        while running:
+            self.__gateway.process()
+            self.__client_manager.process()
+            time.sleep(0.01)
+            self.__stoplock.acquire()
+            running = not self.__stopped
+            self.__stoplock.release()
+
+    def stop(self):
+        self.__stoplock.acquire()
+        if self.__stopped:
+            self.__stoplock.release()
+            return
+        self.__stopped = True
+        self.__stoplock.release()
+        if self.__verbose: log.info(&quot;[*] Stopping server...&quot;)
+        self.__client_manager.stop()
+        self.__gateway.stop()
+        log.info(&quot;[*] Server stopped&quot;)

Added: happyboom/trunk/happyboom/server/client.py
===================================================================
--- happyboom/trunk/happyboom/server/client.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/client.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,45 @@
+from happyboom.common.protocol import ProtocolException
+from happyboom.common.log import log
+
+class Client(object):
+    &quot;&quot;&quot;
+    High-level class for a client in the server.
+    &quot;&quot;&quot;
+
+    def __init__(self, io_client, gateway, client_manager):
+        self.io = io_client
+        self.__client_manager = client_manager
+        self.__gateway = gateway
+        self.signature = None
+        self.features = [] 
+
+    def __str__(self):
+        return self.io.__str__()
+
+    def disconnect(self, reason):
+        self.launchEvent(&quot;happyboom&quot;, &quot;clientDisconnect&quot;, self.io, reason)
+
+    # Stop client: close socket.
+    def stop(self):
+        self.io.disconnect()
+
+    # Read a message from network stack
+    # Blocking function, returns None after timeout seconds (no data)
+    def read(self, timeout):
+        return self.__client_manager.readClientAnswer(self.io, timeout)
+
+    # Send a network packet the the client socket
+    def sendPacket(self, packet):
+        self.io.send(packet)
+
+    # Send a HappyBoom message to the client (see L{sendPacket})
+    def sendNetMsg(self, feature, event, *args):
+        try:
+            data = self.__protocol.createMsg(feature, event, *args)
+        except ProtocolException, err:
+            log.error(err)
+            return
+        self.launchEvent(&quot;happyboom&quot;, &quot;event&quot;, (self,), data);
+
+    def __getAddr(self): return self.io.addr
+    addr = property(__getAddr)

Added: happyboom/trunk/happyboom/server/client_manager.py
===================================================================
--- happyboom/trunk/happyboom/server/client_manager.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/client_manager.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,152 @@
+Pfrom happyboom.net.io_tcp.tcp import IO_TCP
+from happyboom.common.packer import unpackBin
+from happyboom.common.log import log
+from happyboom.common.thread import getBacktrace
+from happyboom.server.client import Client
+from happyboom.common.event import EventLauncher
+import thread, time
+
+class ClientManager(EventLauncher, object):
+    def __init__(self, protocol, arg): 
+        EventLauncher.__init__(self)
+        self.server = None 
+        self.__protocol = protocol
+        self.__io = IO_TCP(is_server=True)
+        self.__io.debug = arg.get(&quot;debug&quot;, False)
+        self.__io.verbose = arg.get(&quot;verbose&quot;, False)
+        self.__debug = arg.get(&quot;debug&quot;, False)
+        self.__verbose = arg.get(&quot;verbose&quot;, False)
+        self.max_clients = arg.get(&quot;max_clients&quot;, 2)
+        self.client_port = arg.get(&quot;client_port&quot;, 12430)
+        self.__supported_features = {}
+        self.__clients = {}
+        self.__clients_lock = thread.allocate_lock()
+        self.gateway = None
+        self.presentation = None
+
+    def onClientDisconnection(self, ioclient, reason):
+        log.info(&quot;Client %s leave us: %s&quot; % (ioclient, reason))
+        self.closeClient(ioclient)
+
+    def onClientConnection(self, ioclient, version, signature):
+        # TODO: Case where signature != &quot;&quot; ??? (reconnection)
+        if self.__verbose: log.info(&quot;Client %s try to connect : check version.&quot; % ioclient)
+        server_version = self.__protocol.version
+        if version == server_version:
+            if self.__verbose: log.info(&quot;Client %s try to connect: version ok.&quot; % ioclient)
+            signature = self.generateSignature(ioclient)
+            self.launchEvent(&quot;happyboom&quot;, &quot;connection&quot;, ioclient, server_version, signature)
+        else:    
+            if self.__verbose: log.warning(&quot;Client %s try to connect: wrong version (%s).&quot; % version)
+            self.launchEvent(&quot;happyboom&quot;, &quot;closeConnection&quot;, ioclient, u&quot;Wrong server version (%s VS %s)&quot; % (version, serveur_version))
+
+    def onClientFeatures(self, ioclient, features):
+        # Register client in the clients list
+        client = Client(ioclient, self.gateway, self)
+        self.__clients_lock.acquire() 
+        self.__clients[client.addr] = client
+        self.__clients_lock.release() 
+
+        # Register client to features
+        for feature in features:
+            f = self.__protocol[ord(feature)]
+            feature = f.name
+            if self.__verbose: log.info(&quot;Register feature %s for client %s&quot; % (feature, client))
+            if feature in self.__supported_features:
+                self.__supported_features[feature].append(ioclient)
+            else:
+                self.__supported_features[feature] = [ioclient]
+            client.features.append(feature)
+      
+        # Send message to network and to the log
+        txt = u&quot;Welcome to new (display) client : %s&quot; % client
+        log.info(&quot;[*] Client %s connected&quot; % client)
+        self.launchEvent(&quot;happyboom&quot;, &quot;network&quot;, &quot;info&quot;, &quot;notice&quot;, txt)
+        self.launchEvent(&quot;happyboom&quot;, &quot;newClient&quot;, client)
+
+    def stop(self):
+        for client in self.__clients.values():
+            client.stop()
+
+    def process(self):
+        if not self.__io.isRunning():
+            self.server.stop()
+
+    def start(self):
+        if self.__verbose: log.info(&quot;[*] Starting server&quot;)
+        self.__io.name = &quot;server&quot;
+        self.__io.on_client_connect = self.openClient
+        self.__io.on_client_disconnect = self.closeClient
+        self.__io.on_new_packet = self.presentation.processPacket
+        self.__io.connect('', self.client_port)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;connection&quot;, self.onClientConnection)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;disconnection&quot;, self.onClientDisconnection)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;features&quot;, self.onClientFeatures)
+        thread.start_new_thread(self.run_io_thread, ())
+
+    def registerFeature(self, client, role):
+        if role in self.__supported_features:
+            if client not in self.__supported_features[role]:
+                self.__supported_features[role].append(client)
+        else:
+            self.__supported_features[role] = [client,]
+        
+    def openClient(self, ioclient):
+        if self.__verbose: log.info(&quot;[*] Client %s try to connect ...&quot; % ioclient)
+
+    def removeClient(self, ioclient):
+        if self.__verbose: log.info(&quot;Disconnect client %s.&quot; % ioclient)
+        self.gateway.sendText(u&quot;Client %s leave us.&quot; % ioclient)
+
+        self.__clients_lock.acquire() 
+        del self.__clients[ioclient.addr]
+        self.__clients_lock.release() 
+    
+    def closeClient(self, ioclient):
+        # TODO: get client of type Client for the client of type ClientIO to send
+        # him bye
+#        client.sendNetMsg(&quot;presentation&quot;, &quot;bye&quot;, &quot;utf8&quot;, u&quot;Lost connection&quot;)
+        client = self.getClientByAddr(ioclient.addr)
+        if client == None: return
+        log.info(&quot;[*] Client %s leave us.&quot; % client)
+        self.removeClient(client.io)
+        
+    def __clientChallenge(self, client, func):
+        try:
+            func(client)
+        except Exception, msg:
+            log.error( \
+                &quot;EXCEPTION WHEN A CLIENT TRY TO CONNECT :\n%s\n%s&quot; \
+                % (msg, getBacktrace()))
+            self.stop()
+
+    # Function which should be called in a thread
+    # TODO: Why is this used?
+    def run_io_thread(self):
+        try:
+            while self.__io.isRunning():
+                self.__io.live()                
+                time.sleep(0.001)
+        except Exception, msg:
+            log.error( \
+                &quot;EXCEPTION IN IO THREAD :\n%s\n%s&quot; \
+                % (msg, getBacktrace()))
+            self.server.stop()
+
+    def generateSignature(self, ioclient):
+        import random
+        r1 = random.randint(0,1000000)
+        r2 = random.randint(0,1000000)
+        return &quot;%s%s%s&quot; % (r1,ioclient.addr,r2)
+
+    def getClientByAddr(self, addr):
+        &quot;&quot;&quot; Returns None if no client matchs. &quot;&quot;&quot;
+        self.__clients_lock.acquire() 
+        client = self.__clients.get(addr, None)
+        self.__clients_lock.release() 
+        return client
+        
+    def __getSupportedFeatures(self): return self.__supported_features
+    supported_features = property(__getSupportedFeatures)
+
+

Added: happyboom/trunk/happyboom/server/gateway.py
===================================================================
--- happyboom/trunk/happyboom/server/gateway.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/gateway.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,83 @@
+from happyboom.server.agent import Agent, Message
+from happyboom.common.protocol import loadProtocol, ProtocolException
+from happyboom.net.io import Packet
+from happyboom.common.log import log
+from pysma import Kernel, DummyScheduler
+from happyboom.common.event import EventListener
+import struct
+
+class Gateway(Agent, EventListener):
+    def __init__(self, protocol, presentation, client_manager, arg):
+        EventListener.__init__(self, &quot;evt_&quot;)
+        Agent.__init__(self, self, &quot;gateway&quot;)
+        self.__protocol = protocol
+        self.client_manager = client_manager
+        self.presentation = presentation
+        self.presentation.gateway = self 
+        self.presentation.client_manager = self.client_manager
+        self.client_manager.presentation = self.presentation
+        self.__server = None 
+        self._debug = arg.get(&quot;debug&quot;, False)
+        self._verbose = arg.get(&quot;verbose&quot;, False)
+        self.__scheduler = DummyScheduler(sleep=0.01)
+        self.registerEvent(&quot;happyboom&quot;)
+        Kernel().addAgent(self.__scheduler)
+
+    def eventPerformed(self, event):
+        p = self.pattern % self.getEventName(event.type, event.event)
+
+    def __setServer(self, server):
+        self.__server = server
+        self.client_manager.server = server
+    server = property(None, __setServer)
+
+#    def eventPerformed(self, event):
+#        print &quot;gzzz&quot;, event
+
+    def evt_happyboom_network(self, feature, event, *args):
+        self.sendNetMsg(feature, event, *args)
+        
+    def evt_happyboom_netCreateItem(self, client, item):
+        try:
+            type = item.type
+            type = self.presentation.protocol.getFeature(type)
+            type = type.id
+        except ProtocolException, err:
+            log.error(err)
+            return
+        self.launchEvent(&quot;happyboom&quot;, &quot;create&quot;, client.io, type, item.id);
+        
+    def start(self):
+        Kernel.instance.addAgent(self)
+        self.launchEvent(&quot;happyboom&quot;, &quot;register&quot;, &quot;recv_event&quot;, self.recvNetMsg)
+        
+    def stop(self):
+        self.sendNetMsg(&quot;game&quot;, &quot;stop&quot;)
+        Kernel.instance.stopKernel()
+
+    def process(self):
+        # Stop server if the scheduler is dead
+#       TODO: Waiting for last PySMA version...        
+#        if not self.__scheduler.alive:
+#            self.__server.stop()
+        pass
+
+    def sendText(self, txt, client=None):
+        if client != None:
+            client.sendMsg(&quot;chat&quot;, &quot;message&quot;, txt)
+        else:
+            self.sendNetMsg(&quot;chat&quot;, &quot;message&quot;, txt)
+
+    def recvNetMsg(self, ioclient, feature, event, args):
+        if self._verbose: log.info(&quot;Received: %s.%s%s&quot; % (feature, event, args))
+        message = Message(&quot;%s_%s&quot; % (feature, event), args)
+        self.sendBroadcastMessage(message, &quot;%s_listener&quot; % feature)
+
+    def evt_happyboom_newClient(self, client):
+        self.launchEvent(&quot;gateway&quot;, &quot;syncClientCreate&quot;, client)
+        self.launchEvent(&quot;gateway&quot;, &quot;syncClient&quot;, client)
+
+    def sendNetMsg(self, feature, event, *args):
+        clients = self.client_manager.supported_features.get(feature, ())
+        if len(clients)==0: return
+        self.launchEvent(&quot;happyboom&quot;, &quot;event&quot;, clients, feature, event, args);

Added: happyboom/trunk/happyboom/server/server_agent.py
===================================================================
--- happyboom/trunk/happyboom/server/server_agent.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/server_agent.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,14 @@
+from agent import *
+
+class ServerAgent(Agent):
+    def __init__(self, type):
+        Agent.__init__(self)
+        self.type = type
+        self.id = -1 
+        self.server = None
+
+    def sendMsg(self, role, type, arg=None, client=None, skippable=False):
+        if client != None:
+            self.server.sendMsgToClient(client, role, type, arg, skippable=skippable)
+        else:
+            self.server.sendMsg(role, type, arg, skippable=skippable)

Added: happyboom/trunk/happyboom/server/stat.py
===================================================================
--- happyboom/trunk/happyboom/server/stat.py	2005-09-19 20:09:06 UTC (rev 208)
+++ happyboom/trunk/happyboom/server/stat.py	2005-09-19 20:14:42 UTC (rev 209)
@@ -0,0 +1,91 @@
+import time
+import server_agent 
+
+class ServerStat:
+    def __init__(self, server):
+        self.started = time.time()
+        self.server = server
+        self.net_in = 0
+        self.net_out = 0
+
+    # Event called on new sent/read data from network
+    def onNetSend(self, data):
+        self.net_out = self.net_out + len(data)
+    def onNetReceive(self, data):
+        self.net_in = self.net_in + len(data)
+
+    # Number of seconds since server started
+    def getUptime(self):
+        return int( time.time() - self.started )
+
+    # Current/Maximum number of view/input clients
+    def getNbInputs(self):
+        return self.server.getNbInput()
+    def getNbViews(self):
+        return self.server.getNbView()
+    def getMaxViews(self):
+        return self.server.getMaxNbView()
+    def getMaxInputs(self):
+        return self.server.getMaxNbInput()
+
+class ServerStatAgent(server_agent.ServerAgent):
+    def __init__(self):
+        server_agent.ServerAgent.__init__(self, &quot;server_stat&quot;)
+        self.uptime = None
+        self.nb_view = None
+        self.nb_input = None
+        self.net_in = None
+        self.net_out = None
+        self.max_views = None
+        self.max_inputs = None
+        self.net_time = time.time()
+        self.net_time_update = 1.0
+
+    def sync(self, client=None):
+        if self.uptime != None:
+            self.sendMsg(&quot;server_stat&quot;, &quot;Uptime&quot;, &quot;%u&quot; % self.uptime, client)
+        if self.max_views != None:
+            self.sendMsg(&quot;server_stat&quot;, &quot;MaxViews&quot;, &quot;%u&quot; % self.max_views, client)
+        if self.max_inputs != None:
+            self.sendMsg(&quot;server_stat&quot;, &quot;MaxInputs&quot;, &quot;%u&quot; % self.max_inputs, client)
+        if self.nb_input != None:
+            self.sendMsg(&quot;server_stat&quot;, &quot;NbInput&quot;, &quot;%u&quot; % self.nb_input, client)
+        if self.nb_view != None:
+            self.sendMsg(&quot;server_stat&quot;, &quot;NbView&quot;, &quot;%u&quot; % self.nb_view, client)
+        if (self.net_in != None) and (self.net_out != None):
+            self.sendMsg(&quot;server_stat&quot;, &quot;NetStat&quot;, &quot;%u,%u&quot; % (self.net_in, self.net_out), client)
+    
+    def update(self):
+        if self.server.stat == None: return
+        
+        if self.max_views == None:
+            self.max_views = self.server.stat.getMaxViews()
+        
+        if self.max_inputs == None:
+            self.max_inputs = self.server.stat.getMaxInputs()
+        
+        if self.net_time_update &lt; time.time() - self.net_time:
+            self.net_time = time.time()
+            if (self.server.stat.net_in != self.net_in) \
+            or (self.server.stat.net_out != self.net_out):
+                self.net_in = self.server.stat.net_in
+                self.net_out = self.server.stat.net_out
+                self.sendMsg(&quot;server_stat&quot;, &quot;NetStat&quot;, &quot;%u,%u&quot; % (self.net_in, self.net_out,))
+        
+        input = self.server.stat.getNbInputs()
+        if input != self.nb_input:
+            self.nb_input = input
+            self.sendMsg(&quot;server_stat&quot;, &quot;NbInput&quot;, &quot;%u&quot; % self.nb_input)
+        
+        view = self.server.stat.getNbViews()
+        if view != self.nb_view:
+            self.nb_view = view
+            self.sendMsg(&quot;server_stat&quot;, &quot;NbView&quot;, &quot;%u&quot; % self.nb_view)
+
+        uptime = self.server.stat.getUptime()
+        if uptime != self.uptime:
+            self.uptime = uptime
+            self.sendMsg(&quot;server_stat&quot;, &quot;Uptime&quot;, &quot;%u&quot; % self.uptime)            
+
+    def live(self):
+        self.update()

Added: happyboom/trunk/happyboom/specification/client.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/happyboom/specification/client.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: happyboom/trunk/happyboom/specification/server.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/happyboom/specification/server.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: happyboom/trunk/happyboom/specification/socket_at_server_side.dia
===================================================================
(Binary files differ)


Property changes on: happyboom/trunk/happyboom/specification/socket_at_server_side.dia
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000115.html">[Happyboom-svn] r208 - happyboom/trunk
</A></li>
	<LI>Next message: <A HREF="000116.html">[Happyboom-svn] r210 - in happyboom/trunk: . common
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#122">[ date ]</a>
              <a href="thread.html#122">[ thread ]</a>
              <a href="subject.html#122">[ subject ]</a>
              <a href="author.html#122">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/happyboom-svn">More information about the Happyboom-svn
mailing list</a><br>
</body></html>
